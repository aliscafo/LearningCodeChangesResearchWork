1854
#method_before
public static void display(final String token) {
    if (body.getView() == null || !body.getView().displayToken(token)) {
        dispatcher.display(token);
    }
}
#method_after
public static void display(final String token) {
    if (body.getView() == null || !body.getView().displayToken(token)) {
        dispatcher.display(token);
        updateUiLink(token);
    }
}
#end_block

#method_before
public static void display(final String token, final Screen view) {
    if (view.isRequiresSignIn() && !isSignedIn()) {
        doSignIn(token);
    } else {
        view.setToken(token);
        if (isSignedIn()) {
            LocalComments.saveInlineComments();
        }
        body.setView(view);
    }
}
#method_after
public static void display(final String token, final Screen view) {
    if (view.isRequiresSignIn() && !isSignedIn()) {
        doSignIn(token);
    } else {
        view.setToken(token);
        if (isSignedIn()) {
            LocalComments.saveInlineComments();
        }
        body.setView(view);
        updateUiLink(token);
    }
}
#end_block

#method_before
private static void populateBottomMenu(RootPanel btmmenu, HostPageData hpd) {
    String vs = hpd.version;
    if (vs == null || vs.isEmpty()) {
        vs = "dev";
    }
    btmmenu.add(new InlineHTML(M.poweredBy(vs)));
    if (info().gerrit().webUis().contains(UiType.POLYGERRIT)) {
        btmmenu.add(new InlineLabel(" | "));
        Anchor a = new Anchor(C.polyGerrit(), History.getToken() + "?polygerrit=1");
        a.setStyleName("");
        btmmenu.add(a);
    }
    String reportBugUrl = info().gerrit().reportBugUrl();
    if (reportBugUrl != null) {
        String reportBugText = info().gerrit().reportBugText();
        Anchor a = new Anchor(reportBugText == null ? C.reportBug() : reportBugText, reportBugUrl);
        a.setTarget("_blank");
        a.setStyleName("");
        btmmenu.add(new InlineLabel(" | "));
        btmmenu.add(a);
    }
    btmmenu.add(new InlineLabel(" | "));
    btmmenu.add(new InlineLabel(C.keyHelp()));
}
#method_after
private static void populateBottomMenu(RootPanel btmmenu, HostPageData hpd) {
    String vs = hpd.version;
    if (vs == null || vs.isEmpty()) {
        vs = "dev";
    }
    btmmenu.add(new InlineHTML(M.poweredBy(vs)));
    if (info().gerrit().webUis().contains(UiType.POLYGERRIT)) {
        btmmenu.add(new InlineLabel(" | "));
        uiSwitcherLink = new Anchor(C.newUi(), getUiSwitcherUrl(History.getToken()));
        uiSwitcherLink.setStyleName("");
        btmmenu.add(uiSwitcherLink);
    }
    String reportBugUrl = info().gerrit().reportBugUrl();
    if (reportBugUrl != null) {
        String reportBugText = info().gerrit().reportBugText();
        Anchor a = new Anchor(reportBugText == null ? C.reportBug() : reportBugText, reportBugUrl);
        a.setTarget("_blank");
        a.setStyleName("");
        btmmenu.add(new InlineLabel(" | "));
        btmmenu.add(a);
    }
    btmmenu.add(new InlineLabel(" | "));
    btmmenu.add(new InlineLabel(C.keyHelp()));
}
#end_block

#method_before
public void deleteVote(boolean onRevisionLevel) throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.approve());
    PushOneCommit.Result r2 = amendChange(r.getChangeId());
    setApiUser(user);
    recommend(r.getChangeId());
    sender.clear();
    String endPoint = "/changes/" + r.getChangeId() + (onRevisionLevel ? ("/revisions/" + r2.getCommit().getName()) : "") + "/reviewers/" + user.getId().toString() + "/votes/Code-Review";
    RestResponse response = adminRestSession.delete(endPoint);
    response.assertNoContent();
    List<FakeEmailSender.Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    FakeEmailSender.Message msg = messages.get(0);
    assertThat(msg.rcpt()).containsExactly(user.emailAddress);
    assertThat(msg.body()).contains(admin.fullName + " has removed a vote on this change.\n");
    assertThat(msg.body()).contains("Removed Code-Review+1 by " + user.fullName + " <" + user.email + ">" + "\n");
    endPoint = "/changes/" + r.getChangeId() + (onRevisionLevel ? ("/revisions/" + r2.getCommit().getName()) : "") + "/reviewers/" + user.getId().toString() + "/votes";
    response = adminRestSession.get(endPoint);
    response.assertOK();
    Map<String, Short> m = newGson().fromJson(response.getReader(), new TypeToken<Map<String, Short>>() {
    }.getType());
    assertThat(m).containsExactly("Code-Review", Short.valueOf((short) 0));
    ChangeInfo c = gApi.changes().id(r.getChangeId()).get();
    ChangeMessageInfo message = Iterables.getLast(c.messages);
    assertThat(message.author._accountId).isEqualTo(admin.getId().get());
    assertThat(message.message).isEqualTo("Removed Code-Review+1 by User <user@example.com>\n");
    assertThat(getReviewers(c.reviewers.get(REVIEWER))).containsExactlyElementsIn(ImmutableSet.of(admin.getId(), user.getId()));
}
#method_after
private void deleteVote(boolean onRevisionLevel) throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.approve());
    PushOneCommit.Result r2 = amendChange(r.getChangeId());
    setApiUser(user);
    recommend(r.getChangeId());
    sender.clear();
    String endPoint = "/changes/" + r.getChangeId() + (onRevisionLevel ? ("/revisions/" + r2.getCommit().getName()) : "") + "/reviewers/" + user.getId().toString() + "/votes/Code-Review";
    RestResponse response = adminRestSession.delete(endPoint);
    response.assertNoContent();
    List<FakeEmailSender.Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    FakeEmailSender.Message msg = messages.get(0);
    assertThat(msg.rcpt()).containsExactly(user.emailAddress);
    assertThat(msg.body()).contains(admin.fullName + " has removed a vote on this change.\n");
    assertThat(msg.body()).contains("Removed Code-Review+1 by " + user.fullName + " <" + user.email + ">" + "\n");
    endPoint = "/changes/" + r.getChangeId() + (onRevisionLevel ? ("/revisions/" + r2.getCommit().getName()) : "") + "/reviewers/" + user.getId().toString() + "/votes";
    response = adminRestSession.get(endPoint);
    response.assertOK();
    Map<String, Short> m = newGson().fromJson(response.getReader(), new TypeToken<Map<String, Short>>() {
    }.getType());
    assertThat(m).containsExactly("Code-Review", Short.valueOf((short) 0));
    ChangeInfo c = gApi.changes().id(r.getChangeId()).get();
    ChangeMessageInfo message = Iterables.getLast(c.messages);
    assertThat(message.author._accountId).isEqualTo(admin.getId().get());
    assertThat(message.message).isEqualTo("Removed Code-Review+1 by User <user@example.com>\n");
    assertThat(getReviewers(c.reviewers.get(REVIEWER))).containsExactlyElementsIn(ImmutableSet.of(admin.getId(), user.getId()));
}
#end_block

#method_before
private static Iterable<Account.Id> getReviewers(Collection<AccountInfo> r) {
    return Iterables.transform(r, a -> new Account.Id(a._accountId));
}
#method_after
private Iterable<Account.Id> getReviewers(Collection<AccountInfo> r) {
    return Iterables.transform(r, a -> new Account.Id(a._accountId));
}
#end_block

#method_before
@Override
public Response<?> apply(VoteResource rsrc, DeleteVoteInput input) throws RestApiException, UpdateException {
    if (input == null) {
        input = new DeleteVoteInput();
    }
    if (input.label != null && !rsrc.getLabel().equals(input.label)) {
        throw new BadRequestException("label must match URL");
    }
    if (input.notify == null) {
        input.notify = NotifyHandling.ALL;
    }
    ReviewerResource r = rsrc.getReviewer();
    Change change = r.getChange();
    if (input.patchSet != 0 && input.patchSet != change.currentPatchSetId().get()) {
        // can't delete a vote if it's not on current patch set
        throw new RestApiException("Cannot delete the vote of a stale patch set");
    }
    try (BatchUpdate bu = batchUpdateFactory.create(db.get(), change.getProject(), r.getControl().getUser(), TimeUtil.nowTs())) {
        bu.addOp(change.getId(), new Op(r.getReviewerUser().getAccountId(), rsrc.getLabel(), input));
        bu.execute();
    }
    return Response.none();
}
#method_after
@Override
public Response<?> apply(VoteResource rsrc, DeleteVoteInput input) throws RestApiException, UpdateException {
    if (input == null) {
        input = new DeleteVoteInput();
    }
    if (input.label != null && !rsrc.getLabel().equals(input.label)) {
        throw new BadRequestException("label must match URL");
    }
    if (input.notify == null) {
        input.notify = NotifyHandling.ALL;
    }
    ReviewerResource r = rsrc.getReviewer();
    Change change = r.getChange();
    if (r.getRevisionResource() != null && !r.getRevisionResource().isCurrent()) {
        throw new MethodNotAllowedException("Cannot delete vote on non-current patch set");
    }
    try (BatchUpdate bu = batchUpdateFactory.create(db.get(), change.getProject(), r.getControl().getUser(), TimeUtil.nowTs())) {
        bu.addOp(change.getId(), new Op(r.getReviewerUser().getAccountId(), rsrc.getLabel(), input));
        bu.execute();
    }
    return Response.none();
}
#end_block

#method_before
@Override
public IncludedInInfo apply(ChangeResource rsrc) throws BadRequestException, ResourceConflictException, OrmException, IOException {
    ChangeControl ctl = rsrc.getControl();
    PatchSet ps = psUtil.current(db.get(), rsrc.getNotes());
    Project.NameKey project = ctl.getProject().getNameKey();
    try (Repository r = repoManager.openRepository(project);
        RevWalk rw = new RevWalk(r)) {
        rw.setRetainBody(false);
        RevCommit rev;
        try {
            rev = rw.parseCommit(ObjectId.fromString(ps.getRevision().get()));
        } catch (IncorrectObjectTypeException err) {
            throw new BadRequestException(err.getMessage());
        } catch (MissingObjectException err) {
            throw new ResourceConflictException(err.getMessage());
        }
        IncludedInResolver.Result d = IncludedInResolver.resolve(r, rw, rev);
        ListMultimap<String, String> external = MultimapBuilder.hashKeys().arrayListValues().build();
        for (ExternalIncludedIn ext : includedIn) {
            Multimap<String, String> extIncludedIns = ext.getIncludedIn(project.get(), rev.name(), d.getTags(), d.getBranches());
            if (extIncludedIns != null) {
                external.putAll(extIncludedIns);
            }
        }
        return new IncludedInInfo(d, (!external.isEmpty() ? external.asMap() : null));
    }
}
#method_after
@Override
public IncludedInInfo apply(ChangeResource rsrc) throws BadRequestException, ResourceConflictException, OrmException, IOException {
    ChangeControl ctl = rsrc.getControl();
    PatchSet ps = psUtil.current(db.get(), rsrc.getNotes());
    Project.NameKey project = ctl.getProject().getNameKey();
    try (Repository r = repoManager.openRepository(project);
        RevWalk rw = new RevWalk(r)) {
        rw.setRetainBody(false);
        RevCommit rev;
        try {
            rev = rw.parseCommit(ObjectId.fromString(ps.getRevision().get()));
        } catch (IncorrectObjectTypeException err) {
            throw new BadRequestException(err.getMessage());
        } catch (MissingObjectException err) {
            throw new ResourceConflictException(err.getMessage());
        }
        IncludedInResolver.Result d = IncludedInResolver.resolve(r, rw, rev);
        ListMultimap<String, String> external = MultimapBuilder.hashKeys().arrayListValues().build();
        for (ExternalIncludedIn ext : includedIn) {
            ListMultimap<String, String> extIncludedIns = ext.getIncludedIn(project.get(), rev.name(), d.getTags(), d.getBranches());
            if (extIncludedIns != null) {
                external.putAll(extIncludedIns);
            }
        }
        return new IncludedInInfo(d, (!external.isEmpty() ? external.asMap() : null));
    }
}
#end_block

#method_before
private ListMultimap<String, ?> extractParams(final Audit note, final GerritCall call) {
    ListMultimap<String, Object> args = ArrayListMultimap.create();
    Object[] params = call.getParams();
    for (int i = 0; i < params.length; i++) {
        args.put("$" + i, params[i]);
    }
    for (int idx : note.obfuscate()) {
        args.removeAll("$" + idx);
        args.put("$" + idx, "*****");
    }
    return args;
}
#method_after
private ListMultimap<String, ?> extractParams(Audit note, GerritCall call) {
    ListMultimap<String, Object> args = ArrayListMultimap.create();
    Object[] params = call.getParams();
    for (int i = 0; i < params.length; i++) {
        args.put("$" + i, params[i]);
    }
    for (int idx : note.obfuscate()) {
        args.removeAll("$" + idx);
        args.put("$" + idx, "*****");
    }
    return args;
}
#end_block

#method_before
private void checkUserSession(HttpServletRequest req) throws AuthException {
    CurrentUser user = globals.currentUser.get();
    if (isRead(req)) {
        user.setAccessPath(AccessPath.REST_API);
        CurrentUser.PropertyKey<AccountExternalId.Key> k = CurrentUser.PropertyKey.create();
        user.put(k, globals.webSession.get().getLastLoginExternalId());
    } else if (user instanceof AnonymousUser) {
        throw new AuthException("Authentication required");
    } else if (!globals.webSession.get().isAccessPathOk(AccessPath.REST_API)) {
        throw new AuthException("Invalid authentication method. In order to authenticate, " + "prefix the REST endpoint URL with /a/ (e.g. http://example.com/a/projects/).");
    }
}
#method_after
private void checkUserSession(HttpServletRequest req) throws AuthException {
    CurrentUser user = globals.currentUser.get();
    if (isRead(req)) {
        user.setAccessPath(AccessPath.REST_API);
        user.setLastLoginExternalIdKey(globals.webSession.get().getLastLoginExternalId());
    } else if (user instanceof AnonymousUser) {
        throw new AuthException("Authentication required");
    } else if (!globals.webSession.get().isAccessPathOk(AccessPath.REST_API)) {
        throw new AuthException("Invalid authentication method. In order to authenticate, " + "prefix the REST endpoint URL with /a/ (e.g. http://example.com/a/projects/).");
    }
}
#end_block

#method_before
@Override
public void setParams(ListMultimap<String, String> params) {
    // The --query2 option is defined in QueryGroups
    this.hasQuery2 = params.containsKey("query2");
}
#method_after
@Override
public void setParams(ListMultimap<String, String> params) throws BadRequestException {
    if (params.containsKey("query") && params.containsKey("query2")) {
        throw new BadRequestException("\"query\" and \"query2\" options are mutually exclusive");
    }
    // The --query2 option is defined in QueryGroups
    this.hasQuery2 = params.containsKey("query2");
}
#end_block

#method_before
public String generateToken(String operation, AnyLongObjectId id) {
    if (key.isPresent()) {
        try {
            byte[] initVector = new byte[IV_LENGTH];
            rndm.nextBytes(initVector);
            Cipher cipher = cipher(initVector, Cipher.ENCRYPT_MODE);
            return Base64.encodeBytes(Bytes.concat(initVector, cipher.doFinal(String.format("%s-%s-%s", operation, id.name(), timeout()).getBytes(StandardCharsets.UTF_8))));
        } catch (GeneralSecurityException e) {
            log.error("Token generation failed with error", e);
        }
    }
    return "not:required";
}
#method_after
public String generateToken(String operation, AnyLongObjectId id) {
    try {
        byte[] initVector = new byte[IV_LENGTH];
        rndm.nextBytes(initVector);
        Cipher cipher = cipher(initVector, Cipher.ENCRYPT_MODE);
        return Base64.encodeBytes(Bytes.concat(initVector, cipher.doFinal(String.format("%s-%s-%s", operation, id.name(), timeout()).getBytes(StandardCharsets.UTF_8))));
    } catch (GeneralSecurityException e) {
        log.error("Token generation failed with error", e);
        throw new RuntimeException(e);
    }
}
#end_block

#method_before
public boolean verifyAgainstToken(String token, String operation, AnyLongObjectId id) {
    if (!key.isPresent()) {
        return true;
    }
    if (Strings.isNullOrEmpty(token)) {
        return false;
    }
    byte[] bytes = Base64.decode(token);
    byte[] initVector = Arrays.copyOf(bytes, IV_LENGTH);
    try {
        Cipher cipher = cipher(initVector, Cipher.DECRYPT_MODE);
        String data = new String(cipher.doFinal(Arrays.copyOfRange(bytes, IV_LENGTH, bytes.length)), StandardCharsets.UTF_8);
        String oid = id.name();
        String prefix = String.format("%s-%s-", operation, oid);
        return data.startsWith(prefix) && onTime(data.substring(prefix.length()), operation, oid);
    } catch (GeneralSecurityException e) {
        log.error("Exception was thrown during token verification", e);
    }
    return false;
}
#method_after
public boolean verifyAgainstToken(String token, String operation, AnyLongObjectId id) {
    if (Strings.isNullOrEmpty(token)) {
        return false;
    }
    byte[] bytes = Base64.decode(token);
    byte[] initVector = Arrays.copyOf(bytes, IV_LENGTH);
    try {
        Cipher cipher = cipher(initVector, Cipher.DECRYPT_MODE);
        String data = new String(cipher.doFinal(Arrays.copyOfRange(bytes, IV_LENGTH, bytes.length)), StandardCharsets.UTF_8);
        String oid = id.name();
        String prefix = String.format("%s-%s-", operation, oid);
        return data.startsWith(prefix) && onTime(data.substring(prefix.length()), operation, oid);
    } catch (GeneralSecurityException e) {
        log.error("Exception was thrown during token verification", e);
    }
    return false;
}
#end_block

#method_before
private boolean onTime(String dateTime, String operation, String id) {
    DateTime deadline = ISODateTimeFormat.dateTimeParser().parseDateTime(dateTime);
    if (deadline.isBeforeNow()) {
        log.info("Operation {} on id {} timed out", operation, id);
        return false;
    }
    return true;
}
#method_after
boolean onTime(String dateTime, String operation, String id) {
    String now = DATE_TIME.print(now());
    if (now.compareTo(dateTime) > 0) {
        log.info("Operation {} on id {} timed out", operation, id);
        return false;
    }
    return true;
}
#end_block

#method_before
private String timeout() {
    DateTime now = now();
    return ISODateTimeFormat.dateTime().print(now.plusSeconds(timeout));
}
#method_after
private String timeout() {
    return DATE_TIME.print(now().plusSeconds(timeout));
}
#end_block

#method_before
private Cipher cipher(byte[] initVector, int mode) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidParameterSpecException, InvalidKeyException, InvalidAlgorithmParameterException {
    IvParameterSpec spec = new IvParameterSpec(initVector);
    Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
    AlgorithmParameters params = AlgorithmParameters.getInstance(ALGORITHM);
    params.init(spec);
    cipher.init(mode, key.get(), params);
    return cipher;
}
#method_after
private Cipher cipher(byte[] initVector, int mode) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidParameterSpecException, InvalidKeyException, InvalidAlgorithmParameterException {
    IvParameterSpec spec = new IvParameterSpec(initVector);
    Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
    AlgorithmParameters params = AlgorithmParameters.getInstance(ALGORITHM);
    params.init(spec);
    cipher.init(mode, key, params);
    return cipher;
}
#end_block

#method_before
private Optional<SecretKey> generateKey() {
    try {
        KeyGenerator generator = KeyGenerator.getInstance(ALGORITHM);
        generator.init(128, rndm);
        return Optional.of(generator.generateKey());
    } catch (NoSuchAlgorithmException e) {
        log.error("Generating key failed with error", e);
    }
    return Optional.absent();
}
#method_after
private SecretKey generateKey() {
    try {
        KeyGenerator generator = KeyGenerator.getInstance(ALGORITHM);
        generator.init(128, rndm);
        return generator.generateKey();
    } catch (NoSuchAlgorithmException e) {
        log.error("Generating key failed with error", e);
        throw new RuntimeException(e);
    }
}
#end_block

#method_before
private static Term idTerm(AccountGroup as) {
    return idTerm(as.getGroupUUID());
}
#method_after
private static Term idTerm(AccountGroup group) {
    return idTerm(group.getGroupUUID());
}
#end_block

#method_before
@Override
public void replace(AccountGroup as) throws IOException {
    try {
        // No parts of FillArgs are currently required, just use null.
        replace(idTerm(as), toDocument(as, null)).get();
    } catch (ExecutionException | InterruptedException e) {
        throw new IOException(e);
    }
}
#method_after
@Override
public void replace(AccountGroup group) throws IOException {
    try {
        // No parts of FillArgs are currently required, just use null.
        replace(idTerm(group), toDocument(group, null)).get();
    } catch (ExecutionException | InterruptedException e) {
        throw new IOException(e);
    }
}
#end_block

#method_before
private AccountGroup toAccountGroup(Document doc) {
    AccountGroup.UUID uuid = new AccountGroup.UUID(doc.getField(UUID.getName()).stringValue());
    // document (of which there shouldn't be any.
    return groupCache.get(uuid);
}
#method_after
private AccountGroup toAccountGroup(Document doc) {
    AccountGroup.UUID uuid = new AccountGroup.UUID(doc.getField(UUID.getName()).stringValue());
    // document (of which there shouldn't be any).
    return groupCache.get(uuid);
}
#end_block

#method_before
public Response<String> apply(IdentifiedUser user, String newPassword) throws ResourceNotFoundException, ResourceConflictException, OrmException, IOException {
    if (user.getUserName() == null) {
        throw new ResourceConflictException("username must be set");
    }
    AccountExternalId id = dbProvider.get().accountExternalIds().get(new AccountExternalId.Key(SCHEME_USERNAME, user.getUserName()));
    if (id == null) {
        throw new ResourceNotFoundException();
    }
    id.setPassword(newPassword);
    dbProvider.get().accountExternalIds().update(Collections.singleton(id));
    externalIdCache.update(id);
    accountCache.evict(user.getAccountId());
    return Strings.isNullOrEmpty(newPassword) ? Response.<String>none() : Response.ok(newPassword);
}
#method_after
public Response<String> apply(IdentifiedUser user, String newPassword) throws ResourceNotFoundException, ResourceConflictException, OrmException, IOException {
    if (user.getUserName() == null) {
        throw new ResourceConflictException("username must be set");
    }
    AccountExternalId id = dbProvider.get().accountExternalIds().get(new AccountExternalId.Key(SCHEME_USERNAME, user.getUserName()));
    if (id == null) {
        throw new ResourceNotFoundException();
    }
    id.setPassword(newPassword);
    dbProvider.get().accountExternalIds().update(Collections.singleton(id));
    externalIdCache.onUpdate(id);
    accountCache.evict(user.getAccountId());
    return Strings.isNullOrEmpty(newPassword) ? Response.<String>none() : Response.ok(newPassword);
}
#end_block

#method_before
public Account.Id lookup(String externalId) throws AccountException {
    try {
        AccountState accountState = accountQueryProvider.get().oneByExternalId(externalId);
        return accountState != null ? accountState.getAccount().getId() : null;
    } catch (OrmException e) {
        throw new AccountException("Cannot lookup account " + externalId, e);
    }
}
#method_after
public Optional<Account.Id> lookup(String externalId) throws AccountException {
    try {
        AccountState accountState = accountQueryProvider.get().oneByExternalId(externalId);
        return accountState != null ? Optional.of(accountState.getAccount().getId()) : Optional.empty();
    } catch (OrmException e) {
        throw new AccountException("Cannot lookup account " + externalId, e);
    }
}
#end_block

#method_before
private void update(ReviewDb db, AuthRequest who, AccountExternalId extId) throws OrmException, IOException {
    IdentifiedUser user = userFactory.create(extId.getAccountId());
    Account toUpdate = null;
    // If the email address was modified by the authentication provider,
    // update our records to match the changed email.
    // 
    String newEmail = who.getEmailAddress();
    String oldEmail = extId.getEmailAddress();
    if (newEmail != null && !newEmail.equals(oldEmail)) {
        if (oldEmail != null && oldEmail.equals(user.getAccount().getPreferredEmail())) {
            toUpdate = load(toUpdate, user.getAccountId(), db);
            toUpdate.setPreferredEmail(newEmail);
        }
        extId.setEmailAddress(newEmail);
        db.accountExternalIds().update(Collections.singleton(extId));
        externalIdCache.update(extId);
    }
    if (!realm.allowsEdit(AccountFieldName.FULL_NAME) && !Strings.isNullOrEmpty(who.getDisplayName()) && !eq(user.getAccount().getFullName(), who.getDisplayName())) {
        toUpdate = load(toUpdate, user.getAccountId(), db);
        toUpdate.setFullName(who.getDisplayName());
    }
    if (!realm.allowsEdit(AccountFieldName.USER_NAME) && who.getUserName() != null && !eq(user.getUserName(), who.getUserName())) {
        log.warn(String.format("Not changing already set username %s to %s", user.getUserName(), who.getUserName()));
    }
    if (toUpdate != null) {
        db.accounts().update(Collections.singleton(toUpdate));
    }
    if (newEmail != null && !newEmail.equals(oldEmail)) {
        byEmailCache.evict(oldEmail);
        byEmailCache.evict(newEmail);
    }
    if (toUpdate != null) {
        byIdCache.evict(toUpdate.getId());
    }
}
#method_after
private void update(ReviewDb db, AuthRequest who, AccountExternalId extId) throws OrmException, IOException {
    IdentifiedUser user = userFactory.create(extId.getAccountId());
    Account toUpdate = null;
    // If the email address was modified by the authentication provider,
    // update our records to match the changed email.
    // 
    String newEmail = who.getEmailAddress();
    String oldEmail = extId.getEmailAddress();
    if (newEmail != null && !newEmail.equals(oldEmail)) {
        if (oldEmail != null && oldEmail.equals(user.getAccount().getPreferredEmail())) {
            toUpdate = load(toUpdate, user.getAccountId(), db);
            toUpdate.setPreferredEmail(newEmail);
        }
        extId.setEmailAddress(newEmail);
        db.accountExternalIds().update(Collections.singleton(extId));
        externalIdCache.onUpdate(extId);
    }
    if (!realm.allowsEdit(AccountFieldName.FULL_NAME) && !Strings.isNullOrEmpty(who.getDisplayName()) && !eq(user.getAccount().getFullName(), who.getDisplayName())) {
        toUpdate = load(toUpdate, user.getAccountId(), db);
        toUpdate.setFullName(who.getDisplayName());
    }
    if (!realm.allowsEdit(AccountFieldName.USER_NAME) && who.getUserName() != null && !eq(user.getUserName(), who.getUserName())) {
        log.warn(String.format("Not changing already set username %s to %s", user.getUserName(), who.getUserName()));
    }
    if (toUpdate != null) {
        db.accounts().update(Collections.singleton(toUpdate));
    }
    if (newEmail != null && !newEmail.equals(oldEmail)) {
        byEmailCache.evict(oldEmail);
        byEmailCache.evict(newEmail);
    }
    if (toUpdate != null) {
        byIdCache.evict(toUpdate.getId());
    }
}
#end_block

#method_before
private AuthResult create(ReviewDb db, AuthRequest who) throws OrmException, AccountException, IOException {
    Account.Id newId = new Account.Id(db.nextAccountId());
    Account account = new Account(newId, TimeUtil.nowTs());
    AccountExternalId extId = createId(newId, who);
    extId.setEmailAddress(who.getEmailAddress());
    account.setFullName(who.getDisplayName());
    account.setPreferredEmail(extId.getEmailAddress());
    boolean isFirstAccount = awaitsFirstAccountCheck.getAndSet(false) && db.accounts().anyAccounts().toList().isEmpty();
    try {
        db.accounts().upsert(Collections.singleton(account));
        AccountExternalId existingExtId = db.accountExternalIds().get(extId.getKey());
        if (existingExtId != null && !existingExtId.getAccountId().equals(extId.getAccountId())) {
            // external ID is assigned to another account, do not overwrite
            db.accounts().delete(Collections.singleton(account));
            throw new AccountException("Cannot assign external ID \"" + extId.getExternalId() + "\" to account " + newId + "; external ID already in use.");
        }
        db.accountExternalIds().upsert(Collections.singleton(extId));
        externalIdCache.update(extId);
    } finally {
        // If adding the account failed, it may be that it actually was the
        // first account. So we reset the 'check for first account'-guard, as
        // otherwise the first account would not get administration permissions.
        awaitsFirstAccountCheck.set(isFirstAccount);
    }
    if (isFirstAccount) {
        // This is the first user account on our site. Assume this user
        // is going to be the site's administrator and just make them that
        // to bootstrap the authentication database.
        // 
        Permission admin = projectCache.getAllProjects().getConfig().getAccessSection(AccessSection.GLOBAL_CAPABILITIES).getPermission(GlobalCapability.ADMINISTRATE_SERVER);
        AccountGroup.UUID uuid = admin.getRules().get(0).getGroup().getUUID();
        AccountGroup g = db.accountGroups().byUUID(uuid).iterator().next();
        AccountGroup.Id adminId = g.getId();
        AccountGroupMember m = new AccountGroupMember(new AccountGroupMember.Key(newId, adminId));
        auditService.dispatchAddAccountsToGroup(newId, Collections.singleton(m));
        db.accountGroupMembers().insert(Collections.singleton(m));
    }
    if (who.getUserName() != null) {
        // Only set if the name hasn't been used yet, but was given to us.
        // 
        IdentifiedUser user = userFactory.create(newId);
        try {
            changeUserNameFactory.create(db, user, who.getUserName()).call();
        } catch (NameAlreadyUsedException e) {
            String message = "Cannot assign user name \"" + who.getUserName() + "\" to account " + newId + "; name already in use.";
            handleSettingUserNameFailure(db, account, extId, message, e, false);
        } catch (InvalidUserNameException e) {
            String message = "Cannot assign user name \"" + who.getUserName() + "\" to account " + newId + "; name does not conform.";
            handleSettingUserNameFailure(db, account, extId, message, e, false);
        } catch (OrmException e) {
            String message = "Cannot assign user name";
            handleSettingUserNameFailure(db, account, extId, message, e, true);
        }
    }
    byEmailCache.evict(account.getPreferredEmail());
    byIdCache.evict(account.getId());
    realm.onCreateAccount(who, account);
    return new AuthResult(newId, extId.getKey(), true);
}
#method_after
private AuthResult create(ReviewDb db, AuthRequest who) throws OrmException, AccountException, IOException {
    Account.Id newId = new Account.Id(db.nextAccountId());
    Account account = new Account(newId, TimeUtil.nowTs());
    AccountExternalId extId = createId(newId, who);
    extId.setEmailAddress(who.getEmailAddress());
    account.setFullName(who.getDisplayName());
    account.setPreferredEmail(extId.getEmailAddress());
    boolean isFirstAccount = awaitsFirstAccountCheck.getAndSet(false) && db.accounts().anyAccounts().toList().isEmpty();
    try {
        db.accounts().upsert(Collections.singleton(account));
        AccountExternalId existingExtId = db.accountExternalIds().get(extId.getKey());
        if (existingExtId != null && !existingExtId.getAccountId().equals(extId.getAccountId())) {
            // external ID is assigned to another account, do not overwrite
            db.accounts().delete(Collections.singleton(account));
            throw new AccountException("Cannot assign external ID \"" + extId.getExternalId() + "\" to account " + newId + "; external ID already in use.");
        }
        db.accountExternalIds().upsert(Collections.singleton(extId));
        externalIdCache.onUpdate(extId);
    } finally {
        // If adding the account failed, it may be that it actually was the
        // first account. So we reset the 'check for first account'-guard, as
        // otherwise the first account would not get administration permissions.
        awaitsFirstAccountCheck.set(isFirstAccount);
    }
    if (isFirstAccount) {
        // This is the first user account on our site. Assume this user
        // is going to be the site's administrator and just make them that
        // to bootstrap the authentication database.
        // 
        Permission admin = projectCache.getAllProjects().getConfig().getAccessSection(AccessSection.GLOBAL_CAPABILITIES).getPermission(GlobalCapability.ADMINISTRATE_SERVER);
        AccountGroup.UUID uuid = admin.getRules().get(0).getGroup().getUUID();
        AccountGroup g = db.accountGroups().byUUID(uuid).iterator().next();
        AccountGroup.Id adminId = g.getId();
        AccountGroupMember m = new AccountGroupMember(new AccountGroupMember.Key(newId, adminId));
        auditService.dispatchAddAccountsToGroup(newId, Collections.singleton(m));
        db.accountGroupMembers().insert(Collections.singleton(m));
    }
    if (who.getUserName() != null) {
        // Only set if the name hasn't been used yet, but was given to us.
        // 
        IdentifiedUser user = userFactory.create(newId);
        try {
            changeUserNameFactory.create(db, user, who.getUserName()).call();
        } catch (NameAlreadyUsedException e) {
            String message = "Cannot assign user name \"" + who.getUserName() + "\" to account " + newId + "; name already in use.";
            handleSettingUserNameFailure(db, account, extId, message, e, false);
        } catch (InvalidUserNameException e) {
            String message = "Cannot assign user name \"" + who.getUserName() + "\" to account " + newId + "; name does not conform.";
            handleSettingUserNameFailure(db, account, extId, message, e, false);
        } catch (OrmException e) {
            String message = "Cannot assign user name";
            handleSettingUserNameFailure(db, account, extId, message, e, true);
        }
    }
    byEmailCache.evict(account.getPreferredEmail());
    byIdCache.evict(account.getId());
    realm.onCreateAccount(who, account);
    return new AuthResult(newId, extId.getKey(), true);
}
#end_block

#method_before
private void handleSettingUserNameFailure(ReviewDb db, Account account, AccountExternalId extId, String errorMessage, Exception e, boolean logException) throws AccountUserNameException, OrmException {
    if (logException) {
        log.error(errorMessage, e);
    } else {
        log.error(errorMessage);
    }
    if (!realm.allowsEdit(AccountFieldName.USER_NAME)) {
        // setting the given user name has failed, but the realm does not
        // allow the user to manually set a user name,
        // this means we would end with an account without user name
        // (without 'username:<USERNAME>' entry in
        // account_external_ids table),
        // such an account cannot be used for uploading changes,
        // this is why the best we can do here is to fail early and cleanup
        // the database
        db.accounts().delete(Collections.singleton(account));
        db.accountExternalIds().delete(Collections.singleton(extId));
        externalIdCache.remove(extId);
        throw new AccountUserNameException(errorMessage, e);
    }
}
#method_after
private void handleSettingUserNameFailure(ReviewDb db, Account account, AccountExternalId extId, String errorMessage, Exception e, boolean logException) throws AccountUserNameException, OrmException {
    if (logException) {
        log.error(errorMessage, e);
    } else {
        log.error(errorMessage);
    }
    if (!realm.allowsEdit(AccountFieldName.USER_NAME)) {
        // setting the given user name has failed, but the realm does not
        // allow the user to manually set a user name,
        // this means we would end with an account without user name
        // (without 'username:<USERNAME>' entry in
        // account_external_ids table),
        // such an account cannot be used for uploading changes,
        // this is why the best we can do here is to fail early and cleanup
        // the database
        db.accounts().delete(Collections.singleton(account));
        db.accountExternalIds().delete(Collections.singleton(extId));
        externalIdCache.onRemove(extId);
        throw new AccountUserNameException(errorMessage, e);
    }
}
#end_block

#method_before
public AuthResult updateLink(Account.Id to, AuthRequest who) throws OrmException, AccountException, IOException {
    try (ReviewDb db = schema.open()) {
        AccountExternalId.Key key = id(who);
        List<AccountExternalId.Key> filteredKeysByScheme = filterKeysByScheme(key.getScheme(), externalIdCache.byAccount(to));
        if (!filteredKeysByScheme.isEmpty() && (filteredKeysByScheme.size() > 1 || !filteredKeysByScheme.contains(key))) {
            db.accountExternalIds().deleteKeys(filteredKeysByScheme);
            externalIdCache.remove(to, filteredKeysByScheme);
        }
        byIdCache.evict(to);
        return link(to, who);
    }
}
#method_after
public AuthResult updateLink(Account.Id to, AuthRequest who) throws OrmException, AccountException, IOException {
    try (ReviewDb db = schema.open()) {
        AccountExternalId.Key key = id(who);
        List<AccountExternalId.Key> filteredKeysByScheme = filterKeysByScheme(key.getScheme(), externalIdCache.byAccount(to));
        if (!filteredKeysByScheme.isEmpty() && (filteredKeysByScheme.size() > 1 || !filteredKeysByScheme.contains(key))) {
            db.accountExternalIds().deleteKeys(filteredKeysByScheme);
            externalIdCache.onRemove(to, filteredKeysByScheme);
        }
        byIdCache.evict(to);
        return link(to, who);
    }
}
#end_block

#method_before
public AuthResult unlink(Account.Id from, AuthRequest who) throws AccountException, OrmException, IOException {
    try (ReviewDb db = schema.open()) {
        AccountExternalId.Key key = id(who);
        AccountExternalId extId = getAccountExternalId(key);
        if (extId != null) {
            if (!extId.getAccountId().equals(from)) {
                throw new AccountException("Identity '" + key.get() + "' in use by another account");
            }
            db.accountExternalIds().delete(Collections.singleton(extId));
            externalIdCache.remove(extId);
            if (who.getEmailAddress() != null) {
                Account a = db.accounts().get(from);
                if (a.getPreferredEmail() != null && a.getPreferredEmail().equals(who.getEmailAddress())) {
                    a.setPreferredEmail(null);
                    db.accounts().update(Collections.singleton(a));
                }
                byEmailCache.evict(who.getEmailAddress());
                byIdCache.evict(from);
            }
        } else {
            throw new AccountException("Identity '" + key.get() + "' not found");
        }
        return new AuthResult(from, key, false);
    }
}
#method_after
public AuthResult unlink(Account.Id from, AuthRequest who) throws AccountException, OrmException, IOException {
    try (ReviewDb db = schema.open()) {
        AccountExternalId.Key key = id(who);
        AccountExternalId extId = getAccountExternalId(key);
        if (extId != null) {
            if (!extId.getAccountId().equals(from)) {
                throw new AccountException("Identity '" + key.get() + "' in use by another account");
            }
            db.accountExternalIds().delete(Collections.singleton(extId));
            externalIdCache.onRemove(extId);
            if (who.getEmailAddress() != null) {
                Account a = db.accounts().get(from);
                if (a.getPreferredEmail() != null && a.getPreferredEmail().equals(who.getEmailAddress())) {
                    a.setPreferredEmail(null);
                    db.accounts().update(Collections.singleton(a));
                }
                byEmailCache.evict(who.getEmailAddress());
                byIdCache.evict(from);
            }
        } else {
            throw new AccountException("Identity '" + key.get() + "' not found");
        }
        return new AuthResult(from, key, false);
    }
}
#end_block

#method_before
@Override
public Response<?> apply(GpgKey rsrc, Input input) throws ResourceConflictException, PGPException, OrmException, IOException {
    PGPPublicKey key = rsrc.getKeyRing().getPublicKey();
    AccountExternalId.Key extIdKey = new AccountExternalId.Key(AccountExternalId.SCHEME_GPGKEY, BaseEncoding.base16().encode(key.getFingerprint()));
    db.get().accountExternalIds().deleteKeys(Collections.singleton(extIdKey));
    externalIdCache.remove(rsrc.getUser().getAccountId(), extIdKey);
    accountCache.evict(rsrc.getUser().getAccountId());
    try (PublicKeyStore store = storeProvider.get()) {
        store.remove(rsrc.getKeyRing().getPublicKey().getFingerprint());
        CommitBuilder cb = new CommitBuilder();
        PersonIdent committer = serverIdent.get();
        cb.setAuthor(rsrc.getUser().newCommitterIdent(committer.getWhen(), committer.getTimeZone()));
        cb.setCommitter(committer);
        cb.setMessage("Delete public key " + keyIdToString(key.getKeyID()));
        RefUpdate.Result saveResult = store.save(cb);
        switch(saveResult) {
            case NO_CHANGE:
            case FAST_FORWARD:
                break;
            case FORCED:
            case IO_FAILURE:
            case LOCK_FAILURE:
            case NEW:
            case NOT_ATTEMPTED:
            case REJECTED:
            case REJECTED_CURRENT_BRANCH:
            case RENAMED:
            default:
                throw new ResourceConflictException("Failed to delete public key: " + saveResult);
        }
    }
    return Response.none();
}
#method_after
@Override
public Response<?> apply(GpgKey rsrc, Input input) throws ResourceConflictException, PGPException, OrmException, IOException {
    PGPPublicKey key = rsrc.getKeyRing().getPublicKey();
    AccountExternalId.Key extIdKey = new AccountExternalId.Key(AccountExternalId.SCHEME_GPGKEY, BaseEncoding.base16().encode(key.getFingerprint()));
    db.get().accountExternalIds().deleteKeys(Collections.singleton(extIdKey));
    externalIdCache.onRemove(rsrc.getUser().getAccountId(), extIdKey);
    accountCache.evict(rsrc.getUser().getAccountId());
    try (PublicKeyStore store = storeProvider.get()) {
        store.remove(rsrc.getKeyRing().getPublicKey().getFingerprint());
        CommitBuilder cb = new CommitBuilder();
        PersonIdent committer = serverIdent.get();
        cb.setAuthor(rsrc.getUser().newCommitterIdent(committer.getWhen(), committer.getTimeZone()));
        cb.setCommitter(committer);
        cb.setMessage("Delete public key " + keyIdToString(key.getKeyID()));
        RefUpdate.Result saveResult = store.save(cb);
        switch(saveResult) {
            case NO_CHANGE:
            case FAST_FORWARD:
                break;
            case FORCED:
            case IO_FAILURE:
            case LOCK_FAILURE:
            case NEW:
            case NOT_ATTEMPTED:
            case REJECTED:
            case REJECTED_CURRENT_BRANCH:
            case RENAMED:
            default:
                throw new ResourceConflictException("Failed to delete public key: " + saveResult);
        }
    }
    return Response.none();
}
#end_block

#method_before
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            cache(CACHE_NAME, ListKey.class, new TypeLiteral<Multimap<Account.Id, AccountExternalId>>() {
            }).maximumWeight(1).loader(Loader.class);
            bind(ExternalIdCacheImpl.class);
            bind(ExternalIdCache.class).to(ExternalIdCacheImpl.class);
        }
    };
}
#method_after
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            cache(CACHE_NAME, AllKey.class, new TypeLiteral<ImmutableSetMultimap<Account.Id, AccountExternalId>>() {
            }).maximumWeight(1).loader(Loader.class);
            bind(ExternalIdCacheImpl.class);
            bind(ExternalIdCache.class).to(ExternalIdCacheImpl.class);
        }
    };
}
#end_block

#method_before
@Override
public void onCreate(Iterable<AccountExternalId> extIds) {
    lock.lock();
    try {
        Multimap<Account.Id, AccountExternalId> n = MultimapBuilder.hashKeys().arrayListValues().build(extIdsByAccount.get(ListKey.ALL));
        for (AccountExternalId extId : extIds) {
            n.put(extId.getAccountId(), extId);
        }
        extIdsByAccount.put(ListKey.ALL, ImmutableMultimap.copyOf(n));
    } catch (ExecutionException e) {
        log.warn("Cannot list avaliable projects", e);
    } finally {
        lock.unlock();
    }
}
#method_after
@Override
public void onCreate(Iterable<AccountExternalId> extIds) {
    lock.lock();
    try {
        Multimap<Account.Id, AccountExternalId> n = MultimapBuilder.hashKeys().arrayListValues().build(extIdsByAccount.get(AllKey.ALL));
        for (AccountExternalId extId : extIds) {
            n.put(extId.getAccountId(), extId);
        }
        extIdsByAccount.put(AllKey.ALL, ImmutableSetMultimap.copyOf(n));
    } catch (ExecutionException e) {
        log.warn("Cannot list external IDs", e);
    } finally {
        lock.unlock();
    }
}
#end_block

#method_before
@Override
public Collection<AccountExternalId> byAccount(Account.Id accountId) {
    try {
        return ImmutableSet.copyOf(extIdsByAccount.get(ListKey.ALL).get(accountId));
    } catch (ExecutionException e) {
        log.warn("Cannot list external ids", e);
        return Collections.emptySet();
    }
}
#method_after
@Override
public Collection<AccountExternalId> byAccount(Account.Id accountId) {
    try {
        return extIdsByAccount.get(AllKey.ALL).get(accountId);
    } catch (ExecutionException e) {
        log.warn("Cannot list external ids", e);
        return Collections.emptySet();
    }
}
#end_block

#method_before
@Override
public Multimap<Account.Id, AccountExternalId> load(ListKey key) throws Exception {
    try (ReviewDb db = schema.open()) {
        Multimap<Account.Id, AccountExternalId> extIdsByAccount = MultimapBuilder.hashKeys().arrayListValues().build();
        for (AccountExternalId extId : db.accountExternalIds().all()) {
            extIdsByAccount.put(extId.getAccountId(), extId);
        }
        return ImmutableMultimap.copyOf(extIdsByAccount);
    }
}
#method_after
@Override
public ImmutableSetMultimap<Account.Id, AccountExternalId> load(AllKey key) throws Exception {
    try (ReviewDb db = schema.open()) {
        Multimap<Account.Id, AccountExternalId> extIdsByAccount = MultimapBuilder.hashKeys().arrayListValues().build();
        for (AccountExternalId extId : db.accountExternalIds().all()) {
            extIdsByAccount.put(extId.getAccountId(), extId);
        }
        return ImmutableSetMultimap.copyOf(extIdsByAccount);
    }
}
#end_block

#method_before
@After
public void restoreExternalIds() throws Exception {
    if (savedExternalIds != null) {
        // savedExternalIds is null when we don't run SSH tests and the assume in
        // @Before in AbstractDaemonTest prevents this class' @Before method from
        // being executed.
        Collection<AccountExternalId> adminExtIds = getExternalIds(admin);
        db.accountExternalIds().delete(adminExtIds);
        externalIdCache.remove(adminExtIds);
        Collection<AccountExternalId> userExtIds = getExternalIds(user);
        db.accountExternalIds().delete(userExtIds);
        externalIdCache.remove(userExtIds);
        db.accountExternalIds().insert(savedExternalIds);
        externalIdCache.onCreate(savedExternalIds);
    }
    accountCache.evict(admin.getId());
    accountCache.evict(user.getId());
}
#method_after
@After
public void restoreExternalIds() throws Exception {
    if (savedExternalIds != null) {
        // savedExternalIds is null when we don't run SSH tests and the assume in
        // @Before in AbstractDaemonTest prevents this class' @Before method from
        // being executed.
        Collection<AccountExternalId> adminExtIds = getExternalIds(admin);
        db.accountExternalIds().delete(adminExtIds);
        externalIdCache.onRemove(adminExtIds);
        Collection<AccountExternalId> userExtIds = getExternalIds(user);
        db.accountExternalIds().delete(userExtIds);
        externalIdCache.onRemove(userExtIds);
        db.accountExternalIds().insert(savedExternalIds);
        externalIdCache.onCreate(savedExternalIds);
    }
    accountCache.evict(admin.getId());
    accountCache.evict(user.getId());
}
#end_block

#method_before
@Override
public Set<AccountExternalId.Key> call() throws OrmException, IOException {
    final Map<AccountExternalId.Key, AccountExternalId> have = have();
    List<AccountExternalId> toDelete = new ArrayList<>();
    for (AccountExternalId.Key k : keys) {
        final AccountExternalId id = have.get(k);
        if (id != null && id.canDelete()) {
            toDelete.add(id);
        }
    }
    if (!toDelete.isEmpty()) {
        db.accountExternalIds().delete(toDelete);
        externalIdCache.remove(toDelete);
        accountCache.evict(user.getAccountId());
        for (AccountExternalId e : toDelete) {
            byEmailCache.evict(e.getEmailAddress());
        }
    }
    return toKeySet(toDelete);
}
#method_after
@Override
public Set<AccountExternalId.Key> call() throws OrmException, IOException {
    final Map<AccountExternalId.Key, AccountExternalId> have = have();
    List<AccountExternalId> toDelete = new ArrayList<>();
    for (AccountExternalId.Key k : keys) {
        final AccountExternalId id = have.get(k);
        if (id != null && id.canDelete()) {
            toDelete.add(id);
        }
    }
    if (!toDelete.isEmpty()) {
        db.accountExternalIds().delete(toDelete);
        externalIdCache.onRemove(toDelete);
        accountCache.evict(user.getAccountId());
        for (AccountExternalId e : toDelete) {
            byEmailCache.evict(e.getEmailAddress());
        }
    }
    return toKeySet(toDelete);
}
#end_block

#method_before
@Override
public Response<AccountInfo> apply(TopLevelResource rsrc, AccountInput input) throws BadRequestException, ResourceConflictException, UnprocessableEntityException, OrmException, IOException, ConfigInvalidException {
    if (input == null) {
        input = new AccountInput();
    }
    if (input.username != null && !username.equals(input.username)) {
        throw new BadRequestException("username must match URL");
    }
    if (!username.matches(Account.USER_NAME_PATTERN)) {
        throw new BadRequestException("Username '" + username + "'" + " must contain only letters, numbers, _, - or .");
    }
    Set<AccountGroup.Id> groups = parseGroups(input.groups);
    Account.Id id = new Account.Id(db.nextAccountId());
    AccountExternalId extUser = new AccountExternalId(id, new AccountExternalId.Key(AccountExternalId.SCHEME_USERNAME, username));
    if (input.httpPassword != null) {
        extUser.setPassword(input.httpPassword);
    }
    if (db.accountExternalIds().get(extUser.getKey()) != null) {
        throw new ResourceConflictException("username '" + username + "' already exists");
    }
    if (input.email != null) {
        if (db.accountExternalIds().get(getEmailKey(input.email)) != null) {
            throw new UnprocessableEntityException("email '" + input.email + "' already exists");
        }
        if (!OutgoingEmailValidator.isValid(input.email)) {
            throw new BadRequestException("invalid email address");
        }
    }
    LinkedList<AccountExternalId> externalIds = new LinkedList<>();
    externalIds.add(extUser);
    for (AccountExternalIdCreator c : externalIdCreators) {
        externalIds.addAll(c.create(id, username, input.email));
    }
    try {
        db.accountExternalIds().insert(externalIds);
        externalIdCache.onCreate(externalIds);
    } catch (OrmDuplicateKeyException duplicateKey) {
        throw new ResourceConflictException("username '" + username + "' already exists");
    }
    if (input.email != null) {
        AccountExternalId extMailto = new AccountExternalId(id, getEmailKey(input.email));
        extMailto.setEmailAddress(input.email);
        try {
            db.accountExternalIds().insert(Collections.singleton(extMailto));
            externalIdCache.onCreate(extMailto);
        } catch (OrmDuplicateKeyException duplicateKey) {
            try {
                db.accountExternalIds().delete(Collections.singleton(extUser));
                externalIdCache.remove(extUser);
            } catch (OrmException cleanupError) {
            // Ignored
            }
            throw new UnprocessableEntityException("email '" + input.email + "' already exists");
        }
    }
    Account a = new Account(id, TimeUtil.nowTs());
    a.setFullName(input.name);
    a.setPreferredEmail(input.email);
    db.accounts().insert(Collections.singleton(a));
    for (AccountGroup.Id groupId : groups) {
        AccountGroupMember m = new AccountGroupMember(new AccountGroupMember.Key(id, groupId));
        auditService.dispatchAddAccountsToGroup(currentUser.get().getAccountId(), Collections.singleton(m));
        db.accountGroupMembers().insert(Collections.singleton(m));
    }
    if (input.sshKey != null) {
        try {
            authorizedKeys.addKey(id, input.sshKey);
            sshKeyCache.evict(username);
        } catch (InvalidSshKeyException e) {
            throw new BadRequestException(e.getMessage());
        }
    }
    accountCache.evictByUsername(username);
    byEmailCache.evict(input.email);
    indexer.index(id);
    AccountLoader loader = infoLoader.create(true);
    AccountInfo info = loader.get(id);
    loader.fill();
    return Response.created(info);
}
#method_after
@Override
public Response<AccountInfo> apply(TopLevelResource rsrc, AccountInput input) throws BadRequestException, ResourceConflictException, UnprocessableEntityException, OrmException, IOException, ConfigInvalidException {
    if (input == null) {
        input = new AccountInput();
    }
    if (input.username != null && !username.equals(input.username)) {
        throw new BadRequestException("username must match URL");
    }
    if (!username.matches(Account.USER_NAME_PATTERN)) {
        throw new BadRequestException("Username '" + username + "'" + " must contain only letters, numbers, _, - or .");
    }
    Set<AccountGroup.Id> groups = parseGroups(input.groups);
    Account.Id id = new Account.Id(db.nextAccountId());
    AccountExternalId extUser = new AccountExternalId(id, new AccountExternalId.Key(AccountExternalId.SCHEME_USERNAME, username));
    if (input.httpPassword != null) {
        extUser.setPassword(input.httpPassword);
    }
    if (db.accountExternalIds().get(extUser.getKey()) != null) {
        throw new ResourceConflictException("username '" + username + "' already exists");
    }
    if (input.email != null) {
        if (db.accountExternalIds().get(getEmailKey(input.email)) != null) {
            throw new UnprocessableEntityException("email '" + input.email + "' already exists");
        }
        if (!OutgoingEmailValidator.isValid(input.email)) {
            throw new BadRequestException("invalid email address");
        }
    }
    LinkedList<AccountExternalId> externalIds = new LinkedList<>();
    externalIds.add(extUser);
    for (AccountExternalIdCreator c : externalIdCreators) {
        externalIds.addAll(c.create(id, username, input.email));
    }
    try {
        db.accountExternalIds().insert(externalIds);
        externalIdCache.onCreate(externalIds);
    } catch (OrmDuplicateKeyException duplicateKey) {
        throw new ResourceConflictException("username '" + username + "' already exists");
    }
    if (input.email != null) {
        AccountExternalId extMailto = new AccountExternalId(id, getEmailKey(input.email));
        extMailto.setEmailAddress(input.email);
        try {
            db.accountExternalIds().insert(Collections.singleton(extMailto));
            externalIdCache.onCreate(extMailto);
        } catch (OrmDuplicateKeyException duplicateKey) {
            try {
                db.accountExternalIds().delete(Collections.singleton(extUser));
                externalIdCache.onRemove(extUser);
            } catch (OrmException cleanupError) {
            // Ignored
            }
            throw new UnprocessableEntityException("email '" + input.email + "' already exists");
        }
    }
    Account a = new Account(id, TimeUtil.nowTs());
    a.setFullName(input.name);
    a.setPreferredEmail(input.email);
    db.accounts().insert(Collections.singleton(a));
    for (AccountGroup.Id groupId : groups) {
        AccountGroupMember m = new AccountGroupMember(new AccountGroupMember.Key(id, groupId));
        auditService.dispatchAddAccountsToGroup(currentUser.get().getAccountId(), Collections.singleton(m));
        db.accountGroupMembers().insert(Collections.singleton(m));
    }
    if (input.sshKey != null) {
        try {
            authorizedKeys.addKey(id, input.sshKey);
            sshKeyCache.evict(username);
        } catch (InvalidSshKeyException e) {
            throw new BadRequestException(e.getMessage());
        }
    }
    accountCache.evictByUsername(username);
    byEmailCache.evict(input.email);
    indexer.index(id);
    AccountLoader loader = infoLoader.create(true);
    AccountInfo info = loader.get(id);
    loader.fill();
    return Response.created(info);
}
#end_block

#method_before
@Override
public Map<String, GpgKeyInfo> apply(AccountResource rsrc, Input input) throws ResourceNotFoundException, BadRequestException, ResourceConflictException, PGPException, OrmException, IOException {
    GpgKeys.checkVisible(self, rsrc);
    List<AccountExternalId> existingExtIds = GpgKeys.getGpgExtIds(externalIdCache, rsrc.getUser().getAccountId()).toList();
    try (PublicKeyStore store = storeProvider.get()) {
        Set<Fingerprint> toRemove = readKeysToRemove(input, existingExtIds);
        List<PGPPublicKeyRing> newKeys = readKeysToAdd(input, toRemove);
        List<AccountExternalId> newExtIds = new ArrayList<>(existingExtIds.size());
        for (PGPPublicKeyRing keyRing : newKeys) {
            PGPPublicKey key = keyRing.getPublicKey();
            AccountExternalId.Key extIdKey = toExtIdKey(key.getFingerprint());
            Account account = getAccountByExternalId(extIdKey.get());
            if (account != null) {
                if (!account.getId().equals(rsrc.getUser().getAccountId())) {
                    throw new ResourceConflictException("GPG key already associated with another account");
                }
            } else {
                newExtIds.add(new AccountExternalId(rsrc.getUser().getAccountId(), extIdKey));
            }
        }
        storeKeys(rsrc, newKeys, toRemove);
        if (!newExtIds.isEmpty()) {
            db.get().accountExternalIds().insert(newExtIds);
            externalIdCache.onCreate(newExtIds);
        }
        Iterable<AccountExternalId.Key> extIdKeysToRemove = Iterables.transform(toRemove, fp -> toExtIdKey(fp.get()));
        db.get().accountExternalIds().deleteKeys(extIdKeysToRemove);
        externalIdCache.remove(rsrc.getUser().getAccountId(), extIdKeysToRemove);
        accountCache.evict(rsrc.getUser().getAccountId());
        return toJson(newKeys, toRemove, store, rsrc.getUser());
    }
}
#method_after
@Override
public Map<String, GpgKeyInfo> apply(AccountResource rsrc, Input input) throws ResourceNotFoundException, BadRequestException, ResourceConflictException, PGPException, OrmException, IOException {
    GpgKeys.checkVisible(self, rsrc);
    List<AccountExternalId> existingExtIds = GpgKeys.getGpgExtIds(externalIdCache, rsrc.getUser().getAccountId()).toList();
    try (PublicKeyStore store = storeProvider.get()) {
        Set<Fingerprint> toRemove = readKeysToRemove(input, existingExtIds);
        List<PGPPublicKeyRing> newKeys = readKeysToAdd(input, toRemove);
        List<AccountExternalId> newExtIds = new ArrayList<>(existingExtIds.size());
        for (PGPPublicKeyRing keyRing : newKeys) {
            PGPPublicKey key = keyRing.getPublicKey();
            AccountExternalId.Key extIdKey = toExtIdKey(key.getFingerprint());
            Account account = getAccountByExternalId(extIdKey.get());
            if (account != null) {
                if (!account.getId().equals(rsrc.getUser().getAccountId())) {
                    throw new ResourceConflictException("GPG key already associated with another account");
                }
            } else {
                newExtIds.add(new AccountExternalId(rsrc.getUser().getAccountId(), extIdKey));
            }
        }
        storeKeys(rsrc, newKeys, toRemove);
        if (!newExtIds.isEmpty()) {
            db.get().accountExternalIds().insert(newExtIds);
            externalIdCache.onCreate(newExtIds);
        }
        List<AccountExternalId.Key> extIdKeysToRemove = toRemove.stream().map(fp -> toExtIdKey(fp.get())).collect(toList());
        db.get().accountExternalIds().deleteKeys(extIdKeysToRemove);
        externalIdCache.onRemove(rsrc.getUser().getAccountId(), extIdKeysToRemove);
        accountCache.evict(rsrc.getUser().getAccountId());
        return toJson(newKeys, toRemove, store, rsrc.getUser());
    }
}
#end_block

#method_before
@Test
public void noExternalIds() throws Exception {
    Collection<AccountExternalId> extIds = externalIdCache.byAccount(user.getAccountId());
    db.accountExternalIds().delete(extIds);
    externalIdCache.remove(extIds);
    reloadUser();
    TestKey key = validKeyWithSecondUserId();
    PublicKeyChecker checker = checkerFactory.create(user, store).disableTrust();
    assertProblems(checker.check(key.getPublicKey()), Status.BAD, "No identities found for user; check" + " http://test/#/settings/web-identities");
    checker = checkerFactory.create().setStore(store).disableTrust();
    assertProblems(checker.check(key.getPublicKey()), Status.BAD, "Key is not associated with any users");
    AccountExternalId extId = new AccountExternalId(user.getAccountId(), toExtIdKey(key.getPublicKey()));
    db.accountExternalIds().insert(Collections.singleton(extId));
    externalIdCache.onCreate(extId);
    reloadUser();
    assertProblems(checker.check(key.getPublicKey()), Status.BAD, "No identities found for user");
}
#method_after
@Test
public void noExternalIds() throws Exception {
    Collection<AccountExternalId> extIds = externalIdCache.byAccount(user.getAccountId());
    db.accountExternalIds().delete(extIds);
    externalIdCache.onRemove(extIds);
    reloadUser();
    TestKey key = validKeyWithSecondUserId();
    PublicKeyChecker checker = checkerFactory.create(user, store).disableTrust();
    assertProblems(checker.check(key.getPublicKey()), Status.BAD, "No identities found for user; check" + " http://test/#/settings/web-identities");
    checker = checkerFactory.create().setStore(store).disableTrust();
    assertProblems(checker.check(key.getPublicKey()), Status.BAD, "Key is not associated with any users");
    AccountExternalId extId = new AccountExternalId(user.getAccountId(), toExtIdKey(key.getPublicKey()));
    db.accountExternalIds().insert(Collections.singleton(extId));
    externalIdCache.onCreate(extId);
    reloadUser();
    assertProblems(checker.check(key.getPublicKey()), Status.BAD, "No identities found for user");
}
#end_block

#method_before
@Override
public VoidResult call() throws OrmException, NameAlreadyUsedException, InvalidUserNameException, IOException {
    final Collection<AccountExternalId> old = old();
    if (!old.isEmpty()) {
        throw new IllegalStateException(USERNAME_CANNOT_BE_CHANGED);
    }
    if (newUsername != null && !newUsername.isEmpty()) {
        if (!USER_NAME_PATTERN.matcher(newUsername).matches()) {
            throw new InvalidUserNameException();
        }
        final AccountExternalId.Key key = new AccountExternalId.Key(SCHEME_USERNAME, newUsername);
        try {
            final AccountExternalId id = new AccountExternalId(user.getAccountId(), key);
            for (AccountExternalId i : old) {
                if (i.getPassword() != null) {
                    id.setPassword(i.getPassword());
                }
            }
            db.accountExternalIds().insert(Collections.singleton(id));
            externalIdCache.onCreate(id);
        } catch (OrmDuplicateKeyException dupeErr) {
            // If we are using this identity, don't report the exception.
            // 
            AccountExternalId other = db.accountExternalIds().get(key);
            if (other != null && other.getAccountId().equals(user.getAccountId())) {
                return VoidResult.INSTANCE;
            }
            // 
            throw new NameAlreadyUsedException(newUsername);
        }
    }
    // If we have any older user names, remove them.
    // 
    db.accountExternalIds().delete(old);
    externalIdCache.remove(old);
    for (AccountExternalId i : old) {
        sshKeyCache.evict(i.getSchemeRest());
        accountCache.evictByUsername(i.getSchemeRest());
    }
    accountCache.evict(user.getAccountId());
    accountCache.evictByUsername(newUsername);
    sshKeyCache.evict(newUsername);
    return VoidResult.INSTANCE;
}
#method_after
@Override
public VoidResult call() throws OrmException, NameAlreadyUsedException, InvalidUserNameException, IOException {
    final Collection<AccountExternalId> old = old();
    if (!old.isEmpty()) {
        throw new IllegalStateException(USERNAME_CANNOT_BE_CHANGED);
    }
    if (newUsername != null && !newUsername.isEmpty()) {
        if (!USER_NAME_PATTERN.matcher(newUsername).matches()) {
            throw new InvalidUserNameException();
        }
        final AccountExternalId.Key key = new AccountExternalId.Key(SCHEME_USERNAME, newUsername);
        try {
            final AccountExternalId id = new AccountExternalId(user.getAccountId(), key);
            for (AccountExternalId i : old) {
                if (i.getPassword() != null) {
                    id.setPassword(i.getPassword());
                }
            }
            db.accountExternalIds().insert(Collections.singleton(id));
            externalIdCache.onCreate(id);
        } catch (OrmDuplicateKeyException dupeErr) {
            // If we are using this identity, don't report the exception.
            // 
            AccountExternalId other = db.accountExternalIds().get(key);
            if (other != null && other.getAccountId().equals(user.getAccountId())) {
                return VoidResult.INSTANCE;
            }
            // 
            throw new NameAlreadyUsedException(newUsername);
        }
    }
    // If we have any older user names, remove them.
    // 
    db.accountExternalIds().delete(old);
    externalIdCache.onRemove(old);
    for (AccountExternalId i : old) {
        sshKeyCache.evict(i.getSchemeRest());
        accountCache.evictByUsername(i.getSchemeRest());
    }
    accountCache.evict(user.getAccountId());
    accountCache.evictByUsername(newUsername);
    sshKeyCache.evict(newUsername);
    return VoidResult.INSTANCE;
}
#end_block

#method_before
public String generateToken(String operation, AnyLongObjectId id, int expirationSeconds) {
    if (key.isPresent()) {
        try {
            byte[] initVector = new byte[IV_LENGTH];
            rndm.nextBytes(initVector);
            Cipher cipher = cipher(initVector, Cipher.ENCRYPT_MODE);
            return Base64.encodeBytes(Bytes.concat(initVector, cipher.doFinal(String.format("%s-%s-%s", operation, id.name(), timeout(expirationSeconds)).getBytes(StandardCharsets.UTF_8))));
        } catch (GeneralSecurityException e) {
            log.error("Token generation failed with error", e);
        }
    }
    return "not:required";
}
#method_after
public String generateToken(String operation, AnyLongObjectId id, int expirationSeconds) {
    try {
        byte[] initVector = new byte[IV_LENGTH];
        rndm.nextBytes(initVector);
        Cipher cipher = cipher(initVector, Cipher.ENCRYPT_MODE);
        return Base64.encodeBytes(Bytes.concat(initVector, cipher.doFinal(String.format("%s-%s-%s", operation, id.name(), timeout(expirationSeconds)).getBytes(StandardCharsets.UTF_8))));
    } catch (GeneralSecurityException e) {
        log.error("Token generation failed with error", e);
        throw new RuntimeException(e);
    }
}
#end_block

#method_before
public boolean verifyAgainstToken(String token, String operation, AnyLongObjectId id) {
    if (!key.isPresent()) {
        return true;
    }
    if (Strings.isNullOrEmpty(token)) {
        return false;
    }
    byte[] bytes = Base64.decode(token);
    byte[] initVector = Arrays.copyOf(bytes, IV_LENGTH);
    try {
        Cipher cipher = cipher(initVector, Cipher.DECRYPT_MODE);
        String data = new String(cipher.doFinal(Arrays.copyOfRange(bytes, IV_LENGTH, bytes.length)), StandardCharsets.UTF_8);
        String oid = id.name();
        String prefix = String.format("%s-%s-", operation, oid);
        return data.startsWith(prefix) && onTime(data.substring(prefix.length()), operation, oid);
    } catch (GeneralSecurityException e) {
        log.error("Exception was thrown during token verification", e);
    }
    return false;
}
#method_after
public boolean verifyAgainstToken(String token, String operation, AnyLongObjectId id) {
    if (Strings.isNullOrEmpty(token)) {
        return false;
    }
    byte[] bytes = Base64.decode(token);
    byte[] initVector = Arrays.copyOf(bytes, IV_LENGTH);
    try {
        Cipher cipher = cipher(initVector, Cipher.DECRYPT_MODE);
        String data = new String(cipher.doFinal(Arrays.copyOfRange(bytes, IV_LENGTH, bytes.length)), StandardCharsets.UTF_8);
        String oid = id.name();
        String prefix = String.format("%s-%s-", operation, oid);
        return data.startsWith(prefix) && onTime(data.substring(prefix.length()), operation, oid);
    } catch (GeneralSecurityException e) {
        log.error("Exception was thrown during token verification", e);
    }
    return false;
}
#end_block

#method_before
private boolean onTime(String dateTime, String operation, String id) {
    DateTime deadline = ISODateTimeFormat.dateTimeParser().parseDateTime(dateTime);
    if (deadline.isBeforeNow()) {
        log.info("Operation {} on id {} timed out", operation, id);
        return false;
    }
    return true;
}
#method_after
boolean onTime(String dateTime, String operation, String id) {
    String now = DATE_TIME.print(now());
    if (now.compareTo(dateTime) > 0) {
        log.info("Operation {} on id {} timed out", operation, id);
        return false;
    }
    return true;
}
#end_block

#method_before
private String timeout(int expirationSeconds) {
    DateTime now = now();
    return ISODateTimeFormat.dateTime().print(now.plusSeconds(expirationSeconds));
}
#method_after
private String timeout(int expirationSeconds) {
    return DATE_TIME.print(now().plusSeconds(expirationSeconds));
}
#end_block

#method_before
private Cipher cipher(byte[] initVector, int mode) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidParameterSpecException, InvalidKeyException, InvalidAlgorithmParameterException {
    IvParameterSpec spec = new IvParameterSpec(initVector);
    Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
    AlgorithmParameters params = AlgorithmParameters.getInstance(ALGORITHM);
    params.init(spec);
    cipher.init(mode, key.get(), params);
    return cipher;
}
#method_after
private Cipher cipher(byte[] initVector, int mode) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidParameterSpecException, InvalidKeyException, InvalidAlgorithmParameterException {
    IvParameterSpec spec = new IvParameterSpec(initVector);
    Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
    AlgorithmParameters params = AlgorithmParameters.getInstance(ALGORITHM);
    params.init(spec);
    cipher.init(mode, key, params);
    return cipher;
}
#end_block

#method_before
private Optional<SecretKey> generateKey() {
    try {
        KeyGenerator generator = KeyGenerator.getInstance(ALGORITHM);
        generator.init(128, rndm);
        return Optional.of(generator.generateKey());
    } catch (NoSuchAlgorithmException e) {
        log.error("Generating key failed with error", e);
    }
    return Optional.absent();
}
#method_after
private SecretKey generateKey() {
    try {
        KeyGenerator generator = KeyGenerator.getInstance(ALGORITHM);
        generator.init(128, rndm);
        return generator.generateKey();
    } catch (NoSuchAlgorithmException e) {
        log.error("Generating key failed with error", e);
        throw new RuntimeException(e);
    }
}
#end_block

#method_before
public Comment newComment(ChangeContext ctx, String path, PatchSet.Id psId, short side, String message) {
    Comment c = new Comment(new Comment.Key(ChangeUtil.messageUuid(), path, psId.get()), ctx.getUser().getAccountId(), ctx.getWhen(), side, message, serverId, false);
    ctx.getUser().updateRealAccountId(c::setRealAuthor);
    return c;
}
#method_after
public Comment newComment(ChangeContext ctx, String path, PatchSet.Id psId, short side, String message, @Nullable Boolean unresolved, @Nullable String parentUuid) throws OrmException, UnprocessableEntityException {
    if (unresolved == null) {
        if (parentUuid == null) {
            // Default to false if comment is not descended from another.
            unresolved = false;
        } else {
            // Inherit unresolved value from inReplyTo comment if not specified.
            Comment.Key key = new Comment.Key(parentUuid, path, psId.patchSetId);
            Optional<Comment> parent = get(ctx.getDb(), ctx.getNotes(), key);
            if (!parent.isPresent()) {
                throw new UnprocessableEntityException("Invalid parentUuid supplied for comment");
            }
            unresolved = parent.get().unresolved;
        }
    }
    Comment c = new Comment(new Comment.Key(ChangeUtil.messageUuid(), path, psId.get()), ctx.getUser().getAccountId(), ctx.getWhen(), side, message, serverId, unresolved);
    ctx.getUser().updateRealAccountId(c::setRealAuthor);
    return c;
}
#end_block

#method_before
@Test
public void draftComment() throws Exception {
    PushOneCommit.Result r = createChange();
    Change.Id id = r.getPatchSetId().getParentKey();
    putDraft(user, id, 1, "comment");
    checker.rebuildAndCheckChanges(id);
}
#method_after
@Test
public void draftComment() throws Exception {
    PushOneCommit.Result r = createChange();
    Change.Id id = r.getPatchSetId().getParentKey();
    putDraft(user, id, 1, "comment", null);
    checker.rebuildAndCheckChanges(id);
}
#end_block

#method_before
@Test
public void draftAndPublishedComment() throws Exception {
    PushOneCommit.Result r = createChange();
    Change.Id id = r.getPatchSetId().getParentKey();
    putDraft(user, id, 1, "draft comment");
    putComment(user, id, 1, "published comment");
    checker.rebuildAndCheckChanges(id);
}
#method_after
@Test
public void draftAndPublishedComment() throws Exception {
    PushOneCommit.Result r = createChange();
    Change.Id id = r.getPatchSetId().getParentKey();
    putDraft(user, id, 1, "draft comment", null);
    putComment(user, id, 1, "published comment");
    checker.rebuildAndCheckChanges(id);
}
#end_block

#method_before
@Test
public void publishDraftComment() throws Exception {
    PushOneCommit.Result r = createChange();
    Change.Id id = r.getPatchSetId().getParentKey();
    putDraft(user, id, 1, "draft comment");
    publishDrafts(user, id);
    checker.rebuildAndCheckChanges(id);
}
#method_after
@Test
public void publishDraftComment() throws Exception {
    PushOneCommit.Result r = createChange();
    Change.Id id = r.getPatchSetId().getParentKey();
    putDraft(user, id, 1, "draft comment", null);
    publishDrafts(user, id);
    checker.rebuildAndCheckChanges(id);
}
#end_block

#method_before
@Test
public void noteDbChangeState() throws Exception {
    setNotesMigration(true, true);
    PushOneCommit.Result r = createChange();
    Change.Id id = r.getPatchSetId().getParentKey();
    ObjectId changeMetaId = getMetaRef(project, changeMetaRef(id));
    assertThat(getUnwrappedDb().changes().get(id).getNoteDbState()).isEqualTo(changeMetaId.name());
    putDraft(user, id, 1, "comment by user");
    ObjectId userDraftsId = getMetaRef(allUsers, refsDraftComments(id, user.getId()));
    assertThat(getUnwrappedDb().changes().get(id).getNoteDbState()).isEqualTo(changeMetaId.name() + "," + user.getId() + "=" + userDraftsId.name());
    putDraft(admin, id, 2, "comment by admin");
    ObjectId adminDraftsId = getMetaRef(allUsers, refsDraftComments(id, admin.getId()));
    assertThat(admin.getId().get()).isLessThan(user.getId().get());
    assertThat(getUnwrappedDb().changes().get(id).getNoteDbState()).isEqualTo(changeMetaId.name() + "," + admin.getId() + "=" + adminDraftsId.name() + "," + user.getId() + "=" + userDraftsId.name());
    putDraft(admin, id, 2, "revised comment by admin");
    adminDraftsId = getMetaRef(allUsers, refsDraftComments(id, admin.getId()));
    assertThat(getUnwrappedDb().changes().get(id).getNoteDbState()).isEqualTo(changeMetaId.name() + "," + admin.getId() + "=" + adminDraftsId.name() + "," + user.getId() + "=" + userDraftsId.name());
}
#method_after
@Test
public void noteDbChangeState() throws Exception {
    setNotesMigration(true, true);
    PushOneCommit.Result r = createChange();
    Change.Id id = r.getPatchSetId().getParentKey();
    ObjectId changeMetaId = getMetaRef(project, changeMetaRef(id));
    assertThat(getUnwrappedDb().changes().get(id).getNoteDbState()).isEqualTo(changeMetaId.name());
    putDraft(user, id, 1, "comment by user", null);
    ObjectId userDraftsId = getMetaRef(allUsers, refsDraftComments(id, user.getId()));
    assertThat(getUnwrappedDb().changes().get(id).getNoteDbState()).isEqualTo(changeMetaId.name() + "," + user.getId() + "=" + userDraftsId.name());
    putDraft(admin, id, 2, "comment by admin", null);
    ObjectId adminDraftsId = getMetaRef(allUsers, refsDraftComments(id, admin.getId()));
    assertThat(admin.getId().get()).isLessThan(user.getId().get());
    assertThat(getUnwrappedDb().changes().get(id).getNoteDbState()).isEqualTo(changeMetaId.name() + "," + admin.getId() + "=" + adminDraftsId.name() + "," + user.getId() + "=" + userDraftsId.name());
    putDraft(admin, id, 2, "revised comment by admin", null);
    adminDraftsId = getMetaRef(allUsers, refsDraftComments(id, admin.getId()));
    assertThat(getUnwrappedDb().changes().get(id).getNoteDbState()).isEqualTo(changeMetaId.name() + "," + admin.getId() + "=" + adminDraftsId.name() + "," + user.getId() + "=" + userDraftsId.name());
}
#end_block

#method_before
@Test
public void rebuildReturnsDraftResultWhenRebuildingInChangeNotesFails() throws Exception {
    setNotesMigration(true, true);
    PushOneCommit.Result r = createChange();
    Change.Id id = r.getPatchSetId().getParentKey();
    putDraft(user, id, 1, "comment by user");
    assertChangeUpToDate(true, id);
    ObjectId oldMetaId = getMetaRef(allUsers, refsDraftComments(id, user.getId()));
    // Add a draft behind NoteDb's back.
    setNotesMigration(false, false);
    putDraft(user, id, 1, "second comment by user");
    setInvalidNoteDbState(id);
    assertDraftsUpToDate(false, id, user);
    assertThat(getMetaRef(allUsers, refsDraftComments(id, user.getId()))).isEqualTo(oldMetaId);
    // Force the next rebuild attempt to fail (in ChangeNotes).
    rebuilderWrapper.failNextUpdate();
    setNotesMigration(true, true);
    ChangeNotes notes = notesFactory.create(dbProvider.get(), project, id);
    notes.getDraftComments(user.getId());
    assertThat(getMetaRef(allUsers, refsDraftComments(id, user.getId()))).isEqualTo(oldMetaId);
    // Not up to date, but the actual returned state matches anyway.
    assertDraftsUpToDate(false, id, user);
    ChangeBundle actual = ChangeBundle.fromNotes(commentsUtil, notes);
    ChangeBundle expected = bundleReader.fromReviewDb(getUnwrappedDb(), id);
    assertThat(actual.differencesFrom(expected)).isEmpty();
    // Another rebuild attempt succeeds
    notesFactory.create(dbProvider.get(), project, id);
    assertChangeUpToDate(true, id);
    assertDraftsUpToDate(true, id, user);
    assertThat(getMetaRef(allUsers, refsDraftComments(id, user.getId()))).isNotEqualTo(oldMetaId);
}
#method_after
@Test
public void rebuildReturnsDraftResultWhenRebuildingInChangeNotesFails() throws Exception {
    setNotesMigration(true, true);
    PushOneCommit.Result r = createChange();
    Change.Id id = r.getPatchSetId().getParentKey();
    putDraft(user, id, 1, "comment by user", null);
    assertChangeUpToDate(true, id);
    ObjectId oldMetaId = getMetaRef(allUsers, refsDraftComments(id, user.getId()));
    // Add a draft behind NoteDb's back.
    setNotesMigration(false, false);
    putDraft(user, id, 1, "second comment by user", null);
    setInvalidNoteDbState(id);
    assertDraftsUpToDate(false, id, user);
    assertThat(getMetaRef(allUsers, refsDraftComments(id, user.getId()))).isEqualTo(oldMetaId);
    // Force the next rebuild attempt to fail (in ChangeNotes).
    rebuilderWrapper.failNextUpdate();
    setNotesMigration(true, true);
    ChangeNotes notes = notesFactory.create(dbProvider.get(), project, id);
    notes.getDraftComments(user.getId());
    assertThat(getMetaRef(allUsers, refsDraftComments(id, user.getId()))).isEqualTo(oldMetaId);
    // Not up to date, but the actual returned state matches anyway.
    assertDraftsUpToDate(false, id, user);
    ChangeBundle actual = ChangeBundle.fromNotes(commentsUtil, notes);
    ChangeBundle expected = bundleReader.fromReviewDb(getUnwrappedDb(), id);
    assertThat(actual.differencesFrom(expected)).isEmpty();
    // Another rebuild attempt succeeds
    notesFactory.create(dbProvider.get(), project, id);
    assertChangeUpToDate(true, id);
    assertDraftsUpToDate(true, id, user);
    assertThat(getMetaRef(allUsers, refsDraftComments(id, user.getId()))).isNotEqualTo(oldMetaId);
}
#end_block

#method_before
@Test
public void rebuildReturnsDraftResultWhenRebuildingInDraftCommentNotesFails() throws Exception {
    setNotesMigration(true, true);
    PushOneCommit.Result r = createChange();
    Change.Id id = r.getPatchSetId().getParentKey();
    putDraft(user, id, 1, "comment by user");
    assertChangeUpToDate(true, id);
    ObjectId oldMetaId = getMetaRef(allUsers, refsDraftComments(id, user.getId()));
    // Add a draft behind NoteDb's back.
    setNotesMigration(false, false);
    putDraft(user, id, 1, "second comment by user");
    ReviewDb db = getUnwrappedDb();
    Change c = db.changes().get(id);
    // Leave change meta ID alone so DraftCommentNotes does the rebuild.
    ObjectId badSha = ObjectId.fromString("deadbeefdeadbeefdeadbeefdeadbeefdeadbeef");
    NoteDbChangeState bogusState = new NoteDbChangeState(id, PrimaryStorage.REVIEW_DB, Optional.of(NoteDbChangeState.RefState.create(NoteDbChangeState.parse(c).getChangeMetaId(), ImmutableMap.of(user.getId(), badSha))));
    c.setNoteDbState(bogusState.toString());
    db.changes().update(Collections.singleton(c));
    assertDraftsUpToDate(false, id, user);
    assertThat(getMetaRef(allUsers, refsDraftComments(id, user.getId()))).isEqualTo(oldMetaId);
    // Force the next rebuild attempt to fail (in DraftCommentNotes).
    rebuilderWrapper.failNextUpdate();
    setNotesMigration(true, true);
    ChangeNotes notes = notesFactory.create(dbProvider.get(), project, id);
    notes.getDraftComments(user.getId());
    assertThat(getMetaRef(allUsers, refsDraftComments(id, user.getId()))).isEqualTo(oldMetaId);
    // Not up to date, but the actual returned state matches anyway.
    assertChangeUpToDate(true, id);
    assertDraftsUpToDate(false, id, user);
    ChangeBundle actual = ChangeBundle.fromNotes(commentsUtil, notes);
    ChangeBundle expected = bundleReader.fromReviewDb(getUnwrappedDb(), id);
    assertThat(actual.differencesFrom(expected)).isEmpty();
    // Another rebuild attempt succeeds
    notesFactory.create(dbProvider.get(), project, id).getDraftComments(user.getId());
    assertChangeUpToDate(true, id);
    assertDraftsUpToDate(true, id, user);
    assertThat(getMetaRef(allUsers, refsDraftComments(id, user.getId()))).isNotEqualTo(oldMetaId);
}
#method_after
@Test
public void rebuildReturnsDraftResultWhenRebuildingInDraftCommentNotesFails() throws Exception {
    setNotesMigration(true, true);
    PushOneCommit.Result r = createChange();
    Change.Id id = r.getPatchSetId().getParentKey();
    putDraft(user, id, 1, "comment by user", null);
    assertChangeUpToDate(true, id);
    ObjectId oldMetaId = getMetaRef(allUsers, refsDraftComments(id, user.getId()));
    // Add a draft behind NoteDb's back.
    setNotesMigration(false, false);
    putDraft(user, id, 1, "second comment by user", null);
    ReviewDb db = getUnwrappedDb();
    Change c = db.changes().get(id);
    // Leave change meta ID alone so DraftCommentNotes does the rebuild.
    ObjectId badSha = ObjectId.fromString("deadbeefdeadbeefdeadbeefdeadbeefdeadbeef");
    NoteDbChangeState bogusState = new NoteDbChangeState(id, PrimaryStorage.REVIEW_DB, Optional.of(NoteDbChangeState.RefState.create(NoteDbChangeState.parse(c).getChangeMetaId(), ImmutableMap.of(user.getId(), badSha))));
    c.setNoteDbState(bogusState.toString());
    db.changes().update(Collections.singleton(c));
    assertDraftsUpToDate(false, id, user);
    assertThat(getMetaRef(allUsers, refsDraftComments(id, user.getId()))).isEqualTo(oldMetaId);
    // Force the next rebuild attempt to fail (in DraftCommentNotes).
    rebuilderWrapper.failNextUpdate();
    setNotesMigration(true, true);
    ChangeNotes notes = notesFactory.create(dbProvider.get(), project, id);
    notes.getDraftComments(user.getId());
    assertThat(getMetaRef(allUsers, refsDraftComments(id, user.getId()))).isEqualTo(oldMetaId);
    // Not up to date, but the actual returned state matches anyway.
    assertChangeUpToDate(true, id);
    assertDraftsUpToDate(false, id, user);
    ChangeBundle actual = ChangeBundle.fromNotes(commentsUtil, notes);
    ChangeBundle expected = bundleReader.fromReviewDb(getUnwrappedDb(), id);
    assertThat(actual.differencesFrom(expected)).isEmpty();
    // Another rebuild attempt succeeds
    notesFactory.create(dbProvider.get(), project, id).getDraftComments(user.getId());
    assertChangeUpToDate(true, id);
    assertDraftsUpToDate(true, id, user);
    assertThat(getMetaRef(allUsers, refsDraftComments(id, user.getId()))).isNotEqualTo(oldMetaId);
}
#end_block

#method_before
@Test
public void rebuildAutomaticallyWhenDraftsOutOfDate() throws Exception {
    setNotesMigration(true, true);
    setApiUser(user);
    PushOneCommit.Result r = createChange();
    Change.Id id = r.getPatchSetId().getParentKey();
    putDraft(user, id, 1, "comment");
    assertDraftsUpToDate(true, id, user);
    // Make a ReviewDb change behind NoteDb's back and ensure it's detected.
    setNotesMigration(false, false);
    putDraft(user, id, 1, "comment");
    setInvalidNoteDbState(id);
    assertDraftsUpToDate(false, id, user);
    // On next NoteDb read, the drafts are transparently rebuilt.
    setNotesMigration(true, true);
    assertThat(gApi.changes().id(id.get()).current().drafts()).containsKey(PushOneCommit.FILE_NAME);
    assertDraftsUpToDate(true, id, user);
}
#method_after
@Test
public void rebuildAutomaticallyWhenDraftsOutOfDate() throws Exception {
    setNotesMigration(true, true);
    setApiUser(user);
    PushOneCommit.Result r = createChange();
    Change.Id id = r.getPatchSetId().getParentKey();
    putDraft(user, id, 1, "comment", null);
    assertDraftsUpToDate(true, id, user);
    // Make a ReviewDb change behind NoteDb's back and ensure it's detected.
    setNotesMigration(false, false);
    putDraft(user, id, 1, "comment", null);
    setInvalidNoteDbState(id);
    assertDraftsUpToDate(false, id, user);
    // On next NoteDb read, the drafts are transparently rebuilt.
    setNotesMigration(true, true);
    assertThat(gApi.changes().id(id.get()).current().drafts()).containsKey(PushOneCommit.FILE_NAME);
    assertDraftsUpToDate(true, id, user);
}
#end_block

#method_before
@Test
public void rebuildDeletesOldDraftRefs() throws Exception {
    PushOneCommit.Result r = createChange();
    Change.Id id = r.getPatchSetId().getParentKey();
    putDraft(user, id, 1, "comment");
    Account.Id otherAccountId = new Account.Id(user.getId().get() + 1234);
    String otherDraftRef = refsDraftComments(id, otherAccountId);
    try (Repository repo = repoManager.openRepository(allUsers);
        ObjectInserter ins = repo.newObjectInserter()) {
        ObjectId sha = ins.insert(OBJ_BLOB, "garbage data".getBytes(UTF_8));
        ins.flush();
        RefUpdate ru = repo.updateRef(otherDraftRef);
        ru.setExpectedOldObjectId(ObjectId.zeroId());
        ru.setNewObjectId(sha);
        assertThat(ru.update()).isEqualTo(RefUpdate.Result.NEW);
    }
    checker.rebuildAndCheckChanges(id);
    try (Repository repo = repoManager.openRepository(allUsers)) {
        assertThat(repo.exactRef(otherDraftRef)).isNull();
    }
}
#method_after
@Test
public void rebuildDeletesOldDraftRefs() throws Exception {
    PushOneCommit.Result r = createChange();
    Change.Id id = r.getPatchSetId().getParentKey();
    putDraft(user, id, 1, "comment", null);
    Account.Id otherAccountId = new Account.Id(user.getId().get() + 1234);
    String otherDraftRef = refsDraftComments(id, otherAccountId);
    try (Repository repo = repoManager.openRepository(allUsers);
        ObjectInserter ins = repo.newObjectInserter()) {
        ObjectId sha = ins.insert(OBJ_BLOB, "garbage data".getBytes(UTF_8));
        ins.flush();
        RefUpdate ru = repo.updateRef(otherDraftRef);
        ru.setExpectedOldObjectId(ObjectId.zeroId());
        ru.setNewObjectId(sha);
        assertThat(ru.update()).isEqualTo(RefUpdate.Result.NEW);
    }
    checker.rebuildAndCheckChanges(id);
    try (Repository repo = repoManager.openRepository(allUsers)) {
        assertThat(repo.exactRef(otherDraftRef)).isNull();
    }
}
#end_block

#method_before
private void putDraft(TestAccount account, Change.Id id, int line, String msg) throws Exception {
    DraftInput in = new DraftInput();
    in.line = line;
    in.message = msg;
    in.path = PushOneCommit.FILE_NAME;
    AcceptanceTestRequestScope.Context old = setApiUser(account);
    try {
        gApi.changes().id(id.get()).current().createDraft(in);
    } finally {
        atrScope.set(old);
    }
}
#method_after
private void putDraft(TestAccount account, Change.Id id, int line, String msg, Boolean unresolved) throws Exception {
    DraftInput in = new DraftInput();
    in.line = line;
    in.message = msg;
    in.path = PushOneCommit.FILE_NAME;
    in.unresolved = unresolved;
    AcceptanceTestRequestScope.Context old = setApiUser(account);
    try {
        gApi.changes().id(id.get()).current().createDraft(in);
    } finally {
        atrScope.set(old);
    }
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, ResourceConflictException {
    user = ctx.getIdentifiedUser();
    notes = ctx.getNotes();
    ps = psUtil.get(ctx.getDb(), ctx.getNotes(), psId);
    boolean dirty = false;
    dirty |= insertComments(ctx);
    dirty |= insertRobotComments(ctx);
    dirty |= updateLabels(ctx);
    dirty |= insertMessage(ctx);
    return dirty;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, ResourceConflictException, UnprocessableEntityException {
    user = ctx.getIdentifiedUser();
    notes = ctx.getNotes();
    ps = psUtil.get(ctx.getDb(), ctx.getNotes(), psId);
    boolean dirty = false;
    dirty |= insertComments(ctx);
    dirty |= insertRobotComments(ctx);
    dirty |= updateLabels(ctx);
    dirty |= insertMessage(ctx);
    return dirty;
}
#end_block

#method_before
private boolean insertComments(ChangeContext ctx) throws OrmException {
    Map<String, List<CommentInput>> map = in.comments;
    if (map == null) {
        map = Collections.emptyMap();
    }
    Map<String, Comment> drafts = Collections.emptyMap();
    if (!map.isEmpty() || in.drafts != DraftHandling.KEEP) {
        if (in.drafts == DraftHandling.PUBLISH_ALL_REVISIONS) {
            drafts = changeDrafts(ctx);
        } else {
            drafts = patchSetDrafts(ctx);
        }
    }
    List<Comment> toDel = new ArrayList<>();
    List<Comment> toPublish = new ArrayList<>();
    Set<CommentSetEntry> existingIds = in.omitDuplicateComments ? readExistingComments(ctx) : Collections.emptySet();
    for (Map.Entry<String, List<CommentInput>> ent : map.entrySet()) {
        String path = ent.getKey();
        for (CommentInput c : ent.getValue()) {
            String parent = Url.decode(c.inReplyTo);
            Comment e = drafts.remove(Url.decode(c.id));
            if (e == null) {
                e = commentsUtil.newComment(ctx, path, psId, c.side(), c.message);
            } else {
                e.writtenOn = ctx.getWhen();
                e.side = c.side();
                e.message = c.message;
            }
            if (parent != null) {
                e.parentUuid = parent;
            }
            setCommentRevId(e, patchListCache, ctx.getChange(), ps);
            e.setLineNbrAndRange(c.line, c.range);
            e.tag = in.tag;
            if (existingIds.contains(CommentSetEntry.create(e))) {
                continue;
            }
            toPublish.add(e);
        }
    }
    switch(in.drafts) {
        case KEEP:
        default:
            break;
        case DELETE:
            toDel.addAll(drafts.values());
            break;
        case PUBLISH:
            for (Comment e : drafts.values()) {
                toPublish.add(publishComment(ctx, e, ps));
            }
            break;
        case PUBLISH_ALL_REVISIONS:
            publishAllRevisions(ctx, drafts, toPublish);
            break;
    }
    ChangeUpdate u = ctx.getUpdate(psId);
    commentsUtil.deleteComments(ctx.getDb(), u, toDel);
    commentsUtil.putComments(ctx.getDb(), u, Status.PUBLISHED, toPublish);
    comments.addAll(toPublish);
    return !toDel.isEmpty() || !toPublish.isEmpty();
}
#method_after
private boolean insertComments(ChangeContext ctx) throws OrmException, UnprocessableEntityException {
    Map<String, List<CommentInput>> map = in.comments;
    if (map == null) {
        map = Collections.emptyMap();
    }
    Map<String, Comment> drafts = Collections.emptyMap();
    if (!map.isEmpty() || in.drafts != DraftHandling.KEEP) {
        if (in.drafts == DraftHandling.PUBLISH_ALL_REVISIONS) {
            drafts = changeDrafts(ctx);
        } else {
            drafts = patchSetDrafts(ctx);
        }
    }
    List<Comment> toDel = new ArrayList<>();
    List<Comment> toPublish = new ArrayList<>();
    Set<CommentSetEntry> existingIds = in.omitDuplicateComments ? readExistingComments(ctx) : Collections.emptySet();
    for (Map.Entry<String, List<CommentInput>> ent : map.entrySet()) {
        String path = ent.getKey();
        for (CommentInput c : ent.getValue()) {
            String parent = Url.decode(c.inReplyTo);
            Comment e = drafts.remove(Url.decode(c.id));
            if (e == null) {
                e = commentsUtil.newComment(ctx, path, psId, c.side(), c.message, c.unresolved, parent);
            } else {
                e.writtenOn = ctx.getWhen();
                e.side = c.side();
                e.message = c.message;
            }
            setCommentRevId(e, patchListCache, ctx.getChange(), ps);
            e.setLineNbrAndRange(c.line, c.range);
            e.tag = in.tag;
            if (existingIds.contains(CommentSetEntry.create(e))) {
                continue;
            }
            toPublish.add(e);
        }
    }
    switch(in.drafts) {
        case KEEP:
        default:
            break;
        case DELETE:
            toDel.addAll(drafts.values());
            break;
        case PUBLISH:
            for (Comment e : drafts.values()) {
                toPublish.add(publishComment(ctx, e, ps));
            }
            break;
        case PUBLISH_ALL_REVISIONS:
            publishAllRevisions(ctx, drafts, toPublish);
            break;
    }
    ChangeUpdate u = ctx.getUpdate(psId);
    commentsUtil.deleteComments(ctx.getDb(), u, toDel);
    commentsUtil.putComments(ctx.getDb(), u, Status.PUBLISHED, toPublish);
    comments.addAll(toPublish);
    return !toDel.isEmpty() || !toPublish.isEmpty();
}
#end_block

#method_before
@Override
public String[] getList(String section, String subsection, String name) {
    return FluentIterable.from(Arrays.asList(sec.getStringList(section, subsection, name))).transform(decode).toArray(String.class);
}
#method_after
@Override
public String[] getList(String section, String subsection, String name) {
    return FluentIterable.from(Arrays.asList(sec.getStringList(section, subsection, name))).transform(codec.decodeFun).toArray(String.class);
}
#end_block

#method_before
@Override
public synchronized String[] getListForPlugin(String pluginName, String section, String subsection, String name) {
    FileBasedConfig cfg = null;
    if (pluginSec.containsKey(pluginName)) {
        cfg = pluginSec.get(pluginName);
    } else {
        String filename = pluginName + ".secure.config";
        File pluginConfigFile = site.etc_dir.resolve(filename).toFile();
        if (pluginConfigFile.exists()) {
            cfg = new FileBasedConfig(pluginConfigFile, FS.DETECTED);
            try {
                cfg.load();
                pluginSec.put(pluginName, cfg);
            } catch (IOException | ConfigInvalidException e) {
                throw new RuntimeException("Cannot load " + filename, e);
            }
        }
    }
    return cfg != null ? FluentIterable.from(Arrays.asList(cfg.getStringList(section, subsection, name))).transform(decode).toArray(String.class) : null;
}
#method_after
@Override
public synchronized String[] getListForPlugin(String pluginName, String section, String subsection, String name) {
    FileBasedConfig cfg = null;
    if (pluginSec.containsKey(pluginName)) {
        cfg = pluginSec.get(pluginName);
    } else {
        String filename = pluginName + ".secure.config";
        File pluginConfigFile = site.etc_dir.resolve(filename).toFile();
        if (pluginConfigFile.exists()) {
            cfg = new FileBasedConfig(pluginConfigFile, FS.DETECTED);
            try {
                cfg.load();
                pluginSec.put(pluginName, cfg);
            } catch (IOException | ConfigInvalidException e) {
                throw new RuntimeException("Cannot load " + filename, e);
            }
        }
    }
    return cfg != null ? FluentIterable.from(Arrays.asList(cfg.getStringList(section, subsection, name))).transform(codec.decodeFun).toArray(String.class) : null;
}
#end_block

#method_before
@Override
public void setList(String section, String subsection, String name, List<String> values) {
    if (values != null) {
        sec.setStringList(section, subsection, name, FluentIterable.from(values).transform(encode).toList());
    } else {
        sec.unset(section, subsection, name);
    }
    save();
}
#method_after
@Override
public void setList(String section, String subsection, String name, List<String> values) {
    if (values != null) {
        sec.setStringList(section, subsection, name, FluentIterable.from(values).transform(codec.encodeFun).toList());
    } else {
        sec.unset(section, subsection, name);
    }
    save();
}
#end_block

#method_before
@Override
public Map<String, List<RobotCommentInfo>> robotComments() throws RestApiException {
    try {
        return listChangeRobotComments.apply(change);
    } catch (OrmException e) {
        throw new RestApiException("Cannot get comments", e);
    }
}
#method_after
@Override
public Map<String, List<RobotCommentInfo>> robotComments() throws RestApiException {
    try {
        return listChangeRobotComments.apply(change);
    } catch (OrmException e) {
        throw new RestApiException("Cannot get robot comments", e);
    }
}
#end_block

#method_before
@Test
public void addedRobotCommentsCanBeRetrievedByChange() throws Exception {
    assume().that(notesMigration.enabled()).isTrue();
    RobotCommentInput in = createRobotCommentInput();
    addRobotComment(changeId, in);
    Map<String, List<RobotCommentInfo>> out = gApi.changes().id(changeId).robotComments();
    assertThat(out).hasSize(1);
    RobotCommentInfo comment = Iterables.getOnlyElement(out.get(in.path));
    assertRobotComment(comment, in, false);
}
#method_after
@Test
public void addedRobotCommentsCanBeRetrievedByChange() throws Exception {
    assume().that(notesMigration.enabled()).isTrue();
    RobotCommentInput in = createRobotCommentInput();
    addRobotComment(changeId, in);
    pushFactory.create(db, admin.getIdent(), testRepo, changeId).to("refs/for/master");
    RobotCommentInput in2 = createRobotCommentInput();
    addRobotComment(changeId, in2);
    Map<String, List<RobotCommentInfo>> out = gApi.changes().id(changeId).robotComments();
    assertThat(out).hasSize(1);
    assertThat(out.get(in.path)).hasSize(2);
    RobotCommentInfo comment1 = out.get(in.path).get(0);
    assertRobotComment(comment1, in, false);
    RobotCommentInfo comment2 = out.get(in.path).get(1);
    assertRobotComment(comment2, in2, false);
}
#end_block

#method_before
private Collection<AccountInfo> removableReviewers(ChangeControl ctl, ChangeInfo out) {
    Collection<LabelInfo> labels = out.labels.values();
    Set<Account.Id> fixed = Sets.newHashSetWithExpectedSize(labels.size());
    Set<Account.Id> removable = Sets.newHashSetWithExpectedSize(labels.size());
    for (LabelInfo label : labels) {
        if (label.all == null) {
            continue;
        }
        for (ApprovalInfo ai : label.all) {
            Account.Id id = new Account.Id(ai._accountId);
            if (ctl.canRemoveReviewer(id, MoreObjects.firstNonNull(ai.value, 0))) {
                removable.add(id);
            } else {
                fixed.add(id);
            }
        }
    }
    removable.removeAll(fixed);
    Collection<AccountInfo> ccs = out.reviewers.get(ReviewerState.CC);
    if (ccs != null) {
        for (AccountInfo ai : ccs) {
            Account.Id id = new Account.Id(ai._accountId);
            if (ctl.canRemoveReviewer(id, 0)) {
                removable.add(id);
            }
        }
    }
    List<AccountInfo> result = Lists.newArrayListWithCapacity(removable.size());
    for (Account.Id id : removable) {
        result.add(accountLoader.get(id));
    }
    return result;
}
#method_after
private Collection<AccountInfo> removableReviewers(ChangeControl ctl, ChangeInfo out) {
    // Although this is called removableReviewers, this method also determines
    // which CCs are removable.
    // 
    // For reviewers, we need to look at each approval, because the reviewer
    // should only be considered removable if *all* of their approvals can be
    // removed. First, add all reviewers with *any* removable approval to the
    // "removable" set. Along the way, if we encounter a non-removable approval,
    // add the reviewer to the "fixed" set. Before we return, remove all members
    // of "fixed" from "removable", because not all of their approvals can be
    // removed.
    Collection<LabelInfo> labels = out.labels.values();
    Set<Account.Id> fixed = Sets.newHashSetWithExpectedSize(labels.size());
    Set<Account.Id> removable = Sets.newHashSetWithExpectedSize(labels.size());
    for (LabelInfo label : labels) {
        if (label.all == null) {
            continue;
        }
        for (ApprovalInfo ai : label.all) {
            Account.Id id = new Account.Id(ai._accountId);
            if (ctl.canRemoveReviewer(id, MoreObjects.firstNonNull(ai.value, 0))) {
                removable.add(id);
            } else {
                fixed.add(id);
            }
        }
    }
    // CCs are simpler than reviewers. They are removable if the ChangeControl
    // would permit a non-negative approval by that account to be removed, in
    // which case add them to removable. We don't need to add unremovable CCs to
    // "fixed" because we only visit each CC once here.
    Collection<AccountInfo> ccs = out.reviewers.get(ReviewerState.CC);
    if (ccs != null) {
        for (AccountInfo ai : ccs) {
            Account.Id id = new Account.Id(ai._accountId);
            if (ctl.canRemoveReviewer(id, 0)) {
                removable.add(id);
            }
        }
    }
    // Subtract any reviewers with non-removable approvals from the "removable"
    // set. This also subtracts any CCs that for some reason also hold
    // unremovable approvals.
    removable.removeAll(fixed);
    List<AccountInfo> result = Lists.newArrayListWithCapacity(removable.size());
    for (Account.Id id : removable) {
        result.add(accountLoader.get(id));
    }
    return result;
}
#end_block

#method_before
CommitInfo toCommit(ChangeControl ctl, RevWalk rw, RevCommit commit, boolean addLinks, boolean fillCommit) throws IOException {
    Project.NameKey project = ctl.getProject().getNameKey();
    CommitInfo info = new CommitInfo();
    if (fillCommit) {
        info.commit = commit.name();
    }
    info.parents = new ArrayList<>(commit.getParentCount());
    info.author = toGitPerson(commit.getAuthorIdent());
    info.committer = toGitPerson(commit.getCommitterIdent());
    info.subject = commit.getShortMessage();
    info.message = commit.getFullMessage();
    if (addLinks) {
        FluentIterable<WebLinkInfo> links = webLinks.getPatchSetLinks(project, commit.name());
        info.webLinks = links.isEmpty() ? null : links.toList();
    }
    for (RevCommit parent : commit.getParents()) {
        rw.parseBody(parent);
        CommitInfo i = new CommitInfo();
        i.commit = parent.name();
        i.subject = parent.getShortMessage();
        if (addLinks) {
            FluentIterable<WebLinkInfo> parentLinks = webLinks.getPatchSetLinks(project, parent.name());
            i.webLinks = parentLinks.isEmpty() ? null : parentLinks.toList();
        }
        info.parents.add(i);
    }
    return info;
}
#method_after
CommitInfo toCommit(ChangeControl ctl, RevWalk rw, RevCommit commit, boolean addLinks, boolean fillCommit) throws IOException {
    Project.NameKey project = ctl.getProject().getNameKey();
    CommitInfo info = new CommitInfo();
    if (fillCommit) {
        info.commit = commit.name();
    }
    info.parents = new ArrayList<>(commit.getParentCount());
    info.author = toGitPerson(commit.getAuthorIdent());
    info.committer = toGitPerson(commit.getCommitterIdent());
    info.subject = commit.getShortMessage();
    info.message = commit.getFullMessage();
    if (addLinks) {
        List<WebLinkInfo> links = webLinks.getPatchSetLinks(project, commit.name());
        info.webLinks = links.isEmpty() ? null : links;
    }
    for (RevCommit parent : commit.getParents()) {
        rw.parseBody(parent);
        CommitInfo i = new CommitInfo();
        i.commit = parent.name();
        i.subject = parent.getShortMessage();
        if (addLinks) {
            List<WebLinkInfo> parentLinks = webLinks.getParentLinks(project, parent.name());
            i.webLinks = parentLinks.isEmpty() ? null : parentLinks;
        }
        info.parents.add(i);
    }
    return info;
}
#end_block

#method_before
@Override
protected void configure() {
    bind(IndexRewriter.class);
    bind(AccountIndexCollection.class);
    listener().to(AccountIndexCollection.class);
    factory(AccountIndexer.Factory.class);
    bind(ChangeIndexCollection.class);
    listener().to(ChangeIndexCollection.class);
    factory(ChangeIndexer.Factory.class);
}
#method_after
@Override
protected void configure() {
    bind(IndexRewriter.class);
    bind(AccountIndexCollection.class);
    listener().to(AccountIndexCollection.class);
    bind(ChangeIndexCollection.class);
    listener().to(ChangeIndexCollection.class);
    factory(ChangeIndexer.Factory.class);
}
#end_block

#method_before
@Override
public void evict(Account.Id accountId) throws IOException {
    if (accountId != null) {
        byId.invalidate(accountId);
        indexer.get().index(accountId);
    }
}
#method_after
@Override
public void evict(Account.Id accountId) throws IOException {
    if (accountId != null) {
        byId.invalidate(accountId);
        index(accountId);
    }
}
#end_block

#method_before
public List<WebLinkInfo> getFileHistoryLinks(String project, String revision, String file) {
    return filterLinks(fileHistoryLinks, webLink -> webLink.getFileHistoryWebLink(project, revision, file));
}
#method_after
public List<WebLinkInfoCommon> getFileHistoryLinks(String project, String revision, String file) {
    return FluentIterable.from(fileHistoryLinks).transform(webLink -> {
        WebLinkInfo info = webLink.getFileHistoryWebLink(project, revision, file);
        if (info == null) {
            return null;
        }
        WebLinkInfoCommon commonInfo = new WebLinkInfoCommon();
        commonInfo.name = info.name;
        commonInfo.imageUrl = info.imageUrl;
        commonInfo.url = info.url;
        commonInfo.target = info.target;
        return commonInfo;
    }).filter(INVALID_WEBLINK_COMMON).toList();
}
#end_block

#method_before
private List<WebLinkInfoCommon> getConfigFileLogLinks(String projectName) {
    List<WebLinkInfoCommon> links = webLinks.getFileHistoryLinksCommon(projectName, RefNames.REFS_CONFIG, ProjectConfig.PROJECT_CONFIG);
    return links.isEmpty() ? null : links;
}
#method_after
private List<WebLinkInfoCommon> getConfigFileLogLinks(String projectName) {
    List<WebLinkInfoCommon> links = webLinks.getFileHistoryLinks(projectName, RefNames.REFS_CONFIG, ProjectConfig.PROJECT_CONFIG);
    return links.isEmpty() ? null : links;
}
#end_block

#method_before
CommitInfo toCommit(ChangeControl ctl, RevWalk rw, RevCommit commit, boolean addLinks, boolean fillCommit) throws IOException {
    Project.NameKey project = ctl.getProject().getNameKey();
    CommitInfo info = new CommitInfo();
    if (fillCommit) {
        info.commit = commit.name();
    }
    info.parents = new ArrayList<>(commit.getParentCount());
    info.author = toGitPerson(commit.getAuthorIdent());
    info.committer = toGitPerson(commit.getCommitterIdent());
    info.subject = commit.getShortMessage();
    info.message = commit.getFullMessage();
    if (addLinks) {
        List<WebLinkInfo> links = webLinks.getPatchSetLinks(project, commit.name());
        info.webLinks = links.isEmpty() ? null : links;
    }
    for (RevCommit parent : commit.getParents()) {
        rw.parseBody(parent);
        CommitInfo i = new CommitInfo();
        i.commit = parent.name();
        i.subject = parent.getShortMessage();
        if (addLinks) {
            List<WebLinkInfo> parentLinks = webLinks.getPatchSetLinks(project, parent.name());
            i.webLinks = parentLinks.isEmpty() ? null : parentLinks;
        }
        info.parents.add(i);
    }
    return info;
}
#method_after
CommitInfo toCommit(ChangeControl ctl, RevWalk rw, RevCommit commit, boolean addLinks, boolean fillCommit) throws IOException {
    Project.NameKey project = ctl.getProject().getNameKey();
    CommitInfo info = new CommitInfo();
    if (fillCommit) {
        info.commit = commit.name();
    }
    info.parents = new ArrayList<>(commit.getParentCount());
    info.author = toGitPerson(commit.getAuthorIdent());
    info.committer = toGitPerson(commit.getCommitterIdent());
    info.subject = commit.getShortMessage();
    info.message = commit.getFullMessage();
    if (addLinks) {
        List<WebLinkInfo> links = webLinks.getPatchSetLinks(project, commit.name());
        info.webLinks = links.isEmpty() ? null : links;
    }
    for (RevCommit parent : commit.getParents()) {
        rw.parseBody(parent);
        CommitInfo i = new CommitInfo();
        i.commit = parent.name();
        i.subject = parent.getShortMessage();
        info.parents.add(i);
    }
    return info;
}
#end_block

#method_before
@Override
public Response<?> apply(ProjectResource project, DeleteTagsInput input) throws OrmException, IOException, ResourceConflictException {
    if (input == null) {
        input = new DeleteTagsInput();
    }
    if (input.tags == null) {
        input.tags = Lists.newArrayListWithCapacity(1);
    }
    try (Repository r = repoManager.openRepository(project.getNameKey())) {
        BatchRefUpdate batchUpdate = r.getRefDatabase().newBatchUpdate();
        for (String tag : input.tags) {
            batchUpdate.addCommand(createDeleteCommand(project, r, tag));
        }
        try (RevWalk rw = new RevWalk(r)) {
            batchUpdate.execute(rw, NullProgressMonitor.INSTANCE);
        }
        StringBuilder errorMessages = new StringBuilder();
        for (ReceiveCommand command : batchUpdate.getCommands()) {
            if (command.getResult() == Result.OK) {
                postDeletion(project, command);
            } else {
                appendAndLogErrorMessage(errorMessages, command);
            }
        }
        if (errorMessages.length() > 0) {
            throw new ResourceConflictException(errorMessages.toString());
        }
    }
    return Response.none();
}
#method_after
@Override
public Response<?> apply(ProjectResource project, DeleteTagsInput input) throws OrmException, RestApiException, IOException {
    if (input == null || input.tags == null || input.tags.isEmpty()) {
        throw new BadRequestException("tags must be specified");
    }
    deleteRefFactory.create(project).refs(input.tags).prefix(R_TAGS).delete();
    return Response.none();
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ProjectsCollection.class);
    bind(DashboardsCollection.class);
    DynamicMap.mapOf(binder(), PROJECT_KIND);
    DynamicMap.mapOf(binder(), CHILD_PROJECT_KIND);
    DynamicMap.mapOf(binder(), BRANCH_KIND);
    DynamicMap.mapOf(binder(), DASHBOARD_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), COMMIT_KIND);
    DynamicMap.mapOf(binder(), TAG_KIND);
    put(PROJECT_KIND).to(PutProject.class);
    get(PROJECT_KIND).to(GetProject.class);
    get(PROJECT_KIND, "description").to(GetDescription.class);
    put(PROJECT_KIND, "description").to(PutDescription.class);
    delete(PROJECT_KIND, "description").to(PutDescription.class);
    get(PROJECT_KIND, "access").to(GetAccess.class);
    post(PROJECT_KIND, "access").to(SetAccess.class);
    get(PROJECT_KIND, "parent").to(GetParent.class);
    put(PROJECT_KIND, "parent").to(SetParent.class);
    child(PROJECT_KIND, "children").to(ChildProjectsCollection.class);
    get(CHILD_PROJECT_KIND).to(GetChildProject.class);
    get(PROJECT_KIND, "HEAD").to(GetHead.class);
    put(PROJECT_KIND, "HEAD").to(SetHead.class);
    put(PROJECT_KIND, "ban").to(BanCommit.class);
    get(PROJECT_KIND, "statistics.git").to(GetStatistics.class);
    post(PROJECT_KIND, "gc").to(GarbageCollect.class);
    child(PROJECT_KIND, "branches").to(BranchesCollection.class);
    put(BRANCH_KIND).to(PutBranch.class);
    get(BRANCH_KIND).to(GetBranch.class);
    delete(BRANCH_KIND).to(DeleteBranch.class);
    post(PROJECT_KIND, "branches:delete").to(DeleteBranches.class);
    factory(CreateBranch.Factory.class);
    get(BRANCH_KIND, "mergeable").to(CheckMergeability.class);
    factory(RefValidationHelper.Factory.class);
    get(BRANCH_KIND, "reflog").to(GetReflog.class);
    child(BRANCH_KIND, "files").to(FilesCollection.class);
    get(FILE_KIND, "content").to(GetContent.class);
    child(PROJECT_KIND, "commits").to(CommitsCollection.class);
    get(COMMIT_KIND).to(GetCommit.class);
    child(COMMIT_KIND, "files").to(FilesInCommitCollection.class);
    child(PROJECT_KIND, "tags").to(TagsCollection.class);
    get(TAG_KIND).to(GetTag.class);
    put(TAG_KIND).to(PutTag.class);
    delete(TAG_KIND).to(DeleteTag.class);
    post(PROJECT_KIND, "tags:delete").to(DeleteTags.class);
    factory(CreateTag.Factory.class);
    child(PROJECT_KIND, "dashboards").to(DashboardsCollection.class);
    get(DASHBOARD_KIND).to(GetDashboard.class);
    put(DASHBOARD_KIND).to(SetDashboard.class);
    delete(DASHBOARD_KIND).to(DeleteDashboard.class);
    factory(CreateProject.Factory.class);
    get(PROJECT_KIND, "config").to(GetConfig.class);
    put(PROJECT_KIND, "config").to(PutConfig.class);
}
#method_after
@Override
protected void configure() {
    bind(ProjectsCollection.class);
    bind(DashboardsCollection.class);
    DynamicMap.mapOf(binder(), PROJECT_KIND);
    DynamicMap.mapOf(binder(), CHILD_PROJECT_KIND);
    DynamicMap.mapOf(binder(), BRANCH_KIND);
    DynamicMap.mapOf(binder(), DASHBOARD_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), COMMIT_KIND);
    DynamicMap.mapOf(binder(), TAG_KIND);
    put(PROJECT_KIND).to(PutProject.class);
    get(PROJECT_KIND).to(GetProject.class);
    get(PROJECT_KIND, "description").to(GetDescription.class);
    put(PROJECT_KIND, "description").to(PutDescription.class);
    delete(PROJECT_KIND, "description").to(PutDescription.class);
    get(PROJECT_KIND, "access").to(GetAccess.class);
    post(PROJECT_KIND, "access").to(SetAccess.class);
    get(PROJECT_KIND, "parent").to(GetParent.class);
    put(PROJECT_KIND, "parent").to(SetParent.class);
    child(PROJECT_KIND, "children").to(ChildProjectsCollection.class);
    get(CHILD_PROJECT_KIND).to(GetChildProject.class);
    get(PROJECT_KIND, "HEAD").to(GetHead.class);
    put(PROJECT_KIND, "HEAD").to(SetHead.class);
    put(PROJECT_KIND, "ban").to(BanCommit.class);
    get(PROJECT_KIND, "statistics.git").to(GetStatistics.class);
    post(PROJECT_KIND, "gc").to(GarbageCollect.class);
    child(PROJECT_KIND, "branches").to(BranchesCollection.class);
    put(BRANCH_KIND).to(PutBranch.class);
    get(BRANCH_KIND).to(GetBranch.class);
    delete(BRANCH_KIND).to(DeleteBranch.class);
    post(PROJECT_KIND, "branches:delete").to(DeleteBranches.class);
    factory(CreateBranch.Factory.class);
    get(BRANCH_KIND, "mergeable").to(CheckMergeability.class);
    factory(RefValidationHelper.Factory.class);
    get(BRANCH_KIND, "reflog").to(GetReflog.class);
    child(BRANCH_KIND, "files").to(FilesCollection.class);
    get(FILE_KIND, "content").to(GetContent.class);
    child(PROJECT_KIND, "commits").to(CommitsCollection.class);
    get(COMMIT_KIND).to(GetCommit.class);
    child(COMMIT_KIND, "files").to(FilesInCommitCollection.class);
    child(PROJECT_KIND, "tags").to(TagsCollection.class);
    get(TAG_KIND).to(GetTag.class);
    put(TAG_KIND).to(PutTag.class);
    delete(TAG_KIND).to(DeleteTag.class);
    post(PROJECT_KIND, "tags:delete").to(DeleteTags.class);
    factory(CreateTag.Factory.class);
    child(PROJECT_KIND, "dashboards").to(DashboardsCollection.class);
    get(DASHBOARD_KIND).to(GetDashboard.class);
    put(DASHBOARD_KIND).to(SetDashboard.class);
    delete(DASHBOARD_KIND).to(DeleteDashboard.class);
    factory(CreateProject.Factory.class);
    get(PROJECT_KIND, "config").to(GetConfig.class);
    put(PROJECT_KIND, "config").to(PutConfig.class);
    factory(DeleteRef.Factory.class);
}
#end_block

#method_before
Multimap<RecipientType, Account.Id> getAccountsToNotify() {
    if ((tos == null || tos.isEmpty()) && (ccs == null || ccs.isEmpty()) && (bccs == null || bccs.isEmpty())) {
        return null;
    }
    Multimap<RecipientType, Account.Id> accountsToNotify = ArrayListMultimap.create();
    if (tos != null) {
        accountsToNotify.putAll(RecipientType.TO, tos);
    }
    if (ccs != null) {
        accountsToNotify.putAll(RecipientType.CC, ccs);
    }
    if (bccs != null) {
        accountsToNotify.putAll(RecipientType.BCC, bccs);
    }
    return accountsToNotify;
}
#method_after
Multimap<RecipientType, Account.Id> getAccountsToNotify() {
    Multimap<RecipientType, Account.Id> accountsToNotify = ArrayListMultimap.create();
    accountsToNotify.putAll(RecipientType.TO, tos);
    accountsToNotify.putAll(RecipientType.CC, ccs);
    accountsToNotify.putAll(RecipientType.BCC, bccs);
    return accountsToNotify;
}
#end_block

#method_before
@Test
public void publishEdit() throws Exception {
    assertThat(modifier.createEdit(change, getCurrentPatchSet(changeId))).isEqualTo(RefUpdate.Result.NEW);
    assertThat(modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, RawInputUtil.create(CONTENT_NEW2))).isEqualTo(RefUpdate.Result.FORCED);
    editUtil.publish(editUtil.byChange(change).get(), NotifyHandling.NONE, null);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertThat(edit.isPresent()).isFalse();
    assertChangeMessages(change, ImmutableList.of("Uploaded patch set 1.", "Uploaded patch set 2.", "Patch Set 3: Published edit on patch set 2."));
}
#method_after
@Test
public void publishEdit() throws Exception {
    assertThat(modifier.createEdit(change, getCurrentPatchSet(changeId))).isEqualTo(RefUpdate.Result.NEW);
    assertThat(modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, RawInputUtil.create(CONTENT_NEW2))).isEqualTo(RefUpdate.Result.FORCED);
    editUtil.publish(editUtil.byChange(change).get(), NotifyHandling.NONE, ImmutableListMultimap.of());
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertThat(edit.isPresent()).isFalse();
    assertChangeMessages(change, ImmutableList.of("Uploaded patch set 1.", "Uploaded patch set 2.", "Patch Set 3: Published edit on patch set 2."));
}
#end_block

#method_before
@Test
public void updateMessage() throws Exception {
    assertThat(modifier.createEdit(change, getCurrentPatchSet(changeId))).isEqualTo(RefUpdate.Result.NEW);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    String msg = String.format("New commit message\n\nChange-Id: %s\n", change.getKey());
    assertThat(modifier.modifyMessage(edit.get(), msg)).isEqualTo(RefUpdate.Result.FORCED);
    edit = editUtil.byChange(change);
    assertThat(edit.get().getEditCommit().getFullMessage()).isEqualTo(msg);
    editUtil.publish(edit.get(), NotifyHandling.NONE, null);
    assertThat(editUtil.byChange(change).isPresent()).isFalse();
    ChangeInfo info = get(changeId, ListChangesOption.CURRENT_COMMIT, ListChangesOption.CURRENT_REVISION);
    assertThat(info.revisions.get(info.currentRevision).commit.message).isEqualTo(msg);
    assertChangeMessages(change, ImmutableList.of("Uploaded patch set 1.", "Uploaded patch set 2.", "Patch Set 3: Commit message was updated."));
}
#method_after
@Test
public void updateMessage() throws Exception {
    assertThat(modifier.createEdit(change, getCurrentPatchSet(changeId))).isEqualTo(RefUpdate.Result.NEW);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    String msg = String.format("New commit message\n\nChange-Id: %s\n", change.getKey());
    assertThat(modifier.modifyMessage(edit.get(), msg)).isEqualTo(RefUpdate.Result.FORCED);
    edit = editUtil.byChange(change);
    assertThat(edit.get().getEditCommit().getFullMessage()).isEqualTo(msg);
    editUtil.publish(edit.get(), NotifyHandling.NONE, ImmutableListMultimap.of());
    assertThat(editUtil.byChange(change).isPresent()).isFalse();
    ChangeInfo info = get(changeId, ListChangesOption.CURRENT_COMMIT, ListChangesOption.CURRENT_REVISION);
    assertThat(info.revisions.get(info.currentRevision).commit.message).isEqualTo(msg);
    assertChangeMessages(change, ImmutableList.of("Uploaded patch set 1.", "Uploaded patch set 2.", "Patch Set 3: Commit message was updated."));
}
#end_block

#method_before
@Test
public void updateMessageRest() throws Exception {
    adminRestSession.get(urlEditMessage(false)).assertNotFound();
    EditMessage.Input in = new EditMessage.Input();
    in.message = String.format("New commit message\n\n" + CONTENT_NEW2_STR + "\n\nChange-Id: %s\n", change.getKey());
    adminRestSession.put(urlEditMessage(false), in).assertNoContent();
    RestResponse r = adminRestSession.getJsonAccept(urlEditMessage(false));
    r.assertOK();
    assertThat(readContentFromJson(r)).isEqualTo(in.message);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertThat(edit.get().getEditCommit().getFullMessage()).isEqualTo(in.message);
    in.message = String.format("New commit message2\n\nChange-Id: %s\n", change.getKey());
    adminRestSession.put(urlEditMessage(false), in).assertNoContent();
    edit = editUtil.byChange(change);
    assertThat(edit.get().getEditCommit().getFullMessage()).isEqualTo(in.message);
    r = adminRestSession.getJsonAccept(urlEditMessage(true));
    try (Repository repo = repoManager.openRepository(project);
        RevWalk rw = new RevWalk(repo)) {
        RevCommit commit = rw.parseCommit(ObjectId.fromString(ps.getRevision().get()));
        assertThat(readContentFromJson(r)).isEqualTo(commit.getFullMessage());
    }
    editUtil.publish(edit.get(), NotifyHandling.NONE, null);
    assertChangeMessages(change, ImmutableList.of("Uploaded patch set 1.", "Uploaded patch set 2.", "Patch Set 3: Commit message was updated."));
}
#method_after
@Test
public void updateMessageRest() throws Exception {
    adminRestSession.get(urlEditMessage(false)).assertNotFound();
    EditMessage.Input in = new EditMessage.Input();
    in.message = String.format("New commit message\n\n" + CONTENT_NEW2_STR + "\n\nChange-Id: %s\n", change.getKey());
    adminRestSession.put(urlEditMessage(false), in).assertNoContent();
    RestResponse r = adminRestSession.getJsonAccept(urlEditMessage(false));
    r.assertOK();
    assertThat(readContentFromJson(r)).isEqualTo(in.message);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertThat(edit.get().getEditCommit().getFullMessage()).isEqualTo(in.message);
    in.message = String.format("New commit message2\n\nChange-Id: %s\n", change.getKey());
    adminRestSession.put(urlEditMessage(false), in).assertNoContent();
    edit = editUtil.byChange(change);
    assertThat(edit.get().getEditCommit().getFullMessage()).isEqualTo(in.message);
    r = adminRestSession.getJsonAccept(urlEditMessage(true));
    try (Repository repo = repoManager.openRepository(project);
        RevWalk rw = new RevWalk(repo)) {
        RevCommit commit = rw.parseCommit(ObjectId.fromString(ps.getRevision().get()));
        assertThat(readContentFromJson(r)).isEqualTo(commit.getFullMessage());
    }
    editUtil.publish(edit.get(), NotifyHandling.NONE, ImmutableListMultimap.of());
    assertChangeMessages(change, ImmutableList.of("Uploaded patch set 1.", "Uploaded patch set 2.", "Patch Set 3: Commit message was updated."));
}
#end_block

#method_before
@Test
public void editCommitMessageCopiesLabelScores() throws Exception {
    String cr = "Code-Review";
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    LabelType codeReview = Util.codeReview();
    codeReview.setCopyAllScoresIfNoCodeChange(true);
    cfg.getLabelSections().put(cr, codeReview);
    saveProjectConfig(project, cfg);
    String changeId = change.getKey().get();
    ReviewInput r = new ReviewInput();
    r.labels = ImmutableMap.<String, Short>of(cr, (short) 1);
    gApi.changes().id(changeId).revision(change.currentPatchSetId().get()).review(r);
    assertThat(modifier.createEdit(change, getCurrentPatchSet(changeId))).isEqualTo(RefUpdate.Result.NEW);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    String newSubj = "New commit message";
    String newMsg = newSubj + "\n\nChange-Id: " + changeId + "\n";
    assertThat(modifier.modifyMessage(edit.get(), newMsg)).isEqualTo(RefUpdate.Result.FORCED);
    edit = editUtil.byChange(change);
    editUtil.publish(edit.get(), NotifyHandling.NONE, null);
    ChangeInfo info = get(changeId);
    assertThat(info.subject).isEqualTo(newSubj);
    List<ApprovalInfo> approvals = info.labels.get(cr).all;
    assertThat(approvals).hasSize(1);
    assertThat(approvals.get(0).value).isEqualTo(1);
}
#method_after
@Test
public void editCommitMessageCopiesLabelScores() throws Exception {
    String cr = "Code-Review";
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    LabelType codeReview = Util.codeReview();
    codeReview.setCopyAllScoresIfNoCodeChange(true);
    cfg.getLabelSections().put(cr, codeReview);
    saveProjectConfig(project, cfg);
    String changeId = change.getKey().get();
    ReviewInput r = new ReviewInput();
    r.labels = ImmutableMap.<String, Short>of(cr, (short) 1);
    gApi.changes().id(changeId).revision(change.currentPatchSetId().get()).review(r);
    assertThat(modifier.createEdit(change, getCurrentPatchSet(changeId))).isEqualTo(RefUpdate.Result.NEW);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    String newSubj = "New commit message";
    String newMsg = newSubj + "\n\nChange-Id: " + changeId + "\n";
    assertThat(modifier.modifyMessage(edit.get(), newMsg)).isEqualTo(RefUpdate.Result.FORCED);
    edit = editUtil.byChange(change);
    editUtil.publish(edit.get(), NotifyHandling.NONE, ImmutableListMultimap.of());
    ChangeInfo info = get(changeId);
    assertThat(info.subject).isEqualTo(newSubj);
    List<ApprovalInfo> approvals = info.labels.get(cr).all;
    assertThat(approvals).hasSize(1);
    assertThat(approvals.get(0).value).isEqualTo(1);
}
#end_block

#method_before
@Test
public void testHasEditPredicate() throws Exception {
    assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW);
    assertThat(queryEdits()).hasSize(1);
    PatchSet current = getCurrentPatchSet(changeId2);
    assertThat(modifier.createEdit(change2, current)).isEqualTo(RefUpdate.Result.NEW);
    assertThat(modifier.modifyFile(editUtil.byChange(change2).get(), FILE_NAME, RawInputUtil.create(CONTENT_NEW))).isEqualTo(RefUpdate.Result.FORCED);
    assertThat(queryEdits()).hasSize(2);
    assertThat(modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, RawInputUtil.create(CONTENT_NEW))).isEqualTo(RefUpdate.Result.FORCED);
    editUtil.delete(editUtil.byChange(change).get());
    assertThat(queryEdits()).hasSize(1);
    editUtil.publish(editUtil.byChange(change2).get(), NotifyHandling.NONE, null);
    assertThat(queryEdits()).hasSize(0);
    setApiUser(user);
    assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW);
    assertThat(queryEdits()).hasSize(1);
    setApiUser(admin);
    assertThat(queryEdits()).hasSize(0);
}
#method_after
@Test
public void testHasEditPredicate() throws Exception {
    assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW);
    assertThat(queryEdits()).hasSize(1);
    PatchSet current = getCurrentPatchSet(changeId2);
    assertThat(modifier.createEdit(change2, current)).isEqualTo(RefUpdate.Result.NEW);
    assertThat(modifier.modifyFile(editUtil.byChange(change2).get(), FILE_NAME, RawInputUtil.create(CONTENT_NEW))).isEqualTo(RefUpdate.Result.FORCED);
    assertThat(queryEdits()).hasSize(2);
    assertThat(modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, RawInputUtil.create(CONTENT_NEW))).isEqualTo(RefUpdate.Result.FORCED);
    editUtil.delete(editUtil.byChange(change).get());
    assertThat(queryEdits()).hasSize(1);
    editUtil.publish(editUtil.byChange(change2).get(), NotifyHandling.NONE, ImmutableListMultimap.of());
    assertThat(queryEdits()).hasSize(0);
    setApiUser(user);
    assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW);
    assertThat(queryEdits()).hasSize(1);
    setApiUser(admin);
    assertThat(queryEdits()).hasSize(0);
}
#end_block

#method_before
public PatchSetInserter setAccountsToNotify(Multimap<RecipientType, Account.Id> accountsToNotify) {
    this.accountsToNotify = accountsToNotify;
    return this;
}
#method_after
public PatchSetInserter setAccountsToNotify(Multimap<RecipientType, Account.Id> accountsToNotify) {
    this.accountsToNotify = checkNotNull(accountsToNotify);
    return this;
}
#end_block

#method_before
@Override
public void postUpdate(Context ctx) throws OrmException {
    if (notify != NotifyHandling.NONE || (accountsToNotify != null && !accountsToNotify.isEmpty())) {
        try {
            ReplacePatchSetSender cm = replacePatchSetFactory.create(ctx.getProject(), change.getId());
            cm.setFrom(ctx.getAccountId());
            cm.setPatchSet(patchSet, patchSetInfo);
            cm.setChangeMessage(changeMessage.getMessage(), ctx.getWhen());
            cm.addReviewers(oldReviewers.byState(REVIEWER));
            cm.addExtraCC(oldReviewers.byState(CC));
            cm.setNotify(notify);
            cm.setAccountsToNotify(accountsToNotify);
            cm.send();
        } catch (Exception err) {
            log.error("Cannot send email for new patch set on change " + change.getId(), err);
        }
    }
    if (fireRevisionCreated) {
        revisionCreated.fire(change, patchSet, ctx.getAccount(), ctx.getWhen(), notify);
    }
}
#method_after
@Override
public void postUpdate(Context ctx) throws OrmException {
    if (notify != NotifyHandling.NONE || !accountsToNotify.isEmpty()) {
        try {
            ReplacePatchSetSender cm = replacePatchSetFactory.create(ctx.getProject(), change.getId());
            cm.setFrom(ctx.getAccountId());
            cm.setPatchSet(patchSet, patchSetInfo);
            cm.setChangeMessage(changeMessage.getMessage(), ctx.getWhen());
            cm.addReviewers(oldReviewers.byState(REVIEWER));
            cm.addExtraCC(oldReviewers.byState(CC));
            cm.setNotify(notify);
            cm.setAccountsToNotify(accountsToNotify);
            cm.send();
        } catch (Exception err) {
            log.error("Cannot send email for new patch set on change " + change.getId(), err);
        }
    }
    if (fireRevisionCreated) {
        revisionCreated.fire(change, patchSet, ctx.getAccount(), ctx.getWhen(), notify);
    }
}
#end_block

#method_before
public void setAccountsToNotify(Multimap<RecipientType, Account.Id> accountsToNotify) {
    this.accountsToNotify = accountsToNotify != null ? ImmutableListMultimap.copyOf(accountsToNotify) : null;
}
#method_after
public void setAccountsToNotify(Multimap<RecipientType, Account.Id> accountsToNotify) {
    this.accountsToNotify = checkNotNull(accountsToNotify);
}
#end_block

#method_before
public void send() throws EmailException {
    if (NotifyHandling.NONE.equals(notify) && (accountsToNotify == null || accountsToNotify.isEmpty())) {
        return;
    }
    if (!args.emailSender.isEnabled()) {
        // 
        return;
    }
    init();
    if (useHtml()) {
        appendHtml(soyHtmlTemplate("HeaderHtml"));
    }
    format();
    appendText(textTemplate("Footer"));
    if (useHtml()) {
        appendHtml(soyHtmlTemplate("FooterHtml"));
    }
    if (shouldSendMessage()) {
        if (fromId != null) {
            final Account fromUser = args.accountCache.get(fromId).getAccount();
            GeneralPreferencesInfo senderPrefs = fromUser.getGeneralPreferencesInfo();
            if (senderPrefs != null && senderPrefs.getEmailStrategy() == CC_ON_OWN_COMMENTS) {
                // If we are impersonating a user, make sure they receive a CC of
                // this message so they can always review and audit what we sent
                // on their behalf to others.
                // 
                add(RecipientType.CC, fromId);
            } else if ((accountsToNotify == null || !accountsToNotify.containsValue(fromId)) && rcptTo.remove(fromId)) {
                // If they don't want a copy, but we queued one up anyway,
                // drop them from the recipient lists.
                // 
                removeUser(fromUser);
            }
            // his email notifications then drop him from recipients' list
            for (Account.Id id : rcptTo) {
                Account thisUser = args.accountCache.get(id).getAccount();
                GeneralPreferencesInfo prefs = thisUser.getGeneralPreferencesInfo();
                if (prefs == null || prefs.getEmailStrategy() == DISABLED) {
                    removeUser(thisUser);
                }
                if (smtpRcptTo.isEmpty()) {
                    return;
                }
            }
        }
        String textPart = textBody.toString();
        OutgoingEmailValidationListener.Args va = new OutgoingEmailValidationListener.Args();
        va.messageClass = messageClass;
        va.smtpFromAddress = smtpFromAddress;
        va.smtpRcptTo = smtpRcptTo;
        va.headers = headers;
        va.body = textPart;
        if (useHtml()) {
            va.htmlBody = htmlBody.toString();
        } else {
            va.htmlBody = null;
        }
        for (OutgoingEmailValidationListener validator : args.outgoingEmailValidationListeners) {
            try {
                validator.validateOutgoingEmail(va);
            } catch (ValidationException e) {
                return;
            }
        }
        args.emailSender.send(va.smtpFromAddress, va.smtpRcptTo, va.headers, va.body, va.htmlBody);
    }
}
#method_after
public void send() throws EmailException {
    if (NotifyHandling.NONE.equals(notify) && accountsToNotify.isEmpty()) {
        return;
    }
    if (!args.emailSender.isEnabled()) {
        // 
        return;
    }
    init();
    if (useHtml()) {
        appendHtml(soyHtmlTemplate("HeaderHtml"));
    }
    format();
    appendText(textTemplate("Footer"));
    if (useHtml()) {
        appendHtml(soyHtmlTemplate("FooterHtml"));
    }
    if (shouldSendMessage()) {
        if (fromId != null) {
            final Account fromUser = args.accountCache.get(fromId).getAccount();
            GeneralPreferencesInfo senderPrefs = fromUser.getGeneralPreferencesInfo();
            if (senderPrefs != null && senderPrefs.getEmailStrategy() == CC_ON_OWN_COMMENTS) {
                // If we are impersonating a user, make sure they receive a CC of
                // this message so they can always review and audit what we sent
                // on their behalf to others.
                // 
                add(RecipientType.CC, fromId);
            } else if (!accountsToNotify.containsValue(fromId) && rcptTo.remove(fromId)) {
                // If they don't want a copy, but we queued one up anyway,
                // drop them from the recipient lists.
                // 
                removeUser(fromUser);
            }
            // his email notifications then drop him from recipients' list
            for (Account.Id id : rcptTo) {
                Account thisUser = args.accountCache.get(id).getAccount();
                GeneralPreferencesInfo prefs = thisUser.getGeneralPreferencesInfo();
                if (prefs == null || prefs.getEmailStrategy() == DISABLED) {
                    removeUser(thisUser);
                }
                if (smtpRcptTo.isEmpty()) {
                    return;
                }
            }
        }
        String textPart = textBody.toString();
        OutgoingEmailValidationListener.Args va = new OutgoingEmailValidationListener.Args();
        va.messageClass = messageClass;
        va.smtpFromAddress = smtpFromAddress;
        va.smtpRcptTo = smtpRcptTo;
        va.headers = headers;
        va.body = textPart;
        if (useHtml()) {
            va.htmlBody = htmlBody.toString();
        } else {
            va.htmlBody = null;
        }
        for (OutgoingEmailValidationListener validator : args.outgoingEmailValidationListeners) {
            try {
                validator.validateOutgoingEmail(va);
            } catch (ValidationException e) {
                return;
            }
        }
        args.emailSender.send(va.smtpFromAddress, va.smtpRcptTo, va.headers, va.body, va.htmlBody);
    }
}
#end_block

#method_before
protected void init() throws EmailException {
    setupVelocityContext();
    setupSoyContext();
    smtpFromAddress = args.fromAddressGenerator.from(fromId);
    setHeader("Date", new Date());
    headers.put("From", new EmailHeader.AddressList(smtpFromAddress));
    headers.put(HDR_TO, new EmailHeader.AddressList());
    headers.put(HDR_CC, new EmailHeader.AddressList());
    setHeader("Message-ID", "");
    if (accountsToNotify != null) {
        for (RecipientType recipientType : accountsToNotify.keySet()) {
            add(recipientType, accountsToNotify.get(recipientType));
        }
    }
    if (fromId != null) {
        // If we have a user that this message is supposedly caused by
        // but the From header on the email does not match the user as
        // it is a generic header for this Gerrit server, include the
        // Reply-To header with the current user's email address.
        // 
        final Address a = toAddress(fromId);
        if (a != null && !smtpFromAddress.getEmail().equals(a.getEmail())) {
            setHeader("Reply-To", a.getEmail());
        }
    }
    setHeader("X-Gerrit-MessageType", messageClass);
    textBody = new StringBuilder();
    htmlBody = new StringBuilder();
    if (fromId != null && args.fromAddressGenerator.isGenericAddress(fromId)) {
        appendText(getFromLine());
    }
}
#method_after
protected void init() throws EmailException {
    setupVelocityContext();
    setupSoyContext();
    smtpFromAddress = args.fromAddressGenerator.from(fromId);
    setHeader("Date", new Date());
    headers.put("From", new EmailHeader.AddressList(smtpFromAddress));
    headers.put(HDR_TO, new EmailHeader.AddressList());
    headers.put(HDR_CC, new EmailHeader.AddressList());
    setHeader("Message-ID", "");
    for (RecipientType recipientType : accountsToNotify.keySet()) {
        add(recipientType, accountsToNotify.get(recipientType));
    }
    if (fromId != null) {
        // If we have a user that this message is supposedly caused by
        // but the From header on the email does not match the user as
        // it is a generic header for this Gerrit server, include the
        // Reply-To header with the current user's email address.
        // 
        final Address a = toAddress(fromId);
        if (a != null && !smtpFromAddress.getEmail().equals(a.getEmail())) {
            setHeader("Reply-To", a.getEmail());
        }
    }
    setHeader("X-Gerrit-MessageType", messageClass);
    textBody = new StringBuilder();
    htmlBody = new StringBuilder();
    if (fromId != null && args.fromAddressGenerator.isGenericAddress(fromId)) {
        appendText(getFromLine());
    }
}
#end_block

#method_before
protected void setupSoyContext() {
    soyContext = new HashMap<>();
    soyContext.put("messageClass", messageClass);
    soyContextEmailData = new HashMap<>();
    soyContextEmailData.put("settingsUrl", getSettingsUrl());
    soyContextEmailData.put("gerritHost", getGerritHost());
    soyContextEmailData.put("gerritUrl", getGerritUrl());
    soyContext.put("email", soyContextEmailData);
}
#method_after
protected void setupSoyContext() {
    soyContext = new HashMap<>();
    footers = new ArrayList<>();
    soyContext.put("messageClass", messageClass);
    soyContext.put("footers", footers);
    soyContextEmailData = new HashMap<>();
    soyContextEmailData.put("settingsUrl", getSettingsUrl());
    soyContextEmailData.put("gerritHost", getGerritHost());
    soyContextEmailData.put("gerritUrl", getGerritUrl());
    soyContext.put("email", soyContextEmailData);
}
#end_block

#method_before
@Test
public void customCommitFooters() throws Exception {
    PushOneCommit.Result change = createChange();
    RegistrationHandle handle = changeMessageModifiers.add(new ChangeMessageModifier() {

        @Override
        public String onSubmit(String newCommitMessage, RevCommit original, RevCommit mergeTip, Branch.NameKey destination) {
            return newCommitMessage + "Custom: " + destination.get();
        }
    });
    ChangeInfo actual;
    try {
        EnumSet<ListChangesOption> options = EnumSet.of(ListChangesOption.ALL_REVISIONS, ListChangesOption.COMMIT_FOOTERS);
        actual = gApi.changes().id(change.getChangeId()).get(options);
    } finally {
        handle.remove();
    }
    List<String> footers = new ArrayList<>(Arrays.asList(actual.revisions.get(change.getCommit().getName()).commitWithFooters.split("\\n")));
    // remove subject + blank line
    footers.remove(0);
    footers.remove(0);
    List<String> expectedFooters = Arrays.asList("Change-Id: " + change.getChangeId(), "Reviewed-on: " + canonicalWebUrl.get() + change.getChange().getId(), "Custom: refs/heads/master");
    assertThat(footers).containsExactlyElementsIn(expectedFooters);
}
#method_after
@Test
public void customCommitFooters() throws Exception {
    PushOneCommit.Result change = createChange();
    RegistrationHandle handle = changeMessageModifiers.add(new ChangeMessageModifier() {

        @Override
        public String onSubmit(String newCommitMessage, RevCommit original, RevCommit mergeTip, Branch.NameKey destination) {
            assertThat(original.getName()).isNotEqualTo(mergeTip.getName());
            return newCommitMessage + "Custom: " + destination.get();
        }
    });
    ChangeInfo actual;
    try {
        EnumSet<ListChangesOption> options = EnumSet.of(ListChangesOption.ALL_REVISIONS, ListChangesOption.COMMIT_FOOTERS);
        actual = gApi.changes().id(change.getChangeId()).get(options);
    } finally {
        handle.remove();
    }
    List<String> footers = new ArrayList<>(Arrays.asList(actual.revisions.get(change.getCommit().getName()).commitWithFooters.split("\\n")));
    // remove subject + blank line
    footers.remove(0);
    footers.remove(0);
    List<String> expectedFooters = Arrays.asList("Change-Id: " + change.getChangeId(), "Reviewed-on: " + canonicalWebUrl.get() + change.getChange().getId(), "Custom: refs/heads/master");
    assertThat(footers).containsExactlyElementsIn(expectedFooters);
}
#end_block

#method_before
@Override
protected void setupSoyContext() {
    super.setupSoyContext();
    String projectName = branch.getParentKey().get();
    soyContext.put("projectName", projectName);
    // shortProjectName is the project name with the path abbreviated.
    soyContext.put("shortProjectName", projectName.replaceAll("/.*/", "..."));
    soyContextEmailData.put("sshHost", getSshHost());
    Map<String, String> branchData = new HashMap<>();
    branchData.put("shortName", branch.getShortName());
    soyContext.put("branch", branchData);
}
#method_after
@Override
protected void setupSoyContext() {
    super.setupSoyContext();
    String projectName = branch.getParentKey().get();
    soyContext.put("projectName", projectName);
    // shortProjectName is the project name with the path abbreviated.
    soyContext.put("shortProjectName", projectName.replaceAll("/.*/", "..."));
    soyContextEmailData.put("sshHost", getSshHost());
    Map<String, String> branchData = new HashMap<>();
    branchData.put("shortName", branch.getShortName());
    soyContext.put("branch", branchData);
    footers.add("Gerrit-Project: " + branch.getParentKey().get());
    footers.add("Gerrit-Branch: " + branch.getShortName());
}
#end_block

#method_before
public ChangeInserter setAccountsToNotify(Multimap<RecipientType, Account.Id> accountsToNotify) {
    this.accountsToNotify = accountsToNotify;
    return this;
}
#method_after
public ChangeInserter setAccountsToNotify(Multimap<RecipientType, Account.Id> accountsToNotify) {
    this.accountsToNotify = checkNotNull(accountsToNotify);
    return this;
}
#end_block

#method_before
@Override
public void postUpdate(Context ctx) throws OrmException, NoSuchChangeException {
    if (sendMail) {
        Runnable sender = new Runnable() {

            @Override
            public void run() {
                try {
                    CreateChangeSender cm = createChangeSenderFactory.create(change.getProject(), change.getId());
                    cm.setFrom(change.getOwner());
                    cm.setPatchSet(patchSet, patchSetInfo);
                    cm.setNotify(notify);
                    cm.setAccountsToNotify(accountsToNotify);
                    cm.addReviewers(reviewers);
                    cm.addExtraCC(extraCC);
                    cm.send();
                } catch (Exception e) {
                    log.error("Cannot send email for new change " + change.getId(), e);
                }
            }

            @Override
            public String toString() {
                return "send-email newchange";
            }
        };
        if (requestScopePropagator != null) {
            sendEmailExecutor.submit(requestScopePropagator.wrap(sender));
        } else {
            sender.run();
        }
    }
    /* For labels that are not set in this operation, show the "current" value
     * of 0, and no oldValue as the value was not modified by this operation.
     * For labels that are set in this operation, the value was modified, so
     * show a transition from an oldValue of 0 to the new value.
     */
    if (fireRevisionCreated) {
        revisionCreated.fire(change, patchSet, ctx.getAccount(), ctx.getWhen(), notify);
        if (approvals != null && !approvals.isEmpty()) {
            ChangeControl changeControl = changeControlFactory.controlFor(ctx.getDb(), change, ctx.getUser());
            List<LabelType> labels = changeControl.getLabelTypes().getLabelTypes();
            Map<String, Short> allApprovals = new HashMap<>();
            Map<String, Short> oldApprovals = new HashMap<>();
            for (LabelType lt : labels) {
                allApprovals.put(lt.getName(), (short) 0);
                oldApprovals.put(lt.getName(), null);
            }
            for (Map.Entry<String, Short> entry : approvals.entrySet()) {
                if (entry.getValue() != 0) {
                    allApprovals.put(entry.getKey(), entry.getValue());
                    oldApprovals.put(entry.getKey(), (short) 0);
                }
            }
            commentAdded.fire(change, patchSet, ctx.getAccount(), null, allApprovals, oldApprovals, ctx.getWhen());
        }
    }
}
#method_after
@Override
public void postUpdate(Context ctx) throws OrmException, NoSuchChangeException {
    if (sendMail && (notify != NotifyHandling.NONE || !accountsToNotify.isEmpty())) {
        Runnable sender = new Runnable() {

            @Override
            public void run() {
                try {
                    CreateChangeSender cm = createChangeSenderFactory.create(change.getProject(), change.getId());
                    cm.setFrom(change.getOwner());
                    cm.setPatchSet(patchSet, patchSetInfo);
                    cm.setNotify(notify);
                    cm.setAccountsToNotify(accountsToNotify);
                    cm.addReviewers(reviewers);
                    cm.addExtraCC(extraCC);
                    cm.send();
                } catch (Exception e) {
                    log.error("Cannot send email for new change " + change.getId(), e);
                }
            }

            @Override
            public String toString() {
                return "send-email newchange";
            }
        };
        if (requestScopePropagator != null) {
            sendEmailExecutor.submit(requestScopePropagator.wrap(sender));
        } else {
            sender.run();
        }
    }
    /* For labels that are not set in this operation, show the "current" value
     * of 0, and no oldValue as the value was not modified by this operation.
     * For labels that are set in this operation, the value was modified, so
     * show a transition from an oldValue of 0 to the new value.
     */
    if (fireRevisionCreated) {
        revisionCreated.fire(change, patchSet, ctx.getAccount(), ctx.getWhen(), notify);
        if (approvals != null && !approvals.isEmpty()) {
            ChangeControl changeControl = changeControlFactory.controlFor(ctx.getDb(), change, ctx.getUser());
            List<LabelType> labels = changeControl.getLabelTypes().getLabelTypes();
            Map<String, Short> allApprovals = new HashMap<>();
            Map<String, Short> oldApprovals = new HashMap<>();
            for (LabelType lt : labels) {
                allApprovals.put(lt.getName(), (short) 0);
                oldApprovals.put(lt.getName(), null);
            }
            for (Map.Entry<String, Short> entry : approvals.entrySet()) {
                if (entry.getValue() != 0) {
                    allApprovals.put(entry.getKey(), entry.getValue());
                    oldApprovals.put(entry.getKey(), (short) 0);
                }
            }
            commentAdded.fire(change, patchSet, ctx.getAccount(), null, allApprovals, oldApprovals, ctx.getWhen());
        }
    }
}
#end_block

#method_before
public Change abandon(ChangeControl control) throws RestApiException, UpdateException {
    return abandon(control, "", NotifyHandling.ALL, null);
}
#method_after
public Change abandon(ChangeControl control) throws RestApiException, UpdateException {
    return abandon(control, "", NotifyHandling.ALL, ImmutableListMultimap.of());
}
#end_block

#method_before
public Change abandon(ChangeControl control, String msgTxt) throws RestApiException, UpdateException {
    return abandon(control, msgTxt, NotifyHandling.ALL, null);
}
#method_after
public Change abandon(ChangeControl control, String msgTxt) throws RestApiException, UpdateException {
    return abandon(control, msgTxt, NotifyHandling.ALL, ImmutableListMultimap.of());
}
#end_block

#method_before
public void batchAbandon(Project.NameKey project, CurrentUser user, Collection<ChangeControl> controls, String msgTxt) throws RestApiException, UpdateException {
    batchAbandon(project, user, controls, msgTxt, NotifyHandling.ALL, null);
}
#method_after
public void batchAbandon(Project.NameKey project, CurrentUser user, Collection<ChangeControl> controls, String msgTxt) throws RestApiException, UpdateException {
    batchAbandon(project, user, controls, msgTxt, NotifyHandling.ALL, ImmutableListMultimap.of());
}
#end_block

#method_before
public void batchAbandon(Project.NameKey project, CurrentUser user, Collection<ChangeControl> controls) throws RestApiException, UpdateException {
    batchAbandon(project, user, controls, "", NotifyHandling.ALL, null);
}
#method_after
public void batchAbandon(Project.NameKey project, CurrentUser user, Collection<ChangeControl> controls) throws RestApiException, UpdateException {
    batchAbandon(project, user, controls, "", NotifyHandling.ALL, ImmutableListMultimap.of());
}
#end_block

#method_before
Addition ccCurrentUser(CurrentUser user, RevisionResource revision) {
    return new Addition(user.getUserName(), revision.getChangeResource(), ImmutableMap.of(user.getAccountId(), revision.getControl()), CC, NotifyHandling.NONE, null);
}
#method_after
Addition ccCurrentUser(CurrentUser user, RevisionResource revision) {
    return new Addition(user.getUserName(), revision.getChangeResource(), ImmutableMap.of(user.getAccountId(), revision.getControl()), CC, NotifyHandling.NONE, ImmutableListMultimap.of());
}
#end_block

#method_before
@Override
protected void setupSoyContext() {
    super.setupSoyContext();
    soyContext.put("changeId", change.getKey().get());
    soyContext.put("coverLetter", getCoverLetter());
    soyContext.put("fromName", getNameFor(fromId));
    soyContextEmailData.put("unifiedDiff", getUnifiedDiff());
    soyContextEmailData.put("changeDetail", getChangeDetail());
    soyContextEmailData.put("changeUrl", getChangeUrl());
    soyContextEmailData.put("includeDiff", getIncludeDiff());
    Map<String, String> changeData = new HashMap<>();
    changeData.put("subject", change.getSubject());
    changeData.put("originalSubject", change.getOriginalSubject());
    changeData.put("ownerEmail", getNameEmailFor(change.getOwner()));
    changeData.put("changeNumber", Integer.toString(change.getChangeId()));
    soyContext.put("change", changeData);
    String subject = change.getSubject();
    changeData.put("subject", subject);
    // it exceeds that.
    if (subject.length() < 64) {
        changeData.put("shortSubject", subject);
    } else {
        changeData.put("shortSubject", subject.substring(0, 60) + "...");
    }
    Map<String, Object> patchSetData = new HashMap<>();
    patchSetData.put("patchSetId", patchSet.getPatchSetId());
    patchSetData.put("refName", patchSet.getRefName());
    soyContext.put("patchSet", patchSetData);
    soyContext.put("reviewerEmails", getEmailsByState(ReviewerStateInternal.REVIEWER));
    soyContext.put("ccEmails", getEmailsByState(ReviewerStateInternal.CC));
// TODO(wyatta): patchSetInfo
}
#method_after
@Override
protected void setupSoyContext() {
    super.setupSoyContext();
    soyContext.put("changeId", change.getKey().get());
    soyContext.put("coverLetter", getCoverLetter());
    soyContext.put("fromName", getNameFor(fromId));
    soyContextEmailData.put("unifiedDiff", getUnifiedDiff());
    soyContextEmailData.put("changeDetail", getChangeDetail());
    soyContextEmailData.put("changeUrl", getChangeUrl());
    soyContextEmailData.put("includeDiff", getIncludeDiff());
    Map<String, String> changeData = new HashMap<>();
    changeData.put("subject", change.getSubject());
    changeData.put("originalSubject", change.getOriginalSubject());
    changeData.put("ownerEmail", getNameEmailFor(change.getOwner()));
    changeData.put("changeNumber", Integer.toString(change.getChangeId()));
    soyContext.put("change", changeData);
    String subject = change.getSubject();
    changeData.put("subject", subject);
    // it exceeds that.
    if (subject.length() < 64) {
        changeData.put("shortSubject", subject);
    } else {
        changeData.put("shortSubject", subject.substring(0, 60) + "...");
    }
    Map<String, Object> patchSetData = new HashMap<>();
    patchSetData.put("patchSetId", patchSet.getPatchSetId());
    patchSetData.put("refName", patchSet.getRefName());
    soyContext.put("patchSet", patchSetData);
    // TODO(wyatta): patchSetInfo
    footers.add("Gerrit-MessageType: " + messageClass);
    footers.add("Gerrit-Change-Id: " + change.getKey().get());
    footers.add("Gerrit-Change-Number: " + Integer.toString(change.getChangeId()));
    footers.add("Gerrit-PatchSet: " + patchSet.getPatchSetId());
    footers.add("Gerrit-Owner: " + getNameEmailFor(change.getOwner()));
    for (String reviewer : getEmailsByState(ReviewerStateInternal.REVIEWER)) {
        footers.add("Gerrit-Reviewer: " + reviewer);
    }
    for (String reviewer : getEmailsByState(ReviewerStateInternal.CC)) {
        footers.add("Gerrit-CC: " + reviewer);
    }
}
#end_block

#method_before
public Multimap<RecipientType, Account.Id> resolveAccounts(@Nullable Map<RecipientType, NotifyInfo> notifyDetails) throws OrmException, BadRequestException {
    if (isNullOrEmpty(notifyDetails)) {
        return null;
    }
    Multimap<RecipientType, Account.Id> m = null;
    for (Entry<RecipientType, NotifyInfo> e : notifyDetails.entrySet()) {
        List<String> accounts = e.getValue().accounts;
        if (accounts != null) {
            if (m == null) {
                m = ArrayListMultimap.create();
            }
            m.putAll(e.getKey(), find(dbProvider.get(), accounts));
        }
    }
    return m;
}
#method_after
public Multimap<RecipientType, Account.Id> resolveAccounts(@Nullable Map<RecipientType, NotifyInfo> notifyDetails) throws OrmException, BadRequestException {
    if (isNullOrEmpty(notifyDetails)) {
        return ImmutableListMultimap.of();
    }
    Multimap<RecipientType, Account.Id> m = null;
    for (Entry<RecipientType, NotifyInfo> e : notifyDetails.entrySet()) {
        List<String> accounts = e.getValue().accounts;
        if (accounts != null) {
            if (m == null) {
                m = ArrayListMultimap.create();
            }
            m.putAll(e.getKey(), find(dbProvider.get(), accounts));
        }
    }
    return m != null ? m : ImmutableListMultimap.of();
}
#end_block

#method_before
private <T extends CommentInput> void checkComments(RevisionResource revision, Map<String, List<T>> in) throws BadRequestException, OrmException {
    Iterator<? extends Map.Entry<String, List<T>>> mapItr = in.entrySet().iterator();
    Set<String> filePaths = Sets.newHashSet(changeDataFactory.create(db.get(), revision.getControl()).filePaths(revision.getPatchSet()));
    while (mapItr.hasNext()) {
        Map.Entry<String, List<T>> ent = mapItr.next();
        String path = ent.getKey();
        if (!filePaths.contains(path) && !Patch.isMagic(path)) {
            throw new BadRequestException(String.format("file %s not found in revision %s", path, revision.getChange().currentPatchSetId()));
        }
        List<T> list = ent.getValue();
        if (list == null) {
            mapItr.remove();
            continue;
        }
        if (Patch.isMagic(path)) {
            for (T comment : list) {
                if (comment.side == Side.PARENT && comment.parent == null) {
                    throw new BadRequestException(String.format("cannot comment on %s on auto-merge", path));
                }
            }
        }
        Iterator<T> listItr = list.iterator();
        while (listItr.hasNext()) {
            T c = listItr.next();
            if (c == null) {
                listItr.remove();
                continue;
            }
            if (c.line != null && c.line < 0) {
                throw new BadRequestException(String.format("negative line number %d not allowed on %s", c.line, path));
            }
            c.message = Strings.nullToEmpty(c.message).trim();
            if (c.message.isEmpty()) {
                listItr.remove();
            }
        }
        if (list.isEmpty()) {
            mapItr.remove();
        }
    }
}
#method_after
private <T extends CommentInput> void checkComments(RevisionResource revision, Map<String, List<T>> commentsPerPath) throws BadRequestException, OrmException {
    cleanUpComments(commentsPerPath);
    ensureCommentsAreAddable(revision, commentsPerPath);
}
#end_block

#method_before
@Override
public void postUpdate(Context ctx) throws OrmException {
    if (message == null) {
        return;
    }
    if (in.notify.compareTo(NotifyHandling.NONE) > 0 || (accountsToNotify != null && !accountsToNotify.isEmpty())) {
        email.create(in.notify, accountsToNotify, notes, ps, user, message, comments).sendAsync();
    }
    commentAdded.fire(notes.getChange(), ps, user.getAccount(), message.getMessage(), approvals, oldApprovals, ctx.getWhen());
}
#method_after
@Override
public void postUpdate(Context ctx) throws OrmException {
    if (message == null) {
        return;
    }
    if (in.notify.compareTo(NotifyHandling.NONE) > 0 || !accountsToNotify.isEmpty()) {
        email.create(in.notify, accountsToNotify, notes, ps, user, message, comments).sendAsync();
    }
    commentAdded.fire(notes.getChange(), ps, user.getAccount(), message.getMessage(), approvals, oldApprovals, ctx.getWhen());
}
#end_block

#method_before
private BinaryResult getBundles(RevisionResource rsrc, final ArchiveFormat f) throws OrmException, RestApiException {
    ReviewDb db = dbProvider.get();
    ChangeControl control = rsrc.getControl();
    IdentifiedUser caller = control.getUser().asIdentifiedUser();
    Change change = rsrc.getChange();
    BinaryResult bin;
    try (MergeOp op = mergeOpProvider.get()) {
        op.merge(db, change, caller, false, new SubmitInput(), true);
        final MergeOpRepoManager orm = op.getMergeOpRepoManager();
        final Set<Project.NameKey> projects = op.getAllProjects();
        bin = new BinaryResult() {

            @Override
            public void writeTo(OutputStream out) throws IOException {
                try (ArchiveOutputStream aos = f.createArchiveOutputStream(out)) {
                    for (Project.NameKey p : projects) {
                        OpenRepo or = orm.getRepo(p);
                        BundleWriter bw = new BundleWriter(or.getRepo());
                        bw.setObjectCountCallback(null);
                        bw.setPackConfig(null);
                        Collection<ReceiveCommand> refs = or.getUpdate().getRefUpdates();
                        for (ReceiveCommand r : refs) {
                            bw.include(r.getRefName(), r.getNewId());
                            if (!r.getOldId().equals(ObjectId.zeroId())) {
                                bw.assume(or.getCodeReviewRevWalk().parseCommit(r.getOldId()));
                            }
                        }
                        // This naming scheme cannot produce directory/file conflicts
                        // as no projects contains ".git/":
                        String path = p.get() + ".git";
                        ByteArrayOutputStream bos = new ByteArrayOutputStream();
                        bw.writeBundle(NullProgressMonitor.INSTANCE, bos);
                        f.putEntry(aos, path, bos.toByteArray());
                    }
                }
            }
        };
    }
    return bin;
}
#method_after
private BinaryResult getBundles(RevisionResource rsrc, final ArchiveFormat f) throws OrmException, RestApiException {
    ReviewDb db = dbProvider.get();
    ChangeControl control = rsrc.getControl();
    IdentifiedUser caller = control.getUser().asIdentifiedUser();
    Change change = rsrc.getChange();
    BinaryResult bin;
    try (MergeOp op = mergeOpProvider.get()) {
        op.merge(db, change, caller, false, new SubmitInput(), true);
        final MergeOpRepoManager orm = op.getMergeOpRepoManager();
        final Set<Project.NameKey> projects = op.getAllProjects();
        bin = new BinaryResult() {

            @Override
            public void writeTo(OutputStream out) throws IOException {
                try (ArchiveOutputStream aos = f.createArchiveOutputStream(out)) {
                    for (Project.NameKey p : projects) {
                        OpenRepo or = orm.getRepo(p);
                        BundleWriter bw = new BundleWriter(or.getRepo());
                        bw.setObjectCountCallback(null);
                        bw.setPackConfig(null);
                        Collection<ReceiveCommand> refs = or.getUpdate().getRefUpdates();
                        for (ReceiveCommand r : refs) {
                            bw.include(r.getRefName(), r.getNewId());
                            if (!r.getOldId().equals(ObjectId.zeroId())) {
                                bw.assume(or.getCodeReviewRevWalk().parseCommit(r.getOldId()));
                            }
                        }
                        // This naming scheme cannot produce directory/file conflicts
                        // as no projects contains ".git/":
                        String path = p.get() + ".git";
                        LimitedByteArrayOutputStream bos = new LimitedByteArrayOutputStream(maxBundleSize, 1024);
                        bw.writeBundle(NullProgressMonitor.INSTANCE, bos);
                        f.putEntry(aos, path, bos.toByteArray());
                    }
                } catch (LimitExceededException e) {
                    throw new NotImplementedException("The bundle is too big to " + "generate at the server");
                }
            }
        };
    }
    return bin;
}
#end_block

#method_before
@Test
public void testTGZ() throws Exception {
    Project.NameKey p1 = createProject("project-name");
    TestRepository<?> repo1 = cloneProject(p1);
    PushOneCommit.Result change1 = createChange(repo1, "master", "test", "a.txt", "1", "topic");
    approve(change1.getChangeId());
    // get a preview before submitting:
    BinaryResult request = submitPreview(change1.getChangeId(), "tgz");
    assertThat(request.getContentType()).isEqualTo("application/x-gzip");
    File tempfile = File.createTempFile("test", null);
    request.writeTo(new FileOutputStream(tempfile));
    InputStream is = new GZIPInputStream(new FileInputStream(tempfile));
    final List<String> untaredFiles = new LinkedList<>();
    try (TarArchiveInputStream debInputStream = (TarArchiveInputStream) new ArchiveStreamFactory().createArchiveInputStream("tar", is)) {
        TarArchiveEntry entry = null;
        while ((entry = (TarArchiveEntry) debInputStream.getNextEntry()) != null) {
            untaredFiles.add(entry.getName());
        }
    }
    assertThat(untaredFiles).containsExactly(name("project-name") + ".git");
}
#method_after
@Test
public void testTGZ() throws Exception {
    Project.NameKey p1 = createProject("project-name");
    TestRepository<?> repo1 = cloneProject(p1);
    PushOneCommit.Result change1 = createChange(repo1, "master", "test", "a.txt", "1", "topic");
    approve(change1.getChangeId());
    // get a preview before submitting:
    BinaryResult request = submitPreview(change1.getChangeId(), "tgz");
    assertThat(request.getContentType()).isEqualTo("application/x-gzip");
    File tempfile = File.createTempFile("test", null);
    request.writeTo(new FileOutputStream(tempfile));
    InputStream is = new GZIPInputStream(new FileInputStream(tempfile));
    final List<String> untarredFiles = new LinkedList<>();
    try (TarArchiveInputStream debInputStream = (TarArchiveInputStream) new ArchiveStreamFactory().createArchiveInputStream("tar", is)) {
        TarArchiveEntry entry = null;
        while ((entry = (TarArchiveEntry) debInputStream.getNextEntry()) != null) {
            untarredFiles.add(entry.getName());
        }
    }
    assertThat(untarredFiles).containsExactly(name("project-name") + ".git");
}
#end_block

#method_before
@Override
protected void run() throws UnloggedFailure {
    if (abandonChange) {
        if (restoreChange) {
            throw die("abandon and restore actions are mutually exclusive");
        }
        if (submitChange) {
            throw die("abandon and submit actions are mutually exclusive");
        }
        if (publishPatchSet) {
            throw die("abandon and publish actions are mutually exclusive");
        }
        if (deleteDraftPatchSet) {
            throw die("abandon and delete actions are mutually exclusive");
        }
        if (rebaseChange) {
            throw die("abandon and rebase actions are mutually exclusive");
        }
    }
    if (publishPatchSet) {
        if (restoreChange) {
            throw die("publish and restore actions are mutually exclusive");
        }
        if (submitChange) {
            throw die("publish and submit actions are mutually exclusive");
        }
        if (deleteDraftPatchSet) {
            throw die("publish and delete actions are mutually exclusive");
        }
    }
    if (json) {
        if (restoreChange) {
            throw die("json and restore actions are mutually exclusive");
        }
        if (submitChange) {
            throw die("json and submit actions are mutually exclusive");
        }
        if (deleteDraftPatchSet) {
            throw die("json and delete actions are mutually exclusive");
        }
        if (publishPatchSet) {
            throw die("json and publish actions are mutually exclusive");
        }
        if (abandonChange) {
            throw die("json and abandon actions are mutually exclusive");
        }
        if (changeComment != null) {
            throw die("json and message are mutually exclusive");
        }
        if (rebaseChange) {
            throw die("json and rebase actions are mutually exclusive");
        }
        if (moveToBranch != null) {
            throw die("json and move actions are mutually exclusive");
        }
        if (changeTag != null) {
            throw die("json and tag actions are mutually exclusive");
        }
    }
    if (rebaseChange) {
        if (deleteDraftPatchSet) {
            throw die("rebase and delete actions are mutually exclusive");
        }
        if (submitChange) {
            throw die("rebase and submit actions are mutually exclusive");
        }
    }
    if (deleteDraftPatchSet && submitChange) {
        throw die("delete and submit actions are mutually exclusive");
    }
    boolean ok = true;
    ReviewInput input = null;
    if (json) {
        input = reviewFromJson();
    }
    for (final PatchSet patchSet : patchSets) {
        try {
            if (input != null) {
                applyReview(patchSet, input);
            } else {
                reviewPatchSet(patchSet);
            }
        } catch (RestApiException | UnloggedFailure e) {
            ok = false;
            writeError("error", e.getMessage() + "\n");
        } catch (NoSuchChangeException e) {
            ok = false;
            writeError("error", "no such change " + patchSet.getId().getParentKey().get());
        } catch (Exception e) {
            ok = false;
            writeError("fatal", "internal server error while reviewing " + patchSet.getId() + "\n");
            log.error("internal error while reviewing " + patchSet.getId(), e);
        }
    }
    if (!ok) {
        throw die("one or more reviews failed; review output above");
    }
}
#method_after
@Override
protected void run() throws UnloggedFailure {
    if (abandonChange) {
        if (restoreChange) {
            throw die("abandon and restore actions are mutually exclusive");
        }
        if (submitChange) {
            throw die("abandon and submit actions are mutually exclusive");
        }
        if (publishPatchSet) {
            throw die("abandon and publish actions are mutually exclusive");
        }
        if (deleteDraftPatchSet) {
            throw die("abandon and delete actions are mutually exclusive");
        }
        if (rebaseChange) {
            throw die("abandon and rebase actions are mutually exclusive");
        }
        if (moveToBranch != null) {
            throw die("abandon and move actions are mutually exclusive");
        }
    }
    if (publishPatchSet) {
        if (restoreChange) {
            throw die("publish and restore actions are mutually exclusive");
        }
        if (submitChange) {
            throw die("publish and submit actions are mutually exclusive");
        }
        if (deleteDraftPatchSet) {
            throw die("publish and delete actions are mutually exclusive");
        }
    }
    if (json) {
        if (restoreChange) {
            throw die("json and restore actions are mutually exclusive");
        }
        if (submitChange) {
            throw die("json and submit actions are mutually exclusive");
        }
        if (deleteDraftPatchSet) {
            throw die("json and delete actions are mutually exclusive");
        }
        if (publishPatchSet) {
            throw die("json and publish actions are mutually exclusive");
        }
        if (abandonChange) {
            throw die("json and abandon actions are mutually exclusive");
        }
        if (changeComment != null) {
            throw die("json and message are mutually exclusive");
        }
        if (rebaseChange) {
            throw die("json and rebase actions are mutually exclusive");
        }
        if (moveToBranch != null) {
            throw die("json and move actions are mutually exclusive");
        }
        if (changeTag != null) {
            throw die("json and tag actions are mutually exclusive");
        }
    }
    if (rebaseChange) {
        if (deleteDraftPatchSet) {
            throw die("rebase and delete actions are mutually exclusive");
        }
        if (submitChange) {
            throw die("rebase and submit actions are mutually exclusive");
        }
    }
    if (deleteDraftPatchSet && submitChange) {
        throw die("delete and submit actions are mutually exclusive");
    }
    boolean ok = true;
    ReviewInput input = null;
    if (json) {
        input = reviewFromJson();
    }
    for (final PatchSet patchSet : patchSets) {
        try {
            if (input != null) {
                applyReview(patchSet, input);
            } else {
                reviewPatchSet(patchSet);
            }
        } catch (RestApiException | UnloggedFailure e) {
            ok = false;
            writeError("error", e.getMessage() + "\n");
        } catch (NoSuchChangeException e) {
            ok = false;
            writeError("error", "no such change " + patchSet.getId().getParentKey().get());
        } catch (Exception e) {
            ok = false;
            writeError("fatal", "internal server error while reviewing " + patchSet.getId() + "\n");
            log.error("internal error while reviewing " + patchSet.getId(), e);
        }
    }
    if (!ok) {
        throw die("one or more reviews failed; review output above");
    }
}
#end_block

#method_before
private void reviewPatchSet(final PatchSet patchSet) throws Exception {
    if (notify == null) {
        notify = NotifyHandling.ALL;
    }
    ReviewInput review = new ReviewInput();
    review.message = Strings.emptyToNull(changeComment);
    review.tag = Strings.emptyToNull(changeTag);
    review.notify = notify;
    review.labels = new TreeMap<>();
    review.drafts = ReviewInput.DraftHandling.PUBLISH;
    review.strictLabels = strictLabels;
    for (ApproveOption ao : optionList) {
        Short v = ao.value();
        if (v != null) {
            review.labels.put(ao.getLabelName(), v);
        }
    }
    review.labels.putAll(customLabels);
    // We don't need to add the review comment when abandoning/restoring.
    if (abandonChange || restoreChange) {
        review.message = null;
    }
    try {
        if (abandonChange) {
            AbandonInput input = new AbandonInput();
            input.message = Strings.emptyToNull(changeComment);
            applyReview(patchSet, review);
            changeApi(patchSet).abandon(input);
        } else if (restoreChange) {
            RestoreInput input = new RestoreInput();
            input.message = Strings.emptyToNull(changeComment);
            changeApi(patchSet).restore(input);
            applyReview(patchSet, review);
        } else {
            applyReview(patchSet, review);
        }
        if (moveToBranch != null) {
            MoveInput moveInput = new MoveInput();
            moveInput.destinationBranch = moveToBranch;
            moveInput.message = changeComment;
            changeApi(patchSet).move(moveInput);
        }
        if (rebaseChange) {
            revisionApi(patchSet).rebase();
        }
        if (submitChange) {
            revisionApi(patchSet).submit();
        }
        if (publishPatchSet) {
            revisionApi(patchSet).publish();
        } else if (deleteDraftPatchSet) {
            revisionApi(patchSet).delete();
        }
    } catch (IllegalStateException | RestApiException e) {
        throw die(e);
    }
}
#method_after
private void reviewPatchSet(final PatchSet patchSet) throws Exception {
    if (notify == null) {
        notify = NotifyHandling.ALL;
    }
    ReviewInput review = new ReviewInput();
    review.message = Strings.emptyToNull(changeComment);
    review.tag = Strings.emptyToNull(changeTag);
    review.notify = notify;
    review.labels = new TreeMap<>();
    review.drafts = ReviewInput.DraftHandling.PUBLISH;
    review.strictLabels = strictLabels;
    for (ApproveOption ao : optionList) {
        Short v = ao.value();
        if (v != null) {
            review.labels.put(ao.getLabelName(), v);
        }
    }
    review.labels.putAll(customLabels);
    // We don't need to add the review comment when abandoning/restoring.
    if (abandonChange || restoreChange || moveToBranch != null) {
        review.message = null;
    }
    try {
        if (abandonChange) {
            AbandonInput input = new AbandonInput();
            input.message = Strings.emptyToNull(changeComment);
            applyReview(patchSet, review);
            changeApi(patchSet).abandon(input);
        } else if (restoreChange) {
            RestoreInput input = new RestoreInput();
            input.message = Strings.emptyToNull(changeComment);
            changeApi(patchSet).restore(input);
            applyReview(patchSet, review);
        } else {
            applyReview(patchSet, review);
        }
        if (moveToBranch != null) {
            MoveInput moveInput = new MoveInput();
            moveInput.destinationBranch = moveToBranch;
            moveInput.message = Strings.emptyToNull(changeComment);
            changeApi(patchSet).move(moveInput);
        }
        if (rebaseChange) {
            revisionApi(patchSet).rebase();
        }
        if (submitChange) {
            revisionApi(patchSet).submit();
        }
        if (publishPatchSet) {
            revisionApi(patchSet).publish();
        } else if (deleteDraftPatchSet) {
            revisionApi(patchSet).delete();
        }
    } catch (IllegalStateException | RestApiException e) {
        throw die(e);
    }
}
#end_block

#method_before
void onOpenForm() {
    UIObject.setVisible(form, true);
    UIObject.setVisible(error, false);
    addReviewerIcon.setVisible(false);
    suggestBox.setFocus(true);
}
#method_after
void onOpenForm() {
    UIObject.setVisible(form, true);
    UIObject.setVisible(error, false);
    addReviewerIcon.setVisible(false);
    suggestBox.setServeSuggestionsOnOracle(true);
    suggestBox.setFocus(true);
}
#end_block

#method_before
@UiHandler("cancel")
void onCancel(@SuppressWarnings("unused") ClickEvent e) {
    addReviewerIcon.setVisible(true);
    UIObject.setVisible(form, false);
    suggestBox.setFocus(false);
    suggestBox.setText("");
}
#method_after
@UiHandler("cancel")
void onCancel(@SuppressWarnings("unused") ClickEvent e) {
    addReviewerIcon.setVisible(true);
    UIObject.setVisible(form, false);
    suggestBox.setFocus(false);
    suggestBox.setText("");
    suggestBox.setServeSuggestionsOnOracle(false);
}
#end_block

#method_before
private void updateReviewerList() {
    ChangeApi.detail(changeId.get(), new GerritCallback<ChangeInfo>() {

        @Override
        public void onSuccess(ChangeInfo result) {
            display(result);
        }
    });
}
#method_after
void updateReviewerList() {
    ChangeApi.detail(changeId.get(), new GerritCallback<ChangeInfo>() {

        @Override
        public void onSuccess(ChangeInfo result) {
            display(result);
        }
    });
}
#end_block

#method_before
private static Map<Integer, VotableInfo> votable(ChangeInfo change) {
    Map<Integer, VotableInfo> d = new HashMap<>();
    for (String name : change.labels()) {
        LabelInfo label = change.label(name);
        short labelMaxValue = LabelInfo.parseValue(label.maxValue());
        if (label.all() != null) {
            for (ApprovalInfo ai : Natives.asList(label.all())) {
                int id = ai._accountId();
                VotableInfo ad = d.get(id);
                if (ad == null) {
                    ad = new VotableInfo();
                    d.put(id, ad);
                }
                if (ai.hasMaxPermittedValue() && ai.maxPermittedValue() == labelMaxValue) {
                    ad.votable(name + " (" + label.maxValue() + ") ");
                } else if (ai.hasValue()) {
                    ad.votable(name);
                }
            }
        }
    }
    return d;
}
#method_after
private static Map<Integer, VotableInfo> votable(ChangeInfo change) {
    Map<Integer, VotableInfo> d = new HashMap<>();
    for (String name : change.labels()) {
        LabelInfo label = change.label(name);
        short labelMaxValue = LabelInfo.parseValue(label.maxValue());
        if (label.all() != null) {
            for (ApprovalInfo ai : Natives.asList(label.all())) {
                int id = ai._accountId();
                VotableInfo ad = d.get(id);
                if (ad == null) {
                    ad = new VotableInfo();
                    d.put(id, ad);
                }
                if (ai.permittedVotingRange() != null && ai.permittedVotingRange().max() == labelMaxValue) {
                    ad.votable(name + " (" + label.maxValue() + ") ");
                } else if (ai.hasValue()) {
                    ad.votable(name);
                }
            }
        }
    }
    return d;
}
#end_block

#method_before
public ChangeInfo format(ChangeData cd) throws OrmException {
    return format(cd, Optional.<PatchSet.Id>absent(), true);
}
#method_after
public ChangeInfo format(ChangeData cd) throws OrmException {
    return format(cd, Optional.empty(), true);
}
#end_block

#method_before
private ChangeInfo format(ChangeData cd, Optional<PatchSet.Id> limitToPsId, boolean fillAccountLoader) throws OrmException {
    try {
        if (fillAccountLoader) {
            accountLoader = accountLoaderFactory.create(has(DETAILED_ACCOUNTS));
            ChangeInfo res = toChangeInfo(cd, limitToPsId);
            accountLoader.fill();
            return res;
        }
        return toChangeInfo(cd, limitToPsId);
    } catch (PatchListNotAvailableException | GpgException | OrmException | IOException | RuntimeException e) {
        if (!has(CHECK)) {
            Throwables.propagateIfPossible(e, OrmException.class);
            throw new OrmException(e);
        }
        return checkOnly(cd);
    }
}
#method_after
private ChangeInfo format(ChangeData cd, Optional<PatchSet.Id> limitToPsId, boolean fillAccountLoader) throws OrmException {
    try {
        if (fillAccountLoader) {
            accountLoader = accountLoaderFactory.create(has(DETAILED_ACCOUNTS));
            ChangeInfo res = toChangeInfo(cd, limitToPsId);
            accountLoader.fill();
            return res;
        }
        return toChangeInfo(cd, limitToPsId);
    } catch (PatchListNotAvailableException | GpgException | OrmException | IOException | RuntimeException e) {
        if (!has(CHECK)) {
            Throwables.throwIfInstanceOf(e, OrmException.class);
            throw new OrmException(e);
        }
        return checkOnly(cd);
    }
}
#end_block

#method_before
private List<ChangeInfo> toChangeInfo(Map<Change.Id, ChangeInfo> out, List<ChangeData> changes) {
    List<ChangeInfo> info = Lists.newArrayListWithCapacity(changes.size());
    for (ChangeData cd : changes) {
        ChangeInfo i = out.get(cd.getId());
        if (i == null) {
            try {
                i = toChangeInfo(cd, Optional.<PatchSet.Id>absent());
            } catch (PatchListNotAvailableException | GpgException | OrmException | IOException | RuntimeException e) {
                if (has(CHECK)) {
                    i = checkOnly(cd);
                } else {
                    log.warn("Omitting corrupt change " + cd.getId() + " from results", e);
                    continue;
                }
            }
            out.put(cd.getId(), i);
        }
        info.add(i);
    }
    return info;
}
#method_after
private List<ChangeInfo> toChangeInfo(Map<Change.Id, ChangeInfo> out, List<ChangeData> changes) {
    List<ChangeInfo> info = Lists.newArrayListWithCapacity(changes.size());
    for (ChangeData cd : changes) {
        ChangeInfo i = out.get(cd.getId());
        if (i == null) {
            try {
                i = toChangeInfo(cd, Optional.empty());
            } catch (PatchListNotAvailableException | GpgException | OrmException | IOException | RuntimeException e) {
                if (has(CHECK)) {
                    i = checkOnly(cd);
                } else {
                    log.warn("Omitting corrupt change " + cd.getId() + " from results", e);
                    continue;
                }
            }
            out.put(cd.getId(), i);
        }
        info.add(i);
    }
    return info;
}
#end_block

#method_before
private ChangeInfo toChangeInfo(ChangeData cd, Optional<PatchSet.Id> limitToPsId) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    ChangeInfo out = new ChangeInfo();
    CurrentUser user = userProvider.get();
    ChangeControl ctl = cd.changeControl().forUser(user);
    if (has(CHECK)) {
        out.problems = checkerProvider.get().check(ctl, fix).problems();
        // If any problems were fixed, the ChangeData needs to be reloaded.
        for (ProblemInfo p : out.problems) {
            if (p.status == ProblemInfo.Status.FIXED) {
                cd = changeDataFactory.create(cd.db(), cd.project(), cd.getId());
                break;
            }
        }
    }
    Change in = cd.change();
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    if (indexes.getSearchIndex().getSchema().hasField(ChangeField.ASSIGNEE)) {
        if (in.getAssignee() != null) {
            out.assignee = accountLoader.get(in.getAssignee());
        }
    }
    out.hashtags = cd.hashtags();
    out.changeId = in.getKey().get();
    if (in.getStatus().isOpen()) {
        SubmitTypeRecord str = cd.submitTypeRecord();
        if (str.isOk()) {
            out.submitType = str.type;
        }
        out.mergeable = cd.isMergeable();
        if (has(SUBMITTABLE)) {
            out.submittable = submittable(cd);
        }
    }
    Optional<ChangedLines> changedLines = cd.changedLines();
    if (changedLines.isPresent()) {
        out.insertions = changedLines.get().insertions;
        out.deletions = changedLines.get().deletions;
    }
    out.subject = in.getSubject();
    out.status = in.getStatus().asChangeStatus();
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    if (user.isIdentifiedUser()) {
        Collection<String> stars = cd.stars().get(user.getAccountId());
        out.starred = stars.contains(StarredChangesUtil.DEFAULT_LABEL) ? true : null;
        if (!stars.isEmpty()) {
            out.stars = stars;
        }
    }
    if (in.getStatus().isOpen() && has(REVIEWED) && user.isIdentifiedUser()) {
        Account.Id accountId = user.getAccountId();
        out.reviewed = cd.reviewedBy().contains(accountId) ? true : null;
    }
    out.labels = labelsFor(ctl, cd, has(LABELS), has(DETAILED_LABELS));
    out.submitted = getSubmittedOn(cd);
    if (out.labels != null && has(DETAILED_LABELS)) {
        // list permitted labels, since users can't vote on those patch sets.
        if (!limitToPsId.isPresent() || limitToPsId.get().equals(in.currentPatchSetId())) {
            out.permittedLabels = permittedLabels(ctl, cd);
        }
        out.removableReviewers = removableReviewers(ctl, out.labels.values());
        out.reviewers = new HashMap<>();
        for (Map.Entry<ReviewerStateInternal, Map<Account.Id, Timestamp>> e : cd.reviewers().asTable().rowMap().entrySet()) {
            out.reviewers.put(e.getKey().asReviewerState(), toAccountInfo(e.getValue().keySet()));
        }
    }
    if (has(REVIEWER_UPDATES)) {
        out.reviewerUpdates = reviewerUpdates(cd);
    }
    boolean needMessages = has(MESSAGES);
    boolean needRevisions = has(ALL_REVISIONS) || has(CURRENT_REVISION) || limitToPsId.isPresent();
    Map<PatchSet.Id, PatchSet> src;
    if (needMessages || needRevisions) {
        src = loadPatchSets(cd, limitToPsId);
    } else {
        src = null;
    }
    if (needMessages) {
        out.messages = messages(ctl, cd, src);
    }
    finish(out);
    if (needRevisions) {
        out.revisions = revisions(ctl, cd, src);
        if (out.revisions != null) {
            for (Map.Entry<String, RevisionInfo> entry : out.revisions.entrySet()) {
                if (entry.getValue().isCurrent) {
                    out.currentRevision = entry.getKey();
                    break;
                }
            }
        }
    }
    if (has(CURRENT_ACTIONS) || has(CHANGE_ACTIONS)) {
        actionJson.addChangeActions(out, ctl);
    }
    return out;
}
#method_after
private ChangeInfo toChangeInfo(ChangeData cd, Optional<PatchSet.Id> limitToPsId) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    ChangeInfo out = new ChangeInfo();
    CurrentUser user = userProvider.get();
    ChangeControl ctl = cd.changeControl().forUser(user);
    if (has(CHECK)) {
        out.problems = checkerProvider.get().check(ctl, fix).problems();
        // If any problems were fixed, the ChangeData needs to be reloaded.
        for (ProblemInfo p : out.problems) {
            if (p.status == ProblemInfo.Status.FIXED) {
                cd = changeDataFactory.create(cd.db(), cd.project(), cd.getId());
                break;
            }
        }
    }
    Change in = cd.change();
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    if (indexes.getSearchIndex().getSchema().hasField(ChangeField.ASSIGNEE)) {
        if (in.getAssignee() != null) {
            out.assignee = accountLoader.get(in.getAssignee());
        }
    }
    out.hashtags = cd.hashtags();
    out.changeId = in.getKey().get();
    if (in.getStatus().isOpen()) {
        SubmitTypeRecord str = cd.submitTypeRecord();
        if (str.isOk()) {
            out.submitType = str.type;
        }
        out.mergeable = cd.isMergeable();
        if (has(SUBMITTABLE)) {
            out.submittable = submittable(cd);
        }
    }
    Optional<ChangedLines> changedLines = cd.changedLines();
    if (changedLines.isPresent()) {
        out.insertions = changedLines.get().insertions;
        out.deletions = changedLines.get().deletions;
    }
    out.subject = in.getSubject();
    out.status = in.getStatus().asChangeStatus();
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    if (user.isIdentifiedUser()) {
        Collection<String> stars = cd.stars().get(user.getAccountId());
        out.starred = stars.contains(StarredChangesUtil.DEFAULT_LABEL) ? true : null;
        if (!stars.isEmpty()) {
            out.stars = stars;
        }
    }
    if (in.getStatus().isOpen() && has(REVIEWED) && user.isIdentifiedUser()) {
        Account.Id accountId = user.getAccountId();
        out.reviewed = cd.reviewedBy().contains(accountId) ? true : null;
    }
    out.labels = labelsFor(ctl, cd, has(LABELS), has(DETAILED_LABELS));
    out.submitted = getSubmittedOn(cd);
    if (out.labels != null && has(DETAILED_LABELS)) {
        // list permitted labels, since users can't vote on those patch sets.
        if (!limitToPsId.isPresent() || limitToPsId.get().equals(in.currentPatchSetId())) {
            out.permittedLabels = cd.change().getStatus() != Change.Status.ABANDONED ? permittedLabels(ctl, cd) : ImmutableMap.of();
        }
        out.removableReviewers = removableReviewers(ctl, out.labels.values());
        out.reviewers = new HashMap<>();
        for (Map.Entry<ReviewerStateInternal, Map<Account.Id, Timestamp>> e : cd.reviewers().asTable().rowMap().entrySet()) {
            out.reviewers.put(e.getKey().asReviewerState(), toAccountInfo(e.getValue().keySet()));
        }
    }
    if (has(REVIEWER_UPDATES)) {
        out.reviewerUpdates = reviewerUpdates(cd);
    }
    boolean needMessages = has(MESSAGES);
    boolean needRevisions = has(ALL_REVISIONS) || has(CURRENT_REVISION) || limitToPsId.isPresent();
    Map<PatchSet.Id, PatchSet> src;
    if (needMessages || needRevisions) {
        src = loadPatchSets(cd, limitToPsId);
    } else {
        src = null;
    }
    if (needMessages) {
        out.messages = messages(ctl, cd, src);
    }
    finish(out);
    // it will be passed to ActionVisitors as-is.
    if (needRevisions) {
        out.revisions = revisions(ctl, cd, src, out);
        if (out.revisions != null) {
            for (Map.Entry<String, RevisionInfo> entry : out.revisions.entrySet()) {
                if (entry.getValue().isCurrent) {
                    out.currentRevision = entry.getKey();
                    break;
                }
            }
        }
    }
    if (has(CURRENT_ACTIONS) || has(CHANGE_ACTIONS)) {
        actionJson.addChangeActions(out, ctl);
    }
    return out;
}
#end_block

#method_before
private boolean submittable(ChangeData cd) throws OrmException {
    List<SubmitRecord> records = new SubmitRuleEvaluator(cd).setFastEvalLabels(true).evaluate();
    for (SubmitRecord sr : records) {
        if (sr.status == SubmitRecord.Status.OK) {
            return true;
        }
    }
    return false;
}
#method_after
private boolean submittable(ChangeData cd) throws OrmException {
    return SubmitRecord.findOkRecord(cd.submitRecords(SUBMIT_RULE_OPTIONS_STRICT)).isPresent();
}
#end_block

#method_before
private List<SubmitRecord> submitRecords(ChangeData cd) throws OrmException {
    // TODO(dborowitz): Handle this better at the ChangeData level.
    if (submitRecords == null) {
        submitRecords = new HashMap<>();
    }
    List<SubmitRecord> records = submitRecords.get(cd.getId());
    if (records == null) {
        records = new SubmitRuleEvaluator(cd).setFastEvalLabels(true).setAllowDraft(true).evaluate();
        submitRecords.put(cd.getId(), records);
    }
    return records;
}
#method_after
private List<SubmitRecord> submitRecords(ChangeData cd) throws OrmException {
    return cd.submitRecords(SUBMIT_RULE_OPTIONS_LENIENT);
}
#end_block

#method_before
private Map<String, LabelInfo> labelsFor(ChangeControl ctl, ChangeData cd, boolean standard, boolean detailed) throws OrmException {
    if (!standard && !detailed) {
        return null;
    }
    if (ctl == null) {
        return null;
    }
    LabelTypes labelTypes = ctl.getLabelTypes();
    Map<String, LabelWithStatus> withStatus = cd.change().getStatus().isOpen() ? labelsForOpenChange(ctl, cd, labelTypes, standard, detailed) : labelsForClosedChange(cd, labelTypes, standard, detailed);
    return ImmutableMap.copyOf(Maps.transformValues(withStatus, LabelWithStatus::label));
}
#method_after
private Map<String, LabelInfo> labelsFor(ChangeControl ctl, ChangeData cd, boolean standard, boolean detailed) throws OrmException {
    if (!standard && !detailed) {
        return null;
    }
    if (ctl == null) {
        return null;
    }
    LabelTypes labelTypes = ctl.getLabelTypes();
    Map<String, LabelWithStatus> withStatus = cd.change().getStatus().isOpen() ? labelsForOpenChange(ctl, cd, labelTypes, standard, detailed) : labelsForClosedChange(ctl, cd, labelTypes, standard, detailed);
    return ImmutableMap.copyOf(Maps.transformValues(withStatus, LabelWithStatus::label));
}
#end_block

#method_before
private void setAllApprovals(ChangeControl baseCtrl, ChangeData cd, Map<String, LabelWithStatus> labels) throws OrmException {
    // Include a user in the output for this label if either:
    // - They are an explicit reviewer.
    // - They ever voted on this change.
    Set<Account.Id> allUsers = new HashSet<>();
    allUsers.addAll(cd.reviewers().byState(ReviewerStateInternal.REVIEWER));
    for (PatchSetApproval psa : cd.approvals().values()) {
        allUsers.add(psa.getAccountId());
    }
    Table<Account.Id, String, PatchSetApproval> current = HashBasedTable.create(allUsers.size(), baseCtrl.getLabelTypes().getLabelTypes().size());
    for (PatchSetApproval psa : cd.currentApprovals()) {
        current.put(psa.getAccountId(), psa.getLabel(), psa);
    }
    for (Account.Id accountId : allUsers) {
        IdentifiedUser user = userFactory.create(accountId);
        ChangeControl ctl = baseCtrl.forUser(user);
        Map<String, Collection<String>> permittedLabels = permittedLabels(ctl, cd);
        for (Map.Entry<String, LabelWithStatus> e : labels.entrySet()) {
            LabelType lt = ctl.getLabelTypes().byLabel(e.getKey());
            if (lt == null) {
                // author didn't intend for the label to show up in the table.
                continue;
            }
            Integer value;
            Integer maxPermittedValue = null;
            String tag = null;
            Timestamp date = null;
            PatchSetApproval psa = current.get(accountId, lt.getName());
            if (permittedLabels.containsKey(lt.getName())) {
                Collection<String> range = permittedLabels.get(lt.getName());
                for (String val : range) {
                    Integer v = parseRangeValue(val);
                    if (v != null && (maxPermittedValue == null || v > maxPermittedValue)) {
                        maxPermittedValue = v;
                    }
                }
            }
            if (psa != null) {
                value = Integer.valueOf(psa.getValue());
                if (value == 0) {
                    // This may be a dummy approval that was inserted when the reviewer
                    // was added. Explicitly check whether the user can vote on this
                    // label.
                    value = labelNormalizer.canVote(ctl, lt, accountId) ? 0 : null;
                }
                tag = psa.getTag();
                date = psa.getGranted();
            } else {
                // Either the user cannot vote on this label, or they were added as a
                // reviewer but have not responded yet. Explicitly check whether the
                // user can vote on this label.
                value = labelNormalizer.canVote(ctl, lt, accountId) ? 0 : null;
            }
            addApproval(e.getValue().label(), approvalInfo(accountId, value, maxPermittedValue, tag, date));
        }
    }
}
#method_after
private void setAllApprovals(ChangeControl baseCtrl, ChangeData cd, Map<String, LabelWithStatus> labels) throws OrmException {
    Change.Status status = cd.change().getStatus();
    checkState(status.isOpen(), "should not call setAllApprovals on %s change", status);
    // Include a user in the output for this label if either:
    // - They are an explicit reviewer.
    // - They ever voted on this change.
    Set<Account.Id> allUsers = new HashSet<>();
    allUsers.addAll(cd.reviewers().byState(ReviewerStateInternal.REVIEWER));
    for (PatchSetApproval psa : cd.approvals().values()) {
        allUsers.add(psa.getAccountId());
    }
    Table<Account.Id, String, PatchSetApproval> current = HashBasedTable.create(allUsers.size(), baseCtrl.getLabelTypes().getLabelTypes().size());
    for (PatchSetApproval psa : cd.currentApprovals()) {
        current.put(psa.getAccountId(), psa.getLabel(), psa);
    }
    for (Account.Id accountId : allUsers) {
        IdentifiedUser user = userFactory.create(accountId);
        ChangeControl ctl = baseCtrl.forUser(user);
        Map<String, VotingRangeInfo> pvr = getPermittedVotingRanges(permittedLabels(ctl, cd));
        for (Map.Entry<String, LabelWithStatus> e : labels.entrySet()) {
            LabelType lt = ctl.getLabelTypes().byLabel(e.getKey());
            if (lt == null) {
                // author didn't intend for the label to show up in the table.
                continue;
            }
            Integer value;
            VotingRangeInfo permittedVotingRange = pvr.getOrDefault(lt.getName(), null);
            String tag = null;
            Timestamp date = null;
            PatchSetApproval psa = current.get(accountId, lt.getName());
            if (psa != null) {
                value = Integer.valueOf(psa.getValue());
                if (value == 0) {
                    // This may be a dummy approval that was inserted when the reviewer
                    // was added. Explicitly check whether the user can vote on this
                    // label.
                    value = labelNormalizer.canVote(ctl, lt, accountId) ? 0 : null;
                }
                tag = psa.getTag();
                date = psa.getGranted();
                if (psa.isPostSubmit()) {
                    log.warn("unexpected post-submit approval on open change: {}", psa);
                }
            } else {
                // Either the user cannot vote on this label, or they were added as a
                // reviewer but have not responded yet. Explicitly check whether the
                // user can vote on this label.
                value = labelNormalizer.canVote(ctl, lt, accountId) ? 0 : null;
            }
            addApproval(e.getValue().label(), approvalInfo(accountId, value, permittedVotingRange, tag, date));
        }
    }
}
#end_block

#method_before
private Map<String, LabelWithStatus> labelsForClosedChange(ChangeData cd, LabelTypes labelTypes, boolean standard, boolean detailed) throws OrmException {
    Set<Account.Id> allUsers = new HashSet<>();
    if (detailed) {
        // the latest patch set (in the next loop).
        for (PatchSetApproval psa : cd.approvals().values()) {
            allUsers.add(psa.getAccountId());
        }
    }
    // We can only approximately reconstruct what the submit rule evaluator
    // would have done. These should really come from a stored submit record.
    Set<String> labelNames = new HashSet<>();
    Multimap<Account.Id, PatchSetApproval> current = HashMultimap.create();
    for (PatchSetApproval a : cd.currentApprovals()) {
        allUsers.add(a.getAccountId());
        LabelType type = labelTypes.byLabel(a.getLabelId());
        if (type != null) {
            labelNames.add(type.getName());
            // Not worth the effort to distinguish between votable/non-votable for 0
            // values on closed changes, since they can't vote anyway.
            current.put(a.getAccountId(), a);
        }
    }
    // Don't use Maps.newTreeMap(Comparator) due to OpenJDK bug 100167.
    Map<String, LabelWithStatus> labels = new TreeMap<>(labelTypes.nameComparator());
    for (String name : labelNames) {
        LabelType type = labelTypes.byLabel(name);
        LabelWithStatus l = LabelWithStatus.create(new LabelInfo(), null);
        if (detailed) {
            setLabelValues(type, l);
        }
        labels.put(type.getName(), l);
    }
    for (Account.Id accountId : allUsers) {
        Map<String, ApprovalInfo> byLabel = Maps.newHashMapWithExpectedSize(labels.size());
        if (detailed) {
            for (Map.Entry<String, LabelWithStatus> entry : labels.entrySet()) {
                ApprovalInfo ai = approvalInfo(accountId, 0, 0, null, null);
                byLabel.put(entry.getKey(), ai);
                addApproval(entry.getValue().label(), ai);
            }
        }
        for (PatchSetApproval psa : current.get(accountId)) {
            LabelType type = labelTypes.byLabel(psa.getLabelId());
            if (type == null) {
                continue;
            }
            short val = psa.getValue();
            ApprovalInfo info = byLabel.get(type.getName());
            if (info != null) {
                info.value = Integer.valueOf(val);
                info.date = psa.getGranted();
                info.tag = psa.getTag();
            }
            if (!standard) {
                continue;
            }
            setLabelScores(type, labels.get(type.getName()), val, accountId);
        }
    }
    return labels;
}
#method_after
private Map<String, LabelWithStatus> labelsForClosedChange(ChangeControl baseCtrl, ChangeData cd, LabelTypes labelTypes, boolean standard, boolean detailed) throws OrmException {
    Set<Account.Id> allUsers = new HashSet<>();
    if (detailed) {
        // the latest patch set (in the next loop).
        for (PatchSetApproval psa : cd.approvals().values()) {
            allUsers.add(psa.getAccountId());
        }
    }
    Set<String> labelNames = new HashSet<>();
    Multimap<Account.Id, PatchSetApproval> current = HashMultimap.create();
    for (PatchSetApproval a : cd.currentApprovals()) {
        allUsers.add(a.getAccountId());
        LabelType type = labelTypes.byLabel(a.getLabelId());
        if (type != null) {
            labelNames.add(type.getName());
            // Not worth the effort to distinguish between votable/non-votable for 0
            // values on closed changes, since they can't vote anyway.
            current.put(a.getAccountId(), a);
        }
    }
    Map<String, LabelWithStatus> labels;
    if (cd.change().getStatus() == Change.Status.MERGED) {
        // Since voting on merged changes is allowed all labels which apply to
        // the change must be returned. All applying labels can be retrieved from
        // the submit records, which is what initLabels does.
        // It's not possible to only compute the labels based on the approvals
        // since merged changes may not have approvals for all labels (e.g. if not
        // all labels are required for submit or if the change was auto-closed due
        // to direct push or if new labels were defined after the change was
        // merged).
        labels = initLabels(cd, labelTypes, standard);
        // it wouldn't be included in the submit records.
        for (String name : labelNames) {
            if (!labels.containsKey(name)) {
                labels.put(name, LabelWithStatus.create(new LabelInfo(), null));
            }
        }
    } else {
        // For abandoned changes return only labels for which approvals exist.
        // Other labels are not needed since voting on abandoned changes is not
        // allowed.
        labels = new TreeMap<>(labelTypes.nameComparator());
        for (String name : labelNames) {
            labels.put(name, LabelWithStatus.create(new LabelInfo(), null));
        }
    }
    if (detailed) {
        labels.entrySet().stream().filter(e -> labelTypes.byLabel(e.getKey()) != null).forEach(e -> setLabelValues(labelTypes.byLabel(e.getKey()), e.getValue()));
    }
    for (Account.Id accountId : allUsers) {
        Map<String, ApprovalInfo> byLabel = Maps.newHashMapWithExpectedSize(labels.size());
        Map<String, VotingRangeInfo> pvr = Collections.emptyMap();
        if (detailed) {
            ChangeControl ctl = baseCtrl.forUser(userFactory.create(accountId));
            pvr = getPermittedVotingRanges(permittedLabels(ctl, cd));
            for (Map.Entry<String, LabelWithStatus> entry : labels.entrySet()) {
                ApprovalInfo ai = approvalInfo(accountId, 0, null, null, null);
                byLabel.put(entry.getKey(), ai);
                addApproval(entry.getValue().label(), ai);
            }
        }
        for (PatchSetApproval psa : current.get(accountId)) {
            LabelType type = labelTypes.byLabel(psa.getLabelId());
            if (type == null) {
                continue;
            }
            short val = psa.getValue();
            ApprovalInfo info = byLabel.get(type.getName());
            if (info != null) {
                info.value = Integer.valueOf(val);
                info.permittedVotingRange = pvr.getOrDefault(type.getName(), null);
                info.date = psa.getGranted();
                info.tag = psa.getTag();
                if (psa.isPostSubmit()) {
                    info.postSubmit = true;
                }
            }
            if (!standard) {
                continue;
            }
            setLabelScores(type, labels.get(type.getName()), val, accountId);
        }
    }
    return labels;
}
#end_block

#method_before
private ApprovalInfo approvalInfo(Account.Id id, Integer value, Integer maxPermittedValue, String tag, Timestamp date) {
    ApprovalInfo ai = getApprovalInfo(id, value, maxPermittedValue, tag, date);
    accountLoader.put(ai);
    return ai;
}
#method_after
private ApprovalInfo approvalInfo(Account.Id id, Integer value, VotingRangeInfo permittedVotingRange, String tag, Timestamp date) {
    ApprovalInfo ai = getApprovalInfo(id, value, permittedVotingRange, tag, date);
    accountLoader.put(ai);
    return ai;
}
#end_block

#method_before
public static ApprovalInfo getApprovalInfo(Account.Id id, Integer value, Integer maxPermittedValue, String tag, Timestamp date) {
    ApprovalInfo ai = new ApprovalInfo(id.get());
    ai.value = value;
    ai.maxPermittedValue = maxPermittedValue;
    ai.date = date;
    ai.tag = tag;
    return ai;
}
#method_after
public static ApprovalInfo getApprovalInfo(Account.Id id, Integer value, VotingRangeInfo permittedVotingRange, String tag, Timestamp date) {
    ApprovalInfo ai = new ApprovalInfo(id.get());
    ai.value = value;
    ai.permittedVotingRange = permittedVotingRange;
    ai.date = date;
    ai.tag = tag;
    return ai;
}
#end_block

#method_before
private Map<String, Collection<String>> permittedLabels(ChangeControl ctl, ChangeData cd) throws OrmException {
    if (ctl == null) {
        return null;
    }
    LabelTypes labelTypes = ctl.getLabelTypes();
    SetMultimap<String, String> permitted = LinkedHashMultimap.create();
    for (SubmitRecord rec : submitRecords(cd)) {
        if (rec.labels == null) {
            continue;
        }
        for (SubmitRecord.Label r : rec.labels) {
            LabelType type = labelTypes.byLabel(r.label);
            if (type == null) {
                continue;
            }
            PermissionRange range = ctl.getRange(Permission.forLabel(r.label));
            for (LabelValue v : type.getValues()) {
                if (range.contains(v.getValue())) {
                    permitted.put(r.label, v.formatValue());
                }
            }
        }
    }
    List<String> toClear = Lists.newArrayListWithCapacity(permitted.keySet().size());
    for (Map.Entry<String, Collection<String>> e : permitted.asMap().entrySet()) {
        if (isOnlyZero(e.getValue())) {
            toClear.add(e.getKey());
        }
    }
    for (String label : toClear) {
        permitted.removeAll(label);
    }
    return permitted.asMap();
}
#method_after
private Map<String, Collection<String>> permittedLabels(ChangeControl ctl, ChangeData cd) throws OrmException {
    if (ctl == null || !ctl.getUser().isIdentifiedUser()) {
        return null;
    }
    Map<String, Short> labels = null;
    boolean isMerged = ctl.getChange().getStatus() == Change.Status.MERGED;
    LabelTypes labelTypes = ctl.getLabelTypes();
    SetMultimap<String, String> permitted = LinkedHashMultimap.create();
    for (SubmitRecord rec : submitRecords(cd)) {
        if (rec.labels == null) {
            continue;
        }
        for (SubmitRecord.Label r : rec.labels) {
            LabelType type = labelTypes.byLabel(r.label);
            if (type == null || (isMerged && !type.allowPostSubmit())) {
                continue;
            }
            PermissionRange range = ctl.getRange(Permission.forLabel(r.label));
            for (LabelValue v : type.getValues()) {
                boolean ok = range.contains(v.getValue());
                if (isMerged) {
                    if (labels == null) {
                        labels = currentLabels(ctl);
                    }
                    short prev = labels.getOrDefault(type.getName(), (short) 0);
                    ok &= v.getValue() >= prev;
                }
                if (ok) {
                    permitted.put(r.label, v.formatValue());
                }
            }
        }
    }
    List<String> toClear = Lists.newArrayListWithCapacity(permitted.keySet().size());
    for (Map.Entry<String, Collection<String>> e : permitted.asMap().entrySet()) {
        if (isOnlyZero(e.getValue())) {
            toClear.add(e.getKey());
        }
    }
    for (String label : toClear) {
        permitted.removeAll(label);
    }
    return permitted.asMap();
}
#end_block

#method_before
private Map<String, RevisionInfo> revisions(ChangeControl ctl, ChangeData cd, Map<PatchSet.Id, PatchSet> map) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    Map<String, RevisionInfo> res = new LinkedHashMap<>();
    try (Repository repo = openRepoIfNecessary(ctl)) {
        for (PatchSet in : map.values()) {
            if ((has(ALL_REVISIONS) || in.getId().equals(ctl.getChange().currentPatchSetId())) && ctl.isPatchVisible(in, db.get())) {
                res.put(in.getRevision().get(), toRevisionInfo(ctl, cd, in, repo, false));
            }
        }
        return res;
    }
}
#method_after
private Map<String, RevisionInfo> revisions(ChangeControl ctl, ChangeData cd, Map<PatchSet.Id, PatchSet> map, ChangeInfo changeInfo) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    Map<String, RevisionInfo> res = new LinkedHashMap<>();
    try (Repository repo = openRepoIfNecessary(ctl)) {
        for (PatchSet in : map.values()) {
            if ((has(ALL_REVISIONS) || in.getId().equals(ctl.getChange().currentPatchSetId())) && ctl.isPatchVisible(in, db.get())) {
                res.put(in.getRevision().get(), toRevisionInfo(ctl, cd, in, repo, false, changeInfo));
            }
        }
        return res;
    }
}
#end_block

#method_before
public RevisionInfo getRevisionInfo(ChangeControl ctl, PatchSet in) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    accountLoader = accountLoaderFactory.create(has(DETAILED_ACCOUNTS));
    try (Repository repo = openRepoIfNecessary(ctl)) {
        RevisionInfo rev = toRevisionInfo(ctl, changeDataFactory.create(db.get(), ctl), in, repo, true);
        accountLoader.fill();
        return rev;
    }
}
#method_after
public RevisionInfo getRevisionInfo(ChangeControl ctl, PatchSet in) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    accountLoader = accountLoaderFactory.create(has(DETAILED_ACCOUNTS));
    try (Repository repo = openRepoIfNecessary(ctl)) {
        RevisionInfo rev = toRevisionInfo(ctl, changeDataFactory.create(db.get(), ctl), in, repo, true, null);
        accountLoader.fill();
        return rev;
    }
}
#end_block

#method_before
private RevisionInfo toRevisionInfo(ChangeControl ctl, ChangeData cd, PatchSet in, @Nullable Repository repo, boolean fillCommit) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    Change c = ctl.getChange();
    RevisionInfo out = new RevisionInfo();
    out.isCurrent = in.getId().equals(c.currentPatchSetId());
    out._number = in.getId().get();
    out.ref = in.getRefName();
    out.created = in.getCreatedOn();
    out.uploader = accountLoader.get(in.getUploader());
    out.draft = in.isDraft() ? true : null;
    out.fetch = makeFetchMap(ctl, in);
    out.kind = changeKindCache.getChangeKind(repo, cd, in);
    boolean setCommit = has(ALL_COMMITS) || (out.isCurrent && has(CURRENT_COMMIT));
    boolean addFooters = out.isCurrent && has(COMMIT_FOOTERS);
    if (setCommit || addFooters) {
        Project.NameKey project = c.getProject();
        try (RevWalk rw = new RevWalk(repo)) {
            String rev = in.getRevision().get();
            RevCommit commit = rw.parseCommit(ObjectId.fromString(rev));
            rw.parseBody(commit);
            if (setCommit) {
                out.commit = toCommit(ctl, rw, commit, has(WEB_LINKS), fillCommit);
            }
            if (addFooters) {
                out.commitWithFooters = mergeUtilFactory.create(projectCache.get(project)).createCherryPickCommitMessage(commit, ctl, in.getId());
            }
        }
    }
    if (has(ALL_FILES) || (out.isCurrent && has(CURRENT_FILES))) {
        out.files = fileInfoJson.toFileInfoMap(c, in);
        out.files.remove(Patch.COMMIT_MSG);
        out.files.remove(Patch.MERGE_LIST);
    }
    if ((out.isCurrent || (out.draft != null && out.draft)) && has(CURRENT_ACTIONS) && userProvider.get().isIdentifiedUser()) {
        actionJson.addRevisionActions(out, new RevisionResource(changeResourceFactory.create(ctl), in));
    }
    if (gpgApi.isEnabled() && has(PUSH_CERTIFICATES)) {
        if (in.getPushCertificate() != null) {
            out.pushCertificate = gpgApi.checkPushCertificate(in.getPushCertificate(), userFactory.create(in.getUploader()));
        } else {
            out.pushCertificate = new PushCertificateInfo();
        }
    }
    return out;
}
#method_after
private RevisionInfo toRevisionInfo(ChangeControl ctl, ChangeData cd, PatchSet in, @Nullable Repository repo, boolean fillCommit, @Nullable ChangeInfo changeInfo) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    Change c = ctl.getChange();
    RevisionInfo out = new RevisionInfo();
    out.isCurrent = in.getId().equals(c.currentPatchSetId());
    out._number = in.getId().get();
    out.ref = in.getRefName();
    out.created = in.getCreatedOn();
    out.uploader = accountLoader.get(in.getUploader());
    out.draft = in.isDraft() ? true : null;
    out.fetch = makeFetchMap(ctl, in);
    out.kind = changeKindCache.getChangeKind(repo, cd, in);
    out.description = in.getDescription();
    boolean setCommit = has(ALL_COMMITS) || (out.isCurrent && has(CURRENT_COMMIT));
    boolean addFooters = out.isCurrent && has(COMMIT_FOOTERS);
    if (setCommit || addFooters) {
        Project.NameKey project = c.getProject();
        try (RevWalk rw = new RevWalk(repo)) {
            String rev = in.getRevision().get();
            RevCommit commit = rw.parseCommit(ObjectId.fromString(rev));
            rw.parseBody(commit);
            if (setCommit) {
                out.commit = toCommit(ctl, rw, commit, has(WEB_LINKS), fillCommit);
            }
            if (addFooters) {
                Ref ref = repo.exactRef(ctl.getChange().getDest().get());
                RevCommit mergeTip = null;
                if (ref != null) {
                    mergeTip = rw.parseCommit(ref.getObjectId());
                    rw.parseBody(mergeTip);
                }
                out.commitWithFooters = mergeUtilFactory.create(projectCache.get(project)).createCommitMessageOnSubmit(commit, mergeTip, ctl, in.getId());
            }
        }
    }
    if (has(ALL_FILES) || (out.isCurrent && has(CURRENT_FILES))) {
        out.files = fileInfoJson.toFileInfoMap(c, in);
        out.files.remove(Patch.COMMIT_MSG);
        out.files.remove(Patch.MERGE_LIST);
    }
    if ((out.isCurrent || (out.draft != null && out.draft)) && has(CURRENT_ACTIONS) && userProvider.get().isIdentifiedUser()) {
        actionJson.addRevisionActions(changeInfo, out, new RevisionResource(changeResourceFactory.create(ctl), in));
    }
    if (gpgApi.isEnabled() && has(PUSH_CERTIFICATES)) {
        if (in.getPushCertificate() != null) {
            out.pushCertificate = gpgApi.checkPushCertificate(in.getPushCertificate(), userFactory.create(in.getUploader()));
        } else {
            out.pushCertificate = new PushCertificateInfo();
        }
    }
    return out;
}
#end_block

#method_before
@Override
public void onTopicEdited(TopicEditedListener.Event event) {
    ChangeInfo change = event.getChange();
    String oldTopic = event.getOldTopic();
    try {
        String revision = gApi.changes().id(change.id).get(EnumSet.of(ListChangesOption.CURRENT_REVISION)).currentRevision;
        Set<String> downstreamBranches = config.getDownstreamBranches(change.branch, change.project);
        if (downstreamBranches.isEmpty()) {
            log.info("Downstream branches of {} on {} are empty", change.branch, change.project);
            return;
        }
        for (String downstreamBranch : downstreamBranches) {
            List<Integer> existingDownstream = getExistingMergesOnBranch(revision, oldTopic, downstreamBranch);
            for (Integer changeNumber : existingDownstream) {
                log.info("Setting topic {} on {}", change.topic, changeNumber);
                gApi.changes().id(changeNumber).topic(change.topic);
            }
        }
    } catch (RestApiException | IOException e) {
        log.error("Failed to edit downstream topics of {}", change.id, e);
    }
}
#method_after
@Override
public void onTopicEdited(TopicEditedListener.Event event) {
    ChangeInfo change = event.getChange();
    String oldTopic = event.getOldTopic();
    String revision = change.currentRevision;
    Set<String> downstreamBranches;
    try {
        downstreamBranches = config.getDownstreamBranches(change.branch, change.project);
    } catch (RestApiException | IOException e) {
        log.error("Failed to edit downstream topics of {}", change.id, e);
        return;
    }
    if (downstreamBranches.isEmpty()) {
        log.info("Downstream branches of {} on {} are empty", change.branch, change.project);
        return;
    }
    for (String downstreamBranch : downstreamBranches) {
        try {
            List<Integer> existingDownstream = getExistingMergesOnBranch(revision, oldTopic, downstreamBranch);
            for (Integer changeNumber : existingDownstream) {
                log.info("Setting topic {} on {}", change.topic, changeNumber);
                gApi.changes().id(changeNumber).topic(change.topic);
            }
        } catch (RestApiException e) {
            log.error("RestApiException when editing downstream topics of {}", change.id, e);
        }
    }
}
#end_block

#method_before
@Override
public void onCommentAdded(CommentAddedListener.Event event) {
    ChangeInfo change = event.getChange();
    try {
        String revision = gApi.changes().id(change.id).get(EnumSet.of(ListChangesOption.CURRENT_REVISION)).currentRevision;
        Set<String> downstreamBranches = config.getDownstreamBranches(change.branch, change.project);
        if (downstreamBranches.isEmpty()) {
            log.info("Downstream branches of {} on {} are empty", change.branch, change.project);
            return;
        }
        Map<String, ApprovalInfo> approvals = event.getApprovals();
        for (String downstreamBranch : downstreamBranches) {
            List<Integer> existingDownstream = getExistingMergesOnBranch(revision, change.topic, downstreamBranch);
            for (Integer changeNumber : existingDownstream) {
                ChangeInfo downstreamChange = gApi.changes().id(changeNumber).get(EnumSet.of(ListChangesOption.CURRENT_REVISION));
                for (String label : approvals.keySet()) {
                    ApprovalInfo vote = approvals.get(label);
                    updateVote(downstreamChange, label, vote.value.shortValue());
                }
            }
        }
    } catch (RestApiException | IOException e) {
        log.error("Failed to edit downstream votes of {}", change.id, e);
    }
}
#method_after
@Override
public void onCommentAdded(CommentAddedListener.Event event) {
    RevisionInfo eventRevision = event.getRevision();
    if (!eventRevision.isCurrent) {
        log.info("Not updating downstream votes since revision {} is not current.", eventRevision._number);
        return;
    }
    ChangeInfo change = event.getChange();
    String revision = change.currentRevision;
    Set<String> downstreamBranches;
    try {
        downstreamBranches = config.getDownstreamBranches(change.branch, change.project);
    } catch (RestApiException | IOException e) {
        log.error("Failed to update downstream votes of {}", change.id, e);
        return;
    }
    if (downstreamBranches.isEmpty()) {
        log.debug("Downstream branches of {} on {} are empty", change.branch, change.project);
        return;
    }
    Map<String, ApprovalInfo> approvals = event.getApprovals();
    for (String downstreamBranch : downstreamBranches) {
        try {
            List<Integer> existingDownstream = getExistingMergesOnBranch(revision, change.topic, downstreamBranch);
            for (Integer changeNumber : existingDownstream) {
                ChangeInfo downstreamChange = gApi.changes().id(changeNumber).get(EnumSet.of(ListChangesOption.CURRENT_REVISION));
                for (Map.Entry<String, ApprovalInfo> label : approvals.entrySet()) {
                    updateVote(downstreamChange, label.getKey(), label.getValue().value.shortValue());
                }
            }
        } catch (RestApiException e) {
            log.error("RestApiException when updating downstream votes of {}", change.id, e);
        }
    }
}
#end_block

#method_before
private void abandonDownstream(ChangeInfo change, String revision) {
    try {
        Set<String> downstreamBranches = config.getDownstreamBranches(change.branch, change.project);
        if (downstreamBranches.isEmpty()) {
            log.info("Downstream branches of {} on {} are empty", change.branch, change.project);
            return;
        }
        for (String downstreamBranch : downstreamBranches) {
            List<Integer> existingDownstream = getExistingMergesOnBranch(revision, change.topic, downstreamBranch);
            log.info("Abandoning existing downstreams: {}", existingDownstream);
            for (Integer changeNumber : existingDownstream) {
                abandonChange(changeNumber);
            }
        }
    } catch (RestApiException | IOException e) {
        log.error("Failed to abandon downstreams of {}", change.id, e);
    }
}
#method_after
private void abandonDownstream(ChangeInfo change, String revision) {
    try {
        Set<String> downstreamBranches = config.getDownstreamBranches(change.branch, change.project);
        if (downstreamBranches.isEmpty()) {
            log.debug("Downstream branches of {} on {} are empty", change.branch, change.project);
            return;
        }
        for (String downstreamBranch : downstreamBranches) {
            List<Integer> existingDownstream = getExistingMergesOnBranch(revision, change.topic, downstreamBranch);
            log.info("Abandoning existing downstreams: {}", existingDownstream);
            for (Integer changeNumber : existingDownstream) {
                abandonChange(changeNumber);
            }
        }
    } catch (RestApiException | IOException e) {
        log.error("Failed to abandon downstreams of {}", change.id, e);
    }
}
#end_block

#method_before
private void updateVote(ChangeInfo change, String label, Short vote) throws RestApiException {
    if (label.equals(config.getAutomergeLabel())) {
        log.info("Not updating automerge label, as it blocks when there is a merge conflict.");
        return;
    }
    log.info("Giving {} for label {} to {}", vote, label, change.id);
    // Vote on all downstream branches unless merge conflict.
    ReviewInput reviewInput = new ReviewInput();
    Map<String, Short> labels = new HashMap<String, Short>();
    labels.put(label, vote);
    reviewInput.labels = labels;
    gApi.changes().id(change.id).revision(change.currentRevision).review(reviewInput);
}
#method_after
private void updateVote(ChangeInfo change, String label, short vote) throws RestApiException {
    if (label.equals(config.getAutomergeLabel())) {
        log.info("Not updating automerge label, as it blocks when there is a merge conflict.");
        return;
    }
    log.info("Giving {} for label {} to {}", vote, label, change.id);
    // Vote on all downstream branches unless merge conflict.
    ReviewInput reviewInput = new ReviewInput();
    Map<String, Short> labels = new HashMap<String, Short>();
    labels.put(label, vote);
    reviewInput.labels = labels;
    gApi.changes().id(change.id).revision(change.currentRevision).review(reviewInput);
}
#end_block

#method_before
@Provides
@Singleton
BowerComponentsServlet getBowerComponentsServlet(@Named(CACHE) Cache<Path, Resource> cache) throws IOException {
    return new BowerComponentsServlet(cache, getPaths().builder);
}
#method_after
@Provides
@Singleton
BowerComponentsDevServlet getBowerComponentsServlet(@Named(CACHE) Cache<Path, Resource> cache) throws IOException {
    return getPaths().isDev() ? new BowerComponentsDevServlet(cache, getPaths().builder) : null;
}
#end_block

#method_before
@Provides
@Singleton
FontsServlet getFontsServlet(@Named(CACHE) Cache<Path, Resource> cache) throws IOException {
    return new FontsServlet(cache, getPaths().builder);
}
#method_after
@Provides
@Singleton
FontsDevServlet getFontsServlet(@Named(CACHE) Cache<Path, Resource> cache) throws IOException {
    return getPaths().isDev() ? new FontsDevServlet(cache, getPaths().builder) : null;
}
#end_block

#method_before
@Override
public void doFilter(ServletRequest request, ServletResponse res, FilterChain chain) throws IOException, ServletException {
    String pkg = "gerrit-gwtui";
    String target = "ui_" + rule.select((HttpServletRequest) request);
    if (gwtuiRecompile || !uaInitialized.contains(target)) {
        String rule = "//" + pkg + ":" + target;
        // TODO(davido): instead of assuming specific Buck's internal
        // target directory for gwt_binary() artifacts, ask Buck for
        // the location of user agent permutation GWT zip, e. g.:
        // $ buck targets --show_output //gerrit-gwtui:ui_safari \
        // | awk '{print $2}'
        String child = String.format("%s/__gwt_binary_%s__", pkg, target);
        BuildSystem.Label label = new BuildSystem.Label(pkg, target + ".zip");
        File zip = builder.targetPath(label).toFile();
        synchronized (this) {
            try {
                builder.build(label);
            } catch (BuildSystem.BuildFailureException e) {
                e.display(rule, (HttpServletResponse) res);
                return;
            }
            if (!target.equals(lastTarget) || lastTime != zip.lastModified()) {
                lastTarget = target;
                lastTime = zip.lastModified();
                unpack(zip, unpackedWar.toFile());
            }
        }
        uaInitialized.add(target);
    }
    chain.doFilter(request, res);
}
#method_after
@Override
public void doFilter(ServletRequest request, ServletResponse res, FilterChain chain) throws IOException, ServletException {
    String agent = rule.select((HttpServletRequest) request);
    if (unpackedWar != null && (gwtuiRecompile || !uaInitialized.contains(agent))) {
        Label label = builder.gwtZipLabel(agent);
        File zip = builder.targetPath(label).toFile();
        synchronized (this) {
            try {
                builder.build(label);
            } catch (BuildSystem.BuildFailureException e) {
                e.display(label.toString(), (HttpServletResponse) res);
                return;
            }
            if (!agent.equals(lastAgent) || lastTime != zip.lastModified()) {
                lastAgent = agent;
                lastTime = zip.lastModified();
                unpack(zip, unpackedWar.toFile());
            }
        }
        uaInitialized.add(agent);
    }
    chain.doFilter(request, res);
}
#end_block

#method_before
public static Path resolveInSourceRoot(String name) throws FileNotFoundException {
    // Find ourselves in the classpath, as a loose class file or jar.
    Class<GerritLauncher> self = GerritLauncher.class;
    // If the build system provides us with a source root, use that.
    try (InputStream stream = self.getResourceAsStream(SOURCE_ROOT_RESOURCE)) {
        System.err.println("URL: " + stream);
        if (stream != null) {
            Scanner scan = new java.util.Scanner(stream, "UTF-8").useDelimiter("\n");
            if (scan.hasNext()) {
                Path p = Paths.get(scan.next());
                if (!Files.exists(p)) {
                    throw new FileNotFoundException("source root not found: " + p);
                }
                return p;
            }
        }
    } catch (IOException e) {
    // not Bazel, then.
    }
    URL u = self.getResource(self.getSimpleName() + ".class");
    if (u == null) {
        throw new FileNotFoundException("Cannot find class " + self.getName());
    } else if ("jar".equals(u.getProtocol())) {
        String p = u.getPath();
        try {
            u = new URL(p.substring(0, p.indexOf('!')));
        } catch (MalformedURLException e) {
            FileNotFoundException fnfe = new FileNotFoundException("Not a valid jar file: " + u);
            fnfe.initCause(e);
            throw fnfe;
        }
    }
    if (!"file".equals(u.getProtocol())) {
        throw new FileNotFoundException("Cannot extract path from " + u);
    }
    // Pop up to the top-level source folder by looking for .buckconfig.
    Path dir = Paths.get(u.getPath());
    while (!Files.isRegularFile(dir.resolve(".buckconfig"))) {
        Path parent = dir.getParent();
        if (parent == null) {
            throw new FileNotFoundException("Cannot find source root from " + u);
        }
        dir = parent;
    }
    Path ret = dir.resolve(name);
    if (!Files.exists(ret)) {
        throw new FileNotFoundException(name + " not found in source root " + dir);
    }
    return ret;
}
#method_after
public static Path resolveInSourceRoot(String name) throws FileNotFoundException {
    // Find ourselves in the classpath, as a loose class file or jar.
    Class<GerritLauncher> self = GerritLauncher.class;
    // If the build system provides us with a source root, use that.
    try (InputStream stream = self.getResourceAsStream(SOURCE_ROOT_RESOURCE)) {
        System.err.println("URL: " + stream);
        if (stream != null) {
            try (Scanner scan = new Scanner(stream, UTF_8.name()).useDelimiter("\n")) {
                if (scan.hasNext()) {
                    Path p = Paths.get(scan.next());
                    if (!Files.exists(p)) {
                        throw new FileNotFoundException("source root not found: " + p);
                    }
                    return p;
                }
            }
        }
    } catch (IOException e) {
    // not Bazel, then.
    }
    URL u = self.getResource(self.getSimpleName() + ".class");
    if (u == null) {
        throw new FileNotFoundException("Cannot find class " + self.getName());
    } else if ("jar".equals(u.getProtocol())) {
        String p = u.getPath();
        try {
            u = new URL(p.substring(0, p.indexOf('!')));
        } catch (MalformedURLException e) {
            FileNotFoundException fnfe = new FileNotFoundException("Not a valid jar file: " + u);
            fnfe.initCause(e);
            throw fnfe;
        }
    }
    if (!"file".equals(u.getProtocol())) {
        throw new FileNotFoundException("Cannot extract path from " + u);
    }
    // Pop up to the top-level source folder by looking for .buckconfig.
    Path dir = Paths.get(u.getPath());
    while (!Files.isRegularFile(dir.resolve(".buckconfig"))) {
        Path parent = dir.getParent();
        if (parent == null) {
            throw new FileNotFoundException("Cannot find source root from " + u);
        }
        dir = parent;
    }
    Path ret = dir.resolve(name);
    if (!Files.exists(ret)) {
        throw new FileNotFoundException(name + " not found in source root " + dir);
    }
    return ret;
}
#end_block

#method_before
@Override
public void build(Label label) throws IOException, BuildFailureException {
    log.info("buck build " + label);
    Properties properties = loadBuckProperties(targetPath(label));
    String buck = firstNonNull(properties.getProperty("buck"), "buck");
    ProcessBuilder proc = new ProcessBuilder(buck, "build", label.fullName()).directory(sourceRoot.toFile()).redirectErrorStream(true);
    if (properties.containsKey("PATH")) {
        proc.environment().put("PATH", properties.getProperty("PATH"));
    }
    long start = TimeUtil.nowMs();
    Process rebuild = proc.start();
    byte[] out;
    try (InputStream in = rebuild.getInputStream()) {
        out = ByteStreams.toByteArray(in);
    } finally {
        rebuild.getOutputStream().close();
    }
    int status;
    try {
        status = rebuild.waitFor();
    } catch (InterruptedException e) {
        throw new InterruptedIOException("interrupted waiting for " + buck);
    }
    if (status != 0) {
        throw new BuildFailureException(out);
    }
    long time = TimeUtil.nowMs() - start;
    log.info(String.format("UPDATED    %s in %.3fs", label.fullName(), time / 1000.0));
}
#method_after
@Override
public void build(Label label) throws IOException, BuildFailureException {
    log.info("buck build " + label.fullName());
    Properties properties = loadBuckProperties(sourceRoot.resolve("buck-out/gen/tools/buck/buck.properties"));
    String buck = firstNonNull(properties.getProperty("buck"), "buck");
    ProcessBuilder proc = new ProcessBuilder(buck, "build", label.fullName()).directory(sourceRoot.toFile()).redirectErrorStream(true);
    if (properties.containsKey("PATH")) {
        proc.environment().put("PATH", properties.getProperty("PATH"));
    }
    long start = TimeUtil.nowMs();
    Process rebuild = proc.start();
    byte[] out;
    try (InputStream in = rebuild.getInputStream()) {
        out = ByteStreams.toByteArray(in);
    } finally {
        rebuild.getOutputStream().close();
    }
    int status;
    try {
        status = rebuild.waitFor();
    } catch (InterruptedException e) {
        throw new InterruptedIOException("interrupted waiting for " + buck);
    }
    if (status != 0) {
        throw new BuildFailureException(out);
    }
    long time = TimeUtil.nowMs() - start;
    log.info(String.format("UPDATED    %s in %.3fs", label.fullName(), time / 1000.0));
}
#end_block

#method_before
private static Properties loadBuckProperties(Path gen) throws IOException {
    Properties properties = new Properties();
    Path p = gen.resolve(Paths.get("tools/buck/buck.properties"));
    try (InputStream in = Files.newInputStream(p)) {
        properties.load(in);
    } catch (NoSuchFileException e) {
    // Ignore; will be run from PATH, with a descriptive error if it fails.
    }
    return properties;
}
#method_after
private static Properties loadBuckProperties(Path propPath) throws IOException {
    Properties properties = new Properties();
    try (InputStream in = Files.newInputStream(propPath)) {
        properties.load(in);
    } catch (NoSuchFileException e) {
    // Ignore; will be run from PATH, with a descriptive error if it fails.
    }
    return properties;
}
#end_block

#method_before
@Override
public Path targetPath(Label label) {
    return sourceRoot.resolve("buck-out").resolve("gen").resolve(label.pkg).resolve(label.name).resolve(label.artifact);
}
#method_after
@Override
public Path targetPath(Label label) {
    return sourceRoot.resolve("buck-out").resolve("gen").resolve(label.artifact);
}
#end_block

#method_before
@Deprecated
public String getInlineComments(int lines) {
    StringBuilder cmts = new StringBuilder();
    for (FileCommentGroup group : getGroupedInlineComments()) {
        String link = group.getLink();
        if (link != null) {
            cmts.append(link).append('\n');
        }
        cmts.append(group.getTitle()).append(":\n\n");
        for (Comment c : group.comments) {
            appendComment(cmts, lines, group.fileData, c);
        }
        cmts.append("\n\n");
    }
    return cmts.toString();
}
#method_after
@Deprecated
public String getInlineComments(int lines) {
    try (Repository repo = getRepository()) {
        StringBuilder cmts = new StringBuilder();
        for (FileCommentGroup group : getGroupedInlineComments(repo)) {
            String link = group.getLink();
            if (link != null) {
                cmts.append(link).append('\n');
            }
            cmts.append(group.getTitle()).append(":\n\n");
            for (Comment c : group.comments) {
                appendComment(cmts, lines, group.fileData, c);
            }
            cmts.append("\n\n");
        }
        return cmts.toString();
    }
}
#end_block

#method_before
private List<CommentSender.FileCommentGroup> getGroupedInlineComments() {
    List<CommentSender.FileCommentGroup> groups = new ArrayList<>();
    try (Repository repo = getRepository()) {
        // Get the patch list:
        PatchList patchList = null;
        if (repo != null) {
            try {
                patchList = getPatchList();
            } catch (PatchListNotAvailableException e) {
                log.error("Failed to get patch list", e);
            }
        }
        // Loop over the comments and collect them into groups based on the file
        // location of the comment.
        FileCommentGroup currentGroup = null;
        for (Comment c : inlineComments) {
            // If it's a new group:
            if (currentGroup == null || !c.key.filename.equals(currentGroup.filename) || c.key.patchSetId != currentGroup.patchSetId) {
                currentGroup = new FileCommentGroup();
                currentGroup.filename = c.key.filename;
                currentGroup.patchSetId = c.key.patchSetId;
                groups.add(currentGroup);
                if (patchList != null) {
                    try {
                        currentGroup.fileData = new PatchFile(repo, patchList, c.key.filename);
                    } catch (IOException e) {
                        log.warn(String.format("Cannot load %s from %s in %s", c.key.filename, patchList.getNewId().name(), projectState.getProject().getName()), e);
                        currentGroup.fileData = null;
                    }
                }
            }
            if (currentGroup.fileData != null) {
                currentGroup.comments.add(c);
            }
        }
    }
    Collections.sort(groups, Comparator.comparing(g -> g.filename, FilenameComparator.INSTANCE));
    return groups;
}
#method_after
private List<CommentSender.FileCommentGroup> getGroupedInlineComments(Repository repo) {
    List<CommentSender.FileCommentGroup> groups = new ArrayList<>();
    // Get the patch list:
    PatchList patchList = null;
    if (repo != null) {
        try {
            patchList = getPatchList();
        } catch (PatchListNotAvailableException e) {
            log.error("Failed to get patch list", e);
        }
    }
    // Loop over the comments and collect them into groups based on the file
    // location of the comment.
    FileCommentGroup currentGroup = null;
    for (Comment c : inlineComments) {
        // If it's a new group:
        if (currentGroup == null || !c.key.filename.equals(currentGroup.filename) || c.key.patchSetId != currentGroup.patchSetId) {
            currentGroup = new FileCommentGroup();
            currentGroup.filename = c.key.filename;
            currentGroup.patchSetId = c.key.patchSetId;
            groups.add(currentGroup);
            if (patchList != null) {
                try {
                    currentGroup.fileData = new PatchFile(repo, patchList, c.key.filename);
                } catch (IOException e) {
                    log.warn(String.format("Cannot load %s from %s in %s", c.key.filename, patchList.getNewId().name(), projectState.getProject().getName()), e);
                    currentGroup.fileData = null;
                }
            }
        }
        if (currentGroup.fileData != null) {
            currentGroup.comments.add(c);
        }
    }
    Collections.sort(groups, Comparator.comparing(g -> g.filename, FilenameComparator.INSTANCE));
    return groups;
}
#end_block

#method_before
private List<String> getLinesOfComment(Comment comment, PatchFile fileData) {
    List<String> lines = new ArrayList<>();
    if (comment.range == null) {
        lines.add(getLine(fileData, comment.side, comment.lineNbr));
    } else {
        lines.addAll(getLinesByRange(comment.range, fileData, comment.side));
    }
    return lines;
}
#method_after
private List<String> getLinesOfComment(Comment comment, PatchFile fileData) {
    List<String> lines = new ArrayList<>();
    if (comment.lineNbr == 0) {
        // file level comment has no line
        return lines;
    }
    if (comment.range == null) {
        lines.add(getLine(fileData, comment.side, comment.lineNbr));
    } else {
        lines.addAll(getLinesByRange(comment.range, fileData, comment.side));
    }
    return lines;
}
#end_block

#method_before
private List<Map<String, Object>> getCommentGroupsTemplateData() {
    List<Map<String, Object>> commentGroups = new ArrayList<>();
    for (CommentSender.FileCommentGroup group : getGroupedInlineComments()) {
        Map<String, Object> groupData = new HashMap<>();
        groupData.put("link", group.getLink());
        groupData.put("title", group.getTitle());
        groupData.put("patchSetId", group.patchSetId);
        List<Map<String, Object>> commentsList = new ArrayList<>();
        for (Comment comment : group.comments) {
            Map<String, Object> commentData = new HashMap<>();
            commentData.put("lines", getLinesOfComment(comment, group.fileData));
            commentData.put("message", comment.message.trim());
            // Set the prefix.
            String prefix = getCommentLinePrefix(comment);
            commentData.put("linePrefix", prefix);
            commentData.put("linePrefixEmpty", Strings.padStart(": ", prefix.length(), ' '));
            // Set line numbers.
            int startLine;
            if (comment.range == null) {
                startLine = comment.lineNbr;
            } else {
                startLine = comment.range.startLine;
                commentData.put("endLine", comment.range.endLine);
            }
            commentData.put("startLine", startLine);
            // Set the comment link.
            if (comment.lineNbr == 0) {
                commentData.put("link", group.getLink());
            } else if (comment.side == 0) {
                commentData.put("link", group.getLink() + "@a" + startLine);
            } else {
                commentData.put("link", group.getLink() + '@' + startLine);
            }
            // Set robot comment data.
            if (comment instanceof RobotComment) {
                RobotComment robotComment = (RobotComment) comment;
                commentData.put("isRobotComment", true);
                commentData.put("robotId", robotComment.robotId);
                commentData.put("robotRunId", robotComment.robotRunId);
                commentData.put("robotUrl", robotComment.url);
            } else {
                commentData.put("isRobotComment", false);
            }
            // Set parent comment info.
            Optional<Comment> parent = getParent(comment);
            if (parent.isPresent()) {
                commentData.put("parentMessage", getShortenedCommentMessage(parent.get()));
            }
            commentsList.add(commentData);
        }
        groupData.put("comments", commentsList);
        commentGroups.add(groupData);
    }
    return commentGroups;
}
#method_after
private List<Map<String, Object>> getCommentGroupsTemplateData(Repository repo) {
    List<Map<String, Object>> commentGroups = new ArrayList<>();
    for (CommentSender.FileCommentGroup group : getGroupedInlineComments(repo)) {
        Map<String, Object> groupData = new HashMap<>();
        groupData.put("link", group.getLink());
        groupData.put("title", group.getTitle());
        groupData.put("patchSetId", group.patchSetId);
        List<Map<String, Object>> commentsList = new ArrayList<>();
        for (Comment comment : group.comments) {
            Map<String, Object> commentData = new HashMap<>();
            commentData.put("lines", getLinesOfComment(comment, group.fileData));
            commentData.put("message", comment.message.trim());
            // Set the prefix.
            String prefix = getCommentLinePrefix(comment);
            commentData.put("linePrefix", prefix);
            commentData.put("linePrefixEmpty", Strings.padStart(": ", prefix.length(), ' '));
            // Set line numbers.
            int startLine;
            if (comment.range == null) {
                startLine = comment.lineNbr;
            } else {
                startLine = comment.range.startLine;
                commentData.put("endLine", comment.range.endLine);
            }
            commentData.put("startLine", startLine);
            // Set the comment link.
            if (comment.lineNbr == 0) {
                commentData.put("link", group.getLink());
            } else if (comment.side == 0) {
                commentData.put("link", group.getLink() + "@a" + startLine);
            } else {
                commentData.put("link", group.getLink() + '@' + startLine);
            }
            // Set robot comment data.
            if (comment instanceof RobotComment) {
                RobotComment robotComment = (RobotComment) comment;
                commentData.put("isRobotComment", true);
                commentData.put("robotId", robotComment.robotId);
                commentData.put("robotRunId", robotComment.robotRunId);
                commentData.put("robotUrl", robotComment.url);
            } else {
                commentData.put("isRobotComment", false);
            }
            // Set parent comment info.
            Optional<Comment> parent = getParent(comment);
            if (parent.isPresent()) {
                commentData.put("parentMessage", getShortenedCommentMessage(parent.get()));
            }
            commentsList.add(commentData);
        }
        groupData.put("comments", commentsList);
        commentGroups.add(groupData);
    }
    return commentGroups;
}
#end_block

#method_before
@Override
protected void setupSoyContext() {
    super.setupSoyContext();
    soyContext.put("commentFiles", getCommentGroupsTemplateData());
    soyContext.put("commentTimestamp", getCommentTimestamp());
}
#method_after
@Override
protected void setupSoyContext() {
    super.setupSoyContext();
    try (Repository repo = getRepository()) {
        soyContext.put("commentFiles", getCommentGroupsTemplateData(repo));
    }
    soyContext.put("commentTimestamp", getCommentTimestamp());
}
#end_block

#method_before
private String getCommentTimestamp() {
    // Grouping is currently done by timestamp.
    return MailUtil.rfcDateformatter.print(new DateTime(timestamp));
}
#method_after
private String getCommentTimestamp() {
    // Grouping is currently done by timestamp.
    return MailUtil.rfcDateformatter.format(ZonedDateTime.ofInstant(timestamp.toInstant(), ZoneId.of("UTC")));
}
#end_block

#method_before
private static void assertHeaders(Map<String, EmailHeader> have, Map<String, Object> want) throws Exception {
    for (Map.Entry<String, Object> entry : want.entrySet()) {
        if (entry.getValue() instanceof String) {
            assertThat(have).containsEntry("X-" + entry.getKey(), new EmailHeader.String((String) entry.getValue()));
        } else if (entry.getValue() instanceof Date) {
            assertThat(have).containsEntry("X-" + entry.getKey(), new EmailHeader.Date((Date) entry.getValue()));
        } else {
            throw new Exception("Object has unsupported type: " + entry.getValue().getClass().getName() + " must be java.util.Date or java.lang.String");
        }
    }
}
#method_after
private static void assertHeaders(Map<String, EmailHeader> have, Map<String, Object> want) throws Exception {
    for (Map.Entry<String, Object> entry : want.entrySet()) {
        if (entry.getValue() instanceof String) {
            assertThat(have).containsEntry("X-" + entry.getKey(), new EmailHeader.String((String) entry.getValue()));
        } else if (entry.getValue() instanceof Date) {
            assertThat(have).containsEntry("X-" + entry.getKey(), new EmailHeader.Date((Date) entry.getValue()));
        } else {
            throw new Exception("Object has unsupported type: " + entry.getValue().getClass().getName() + " must be java.util.Date or java.lang.String for key " + entry.getKey());
        }
    }
}
#end_block

#method_before
private static void assertTextFooter(String body, Map<String, Object> want) throws Exception {
    for (Map.Entry<String, Object> entry : want.entrySet()) {
        if (entry.getValue() instanceof String) {
            assertThat(body).contains(entry.getKey() + ": " + entry.getValue());
        } else if (entry.getValue() instanceof Date) {
            assertThat(body).contains(entry.getKey() + ": " + MailUtil.rfcDateformatter.print(new DateTime(entry.getValue())));
        } else {
            throw new Exception("Object has unsupported type: " + entry.getValue().getClass().getName() + " must be java.util.Date or java.lang.String");
        }
    }
}
#method_after
private static void assertTextFooter(String body, Map<String, Object> want) throws Exception {
    for (Map.Entry<String, Object> entry : want.entrySet()) {
        if (entry.getValue() instanceof String) {
            assertThat(body).contains(entry.getKey() + ": " + entry.getValue());
        } else if (entry.getValue() instanceof Timestamp) {
            assertThat(body).contains(entry.getKey() + ": " + MailUtil.rfcDateformatter.format(ZonedDateTime.ofInstant(((Timestamp) entry.getValue()).toInstant(), ZoneId.of("UTC"))));
        } else {
            throw new Exception("Object has unsupported type: " + entry.getValue().getClass().getName() + " must be java.util.Date or java.lang.String for key " + entry.getKey());
        }
    }
}
#end_block

#method_before
private void validatePostSubmitLabels(ChangeContext ctx, LabelTypes labelTypes, Map<String, Short> previous, List<PatchSetApproval> ups, List<PatchSetApproval> del) throws ResourceConflictException {
    if (ctx.getChange().getStatus().isOpen()) {
        // Not closed, nothing to validate.
        return;
    } else if (del.isEmpty() && ups.isEmpty()) {
        // No new votes.
        return;
    } else if (ctx.getChange().getStatus() != Change.Status.MERGED) {
        throw new ResourceConflictException("change is closed");
    }
    // Disallow reducing votes on any labels post-submit. This assumes the
    // high values were broadly necessary to submit, so reducing them would
    // make it possible to take a merged change and make it no longer
    // submittable.
    List<PatchSetApproval> reduced = new ArrayList<>(ups.size() + del.size());
    List<String> disallowed = new ArrayList<>(labelTypes.getLabelTypes().size());
    for (PatchSetApproval psa : del) {
        LabelType lt = checkNotNull(labelTypes.byLabel(psa.getLabel()));
        String normName = lt.getName();
        if (!lt.allowPostSubmit()) {
            disallowed.add(normName);
        }
        Short prev = previous.get(normName);
        if (prev != null) {
            reduced.add(psa);
        }
    }
    for (PatchSetApproval psa : ups) {
        LabelType lt = checkNotNull(labelTypes.byLabel(psa.getLabel()));
        String normName = lt.getName();
        if (!lt.allowPostSubmit()) {
            disallowed.add(normName);
        }
        Short prev = previous.get(normName);
        if (prev == null) {
            continue;
        }
        // Should be filtered out above.
        checkState(prev != psa.getValue());
        if (prev > psa.getValue()) {
            reduced.add(psa);
        } else {
            // Set postSubmit bit in ReviewDb; not required for NoteDb, which sets
            // it automatically.
            psa.setPostSubmit(true);
        }
    }
    if (!disallowed.isEmpty()) {
        throw new ResourceConflictException("Voting on labels disallowed after submit: " + disallowed.stream().distinct().sorted().collect(joining(", ")));
    }
    if (!reduced.isEmpty()) {
        throw new ResourceConflictException("Cannot reduce vote on labels for closed change: " + reduced.stream().map(p -> p.getLabel()).distinct().sorted().collect(joining(", ")));
    }
}
#method_after
private void validatePostSubmitLabels(ChangeContext ctx, LabelTypes labelTypes, Map<String, Short> previous, List<PatchSetApproval> ups, List<PatchSetApproval> del) throws ResourceConflictException {
    if (ctx.getChange().getStatus().isOpen()) {
        // Not closed, nothing to validate.
        return;
    } else if (del.isEmpty() && ups.isEmpty()) {
        // No new votes.
        return;
    } else if (ctx.getChange().getStatus() != Change.Status.MERGED) {
        throw new ResourceConflictException("change is closed");
    }
    // Disallow reducing votes on any labels post-submit. This assumes the
    // high values were broadly necessary to submit, so reducing them would
    // make it possible to take a merged change and make it no longer
    // submittable.
    List<PatchSetApproval> reduced = new ArrayList<>(ups.size() + del.size());
    List<String> disallowed = new ArrayList<>(labelTypes.getLabelTypes().size());
    for (PatchSetApproval psa : del) {
        LabelType lt = checkNotNull(labelTypes.byLabel(psa.getLabel()));
        String normName = lt.getName();
        if (!lt.allowPostSubmit()) {
            disallowed.add(normName);
        }
        Short prev = previous.get(normName);
        if (prev != null && prev != 0) {
            reduced.add(psa);
        }
    }
    for (PatchSetApproval psa : ups) {
        LabelType lt = checkNotNull(labelTypes.byLabel(psa.getLabel()));
        String normName = lt.getName();
        if (!lt.allowPostSubmit()) {
            disallowed.add(normName);
        }
        Short prev = previous.get(normName);
        if (prev == null) {
            continue;
        }
        // Should be filtered out above.
        checkState(prev != psa.getValue());
        if (prev > psa.getValue()) {
            reduced.add(psa);
        } else {
            // Set postSubmit bit in ReviewDb; not required for NoteDb, which sets
            // it automatically.
            psa.setPostSubmit(true);
        }
    }
    if (!disallowed.isEmpty()) {
        throw new ResourceConflictException("Voting on labels disallowed after submit: " + disallowed.stream().distinct().sorted().collect(joining(", ")));
    }
    if (!reduced.isEmpty()) {
        throw new ResourceConflictException("Cannot reduce vote on labels for closed change: " + reduced.stream().map(p -> p.getLabel()).distinct().sorted().collect(joining(", ")));
    }
}
#end_block

#method_before
@Test
public void postSubmitApproval() throws Exception {
    PushOneCommit.Result r = createChange();
    String changeId = project.get() + "~master~" + r.getChangeId();
    gApi.changes().id(changeId).current().review(ReviewInput.recommend());
    String label = "Code-Review";
    ApprovalInfo approval = getApproval(changeId, label);
    assertThat(approval.value).isEqualTo(1);
    assertThat(approval.postSubmit).isNull();
    // Submit by direct push.
    git().push().setRefSpecs(new RefSpec(r.getCommit().name() + ":refs/heads/master")).call();
    assertThat(gApi.changes().id(changeId).get().status).isEqualTo(ChangeStatus.MERGED);
    approval = getApproval(changeId, label);
    assertThat(approval.value).isEqualTo(1);
    assertThat(approval.postSubmit).isNull();
    // Repeating the current label is allowed. Does not flip the postSubmit bit
    // due to deduplication codepath.
    gApi.changes().id(changeId).current().review(ReviewInput.recommend());
    approval = getApproval(changeId, label);
    assertThat(approval.value).isEqualTo(1);
    assertThat(approval.postSubmit).isNull();
    // Reducing vote is not allowed.
    try {
        gApi.changes().id(changeId).current().review(ReviewInput.dislike());
        fail("expected ResourceConflictException");
    } catch (ResourceConflictException e) {
        assertThat(e).hasMessage("Cannot reduce vote on labels for closed change: Code-Review");
    }
    approval = getApproval(changeId, label);
    assertThat(approval.value).isEqualTo(1);
    assertThat(approval.postSubmit).isNull();
    // Increasing vote is allowed.
    gApi.changes().id(changeId).current().review(ReviewInput.approve());
    approval = getApproval(changeId, label);
    assertThat(approval.value).isEqualTo(2);
    assertThat(approval.postSubmit).isTrue();
    // Decreasing to previous post-submit vote is still not allowed.
    try {
        gApi.changes().id(changeId).current().review(ReviewInput.dislike());
        fail("expected ResourceConflictException");
    } catch (ResourceConflictException e) {
        assertThat(e).hasMessage("Cannot reduce vote on labels for closed change: Code-Review");
    }
    approval = getApproval(changeId, label);
    assertThat(approval.value).isEqualTo(2);
    assertThat(approval.postSubmit).isTrue();
}
#method_after
@Test
public void postSubmitApproval() throws Exception {
    PushOneCommit.Result r = createChange();
    String changeId = project.get() + "~master~" + r.getChangeId();
    gApi.changes().id(changeId).current().review(ReviewInput.recommend());
    String label = "Code-Review";
    ApprovalInfo approval = getApproval(changeId, label);
    assertThat(approval.value).isEqualTo(1);
    assertThat(approval.postSubmit).isNull();
    // Submit by direct push.
    git().push().setRefSpecs(new RefSpec(r.getCommit().name() + ":refs/heads/master")).call();
    assertThat(gApi.changes().id(changeId).get().status).isEqualTo(ChangeStatus.MERGED);
    approval = getApproval(changeId, label);
    assertThat(approval.value).isEqualTo(1);
    assertThat(approval.postSubmit).isNull();
    assertPermitted(gApi.changes().id(changeId).get(EnumSet.of(DETAILED_LABELS)), "Code-Review", 1, 2);
    // Repeating the current label is allowed. Does not flip the postSubmit bit
    // due to deduplication codepath.
    gApi.changes().id(changeId).current().review(ReviewInput.recommend());
    approval = getApproval(changeId, label);
    assertThat(approval.value).isEqualTo(1);
    assertThat(approval.postSubmit).isNull();
    // Reducing vote is not allowed.
    try {
        gApi.changes().id(changeId).current().review(ReviewInput.dislike());
        fail("expected ResourceConflictException");
    } catch (ResourceConflictException e) {
        assertThat(e).hasMessage("Cannot reduce vote on labels for closed change: Code-Review");
    }
    approval = getApproval(changeId, label);
    assertThat(approval.value).isEqualTo(1);
    assertThat(approval.postSubmit).isNull();
    // Increasing vote is allowed.
    gApi.changes().id(changeId).current().review(ReviewInput.approve());
    approval = getApproval(changeId, label);
    assertThat(approval.value).isEqualTo(2);
    assertThat(approval.postSubmit).isTrue();
    assertPermitted(gApi.changes().id(changeId).get(EnumSet.of(DETAILED_LABELS)), "Code-Review", 2);
    // Decreasing to previous post-submit vote is still not allowed.
    try {
        gApi.changes().id(changeId).current().review(ReviewInput.dislike());
        fail("expected ResourceConflictException");
    } catch (ResourceConflictException e) {
        assertThat(e).hasMessage("Cannot reduce vote on labels for closed change: Code-Review");
    }
    approval = getApproval(changeId, label);
    assertThat(approval.value).isEqualTo(2);
    assertThat(approval.postSubmit).isTrue();
}
#end_block

#method_before
private ApprovalInfo getApproval(String changeId, String label) throws Exception {
    ChangeInfo info = gApi.changes().id(changeId).get(EnumSet.of(ListChangesOption.DETAILED_LABELS));
    LabelInfo li = info.labels.get(label);
    assertThat(li).isNotNull();
    int accountId = atrScope.get().getUser().getAccountId().get();
    return li.all.stream().filter(a -> a._accountId == accountId).findFirst().get();
}
#method_after
private ApprovalInfo getApproval(String changeId, String label) throws Exception {
    ChangeInfo info = gApi.changes().id(changeId).get(EnumSet.of(DETAILED_LABELS));
    LabelInfo li = info.labels.get(label);
    assertThat(li).isNotNull();
    int accountId = atrScope.get().getUser().getAccountId().get();
    return li.all.stream().filter(a -> a._accountId == accountId).findFirst().get();
}
#end_block

#method_before
private List<ChangeControl> changeFromNotesFactory(String id, final CurrentUser currentUser) throws OrmException {
    List<ChangeNotes> changes = changeNotesFactory.create(db, parseId(id));
    return FluentIterable.from(changes).transform(new Function<ChangeNotes, ChangeControl>() {

        @Override
        public ChangeControl apply(ChangeNotes changeNote) {
            return controlForChange(changeNote, currentUser);
        }
    }).filter(Predicates.notNull()).toList();
}
#method_after
private List<ChangeControl> changeFromNotesFactory(String id, final CurrentUser currentUser) throws OrmException, UnloggedFailure {
    List<ChangeNotes> changes = changeNotesFactory.create(db, parseId(id));
    return FluentIterable.from(changes).transform(new Function<ChangeNotes, ChangeControl>() {

        @Override
        public ChangeControl apply(ChangeNotes changeNote) {
            return controlForChange(changeNote, currentUser);
        }
    }).filter(Predicates.notNull()).toList();
}
#end_block

#method_before
private List<Change.Id> parseId(String id) {
    try {
        return Arrays.asList(new Change.Id(Integer.parseInt(id)));
    } catch (NumberFormatException e) {
        log.error("Invalid change ID " + id, e);
        return Collections.emptyList();
    }
}
#method_after
private List<Change.Id> parseId(String id) throws UnloggedFailure {
    try {
        return Arrays.asList(new Change.Id(Integer.parseInt(id)));
    } catch (NumberFormatException e) {
        throw new UnloggedFailure(2, "Invalid change ID " + id, e);
    }
}
#end_block

#method_before
public List<CodeReviewCommit> sort(Collection<CodeReviewCommit> incoming) throws IOException {
    final List<CodeReviewCommit> sorted = new ArrayList<>();
    final Set<CodeReviewCommit> sort = new HashSet<>(incoming);
    while (!sort.isEmpty()) {
        final CodeReviewCommit n = removeOne(sort);
        rw.resetRetain(canMergeFlag);
        rw.markStart(n);
        if (initialTip != null) {
            rw.markUninteresting(initialTip);
        }
        CodeReviewCommit c;
        final List<CodeReviewCommit> contents = new ArrayList<>();
        while ((c = rw.next()) != null) {
            if (!c.has(canMergeFlag) || !incoming.contains(c)) {
                if (isAlreadyMerged(c)) {
                    rw.markUninteresting(c);
                    continue;
                }
                // 
                if (n.missing == null) {
                    n.setStatusCode(CommitMergeStatus.MISSING_DEPENDENCY);
                    n.missing = new ArrayList<>();
                }
                n.missing.add(c);
            } else {
                contents.add(c);
            }
        }
        if (n.getStatusCode() == CommitMergeStatus.MISSING_DEPENDENCY) {
            continue;
        }
        sort.removeAll(contents);
        Collections.reverse(contents);
        sorted.removeAll(contents);
        sorted.addAll(contents);
    }
    return sorted;
}
#method_after
public List<CodeReviewCommit> sort(Collection<CodeReviewCommit> incoming) throws IOException {
    final List<CodeReviewCommit> sorted = new ArrayList<>();
    final Set<CodeReviewCommit> sort = new HashSet<>(incoming);
    while (!sort.isEmpty()) {
        final CodeReviewCommit n = removeOne(sort);
        rw.resetRetain(canMergeFlag);
        rw.markStart(n);
        if (initialTip != null) {
            rw.markUninteresting(initialTip);
        }
        CodeReviewCommit c;
        final List<CodeReviewCommit> contents = new ArrayList<>();
        while ((c = rw.next()) != null) {
            if (!c.has(canMergeFlag) || !incoming.contains(c)) {
                if (isAlreadyMerged(c)) {
                    rw.markUninteresting(c);
                    break;
                }
                // 
                if (n.missing == null) {
                    n.setStatusCode(CommitMergeStatus.MISSING_DEPENDENCY);
                    n.missing = new ArrayList<>();
                }
                n.missing.add(c);
            } else {
                contents.add(c);
            }
        }
        if (n.getStatusCode() == CommitMergeStatus.MISSING_DEPENDENCY) {
            continue;
        }
        sort.removeAll(contents);
        Collections.reverse(contents);
        sorted.removeAll(contents);
        sorted.addAll(contents);
    }
    return sorted;
}
#end_block

#method_before
public static <R extends RestResource> Iterable<UiAction.Description> from(DynamicMap<RestView<R>> views, R resource, Provider<CurrentUser> userProvider, Config cfg) {
    return FluentIterable.from(views).transform((DynamicMap.Entry<RestView<R>> e) -> {
        int d = e.getExportName().indexOf('.');
        if (d < 0) {
            return null;
        }
        RestView<R> view;
        try {
            view = e.getProvider().get();
        } catch (RuntimeException err) {
            log.error(String.format("error creating view %s.%s", e.getPluginName(), e.getExportName()), err);
            return null;
        }
        if (!(view instanceof UiAction)) {
            return null;
        }
        try {
            CapabilityUtils.checkRequiresCapability(userProvider, e.getPluginName(), view.getClass());
        } catch (AuthException exc) {
            return null;
        }
        UiAction.Description dsc = ((UiAction<R>) view).getDescription(resource);
        if (dsc == null || !dsc.isVisible()) {
            return null;
        }
        String name = e.getExportName().substring(d + 1);
        PrivateInternals_UiActionDescription.setMethod(dsc, e.getExportName().substring(0, d));
        String id = "gerrit".equals(e.getPluginName()) ? name : e.getPluginName() + '~' + name;
        PrivateInternals_UiActionDescription.setId(dsc, id);
        dsc.setEnabled(cfg.getBoolean("action", id, "enabled", false));
        return dsc;
    }).filter(Objects::nonNull);
}
#method_after
public static <R extends RestResource> FluentIterable<UiAction.Description> from(RestCollection<?, R> collection, R resource, Provider<CurrentUser> userProvider) {
    return from(collection.views(), resource, userProvider);
}
#end_block

#method_before
public Map<String, ActionInfo> format(RevisionResource rsrc) {
    return toActionMap(rsrc);
}
#method_after
public Map<String, ActionInfo> format(RevisionResource rsrc) throws OrmException {
    ChangeInfo changeInfo = null;
    RevisionInfo revisionInfo = null;
    List<ActionVisitor> visitors = visitors();
    if (!visitors.isEmpty()) {
        changeInfo = changeJson().format(rsrc);
        revisionInfo = checkNotNull(Iterables.getOnlyElement(changeInfo.revisions.values()));
        changeInfo.revisions = null;
    }
    return toActionMap(rsrc, visitors, changeInfo, revisionInfo);
}
#end_block

#method_before
public ChangeInfo addChangeActions(ChangeInfo to, ChangeControl ctl) {
    to.actions = toActionMap(ctl);
    return to;
}
#method_after
public ChangeInfo addChangeActions(ChangeInfo to, ChangeControl ctl) {
    List<ActionVisitor> visitors = visitors();
    to.actions = toActionMap(ctl, visitors, copy(visitors, to));
    return to;
}
#end_block

#method_before
public RevisionInfo addRevisionActions(RevisionInfo to, RevisionResource rsrc) {
    to.actions = toActionMap(rsrc);
    return to;
}
#method_after
public RevisionInfo addRevisionActions(@Nullable ChangeInfo changeInfo, RevisionInfo to, RevisionResource rsrc) throws OrmException {
    List<ActionVisitor> visitors = visitors();
    if (!visitors.isEmpty()) {
        if (changeInfo != null) {
            changeInfo = copy(visitors, changeInfo);
        } else {
            changeInfo = changeJson().format(rsrc);
        }
    }
    to.actions = toActionMap(rsrc, visitors, changeInfo, copy(visitors, to));
    return to;
}
#end_block

#method_before
private Map<String, ActionInfo> toActionMap(RevisionResource rsrc) {
    Map<String, ActionInfo> out = new LinkedHashMap<>();
    if (rsrc.getControl().getUser().isIdentifiedUser()) {
        Provider<CurrentUser> userProvider = Providers.of(rsrc.getControl().getUser());
        for (UiAction.Description d : UiActions.from(revisions, rsrc, userProvider, cfg)) {
            out.put(d.getId(), new ActionInfo(d));
        }
    }
    return out;
}
#method_after
private Map<String, ActionInfo> toActionMap(ChangeControl ctl, List<ActionVisitor> visitors, ChangeInfo changeInfo) {
    Map<String, ActionInfo> out = new LinkedHashMap<>();
    if (!ctl.getUser().isIdentifiedUser()) {
        return out;
    }
    Provider<CurrentUser> userProvider = Providers.of(ctl.getUser());
    FluentIterable<UiAction.Description> descs = UiActions.from(changeViews, changeResourceFactory.create(ctl), userProvider);
    // resulting action map.
    if (ctl.getChange().getStatus().isOpen()) {
        UiAction.Description descr = new UiAction.Description();
        PrivateInternals_UiActionDescription.setId(descr, "followup");
        PrivateInternals_UiActionDescription.setMethod(descr, "POST");
        descr.setTitle("Create follow-up change");
        descr.setLabel("Follow-Up");
        descs = descs.append(descr);
    }
    ACTION: for (UiAction.Description d : descs) {
        ActionInfo actionInfo = new ActionInfo(d);
        for (ActionVisitor visitor : visitors) {
            if (!visitor.visit(d.getId(), actionInfo, changeInfo)) {
                continue ACTION;
            }
        }
        out.put(d.getId(), actionInfo);
    }
    return out;
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    CallbackGroup group = new CallbackGroup();
    if (Gerrit.isSignedIn()) {
        ChangeList.query("change:" + changeId.get() + " has:draft", Collections.<ListChangesOption>emptySet(), group.add(new AsyncCallback<ChangeList>() {

            @Override
            public void onSuccess(ChangeList result) {
                hasDraftComments = result.length() > 0;
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        }));
        ChangeApi.editWithFiles(changeId.get(), group.add(new AsyncCallback<EditInfo>() {

            @Override
            public void onSuccess(EditInfo result) {
                edit = result;
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        }));
    }
    loadChangeInfo(true, group.addFinal(new GerritCallback<ChangeInfo>() {

        @Override
        public void onSuccess(final ChangeInfo info) {
            info.init();
            addExtensionPoints(info, initCurrentRevision(info));
            final RevisionInfo rev = info.revision(revision);
            CallbackGroup group = new CallbackGroup();
            loadCommit(rev, group);
            group.addListener(new GerritCallback<Void>() {

                @Override
                public void onSuccess(Void result) {
                    if (base == null && rev.commit().parents().length() > 1 && Gerrit.getUserPreferences().defaultBaseForMerges() == DefaultBase.FIRST_PARENT) {
                        base = "-1";
                    }
                    loadConfigInfo(info, base);
                }
            });
            group.done();
        }
    }));
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    CallbackGroup group = new CallbackGroup();
    if (Gerrit.isSignedIn()) {
        ChangeList.query("change:" + changeId.get() + " has:draft", Collections.<ListChangesOption>emptySet(), group.add(new AsyncCallback<ChangeList>() {

            @Override
            public void onSuccess(ChangeList result) {
                hasDraftComments = result.length() > 0;
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        }));
        ChangeApi.editWithFiles(changeId.get(), group.add(new AsyncCallback<EditInfo>() {

            @Override
            public void onSuccess(EditInfo result) {
                edit = result;
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        }));
    }
    loadChangeInfo(true, group.addFinal(new GerritCallback<ChangeInfo>() {

        @Override
        public void onSuccess(final ChangeInfo info) {
            info.init();
            addExtensionPoints(info, initCurrentRevision(info));
            final RevisionInfo rev = info.revision(revision);
            CallbackGroup group = new CallbackGroup();
            loadCommit(rev, group);
            group.addListener(new GerritCallback<Void>() {

                @Override
                public void onSuccess(Void result) {
                    if (base == null && rev.commit().parents().length() > 1) {
                        base = Gerrit.getUserPreferences().defaultBaseForMerges().getBase();
                    }
                    loadConfigInfo(info, base);
                }
            });
            group.done();
        }
    }));
}
#end_block

#method_before
public final void defaultBaseForMerges(DefaultBase s) {
    defaultBaseForMergesRaw(s != null ? s.toString() : null);
}
#method_after
public final void defaultBaseForMerges(DefaultBase b) {
    defaultBaseForMergesRaw(b != null ? b.toString() : null);
}
#end_block

#method_before
@Override
public String getCommand(DownloadScheme scheme, String project) {
    String username = userProvider.get().getUserName();
    if (username == null) {
        return null;
    }
    String projectName = getBaseName(project);
    if (configCommand != null) {
        return new StringBuilder().append(super.getCommand(scheme, project)).append(" && (cd ").append(projectName).append(" && ").append(configCommand).append(")").toString();
    }
    if (scheme instanceof SshScheme) {
        StringBuilder b = new StringBuilder().append(super.getCommand(scheme, project)).append(" && scp -p");
        if (sshScheme.getSshdPort() != 22) {
            b.append(" -P ").append(sshScheme.getSshdPort());
        }
        b.append(" ").append(username).append("@").append(sshScheme.getSshdHost()).append(":").append(HOOK).append(" ").append(projectName).append("/.git/hooks/");
        return b.toString();
    }
    if (scheme instanceof HttpScheme || scheme instanceof AnonymousHttpScheme) {
        return new StringBuilder().append(super.getCommand(scheme, project)).append(" && (cd ").append(projectName).append(" && curl -kLo").append(TARGET).append(HOOK).append(" ").append(getHttpHost(scheme.getUrl(project), project)).append("tools/").append(HOOK).append("; chmod +x").append(TARGET).append(HOOK).append(")").toString();
    }
    return null;
}
#method_after
@Override
public String getCommand(DownloadScheme scheme, String project) {
    String username = userProvider.get().getUserName();
    if (username == null) {
        return null;
    }
    String projectName = getBaseName(project);
    if (configCommand != null) {
        return new StringBuilder().append(super.getCommand(scheme, project)).append(" && (cd ").append(projectName).append(" && ").append(configCommand).append(")").toString();
    }
    if (scheme instanceof SshScheme) {
        StringBuilder b = new StringBuilder().append(super.getCommand(scheme, project)).append(" && scp -p");
        if (sshScheme.getSshdPort() != 22) {
            b.append(" -P ").append(sshScheme.getSshdPort());
        }
        b.append(" ").append(username).append("@").append(sshScheme.getSshdHost()).append(":").append(HOOK).append(" ").append(projectName).append("/.git/hooks/");
        return b.toString();
    }
    if (scheme instanceof HttpScheme || scheme instanceof AnonymousHttpScheme) {
        return new StringBuilder().append(super.getCommand(scheme, project)).append(" && (cd ").append(projectName).append(" && curl -kLo").append(TARGET).append(HOOK).append(" ").append(getHttpHost(scheme, project)).append("tools/").append(HOOK).append("; chmod +x").append(TARGET).append(HOOK).append(")").toString();
    }
    return null;
}
#end_block

#method_before
private String getHttpHost(String url, String project) {
    int auth = url.lastIndexOf("/a/");
    if (auth > -1) {
        return url.substring(0, auth + 1);
    }
    return url.substring(0, url.lastIndexOf(project));
}
#method_after
private String getHttpHost(DownloadScheme scheme, String project) {
    String host = scheme.getUrl(project);
    host = host.substring(0, host.lastIndexOf(project));
    int auth = host.lastIndexOf("/a/");
    if (auth > -1) {
        host = host.substring(0, auth + 1);
    }
    return host;
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    Util.allow(cfg, Permission.OWNER, REGISTERED_USERS, "refs/*");
    Util.allow(cfg, Permission.PUSH, REGISTERED_USERS, "refs/for/refs/meta/config");
    Util.allow(cfg, Permission.SUBMIT, REGISTERED_USERS, "refs/meta/config");
    saveProjectConfig(project, cfg);
    setApiUser(user);
    fetchRefsMetaConfig();
}
#method_after
@Before
public void setUp() throws Exception {
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    Util.allow(cfg, Permission.OWNER, REGISTERED_USERS, "refs/*");
    Util.allow(cfg, Permission.PUSH, REGISTERED_USERS, "refs/for/refs/meta/config");
    Util.allow(cfg, Permission.SUBMIT, REGISTERED_USERS, RefNames.REFS_CONFIG);
    saveProjectConfig(project, cfg);
    setApiUser(user);
    fetchRefsMetaConfig();
}
#end_block

#method_before
private String testUpdateProjectConfig() throws Exception {
    Config cfg = readProjectConfig();
    assertThat(cfg.getString("project", null, "description")).isNull();
    String desc = "new project description";
    cfg.setString("project", null, "description", desc);
    PushOneCommit.Result r = createConfigChange(cfg);
    String id = r.getChangeId();
    gApi.changes().id(id).current().review(ReviewInput.approve());
    gApi.changes().id(id).current().submit();
    assertThat(gApi.changes().id(id).info().status).isEqualTo(ChangeStatus.MERGED);
    assertThat(gApi.projects().name(project.get()).get().description).isEqualTo(desc);
    fetchRefsMetaConfig();
    assertThat(readProjectConfig().getString("project", null, "description")).isEqualTo(desc);
    String changeRev = gApi.changes().id(id).get().currentRevision;
    String branchRev = gApi.projects().name(project.get()).branch("refs/meta/config").get().revision;
    assertThat(changeRev).isEqualTo(branchRev);
    return id;
}
#method_after
private String testUpdateProjectConfig() throws Exception {
    Config cfg = readProjectConfig();
    assertThat(cfg.getString("project", null, "description")).isNull();
    String desc = "new project description";
    cfg.setString("project", null, "description", desc);
    PushOneCommit.Result r = createConfigChange(cfg);
    String id = r.getChangeId();
    gApi.changes().id(id).current().review(ReviewInput.approve());
    gApi.changes().id(id).current().submit();
    assertThat(gApi.changes().id(id).info().status).isEqualTo(ChangeStatus.MERGED);
    assertThat(gApi.projects().name(project.get()).get().description).isEqualTo(desc);
    fetchRefsMetaConfig();
    assertThat(readProjectConfig().getString("project", null, "description")).isEqualTo(desc);
    String changeRev = gApi.changes().id(id).get().currentRevision;
    String branchRev = gApi.projects().name(project.get()).branch(RefNames.REFS_CONFIG).get().revision;
    assertThat(changeRev).isEqualTo(branchRev);
    return id;
}
#end_block

#method_before
@Test
public void rejectDoubleInheritance() throws Exception {
    // Create separate projects to test the config
    Project.NameKey parent = createProject("projectToInheritFrom");
    Project.NameKey child = createProject("projectWithMalformedConfig");
    String config = gApi.projects().name(child.get()).branch(RefNames.REFS_CONFIG).file("project.config").asString();
    // Append and push malformed project config
    String pattern = "[access]\n" + "\tinheritFrom = " + allProjects.get() + "\n";
    String doubleInherit = pattern + "\tinheritFrom = " + parent.get() + "\n";
    config = config.replace(pattern, doubleInherit);
    TestRepository<InMemoryRepository> childRepo = cloneProject(child, admin);
    // Fetch permission ref
    GitUtil.fetch(childRepo, "refs/meta/config:cfg");
    childRepo.reset("cfg");
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), childRepo, "Subject", "project.config", config);
    push.to(RefNames.REFS_CONFIG).assertErrorStatus("invalid project configuration");
}
#method_after
@Test
public void rejectDoubleInheritance() throws Exception {
    setApiUser(admin);
    // Create separate projects to test the config
    Project.NameKey parent = createProject("projectToInheritFrom");
    Project.NameKey child = createProject("projectWithMalformedConfig");
    String config = gApi.projects().name(child.get()).branch(RefNames.REFS_CONFIG).file("project.config").asString();
    // Append and push malformed project config
    String pattern = "[access]\n" + "\tinheritFrom = " + allProjects.get() + "\n";
    String doubleInherit = pattern + "\tinheritFrom = " + parent.get() + "\n";
    config = config.replace(pattern, doubleInherit);
    TestRepository<InMemoryRepository> childRepo = cloneProject(child, admin);
    // Fetch meta ref
    GitUtil.fetch(childRepo, RefNames.REFS_CONFIG + ":cfg");
    childRepo.reset("cfg");
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), childRepo, "Subject", "project.config", config);
    PushOneCommit.Result res = push.to(RefNames.REFS_CONFIG);
    res.assertErrorStatus();
    res.assertMessage("cannot inherit from multiple projects");
}
#end_block

#method_before
private void fetchRefsMetaConfig() throws Exception {
    git().fetch().setRefSpecs(new RefSpec("refs/meta/config:refs/meta/config")).call();
    testRepo.reset("refs/meta/config");
}
#method_after
private void fetchRefsMetaConfig() throws Exception {
    git().fetch().setRefSpecs(new RefSpec("refs/meta/config:refs/meta/config")).call();
    testRepo.reset(RefNames.REFS_CONFIG);
}
#end_block

#method_before
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    readGroupList();
    Map<String, GroupReference> groupsByName = mapGroupReferences();
    rulesId = getObjectId("rules.pl");
    Config rc = readConfig(PROJECT_CONFIG);
    project = new Project(projectName);
    Project p = project;
    p.setDescription(rc.getString(PROJECT, null, KEY_DESCRIPTION));
    if (p.getDescription() == null) {
        p.setDescription("");
    }
    if (rc.getStringList(ACCESS, null, KEY_INHERIT_FROM).length > 1) {
        throw new ConfigInvalidException("Cannot inherit from multiple projects");
    }
    p.setParentName(rc.getString(ACCESS, null, KEY_INHERIT_FROM));
    p.setUseContributorAgreements(getEnum(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, InheritableBoolean.INHERIT));
    p.setUseSignedOffBy(getEnum(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, InheritableBoolean.INHERIT));
    p.setRequireChangeID(getEnum(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, InheritableBoolean.INHERIT));
    p.setCreateNewChangeForAllNotInTarget(getEnum(rc, RECEIVE, null, KEY_USE_ALL_NOT_IN_TARGET, InheritableBoolean.INHERIT));
    p.setEnableSignedPush(getEnum(rc, RECEIVE, null, KEY_ENABLE_SIGNED_PUSH, InheritableBoolean.INHERIT));
    p.setRequireSignedPush(getEnum(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_PUSH, InheritableBoolean.INHERIT));
    p.setMaxObjectSizeLimit(rc.getString(RECEIVE, null, KEY_MAX_OBJECT_SIZE_LIMIT));
    p.setSubmitType(getEnum(rc, SUBMIT, null, KEY_ACTION, defaultSubmitAction));
    p.setUseContentMerge(getEnum(rc, SUBMIT, null, KEY_MERGE_CONTENT, InheritableBoolean.INHERIT));
    p.setState(getEnum(rc, PROJECT, null, KEY_STATE, defaultStateValue));
    p.setDefaultDashboard(rc.getString(DASHBOARD, null, KEY_DEFAULT));
    p.setLocalDefaultDashboard(rc.getString(DASHBOARD, null, KEY_LOCAL_DEFAULT));
    loadAccountsSection(rc, groupsByName);
    loadContributorAgreements(rc, groupsByName);
    loadAccessSections(rc, groupsByName);
    loadBranchOrderSection(rc);
    loadNotifySections(rc, groupsByName);
    loadLabelSections(rc);
    loadCommentLinkSections(rc);
    loadSubscribeSections(rc);
    mimeTypes = new ConfiguredMimeTypes(projectName.get(), rc);
    loadPluginSections(rc);
    loadReceiveSection(rc);
}
#method_after
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    readGroupList();
    Map<String, GroupReference> groupsByName = mapGroupReferences();
    rulesId = getObjectId("rules.pl");
    Config rc = readConfig(PROJECT_CONFIG);
    project = new Project(projectName);
    Project p = project;
    p.setDescription(rc.getString(PROJECT, null, KEY_DESCRIPTION));
    if (p.getDescription() == null) {
        p.setDescription("");
    }
    if (rc.getStringList(ACCESS, null, KEY_INHERIT_FROM).length > 1) {
        // The config must not contain more than one parent to inherit from
        // as there is no guarantee which of the parents would be used then.
        error(new ValidationError(PROJECT_CONFIG, "Cannot inherit from multiple projects"));
    }
    p.setParentName(rc.getString(ACCESS, null, KEY_INHERIT_FROM));
    p.setUseContributorAgreements(getEnum(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, InheritableBoolean.INHERIT));
    p.setUseSignedOffBy(getEnum(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, InheritableBoolean.INHERIT));
    p.setRequireChangeID(getEnum(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, InheritableBoolean.INHERIT));
    p.setCreateNewChangeForAllNotInTarget(getEnum(rc, RECEIVE, null, KEY_USE_ALL_NOT_IN_TARGET, InheritableBoolean.INHERIT));
    p.setEnableSignedPush(getEnum(rc, RECEIVE, null, KEY_ENABLE_SIGNED_PUSH, InheritableBoolean.INHERIT));
    p.setRequireSignedPush(getEnum(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_PUSH, InheritableBoolean.INHERIT));
    p.setMaxObjectSizeLimit(rc.getString(RECEIVE, null, KEY_MAX_OBJECT_SIZE_LIMIT));
    p.setSubmitType(getEnum(rc, SUBMIT, null, KEY_ACTION, defaultSubmitAction));
    p.setUseContentMerge(getEnum(rc, SUBMIT, null, KEY_MERGE_CONTENT, InheritableBoolean.INHERIT));
    p.setState(getEnum(rc, PROJECT, null, KEY_STATE, defaultStateValue));
    p.setDefaultDashboard(rc.getString(DASHBOARD, null, KEY_DEFAULT));
    p.setLocalDefaultDashboard(rc.getString(DASHBOARD, null, KEY_LOCAL_DEFAULT));
    loadAccountsSection(rc, groupsByName);
    loadContributorAgreements(rc, groupsByName);
    loadAccessSections(rc, groupsByName);
    loadBranchOrderSection(rc);
    loadNotifySections(rc, groupsByName);
    loadLabelSections(rc);
    loadCommentLinkSections(rc);
    loadSubscribeSections(rc);
    mimeTypes = new ConfiguredMimeTypes(projectName.get(), rc);
    loadPluginSections(rc);
    loadReceiveSection(rc);
}
#end_block

#method_before
@Override
protected void configure() {
    if (mailSettings.protocol != Protocol.NONE) {
        listener().to(MailReceiver.class);
        if (mailSettings.protocol == Protocol.IMAP) {
            bind(MailReceiver.class).to(ImapMailReceiver.class);
        } else if (mailSettings.protocol == Protocol.POP3) {
            bind(MailReceiver.class).to(Pop3MailReceiver.class);
        }
    }
}
#method_after
@Override
protected void configure() {
    if (mailSettings.protocol == Protocol.NONE) {
        return;
    }
    listener().to(MailReceiver.class);
    switch(mailSettings.protocol) {
        case IMAP:
            bind(MailReceiver.class).to(ImapMailReceiver.class);
            break;
        case POP3:
            bind(MailReceiver.class).to(Pop3MailReceiver.class);
            break;
        case NONE:
        default:
    }
}
#end_block

#method_before
public void start() {
    if (timer == null) {
        timer = new Timer();
    } else {
        timer.cancel();
    }
    timer.scheduleAtFixedRate(new TimerTask() {

        @Override
        public void run() {
            MailReceiver.this.handleEmails();
        }
    }, 0l, mailSettings.fetchInterval * 1000);
}
#method_after
@Override
public void start() {
    if (timer == null) {
        timer = new Timer();
    } else {
        timer.cancel();
    }
    timer.scheduleAtFixedRate(new TimerTask() {

        @Override
        public void run() {
            MailReceiver.this.handleEmails();
        }
    }, 0l, mailSettings.fetchInterval);
}
#end_block

#method_before
public void stop() {
    if (timer != null) {
        timer.cancel();
    }
}
#method_after
@Override
public void stop() {
    if (timer != null) {
        timer.cancel();
    }
}
#end_block

#method_before
protected synchronized void handleEmails() {
// TODO(hiesel) Implement.
}
#method_after
@Override
protected synchronized void handleEmails() {
// TODO(hiesel) Implement.
}
#end_block

#method_before
protected synchronized void handleEmails() {
// TODO(hiesel) Implement.
}
#method_after
@Override
protected synchronized void handleEmails() {
// TODO(hiesel) Implement.
}
#end_block

#method_before
private void migrateData(List<SchemaVersion> pending, UpdateUI ui, CurrentSchemaVersion curr, ReviewDb db) throws OrmException, SQLException {
    for (SchemaVersion v : pending) {
        long startSec = System.currentTimeMillis();
        ui.message(String.format("Migrating data to schema %d ...", v.getVersionNbr()));
        v.migrateData(db, ui);
        v.finish(curr, db);
        ui.message(String.format("                          > Done (%.3f s)", (System.currentTimeMillis() - startSec) / 1000.0));
    }
}
#method_after
private void migrateData(List<SchemaVersion> pending, UpdateUI ui, CurrentSchemaVersion curr, ReviewDb db) throws OrmException, SQLException {
    for (SchemaVersion v : pending) {
        Stopwatch sw = Stopwatch.createStarted();
        ui.message(String.format("Migrating data to schema %d ...", v.getVersionNbr()));
        v.migrateData(db, ui);
        v.finish(curr, db);
        ui.message(String.format("\t> Done (%.3f s)", sw.elapsed(TimeUnit.MILLISECONDS) / 1000d));
    }
}
#end_block

#method_before
@Override
public List<Destination> getDestinations(FilterType filterType) {
    Predicate<Destination> filter;
    switch(filterType) {
        case PROJECT_CREATION:
            filter = new Predicate<Destination>() {

                @Override
                public boolean apply(Destination dest) {
                    if (dest == null || !dest.isCreateMissingRepos()) {
                        return false;
                    }
                    return true;
                }
            };
            break;
        case PROJECT_DELETION:
            filter = new Predicate<Destination>() {

                @Override
                public boolean apply(Destination dest) {
                    if (dest == null || !dest.isReplicateProjectDeletions()) {
                        return false;
                    }
                    return true;
                }
            };
            break;
        case ALL:
            return destinations;
        default:
            return destinations;
    }
    return FluentIterable.from(destinations).filter(filter).toList();
}
#method_after
@Override
public List<Destination> getDestinations(FilterType filterType) {
    Predicate<? super Destination> filter;
    switch(filterType) {
        case PROJECT_CREATION:
            filter = dest -> dest.isCreateMissingRepos();
            break;
        case PROJECT_DELETION:
            filter = dest -> dest.isReplicateProjectDeletions();
            break;
        case ALL:
        default:
            filter = dest -> true;
            break;
    }
    return destinations.stream().filter(Objects::nonNull).filter(filter).collect(toList());
}
#end_block

#method_before
private List<Destination> allDestinations(Destination.Factory destinationFactory) throws ConfigInvalidException, IOException {
    if (!config.getFile().exists()) {
        log.warn("Config file " + config.getFile() + " does not exist; not replicating");
        return Collections.emptyList();
    }
    if (config.getFile().length() == 0) {
        log.info("Config file " + config.getFile() + " is empty; not replicating");
        return Collections.emptyList();
    }
    try {
        config.load();
    } catch (ConfigInvalidException e) {
        throw new ConfigInvalidException(String.format("Config file %s is invalid: %s", config.getFile(), e.getMessage()), e);
    } catch (IOException e) {
        throw new IOException(String.format("Cannot read %s: %s", config.getFile(), e.getMessage()), e);
    }
    replicateAllOnPluginStart = config.getBoolean("gerrit", "replicateOnStartup", true);
    defaultForceUpdate = config.getBoolean("gerrit", "defaultForceUpdate", false);
    ImmutableList.Builder<Destination> dest = ImmutableList.builder();
    for (RemoteConfig c : allRemotes(config)) {
        if (c.getURIs().isEmpty()) {
            continue;
        }
        // If destination for push is not set assume equal to source.
        for (RefSpec ref : c.getPushRefSpecs()) {
            if (ref.getDestination() == null) {
                ref.setDestination(ref.getSource());
            }
        }
        if (c.getPushRefSpecs().isEmpty()) {
            c.addPushRefSpec(new RefSpec().setSourceDestination("refs/*", "refs/*").setForceUpdate(defaultForceUpdate));
        }
        Destination destination = destinationFactory.create(c, config);
        if (!destination.isSingleProjectMatch()) {
            for (URIish u : c.getURIs()) {
                if (u.getPath() == null || !u.getPath().contains("${name}")) {
                    throw new ConfigInvalidException(String.format("remote.%s.url \"%s\" lacks ${name} placeholder in %s", c.getName(), u, config.getFile()));
                }
            }
        }
        dest.add(destination);
    }
    return dest.build();
}
#method_after
private List<Destination> allDestinations(DestinationFactory destinationFactory) throws ConfigInvalidException, IOException {
    if (!config.getFile().exists()) {
        log.warn("Config file " + config.getFile() + " does not exist; not replicating");
        return Collections.emptyList();
    }
    if (config.getFile().length() == 0) {
        log.info("Config file " + config.getFile() + " is empty; not replicating");
        return Collections.emptyList();
    }
    try {
        config.load();
    } catch (ConfigInvalidException e) {
        throw new ConfigInvalidException(String.format("Config file %s is invalid: %s", config.getFile(), e.getMessage()), e);
    } catch (IOException e) {
        throw new IOException(String.format("Cannot read %s: %s", config.getFile(), e.getMessage()), e);
    }
    replicateAllOnPluginStart = config.getBoolean("gerrit", "replicateOnStartup", true);
    defaultForceUpdate = config.getBoolean("gerrit", "defaultForceUpdate", false);
    ImmutableList.Builder<Destination> dest = ImmutableList.builder();
    for (RemoteConfig c : allRemotes(config)) {
        if (c.getURIs().isEmpty()) {
            continue;
        }
        // If destination for push is not set assume equal to source.
        for (RefSpec ref : c.getPushRefSpecs()) {
            if (ref.getDestination() == null) {
                ref.setDestination(ref.getSource());
            }
        }
        if (c.getPushRefSpecs().isEmpty()) {
            c.addPushRefSpec(new RefSpec().setSourceDestination("refs/*", "refs/*").setForceUpdate(defaultForceUpdate));
        }
        Destination destination = destinationFactory.create(new DestinationConfiguration(c, config));
        if (!destination.isSingleProjectMatch()) {
            for (URIish u : c.getURIs()) {
                if (u.getPath() == null || !u.getPath().contains("${name}")) {
                    throw new ConfigInvalidException(String.format("remote.%s.url \"%s\" lacks ${name} placeholder in %s", c.getName(), u, config.getFile()));
                }
            }
        }
        dest.add(destination);
    }
    return dest.build();
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ReplicationQueue.class).in(Scopes.SINGLETON);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ReplicationQueue.class);
    DynamicSet.bind(binder(), NewProjectCreatedListener.class).to(ReplicationQueue.class);
    DynamicSet.bind(binder(), ProjectDeletedListener.class).to(ReplicationQueue.class);
    DynamicSet.bind(binder(), HeadUpdatedListener.class).to(ReplicationQueue.class);
    bind(OnStartStop.class).in(Scopes.SINGLETON);
    bind(LifecycleListener.class).annotatedWith(UniqueAnnotations.create()).to(OnStartStop.class);
    bind(LifecycleListener.class).annotatedWith(UniqueAnnotations.create()).to(ReplicationLogFile.class);
    bind(CredentialsFactory.class).to(AutoReloadSecureCredentialsFactoryDecorator.class).in(Scopes.SINGLETON);
    bind(CapabilityDefinition.class).annotatedWith(Exports.named(START_REPLICATION)).to(StartReplicationCapability.class);
    install(new FactoryModuleBuilder().build(PushAll.Factory.class));
    install(new FactoryModuleBuilder().build(RemoteSiteUser.Factory.class));
    install(new FactoryModuleBuilder().build(Destination.Factory.class));
    bind(ReplicationConfig.class).to(AutoReloadConfigDecorator.class);
    bind(ReplicationStateListener.class).to(ReplicationStateLogger.class);
    EventTypes.register(RefReplicatedEvent.TYPE, RefReplicatedEvent.class);
    EventTypes.register(RefReplicationDoneEvent.TYPE, RefReplicationDoneEvent.class);
    bind(SshSessionFactory.class).toProvider(ReplicationSshSessionFactoryProvider.class);
}
#method_after
@Override
protected void configure() {
    bind(DestinationFactory.class).in(Scopes.SINGLETON);
    bind(ReplicationQueue.class).in(Scopes.SINGLETON);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ReplicationQueue.class);
    DynamicSet.bind(binder(), NewProjectCreatedListener.class).to(ReplicationQueue.class);
    DynamicSet.bind(binder(), ProjectDeletedListener.class).to(ReplicationQueue.class);
    DynamicSet.bind(binder(), HeadUpdatedListener.class).to(ReplicationQueue.class);
    bind(OnStartStop.class).in(Scopes.SINGLETON);
    bind(LifecycleListener.class).annotatedWith(UniqueAnnotations.create()).to(OnStartStop.class);
    bind(LifecycleListener.class).annotatedWith(UniqueAnnotations.create()).to(ReplicationLogFile.class);
    bind(CredentialsFactory.class).to(AutoReloadSecureCredentialsFactoryDecorator.class).in(Scopes.SINGLETON);
    bind(CapabilityDefinition.class).annotatedWith(Exports.named(START_REPLICATION)).to(StartReplicationCapability.class);
    install(new FactoryModuleBuilder().build(PushAll.Factory.class));
    install(new FactoryModuleBuilder().build(RemoteSiteUser.Factory.class));
    bind(ReplicationConfig.class).to(AutoReloadConfigDecorator.class);
    bind(ReplicationStateListener.class).to(ReplicationStateLogger.class);
    EventTypes.register(RefReplicatedEvent.TYPE, RefReplicatedEvent.class);
    EventTypes.register(RefReplicationDoneEvent.TYPE, RefReplicationDoneEvent.class);
    bind(SshSessionFactory.class).toProvider(ReplicationSshSessionFactoryProvider.class);
}
#end_block

#method_before
@Override
public void sendRedirect(String location) throws IOException {
    this.status = SC_MOVED_TEMPORARILY;
    super.setHeader("Location", location);
}
#method_after
@Override
public void sendRedirect(String location) throws IOException {
    this.status = SC_MOVED_TEMPORARILY;
    setHeader(LOCATION_HEADER, location);
}
#end_block

#method_before
@Override
public void setHeader(String name, String value) {
    super.setHeader(name, value);
    headers.put(name.toLowerCase(), value);
}
#method_after
@Override
public void setHeader(String name, String value) {
    super.setHeader(name, value);
    headers.put(name, value);
}
#end_block

#method_before
@Override
public int getStatus() {
    return status;
}
#method_after
@SuppressWarnings("all")
public // to servlet-api 3.1
int getStatus() {
    return status;
}
#end_block

#method_before
void play() throws IOException {
    if (status != 0) {
        log.debug("Replaying {} {}", status, statusMsg);
        if (status == SC_MOVED_TEMPORARILY) {
            super.sendRedirect(headers.get("location"));
        } else {
            super.sendError(status, statusMsg);
        }
    }
}
#method_after
void play() throws IOException {
    if (status != 0) {
        log.debug("Replaying {} {}", status, statusMsg);
        if (status == SC_MOVED_TEMPORARILY) {
            super.sendRedirect(headers.get(LOCATION_HEADER));
        } else {
            super.sendError(status, statusMsg);
        }
    }
}
#end_block

#method_before
private ChangeMessage newMessage(ChangeContext ctx) throws OrmException {
    StringBuilder msg = new StringBuilder();
    msg.append("Abandoned");
    if (!Strings.nullToEmpty(msgTxt).trim().isEmpty()) {
        msg.append("\n\n");
        msg.append(msgTxt.trim());
    }
    return ChangeMessagesUtil.newMessage(ctx, msg.toString(), ChangeMessagesUtil.ABANDON);
}
#method_after
private ChangeMessage newMessage(ChangeContext ctx) throws OrmException {
    StringBuilder msg = new StringBuilder();
    msg.append("Abandoned");
    if (!Strings.nullToEmpty(msgTxt).trim().isEmpty()) {
        msg.append("\n\n");
        msg.append(msgTxt.trim());
    }
    return ChangeMessagesUtil.newMessage(ctx, msg.toString(), ChangeMessagesUtil.TAG_ABANDON);
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException {
    change = ctx.getChange();
    ChangeUpdate update = ctx.getUpdate(change.currentPatchSetId());
    newTopicName = Strings.nullToEmpty(input.topic);
    oldTopicName = Strings.nullToEmpty(change.getTopic());
    if (oldTopicName.equals(newTopicName)) {
        return false;
    }
    String summary;
    if (oldTopicName.isEmpty()) {
        summary = "Topic set to " + newTopicName;
    } else if (newTopicName.isEmpty()) {
        summary = "Topic " + oldTopicName + " removed";
    } else {
        summary = String.format("Topic changed from %s to %s", oldTopicName, newTopicName);
    }
    change.setTopic(Strings.emptyToNull(newTopicName));
    update.setTopic(change.getTopic());
    ChangeMessage cmsg = ChangeMessagesUtil.newMessage(ctx, summary, ChangeMessagesUtil.PUT_TOPIC);
    cmUtil.addChangeMessage(ctx.getDb(), update, cmsg);
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException {
    change = ctx.getChange();
    ChangeUpdate update = ctx.getUpdate(change.currentPatchSetId());
    newTopicName = Strings.nullToEmpty(input.topic);
    oldTopicName = Strings.nullToEmpty(change.getTopic());
    if (oldTopicName.equals(newTopicName)) {
        return false;
    }
    String summary;
    if (oldTopicName.isEmpty()) {
        summary = "Topic set to " + newTopicName;
    } else if (newTopicName.isEmpty()) {
        summary = "Topic " + oldTopicName + " removed";
    } else {
        summary = String.format("Topic changed from %s to %s", oldTopicName, newTopicName);
    }
    change.setTopic(Strings.emptyToNull(newTopicName));
    update.setTopic(change.getTopic());
    ChangeMessage cmsg = ChangeMessagesUtil.newMessage(ctx, summary, ChangeMessagesUtil.TAG_SET_TOPIC);
    cmUtil.addChangeMessage(ctx.getDb(), update, cmsg);
    return true;
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, IOException {
    // Use defensive copy created by ChangeControl.
    change = ctx.getChange();
    ReviewDb db = ctx.getDb();
    ChangeControl ctl = ctx.getControl();
    patchSetInfo = patchSetInfoFactory.get(ctx.getRevWalk(), commit, psId);
    ctx.getChange().setCurrentPatchSet(patchSetInfo);
    ChangeUpdate update = ctx.getUpdate(psId);
    update.setChangeId(change.getKey().get());
    update.setSubjectForCommit("Create change");
    update.setBranch(change.getDest().get());
    update.setTopic(change.getTopic());
    boolean draft = status == Change.Status.DRAFT;
    List<String> newGroups = groups;
    if (newGroups.isEmpty()) {
        newGroups = GroupCollector.getDefaultGroups(commit);
    }
    patchSet = psUtil.insert(ctx.getDb(), ctx.getRevWalk(), update, psId, commit, draft, newGroups, pushCert);
    /* TODO: fixStatus is used here because the tests
     * (byStatusClosed() in AbstractQueryChangesTest)
     * insert changes that are already merged,
     * and setStatus may not be used to set the Status to merged
     *
     * is it possible to make the tests use the merge code path,
     * instead of setting the status directly?
     */
    update.fixStatus(change.getStatus());
    LabelTypes labelTypes = ctl.getProjectControl().getLabelTypes();
    approvalsUtil.addReviewers(db, update, labelTypes, change, patchSet, patchSetInfo, filterOnChangeVisibility(db, ctx.getNotes(), reviewers), Collections.<Account.Id>emptySet());
    approvalsUtil.addApprovalsForNewPatchSet(db, update, labelTypes, patchSet, ctx.getControl(), approvals);
    if (message != null) {
        changeMessage = ChangeMessagesUtil.newMessage(db, patchSet.getId(), ctx.getUser(), patchSet.getCreatedOn(), message, ChangeMessagesUtil.CHANGE_INSERTER);
        cmUtil.addChangeMessage(db, update, changeMessage);
    }
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, IOException {
    // Use defensive copy created by ChangeControl.
    change = ctx.getChange();
    ReviewDb db = ctx.getDb();
    ChangeControl ctl = ctx.getControl();
    patchSetInfo = patchSetInfoFactory.get(ctx.getRevWalk(), commit, psId);
    ctx.getChange().setCurrentPatchSet(patchSetInfo);
    ChangeUpdate update = ctx.getUpdate(psId);
    update.setChangeId(change.getKey().get());
    update.setSubjectForCommit("Create change");
    update.setBranch(change.getDest().get());
    update.setTopic(change.getTopic());
    boolean draft = status == Change.Status.DRAFT;
    List<String> newGroups = groups;
    if (newGroups.isEmpty()) {
        newGroups = GroupCollector.getDefaultGroups(commit);
    }
    patchSet = psUtil.insert(ctx.getDb(), ctx.getRevWalk(), update, psId, commit, draft, newGroups, pushCert);
    /* TODO: fixStatus is used here because the tests
     * (byStatusClosed() in AbstractQueryChangesTest)
     * insert changes that are already merged,
     * and setStatus may not be used to set the Status to merged
     *
     * is it possible to make the tests use the merge code path,
     * instead of setting the status directly?
     */
    update.fixStatus(change.getStatus());
    LabelTypes labelTypes = ctl.getProjectControl().getLabelTypes();
    approvalsUtil.addReviewers(db, update, labelTypes, change, patchSet, patchSetInfo, filterOnChangeVisibility(db, ctx.getNotes(), reviewers), Collections.<Account.Id>emptySet());
    approvalsUtil.addApprovalsForNewPatchSet(db, update, labelTypes, patchSet, ctx.getControl(), approvals);
    if (message != null) {
        changeMessage = ChangeMessagesUtil.newMessage(db, patchSet.getId(), ctx.getUser(), patchSet.getCreatedOn(), message, ChangeMessagesUtil.TAG_UPLOADED_PATCH_SET);
        cmUtil.addChangeMessage(db, update, changeMessage);
    }
    return true;
}
#end_block

#method_before
private void addMessage(BatchUpdate.ChangeContext ctx, ChangeUpdate update, Account previousAssignee) throws OrmException {
    StringBuilder msg = new StringBuilder();
    msg.append("Assignee ");
    if (previousAssignee == null) {
        msg.append("added: ");
        msg.append(newAssignee.getName(anonymousCowardName));
    } else {
        msg.append("changed from: ");
        msg.append(previousAssignee.getName(anonymousCowardName));
        msg.append(" to: ");
        msg.append(newAssignee.getName(anonymousCowardName));
    }
    ChangeMessage cmsg = ChangeMessagesUtil.newMessage(ctx, msg.toString(), ChangeMessagesUtil.SET_ASSIGNEE_OP);
    cmUtil.addChangeMessage(ctx.getDb(), update, cmsg);
}
#method_after
private void addMessage(BatchUpdate.ChangeContext ctx, ChangeUpdate update, Account previousAssignee) throws OrmException {
    StringBuilder msg = new StringBuilder();
    msg.append("Assignee ");
    if (previousAssignee == null) {
        msg.append("added: ");
        msg.append(newAssignee.getName(anonymousCowardName));
    } else {
        msg.append("changed from: ");
        msg.append(previousAssignee.getName(anonymousCowardName));
        msg.append(" to: ");
        msg.append(newAssignee.getName(anonymousCowardName));
    }
    ChangeMessage cmsg = ChangeMessagesUtil.newMessage(ctx, msg.toString(), ChangeMessagesUtil.TAG_SET_ASSIGNEE);
    cmUtil.addChangeMessage(ctx.getDb(), update, cmsg);
}
#end_block

#method_before
private void addMessage(BatchUpdate.ChangeContext ctx, ChangeUpdate update, Account deleted) throws OrmException {
    ChangeMessage cmsg = ChangeMessagesUtil.newMessage(ctx, "Assignee deleted: " + deleted.getName(anonymousCowardName), ChangeMessagesUtil.DELETE_ASSIGNEE);
    cmUtil.addChangeMessage(ctx.getDb(), update, cmsg);
}
#method_after
private void addMessage(BatchUpdate.ChangeContext ctx, ChangeUpdate update, Account deleted) throws OrmException {
    ChangeMessage cmsg = ChangeMessagesUtil.newMessage(ctx, "Assignee deleted: " + deleted.getName(anonymousCowardName), ChangeMessagesUtil.TAG_DELETE_ASSIGNEE);
    cmUtil.addChangeMessage(ctx.getDb(), update, cmsg);
}
#end_block

#method_before
@Override
public void updateRepo(RepoContext ctx) throws Exception {
    changeKind = changeKindCache.getChangeKind(projectControl.getProject().getNameKey(), ctx.getRepository(), priorCommit, commit);
    if (checkMergedInto) {
        Ref mergedInto = findMergedInto(ctx, dest.get(), commit);
        if (mergedInto != null) {
            mergedByPushOp = mergedByPushOpFactory.create(requestScopePropagator, patchSetId, mergedInto.getName());
        }
    }
}
#method_after
@Override
public void updateRepo(RepoContext ctx) throws Exception {
    changeKind = changeKindCache.getChangeKind(projectControl.getProject().getNameKey(), ctx.getRepository(), priorCommit, commit);
    if (checkMergedInto) {
        Ref mergedInto = findMergedInto(ctx, dest.get(), commit);
        if (mergedInto != null) {
            mergedByPushOp = mergedByPushOpFactory.create(requestScopePropagator, patchSetId, mergedInto.getName());
        }
    }
    if (updateRef) {
        ctx.addRefUpdate(new ReceiveCommand(ObjectId.zeroId(), commit, patchSetId.toRefName()));
    }
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, IOException {
    change = ctx.getChange();
    if (change == null || change.getStatus().isClosed()) {
        rejectMessage = CHANGE_IS_CLOSED;
        return false;
    }
    if (groups.isEmpty()) {
        PatchSet prevPs = psUtil.current(ctx.getDb(), ctx.getNotes());
        groups = prevPs != null ? prevPs.getGroups() : ImmutableList.<String>of();
    }
    ChangeUpdate update = ctx.getUpdate(patchSetId);
    update.setSubjectForCommit("Create patch set " + patchSetId.get());
    String reviewMessage = null;
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        reviewMessage = magicBranch.message;
        approvals.putAll(magicBranch.labels);
        Set<String> hashtags = magicBranch.hashtags;
        if (hashtags != null && !hashtags.isEmpty()) {
            hashtags.addAll(ctx.getNotes().getHashtags());
            update.setHashtags(hashtags);
        }
        if (magicBranch.topic != null && !magicBranch.topic.equals(ctx.getChange().getTopic())) {
            update.setTopic(magicBranch.topic);
        }
    }
    boolean draft = magicBranch != null && magicBranch.draft;
    if (change.getStatus() == Change.Status.DRAFT && !draft) {
        update.setStatus(Change.Status.NEW);
    }
    newPatchSet = psUtil.insert(ctx.getDb(), ctx.getRevWalk(), update, patchSetId, commit, draft, groups, pushCertificate != null ? pushCertificate.toTextWithSignature() : null);
    recipients.add(getRecipientsFromFooters(ctx.getDb(), accountResolver, draft, commit.getFooterLines()));
    recipients.remove(ctx.getAccountId());
    ChangeData cd = changeDataFactory.create(ctx.getDb(), ctx.getControl());
    MailRecipients oldRecipients = getRecipientsFromReviewers(cd.reviewers());
    Iterable<PatchSetApproval> newApprovals = approvalsUtil.addApprovalsForNewPatchSet(ctx.getDb(), update, projectControl.getLabelTypes(), newPatchSet, ctx.getControl(), approvals);
    approvalCopier.copy(ctx.getDb(), ctx.getControl(), newPatchSet, newApprovals);
    approvalsUtil.addReviewers(ctx.getDb(), update, projectControl.getLabelTypes(), change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
    recipients.add(oldRecipients);
    String approvalMessage = ApprovalsUtil.renderMessageWithApprovals(patchSetId.get(), approvals, scanLabels(ctx, approvals));
    String kindMessage = changeKindMessage(changeKind);
    StringBuilder message = new StringBuilder(approvalMessage);
    if (!Strings.isNullOrEmpty(kindMessage)) {
        message.append(kindMessage);
    } else {
        message.append('.');
    }
    if (!Strings.isNullOrEmpty(reviewMessage)) {
        message.append("\n").append(reviewMessage);
    }
    msg = ChangeMessagesUtil.newMessage(ctx.getDb(), patchSetId, ctx.getUser(), ctx.getWhen(), message.toString(), ChangeMessagesUtil.REPLACE_OP);
    cmUtil.addChangeMessage(ctx.getDb(), update, msg);
    if (mergedByPushOp == null) {
        resetChange(ctx, msg);
    } else {
        mergedByPushOp.setPatchSetProvider(Providers.of(newPatchSet)).updateChange(ctx);
    }
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, IOException {
    change = ctx.getChange();
    if (change == null || change.getStatus().isClosed()) {
        rejectMessage = CHANGE_IS_CLOSED;
        return false;
    }
    if (groups.isEmpty()) {
        PatchSet prevPs = psUtil.current(ctx.getDb(), ctx.getNotes());
        groups = prevPs != null ? prevPs.getGroups() : ImmutableList.<String>of();
    }
    ChangeUpdate update = ctx.getUpdate(patchSetId);
    update.setSubjectForCommit("Create patch set " + patchSetId.get());
    String reviewMessage = null;
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        reviewMessage = magicBranch.message;
        approvals.putAll(magicBranch.labels);
        Set<String> hashtags = magicBranch.hashtags;
        if (hashtags != null && !hashtags.isEmpty()) {
            hashtags.addAll(ctx.getNotes().getHashtags());
            update.setHashtags(hashtags);
        }
        if (magicBranch.topic != null && !magicBranch.topic.equals(ctx.getChange().getTopic())) {
            update.setTopic(magicBranch.topic);
        }
    }
    boolean draft = magicBranch != null && magicBranch.draft;
    if (change.getStatus() == Change.Status.DRAFT && !draft) {
        update.setStatus(Change.Status.NEW);
    }
    newPatchSet = psUtil.insert(ctx.getDb(), ctx.getRevWalk(), update, patchSetId, commit, draft, groups, pushCertificate != null ? pushCertificate.toTextWithSignature() : null);
    recipients.add(getRecipientsFromFooters(ctx.getDb(), accountResolver, draft, commit.getFooterLines()));
    recipients.remove(ctx.getAccountId());
    ChangeData cd = changeDataFactory.create(ctx.getDb(), ctx.getControl());
    MailRecipients oldRecipients = getRecipientsFromReviewers(cd.reviewers());
    Iterable<PatchSetApproval> newApprovals = approvalsUtil.addApprovalsForNewPatchSet(ctx.getDb(), update, projectControl.getLabelTypes(), newPatchSet, ctx.getControl(), approvals);
    approvalCopier.copy(ctx.getDb(), ctx.getControl(), newPatchSet, newApprovals);
    approvalsUtil.addReviewers(ctx.getDb(), update, projectControl.getLabelTypes(), change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
    recipients.add(oldRecipients);
    String approvalMessage = ApprovalsUtil.renderMessageWithApprovals(patchSetId.get(), approvals, scanLabels(ctx, approvals));
    String kindMessage = changeKindMessage(changeKind);
    StringBuilder message = new StringBuilder(approvalMessage);
    if (!Strings.isNullOrEmpty(kindMessage)) {
        message.append(kindMessage);
    } else {
        message.append('.');
    }
    if (!Strings.isNullOrEmpty(reviewMessage)) {
        message.append("\n").append(reviewMessage);
    }
    msg = ChangeMessagesUtil.newMessage(ctx.getDb(), patchSetId, ctx.getUser(), ctx.getWhen(), message.toString(), ChangeMessagesUtil.TAG_UPLOADED_PATCH_SET);
    cmUtil.addChangeMessage(ctx.getDb(), update, msg);
    if (mergedByPushOp == null) {
        resetChange(ctx, msg);
    } else {
        mergedByPushOp.setPatchSetProvider(Providers.of(newPatchSet)).updateChange(ctx);
    }
    return true;
}
#end_block

#method_before
@Override
public void postUpdate(final Context ctx) throws Exception {
    // Normally the ref updated hook is fired by BatchUpdate, but ReplaceOp is
    // special because its ref is actually updated by ReceiveCommits, so from
    // BatchUpdate's perspective there is no ref update. Thus we have to fire it
    // manually.
    final Account account = ctx.getAccount();
    gitRefUpdated.fire(ctx.getProject(), newPatchSet.getRefName(), ObjectId.zeroId(), commit, account);
    if (changeKind != ChangeKind.TRIVIAL_REBASE) {
        Runnable sender = new Runnable() {

            @Override
            public void run() {
                try {
                    ReplacePatchSetSender cm = replacePatchSetFactory.create(projectControl.getProject().getNameKey(), change.getId());
                    cm.setFrom(account.getId());
                    cm.setPatchSet(newPatchSet, info);
                    cm.setChangeMessage(msg.getMessage(), ctx.getWhen());
                    if (magicBranch != null && magicBranch.notify != null) {
                        cm.setNotify(magicBranch.notify);
                    }
                    cm.addReviewers(recipients.getReviewers());
                    cm.addExtraCC(recipients.getCcOnly());
                    cm.send();
                } catch (Exception e) {
                    log.error("Cannot send email for new patch set " + newPatchSet.getId(), e);
                }
            }

            @Override
            public String toString() {
                return "send-email newpatchset";
            }
        };
        if (requestScopePropagator != null) {
            sendEmailExecutor.submit(requestScopePropagator.wrap(sender));
        } else {
            sender.run();
        }
    }
    NotifyHandling notify = magicBranch != null && magicBranch.notify != null ? magicBranch.notify : NotifyHandling.ALL;
    revisionCreated.fire(change, newPatchSet, ctx.getAccount(), ctx.getWhen(), notify);
    try {
        fireCommentAddedEvent(ctx);
    } catch (Exception e) {
        log.warn("comment-added event invocation failed", e);
    }
    if (mergedByPushOp != null) {
        mergedByPushOp.postUpdate(ctx);
    }
}
#method_after
@Override
public void postUpdate(final Context ctx) throws Exception {
    // Normally the ref updated hook is fired by BatchUpdate, but ReplaceOp is
    // special because its ref is actually updated by ReceiveCommits, so from
    // BatchUpdate's perspective there is no ref update. Thus we have to fire it
    // manually.
    final Account account = ctx.getAccount();
    if (!updateRef) {
        gitRefUpdated.fire(ctx.getProject(), newPatchSet.getRefName(), ObjectId.zeroId(), commit, account);
    }
    if (changeKind != ChangeKind.TRIVIAL_REBASE) {
        Runnable sender = new Runnable() {

            @Override
            public void run() {
                try {
                    ReplacePatchSetSender cm = replacePatchSetFactory.create(projectControl.getProject().getNameKey(), change.getId());
                    cm.setFrom(account.getId());
                    cm.setPatchSet(newPatchSet, info);
                    cm.setChangeMessage(msg.getMessage(), ctx.getWhen());
                    if (magicBranch != null && magicBranch.notify != null) {
                        cm.setNotify(magicBranch.notify);
                    }
                    cm.addReviewers(recipients.getReviewers());
                    cm.addExtraCC(recipients.getCcOnly());
                    cm.send();
                } catch (Exception e) {
                    log.error("Cannot send email for new patch set " + newPatchSet.getId(), e);
                }
            }

            @Override
            public String toString() {
                return "send-email newpatchset";
            }
        };
        if (requestScopePropagator != null) {
            sendEmailExecutor.submit(requestScopePropagator.wrap(sender));
        } else {
            sender.run();
        }
    }
    NotifyHandling notify = magicBranch != null && magicBranch.notify != null ? magicBranch.notify : NotifyHandling.ALL;
    revisionCreated.fire(change, newPatchSet, ctx.getAccount(), ctx.getWhen(), notify);
    try {
        fireCommentAddedEvent(ctx);
    } catch (Exception e) {
        log.warn("comment-added event invocation failed", e);
    }
    if (mergedByPushOp != null) {
        mergedByPushOp.postUpdate(ctx);
    }
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws AuthException, ResourceNotFoundException, OrmException {
    Account.Id reviewerId = reviewer.getId();
    if (!approvalsUtil.getReviewers(ctx.getDb(), ctx.getNotes()).all().contains(reviewerId)) {
        throw new ResourceNotFoundException();
    }
    currChange = ctx.getChange();
    currPs = psUtil.current(ctx.getDb(), ctx.getNotes());
    LabelTypes labelTypes = ctx.getControl().getLabelTypes();
    // removing a reviewer will remove all her votes
    for (LabelType lt : labelTypes.getLabelTypes()) {
        newApprovals.put(lt.getName(), (short) 0);
    }
    StringBuilder msg = new StringBuilder();
    msg.append("Removed reviewer " + reviewer.getFullName());
    StringBuilder removedVotesMsg = new StringBuilder();
    removedVotesMsg.append(" with the following votes:\n\n");
    boolean votesRemoved = false;
    for (PatchSetApproval a : approvals(ctx, reviewerId)) {
        if (ctx.getControl().canRemoveReviewer(a)) {
            del.add(a);
            if (a.getPatchSetId().equals(currPs.getId()) && a.getValue() != 0) {
                oldApprovals.put(a.getLabel(), a.getValue());
                removedVotesMsg.append("* ").append(a.getLabel()).append(formatLabelValue(a.getValue())).append(" by ").append(userFactory.create(a.getAccountId()).getNameEmail()).append("\n");
                votesRemoved = true;
            }
        } else {
            throw new AuthException("delete reviewer not permitted");
        }
    }
    if (votesRemoved) {
        msg.append(removedVotesMsg);
    } else {
        msg.append(".");
    }
    ctx.getDb().patchSetApprovals().delete(del);
    ChangeUpdate update = ctx.getUpdate(currPs.getId());
    update.removeReviewer(reviewerId);
    changeMessage = ChangeMessagesUtil.newMessage(ctx, msg.toString(), ChangeMessagesUtil.DELETE_REVIEWER);
    cmUtil.addChangeMessage(ctx.getDb(), update, changeMessage);
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws AuthException, ResourceNotFoundException, OrmException {
    Account.Id reviewerId = reviewer.getId();
    if (!approvalsUtil.getReviewers(ctx.getDb(), ctx.getNotes()).all().contains(reviewerId)) {
        throw new ResourceNotFoundException();
    }
    currChange = ctx.getChange();
    currPs = psUtil.current(ctx.getDb(), ctx.getNotes());
    LabelTypes labelTypes = ctx.getControl().getLabelTypes();
    // removing a reviewer will remove all her votes
    for (LabelType lt : labelTypes.getLabelTypes()) {
        newApprovals.put(lt.getName(), (short) 0);
    }
    StringBuilder msg = new StringBuilder();
    msg.append("Removed reviewer " + reviewer.getFullName());
    StringBuilder removedVotesMsg = new StringBuilder();
    removedVotesMsg.append(" with the following votes:\n\n");
    boolean votesRemoved = false;
    for (PatchSetApproval a : approvals(ctx, reviewerId)) {
        if (ctx.getControl().canRemoveReviewer(a)) {
            del.add(a);
            if (a.getPatchSetId().equals(currPs.getId()) && a.getValue() != 0) {
                oldApprovals.put(a.getLabel(), a.getValue());
                removedVotesMsg.append("* ").append(a.getLabel()).append(formatLabelValue(a.getValue())).append(" by ").append(userFactory.create(a.getAccountId()).getNameEmail()).append("\n");
                votesRemoved = true;
            }
        } else {
            throw new AuthException("delete reviewer not permitted");
        }
    }
    if (votesRemoved) {
        msg.append(removedVotesMsg);
    } else {
        msg.append(".");
    }
    ctx.getDb().patchSetApprovals().delete(del);
    ChangeUpdate update = ctx.getUpdate(currPs.getId());
    update.removeReviewer(reviewerId);
    changeMessage = ChangeMessagesUtil.newMessage(ctx, msg.toString(), ChangeMessagesUtil.TAG_DELETE_REVIEWER);
    cmUtil.addChangeMessage(ctx.getDb(), update, changeMessage);
    return true;
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, ResourceConflictException, RepositoryNotFoundException, IOException {
    change = ctx.getChange();
    if (change.getStatus() != Status.NEW && change.getStatus() != Status.DRAFT) {
        throw new ResourceConflictException("Change is " + status(change));
    }
    Project.NameKey projectKey = change.getProject();
    newDestKey = new Branch.NameKey(projectKey, input.destinationBranch);
    Branch.NameKey changePrevDest = change.getDest();
    if (changePrevDest.equals(newDestKey)) {
        throw new ResourceConflictException("Change is already destined for the specified branch");
    }
    final PatchSet.Id patchSetId = change.currentPatchSetId();
    try (Repository repo = repoManager.openRepository(projectKey);
        RevWalk revWalk = new RevWalk(repo)) {
        RevCommit currPatchsetRevCommit = revWalk.parseCommit(ObjectId.fromString(psUtil.current(ctx.getDb(), ctx.getNotes()).getRevision().get()));
        if (currPatchsetRevCommit.getParentCount() > 1) {
            throw new ResourceConflictException("Merge commit cannot be moved");
        }
        ObjectId refId = repo.resolve(input.destinationBranch);
        // Check if destination ref exists in project repo
        if (refId == null) {
            throw new ResourceConflictException("Destination " + input.destinationBranch + " not found in the project");
        }
        RevCommit refCommit = revWalk.parseCommit(refId);
        if (revWalk.isMergedInto(currPatchsetRevCommit, refCommit)) {
            throw new ResourceConflictException("Current patchset revision is reachable from tip of " + input.destinationBranch);
        }
    }
    Change.Key changeKey = change.getKey();
    if (!asChanges(queryProvider.get().byBranchKey(newDestKey, changeKey)).isEmpty()) {
        throw new ResourceConflictException("Destination " + newDestKey.getShortName() + " has a different change with same change key " + changeKey);
    }
    if (!change.currentPatchSetId().equals(patchSetId)) {
        throw new ResourceConflictException("Patch set is not current");
    }
    ChangeUpdate update = ctx.getUpdate(change.currentPatchSetId());
    update.setBranch(newDestKey.get());
    change.setDest(newDestKey);
    StringBuilder msgBuf = new StringBuilder();
    msgBuf.append("Change destination moved from ");
    msgBuf.append(changePrevDest.getShortName());
    msgBuf.append(" to ");
    msgBuf.append(newDestKey.getShortName());
    if (!Strings.isNullOrEmpty(input.message)) {
        msgBuf.append("\n\n");
        msgBuf.append(input.message);
    }
    ChangeMessage cmsg = ChangeMessagesUtil.newMessage(ctx, msgBuf.toString(), ChangeMessagesUtil.MOVE);
    cmUtil.addChangeMessage(ctx.getDb(), update, cmsg);
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, ResourceConflictException, RepositoryNotFoundException, IOException {
    change = ctx.getChange();
    if (change.getStatus() != Status.NEW && change.getStatus() != Status.DRAFT) {
        throw new ResourceConflictException("Change is " + status(change));
    }
    Project.NameKey projectKey = change.getProject();
    newDestKey = new Branch.NameKey(projectKey, input.destinationBranch);
    Branch.NameKey changePrevDest = change.getDest();
    if (changePrevDest.equals(newDestKey)) {
        throw new ResourceConflictException("Change is already destined for the specified branch");
    }
    final PatchSet.Id patchSetId = change.currentPatchSetId();
    try (Repository repo = repoManager.openRepository(projectKey);
        RevWalk revWalk = new RevWalk(repo)) {
        RevCommit currPatchsetRevCommit = revWalk.parseCommit(ObjectId.fromString(psUtil.current(ctx.getDb(), ctx.getNotes()).getRevision().get()));
        if (currPatchsetRevCommit.getParentCount() > 1) {
            throw new ResourceConflictException("Merge commit cannot be moved");
        }
        ObjectId refId = repo.resolve(input.destinationBranch);
        // Check if destination ref exists in project repo
        if (refId == null) {
            throw new ResourceConflictException("Destination " + input.destinationBranch + " not found in the project");
        }
        RevCommit refCommit = revWalk.parseCommit(refId);
        if (revWalk.isMergedInto(currPatchsetRevCommit, refCommit)) {
            throw new ResourceConflictException("Current patchset revision is reachable from tip of " + input.destinationBranch);
        }
    }
    Change.Key changeKey = change.getKey();
    if (!asChanges(queryProvider.get().byBranchKey(newDestKey, changeKey)).isEmpty()) {
        throw new ResourceConflictException("Destination " + newDestKey.getShortName() + " has a different change with same change key " + changeKey);
    }
    if (!change.currentPatchSetId().equals(patchSetId)) {
        throw new ResourceConflictException("Patch set is not current");
    }
    ChangeUpdate update = ctx.getUpdate(change.currentPatchSetId());
    update.setBranch(newDestKey.get());
    change.setDest(newDestKey);
    StringBuilder msgBuf = new StringBuilder();
    msgBuf.append("Change destination moved from ");
    msgBuf.append(changePrevDest.getShortName());
    msgBuf.append(" to ");
    msgBuf.append(newDestKey.getShortName());
    if (!Strings.isNullOrEmpty(input.message)) {
        msgBuf.append("\n\n");
        msgBuf.append(input.message);
    }
    ChangeMessage cmsg = ChangeMessagesUtil.newMessage(ctx, msgBuf.toString(), ChangeMessagesUtil.TAG_MOVE);
    cmUtil.addChangeMessage(ctx.getDb(), update, cmsg);
    return true;
}
#end_block

#method_before
private void sendReplacePatchSet(Context ctx) throws EmailException, OrmException {
    ChangeMessage msg = ChangeMessagesUtil.newMessage(ctx.getDb(), psId, ctx.getUser(), ctx.getWhen(), "Uploaded patch set " + psId.get() + ".", ChangeMessagesUtil.PUBLISH_DRAFT_PATCH_SET);
    ReplacePatchSetSender cm = replacePatchSetFactory.create(ctx.getProject(), change.getId());
    cm.setFrom(ctx.getAccountId());
    cm.setPatchSet(patchSet, patchSetInfo);
    cm.setChangeMessage(msg.getMessage(), ctx.getWhen());
    cm.addReviewers(recipients.getReviewers());
    cm.addExtraCC(recipients.getCcOnly());
    cm.send();
}
#method_after
private void sendReplacePatchSet(Context ctx) throws EmailException, OrmException {
    ChangeMessage msg = ChangeMessagesUtil.newMessage(ctx.getDb(), psId, ctx.getUser(), ctx.getWhen(), "Uploaded patch set " + psId.get() + ".", ChangeMessagesUtil.TAG_UPLOADED_PATCH_SET);
    ReplacePatchSetSender cm = replacePatchSetFactory.create(ctx.getProject(), change.getId());
    cm.setFrom(ctx.getAccountId());
    cm.setPatchSet(patchSet, patchSetInfo);
    cm.setChangeMessage(msg.getMessage(), ctx.getWhen());
    cm.addReviewers(recipients.getReviewers());
    cm.addExtraCC(recipients.getCcOnly());
    cm.send();
}
#end_block

#method_before
private ChangeMessage newMessage(ChangeContext ctx) throws OrmException {
    StringBuilder msg = new StringBuilder();
    msg.append("Restored");
    if (!Strings.nullToEmpty(input.message).trim().isEmpty()) {
        msg.append("\n\n");
        msg.append(input.message.trim());
    }
    return ChangeMessagesUtil.newMessage(ctx, msg.toString(), ChangeMessagesUtil.RESTORE);
}
#method_after
private ChangeMessage newMessage(ChangeContext ctx) throws OrmException {
    StringBuilder msg = new StringBuilder();
    msg.append("Restored");
    if (!Strings.nullToEmpty(input.message).trim().isEmpty()) {
        msg.append("\n\n");
        msg.append(input.message.trim());
    }
    return ChangeMessagesUtil.newMessage(ctx, msg.toString(), ChangeMessagesUtil.TAG_RESTORE);
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, AuthException, ResourceNotFoundException {
    ChangeControl ctl = ctx.getControl();
    change = ctl.getChange();
    PatchSet.Id psId = change.currentPatchSetId();
    ps = psUtil.current(db.get(), ctl.getNotes());
    boolean found = false;
    LabelTypes labelTypes = ctx.getControl().getLabelTypes();
    for (PatchSetApproval a : approvalsUtil.byPatchSetUser(ctx.getDb(), ctl, psId, accountId)) {
        if (labelTypes.byLabel(a.getLabelId()) == null) {
            // Ignore undefined labels.
            continue;
        } else if (!a.getLabel().equals(label)) {
            // Populate map for non-matching labels, needed by VoteDeleted.
            newApprovals.put(a.getLabel(), a.getValue());
            continue;
        } else if (!ctl.canRemoveReviewer(a)) {
            throw new AuthException("delete vote not permitted");
        }
        // Set the approval to 0 if vote is being removed.
        newApprovals.put(a.getLabel(), (short) 0);
        found = true;
        // Set old value, as required by VoteDeleted.
        oldApprovals.put(a.getLabel(), a.getValue());
        break;
    }
    if (!found) {
        throw new ResourceNotFoundException();
    }
    ctx.getUpdate(psId).removeApprovalFor(accountId, label);
    ctx.getDb().patchSetApprovals().upsert(Collections.singleton(deletedApproval(ctx)));
    StringBuilder msg = new StringBuilder();
    msg.append("Removed ");
    LabelVote.appendTo(msg, label, checkNotNull(oldApprovals.get(label)));
    msg.append(" by ").append(userFactory.create(accountId).getNameEmail()).append("\n");
    changeMessage = ChangeMessagesUtil.newMessage(ctx, msg.toString(), ChangeMessagesUtil.DELETE_VOTE);
    cmUtil.addChangeMessage(ctx.getDb(), ctx.getUpdate(psId), changeMessage);
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, AuthException, ResourceNotFoundException {
    ChangeControl ctl = ctx.getControl();
    change = ctl.getChange();
    PatchSet.Id psId = change.currentPatchSetId();
    ps = psUtil.current(db.get(), ctl.getNotes());
    boolean found = false;
    LabelTypes labelTypes = ctx.getControl().getLabelTypes();
    for (PatchSetApproval a : approvalsUtil.byPatchSetUser(ctx.getDb(), ctl, psId, accountId)) {
        if (labelTypes.byLabel(a.getLabelId()) == null) {
            // Ignore undefined labels.
            continue;
        } else if (!a.getLabel().equals(label)) {
            // Populate map for non-matching labels, needed by VoteDeleted.
            newApprovals.put(a.getLabel(), a.getValue());
            continue;
        } else if (!ctl.canRemoveReviewer(a)) {
            throw new AuthException("delete vote not permitted");
        }
        // Set the approval to 0 if vote is being removed.
        newApprovals.put(a.getLabel(), (short) 0);
        found = true;
        // Set old value, as required by VoteDeleted.
        oldApprovals.put(a.getLabel(), a.getValue());
        break;
    }
    if (!found) {
        throw new ResourceNotFoundException();
    }
    ctx.getUpdate(psId).removeApprovalFor(accountId, label);
    ctx.getDb().patchSetApprovals().upsert(Collections.singleton(deletedApproval(ctx)));
    StringBuilder msg = new StringBuilder();
    msg.append("Removed ");
    LabelVote.appendTo(msg, label, checkNotNull(oldApprovals.get(label)));
    msg.append(" by ").append(userFactory.create(accountId).getNameEmail()).append("\n");
    changeMessage = ChangeMessagesUtil.newMessage(ctx, msg.toString(), ChangeMessagesUtil.TAG_DELETE_VOTE);
    cmUtil.addChangeMessage(ctx.getDb(), ctx.getUpdate(psId), changeMessage);
    return true;
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws ResourceConflictException, OrmException, IOException {
    ReviewDb db = ctx.getDb();
    ChangeControl ctl = ctx.getControl();
    change = ctx.getChange();
    ChangeUpdate update = ctx.getUpdate(psId);
    update.setSubjectForCommit("Create patch set " + psId.get());
    if (!change.getStatus().isOpen() && !allowClosed) {
        throw new ResourceConflictException(String.format("Cannot create new patch set of change %s because it is %s", change.getId(), change.getStatus().name().toLowerCase()));
    }
    List<String> newGroups = groups;
    if (newGroups.isEmpty()) {
        PatchSet prevPs = psUtil.current(db, ctx.getNotes());
        if (prevPs != null) {
            newGroups = prevPs.getGroups();
        }
    }
    patchSet = psUtil.insert(db, ctx.getRevWalk(), ctx.getUpdate(psId), psId, commit, draft, newGroups, null);
    if (notify != NotifyHandling.NONE) {
        oldReviewers = approvalsUtil.getReviewers(db, ctl.getNotes());
    }
    if (message != null) {
        changeMessage = ChangeMessagesUtil.newMessage(db, patchSet.getId(), ctx.getUser(), ctx.getWhen(), message, ChangeMessagesUtil.PATCH_SET_INSERTER);
        changeMessage.setMessage(message);
    }
    patchSetInfo = patchSetInfoFactory.get(ctx.getRevWalk(), commit, psId);
    if (change.getStatus() != Change.Status.DRAFT && !allowClosed) {
        change.setStatus(Change.Status.NEW);
    }
    change.setCurrentPatchSet(patchSetInfo);
    if (copyApprovals) {
        approvalCopier.copy(db, ctl, patchSet);
    }
    if (changeMessage != null) {
        cmUtil.addChangeMessage(db, update, changeMessage);
    }
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws ResourceConflictException, OrmException, IOException {
    ReviewDb db = ctx.getDb();
    ChangeControl ctl = ctx.getControl();
    change = ctx.getChange();
    ChangeUpdate update = ctx.getUpdate(psId);
    update.setSubjectForCommit("Create patch set " + psId.get());
    if (!change.getStatus().isOpen() && !allowClosed) {
        throw new ResourceConflictException(String.format("Cannot create new patch set of change %s because it is %s", change.getId(), change.getStatus().name().toLowerCase()));
    }
    List<String> newGroups = groups;
    if (newGroups.isEmpty()) {
        PatchSet prevPs = psUtil.current(db, ctx.getNotes());
        if (prevPs != null) {
            newGroups = prevPs.getGroups();
        }
    }
    patchSet = psUtil.insert(db, ctx.getRevWalk(), ctx.getUpdate(psId), psId, commit, draft, newGroups, null);
    if (notify != NotifyHandling.NONE) {
        oldReviewers = approvalsUtil.getReviewers(db, ctl.getNotes());
    }
    if (message != null) {
        changeMessage = ChangeMessagesUtil.newMessage(db, patchSet.getId(), ctx.getUser(), ctx.getWhen(), message, ChangeMessagesUtil.TAG_UPLOADED_PATCH_SET);
        changeMessage.setMessage(message);
    }
    patchSetInfo = patchSetInfoFactory.get(ctx.getRevWalk(), commit, psId);
    if (change.getStatus() != Change.Status.DRAFT && !allowClosed) {
        change.setStatus(Change.Status.NEW);
    }
    change.setCurrentPatchSet(patchSetInfo);
    if (copyApprovals) {
        approvalCopier.copy(db, ctl, patchSet);
    }
    if (changeMessage != null) {
        cmUtil.addChangeMessage(db, update, changeMessage);
    }
    return true;
}
#end_block

#method_before
private ChangeMessage message(ChangeContext ctx, PatchSet.Id psId, String body) throws OrmException {
    return ChangeMessagesUtil.newMessage(ctx.getDb(), psId, ctx.getUser(), ctx.getWhen(), body, ChangeMessagesUtil.SUBMIT_STRATEGY_OP);
}
#method_after
private ChangeMessage message(ChangeContext ctx, PatchSet.Id psId, String body) throws OrmException {
    return ChangeMessagesUtil.newMessage(ctx.getDb(), psId, ctx.getUser(), ctx.getWhen(), body, ChangeMessagesUtil.TAG_MERGED);
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException {
    StringBuilder sb = new StringBuilder("Patch Set ").append(psId.get()).append(": Cherry Picked").append("\n\n").append("This patchset was cherry picked to branch ").append(destBranch).append(" as commit ").append(cherryPickCommit.name());
    ChangeMessage changeMessage = ChangeMessagesUtil.newMessage(ctx.getDb(), psId, ctx.getUser(), ctx.getWhen(), sb.toString(), ChangeMessagesUtil.CHERRY_PICK_CHANGE);
    cmUtil.addChangeMessage(ctx.getDb(), ctx.getUpdate(psId), changeMessage);
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException {
    StringBuilder sb = new StringBuilder("Patch Set ").append(psId.get()).append(": Cherry Picked").append("\n\n").append("This patchset was cherry picked to branch ").append(destBranch).append(" as commit ").append(cherryPickCommit.name());
    ChangeMessage changeMessage = ChangeMessagesUtil.newMessage(ctx.getDb(), psId, ctx.getUser(), ctx.getWhen(), sb.toString(), ChangeMessagesUtil.TAG_CHERRY_PICK_CHANGE);
    cmUtil.addChangeMessage(ctx.getDb(), ctx.getUpdate(psId), changeMessage);
    return true;
}
#end_block

#method_before
private void addMessage(ChangeContext ctx, ChangeUpdate update) throws OrmException {
    StringBuilder msg = new StringBuilder();
    appendHashtagMessage(msg, "added", toAdd);
    appendHashtagMessage(msg, "removed", toRemove);
    ChangeMessage cmsg = ChangeMessagesUtil.newMessage(ctx, msg.toString(), ChangeMessagesUtil.SET_HASHTAGS_OP);
    cmUtil.addChangeMessage(ctx.getDb(), update, cmsg);
}
#method_after
private void addMessage(ChangeContext ctx, ChangeUpdate update) throws OrmException {
    StringBuilder msg = new StringBuilder();
    appendHashtagMessage(msg, "added", toAdd);
    appendHashtagMessage(msg, "removed", toRemove);
    ChangeMessage cmsg = ChangeMessagesUtil.newMessage(ctx, msg.toString(), ChangeMessagesUtil.TAG_SET_HASHTAGS);
    cmUtil.addChangeMessage(ctx.getDb(), update, cmsg);
}
#end_block

#method_before
public List<SubmitRecord> getSubmitRecords(Change.Id id) {
    // Use the cached submit records from the original ChangeData in the input
    // ChangeSet, which were checked earlier in the integrate process. Even in
    // the case of a race where the submit records may have changed, it makes
    // more sense to store the original results of the submit rule evaluator
    // than to fail at this point.
    // 
    // However, do NOT expose that ChangeData directly, as it is way out of
    // date by this point.
    ChangeData cd = checkNotNull(changes.get(id), "ChangeData for %s", id);
    return checkNotNull(cd.getSubmitRecords(), "getSubmitRecord only valid after submit rules are evalutated");
}
#method_after
public List<SubmitRecord> getSubmitRecords(Change.Id id) {
    // Use the cached submit records from the original ChangeData in the input
    // ChangeSet, which were checked earlier in the integrate process. Even in
    // the case of a race where the submit records may have changed, it makes
    // more sense to store the original results of the submit rule evaluator
    // than to fail at this point.
    // 
    // However, do NOT expose that ChangeData directly, as it is way out of
    // date by this point.
    ChangeData cd = checkNotNull(changes.get(id), "ChangeData for %s", id);
    return checkNotNull(cd.getSubmitRecords(SUBMIT_RULE_OPTIONS), "getSubmitRecord only valid after submit rules are evalutated");
}
#end_block

#method_before
public static void checkSubmitRule(ChangeData cd) throws ResourceConflictException, OrmException {
    PatchSet patchSet = cd.currentPatchSet();
    if (patchSet == null) {
        throw new ResourceConflictException("missing current patch set for change " + cd.getId());
    }
    List<SubmitRecord> results = getSubmitRecords(cd);
    if (findOkRecord(results).isPresent()) {
        // Rules supplied a valid solution.
        return;
    } else if (results.isEmpty()) {
        throw new IllegalStateException(String.format("SubmitRuleEvaluator.evaluate for change %s " + "returned empty list for %s in %s", cd.getId(), patchSet.getId(), cd.change().getProject().get()));
    }
    for (SubmitRecord record : results) {
        switch(record.status) {
            case CLOSED:
                throw new ResourceConflictException("change is closed");
            case RULE_ERROR:
                throw new ResourceConflictException("submit rule error: " + record.errorMessage);
            case NOT_READY:
                throw new ResourceConflictException(describeLabels(cd, record.labels));
            case FORCED:
            case OK:
            default:
                throw new IllegalStateException(String.format("Unexpected SubmitRecord status %s for %s in %s", record.status, patchSet.getId().getId(), cd.change().getProject().get()));
        }
    }
    throw new IllegalStateException();
}
#method_after
public static void checkSubmitRule(ChangeData cd) throws ResourceConflictException, OrmException {
    PatchSet patchSet = cd.currentPatchSet();
    if (patchSet == null) {
        throw new ResourceConflictException("missing current patch set for change " + cd.getId());
    }
    List<SubmitRecord> results = getSubmitRecords(cd);
    if (SubmitRecord.findOkRecord(results).isPresent()) {
        // Rules supplied a valid solution.
        return;
    } else if (results.isEmpty()) {
        throw new IllegalStateException(String.format("SubmitRuleEvaluator.evaluate for change %s " + "returned empty list for %s in %s", cd.getId(), patchSet.getId(), cd.change().getProject().get()));
    }
    for (SubmitRecord record : results) {
        switch(record.status) {
            case CLOSED:
                throw new ResourceConflictException("change is closed");
            case RULE_ERROR:
                throw new ResourceConflictException("submit rule error: " + record.errorMessage);
            case NOT_READY:
                throw new ResourceConflictException(describeLabels(cd, record.labels));
            case FORCED:
            case OK:
            default:
                throw new IllegalStateException(String.format("Unexpected SubmitRecord status %s for %s in %s", record.status, patchSet.getId().getId(), cd.change().getProject().get()));
        }
    }
    throw new IllegalStateException();
}
#end_block

#method_before
private static List<SubmitRecord> getSubmitRecords(ChangeData cd) throws OrmException {
    List<SubmitRecord> results = cd.getSubmitRecords();
    if (results == null) {
        results = new SubmitRuleEvaluator(cd).evaluate();
        cd.setSubmitRecords(results);
    }
    return results;
}
#method_after
private static List<SubmitRecord> getSubmitRecords(ChangeData cd) throws OrmException {
    return cd.submitRecords(SUBMIT_RULE_OPTIONS);
}
#end_block

#method_before
private void bypassSubmitRules(ChangeSet cs) {
    checkArgument(!cs.furtherHiddenChanges(), "cannot bypass submit rules for topic with hidden change");
    for (ChangeData cd : cs.changes()) {
        List<SubmitRecord> records;
        try {
            records = new ArrayList<>(getSubmitRecords(cd));
        } catch (OrmException e) {
            log.warn("Error checking submit rules for change " + cd.getId(), e);
            records = new ArrayList<>(1);
        }
        SubmitRecord forced = new SubmitRecord();
        forced.status = SubmitRecord.Status.FORCED;
        records.add(forced);
        cd.setSubmitRecords(records);
    }
}
#method_after
private void bypassSubmitRules(ChangeSet cs) {
    checkArgument(!cs.furtherHiddenChanges(), "cannot bypass submit rules for topic with hidden change");
    for (ChangeData cd : cs.changes()) {
        List<SubmitRecord> records;
        try {
            records = new ArrayList<>(getSubmitRecords(cd));
        } catch (OrmException e) {
            log.warn("Error checking submit rules for change " + cd.getId(), e);
            records = new ArrayList<>(1);
        }
        SubmitRecord forced = new SubmitRecord();
        forced.status = SubmitRecord.Status.FORCED;
        records.add(forced);
        cd.setSubmitRecords(SUBMIT_RULE_OPTIONS, records);
    }
}
#end_block

#method_before
private void abandonAllOpenChangeForDeletedProject(Project.NameKey destProject) {
    try {
        for (ChangeData cd : internalChangeQuery.byProjectOpen(destProject)) {
            try (BatchUpdate bu = batchUpdateFactory.create(db, destProject, internalUserFactory.create(), ts)) {
                bu.setRequestId(submissionId);
                bu.addOp(cd.getId(), new BatchUpdate.Op() {

                    @Override
                    public boolean updateChange(ChangeContext ctx) throws OrmException {
                        Change change = ctx.getChange();
                        if (!change.getStatus().isOpen()) {
                            return false;
                        }
                        change.setStatus(Change.Status.ABANDONED);
                        ChangeMessage msg = ChangeMessagesUtil.newMessage(ctx.getDb(), change.currentPatchSetId(), internalUserFactory.create(), change.getLastUpdatedOn(), ChangeMessagesUtil.MERGE_OP, "Project was deleted.");
                        cmUtil.addChangeMessage(ctx.getDb(), ctx.getUpdate(change.currentPatchSetId()), msg);
                        return true;
                    }
                });
                try {
                    bu.execute();
                } catch (UpdateException | RestApiException e) {
                    logWarn("Cannot abandon changes for deleted project " + destProject, e);
                }
            }
        }
    } catch (OrmException e) {
        logWarn("Cannot abandon changes for deleted project " + destProject, e);
    }
}
#method_after
private void abandonAllOpenChangeForDeletedProject(Project.NameKey destProject) {
    try {
        for (ChangeData cd : internalChangeQuery.byProjectOpen(destProject)) {
            try (BatchUpdate bu = batchUpdateFactory.create(db, destProject, internalUserFactory.create(), ts)) {
                bu.setRequestId(submissionId);
                bu.addOp(cd.getId(), new BatchUpdate.Op() {

                    @Override
                    public boolean updateChange(ChangeContext ctx) throws OrmException {
                        Change change = ctx.getChange();
                        if (!change.getStatus().isOpen()) {
                            return false;
                        }
                        change.setStatus(Change.Status.ABANDONED);
                        ChangeMessage msg = ChangeMessagesUtil.newMessage(ctx.getDb(), change.currentPatchSetId(), internalUserFactory.create(), change.getLastUpdatedOn(), ChangeMessagesUtil.TAG_MERGED, "Project was deleted.");
                        cmUtil.addChangeMessage(ctx.getDb(), ctx.getUpdate(change.currentPatchSetId()), msg);
                        return true;
                    }
                });
                try {
                    bu.execute();
                } catch (UpdateException | RestApiException e) {
                    logWarn("Cannot abandon changes for deleted project " + destProject, e);
                }
            }
        }
    } catch (OrmException e) {
        logWarn("Cannot abandon changes for deleted project " + destProject, e);
    }
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, IOException {
    change = ctx.getChange();
    correctBranch = refName.equals(change.getDest().get());
    if (!correctBranch) {
        return false;
    }
    if (patchSetProvider != null) {
        // Caller might have also arranged for construction of a new patch set
        // that is not present in the old notes so we can't use PatchSetUtil.
        patchSet = patchSetProvider.get();
    } else {
        patchSet = checkNotNull(psUtil.get(ctx.getDb(), ctx.getNotes(), psId), "patch set %s not found", psId);
    }
    info = getPatchSetInfo(ctx);
    ChangeUpdate update = ctx.getUpdate(psId);
    if (change.getStatus().isOpen()) {
        change.setCurrentPatchSet(info);
        change.setStatus(Change.Status.MERGED);
        // we cannot reconstruct the submit records for when this change was
        // submitted, this is why we must fix the status
        update.fixStatus(Change.Status.MERGED);
    }
    StringBuilder msgBuf = new StringBuilder();
    msgBuf.append("Change has been successfully pushed");
    if (!refName.equals(change.getDest().get())) {
        msgBuf.append(" into ");
        if (refName.startsWith(Constants.R_HEADS)) {
            msgBuf.append("branch ");
            msgBuf.append(Repository.shortenRefName(refName));
        } else {
            msgBuf.append(refName);
        }
    }
    msgBuf.append(".");
    ChangeMessage msg = ChangeMessagesUtil.newMessage(ctx.getDb(), psId, ctx.getUser(), ctx.getWhen(), msgBuf.toString(), ChangeMessagesUtil.MERGED_BY_PUSH_OP);
    cmUtil.addChangeMessage(ctx.getDb(), update, msg);
    PatchSetApproval submitter = ApprovalsUtil.newApproval(change.currentPatchSetId(), ctx.getUser(), LabelId.legacySubmit(), 1, ctx.getWhen());
    update.putApproval(submitter.getLabel(), submitter.getValue());
    ctx.getDb().patchSetApprovals().upsert(Collections.singleton(submitter));
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, IOException {
    change = ctx.getChange();
    correctBranch = refName.equals(change.getDest().get());
    if (!correctBranch) {
        return false;
    }
    if (patchSetProvider != null) {
        // Caller might have also arranged for construction of a new patch set
        // that is not present in the old notes so we can't use PatchSetUtil.
        patchSet = patchSetProvider.get();
    } else {
        patchSet = checkNotNull(psUtil.get(ctx.getDb(), ctx.getNotes(), psId), "patch set %s not found", psId);
    }
    info = getPatchSetInfo(ctx);
    ChangeUpdate update = ctx.getUpdate(psId);
    if (change.getStatus().isOpen()) {
        change.setCurrentPatchSet(info);
        change.setStatus(Change.Status.MERGED);
        // we cannot reconstruct the submit records for when this change was
        // submitted, this is why we must fix the status
        update.fixStatus(Change.Status.MERGED);
    }
    StringBuilder msgBuf = new StringBuilder();
    msgBuf.append("Change has been successfully pushed");
    if (!refName.equals(change.getDest().get())) {
        msgBuf.append(" into ");
        if (refName.startsWith(Constants.R_HEADS)) {
            msgBuf.append("branch ");
            msgBuf.append(Repository.shortenRefName(refName));
        } else {
            msgBuf.append(refName);
        }
    }
    msgBuf.append(".");
    ChangeMessage msg = ChangeMessagesUtil.newMessage(ctx.getDb(), psId, ctx.getUser(), ctx.getWhen(), msgBuf.toString(), ChangeMessagesUtil.TAG_MERGED);
    cmUtil.addChangeMessage(ctx.getDb(), update, msg);
    PatchSetApproval submitter = ApprovalsUtil.newApproval(change.currentPatchSetId(), ctx.getUser(), LabelId.legacySubmit(), 1, ctx.getWhen());
    update.putApproval(submitter.getLabel(), submitter.getValue());
    ctx.getDb().patchSetApprovals().upsert(Collections.singleton(submitter));
    return true;
}
#end_block

#method_before
public static ChangeMessage newMessage(BatchUpdate.ChangeContext ctx, String body, String tag) throws OrmException {
    return newMessage(ctx.getDb(), ctx.getChange().currentPatchSetId(), ctx.getUser(), ctx.getWhen(), body, tag);
}
#method_after
public static ChangeMessage newMessage(BatchUpdate.ChangeContext ctx, String body, @Nullable String tag) throws OrmException {
    return newMessage(ctx.getDb(), ctx.getChange().currentPatchSetId(), ctx.getUser(), ctx.getWhen(), body, tag);
}
#end_block

#method_before
public static ChangeMessage newMessage(ReviewDb db, PatchSet.Id psId, CurrentUser user, Timestamp when, String body, String tag) throws OrmException {
    checkNotNull(psId);
    Account.Id accountId = user.isInternalUser() ? null : user.getAccountId();
    ChangeMessage m = new ChangeMessage(new ChangeMessage.Key(psId.getParentKey(), ChangeUtil.messageUUID(db)), accountId, when, psId);
    m.setMessage(body);
    m.setTag(tag);
    user.updateRealAccountId(m::setRealAuthor);
    return m;
}
#method_after
public static ChangeMessage newMessage(ReviewDb db, PatchSet.Id psId, CurrentUser user, Timestamp when, String body, @Nullable String tag) throws OrmException {
    checkNotNull(psId);
    Account.Id accountId = user.isInternalUser() ? null : user.getAccountId();
    ChangeMessage m = new ChangeMessage(new ChangeMessage.Key(psId.getParentKey(), ChangeUtil.messageUUID(db)), accountId, when, psId);
    m.setMessage(body);
    m.setTag(tag);
    user.updateRealAccountId(m::setRealAuthor);
    return m;
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws Exception {
    Change change = ctx.getChange();
    PatchSet.Id patchSetId = change.currentPatchSetId();
    ChangeMessage changeMessage = ChangeMessagesUtil.newMessage(ctx, "Created a revert of this change as I" + computedChangeId.name(), ChangeMessagesUtil.REVERT);
    cmUtil.addChangeMessage(ctx.getDb(), ctx.getUpdate(patchSetId), changeMessage);
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws Exception {
    Change change = ctx.getChange();
    PatchSet.Id patchSetId = change.currentPatchSetId();
    ChangeMessage changeMessage = ChangeMessagesUtil.newMessage(ctx, "Created a revert of this change as I" + computedChangeId.name(), ChangeMessagesUtil.TAG_REVERT);
    cmUtil.addChangeMessage(ctx.getDb(), ctx.getUpdate(patchSetId), changeMessage);
    return true;
}
#end_block

#method_before
protected void ccExistingReviewers() {
    if (!NotifyHandling.ALL.equals(notify) && !NotifyHandling.OWNER_REVIEWERS.equals(notify)) {
        return;
    }
    try {
        for (Account.Id id : changeData.reviewers().byState(REVIEWER)) {
            add(RecipientType.CC, id);
        }
    } catch (OrmException err) {
        log.warn("Cannot CC users that commented on updated change", err);
    }
}
#method_after
protected void ccExistingReviewers() {
    if (!NotifyHandling.ALL.equals(notify) && !NotifyHandling.OWNER_REVIEWERS.equals(notify)) {
        return;
    }
    try {
        for (Account.Id id : changeData.reviewers().byState(ReviewerStateInternal.REVIEWER)) {
            add(RecipientType.CC, id);
        }
    } catch (OrmException err) {
        log.warn("Cannot CC users that commented on updated change", err);
    }
}
#end_block

#method_before
@Override
protected void setupSoyContext() {
    super.setupSoyContext();
    soyContext.put("changeId", change.getKey().get());
    soyContext.put("coverLetter", getCoverLetter());
    soyContext.put("fromName", getNameFor(fromId));
    soyContextEmailData.put("unifiedDiff", getUnifiedDiff());
    soyContextEmailData.put("changeDetail", getChangeDetail());
    soyContextEmailData.put("changeUrl", getChangeUrl());
    soyContextEmailData.put("includeDiff", getIncludeDiff());
    Map<String, String> changeData = new HashMap<>();
    changeData.put("subject", change.getSubject());
    changeData.put("originalSubject", change.getOriginalSubject());
    changeData.put("ownerEmail", getNameEmailFor(change.getOwner()));
    soyContext.put("change", changeData);
    String subject = change.getSubject();
    changeData.put("subject", subject);
    // it exceeds that.
    if (subject.length() < 64) {
        changeData.put("shortSubject", subject);
    } else {
        changeData.put("shortSubject", subject.substring(0, 60) + "...");
    }
    Map<String, Object> patchSetData = new HashMap<>();
    patchSetData.put("patchSetId", patchSet.getPatchSetId());
    patchSetData.put("refName", patchSet.getRefName());
    soyContext.put("patchSet", patchSetData);
    soyContext.put("reviewerEmails", getReviewerEmails());
// TODO(wyatta): patchSetInfo
}
#method_after
@Override
protected void setupSoyContext() {
    super.setupSoyContext();
    soyContext.put("changeId", change.getKey().get());
    soyContext.put("coverLetter", getCoverLetter());
    soyContext.put("fromName", getNameFor(fromId));
    soyContextEmailData.put("unifiedDiff", getUnifiedDiff());
    soyContextEmailData.put("changeDetail", getChangeDetail());
    soyContextEmailData.put("changeUrl", getChangeUrl());
    soyContextEmailData.put("includeDiff", getIncludeDiff());
    Map<String, String> changeData = new HashMap<>();
    changeData.put("subject", change.getSubject());
    changeData.put("originalSubject", change.getOriginalSubject());
    changeData.put("ownerEmail", getNameEmailFor(change.getOwner()));
    soyContext.put("change", changeData);
    String subject = change.getSubject();
    changeData.put("subject", subject);
    // it exceeds that.
    if (subject.length() < 64) {
        changeData.put("shortSubject", subject);
    } else {
        changeData.put("shortSubject", subject.substring(0, 60) + "...");
    }
    Map<String, Object> patchSetData = new HashMap<>();
    patchSetData.put("patchSetId", patchSet.getPatchSetId());
    patchSetData.put("refName", patchSet.getRefName());
    soyContext.put("patchSet", patchSetData);
    soyContext.put("reviewerEmails", getEmailsByState(ReviewerStateInternal.REVIEWER));
    soyContext.put("ccEmails", getEmailsByState(ReviewerStateInternal.CC));
// TODO(wyatta): patchSetInfo
}
#end_block

#method_before
public void addReviewers(Change change, Collection<Account.Id> reviewers) throws ReviewerManagerException {
    addReviewersAs(change, reviewers, change.getOwner());
}
#method_after
public void addReviewers(Change change, Collection<Account.Id> reviewers) throws ReviewerManagerException {
    try (ManualRequestContext ctx = requestContext.openAs(change.getOwner())) {
        ChangeApi cApi = gApi.changes().id(change.getId().get());
        for (Account.Id account : reviewers) {
            cApi.addReviewer(account.toString());
        }
    } catch (RestApiException | OrmException e) {
        log.error("Couldn't add reviewers to the change", e);
        throw new ReviewerManagerException(e);
    }
}
#end_block

#method_before
private void processEvent(Repository repository, Event event) {
    if (event.getRefName().startsWith(CHANGES_REF)) {
        Change.Id id = Change.Id.fromRef(event.getRefName());
        try {
            Change change = db.get().changes().get(id);
            PatchList patchList = getPatchList(event, change);
            if (patchList != null) {
                PathOwners owners = new PathOwners(accountResolver, db, repository, patchList);
                reviewerManager.addReviewers(change, owners.get().values());
            }
        } catch (OrmException e) {
            logger.warn("Could not open change: {}", id, e);
        } catch (ReviewerManagerException e) {
            logger.warn("Could not add reviewers for change: {}", id, e);
        }
    }
}
#method_after
private void processEvent(Repository repository, Event event) {
    if (event.getRefName().startsWith(CHANGES_REF)) {
        Change.Id id = Change.Id.fromRef(event.getRefName());
        try {
            ReviewDb reviewDb = db.get();
            Change change = reviewDb.changes().get(id);
            PatchList patchList = getPatchList(event, change);
            if (patchList != null) {
                PathOwners owners = new PathOwners(accountResolver, reviewDb, repository, patchList);
                reviewerManager.addReviewers(change, owners.get().values());
            }
        } catch (OrmException e) {
            logger.warn("Could not open change: {}", id, e);
        } catch (ReviewerManagerException e) {
            logger.warn("Could not add reviewers for change: {}", id, e);
        }
    }
}
#end_block

#method_before
private PatchList getPatchList(Event event, Change change) {
    ObjectId newId = null;
    if (event.getNewObjectId() != null) {
        newId = ObjectId.fromString(event.getNewObjectId());
    }
    PatchListKey plKey = new PatchListKey(change.getProject(), null, newId, IGNORE_NONE);
    try {
        return patchListCache.get(plKey);
    } catch (PatchListNotAvailableException e) {
        logger.warn("Could not load patch list: {}", plKey, e);
    }
    return null;
}
#method_after
private PatchList getPatchList(Event event, Change change) {
    ObjectId newId = null;
    if (event.getNewObjectId() != null) {
        newId = ObjectId.fromString(event.getNewObjectId());
    }
    PatchListKey plKey = new PatchListKey(null, newId, IGNORE_NONE);
    try {
        return patchListCache.get(plKey, change.getProject());
    } catch (PatchListNotAvailableException e) {
        logger.warn("Could not load patch list: {}", plKey, e);
    }
    return null;
}
#end_block

#method_before
protected static Iterable<Integer> ids(AccountInfo... accounts) {
    return Stream.of(accounts).map(a -> a._accountId).collect(toList());
}
#method_after
protected static Iterable<Integer> ids(AccountInfo... accounts) {
    return ids(Arrays.asList(accounts));
}
#end_block

#method_before
public static Optional<TimeZone> getTimeZone(Config config, String section, String subsection, String name) {
    return Optional.ofNullable(config.getString(section, subsection, name)).map(id -> TimeZone.getTimeZone(id));
}
#method_after
public static Optional<TimeZone> getTimeZone(Config config, String section, String subsection, String name) {
    return Optional.ofNullable(config.getString(section, subsection, name)).map(TimeZone::getTimeZone);
}
#end_block

#method_before
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            persist(OAUTH_TOKENS, String.class, OAuthToken.class);
        }
    };
}
#method_after
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            persist(OAUTH_TOKENS, Account.Id.class, OAuthToken.class);
        }
    };
}
#end_block

#method_before
public OAuthToken get(String userName) {
    OAuthToken accessToken = cache.getIfPresent(userName);
    if (accessToken == null) {
        return null;
    }
    accessToken = decrypt(accessToken);
    if (accessToken.isExpired()) {
        cache.invalidate(userName);
        return null;
    }
    return accessToken;
}
#method_after
public OAuthToken get(Account.Id id) {
    OAuthToken accessToken = cache.getIfPresent(id);
    if (accessToken == null) {
        return null;
    }
    accessToken = decrypt(accessToken);
    if (accessToken.isExpired()) {
        cache.invalidate(id);
        return null;
    }
    return accessToken;
}
#end_block

#method_before
public void put(OAuthUserInfo user, OAuthToken accessToken) {
    cache.put(checkNotNull(user.getGerritUserName()), encrypt(checkNotNull(accessToken)));
}
#method_after
public void put(Account.Id id, OAuthToken accessToken) {
    cache.put(id, encrypt(checkNotNull(accessToken)));
}
#end_block

#method_before
public void remove(OAuthUserInfo user) {
    if (user != null) {
        cache.invalidate(user.getGerritUserName());
    }
}
#method_after
public void remove(Account.Id id) {
    cache.invalidate(id);
}
#end_block

#method_before
private void authenticateAndRedirect(HttpServletRequest req, HttpServletResponse rsp, OAuthToken token) throws IOException {
    AuthRequest areq = new AuthRequest(user.getExternalId());
    AuthResult arsp;
    try {
        String claimedIdentifier = user.getClaimedIdentity();
        if (!Strings.isNullOrEmpty(claimedIdentifier)) {
            if (!authenticateWithIdentityClaimedDuringHandshake(areq, rsp, claimedIdentifier)) {
                return;
            }
        } else if (linkMode) {
            if (!authenticateWithLinkedIdentity(areq, rsp)) {
                return;
            }
        }
        areq.setUserName(user.getUserName());
        areq.setEmailAddress(user.getEmailAddress());
        areq.setDisplayName(user.getDisplayName());
        arsp = accountManager.authenticate(areq);
        if (user != null) {
            user.setGerritUserName(accountCache.get(arsp.getAccountId()).getUserName());
            if (token != null && user.getGerritUserName() != null) {
                tokenCache.put(user, token);
            }
        }
    } catch (AccountException e) {
        log.error("Unable to authenticate user \"" + user + "\"", e);
        rsp.sendError(HttpServletResponse.SC_FORBIDDEN);
        return;
    }
    webSession.get().login(arsp, true);
    String suffix = redirectToken.substring(OAuthWebFilter.GERRIT_LOGIN.length() + 1);
    StringBuilder rdr = new StringBuilder(urlProvider.get(req));
    rdr.append(Url.decode(suffix));
    rsp.sendRedirect(rdr.toString());
}
#method_after
private void authenticateAndRedirect(HttpServletRequest req, HttpServletResponse rsp, OAuthToken token) throws IOException {
    AuthRequest areq = new AuthRequest(user.getExternalId());
    AuthResult arsp;
    try {
        String claimedIdentifier = user.getClaimedIdentity();
        if (!Strings.isNullOrEmpty(claimedIdentifier)) {
            if (!authenticateWithIdentityClaimedDuringHandshake(areq, rsp, claimedIdentifier)) {
                return;
            }
        } else if (linkMode) {
            if (!authenticateWithLinkedIdentity(areq, rsp)) {
                return;
            }
        }
        areq.setUserName(user.getUserName());
        areq.setEmailAddress(user.getEmailAddress());
        areq.setDisplayName(user.getDisplayName());
        arsp = accountManager.authenticate(areq);
        accountId = arsp.getAccountId();
        tokenCache.put(accountId, token);
    } catch (AccountException e) {
        log.error("Unable to authenticate user \"" + user + "\"", e);
        rsp.sendError(HttpServletResponse.SC_FORBIDDEN);
        return;
    }
    webSession.get().login(arsp, true);
    String suffix = redirectToken.substring(OAuthWebFilter.GERRIT_LOGIN.length() + 1);
    StringBuilder rdr = new StringBuilder(urlProvider.get(req));
    rdr.append(Url.decode(suffix));
    rsp.sendRedirect(rdr.toString());
}
#end_block

#method_before
void logout() {
    if (user != null && user.getGerritUserName() != null) {
        tokenCache.remove(user);
    }
    user = null;
    redirectToken = null;
    serviceProvider = null;
}
#method_after
void logout() {
    if (accountId != null) {
        tokenCache.remove(accountId);
        accountId = null;
    }
    user = null;
    redirectToken = null;
    serviceProvider = null;
}
#end_block

#method_before
@Override
public String toString() {
    return "OAuthSession [token=" + tokenCache.get(user) + ", user=" + user + "]";
}
#method_after
@Override
public String toString() {
    return "OAuthSession [token=" + tokenCache.get(accountId) + ", user=" + user + "]";
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ChangesCollection.class);
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(DraftComments.class);
    bind(Comments.class);
    bind(RobotComments.class);
    bind(Files.class);
    bind(Votes.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), ROBOT_COMMENT_KIND);
    DynamicMap.mapOf(binder(), DRAFT_COMMENT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    DynamicMap.mapOf(binder(), CHANGE_EDIT_KIND);
    DynamicMap.mapOf(binder(), VOTE_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    post(CHANGE_KIND, "merge").to(UpdateChangeByMerge.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    get(CHANGE_KIND, "in").to(IncludedIn.class);
    get(CHANGE_KIND, "assignee").to(GetAssignee.class);
    get(CHANGE_KIND, "past_assignees").to(GetPastAssignees.class);
    put(CHANGE_KIND, "assignee").to(PutAssignee.class);
    delete(CHANGE_KIND, "assignee").to(DeleteAssignee.class);
    get(CHANGE_KIND, "hashtags").to(GetHashtags.class);
    get(CHANGE_KIND, "comments").to(ListChangeComments.class);
    get(CHANGE_KIND, "drafts").to(ListChangeDrafts.class);
    get(CHANGE_KIND, "check").to(Check.class);
    post(CHANGE_KIND, "check").to(Check.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND).to(DeleteDraftChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "hashtags").to(PostHashtags.class);
    post(CHANGE_KIND, "publish").to(PublishDraftPatchSet.CurrentRevision.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    get(CHANGE_KIND, "submitted_together").to(SubmittedTogether.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "index").to(Index.class);
    post(CHANGE_KIND, "rebuild.notedb").to(Rebuild.class);
    post(CHANGE_KIND, "move").to(Move.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    get(CHANGE_KIND, "suggest_reviewers").to(SuggestChangeReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    post(REVIEWER_KIND, "delete").to(DeleteReviewer.class);
    child(REVIEWER_KIND, "votes").to(Votes.class);
    delete(VOTE_KIND).to(DeleteVote.class);
    post(VOTE_KIND, "delete").to(DeleteVote.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    get(REVISION_KIND, "actions").to(GetRevisionActions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    delete(REVISION_KIND).to(DeleteDraftPatchSet.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    post(REVISION_KIND, "publish").to(PublishDraftPatchSet.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    get(REVISION_KIND, "preview_submit").to(PreviewSubmit.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    get(REVISION_KIND, "archive").to(GetArchive.class);
    get(REVISION_KIND, "mergelist").to(GetMergeList.class);
    child(REVISION_KIND, "drafts").to(DraftComments.class);
    put(REVISION_KIND, "drafts").to(CreateDraftComment.class);
    get(DRAFT_COMMENT_KIND).to(GetDraftComment.class);
    put(DRAFT_COMMENT_KIND).to(PutDraftComment.class);
    delete(DRAFT_COMMENT_KIND).to(DeleteDraftComment.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    child(REVISION_KIND, "robotcomments").to(RobotComments.class);
    get(ROBOT_COMMENT_KIND).to(GetRobotComment.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "download").to(DownloadContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    get(FILE_KIND, "blame").to(GetBlame.class);
    child(CHANGE_KIND, "edit").to(ChangeEdits.class);
    delete(CHANGE_KIND, "edit").to(DeleteChangeEdit.class);
    child(CHANGE_KIND, "edit:publish").to(PublishChangeEdit.class);
    child(CHANGE_KIND, "edit:rebase").to(RebaseChangeEdit.class);
    put(CHANGE_KIND, "edit:message").to(ChangeEdits.EditMessage.class);
    get(CHANGE_KIND, "edit:message").to(ChangeEdits.GetMessage.class);
    put(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Put.class);
    delete(CHANGE_EDIT_KIND).to(ChangeEdits.DeleteContent.class);
    get(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Get.class);
    get(CHANGE_EDIT_KIND, "meta").to(ChangeEdits.GetMeta.class);
    factory(AccountLoader.Factory.class);
    factory(ChangeEdits.Create.Factory.class);
    factory(ChangeEdits.DeleteFile.Factory.class);
    factory(ChangeInserter.Factory.class);
    factory(EmailReviewComments.Factory.class);
    factory(PatchSetInserter.Factory.class);
    factory(RebaseChangeOp.Factory.class);
    factory(ReviewerResource.Factory.class);
    factory(SetAssigneeOp.Factory.class);
    factory(SetHashtagsOp.Factory.class);
    factory(ChangeResource.Factory.class);
}
#method_after
@Override
protected void configure() {
    bind(ChangesCollection.class);
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(DraftComments.class);
    bind(Comments.class);
    bind(RobotComments.class);
    bind(Files.class);
    bind(Votes.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), ROBOT_COMMENT_KIND);
    DynamicMap.mapOf(binder(), DRAFT_COMMENT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    DynamicMap.mapOf(binder(), CHANGE_EDIT_KIND);
    DynamicMap.mapOf(binder(), VOTE_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    post(CHANGE_KIND, "merge").to(CreateMergePatchSet.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    get(CHANGE_KIND, "in").to(IncludedIn.class);
    get(CHANGE_KIND, "assignee").to(GetAssignee.class);
    get(CHANGE_KIND, "past_assignees").to(GetPastAssignees.class);
    put(CHANGE_KIND, "assignee").to(PutAssignee.class);
    delete(CHANGE_KIND, "assignee").to(DeleteAssignee.class);
    get(CHANGE_KIND, "hashtags").to(GetHashtags.class);
    get(CHANGE_KIND, "comments").to(ListChangeComments.class);
    get(CHANGE_KIND, "drafts").to(ListChangeDrafts.class);
    get(CHANGE_KIND, "check").to(Check.class);
    post(CHANGE_KIND, "check").to(Check.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND).to(DeleteDraftChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "hashtags").to(PostHashtags.class);
    post(CHANGE_KIND, "publish").to(PublishDraftPatchSet.CurrentRevision.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    get(CHANGE_KIND, "submitted_together").to(SubmittedTogether.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "index").to(Index.class);
    post(CHANGE_KIND, "rebuild.notedb").to(Rebuild.class);
    post(CHANGE_KIND, "move").to(Move.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    get(CHANGE_KIND, "suggest_reviewers").to(SuggestChangeReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    post(REVIEWER_KIND, "delete").to(DeleteReviewer.class);
    child(REVIEWER_KIND, "votes").to(Votes.class);
    delete(VOTE_KIND).to(DeleteVote.class);
    post(VOTE_KIND, "delete").to(DeleteVote.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    get(REVISION_KIND, "actions").to(GetRevisionActions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    delete(REVISION_KIND).to(DeleteDraftPatchSet.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    post(REVISION_KIND, "publish").to(PublishDraftPatchSet.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    get(REVISION_KIND, "preview_submit").to(PreviewSubmit.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    get(REVISION_KIND, "archive").to(GetArchive.class);
    get(REVISION_KIND, "mergelist").to(GetMergeList.class);
    child(REVISION_KIND, "drafts").to(DraftComments.class);
    put(REVISION_KIND, "drafts").to(CreateDraftComment.class);
    get(DRAFT_COMMENT_KIND).to(GetDraftComment.class);
    put(DRAFT_COMMENT_KIND).to(PutDraftComment.class);
    delete(DRAFT_COMMENT_KIND).to(DeleteDraftComment.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    child(REVISION_KIND, "robotcomments").to(RobotComments.class);
    get(ROBOT_COMMENT_KIND).to(GetRobotComment.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "download").to(DownloadContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    get(FILE_KIND, "blame").to(GetBlame.class);
    child(CHANGE_KIND, "edit").to(ChangeEdits.class);
    delete(CHANGE_KIND, "edit").to(DeleteChangeEdit.class);
    child(CHANGE_KIND, "edit:publish").to(PublishChangeEdit.class);
    child(CHANGE_KIND, "edit:rebase").to(RebaseChangeEdit.class);
    put(CHANGE_KIND, "edit:message").to(ChangeEdits.EditMessage.class);
    get(CHANGE_KIND, "edit:message").to(ChangeEdits.GetMessage.class);
    put(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Put.class);
    delete(CHANGE_EDIT_KIND).to(ChangeEdits.DeleteContent.class);
    get(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Get.class);
    get(CHANGE_EDIT_KIND, "meta").to(ChangeEdits.GetMeta.class);
    factory(AccountLoader.Factory.class);
    factory(ChangeEdits.Create.Factory.class);
    factory(ChangeEdits.DeleteFile.Factory.class);
    factory(ChangeInserter.Factory.class);
    factory(EmailReviewComments.Factory.class);
    factory(PatchSetInserter.Factory.class);
    factory(RebaseChangeOp.Factory.class);
    factory(ReviewerResource.Factory.class);
    factory(SetAssigneeOp.Factory.class);
    factory(SetHashtagsOp.Factory.class);
    factory(ChangeResource.Factory.class);
}
#end_block

#method_before
@Override
public void updateRepo(RepoContext ctx) throws Exception {
    changeKind = changeKindCache.getChangeKind(projectControl.getProjectState(), ctx.getRepository(), priorCommit, commit);
    if (checkMergedInto) {
        Ref mergedInto = findMergedInto(ctx, dest.get(), commit);
        if (mergedInto != null) {
            mergedByPushOp = mergedByPushOpFactory.create(requestScopePropagator, patchSetId, mergedInto.getName());
        }
    }
    if (updateRef) {
        if (updateRefCommand == null) {
            ctx.addRefUpdate(new ReceiveCommand(ObjectId.zeroId(), commit, patchSetId.toRefName()));
        } else {
            ctx.addRefUpdate(updateRefCommand);
        }
    }
}
#method_after
@Override
public void updateRepo(RepoContext ctx) throws Exception {
    changeKind = changeKindCache.getChangeKind(projectControl.getProject().getNameKey(), ctx.getRepository(), priorCommit, commit);
    if (checkMergedInto) {
        Ref mergedInto = findMergedInto(ctx, dest.get(), commit);
        if (mergedInto != null) {
            mergedByPushOp = mergedByPushOpFactory.create(requestScopePropagator, patchSetId, mergedInto.getName());
        }
    }
    if (updateRef) {
        ctx.addRefUpdate(new ReceiveCommand(ObjectId.zeroId(), commit, patchSetId.toRefName()));
    }
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, IOException {
    change = ctx.getChange();
    if (change == null || change.getStatus().isClosed()) {
        rejectMessage = CHANGE_IS_CLOSED;
        return false;
    }
    if (groups.isEmpty()) {
        PatchSet prevPs = psUtil.current(ctx.getDb(), ctx.getNotes());
        groups = prevPs != null ? prevPs.getGroups() : ImmutableList.<String>of();
    }
    ChangeUpdate update = ctx.getUpdate(patchSetId);
    update.setSubjectForCommit("Create patch set " + patchSetId.get());
    String reviewMessage = null;
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        reviewMessage = magicBranch.message;
        approvals.putAll(magicBranch.labels);
        Set<String> hashtags = magicBranch.hashtags;
        if (hashtags != null && !hashtags.isEmpty()) {
            hashtags.addAll(ctx.getNotes().getHashtags());
            update.setHashtags(hashtags);
        }
        if (magicBranch.topic != null && !magicBranch.topic.equals(ctx.getChange().getTopic())) {
            update.setTopic(magicBranch.topic);
        }
    }
    boolean draft = magicBranch != null && magicBranch.draft;
    if (change.getStatus() == Change.Status.DRAFT && !draft) {
        update.setStatus(Change.Status.NEW);
    }
    newPatchSet = psUtil.insert(ctx.getDb(), ctx.getRevWalk(), update, patchSetId, commit, draft, groups, pushCertificate != null ? pushCertificate.toTextWithSignature() : null);
    recipients.add(getRecipientsFromFooters(ctx.getDb(), accountResolver, draft, commit.getFooterLines()));
    recipients.remove(ctx.getAccountId());
    ChangeData cd = changeDataFactory.create(ctx.getDb(), ctx.getControl());
    MailRecipients oldRecipients = getRecipientsFromReviewers(cd.reviewers());
    Iterable<PatchSetApproval> newApprovals = approvalsUtil.addApprovals(ctx.getDb(), update, projectControl.getLabelTypes(), newPatchSet, ctx.getControl(), approvals);
    approvalCopier.copy(ctx.getDb(), ctx.getControl(), newPatchSet, newApprovals);
    approvalsUtil.addReviewers(ctx.getDb(), update, projectControl.getLabelTypes(), change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
    recipients.add(oldRecipients);
    String approvalMessage = ApprovalsUtil.renderMessageWithApprovals(patchSetId.get(), approvals, scanLabels(ctx, approvals));
    String kindMessage = changeKindMessage(changeKind);
    StringBuilder message = new StringBuilder(approvalMessage);
    if (!Strings.isNullOrEmpty(kindMessage)) {
        message.append(kindMessage);
    } else {
        message.append('.');
    }
    if (!Strings.isNullOrEmpty(reviewMessage)) {
        message.append("\n").append(reviewMessage);
    }
    msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(ctx.getDb())), ctx.getAccountId(), ctx.getWhen(), patchSetId);
    msg.setMessage(message.toString());
    cmUtil.addChangeMessage(ctx.getDb(), update, msg);
    if (mergedByPushOp == null) {
        resetChange(ctx, msg);
    } else {
        mergedByPushOp.setPatchSetProvider(Providers.of(newPatchSet)).updateChange(ctx);
    }
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, IOException {
    change = ctx.getChange();
    if (change == null || change.getStatus().isClosed()) {
        rejectMessage = CHANGE_IS_CLOSED;
        return false;
    }
    if (groups.isEmpty()) {
        PatchSet prevPs = psUtil.current(ctx.getDb(), ctx.getNotes());
        groups = prevPs != null ? prevPs.getGroups() : ImmutableList.<String>of();
    }
    ChangeUpdate update = ctx.getUpdate(patchSetId);
    update.setSubjectForCommit("Create patch set " + patchSetId.get());
    String reviewMessage = null;
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        reviewMessage = magicBranch.message;
        approvals.putAll(magicBranch.labels);
        Set<String> hashtags = magicBranch.hashtags;
        if (hashtags != null && !hashtags.isEmpty()) {
            hashtags.addAll(ctx.getNotes().getHashtags());
            update.setHashtags(hashtags);
        }
        if (magicBranch.topic != null && !magicBranch.topic.equals(ctx.getChange().getTopic())) {
            update.setTopic(magicBranch.topic);
        }
    }
    boolean draft = magicBranch != null && magicBranch.draft;
    if (change.getStatus() == Change.Status.DRAFT && !draft) {
        update.setStatus(Change.Status.NEW);
    }
    newPatchSet = psUtil.insert(ctx.getDb(), ctx.getRevWalk(), update, patchSetId, commit, draft, groups, pushCertificate != null ? pushCertificate.toTextWithSignature() : null);
    recipients.add(getRecipientsFromFooters(ctx.getDb(), accountResolver, draft, commit.getFooterLines()));
    recipients.remove(ctx.getAccountId());
    ChangeData cd = changeDataFactory.create(ctx.getDb(), ctx.getControl());
    MailRecipients oldRecipients = getRecipientsFromReviewers(cd.reviewers());
    Iterable<PatchSetApproval> newApprovals = approvalsUtil.addApprovalsForNewPatchSet(ctx.getDb(), update, projectControl.getLabelTypes(), newPatchSet, ctx.getControl(), approvals);
    approvalCopier.copy(ctx.getDb(), ctx.getControl(), newPatchSet, newApprovals);
    approvalsUtil.addReviewers(ctx.getDb(), update, projectControl.getLabelTypes(), change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
    recipients.add(oldRecipients);
    String approvalMessage = ApprovalsUtil.renderMessageWithApprovals(patchSetId.get(), approvals, scanLabels(ctx, approvals));
    String kindMessage = changeKindMessage(changeKind);
    StringBuilder message = new StringBuilder(approvalMessage);
    if (!Strings.isNullOrEmpty(kindMessage)) {
        message.append(kindMessage);
    } else {
        message.append('.');
    }
    if (!Strings.isNullOrEmpty(reviewMessage)) {
        message.append("\n").append(reviewMessage);
    }
    msg = ChangeMessagesUtil.newMessage(ctx.getDb(), patchSetId, ctx.getUser(), ctx.getWhen(), message.toString());
    cmUtil.addChangeMessage(ctx.getDb(), update, msg);
    if (mergedByPushOp == null) {
        resetChange(ctx, msg);
    } else {
        mergedByPushOp.setPatchSetProvider(Providers.of(newPatchSet)).updateChange(ctx);
    }
    return true;
}
#end_block

#method_before
@Override
public void postUpdate(final Context ctx) throws Exception {
    // Normally the ref updated hook is fired by BatchUpdate, but ReplaceOp is
    // special because its ref is actually updated by ReceiveCommits, so from
    // BatchUpdate's perspective there is no ref update. Thus we have to fire it
    // manually.
    final Account account = ctx.getAccount();
    if (!updateRef) {
        gitRefUpdated.fire(ctx.getProject(), newPatchSet.getRefName(), ObjectId.zeroId(), commit, account);
    }
    if (changeKind != ChangeKind.TRIVIAL_REBASE) {
        Runnable sender = new Runnable() {

            @Override
            public void run() {
                try {
                    ReplacePatchSetSender cm = replacePatchSetFactory.create(projectControl.getProject().getNameKey(), change.getId());
                    cm.setFrom(account.getId());
                    cm.setPatchSet(newPatchSet, info);
                    cm.setChangeMessage(msg.getMessage(), ctx.getWhen());
                    if (magicBranch != null && magicBranch.notify != null) {
                        cm.setNotify(magicBranch.notify);
                    }
                    cm.addReviewers(recipients.getReviewers());
                    cm.addExtraCC(recipients.getCcOnly());
                    cm.send();
                } catch (Exception e) {
                    log.error("Cannot send email for new patch set " + newPatchSet.getId(), e);
                }
            }

            @Override
            public String toString() {
                return "send-email newpatchset";
            }
        };
        if (requestScopePropagator != null) {
            sendEmailExecutor.submit(requestScopePropagator.wrap(sender));
        } else {
            sender.run();
        }
    }
    NotifyHandling notify = magicBranch != null && magicBranch.notify != null ? magicBranch.notify : NotifyHandling.ALL;
    revisionCreated.fire(change, newPatchSet, ctx.getAccountId(), ctx.getWhen(), notify);
    try {
        fireCommentAddedEvent(ctx);
    } catch (Exception e) {
        log.warn("comment-added event invocation failed", e);
    }
    if (mergedByPushOp != null) {
        mergedByPushOp.postUpdate(ctx);
    }
}
#method_after
@Override
public void postUpdate(final Context ctx) throws Exception {
    // Normally the ref updated hook is fired by BatchUpdate, but ReplaceOp is
    // special because its ref is actually updated by ReceiveCommits, so from
    // BatchUpdate's perspective there is no ref update. Thus we have to fire it
    // manually.
    final Account account = ctx.getAccount();
    if (!updateRef) {
        gitRefUpdated.fire(ctx.getProject(), newPatchSet.getRefName(), ObjectId.zeroId(), commit, account);
    }
    if (changeKind != ChangeKind.TRIVIAL_REBASE) {
        Runnable sender = new Runnable() {

            @Override
            public void run() {
                try {
                    ReplacePatchSetSender cm = replacePatchSetFactory.create(projectControl.getProject().getNameKey(), change.getId());
                    cm.setFrom(account.getId());
                    cm.setPatchSet(newPatchSet, info);
                    cm.setChangeMessage(msg.getMessage(), ctx.getWhen());
                    if (magicBranch != null && magicBranch.notify != null) {
                        cm.setNotify(magicBranch.notify);
                    }
                    cm.addReviewers(recipients.getReviewers());
                    cm.addExtraCC(recipients.getCcOnly());
                    cm.send();
                } catch (Exception e) {
                    log.error("Cannot send email for new patch set " + newPatchSet.getId(), e);
                }
            }

            @Override
            public String toString() {
                return "send-email newpatchset";
            }
        };
        if (requestScopePropagator != null) {
            sendEmailExecutor.submit(requestScopePropagator.wrap(sender));
        } else {
            sender.run();
        }
    }
    NotifyHandling notify = magicBranch != null && magicBranch.notify != null ? magicBranch.notify : NotifyHandling.ALL;
    revisionCreated.fire(change, newPatchSet, ctx.getAccount(), ctx.getWhen(), notify);
    try {
        fireCommentAddedEvent(ctx);
    } catch (Exception e) {
        log.warn("comment-added event invocation failed", e);
    }
    if (mergedByPushOp != null) {
        mergedByPushOp.postUpdate(ctx);
    }
}
#end_block

#method_before
private static S3Config getS3Config(LfsGlobalConfig config, LfsBackendConfig backendConfig) {
    String section = backendConfig.type.name();
    String region = config.getString(section, backendConfig.name, "region");
    String bucket = config.getString(section, backendConfig.name, "bucket");
    String storageClass = MoreObjects.firstNonNull(config.getString(section, backendConfig.name, "storageClass"), "REDUCED_REDUNDANCY");
    int expirationSeconds = config.getInt(section, backendConfig.name, "expirationSeconds", 60);
    boolean disableSslVerify = config.getBoolean(section, backendConfig.name, "disableSslVerify", false);
    String accessKey = config.getString(section, backendConfig.name, "accessKey");
    String secretKey = config.getString(section, backendConfig.name, "secretKey");
    return new S3Config(region, bucket, storageClass, accessKey, secretKey, expirationSeconds, disableSslVerify);
}
#method_after
private static S3Config getS3Config(LfsGlobalConfig config, LfsBackend backendConfig) {
    String section = backendConfig.type.name();
    String region = config.getString(section, backendConfig.name, "region");
    String bucket = config.getString(section, backendConfig.name, "bucket");
    String storageClass = MoreObjects.firstNonNull(config.getString(section, backendConfig.name, "storageClass"), "REDUCED_REDUNDANCY");
    int expirationSeconds = config.getInt(section, backendConfig.name, "expirationSeconds", 60);
    boolean disableSslVerify = config.getBoolean(section, backendConfig.name, "disableSslVerify", false);
    String accessKey = config.getString(section, backendConfig.name, "accessKey");
    String secretKey = config.getString(section, backendConfig.name, "secretKey");
    return new S3Config(region, bucket, storageClass, accessKey, secretKey, expirationSeconds, disableSslVerify);
}
#end_block

#method_before
public LfsBackendConfig getDefaultBackend() {
    LfsBackend type = cfg.getEnum("storage", null, "backend", LfsBackend.FS);
    return new LfsBackendConfig(null, type);
}
#method_after
public LfsBackend getDefaultBackend() {
    LfsBackendType type = cfg.getEnum("storage", null, "backend", LfsBackendType.FS);
    return new LfsBackend(null, type);
}
#end_block

#method_before
public Map<String, LfsBackendConfig> getBackends() {
    Builder<String, LfsBackendConfig> builder = ImmutableMap.builder();
    for (final LfsBackend type : LfsBackend.values()) {
        Map<String, LfsBackendConfig> backendsOfType = FluentIterable.from(cfg.getSubsections(type.name())).toMap(new Function<String, LfsBackendConfig>() {

            @Override
            public LfsBackendConfig apply(String input) {
                return new LfsBackendConfig(input, type);
            }
        });
        builder.putAll(backendsOfType);
    }
    return builder.build();
}
#method_after
public Map<String, LfsBackend> getBackends() {
    Builder<String, LfsBackend> builder = ImmutableMap.builder();
    for (final LfsBackendType type : LfsBackendType.values()) {
        Map<String, LfsBackend> backendsOfType = FluentIterable.from(cfg.getSubsections(type.name())).toMap(new Function<String, LfsBackend>() {

            @Override
            public LfsBackend apply(String input) {
                return new LfsBackend(input, type);
            }
        });
        builder.putAll(backendsOfType);
    }
    return builder.build();
}
#end_block

#method_before
@Override
public LfsGlobalConfigInfo apply(ProjectResource resource) throws RestApiException {
    IdentifiedUser user = self.get().asIdentifiedUser();
    if (!(resource.getNameKey().equals(allProjectsName) && user.getCapabilities().canAdministrateServer())) {
        throw new ResourceNotFoundException();
    }
    LfsGlobalConfigInfo info = new LfsGlobalConfigInfo();
    LfsGlobalConfig globalConfig = lfsConfigFactory.getGlobalConfig();
    info.defaultBackend = globalConfig.getDefaultBackend().type;
    info.backends = Maps.transformValues(globalConfig.getBackends(), TO_BACKEND_CFG);
    List<LfsProjectConfigSection> configSections = lfsConfigFactory.getProjectsConfig().getConfigSections();
    if (!configSections.isEmpty()) {
        info.namespaces = new HashMap<>(configSections.size());
        for (LfsProjectConfigSection section : configSections) {
            LfsProjectConfigInfo sectionInfo = new LfsProjectConfigInfo();
            sectionInfo.enabled = section.isEnabled();
            sectionInfo.maxObjectSize = section.getMaxObjectSize();
            sectionInfo.readOnly = section.isReadOnly();
            sectionInfo.backend = section.getBackend();
            info.namespaces.put(section.getNamespace(), sectionInfo);
        }
    }
    return info;
}
#method_after
@Override
public LfsGlobalConfigInfo apply(ProjectResource resource) throws RestApiException {
    IdentifiedUser user = self.get().asIdentifiedUser();
    if (!(resource.getNameKey().equals(allProjectsName) && user.getCapabilities().canAdministrateServer())) {
        throw new ResourceNotFoundException();
    }
    LfsGlobalConfigInfo info = new LfsGlobalConfigInfo();
    LfsGlobalConfig globalConfig = lfsConfigFactory.getGlobalConfig();
    info.defaultBackendType = globalConfig.getDefaultBackend().type;
    info.backends = Maps.transformValues(globalConfig.getBackends(), TO_BACKEND_CFG);
    List<LfsProjectConfigSection> configSections = lfsConfigFactory.getProjectsConfig().getConfigSections();
    if (!configSections.isEmpty()) {
        info.namespaces = new HashMap<>(configSections.size());
        for (LfsProjectConfigSection section : configSections) {
            LfsProjectConfigInfo sectionInfo = new LfsProjectConfigInfo();
            sectionInfo.enabled = section.isEnabled();
            sectionInfo.maxObjectSize = section.getMaxObjectSize();
            sectionInfo.readOnly = section.isReadOnly();
            sectionInfo.backend = section.getBackend();
            info.namespaces.put(section.getNamespace(), sectionInfo);
        }
    }
    return info;
}
#end_block

#method_before
@Override
protected void configureServlets() {
    serveRegex(URL_REGEX).with(LfsApiServlet.class);
    if (FS.equals(defBackendCfg.type)) {
        LocalLargeFileRepository defBackend = fsRepoFactory.create(defBackendCfg);
        serve(defBackend.getServletRegexp()).with(new LfsFsContentServlet(defBackend));
    }
    for (LfsBackendConfig backendCfg : backends.values()) {
        if (FS.equals(backendCfg.type)) {
            LocalLargeFileRepository backend = fsRepoFactory.create(backendCfg);
            serve(backend.getServletRegexp()).with(new LfsFsContentServlet(backend));
        }
    }
}
#method_after
@Override
protected void configureServlets() {
    serveRegex(URL_REGEX).with(LfsApiServlet.class);
    if (FS.equals(defaultBackend.type)) {
        LocalLargeFileRepository defRepository = fsRepoFactory.create(defaultBackend);
        serve(defRepository.getServletUrlPattern()).with(new LfsFsContentServlet(defRepository));
    }
    for (LfsBackend backendCfg : backends.values()) {
        if (FS.equals(backendCfg.type)) {
            LocalLargeFileRepository repository = fsRepoFactory.create(backendCfg);
            serve(repository.getServletUrlPattern()).with(new LfsFsContentServlet(repository));
        }
    }
}
#end_block

#method_before
public LargeFileRepository get(Project.NameKey project, String backendName) throws LfsRepositoryNotFound {
    LfsBackendConfig config = defaultBackend;
    if (!Strings.isNullOrEmpty(backendName)) {
        config = backends.get(backendName);
        if (config == null) {
            throw new LfsRepositoryNotFound(project.get());
        }
    }
    switch(config.type) {
        case FS:
            return fsRepoFactory.create(config);
        case S3:
            return s3RepoFactory.create(config);
        default:
            throw new LfsRepositoryNotFound(project.get());
    }
}
#method_after
public LargeFileRepository get(Project.NameKey project, String backendName) throws LfsRepositoryNotFound {
    LfsBackend config;
    if (Strings.isNullOrEmpty(backendName)) {
        config = defaultBackend;
    } else {
        config = backends.get(backendName);
        if (config == null) {
            throw new LfsRepositoryNotFound(project.get());
        }
    }
    switch(config.type) {
        case FS:
            return fsRepoFactory.create(config);
        case S3:
            return s3RepoFactory.create(config);
        default:
            throw new LfsRepositoryNotFound(project.get());
    }
}
#end_block

#method_before
private static String getContentUrl(String url, LfsBackendConfig backend) {
    // interfere with rest of FS backends
    return url + (url.endsWith("/") ? "" : "/") + getContentPath(backend);
}
#method_after
private static String getContentUrl(String url, LfsBackend backend) {
    // interfere with rest of FS backends
    return url + (url.endsWith("/") ? "" : "/") + getContentPath(backend);
}
#end_block

#method_before
private static String getContentPath(LfsBackendConfig backend) {
    return CONTENT_PATH + "/" + (Strings.isNullOrEmpty(backend.name) ? DEFAULT : backend.name) + "/";
}
#method_after
private static String getContentPath(LfsBackend backend) {
    return CONTENT_PATH + "/" + (Strings.isNullOrEmpty(backend.name) ? DEFAULT : backend.name) + "/";
}
#end_block

#method_before
private static Path getOrCreateDataDir(LfsGlobalConfig config, LfsBackendConfig backendConfig, Path defaultDataDir) throws IOException {
    String dataDir = config.getString(backendConfig.type.name(), backendConfig.name, "directory");
    if (Strings.isNullOrEmpty(dataDir)) {
        return defaultDataDir;
    }
    // note that the following method not only creates missing
    // directory/directories but throws exception when path
    // exists and points to file
    Path ensured = Files.createDirectories(Paths.get(dataDir));
    // we should at least make sure that directory is readable
    if (!Files.isReadable(ensured)) {
        throw new IOException("Path '" + ensured.toAbsolutePath() + "' cannot be accessed");
    }
    return ensured;
}
#method_after
private static Path getOrCreateDataDir(LfsGlobalConfig config, LfsBackend backendConfig, Path defaultDataDir) throws IOException {
    String dataDir = config.getString(backendConfig.type.name(), backendConfig.name, "directory");
    if (Strings.isNullOrEmpty(dataDir)) {
        return defaultDataDir;
    }
    // note that the following method not only creates missing
    // directory/directories but throws exception when path
    // exists and points to file
    Path ensured = Files.createDirectories(Paths.get(dataDir));
    // we should at least make sure that directory is readable
    if (!Files.isReadable(ensured)) {
        throw new IOException("Path '" + ensured.toAbsolutePath() + "' cannot be accessed");
    }
    return ensured;
}
#end_block

#method_before
@Override
public boolean cancel(boolean mayInterruptIfRunning) {
    if (task.cancel(mayInterruptIfRunning)) {
        // 
        if (runnable instanceof CancelableRunnable) {
            if (running.compareAndSet(false, true)) {
                ((CancelableRunnable) runnable).cancel();
            } else if (runnable instanceof CanceledWhileRunning) {
                ((CanceledWhileRunning) runnable).setCanceledWhileRunning();
            }
        }
        if (runnable instanceof Future<?>) {
            // Creating new futures eventually passes through AbstractExecutorService#schedule,
            // which will convert the Guava Future to a Runnable, thereby making it impossible
            // for the cancellation to propagate from ScheduledThreadPool's task back to the
            // Guava future, so kludge it here.
            ((Future<?>) runnable).cancel(mayInterruptIfRunning);
        }
        executor.remove(this);
        executor.purge();
        return true;
    }
    return false;
}
#method_after
@Override
public boolean cancel(boolean mayInterruptIfRunning) {
    if (task.cancel(mayInterruptIfRunning)) {
        // 
        if (runnable instanceof CancelableRunnable) {
            if (running.compareAndSet(false, true)) {
                ((CancelableRunnable) runnable).cancel();
            } else if (runnable instanceof CanceledWhileRunning) {
                ((CanceledWhileRunning) runnable).setCanceledWhileRunning();
            }
        }
        if (runnable instanceof Future<?>) {
            // Creating new futures eventually passes through
            // AbstractExecutorService#schedule, which will convert the Guava
            // Future to a Runnable, thereby making it impossible for the
            // cancellation to propagate from ScheduledThreadPool's task back to
            // the Guava future, so kludge it here.
            ((Future<?>) runnable).cancel(mayInterruptIfRunning);
        }
        executor.remove(this);
        executor.purge();
        return true;
    }
    return false;
}
#end_block

#method_before
@Override
public void requestSuggestions(Request req, Callback cb) {
    Query q = new Query(req, cb);
    if (query == null) {
        query = q;
        q.start();
    } else {
        query = q;
    }
}
#method_after
@Override
public void requestSuggestions(Request req, Callback cb) {
    if (!serveSuggestions) {
        return;
    }
    // backend for each and every keystroke we receive.
    if (requestRetentionTimer != null) {
        requestRetentionTimer.cancel();
    }
    requestRetentionTimer = new Timer() {

        @Override
        public void run() {
            Query q = new Query(req, cb);
            if (query == null) {
                query = q;
                q.start();
            } else {
                query = q;
            }
        }
    };
    requestRetentionTimer.schedule(200);
}
#end_block

#method_before
@Override
public void requestDefaultSuggestions(final Request req, final Callback cb) {
    // We don't want to deal with a null query, but an empty string instead
    req.setQuery("");
    requestSuggestions(req, cb);
}
#method_after
@Override
public void requestDefaultSuggestions(Request req, Callback cb) {
    requestSuggestions(req, cb);
}
#end_block

#method_before
@Override
public void onSuggestionsReady(Request req, Response res) {
    if (query == this) {
        // No new request was started while this query was running.
        // Propose this request's response as the suggestions.
        query = null;
        last = request.getQuery();
        callback.onSuggestionsReady(req, res);
    } else {
        // Another query came in while this one was running. Skip
        // this response and start the most recent query.
        query.start();
    }
}
#method_after
@Override
public void onSuggestionsReady(Request req, Response res) {
    if (cancelOutstandingRequest || !serveSuggestions) {
        // If cancelOutstandingRequest() was called, we ignore this response
        cancelOutstandingRequest = false;
        query = null;
    } else if (query == this) {
        // No new request was started while this query was running.
        // Propose this request's response as the suggestions.
        query = null;
        last = request.getQuery();
        callback.onSuggestionsReady(req, res);
    } else {
        // Another query came in while this one was running. Skip
        // this response and start the most recent query.
        query.start();
    }
}
#end_block

#method_before
@Override
protected void onRequestSuggestions(final Request req, final Callback cb) {
    ChangeApi.suggestReviewers(changeId.get(), req.getQuery(), req.getLimit()).get(new GerritCallback<JsArray<SuggestReviewerInfo>>() {

        @Override
        public void onSuccess(JsArray<SuggestReviewerInfo> result) {
            List<RestReviewerSuggestion> r = new ArrayList<>(result.length());
            for (SuggestReviewerInfo reviewer : Natives.asList(result)) {
                r.add(new RestReviewerSuggestion(reviewer, req.getQuery()));
            }
            cb.onSuggestionsReady(req, new Response(r));
        }

        @Override
        public void onFailure(Throwable err) {
            List<Suggestion> r = Collections.emptyList();
            cb.onSuggestionsReady(req, new Response(r));
        }
    });
}
#method_after
@Override
protected void onRequestSuggestions(final Request req, final Callback cb) {
    ChangeApi.suggestReviewers(changeId.get(), req.getQuery(), req.getLimit(), false).get(new GerritCallback<JsArray<SuggestReviewerInfo>>() {

        @Override
        public void onSuccess(JsArray<SuggestReviewerInfo> result) {
            List<RestReviewerSuggestion> r = new ArrayList<>(result.length());
            for (SuggestReviewerInfo reviewer : Natives.asList(result)) {
                r.add(new RestReviewerSuggestion(reviewer, req.getQuery()));
            }
            cb.onSuggestionsReady(req, new Response(r));
        }

        @Override
        public void onFailure(Throwable err) {
            List<Suggestion> r = Collections.emptyList();
            cb.onSuggestionsReady(req, new Response(r));
        }
    });
}
#end_block

#method_before
public List<SuggestedReviewerInfo> suggestReviewers(ChangeNotes changeNotes, SuggestReviewers suggestReviewers, ProjectControl projectControl, VisibilityControl visibilityControl) throws IOException, OrmException, BadRequestException {
    String query = suggestReviewers.getQuery();
    int limit = suggestReviewers.getLimit();
    if (!suggestReviewers.getSuggestAccounts()) {
        return Collections.emptyList();
    }
    Map<Account.Id, Double> reviewerScores;
    if (Strings.isNullOrEmpty(query)) {
        reviewerScores = defaultReviewersForEmptyQuery();
    } else {
        List<Account.Id> suggestedAccounts = suggestAccounts(suggestReviewers, visibilityControl);
        reviewerScores = defaultRankingForCandidateList(suggestedAccounts, projectControl);
    }
    // can also return non-candidate account ids.
    for (ReviewerSuggestion r : reviewerSuggestionPlugins) {
        // TODO(hiesel) Thread Pool
        for (SuggestedReviewer s : r.suggestReviewers(query, reviewerScores.keySet())) {
            if (reviewerScores.containsKey(s.account)) {
                reviewerScores.put(s.account, reviewerScores.get(s.account) + s.score);
            } else {
                reviewerScores.put(s.account, s.score);
            }
        }
    }
    // Remove change owner
    reviewerScores.remove(changeNotes.getChange().getOwner());
    // Sort results
    List<Account.Id> sortedSuggestions = reviewerScores.entrySet().stream().sorted(Map.Entry.comparingByValue()).map(e -> e.getKey()).collect(Collectors.toList());
    Collections.reverse(sortedSuggestions);
    // Populate AccountInfo
    List<SuggestedReviewerInfo> reviewer = new ArrayList<>();
    for (Account.Id id : sortedSuggestions) {
        SuggestedReviewerInfo info = new SuggestedReviewerInfo();
        info.account = accountLoader.get(id);
        info.count = 1;
        reviewer.add(info);
    }
    accountLoader.fill();
    for (GroupReference g : suggestAccountGroup(suggestReviewers, projectControl)) {
        GroupAsReviewer result = suggestGroupAsReviewer(suggestReviewers, projectControl.getProject(), g, visibilityControl);
        if (result.allowed || result.allowedWithConfirmation) {
            GroupBaseInfo info = new GroupBaseInfo();
            info.id = Url.encode(g.getUUID().get());
            info.name = g.getName();
            SuggestedReviewerInfo suggestedReviewerInfo = new SuggestedReviewerInfo();
            suggestedReviewerInfo.group = info;
            suggestedReviewerInfo.count = result.size;
            if (result.allowedWithConfirmation) {
                suggestedReviewerInfo.confirm = true;
            }
            reviewer.add(suggestedReviewerInfo);
        }
    }
    if (reviewer.size() <= limit) {
        return reviewer;
    }
    return reviewer.subList(0, limit);
}
#method_after
public List<SuggestedReviewerInfo> suggestReviewers(ChangeNotes changeNotes, SuggestReviewers suggestReviewers, ProjectControl projectControl, VisibilityControl visibilityControl, boolean excludeGroups) throws IOException, OrmException {
    String query = suggestReviewers.getQuery();
    int limit = suggestReviewers.getLimit();
    if (!suggestReviewers.getSuggestAccounts()) {
        return Collections.emptyList();
    }
    List<Account.Id> candidateList = new ArrayList<>();
    if (!Strings.isNullOrEmpty(query)) {
        candidateList = suggestAccounts(suggestReviewers, visibilityControl);
    }
    List<Account.Id> sortedRecommendations = reviewerRecommender.suggestReviewers(changeNotes, suggestReviewers, projectControl, candidateList);
    // Populate AccountInfo
    List<SuggestedReviewerInfo> reviewer = new ArrayList<>();
    for (Account.Id id : sortedRecommendations) {
        AccountInfo account = accountLoader.get(id);
        if (account != null) {
            SuggestedReviewerInfo info = new SuggestedReviewerInfo();
            info.account = account;
            info.count = 1;
            reviewer.add(info);
        }
    }
    accountLoader.fill();
    if (!excludeGroups && !Strings.isNullOrEmpty(query)) {
        for (GroupReference g : suggestAccountGroup(suggestReviewers, projectControl)) {
            GroupAsReviewer result = suggestGroupAsReviewer(suggestReviewers, projectControl.getProject(), g, visibilityControl);
            if (result.allowed || result.allowedWithConfirmation) {
                GroupBaseInfo info = new GroupBaseInfo();
                info.id = Url.encode(g.getUUID().get());
                info.name = g.getName();
                SuggestedReviewerInfo suggestedReviewerInfo = new SuggestedReviewerInfo();
                suggestedReviewerInfo.group = info;
                suggestedReviewerInfo.count = result.size;
                if (result.allowedWithConfirmation) {
                    suggestedReviewerInfo.confirm = true;
                }
                // Always add groups at the end as individual accounts are usually
                // more important
                reviewer.add(suggestedReviewerInfo);
            }
        }
    }
    if (reviewer.size() <= limit) {
        return reviewer;
    }
    return reviewer.subList(0, limit);
}
#end_block

#method_before
private List<Account.Id> suggestAccountsFromIndex(SuggestReviewers suggestReviewers) throws OrmException {
    try {
        Set<Account.Id> matches = new HashSet<>();
        QueryResult<AccountState> result = accountQueryProcessor.setLimit(suggestReviewers.getLimit()).query(accountQueryBuilder.defaultQuery(suggestReviewers.getQuery()));
        for (AccountState accountState : result.entities()) {
            Account.Id id = accountState.getAccount().getId();
            matches.add(id);
        }
        return new ArrayList<>(matches);
    } catch (QueryParseException e) {
        return ImmutableList.of();
    }
}
#method_after
private List<Account.Id> suggestAccountsFromIndex(SuggestReviewers suggestReviewers) throws OrmException {
    try {
        Set<Account.Id> matches = new HashSet<>();
        QueryResult<AccountState> result = accountQueryProcessor.setLimit(suggestReviewers.getLimit() * CANDIDATE_LIST_MULTIPLIER).query(accountQueryBuilder.defaultQuery(suggestReviewers.getQuery()));
        for (AccountState accountState : result.entities()) {
            Account.Id id = accountState.getAccount().getId();
            matches.add(id);
        }
        return new ArrayList<>(matches);
    } catch (QueryParseException e) {
        return ImmutableList.of();
    }
}
#end_block

#method_before
private List<Account.Id> suggestAccountsFromDb(SuggestReviewers suggestReviewers, VisibilityControl visibilityControl) throws OrmException {
    String query = suggestReviewers.getQuery();
    int limit = suggestReviewers.getLimit();
    String a = query;
    String b = a + MAX_SUFFIX;
    Set<Account.Id> r = new HashSet<>();
    for (Account p : dbProvider.get().accounts().suggestByFullName(a, b, limit)) {
        if (p.isActive()) {
            addSuggestion(r, p.getId(), visibilityControl);
        }
    }
    if (r.size() < limit) {
        for (Account p : dbProvider.get().accounts().suggestByPreferredEmail(a, b, limit - r.size())) {
            if (p.isActive()) {
                addSuggestion(r, p.getId(), visibilityControl);
            }
        }
    }
    if (r.size() < limit) {
        for (AccountExternalId e : dbProvider.get().accountExternalIds().suggestByEmailAddress(a, b, limit - r.size())) {
            if (!r.contains(e.getAccountId())) {
                Account p = accountCache.get(e.getAccountId()).getAccount();
                if (p.isActive()) {
                    addSuggestion(r, p.getId(), visibilityControl);
                }
            }
        }
    }
    accountLoader.fill();
    return new ArrayList<>(r);
}
#method_after
private List<Account.Id> suggestAccountsFromDb(SuggestReviewers suggestReviewers, VisibilityControl visibilityControl) throws OrmException {
    String query = suggestReviewers.getQuery();
    int limit = suggestReviewers.getLimit() * CANDIDATE_LIST_MULTIPLIER;
    String a = query;
    String b = a + MAX_SUFFIX;
    Set<Account.Id> r = new HashSet<>();
    for (Account p : dbProvider.get().accounts().suggestByFullName(a, b, limit)) {
        if (p.isActive()) {
            addSuggestion(r, p.getId(), visibilityControl);
        }
    }
    if (r.size() < limit) {
        for (Account p : dbProvider.get().accounts().suggestByPreferredEmail(a, b, limit - r.size())) {
            if (p.isActive()) {
                addSuggestion(r, p.getId(), visibilityControl);
            }
        }
    }
    if (r.size() < limit) {
        for (AccountExternalId e : dbProvider.get().accountExternalIds().suggestByEmailAddress(a, b, limit - r.size())) {
            if (!r.contains(e.getAccountId())) {
                Account p = accountCache.get(e.getAccountId()).getAccount();
                if (p.isActive()) {
                    addSuggestion(r, p.getId(), visibilityControl);
                }
            }
        }
    }
    return new ArrayList<>(r);
}
#end_block

#method_before
public void suggestReviewersFullTextSearch() throws Exception {
    String changeId = createChange().getChangeId();
    List<SuggestedReviewerInfo> reviewers;
    reviewers = suggestReviewers(changeId, "first", 20);
    assertThat(reviewers).hasSize(3);
    reviewers = suggestReviewers(changeId, "first1", 2);
    assertThat(reviewers).hasSize(1);
    reviewers = suggestReviewers(changeId, "last", 4);
    assertThat(reviewers).hasSize(3);
    reviewers = suggestReviewers(changeId, "last1", 2);
    assertThat(reviewers).hasSize(1);
    reviewers = suggestReviewers(changeId, "fi la", 4);
    assertThat(reviewers).hasSize(3);
    reviewers = suggestReviewers(changeId, "la fi", 4);
    assertThat(reviewers).hasSize(3);
    reviewers = suggestReviewers(changeId, "first1 la", 2);
    assertThat(reviewers).hasSize(1);
    reviewers = suggestReviewers(changeId, "fi last1", 2);
    assertThat(reviewers).hasSize(1);
    reviewers = suggestReviewers(changeId, "first1 last2", 1);
    assertThat(reviewers).hasSize(0);
    reviewers = suggestReviewers(changeId, name("user"), 7);
    assertThat(reviewers).hasSize(6);
    reviewers = suggestReviewers(changeId, user1.username, 2);
    assertThat(reviewers).hasSize(1);
    reviewers = suggestReviewers(changeId, "example.com", 7);
    assertThat(reviewers).hasSize(6);
    reviewers = suggestReviewers(changeId, user1.email, 2);
    assertThat(reviewers).hasSize(1);
    reviewers = suggestReviewers(changeId, user1.username + " example", 2);
    assertThat(reviewers).hasSize(1);
    reviewers = suggestReviewers(changeId, user4.email.toLowerCase(), 2);
    assertThat(reviewers).hasSize(1);
    assertThat(reviewers.get(0).account.email).isEqualTo(user4.email);
}
#method_after
@Test
public void suggestReviewersFullTextSearch() throws Exception {
    String changeId = createChange().getChangeId();
    List<SuggestedReviewerInfo> reviewers;
    reviewers = suggestReviewers(changeId, "first", 4);
    assertThat(reviewers).hasSize(3);
    reviewers = suggestReviewers(changeId, "first1", 2);
    assertThat(reviewers).hasSize(1);
    reviewers = suggestReviewers(changeId, "last", 4);
    assertThat(reviewers).hasSize(3);
    reviewers = suggestReviewers(changeId, "last1", 2);
    assertThat(reviewers).hasSize(1);
    reviewers = suggestReviewers(changeId, "fi la", 4);
    assertThat(reviewers).hasSize(3);
    reviewers = suggestReviewers(changeId, "la fi", 4);
    assertThat(reviewers).hasSize(3);
    reviewers = suggestReviewers(changeId, "first1 la", 2);
    assertThat(reviewers).hasSize(1);
    reviewers = suggestReviewers(changeId, "fi last1", 2);
    assertThat(reviewers).hasSize(1);
    reviewers = suggestReviewers(changeId, "first1 last2", 1);
    assertThat(reviewers).hasSize(0);
    reviewers = suggestReviewers(changeId, name("user"), 7);
    assertThat(reviewers).hasSize(6);
    reviewers = suggestReviewers(changeId, user1.username, 2);
    assertThat(reviewers).hasSize(1);
    reviewers = suggestReviewers(changeId, "example.com", 7);
    assertThat(reviewers).hasSize(5);
    reviewers = suggestReviewers(changeId, user1.email, 2);
    assertThat(reviewers).hasSize(1);
    reviewers = suggestReviewers(changeId, user1.username + " example", 2);
    assertThat(reviewers).hasSize(1);
    reviewers = suggestReviewers(changeId, user4.email.toLowerCase(), 2);
    assertThat(reviewers).hasSize(1);
    assertThat(reviewers.get(0).account.email).isEqualTo(user4.email);
}
#end_block

#method_before
@Test
public void defaultReviewerSuggestion() throws Exception {
    String prefix = "defaultReviewerSuggestion-";
    TestAccount user1 = accounts.create(prefix + "user1", prefix + "user1@example.com", "User1", null);
    TestAccount reviewer1 = accounts.create(prefix + "user2", prefix + "user2@example.com", "User2", null);
    TestAccount reviewer2 = accounts.create(prefix + "user3", prefix + "user3@example.com", "User3", null);
    setApiUser(user1);
    String changeId1 = createChangeFromAPI();
    addReviewer(changeId1, reviewer1.email);
    String changeId2 = createChangeFromAPI();
    addReviewer(changeId2, reviewer1.email);
    addReviewer(changeId2, reviewer2.email);
    List<SuggestedReviewerInfo> reviewers = suggestReviewers(createChangeFromAPI(), "", 4);
    assertThat(reviewers.stream().map(r -> r.account._accountId).collect(Collectors.toList())).containsExactly(reviewer1.id.get(), reviewer2.id.get()).inOrder();
}
#method_after
@Test
public void defaultReviewerSuggestion() throws Exception {
    TestAccount user1 = user("customuser1", "User1");
    TestAccount reviewer1 = user("customuser2", "User2");
    TestAccount reviewer2 = user("customuser3", "User3");
    setApiUser(user1);
    String changeId1 = createChangeFromApi();
    setApiUser(reviewer1);
    reviewChange(changeId1);
    setApiUser(user1);
    String changeId2 = createChangeFromApi();
    setApiUser(reviewer1);
    reviewChange(changeId2);
    setApiUser(reviewer2);
    reviewChange(changeId2);
    setApiUser(user1);
    List<SuggestedReviewerInfo> reviewers = suggestReviewers(createChangeFromApi(), null, 4);
    assertThat(reviewers.stream().map(r -> r.account._accountId).collect(Collectors.toList())).containsExactly(reviewer1.id.get(), reviewer2.id.get()).inOrder();
}
#end_block

#method_before
@Test
public void defaultReviewerSuggestionOnFirstChange() throws Exception {
    String prefix = "defaultReviewerSuggestionOnFChange-";
    TestAccount user1 = accounts.create(prefix + "user1", prefix + "user1@example.com", "User1", null);
    setApiUser(user1);
    List<SuggestedReviewerInfo> reviewers = suggestReviewers(createChange().getChangeId(), "", 4);
    assertThat(reviewers).isEmpty();
}
#method_after
@Test
public void defaultReviewerSuggestionOnFirstChange() throws Exception {
    TestAccount user1 = user("customuser1", "User1");
    setApiUser(user1);
    List<SuggestedReviewerInfo> reviewers = suggestReviewers(createChange().getChangeId(), "", 4);
    assertThat(reviewers).isEmpty();
}
#end_block

#method_before
@Test
@GerritConfig(name = "suggest.maxSuggestedReviewers", value = "10")
public void reviewerRanking() throws Exception {
    // Assert that user are ranked by the number of times they have reviewed a
    // change (highest), added comments (medium) or owned a change (low).
    String prefix = "reviewerRanking-";
    TestAccount userWhoOwns = accounts.create(prefix + "user1", prefix + "user1@example.com", "Primum1 Finalis1", null);
    TestAccount reviewer1 = accounts.create(prefix + "user2", prefix + "user2@example.com", "Primum2 Finalis2", null);
    TestAccount reviewer2 = accounts.create(prefix + "user3", prefix + "user3@example.com", "Primum3 Finalis3", null);
    TestAccount userWhoComments = accounts.create(prefix + "user4", prefix + "user4@example.com", "Primum4 Finalis4", null);
    TestAccount userWhoLooksForSuggestions = accounts.create(prefix + "user5", prefix + "user5@example.com", "Primum5 Finalis5", null);
    // Create a changee as userWhoOwns and add some reviewers
    setApiUser(userWhoOwns);
    String changeId1 = createChangeFromAPI();
    addReviewer(changeId1, reviewer1.email);
    setApiUser(user1);
    String changeId2 = createChangeFromAPI();
    addReviewer(changeId2, reviewer1.email);
    addReviewer(changeId2, reviewer2.email);
    // Create a comment as a different user
    setApiUser(userWhoComments);
    ReviewInput ri = new ReviewInput();
    ri.message = "Test";
    gApi.changes().id(changeId1).revision(1).review(ri);
    // Create a change as a new user to assert that we receive the correct
    // ranking
    setApiUser(userWhoLooksForSuggestions);
    List<SuggestedReviewerInfo> reviewers = suggestReviewers(createChangeFromAPI(), "Primum", 4);
    assertThat(reviewers.stream().map(r -> r.account._accountId).collect(Collectors.toList())).containsExactly(reviewer1.id.get(), reviewer2.id.get(), userWhoOwns.id.get(), userWhoComments.id.get()).inOrder();
}
#method_after
@Test
@GerritConfig(name = "suggest.maxSuggestedReviewers", value = "10")
public void reviewerRanking() throws Exception {
    // Assert that user are ranked by the number of times they have applied a
    // a label to a change (highest), added comments (medium) or owned a
    // change (low).
    String fullName = "Primum Finalis";
    TestAccount userWhoOwns = user("customuser1", fullName);
    TestAccount reviewer1 = user("customuser2", fullName);
    TestAccount reviewer2 = user("customuser3", fullName);
    TestAccount userWhoComments = user("customuser4", fullName);
    TestAccount userWhoLooksForSuggestions = user("customuser5", fullName);
    // Create a change as userWhoOwns and add some reviews
    setApiUser(userWhoOwns);
    String changeId1 = createChangeFromApi();
    setApiUser(reviewer1);
    reviewChange(changeId1);
    setApiUser(user1);
    String changeId2 = createChangeFromApi();
    setApiUser(reviewer1);
    reviewChange(changeId2);
    setApiUser(reviewer2);
    reviewChange(changeId2);
    // Create a comment as a different user
    setApiUser(userWhoComments);
    ReviewInput ri = new ReviewInput();
    ri.message = "Test";
    gApi.changes().id(changeId1).revision(1).review(ri);
    // Create a change as a new user to assert that we receive the correct
    // ranking
    setApiUser(userWhoLooksForSuggestions);
    List<SuggestedReviewerInfo> reviewers = suggestReviewers(createChangeFromApi(), "Pri", 4);
    assertThat(reviewers.stream().map(r -> r.account._accountId).collect(Collectors.toList())).containsExactly(reviewer1.id.get(), reviewer2.id.get(), userWhoOwns.id.get(), userWhoComments.id.get()).inOrder();
}
#end_block

#method_before
@Test
public void reviewerRankingProjectIsolation() throws Exception {
    // Create new project
    Project.NameKey newProject = createProject("test");
    // Create users who review changes in both the default and the new project
    String prefix = "reviewerRankingProjectIsolation-";
    TestAccount user1 = accounts.create(prefix + "user1", prefix + "user1@example.com", "Primum1 Finalis1", null);
    TestAccount reviewer1 = accounts.create(prefix + "user2", prefix + "user2@example.com", "Primum2 Finalis2", null);
    TestAccount reviewer2 = accounts.create(prefix + "user3", prefix + "user3@example.com", "Primum3 Finalis3", null);
    setApiUser(user1);
    String changeId1 = createChangeFromAPI();
    addReviewer(changeId1, reviewer1.email);
    String changeId2 = createChangeFromAPI(newProject);
    addReviewer(changeId2, reviewer2.email);
    String changeId3 = createChangeFromAPI(newProject);
    addReviewer(changeId3, reviewer2.email);
    List<SuggestedReviewerInfo> reviewers = suggestReviewers(createChangeFromAPI(), "Prim", 4);
    // Assert that reviewer1 is on top, even though reviewer2 has more reviews
    // in other projects
    assertThat(reviewers.stream().map(r -> r.account._accountId).collect(Collectors.toList())).containsExactly(reviewer1.id.get(), reviewer2.id.get()).inOrder();
}
#method_after
@Test
public void reviewerRankingProjectIsolation() throws Exception {
    // Create new project
    Project.NameKey newProject = createProject("test");
    // Create users who review changes in both the default and the new project
    String fullName = "Primum Finalis";
    TestAccount userWhoOwns = user("customuser1", fullName);
    TestAccount reviewer1 = user("customuser2", fullName);
    TestAccount reviewer2 = user("customuser3", fullName);
    setApiUser(userWhoOwns);
    String changeId1 = createChangeFromApi();
    setApiUser(reviewer1);
    reviewChange(changeId1);
    setApiUser(userWhoOwns);
    String changeId2 = createChangeFromApi(newProject);
    setApiUser(reviewer2);
    reviewChange(changeId2);
    setApiUser(userWhoOwns);
    String changeId3 = createChangeFromApi(newProject);
    setApiUser(reviewer2);
    reviewChange(changeId3);
    setApiUser(userWhoOwns);
    List<SuggestedReviewerInfo> reviewers = suggestReviewers(createChangeFromApi(), "Prim", 4);
    // Assert that reviewer1 is on top, even though reviewer2 has more reviews
    // in other projects
    assertThat(reviewers.stream().map(r -> r.account._accountId).collect(Collectors.toList())).containsExactly(reviewer1.id.get(), reviewer2.id.get()).inOrder();
}
#end_block

#method_before
private TestAccount user(String name, String fullName, String emailName, AccountGroup... groups) throws Exception {
    String[] groupNames = FluentIterable.from(Arrays.asList(groups)).transform(new Function<AccountGroup, String>() {

        @Override
        public String apply(AccountGroup in) {
            return in.getName();
        }
    }).toArray(String.class);
    return accounts.create(name(name), name(emailName) + "@example.com", fullName, groupNames);
}
#method_after
private TestAccount user(String name, String fullName, String emailName, AccountGroup... groups) throws Exception {
    String[] groupNames = Arrays.stream(groups).map(AccountGroup::getName).toArray(String[]::new);
    return accounts.create(name(name), name(emailName) + "@example.com", fullName, groupNames);
}
#end_block

#method_before
void onOpenForm() {
    UIObject.setVisible(form, true);
    UIObject.setVisible(error, false);
    addReviewerIcon.setVisible(false);
    suggestBox.setFocus(true);
}
#method_after
void onOpenForm() {
    UIObject.setVisible(form, true);
    UIObject.setVisible(error, false);
    addReviewerIcon.setVisible(false);
    suggestBox.setServeSuggestionsOnOracle(true);
    suggestBox.setFocus(true);
}
#end_block

#method_before
@UiHandler("cancel")
void onCancel(@SuppressWarnings("unused") ClickEvent e) {
    addReviewerIcon.setVisible(true);
    UIObject.setVisible(form, false);
    suggestBox.setFocus(false);
    suggestBox.setText("");
}
#method_after
@UiHandler("cancel")
void onCancel(@SuppressWarnings("unused") ClickEvent e) {
    addReviewerIcon.setVisible(true);
    UIObject.setVisible(form, false);
    suggestBox.setFocus(false);
    suggestBox.setText("");
    suggestBox.setServeSuggestionsOnOracle(false);
}
#end_block

#method_before
private void updateReviewerList() {
    ChangeApi.detail(changeId.get(), new GerritCallback<ChangeInfo>() {

        @Override
        public void onSuccess(ChangeInfo result) {
            display(result);
        }
    });
}
#method_after
void updateReviewerList() {
    ChangeApi.detail(changeId.get(), new GerritCallback<ChangeInfo>() {

        @Override
        public void onSuccess(ChangeInfo result) {
            display(result);
        }
    });
}
#end_block

#method_before
@Override
public List<SuggestedReviewerInfo> apply(ChangeResource rsrc) throws BadRequestException, OrmException, IOException {
    return reviewersUtil.suggestReviewers(rsrc.getNotes(), this, rsrc.getControl().getProjectControl(), getVisibility(rsrc));
}
#method_after
@Override
public List<SuggestedReviewerInfo> apply(ChangeResource rsrc) throws BadRequestException, OrmException, IOException {
    return reviewersUtil.suggestReviewers(rsrc.getNotes(), this, rsrc.getControl().getProjectControl(), getVisibility(rsrc), excludeGroups);
}
#end_block

#method_before
@Override
public final void requestSuggestions(final Request request, final Callback cb) {
    onRequestSuggestions(request, new Callback() {

        @Override
        public void onSuggestionsReady(final Request request, final Response response) {
            final String qpat = getQueryPattern(request.getQuery());
            final boolean html = isHTML();
            final ArrayList<Suggestion> r = new ArrayList<>();
            for (final Suggestion s : response.getSuggestions()) {
                r.add(new BoldSuggestion(qpat, s, html));
            }
            cb.onSuggestionsReady(request, new Response(r));
        }
    });
}
#method_after
@Override
public final void requestSuggestions(Request request, Callback cb) {
    onRequestSuggestions(request, new Callback() {

        @Override
        public void onSuggestionsReady(final Request request, final Response response) {
            final String qpat = getQueryPattern(request.getQuery());
            final boolean html = isHTML();
            final ArrayList<Suggestion> r = new ArrayList<>();
            for (final Suggestion s : response.getSuggestions()) {
                r.add(new BoldSuggestion(qpat, s, html));
            }
            cb.onSuggestionsReady(request, new Response(r));
        }
    });
}
#end_block

#method_before
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    bind(BlameCache.class).to(BlameCacheImpl.class);
    bind(Sequences.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(ChangeKindCacheImpl.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(MergeabilityCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(SubmitStrategy.module());
    install(TagCache.module());
    install(OAuthTokenCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new GitModule());
    install(new GroupModule());
    install(new NoteDbModule(cfg));
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(DeleteReviewerSender.Factory.class);
    factory(AddKeySender.Factory.class);
    factory(BatchUpdate.Factory.class);
    factory(CapabilityCollection.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeData.Factory.class);
    factory(ChangeJson.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupInfoCache.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(EmailMerge.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    factory(ProjectOwnerGroupsProvider.Factory.class);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(GcConfig.class);
    bind(ChangeCleanupConfig.class);
    bind(ApprovalsUtil.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class);
    bind(SoyTofu.class).annotatedWith(MailTemplates.class).toProvider(MailSoyTofuProvider.class);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(Boolean.class).annotatedWith(DisableReverseDnsLookup.class).toProvider(DisableReverseDnsLookupProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), ChangeAbandonedListener.class);
    DynamicSet.setOf(binder(), CommentAddedListener.class);
    DynamicSet.setOf(binder(), DraftPublishedListener.class);
    DynamicSet.setOf(binder(), HashtagsEditedListener.class);
    DynamicSet.setOf(binder(), ChangeMergedListener.class);
    DynamicSet.setOf(binder(), ChangeRestoredListener.class);
    DynamicSet.setOf(binder(), ChangeRevertedListener.class);
    DynamicSet.setOf(binder(), ReviewerAddedListener.class);
    DynamicSet.setOf(binder(), ReviewerDeletedListener.class);
    DynamicSet.setOf(binder(), VoteDeletedListener.class);
    DynamicSet.setOf(binder(), RevisionCreatedListener.class);
    DynamicSet.setOf(binder(), TopicEditedListener.class);
    DynamicSet.setOf(binder(), AgreementSignupListener.class);
    DynamicSet.setOf(binder(), PluginEventListener.class);
    DynamicSet.setOf(binder(), ReceivePackInitializer.class);
    DynamicSet.setOf(binder(), PostReceiveHook.class);
    DynamicSet.setOf(binder(), PreUploadHook.class);
    DynamicSet.setOf(binder(), PostUploadHook.class);
    DynamicSet.setOf(binder(), ChangeIndexedListener.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), GarbageCollectorListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.setOf(binder(), UsageDataPublishedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ReindexAfterUpdate.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ProjectConfigEntry.UpdateChecker.class);
    DynamicSet.setOf(binder(), EventListener.class);
    DynamicSet.bind(binder(), EventListener.class).to(EventsMetrics.class);
    DynamicSet.setOf(binder(), UserScopedEventListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), ReviewerSuggestion.class);
    DynamicSet.setOf(binder(), RefOperationValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicSet.setOf(binder(), ProjectCreationValidationListener.class);
    DynamicSet.setOf(binder(), GroupCreationValidationListener.class);
    DynamicSet.setOf(binder(), HashtagValidationListener.class);
    DynamicSet.setOf(binder(), OutgoingEmailValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), CloneCommand.class);
    DynamicSet.setOf(binder(), ExternalIncludedIn.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    DynamicSet.setOf(binder(), PatchSetWebLink.class);
    DynamicSet.setOf(binder(), FileWebLink.class);
    DynamicSet.setOf(binder(), FileHistoryWebLink.class);
    DynamicSet.setOf(binder(), DiffWebLink.class);
    DynamicSet.setOf(binder(), ProjectWebLink.class);
    DynamicSet.setOf(binder(), BranchWebLink.class);
    DynamicMap.mapOf(binder(), OAuthLoginProvider.class);
    DynamicItem.itemOf(binder(), OAuthTokenEncrypter.class);
    DynamicSet.setOf(binder(), AccountExternalIdCreator.class);
    DynamicSet.setOf(binder(), WebUiPlugin.class);
    DynamicItem.itemOf(binder(), AccountPatchReviewStore.class);
    factory(UploadValidators.Factory.class);
    DynamicSet.setOf(binder(), UploadValidationListener.class);
    DynamicMap.mapOf(binder(), ChangeQueryBuilder.ChangeOperatorFactory.class);
    install(new GitwebConfig.LegacyModule(cfg));
    bind(AnonymousUser.class);
    factory(RefOperationValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    factory(ReplaceOp.Factory.class);
    factory(MergedByPushOp.Factory.class);
    factory(GitModules.Factory.class);
    factory(VersionedAuthorizedKeys.Factory.class);
    factory(SubmoduleOp.Factory.class);
    bind(AccountManager.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#method_after
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    bind(BlameCache.class).to(BlameCacheImpl.class);
    bind(Sequences.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(ChangeKindCacheImpl.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(MergeabilityCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(SubmitStrategy.module());
    install(TagCache.module());
    install(OAuthTokenCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new GitModule());
    install(new GroupModule());
    install(new NoteDbModule(cfg));
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(DeleteReviewerSender.Factory.class);
    factory(AddKeySender.Factory.class);
    factory(BatchUpdate.Factory.class);
    factory(CapabilityCollection.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeData.Factory.class);
    factory(ChangeJson.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupInfoCache.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(EmailMerge.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    factory(ProjectOwnerGroupsProvider.Factory.class);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(GcConfig.class);
    bind(ChangeCleanupConfig.class);
    bind(ApprovalsUtil.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class);
    bind(SoyTofu.class).annotatedWith(MailTemplates.class).toProvider(MailSoyTofuProvider.class);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(Boolean.class).annotatedWith(DisableReverseDnsLookup.class).toProvider(DisableReverseDnsLookupProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), AssigneeChangedListener.class);
    DynamicSet.setOf(binder(), ChangeAbandonedListener.class);
    DynamicSet.setOf(binder(), CommentAddedListener.class);
    DynamicSet.setOf(binder(), DraftPublishedListener.class);
    DynamicSet.setOf(binder(), HashtagsEditedListener.class);
    DynamicSet.setOf(binder(), ChangeMergedListener.class);
    DynamicSet.setOf(binder(), ChangeRestoredListener.class);
    DynamicSet.setOf(binder(), ChangeRevertedListener.class);
    DynamicSet.setOf(binder(), ReviewerAddedListener.class);
    DynamicSet.setOf(binder(), ReviewerDeletedListener.class);
    DynamicSet.setOf(binder(), VoteDeletedListener.class);
    DynamicSet.setOf(binder(), RevisionCreatedListener.class);
    DynamicSet.setOf(binder(), TopicEditedListener.class);
    DynamicSet.setOf(binder(), AgreementSignupListener.class);
    DynamicSet.setOf(binder(), PluginEventListener.class);
    DynamicSet.setOf(binder(), ReceivePackInitializer.class);
    DynamicSet.setOf(binder(), PostReceiveHook.class);
    DynamicSet.setOf(binder(), PreUploadHook.class);
    DynamicSet.setOf(binder(), PostUploadHook.class);
    DynamicSet.setOf(binder(), ChangeIndexedListener.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), GarbageCollectorListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.setOf(binder(), UsageDataPublishedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ReindexAfterUpdate.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ProjectConfigEntry.UpdateChecker.class);
    DynamicSet.setOf(binder(), EventListener.class);
    DynamicSet.bind(binder(), EventListener.class).to(EventsMetrics.class);
    DynamicSet.setOf(binder(), UserScopedEventListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), RefOperationValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicSet.setOf(binder(), ProjectCreationValidationListener.class);
    DynamicSet.setOf(binder(), GroupCreationValidationListener.class);
    DynamicSet.setOf(binder(), HashtagValidationListener.class);
    DynamicSet.setOf(binder(), OutgoingEmailValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), CloneCommand.class);
    DynamicMap.mapOf(binder(), ReviewerSuggestion.class);
    DynamicSet.setOf(binder(), ExternalIncludedIn.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    DynamicSet.setOf(binder(), PatchSetWebLink.class);
    DynamicSet.setOf(binder(), FileWebLink.class);
    DynamicSet.setOf(binder(), FileHistoryWebLink.class);
    DynamicSet.setOf(binder(), DiffWebLink.class);
    DynamicSet.setOf(binder(), ProjectWebLink.class);
    DynamicSet.setOf(binder(), BranchWebLink.class);
    DynamicMap.mapOf(binder(), OAuthLoginProvider.class);
    DynamicItem.itemOf(binder(), OAuthTokenEncrypter.class);
    DynamicSet.setOf(binder(), AccountExternalIdCreator.class);
    DynamicSet.setOf(binder(), WebUiPlugin.class);
    DynamicItem.itemOf(binder(), AccountPatchReviewStore.class);
    DynamicSet.setOf(binder(), AssigneeValidationListener.class);
    factory(UploadValidators.Factory.class);
    DynamicSet.setOf(binder(), UploadValidationListener.class);
    DynamicMap.mapOf(binder(), ChangeQueryBuilder.ChangeOperatorFactory.class);
    install(new GitwebConfig.LegacyModule(cfg));
    bind(AnonymousUser.class);
    factory(RefOperationValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    factory(ReplaceOp.Factory.class);
    factory(MergedByPushOp.Factory.class);
    factory(GitModules.Factory.class);
    factory(VersionedAuthorizedKeys.Factory.class);
    factory(SubmoduleOp.Factory.class);
    bind(AccountManager.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#end_block

#method_before
private void appendComment(StringBuilder out, int contextLines, PatchFile currentFileData, Comment comment) {
    if (comment instanceof RobotComment) {
        RobotComment robotComment = (RobotComment) comment;
        out.append("Robot Comment from ").append(robotComment.robotId).append(" (run ID ").append(robotComment.robotRunId).append("):\n");
    }
    short side = comment.side;
    Comment.Range range = comment.range;
    if (range != null) {
        String prefix = "PS" + comment.key.patchSetId + ", Line " + range.startLine + ": ";
        for (int n = range.startLine; n <= range.endLine; n++) {
            out.append(n == range.startLine ? prefix : Strings.padStart(": ", prefix.length(), ' '));
            String s = getLine(currentFileData, side, n);
            if (n == range.startLine && n == range.endLine) {
                s = s.substring(Math.min(range.startChar, s.length()), Math.min(range.endChar, s.length()));
            } else if (n == range.startLine) {
                s = s.substring(Math.min(range.startChar, s.length()));
            } else if (n == range.endLine) {
                s = s.substring(0, Math.min(range.endChar, s.length()));
            }
            out.append(s).append('\n');
        }
        appendQuotedParent(out, comment);
        out.append(comment.message.trim()).append('\n');
    } else {
        int lineNbr = comment.lineNbr;
        // Initialize maxLines to the known line number.
        int maxLines = lineNbr;
        if (side == 1 || side == 2) {
            try {
                maxLines = currentFileData.getLineCount(side);
            } catch (IOException exc) {
            // The file could not be read, leave the max as is.
            } catch (NoSuchEntityException exc) {
                // Should never be reached.
                throw new AssertionError(exc);
            }
        }
        final int startLine = Math.max(1, lineNbr - contextLines + 1);
        final int stopLine = Math.min(maxLines, lineNbr + contextLines);
        for (int line = startLine; line <= lineNbr; ++line) {
            appendFileLine(out, currentFileData, side, line);
        }
        appendQuotedParent(out, comment);
        out.append(comment.message.trim()).append('\n');
        for (int line = lineNbr + 1; line < stopLine; ++line) {
            appendFileLine(out, currentFileData, side, line);
        }
    }
}
#method_after
private void appendComment(StringBuilder out, int contextLines, PatchFile currentFileData, Comment comment) {
    if (comment instanceof RobotComment) {
        RobotComment robotComment = (RobotComment) comment;
        out.append("Robot Comment from ").append(robotComment.robotId).append(" (run ID ").append(robotComment.robotRunId).append("):\n");
    }
    short side = comment.side;
    Comment.Range range = comment.range;
    if (range != null) {
        String prefix = "PS" + comment.key.patchSetId + ", Line " + range.startLine + ": ";
        for (int n = range.startLine; n <= range.endLine; n++) {
            out.append(n == range.startLine ? prefix : Strings.padStart(": ", prefix.length(), ' '));
            String s = getLine(currentFileData, side, n);
            if (n == range.startLine && n == range.endLine) {
                s = s.substring(Math.min(range.startChar, s.length()), Math.min(range.endChar, s.length()));
            } else if (n == range.startLine) {
                s = s.substring(Math.min(range.startChar, s.length()));
            } else if (n == range.endLine) {
                s = s.substring(0, Math.min(range.endChar, s.length()));
            }
            out.append(s).append('\n');
        }
        appendQuotedParent(out, comment);
        out.append(comment.message.trim()).append('\n');
    } else {
        int lineNbr = comment.lineNbr;
        // Initialize maxLines to the known line number.
        int maxLines = lineNbr;
        try {
            maxLines = currentFileData.getLineCount(side);
        } catch (IOException err) {
            // The file could not be read, leave the max as is.
            log.warn(String.format("Failed to read file %s on side %d", comment.key.filename, side), err);
        } catch (NoSuchEntityException err) {
            // The file could not be read, leave the max as is.
            log.warn(String.format("Side %d of file %s didn't exist", side, comment.key.filename), err);
        }
        final int startLine = Math.max(1, lineNbr - contextLines + 1);
        final int stopLine = Math.min(maxLines, lineNbr + contextLines);
        for (int line = startLine; line <= lineNbr; ++line) {
            appendFileLine(out, currentFileData, side, line);
        }
        appendQuotedParent(out, comment);
        out.append(comment.message.trim()).append('\n');
        for (int line = lineNbr + 1; line < stopLine; ++line) {
            appendFileLine(out, currentFileData, side, line);
        }
    }
}
#end_block

#method_before
private void appendFileLine(StringBuilder cmts, PatchFile fileData, short side, int line) {
    String lineStr = getLine(fileData, side, line);
    cmts.append("Line " + line + ": " + lineStr + "\n");
}
#method_after
private void appendFileLine(StringBuilder cmts, PatchFile fileData, short side, int line) {
    String lineStr = getLine(fileData, side, line);
    cmts.append("Line ").append(line).append(": ").append(lineStr).append("\n");
}
#end_block

#method_before
private String getLine(PatchFile fileInfo, short side, int lineNbr) {
    if (side != 0 && side != 1) {
        throw new IllegalArgumentException("side should be 0 or 1, was " + side);
    }
    try {
        return fileInfo.getLine(side, lineNbr);
    } catch (IOException exc) {
        // Default to the empty string if the file cannot be safely read.
        return "";
    } catch (IndexOutOfBoundsException exc) {
        // in the file.
        return "";
    } catch (NoSuchEntityException exc) {
        // Should never be reached.
        throw new AssertionError(exc);
    }
}
#method_after
private String getLine(PatchFile fileInfo, short side, int lineNbr) {
    try {
        return fileInfo.getLine(side, lineNbr);
    } catch (IOException err) {
        // Default to the empty string if the file cannot be safely read.
        log.warn(String.format("Failed to read file on side %d", side), err);
        return "";
    } catch (IndexOutOfBoundsException err) {
        // Default to the empty string if the given line number does not appear
        // in the file.
        log.warn(String.format("Failed to get line number of file on side %d", side), err);
        return "";
    } catch (NoSuchEntityException err) {
        // Default to the empty string if the side cannot be found.
        log.warn(String.format("Side %d of file didn't exist", side), err);
        return "";
    }
}
#end_block

#method_before
@Override
void apply(ChangeUpdate update) throws OrmException {
    checkUpdate(update);
    update.setChangeMessage(message.getMessage());
    setTopic(update);
    setStatus(update);
}
#method_after
@Override
void apply(ChangeUpdate update) throws OrmException {
    checkUpdate(update);
    update.setChangeMessage(message.getMessage());
    setTopic(update);
}
#end_block

#method_before
@Override
protected String getRefName() {
    return RefNames.refsDraftComments(getId(), effectiveAccountId);
}
#method_after
@Override
protected String getRefName() {
    return RefNames.refsDraftComments(getId(), accountId);
}
#end_block

#method_before
private void buildUpdates(NoteDbUpdateManager manager, ChangeBundle bundle) throws IOException, OrmException {
    manager.setCheckExpectedState(false);
    Change change = new Change(bundle.getChange());
    if (bundle.getPatchSets().isEmpty()) {
        throw new NoPatchSetsException(change.getId());
    }
    PatchSet.Id currPsId = change.currentPatchSetId();
    // We will rebuild all events, except for draft comments, in buckets based
    // on author and timestamp.
    List<Event> events = new ArrayList<>();
    Multimap<Account.Id, DraftCommentEvent> draftCommentEvents = ArrayListMultimap.create();
    events.addAll(getHashtagsEvents(change, manager));
    // Delete ref only after hashtags have been read
    deleteChangeMetaRef(change, manager.getChangeRepo().cmds);
    deleteDraftRefs(change, manager.getAllUsersRepo());
    Integer minPsNum = getMinPatchSetNum(bundle);
    Map<PatchSet.Id, PatchSetEvent> patchSetEvents = Maps.newHashMapWithExpectedSize(bundle.getPatchSets().size());
    for (PatchSet ps : bundle.getPatchSets()) {
        if (ps.getId().get() > currPsId.get()) {
            log.info("Skipping patch set {}, which is higher than current patch set {}", ps.getId(), currPsId);
            continue;
        }
        PatchSetEvent pse = new PatchSetEvent(change, ps, manager.getChangeRepo().rw);
        patchSetEvents.put(ps.getId(), pse);
        events.add(pse);
        for (Comment c : getComments(bundle, serverId, Status.PUBLISHED, ps)) {
            CommentEvent e = new CommentEvent(c, change, ps, patchListCache);
            events.add(e.addDep(pse));
        }
        for (Comment c : getComments(bundle, serverId, Status.DRAFT, ps)) {
            DraftCommentEvent e = new DraftCommentEvent(c, change, ps, patchListCache);
            draftCommentEvents.put(c.author.getId(), e);
        }
    }
    for (PatchSetApproval psa : bundle.getPatchSetApprovals()) {
        PatchSetEvent pse = patchSetEvents.get(psa.getPatchSetId());
        if (pse != null) {
            events.add(new ApprovalEvent(psa, change.getCreatedOn()).addDep(pse));
        }
    }
    for (Table.Cell<ReviewerStateInternal, Account.Id, Timestamp> r : bundle.getReviewers().asTable().cellSet()) {
        events.add(new ReviewerEvent(r, change.getCreatedOn()));
    }
    Change noteDbChange = new Change(null, null, null, null, null);
    for (ChangeMessage msg : bundle.getChangeMessages()) {
        if (msg.getPatchSetId() == null) {
            // No dependency necessary; will get assigned to most recent patch set
            // in sortAndFillEvents.
            events.add(new ChangeMessageEvent(msg, noteDbChange, change.getCreatedOn()));
            continue;
        }
        PatchSetEvent pse = patchSetEvents.get(msg.getPatchSetId());
        if (pse != null) {
            events.add(new ChangeMessageEvent(msg, noteDbChange, change.getCreatedOn()).addDep(pse));
        }
    }
    sortAndFillEvents(change, noteDbChange, events, minPsNum);
    EventList<Event> el = new EventList<>();
    for (Event e : events) {
        if (!el.canAdd(e)) {
            flushEventsToUpdate(manager, el, change);
            checkState(el.canAdd(e));
        }
        el.add(e);
    }
    flushEventsToUpdate(manager, el, change);
    EventList<DraftCommentEvent> plcel = new EventList<>();
    for (Account.Id author : draftCommentEvents.keys()) {
        for (DraftCommentEvent e : Ordering.natural().sortedCopy(draftCommentEvents.get(author))) {
            if (!plcel.canAdd(e)) {
                flushEventsToDraftUpdate(manager, plcel, change);
                checkState(plcel.canAdd(e));
            }
            plcel.add(e);
        }
        flushEventsToDraftUpdate(manager, plcel, change);
    }
}
#method_after
private void buildUpdates(NoteDbUpdateManager manager, ChangeBundle bundle) throws IOException, OrmException {
    manager.setCheckExpectedState(false);
    Change change = new Change(bundle.getChange());
    if (bundle.getPatchSets().isEmpty()) {
        throw new NoPatchSetsException(change.getId());
    }
    PatchSet.Id currPsId = change.currentPatchSetId();
    // We will rebuild all events, except for draft comments, in buckets based
    // on author and timestamp.
    List<Event> events = new ArrayList<>();
    Multimap<Account.Id, DraftCommentEvent> draftCommentEvents = ArrayListMultimap.create();
    events.addAll(getHashtagsEvents(change, manager));
    // Delete ref only after hashtags have been read
    deleteChangeMetaRef(change, manager.getChangeRepo().cmds);
    deleteDraftRefs(change, manager.getAllUsersRepo());
    Integer minPsNum = getMinPatchSetNum(bundle);
    Map<PatchSet.Id, PatchSetEvent> patchSetEvents = Maps.newHashMapWithExpectedSize(bundle.getPatchSets().size());
    for (PatchSet ps : bundle.getPatchSets()) {
        if (ps.getId().get() > currPsId.get()) {
            log.info("Skipping patch set {}, which is higher than current patch set {}", ps.getId(), currPsId);
            continue;
        }
        PatchSetEvent pse = new PatchSetEvent(change, ps, manager.getChangeRepo().rw);
        patchSetEvents.put(ps.getId(), pse);
        events.add(pse);
        for (Comment c : getComments(bundle, serverId, Status.PUBLISHED, ps)) {
            CommentEvent e = new CommentEvent(c, change, ps, patchListCache);
            events.add(e.addDep(pse));
        }
        for (Comment c : getComments(bundle, serverId, Status.DRAFT, ps)) {
            DraftCommentEvent e = new DraftCommentEvent(c, change, ps, patchListCache);
            draftCommentEvents.put(c.author.getId(), e);
        }
    }
    for (PatchSetApproval psa : bundle.getPatchSetApprovals()) {
        PatchSetEvent pse = patchSetEvents.get(psa.getPatchSetId());
        if (pse != null) {
            events.add(new ApprovalEvent(psa, change.getCreatedOn()).addDep(pse));
        }
    }
    for (Table.Cell<ReviewerStateInternal, Account.Id, Timestamp> r : bundle.getReviewers().asTable().cellSet()) {
        events.add(new ReviewerEvent(r, change.getCreatedOn()));
    }
    Change noteDbChange = new Change(null, null, null, null, null);
    for (ChangeMessage msg : bundle.getChangeMessages()) {
        List<Event> msgEvents = parseChangeMessage(msg, change, noteDbChange);
        if (msg.getPatchSetId() != null) {
            PatchSetEvent pse = patchSetEvents.get(msg.getPatchSetId());
            if (pse != null) {
                for (Event e : msgEvents) {
                    e.addDep(pse);
                }
            }
        }
        events.addAll(msgEvents);
    }
    sortAndFillEvents(change, noteDbChange, events, minPsNum);
    EventList<Event> el = new EventList<>();
    for (Event e : events) {
        if (!el.canAdd(e)) {
            flushEventsToUpdate(manager, el, change);
            checkState(el.canAdd(e));
        }
        el.add(e);
    }
    flushEventsToUpdate(manager, el, change);
    EventList<DraftCommentEvent> plcel = new EventList<>();
    for (Account.Id author : draftCommentEvents.keys()) {
        for (DraftCommentEvent e : Ordering.natural().sortedCopy(draftCommentEvents.get(author))) {
            if (!plcel.canAdd(e)) {
                flushEventsToDraftUpdate(manager, plcel, change);
                checkState(plcel.canAdd(e));
            }
            plcel.add(e);
        }
        flushEventsToDraftUpdate(manager, plcel, change);
    }
}
#end_block

#method_before
private void sortAndFillEvents(Change change, Change noteDbChange, List<Event> events, Integer minPsNum) {
    new EventSorter(events).sort();
    events.add(new FinalUpdatesEvent(change, noteDbChange));
    // Ensure the first event in the list creates the change, setting the author
    // and any required footers.
    Event first = events.get(0);
    if (first instanceof PatchSetEvent && change.getOwner().equals(first.effectiveUser)) {
        ((PatchSetEvent) first).createChange = true;
    } else {
        events.add(0, new CreateChangeEvent(change, minPsNum));
    }
    // Final pass to correct some inconsistencies.
    // 
    // First, fill in any missing patch set IDs using the latest patch set of
    // the change at the time of the event, because NoteDb can't represent
    // actions with no associated patch set ID. This workaround is as if a user
    // added a ChangeMessage on the change by replying from the latest patch
    // set.
    // 
    // Start with the first patch set that actually exists. If there are no
    // patch sets at all, minPsNum will be null, so just bail and use 1 as the
    // patch set ID. The corresponding patch set won't exist, but this change is
    // probably corrupt anyway, as deleting the last draft patch set should have
    // deleted the whole change.
    // 
    // Second, ensure timestamps are nondecreasing, by copying the previous
    // timestamp if this happens. This assumes that the only way this can happen
    // is due to dependency constraints, and it is ok to give an event the same
    // timestamp as one of its dependencies.
    int ps = firstNonNull(minPsNum, 1);
    for (int i = 0; i < events.size(); i++) {
        Event e = events.get(i);
        if (e.psId == null) {
            e.psId = new PatchSet.Id(change.getId(), ps);
        } else {
            ps = Math.max(ps, e.psId.get());
        }
        if (i > 0) {
            Event p = events.get(i - 1);
            if (e.when.before(p.when)) {
                e.when = p.when;
            }
        }
    }
}
#method_after
private void sortAndFillEvents(Change change, Change noteDbChange, List<Event> events, Integer minPsNum) {
    events.add(new FinalUpdatesEvent(change, noteDbChange));
    new EventSorter(events).sort();
    // Ensure the first event in the list creates the change, setting the author
    // and any required footers.
    Event first = events.get(0);
    if (first instanceof PatchSetEvent && change.getOwner().equals(first.user)) {
        ((PatchSetEvent) first).createChange = true;
    } else {
        events.add(0, new CreateChangeEvent(change, minPsNum));
    }
    // Final pass to correct some inconsistencies.
    // 
    // First, fill in any missing patch set IDs using the latest patch set of
    // the change at the time of the event, because NoteDb can't represent
    // actions with no associated patch set ID. This workaround is as if a user
    // added a ChangeMessage on the change by replying from the latest patch
    // set.
    // 
    // Start with the first patch set that actually exists. If there are no
    // patch sets at all, minPsNum will be null, so just bail and use 1 as the
    // patch set ID. The corresponding patch set won't exist, but this change is
    // probably corrupt anyway, as deleting the last draft patch set should have
    // deleted the whole change.
    // 
    // Second, ensure timestamps are nondecreasing, by copying the previous
    // timestamp if this happens. This assumes that the only way this can happen
    // is due to dependency constraints, and it is ok to give an event the same
    // timestamp as one of its dependencies.
    int ps = firstNonNull(minPsNum, 1);
    for (int i = 0; i < events.size(); i++) {
        Event e = events.get(i);
        if (e.psId == null) {
            e.psId = new PatchSet.Id(change.getId(), ps);
        } else {
            ps = Math.max(ps, e.psId.get());
        }
        if (i > 0) {
            Event p = events.get(i - 1);
            if (e.when.before(p.when)) {
                e.when = p.when;
            }
        }
    }
}
#end_block

#method_before
private void flushEventsToUpdate(NoteDbUpdateManager manager, EventList<Event> events, Change change) throws OrmException, IOException {
    if (events.isEmpty()) {
        return;
    }
    Comparator<String> labelNameComparator;
    if (projectCache != null) {
        labelNameComparator = projectCache.get(change.getProject()).getLabelTypes().nameComparator();
    } else {
        // No project cache available, bail and use natural ordering; there's no
        // semantic difference anyway difference.
        labelNameComparator = Ordering.natural();
    }
    ChangeUpdate update = updateFactory.create(change, events.getAccountId(), newAuthorIdent(events), events.getWhen(), labelNameComparator);
    update.setAllowWriteToNewRef(true);
    update.setPatchSetId(events.getPatchSetId());
    update.setTag(events.getTag());
    for (Event e : events) {
        e.apply(update);
    }
    manager.add(update);
    events.clear();
}
#method_after
private void flushEventsToUpdate(NoteDbUpdateManager manager, EventList<Event> events, Change change) throws OrmException, IOException {
    if (events.isEmpty()) {
        return;
    }
    Comparator<String> labelNameComparator;
    if (projectCache != null) {
        labelNameComparator = projectCache.get(change.getProject()).getLabelTypes().nameComparator();
    } else {
        // No project cache available, bail and use natural ordering; there's no
        // semantic difference anyway difference.
        labelNameComparator = Ordering.natural();
    }
    ChangeUpdate update = updateFactory.create(change, events.getAccountId(), events.getRealAccountId(), newAuthorIdent(events), events.getWhen(), labelNameComparator);
    update.setAllowWriteToNewRef(true);
    update.setPatchSetId(events.getPatchSetId());
    update.setTag(events.getTag());
    for (Event e : events) {
        e.apply(update);
    }
    manager.add(update);
    events.clear();
}
#end_block

#method_before
private void flushEventsToDraftUpdate(NoteDbUpdateManager manager, EventList<DraftCommentEvent> events, Change change) throws OrmException {
    if (events.isEmpty()) {
        return;
    }
    ChangeDraftUpdate update = draftUpdateFactory.create(change, events.getAccountId(), newAuthorIdent(events), events.getWhen());
    update.setPatchSetId(events.getPatchSetId());
    for (DraftCommentEvent e : events) {
        e.applyDraft(update);
    }
    manager.add(update);
    events.clear();
}
#method_after
private void flushEventsToDraftUpdate(NoteDbUpdateManager manager, EventList<DraftCommentEvent> events, Change change) throws OrmException {
    if (events.isEmpty()) {
        return;
    }
    ChangeDraftUpdate update = draftUpdateFactory.create(change, events.getAccountId(), events.getRealAccountId(), newAuthorIdent(events), events.getWhen());
    update.setPatchSetId(events.getPatchSetId());
    for (DraftCommentEvent e : events) {
        e.applyDraft(update);
    }
    manager.add(update);
    events.clear();
}
#end_block

#method_before
public static ChangeMessage newMessage(ReviewDb db, PatchSet.Id psId, CurrentUser user, Timestamp when, String body) throws OrmException {
    checkNotNull(psId);
    Account.Id accountId = user.isInternalUser() ? null : user.getAccountId();
    ChangeMessage m = new ChangeMessage(new ChangeMessage.Key(psId.getParentKey(), ChangeUtil.messageUUID(db)), accountId, when, psId);
    m.setMessage(body);
    if (user.getRealUser().isIdentifiedUser()) {
        m.setRealAuthor(user.getRealUser().getAccountId());
    }
    return m;
}
#method_after
public static ChangeMessage newMessage(ReviewDb db, PatchSet.Id psId, CurrentUser user, Timestamp when, String body) throws OrmException {
    checkNotNull(psId);
    Account.Id accountId = user.isInternalUser() ? null : user.getAccountId();
    ChangeMessage m = new ChangeMessage(new ChangeMessage.Key(psId.getParentKey(), ChangeUtil.messageUUID(db)), accountId, when, psId);
    m.setMessage(body);
    user.updateRealAccountId(m::setRealAuthor);
    return m;
}
#end_block

#method_before
public void putApproval(String label, short value) {
    putApprovalFor(getEffectiveAccountId(), label, value);
}
#method_after
public void putApproval(String label, short value) {
    putApprovalFor(getAccountId(), label, value);
}
#end_block

#method_before
public void removeApproval(String label) {
    removeApprovalFor(getEffectiveAccountId(), label);
}
#method_after
public void removeApproval(String label) {
    removeApprovalFor(getAccountId(), label);
}
#end_block

#method_before
public void putComment(PatchLineComment.Status status, Comment c) {
    checkRealAccount("update comments");
    verifyComment(c);
    createDraftUpdateIfNull();
    if (status == PatchLineComment.Status.DRAFT) {
        draftUpdate.putComment(c);
    } else {
        comments.add(c);
        // Always delete the corresponding comment from drafts. Published comments
        // are immutable, meaning in normal operation we only hit this path when
        // publishing a comment. It's exactly in that case that we have to delete
        // the draft.
        draftUpdate.deleteComment(c);
    }
}
#method_after
public void putComment(PatchLineComment.Status status, Comment c) {
    verifyComment(c);
    createDraftUpdateIfNull();
    if (status == PatchLineComment.Status.DRAFT) {
        draftUpdate.putComment(c);
    } else {
        comments.add(c);
        // Always delete the corresponding comment from drafts. Published comments
        // are immutable, meaning in normal operation we only hit this path when
        // publishing a comment. It's exactly in that case that we have to delete
        // the draft.
        draftUpdate.deleteComment(c);
    }
}
#end_block

#method_before
public void putRobotComment(RobotComment c) {
    checkRealAccount("update robot comments");
    verifyComment(c);
    createRobotCommentUpdateIfNull();
    robotCommentUpdate.putComment(c);
}
#method_after
public void putRobotComment(RobotComment c) {
    verifyComment(c);
    createRobotCommentUpdateIfNull();
    robotCommentUpdate.putComment(c);
}
#end_block

#method_before
public void deleteComment(Comment c) {
    checkRealAccount("update comments");
    verifyComment(c);
    createDraftUpdateIfNull().deleteComment(c);
}
#method_after
public void deleteComment(Comment c) {
    verifyComment(c);
    createDraftUpdateIfNull().deleteComment(c);
}
#end_block

#method_before
@VisibleForTesting
ChangeDraftUpdate createDraftUpdateIfNull() {
    if (draftUpdate == null) {
        checkRealAccount("update drafts");
        ChangeNotes notes = getNotes();
        if (notes != null) {
            draftUpdate = draftUpdateFactory.create(notes, effectiveAccountId, authorIdent, when);
        } else {
            draftUpdate = draftUpdateFactory.create(getChange(), effectiveAccountId, authorIdent, when);
        }
    }
    return draftUpdate;
}
#method_after
@VisibleForTesting
ChangeDraftUpdate createDraftUpdateIfNull() {
    if (draftUpdate == null) {
        ChangeNotes notes = getNotes();
        if (notes != null) {
            draftUpdate = draftUpdateFactory.create(notes, accountId, realAccountId, authorIdent, when);
        } else {
            draftUpdate = draftUpdateFactory.create(getChange(), accountId, realAccountId, authorIdent, when);
        }
    }
    return draftUpdate;
}
#end_block

#method_before
@VisibleForTesting
RobotCommentUpdate createRobotCommentUpdateIfNull() {
    if (robotCommentUpdate == null) {
        checkRealAccount("update robot comments");
        ChangeNotes notes = getNotes();
        if (notes != null) {
            robotCommentUpdate = robotCommentUpdateFactory.create(notes, effectiveAccountId, authorIdent, when);
        } else {
            robotCommentUpdate = robotCommentUpdateFactory.create(getChange(), effectiveAccountId, authorIdent, when);
        }
    }
    return robotCommentUpdate;
}
#method_after
@VisibleForTesting
RobotCommentUpdate createRobotCommentUpdateIfNull() {
    if (robotCommentUpdate == null) {
        ChangeNotes notes = getNotes();
        if (notes != null) {
            robotCommentUpdate = robotCommentUpdateFactory.create(notes, accountId, realAccountId, authorIdent, when);
        } else {
            robotCommentUpdate = robotCommentUpdateFactory.create(getChange(), accountId, realAccountId, authorIdent, when);
        }
    }
    return robotCommentUpdate;
}
#end_block

#method_before
@Override
protected CommitBuilder applyImpl(RevWalk rw, ObjectInserter ins, ObjectId curr) throws OrmException, IOException {
    CommitBuilder cb = new CommitBuilder();
    int ps = psId != null ? psId.get() : getChange().currentPatchSetId().get();
    StringBuilder msg = new StringBuilder();
    if (commitSubject != null) {
        msg.append(commitSubject);
    } else {
        msg.append("Update patch set ").append(ps);
    }
    msg.append("\n\n");
    if (changeMessage != null) {
        msg.append(changeMessage);
        msg.append("\n\n");
    }
    addPatchSetFooter(msg, ps);
    if (changeId != null) {
        addFooter(msg, FOOTER_CHANGE_ID, changeId);
    }
    if (subject != null) {
        addFooter(msg, FOOTER_SUBJECT, subject);
    }
    if (branch != null) {
        addFooter(msg, FOOTER_BRANCH, branch);
    }
    if (status != null) {
        addFooter(msg, FOOTER_STATUS, status.name().toLowerCase());
    }
    if (topic != null) {
        addFooter(msg, FOOTER_TOPIC, topic);
    }
    if (commit != null) {
        addFooter(msg, FOOTER_COMMIT, commit);
    }
    if (assignee != null) {
        if (assignee.isPresent()) {
            addFooter(msg, FOOTER_ASSIGNEE);
            addIdent(msg, assignee.get()).append('\n');
        } else {
            addFooter(msg, FOOTER_ASSIGNEE).append('\n');
        }
    }
    Joiner comma = Joiner.on(',');
    if (hashtags != null) {
        addFooter(msg, FOOTER_HASHTAGS, comma.join(hashtags));
    }
    if (tag != null) {
        addFooter(msg, FOOTER_TAG, tag);
    }
    if (groups != null) {
        addFooter(msg, FOOTER_GROUPS, comma.join(groups));
    }
    for (Map.Entry<Account.Id, ReviewerStateInternal> e : reviewers.entrySet()) {
        addFooter(msg, e.getValue().getFooterKey());
        addIdent(msg, e.getKey()).append('\n');
    }
    for (Table.Cell<String, Account.Id, Optional<Short>> c : approvals.cellSet()) {
        addFooter(msg, FOOTER_LABEL);
        if (!c.getValue().isPresent()) {
            msg.append('-').append(c.getRowKey());
        } else {
            msg.append(LabelVote.create(c.getRowKey(), c.getValue().get()).formatWithEquals());
        }
        Account.Id id = c.getColumnKey();
        if (!id.equals(getEffectiveAccountId())) {
            addIdent(msg.append(' '), id);
        }
        msg.append('\n');
    }
    if (submissionId != null) {
        addFooter(msg, FOOTER_SUBMISSION_ID, submissionId);
    }
    if (submitRecords != null) {
        for (SubmitRecord rec : submitRecords) {
            addFooter(msg, FOOTER_SUBMITTED_WITH).append(rec.status);
            if (rec.errorMessage != null) {
                msg.append(' ').append(sanitizeFooter(rec.errorMessage));
            }
            msg.append('\n');
            if (rec.labels != null) {
                for (SubmitRecord.Label label : rec.labels) {
                    addFooter(msg, FOOTER_SUBMITTED_WITH).append(label.status).append(": ").append(label.label);
                    if (label.appliedBy != null) {
                        PersonIdent ident = newIdent(accountCache.get(label.appliedBy).getAccount(), when);
                        msg.append(": ").append(ident.getName()).append(" <").append(ident.getEmailAddress()).append('>');
                    }
                    msg.append('\n');
                }
            }
        }
    }
    if (!Objects.equals(effectiveAccountId, realAccountId)) {
        addFooter(msg, FOOTER_REAL_USER);
        addIdent(msg, realAccountId).append('\n');
    }
    cb.setMessage(msg.toString());
    try {
        ObjectId treeId = storeRevisionNotes(rw, ins, curr);
        if (treeId != null) {
            cb.setTreeId(treeId);
        }
    } catch (ConfigInvalidException e) {
        throw new OrmException(e);
    }
    return cb;
}
#method_after
@Override
protected CommitBuilder applyImpl(RevWalk rw, ObjectInserter ins, ObjectId curr) throws OrmException, IOException {
    CommitBuilder cb = new CommitBuilder();
    int ps = psId != null ? psId.get() : getChange().currentPatchSetId().get();
    StringBuilder msg = new StringBuilder();
    if (commitSubject != null) {
        msg.append(commitSubject);
    } else {
        msg.append("Update patch set ").append(ps);
    }
    msg.append("\n\n");
    if (changeMessage != null) {
        msg.append(changeMessage);
        msg.append("\n\n");
    }
    addPatchSetFooter(msg, ps);
    if (changeId != null) {
        addFooter(msg, FOOTER_CHANGE_ID, changeId);
    }
    if (subject != null) {
        addFooter(msg, FOOTER_SUBJECT, subject);
    }
    if (branch != null) {
        addFooter(msg, FOOTER_BRANCH, branch);
    }
    if (status != null) {
        addFooter(msg, FOOTER_STATUS, status.name().toLowerCase());
    }
    if (topic != null) {
        addFooter(msg, FOOTER_TOPIC, topic);
    }
    if (commit != null) {
        addFooter(msg, FOOTER_COMMIT, commit);
    }
    if (assignee != null) {
        if (assignee.isPresent()) {
            addFooter(msg, FOOTER_ASSIGNEE);
            addIdent(msg, assignee.get()).append('\n');
        } else {
            addFooter(msg, FOOTER_ASSIGNEE).append('\n');
        }
    }
    Joiner comma = Joiner.on(',');
    if (hashtags != null) {
        addFooter(msg, FOOTER_HASHTAGS, comma.join(hashtags));
    }
    if (tag != null) {
        addFooter(msg, FOOTER_TAG, tag);
    }
    if (groups != null) {
        addFooter(msg, FOOTER_GROUPS, comma.join(groups));
    }
    for (Map.Entry<Account.Id, ReviewerStateInternal> e : reviewers.entrySet()) {
        addFooter(msg, e.getValue().getFooterKey());
        addIdent(msg, e.getKey()).append('\n');
    }
    for (Table.Cell<String, Account.Id, Optional<Short>> c : approvals.cellSet()) {
        addFooter(msg, FOOTER_LABEL);
        if (!c.getValue().isPresent()) {
            msg.append('-').append(c.getRowKey());
        } else {
            msg.append(LabelVote.create(c.getRowKey(), c.getValue().get()).formatWithEquals());
        }
        Account.Id id = c.getColumnKey();
        if (!id.equals(getAccountId())) {
            addIdent(msg.append(' '), id);
        }
        msg.append('\n');
    }
    if (submissionId != null) {
        addFooter(msg, FOOTER_SUBMISSION_ID, submissionId);
    }
    if (submitRecords != null) {
        for (SubmitRecord rec : submitRecords) {
            addFooter(msg, FOOTER_SUBMITTED_WITH).append(rec.status);
            if (rec.errorMessage != null) {
                msg.append(' ').append(sanitizeFooter(rec.errorMessage));
            }
            msg.append('\n');
            if (rec.labels != null) {
                for (SubmitRecord.Label label : rec.labels) {
                    addFooter(msg, FOOTER_SUBMITTED_WITH).append(label.status).append(": ").append(label.label);
                    if (label.appliedBy != null) {
                        msg.append(": ");
                        addIdent(msg, label.appliedBy);
                    }
                    msg.append('\n');
                }
            }
        }
    }
    if (!Objects.equals(accountId, realAccountId)) {
        addFooter(msg, FOOTER_REAL_USER);
        addIdent(msg, realAccountId).append('\n');
    }
    cb.setMessage(msg.toString());
    try {
        ObjectId treeId = storeRevisionNotes(rw, ins, curr);
        if (treeId != null) {
            cb.setTreeId(treeId);
        }
    } catch (ConfigInvalidException e) {
        throw new OrmException(e);
    }
    return cb;
}
#end_block

#method_before
@SuppressWarnings("deprecation")
@Override
void apply(ChangeUpdate update) throws OrmException {
    if (!Objects.equals(change.getTopic(), noteDbChange.getTopic())) {
        update.setTopic(change.getTopic());
    }
    if (!Objects.equals(change.getStatus(), noteDbChange.getStatus())) {
        // TODO(dborowitz): Stamp approximate approvals at this time.
        update.fixStatus(change.getStatus());
    }
    if (change.getSubmissionId() != null) {
        update.setSubmissionId(change.getSubmissionId());
    }
    if (!update.isEmpty()) {
        update.setSubjectForCommit("Final NoteDb migration updates");
    }
}
#method_after
@SuppressWarnings("deprecation")
@Override
void apply(ChangeUpdate update) throws OrmException {
    if (!Objects.equals(change.getTopic(), noteDbChange.getTopic())) {
        update.setTopic(change.getTopic());
    }
    if (!Objects.equals(change.getStatus(), noteDbChange.getStatus())) {
        // TODO(dborowitz): Stamp approximate approvals at this time.
        update.fixStatus(change.getStatus());
    }
    if (change.getSubmissionId() != null && noteDbChange.getSubmissionId() == null) {
        update.setSubmissionId(change.getSubmissionId());
    }
    if (!Objects.equals(change.getAssignee(), noteDbChange.getAssignee())) {
        // TODO(dborowitz): Parse intermediate values out from messages.
        update.setAssignee(change.getAssignee());
    }
    if (!update.isEmpty()) {
        update.setSubjectForCommit("Final NoteDb migration updates");
    }
}
#end_block

#method_before
boolean canAdd(E e) {
    if (isEmpty()) {
        return true;
    }
    if (e instanceof FinalUpdatesEvent) {
        // FinalUpdatesEvent always gets its own update.
        return false;
    }
    Event last = getLast();
    if (!Objects.equals(e.effectiveUser, last.effectiveUser) || !Objects.equals(e.realUser, last.realUser) || !e.psId.equals(last.psId) || !Objects.equals(e.tag, last.tag)) {
        // Different patch set, author, or tag.
        return false;
    }
    long t = e.when.getTime();
    long tFirst = getFirstTime();
    long tLast = getLastTime();
    checkArgument(t >= tLast, "event %s is before previous event in list %s", e, last);
    if (t - tLast > ChangeRebuilderImpl.MAX_DELTA_MS || t - tFirst > ChangeRebuilderImpl.MAX_WINDOW_MS) {
        // Too much time elapsed.
        return false;
    }
    if (!e.uniquePerUpdate()) {
        return true;
    }
    for (Event o : this) {
        if (e.getClass() == o.getClass()) {
            // Only one event of this type allowed per update.
            return false;
        }
    }
    return true;
}
#method_after
boolean canAdd(E e) {
    if (isEmpty()) {
        return true;
    }
    if (e instanceof FinalUpdatesEvent) {
        // FinalUpdatesEvent always gets its own update.
        return false;
    }
    Event last = getLast();
    if (!Objects.equals(e.user, last.user) || !Objects.equals(e.realUser, last.realUser) || !e.psId.equals(last.psId) || !Objects.equals(e.tag, last.tag)) {
        // Different patch set, author, or tag.
        return false;
    }
    long t = e.when.getTime();
    long tFirst = getFirstTime();
    long tLast = getLastTime();
    checkArgument(t >= tLast, "event %s is before previous event in list %s", e, last);
    if (t - tLast > ChangeRebuilderImpl.MAX_DELTA_MS || t - tFirst > ChangeRebuilderImpl.MAX_WINDOW_MS) {
        // Too much time elapsed.
        return false;
    }
    if (!e.uniquePerUpdate()) {
        return true;
    }
    for (Event o : this) {
        if (e.getClass() == o.getClass()) {
            // Only one event of this type allowed per update.
            return false;
        }
    }
    return true;
}
#end_block

#method_before
Account.Id getAccountId() {
    Account.Id id = get(0).effectiveUser;
    for (int i = 1; i < size(); i++) {
        checkState(Objects.equals(id, get(i).effectiveUser), "mismatched users in EventList: %s != %s", id, get(i).effectiveUser);
    }
    return id;
}
#method_after
Account.Id getAccountId() {
    Account.Id id = get(0).user;
    for (int i = 1; i < size(); i++) {
        checkState(Objects.equals(id, get(i).user), "mismatched users in EventList: %s != %s", id, get(i).user);
    }
    return id;
}
#end_block

#method_before
protected void checkUpdate(AbstractChangeUpdate update) {
    checkState(Objects.equals(update.getPatchSetId(), psId), "cannot apply event for %s to update for %s", update.getPatchSetId(), psId);
    checkState(when.getTime() - update.getWhen().getTime() <= MAX_WINDOW_MS, "event at %s outside update window starting at %s", when, update.getWhen());
    checkState(Objects.equals(update.getNullableAccountId(), effectiveUser), "cannot apply event by %s to update by %s", effectiveUser, update.getNullableAccountId());
}
#method_after
protected void checkUpdate(AbstractChangeUpdate update) {
    checkState(Objects.equals(update.getPatchSetId(), psId), "cannot apply event for %s to update for %s", update.getPatchSetId(), psId);
    checkState(when.getTime() - update.getWhen().getTime() <= MAX_WINDOW_MS, "event at %s outside update window starting at %s", when, update.getWhen());
    checkState(Objects.equals(update.getNullableAccountId(), user), "cannot apply event by %s to update by %s", user, update.getNullableAccountId());
}
#end_block

#method_before
@Override
public String toString() {
    return MoreObjects.toStringHelper(this).add("psId", psId).add("effectiveUser", effectiveUser).add("realUser", realUser).add("when", when).toString();
}
#method_after
@Override
public String toString() {
    return MoreObjects.toStringHelper(this).add("psId", psId).add("effectiveUser", user).add("realUser", realUser).add("when", when).toString();
}
#end_block

#method_before
@Override
public int compareTo(Event other) {
    return ComparisonChain.start().compare(this.when, other.when).compareTrueFirst(isPatchSet(), isPatchSet()).compareTrueFirst(this.predatesChange, other.predatesChange).compare(this.effectiveUser, other.effectiveUser, ReviewDbUtil.intKeyOrdering()).compare(this.realUser, other.realUser, ReviewDbUtil.intKeyOrdering()).compare(this.psId, other.psId, ReviewDbUtil.intKeyOrdering().nullsLast()).result();
}
#method_after
@Override
public int compareTo(Event other) {
    return ComparisonChain.start().compareFalseFirst(this.isFinalUpdates(), other.isFinalUpdates()).compare(this.when, other.when).compareTrueFirst(isPatchSet(), isPatchSet()).compareTrueFirst(this.predatesChange, other.predatesChange).compare(this.user, other.user, ReviewDbUtil.intKeyOrdering()).compare(this.realUser, other.realUser, ReviewDbUtil.intKeyOrdering()).compare(this.psId, other.psId, ReviewDbUtil.intKeyOrdering().nullsLast()).result();
}
#end_block

#method_before
protected boolean isPatchSet() {
    return false;
}
#method_after
private boolean isPatchSet() {
    return this instanceof PatchSetEvent;
}
#end_block

#method_before
public static PatchSetApproval newApproval(PatchSet.Id psId, CurrentUser user, LabelId labelId, int value, Date when) {
    PatchSetApproval psa = new PatchSetApproval(new PatchSetApproval.Key(psId, user.getAccountId(), labelId), Shorts.checkedCast(value), when);
    if (user.getRealUser().isIdentifiedUser()) {
        psa.setRealAccountId(user.getRealUser().getAccountId());
    }
    return psa;
}
#method_after
public static PatchSetApproval newApproval(PatchSet.Id psId, CurrentUser user, LabelId labelId, int value, Date when) {
    PatchSetApproval psa = new PatchSetApproval(new PatchSetApproval.Key(psId, user.getAccountId(), labelId), Shorts.checkedCast(value), when);
    user.updateRealAccountId(psa::setRealAccountId);
    return psa;
}
#end_block

#method_before
private Comment parseComment(byte[] note, MutableInteger curr, String currentFileName, PatchSet.Id psId, RevId revId, boolean isForBase, Integer parentNumber) throws ConfigInvalidException {
    Change.Id changeId = psId.getParentKey();
    // Check if there is a new file.
    boolean newFile = (RawParseUtils.match(note, curr.value, FILE.getBytes(UTF_8))) != -1;
    if (newFile) {
        // If so, parse the new file name.
        currentFileName = parseFilename(note, curr, changeId);
    } else if (currentFileName == null) {
        throw parseException(changeId, "could not parse %s", FILE);
    }
    CommentRange range = parseCommentRange(note, curr);
    if (range == null) {
        throw parseException(changeId, "could not parse %s", COMMENT_RANGE);
    }
    Timestamp commentTime = parseTimestamp(note, curr, changeId);
    Account.Id aId = parseAuthor(note, curr, changeId);
    boolean hasParent = (RawParseUtils.match(note, curr.value, PARENT.getBytes(UTF_8))) != -1;
    String parentUUID = null;
    if (hasParent) {
        parentUUID = parseStringField(note, curr, changeId, PARENT);
    }
    String uuid = parseStringField(note, curr, changeId, UUID);
    boolean hasTag = (RawParseUtils.match(note, curr.value, TAG.getBytes(UTF_8))) != -1;
    String tag = null;
    if (hasTag) {
        tag = parseStringField(note, curr, changeId, TAG);
    }
    int commentLength = parseCommentLength(note, curr, changeId);
    String message = RawParseUtils.decode(UTF_8, note, curr.value, curr.value + commentLength);
    checkResult(message, "message contents", changeId);
    Comment c = new Comment(new Comment.Key(uuid, currentFileName, psId.get()), aId, commentTime, isForBase ? (short) (parentNumber == null ? 0 : -parentNumber) : (short) 1, message, serverId);
    c.lineNbr = range.getEndLine();
    c.parentUuid = parentUUID;
    c.tag = tag;
    c.setRevId(revId);
    if (range.getStartCharacter() != -1) {
        c.setRange(range);
    }
    curr.value = RawParseUtils.nextLF(note, curr.value + commentLength);
    curr.value = RawParseUtils.nextLF(note, curr.value);
    return c;
}
#method_after
private Comment parseComment(byte[] note, MutableInteger curr, String currentFileName, PatchSet.Id psId, RevId revId, boolean isForBase, Integer parentNumber) throws ConfigInvalidException {
    Change.Id changeId = psId.getParentKey();
    // Check if there is a new file.
    boolean newFile = (RawParseUtils.match(note, curr.value, FILE.getBytes(UTF_8))) != -1;
    if (newFile) {
        // If so, parse the new file name.
        currentFileName = parseFilename(note, curr, changeId);
    } else if (currentFileName == null) {
        throw parseException(changeId, "could not parse %s", FILE);
    }
    CommentRange range = parseCommentRange(note, curr);
    if (range == null) {
        throw parseException(changeId, "could not parse %s", COMMENT_RANGE);
    }
    Timestamp commentTime = parseTimestamp(note, curr, changeId);
    Account.Id aId = parseAuthor(note, curr, changeId, AUTHOR);
    boolean hasRealAuthor = (RawParseUtils.match(note, curr.value, REAL_AUTHOR.getBytes(UTF_8))) != -1;
    Account.Id raId = null;
    if (hasRealAuthor) {
        raId = parseAuthor(note, curr, changeId, REAL_AUTHOR);
    }
    boolean hasParent = (RawParseUtils.match(note, curr.value, PARENT.getBytes(UTF_8))) != -1;
    String parentUUID = null;
    if (hasParent) {
        parentUUID = parseStringField(note, curr, changeId, PARENT);
    }
    String uuid = parseStringField(note, curr, changeId, UUID);
    boolean hasTag = (RawParseUtils.match(note, curr.value, TAG.getBytes(UTF_8))) != -1;
    String tag = null;
    if (hasTag) {
        tag = parseStringField(note, curr, changeId, TAG);
    }
    int commentLength = parseCommentLength(note, curr, changeId);
    String message = RawParseUtils.decode(UTF_8, note, curr.value, curr.value + commentLength);
    checkResult(message, "message contents", changeId);
    Comment c = new Comment(new Comment.Key(uuid, currentFileName, psId.get()), aId, commentTime, isForBase ? (short) (parentNumber == null ? 0 : -parentNumber) : (short) 1, message, serverId);
    c.lineNbr = range.getEndLine();
    c.parentUuid = parentUUID;
    c.tag = tag;
    c.setRevId(revId);
    if (raId != null) {
        c.setRealAuthor(raId);
    }
    if (range.getStartCharacter() != -1) {
        c.setRange(range);
    }
    curr.value = RawParseUtils.nextLF(note, curr.value + commentLength);
    curr.value = RawParseUtils.nextLF(note, curr.value);
    return c;
}
#end_block

#method_before
private Account.Id parseAuthor(byte[] note, MutableInteger curr, Change.Id changeId) throws ConfigInvalidException {
    checkHeaderLineFormat(note, curr, AUTHOR, changeId);
    int startOfAccountId = RawParseUtils.endOfFooterLineKey(note, curr.value) + 2;
    PersonIdent ident = RawParseUtils.parsePersonIdent(note, startOfAccountId);
    Account.Id aId = parseIdent(ident, changeId);
    curr.value = RawParseUtils.nextLF(note, curr.value);
    return checkResult(aId, "comment author", changeId);
}
#method_after
private Account.Id parseAuthor(byte[] note, MutableInteger curr, Change.Id changeId, String fieldName) throws ConfigInvalidException {
    checkHeaderLineFormat(note, curr, fieldName, changeId);
    int startOfAccountId = RawParseUtils.endOfFooterLineKey(note, curr.value) + 2;
    PersonIdent ident = RawParseUtils.parsePersonIdent(note, startOfAccountId);
    Account.Id aId = parseIdent(ident, changeId);
    curr.value = RawParseUtils.nextLF(note, curr.value);
    return checkResult(aId, fieldName, changeId);
}
#end_block

#method_before
private void appendOneComment(PrintWriter writer, Comment c) {
    // The CommentRange field for a comment is allowed to be null. If it is
    // null, then in the first line, we simply use the line number field for a
    // comment instead. If it isn't null, we write the comment range itself.
    Comment.Range range = c.range;
    if (range != null) {
        writer.print(range.startLine);
        writer.print(':');
        writer.print(range.startChar);
        writer.print('-');
        writer.print(range.endLine);
        writer.print(':');
        writer.print(range.endChar);
    } else {
        writer.print(c.lineNbr);
    }
    writer.print("\n");
    writer.print(formatTime(serverIdent, c.writtenOn));
    writer.print("\n");
    PersonIdent ident = newIdent(accountCache.get(c.author.getId()).getAccount(), c.writtenOn, serverIdent, anonymousCowardName);
    StringBuilder name = new StringBuilder();
    PersonIdent.appendSanitized(name, ident.getName());
    name.append(" <");
    PersonIdent.appendSanitized(name, ident.getEmailAddress());
    name.append('>');
    appendHeaderField(writer, AUTHOR, name.toString());
    String parent = c.parentUuid;
    if (parent != null) {
        appendHeaderField(writer, PARENT, parent);
    }
    appendHeaderField(writer, UUID, c.key.uuid);
    if (c.tag != null) {
        appendHeaderField(writer, TAG, c.tag);
    }
    byte[] messageBytes = c.message.getBytes(UTF_8);
    appendHeaderField(writer, LENGTH, Integer.toString(messageBytes.length));
    writer.print(c.message);
    writer.print("\n\n");
}
#method_after
private void appendOneComment(PrintWriter writer, Comment c) {
    // The CommentRange field for a comment is allowed to be null. If it is
    // null, then in the first line, we simply use the line number field for a
    // comment instead. If it isn't null, we write the comment range itself.
    Comment.Range range = c.range;
    if (range != null) {
        writer.print(range.startLine);
        writer.print(':');
        writer.print(range.startChar);
        writer.print('-');
        writer.print(range.endLine);
        writer.print(':');
        writer.print(range.endChar);
    } else {
        writer.print(c.lineNbr);
    }
    writer.print("\n");
    writer.print(formatTime(serverIdent, c.writtenOn));
    writer.print("\n");
    appendIdent(writer, AUTHOR, c.author.getId(), c.writtenOn);
    if (!c.getRealAuthor().equals(c.author)) {
        appendIdent(writer, REAL_AUTHOR, c.getRealAuthor().getId(), c.writtenOn);
    }
    String parent = c.parentUuid;
    if (parent != null) {
        appendHeaderField(writer, PARENT, parent);
    }
    appendHeaderField(writer, UUID, c.key.uuid);
    if (c.tag != null) {
        appendHeaderField(writer, TAG, c.tag);
    }
    byte[] messageBytes = c.message.getBytes(UTF_8);
    appendHeaderField(writer, LENGTH, Integer.toString(messageBytes.length));
    writer.print(c.message);
    writer.print("\n\n");
}
#end_block

#method_before
private void parseChangeMessage(PatchSet.Id psId, Account.Id effectiveAccountId, Account.Id realAccountId, ChangeNotesCommit commit, Timestamp ts) {
    byte[] raw = commit.getRawBuffer();
    int size = raw.length;
    Charset enc = RawParseUtils.parseEncoding(raw);
    int subjectStart = RawParseUtils.commitMessage(raw, 0);
    if (subjectStart < 0 || subjectStart >= size) {
        return;
    }
    int subjectEnd = RawParseUtils.endOfParagraph(raw, subjectStart);
    if (subjectEnd == size) {
        return;
    }
    int changeMessageStart;
    if (raw[subjectEnd] == '\n') {
        // \n\n ends paragraph
        changeMessageStart = subjectEnd + 2;
    } else if (raw[subjectEnd] == '\r') {
        // \r\n\r\n ends paragraph
        changeMessageStart = subjectEnd + 4;
    } else {
        return;
    }
    int ptr = size - 1;
    int changeMessageEnd = -1;
    while (ptr > changeMessageStart) {
        ptr = RawParseUtils.prevLF(raw, ptr, '\r');
        if (ptr == -1) {
            break;
        }
        if (raw[ptr] == '\n') {
            changeMessageEnd = ptr - 1;
            break;
        } else if (raw[ptr] == '\r') {
            changeMessageEnd = ptr - 3;
            break;
        }
    }
    if (ptr <= changeMessageStart) {
        return;
    }
    String changeMsgString = RawParseUtils.decode(enc, raw, changeMessageStart, changeMessageEnd + 1);
    ChangeMessage changeMessage = new ChangeMessage(new ChangeMessage.Key(psId.getParentKey(), commit.name()), effectiveAccountId, ts, psId);
    changeMessage.setMessage(changeMsgString);
    changeMessage.setTag(tag);
    changeMessage.setRealAuthor(realAccountId);
    changeMessagesByPatchSet.put(psId, changeMessage);
    allChangeMessages.add(changeMessage);
}
#method_after
private void parseChangeMessage(PatchSet.Id psId, Account.Id accountId, Account.Id realAccountId, ChangeNotesCommit commit, Timestamp ts) {
    byte[] raw = commit.getRawBuffer();
    int size = raw.length;
    Charset enc = RawParseUtils.parseEncoding(raw);
    int subjectStart = RawParseUtils.commitMessage(raw, 0);
    if (subjectStart < 0 || subjectStart >= size) {
        return;
    }
    int subjectEnd = RawParseUtils.endOfParagraph(raw, subjectStart);
    if (subjectEnd == size) {
        return;
    }
    int changeMessageStart;
    if (raw[subjectEnd] == '\n') {
        // \n\n ends paragraph
        changeMessageStart = subjectEnd + 2;
    } else if (raw[subjectEnd] == '\r') {
        // \r\n\r\n ends paragraph
        changeMessageStart = subjectEnd + 4;
    } else {
        return;
    }
    int ptr = size - 1;
    int changeMessageEnd = -1;
    while (ptr > changeMessageStart) {
        ptr = RawParseUtils.prevLF(raw, ptr, '\r');
        if (ptr == -1) {
            break;
        }
        if (raw[ptr] == '\n') {
            changeMessageEnd = ptr - 1;
            break;
        } else if (raw[ptr] == '\r') {
            changeMessageEnd = ptr - 3;
            break;
        }
    }
    if (ptr <= changeMessageStart) {
        return;
    }
    String changeMsgString = RawParseUtils.decode(enc, raw, changeMessageStart, changeMessageEnd + 1);
    ChangeMessage changeMessage = new ChangeMessage(new ChangeMessage.Key(psId.getParentKey(), commit.name()), accountId, ts, psId);
    changeMessage.setMessage(changeMsgString);
    changeMessage.setTag(tag);
    changeMessage.setRealAuthor(realAccountId);
    changeMessagesByPatchSet.put(psId, changeMessage);
    allChangeMessages.add(changeMessage);
}
#end_block

#method_before
public Account.Id getNullableAccountId() {
    return effectiveAccountId;
}
#method_after
public Account.Id getNullableAccountId() {
    return accountId;
}
#end_block

#method_before
void set(ChangeInfo info) {
    this.changeId = info.legacyId();
    assigneeLink.setText(info.assignee() != null ? info.assignee().name() : "");
    assigneeSuggestOracle.setChange(changeId);
    editAssigneeIcon.setVisible(Gerrit.isSignedIn());
}
#method_after
void set(ChangeInfo info) {
    this.changeId = info.legacyId();
    this.canEdit = info.hasActions() && info.actions().containsKey("assignee");
    setAssignee(info.assignee());
    assigneeSuggestOracle.setChange(changeId);
    editAssigneeIcon.setVisible(canEdit);
    if (!canEdit) {
        show.setTitle(null);
    }
}
#end_block

#method_before
void onOpenForm() {
    UIObject.setVisible(form, true);
    UIObject.setVisible(error, false);
    editAssigneeIcon.setVisible(false);
    suggestBox.setFocus(true);
    suggestBox.setText("");
}
#method_after
void onOpenForm() {
    UIObject.setVisible(form, true);
    UIObject.setVisible(show, false);
    UIObject.setVisible(error, false);
    editAssigneeIcon.setVisible(false);
    suggestBox.setFocus(true);
    suggestBox.setText(FormatUtil.nameEmail(currentAssignee));
    suggestBox.selectAll();
}
#end_block

#method_before
void onCloseForm() {
    UIObject.setVisible(form, false);
    UIObject.setVisible(error, false);
    editAssigneeIcon.setVisible(true);
    suggestBox.setFocus(false);
}
#method_after
void onCloseForm() {
    UIObject.setVisible(form, false);
    UIObject.setVisible(show, true);
    UIObject.setVisible(error, false);
    editAssigneeIcon.setVisible(true);
    suggestBox.setFocus(false);
}
#end_block

#method_before
@UiHandler("assign")
void onEditAssignee(@SuppressWarnings("unused") ClickEvent e) {
    editAssignee(suggestBox.getText());
}
#method_after
@UiHandler("assign")
void onEditAssignee(@SuppressWarnings("unused") ClickEvent e) {
    if (canEdit) {
        editAssignee(suggestBox.getText());
    }
}
#end_block

#method_before
private void editAssignee(final String assignee) {
    if (assignee.isEmpty()) {
        ChangeApi.deleteAssignee(changeId.get(), new GerritCallback<AccountInfo>() {

            @Override
            public void onSuccess(AccountInfo result) {
                onCloseForm();
                assigneeLink.setText("");
            }

            @Override
            public void onFailure(Throwable err) {
                if (isSigninFailure(err)) {
                    new NotSignedInDialog().center();
                } else {
                    UIObject.setVisible(error, true);
                    error.setInnerText(err instanceof StatusCodeException ? ((StatusCodeException) err).getEncodedResponse() : err.getMessage());
                }
            }
        });
    } else {
        ChangeApi.setAssignee(changeId.get(), assignee, new GerritCallback<AccountInfo>() {

            @Override
            public void onSuccess(AccountInfo result) {
                onCloseForm();
                assigneeLink.setText(getName(result));
            }

            @Override
            public void onFailure(Throwable err) {
                if (isSigninFailure(err)) {
                    new NotSignedInDialog().center();
                } else {
                    UIObject.setVisible(error, true);
                    error.setInnerText(err instanceof StatusCodeException ? ((StatusCodeException) err).getEncodedResponse() : err.getMessage());
                }
            }
        });
    }
}
#method_after
private void editAssignee(final String assignee) {
    if (assignee.isEmpty()) {
        ChangeApi.deleteAssignee(changeId.get(), new GerritCallback<AccountInfo>() {

            @Override
            public void onSuccess(AccountInfo result) {
                onCloseForm();
                setAssignee(null);
            }

            @Override
            public void onFailure(Throwable err) {
                if (isSigninFailure(err)) {
                    new NotSignedInDialog().center();
                } else {
                    UIObject.setVisible(error, true);
                    error.setInnerText(err instanceof StatusCodeException ? ((StatusCodeException) err).getEncodedResponse() : err.getMessage());
                }
            }
        });
    } else {
        ChangeApi.setAssignee(changeId.get(), assignee, new GerritCallback<AccountInfo>() {

            @Override
            public void onSuccess(AccountInfo result) {
                onCloseForm();
                setAssignee(result);
                Reviewers reviewers = getReviewers();
                if (reviewers != null) {
                    reviewers.updateReviewerList();
                }
            }

            @Override
            public void onFailure(Throwable err) {
                if (isSigninFailure(err)) {
                    new NotSignedInDialog().center();
                } else {
                    UIObject.setVisible(error, true);
                    error.setInnerText(err instanceof StatusCodeException ? ((StatusCodeException) err).getEncodedResponse() : err.getMessage());
                }
            }
        });
    }
}
#end_block

#method_before
private String getName(AccountInfo info) {
    if (info.name() != null) {
        return info.name();
    }
    return info.username();
}
#method_after
private String getName(AccountInfo info) {
    if (info.name() != null) {
        return info.name();
    }
    if (info.email() != null) {
        return info.email();
    }
    return Gerrit.info().user().anonymousCowardName();
}
#end_block

#method_before
public Response<ReviewResult> apply(RevisionResource revision, ReviewInput input, Timestamp ts) throws RestApiException, UpdateException, OrmException, IOException {
    // Respect timestamp, but truncate at change created-on time.
    ts = Ordering.natural().max(ts, revision.getChange().getCreatedOn());
    if (revision.getEdit().isPresent()) {
        throw new ResourceConflictException("cannot post review on edit");
    }
    if (input.onBehalfOf != null) {
        revision = onBehalfOf(revision, input);
        checkState(input.drafts == DraftHandling.KEEP);
    }
    if (input.drafts == null) {
        input.drafts = DraftHandling.DELETE;
    }
    if (input.labels != null) {
        checkLabels(revision, input.strictLabels, input.labels);
    }
    if (input.comments != null) {
        checkComments(revision, input.comments);
    }
    if (input.robotComments != null) {
        if (!migration.readChanges()) {
            throw new MethodNotAllowedException("robot comments not supported");
        }
        checkRobotComments(revision, input.robotComments);
    }
    if (input.notify == null) {
        log.warn("notify = null; assuming notify = NONE");
        input.notify = NotifyHandling.NONE;
    }
    Map<String, AddReviewerResult> reviewerJsonResults = null;
    List<PostReviewers.Addition> reviewerResults = Lists.newArrayList();
    boolean hasError = false;
    boolean confirm = false;
    if (input.reviewers != null) {
        reviewerJsonResults = Maps.newHashMap();
        for (AddReviewerInput reviewerInput : input.reviewers) {
            PostReviewers.Addition result = postReviewers.prepareApplication(revision.getChangeResource(), reviewerInput);
            reviewerJsonResults.put(reviewerInput.reviewer, result.result);
            if (result.result.error != null) {
                hasError = true;
                continue;
            }
            if (result.result.confirm != null) {
                confirm = true;
                continue;
            }
            reviewerResults.add(result);
        }
    }
    ReviewResult output = new ReviewResult();
    output.reviewers = reviewerJsonResults;
    if (hasError || confirm) {
        return Response.withStatusCode(SC_BAD_REQUEST, output);
    }
    output.labels = input.labels;
    try (BatchUpdate bu = batchUpdateFactory.create(db.get(), revision.getChange().getProject(), revision.getUser(), ts)) {
        // updated set of reviewers.
        for (PostReviewers.Addition reviewerResult : reviewerResults) {
            bu.addOp(revision.getChange().getId(), reviewerResult.op);
        }
        bu.addOp(revision.getChange().getId(), new Op(revision.getPatchSet().getId(), input, reviewerResults));
        bu.execute();
        for (PostReviewers.Addition reviewerResult : reviewerResults) {
            reviewerResult.gatherResults();
        }
    }
    return Response.ok(output);
}
#method_after
public Response<ReviewResult> apply(RevisionResource revision, ReviewInput input, Timestamp ts) throws RestApiException, UpdateException, OrmException, IOException {
    // Respect timestamp, but truncate at change created-on time.
    ts = Ordering.natural().max(ts, revision.getChange().getCreatedOn());
    if (revision.getEdit().isPresent()) {
        throw new ResourceConflictException("cannot post review on edit");
    }
    if (input.onBehalfOf != null) {
        revision = onBehalfOf(revision, input);
    } else if (input.drafts == null) {
        input.drafts = DraftHandling.DELETE;
    }
    if (input.labels != null) {
        checkLabels(revision, input.strictLabels, input.labels);
    }
    if (input.comments != null) {
        checkComments(revision, input.comments);
    }
    if (input.robotComments != null) {
        if (!migration.readChanges()) {
            throw new MethodNotAllowedException("robot comments not supported");
        }
        checkRobotComments(revision, input.robotComments);
    }
    if (input.notify == null) {
        log.warn("notify = null; assuming notify = NONE");
        input.notify = NotifyHandling.NONE;
    }
    Map<String, AddReviewerResult> reviewerJsonResults = null;
    List<PostReviewers.Addition> reviewerResults = Lists.newArrayList();
    boolean hasError = false;
    boolean confirm = false;
    if (input.reviewers != null) {
        reviewerJsonResults = Maps.newHashMap();
        for (AddReviewerInput reviewerInput : input.reviewers) {
            PostReviewers.Addition result = postReviewers.prepareApplication(revision.getChangeResource(), reviewerInput);
            reviewerJsonResults.put(reviewerInput.reviewer, result.result);
            if (result.result.error != null) {
                hasError = true;
                continue;
            }
            if (result.result.confirm != null) {
                confirm = true;
                continue;
            }
            reviewerResults.add(result);
        }
    }
    ReviewResult output = new ReviewResult();
    output.reviewers = reviewerJsonResults;
    if (hasError || confirm) {
        return Response.withStatusCode(SC_BAD_REQUEST, output);
    }
    output.labels = input.labels;
    try (BatchUpdate bu = batchUpdateFactory.create(db.get(), revision.getChange().getProject(), revision.getUser(), ts)) {
        // updated set of reviewers.
        for (PostReviewers.Addition reviewerResult : reviewerResults) {
            bu.addOp(revision.getChange().getId(), reviewerResult.op);
        }
        bu.addOp(revision.getChange().getId(), new Op(revision.getPatchSet().getId(), input, reviewerResults));
        bu.execute();
        for (PostReviewers.Addition reviewerResult : reviewerResults) {
            reviewerResult.gatherResults();
        }
    }
    return Response.ok(output);
}
#end_block

#method_before
private RevisionResource onBehalfOf(RevisionResource rev, ReviewInput in) throws BadRequestException, AuthException, UnprocessableEntityException, OrmException {
    if (in.labels == null || in.labels.isEmpty()) {
        throw new AuthException(String.format("label required to post review on behalf of \"%s\"", in.onBehalfOf));
    }
    if (in.drafts == null) {
        in.drafts = DraftHandling.KEEP;
    }
    if (in.drafts != DraftHandling.KEEP || !isEmpty(in.comments) || !isEmpty(in.robotComments)) {
        // well for simplicity and consistency.
        throw new AuthException("not allowed to modify other user's comments");
    }
    ChangeControl caller = rev.getControl();
    Iterator<Map.Entry<String, Short>> itr = in.labels.entrySet().iterator();
    while (itr.hasNext()) {
        Map.Entry<String, Short> ent = itr.next();
        LabelType type = caller.getLabelTypes().byLabel(ent.getKey());
        if (type == null && in.strictLabels) {
            throw new BadRequestException(String.format("label \"%s\" is not a configured label", ent.getKey()));
        } else if (type == null) {
            itr.remove();
            continue;
        }
        PermissionRange r = caller.getRange(Permission.forLabelAs(type.getName()));
        if (r == null || r.isEmpty() || !r.contains(ent.getValue())) {
            throw new AuthException(String.format("not permitted to modify label \"%s\" on behalf of \"%s\"", ent.getKey(), in.onBehalfOf));
        }
    }
    if (in.labels.isEmpty()) {
        throw new AuthException(String.format("label required to post review on behalf of \"%s\"", in.onBehalfOf));
    }
    ChangeControl target = caller.forUser(accounts.parse(in.onBehalfOf));
    if (!target.getRefControl().isVisible()) {
        throw new UnprocessableEntityException(String.format("on_behalf_of account %s cannot see destination ref", target.getUser().getAccountId()));
    }
    return new RevisionResource(changes.parse(target), rev.getPatchSet());
}
#method_after
private RevisionResource onBehalfOf(RevisionResource rev, ReviewInput in) throws BadRequestException, AuthException, UnprocessableEntityException, OrmException {
    if (in.labels == null || in.labels.isEmpty()) {
        throw new AuthException(String.format("label required to post review on behalf of \"%s\"", in.onBehalfOf));
    }
    if (in.drafts == null) {
        in.drafts = DraftHandling.KEEP;
    }
    if (in.drafts != DraftHandling.KEEP) {
        throw new AuthException("not allowed to modify other user's drafts");
    }
    ChangeControl caller = rev.getControl();
    Iterator<Map.Entry<String, Short>> itr = in.labels.entrySet().iterator();
    while (itr.hasNext()) {
        Map.Entry<String, Short> ent = itr.next();
        LabelType type = caller.getLabelTypes().byLabel(ent.getKey());
        if (type == null && in.strictLabels) {
            throw new BadRequestException(String.format("label \"%s\" is not a configured label", ent.getKey()));
        } else if (type == null) {
            itr.remove();
            continue;
        }
        PermissionRange r = caller.getRange(Permission.forLabelAs(type.getName()));
        if (r == null || r.isEmpty() || !r.contains(ent.getValue())) {
            throw new AuthException(String.format("not permitted to modify label \"%s\" on behalf of \"%s\"", ent.getKey(), in.onBehalfOf));
        }
    }
    if (in.labels.isEmpty()) {
        throw new AuthException(String.format("label required to post review on behalf of \"%s\"", in.onBehalfOf));
    }
    ChangeControl target = caller.forUser(accounts.parse(in.onBehalfOf));
    if (!target.getRefControl().isVisible()) {
        throw new UnprocessableEntityException(String.format("on_behalf_of account %s cannot see destination ref", target.getUser().getAccountId()));
    }
    return new RevisionResource(changes.parse(target), rev.getPatchSet());
}
#end_block

#method_before
@Override
public BinaryResult apply(RevisionResource rsrc) throws RestApiException {
    if (Strings.isNullOrEmpty(format)) {
        throw new BadRequestException("format is not specified");
    }
    ArchiveFormat f = allowedFormats.extensions.get("." + format);
    if (allowedFormats.getAllowed().isEmpty() && format.equals("tar")) {
        // When no formats are allowed, this is because the server admin wants
        // to disallow downloading patchsets/changes as archives, this
        // is not applicable to the preview_submit call. Allow tar as a
        // fall back.
        f = ArchiveFormat.TAR;
    }
    if (f == null) {
        throw new BadRequestException("unknown archive format");
    }
    Change change = rsrc.getChange();
    if (!change.getStatus().isOpen()) {
        throw new PreconditionFailedException("change is " + Submit.status(change));
    }
    ChangeControl control = rsrc.getControl();
    if (!control.getUser().isIdentifiedUser()) {
        throw new MethodNotAllowedException("Anonymous users cannot submit");
    }
    try (BinaryResult b = getBundles(rsrc, f)) {
        b.disableGzip().setContentType(f.getMimeType()).setAttachmentName("submit-preview-" + change.getChangeId() + "." + format);
        return b;
    } catch (OrmException | IOException e) {
        throw new RestApiException("Error generating submit preview");
    }
}
#method_after
@Override
public BinaryResult apply(RevisionResource rsrc) throws RestApiException {
    if (Strings.isNullOrEmpty(format)) {
        throw new BadRequestException("format is not specified");
    }
    ArchiveFormat f = allowedFormats.extensions.get("." + format);
    if (f == null && format.equals("tgz")) {
        // Always allow tgz, even when the allowedFormats doesn't contain it.
        // Then we allow at least one format even if the list of allowed
        // formats is empty.
        f = ArchiveFormat.TGZ;
    }
    if (f == null) {
        throw new BadRequestException("unknown archive format");
    }
    Change change = rsrc.getChange();
    if (!change.getStatus().isOpen()) {
        throw new PreconditionFailedException("change is " + Submit.status(change));
    }
    ChangeControl control = rsrc.getControl();
    if (!control.getUser().isIdentifiedUser()) {
        throw new MethodNotAllowedException("Anonymous users cannot submit");
    }
    try (BinaryResult b = getBundles(rsrc, f)) {
        b.disableGzip().setContentType(f.getMimeType()).setAttachmentName("submit-preview-" + change.getChangeId() + "." + format);
        return b;
    } catch (OrmException | IOException e) {
        throw new RestApiException("Error generating submit preview");
    }
}
#end_block

#method_before
private static void formatLink(GitPerson person, FlowPanel p, InlineHyperlink name, Element date, ChangeInfo change) {
    // no avatar plugin is installed
    if (change.owner().hasAvatarInfo()) {
        AvatarImage avatar;
        if (change.owner().email() != null && person != null && person.email() != null && change.owner().email().equals(person.email())) {
            avatar = new AvatarImage(change.owner());
        } else {
            avatar = new AvatarImage(AccountInfo.create(0, person.name(), person.email(), null));
        }
        p.insert(avatar, 0);
    }
    name.setText(renderName(person));
    name.setTargetHistoryToken(PageLinks.toAccountQuery(owner(person), change.status()));
    date.setInnerText(FormatUtil.mediumFormat(person.date()));
}
#method_after
private static void formatLink(GitPerson person, FlowPanel p, InlineHyperlink name, Element date, ChangeInfo change) {
    // no avatar plugin is installed
    if (change.owner().hasAvatarInfo()) {
        AvatarImage avatar;
        if (sameEmail(change.owner(), person)) {
            avatar = new AvatarImage(change.owner());
        } else {
            avatar = new AvatarImage(AccountInfo.create(0, person.name(), person.email(), null));
        }
        p.insert(avatar, 0);
    }
    name.setText(renderName(person));
    name.setTargetHistoryToken(PageLinks.toAccountQuery(owner(person), change.status()));
    date.setInnerText(FormatUtil.mediumFormat(person.date()));
}
#end_block

#method_before
@Override
public Set<AccountInfo> getPastAssignees() throws RestApiException {
    try {
        return getPastAssignees.apply(change).value();
    } catch (Exception e) {
        throw new RestApiException("Cannot get past assignees", e);
    }
}
#method_after
@Override
public List<AccountInfo> getPastAssignees() throws RestApiException {
    try {
        return getPastAssignees.apply(change).value();
    } catch (Exception e) {
        throw new RestApiException("Cannot get past assignees", e);
    }
}
#end_block

#method_before
@Override
public Response<AccountInfo> apply(ChangeResource rsrc, AssigneeInput input) throws RestApiException, UpdateException, OrmException, IOException {
    try (BatchUpdate bu = batchUpdateFactory.create(db.get(), rsrc.getChange().getProject(), rsrc.getControl().getUser(), TimeUtil.nowTs())) {
        SetAssigneeOp op = assigneeFactory.create(input);
        bu.addOp(rsrc.getId(), op);
        PostReviewers.Addition reviewersAddition = addAssigneAsCC(rsrc, input.assignee);
        bu.addOp(rsrc.getId(), reviewersAddition.op);
        bu.execute();
        reviewersAddition.gatherResults();
        return Response.ok(AccountJson.toAccountInfo(op.getNewAssignee()));
    }
}
#method_after
@Override
public Response<AccountInfo> apply(ChangeResource rsrc, AssigneeInput input) throws RestApiException, UpdateException, OrmException, IOException {
    try (BatchUpdate bu = batchUpdateFactory.create(db.get(), rsrc.getChange().getProject(), rsrc.getControl().getUser(), TimeUtil.nowTs())) {
        SetAssigneeOp op = assigneeFactory.create(input);
        bu.addOp(rsrc.getId(), op);
        PostReviewers.Addition reviewersAddition = addAssigneeAsCC(rsrc, input.assignee);
        bu.addOp(rsrc.getId(), reviewersAddition.op);
        bu.execute();
        reviewersAddition.gatherResults();
        return Response.ok(AccountJson.toAccountInfo(op.getNewAssignee()));
    }
}
#end_block

#method_before
@Test
public void approvalsTombstone() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.putApproval("Not-For-Long", (short) 1);
    update.commit();
    ChangeNotes notes = newNotes(c);
    PatchSetApproval psa = Iterables.getOnlyElement(notes.getApprovals().get(c.currentPatchSetId()));
    assertThat(psa.getAccountId().get()).isEqualTo(1);
    assertThat(psa.getLabel()).isEqualTo("Not-For-Long");
    assertThat(psa.getValue()).isEqualTo((short) 1);
    update = newUpdate(c, changeOwner);
    update.removeApproval("Not-For-Long");
    update.commit();
    notes = newNotes(c);
    assertThat(notes.getApprovals()).isEmpty();
}
#method_after
@Test
public void approvalsTombstone() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.putApproval("Not-For-Long", (short) 1);
    update.commit();
    ChangeNotes notes = newNotes(c);
    PatchSetApproval psa = Iterables.getOnlyElement(notes.getApprovals().get(c.currentPatchSetId()));
    assertThat(psa.getAccountId().get()).isEqualTo(1);
    assertThat(psa.getLabel()).isEqualTo("Not-For-Long");
    assertThat(psa.getValue()).isEqualTo((short) 1);
    update = newUpdate(c, changeOwner);
    update.removeApproval("Not-For-Long");
    update.commit();
    notes = newNotes(c);
    assertThat(notes.getApprovals()).containsExactlyEntriesIn(ImmutableMultimap.of(psa.getPatchSetId(), new PatchSetApproval(psa.getKey(), (short) 0, update.getWhen())));
}
#end_block

#method_before
@Test
public void removeOtherUsersApprovals() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, otherUser);
    update.putApproval("Not-For-Long", (short) 1);
    update.commit();
    ChangeNotes notes = newNotes(c);
    PatchSetApproval psa = Iterables.getOnlyElement(notes.getApprovals().get(c.currentPatchSetId()));
    assertThat(psa.getAccountId()).isEqualTo(otherUserId);
    assertThat(psa.getLabel()).isEqualTo("Not-For-Long");
    assertThat(psa.getValue()).isEqualTo((short) 1);
    update = newUpdate(c, changeOwner);
    update.removeApprovalFor(otherUserId, "Not-For-Long");
    update.commit();
    notes = newNotes(c);
    assertThat(notes.getApprovals()).isEmpty();
    // Add back approval on same label.
    update = newUpdate(c, otherUser);
    update.putApproval("Not-For-Long", (short) 2);
    update.commit();
    notes = newNotes(c);
    psa = Iterables.getOnlyElement(notes.getApprovals().get(c.currentPatchSetId()));
    assertThat(psa.getAccountId()).isEqualTo(otherUserId);
    assertThat(psa.getLabel()).isEqualTo("Not-For-Long");
    assertThat(psa.getValue()).isEqualTo((short) 2);
}
#method_after
@Test
public void removeOtherUsersApprovals() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, otherUser);
    update.putApproval("Not-For-Long", (short) 1);
    update.commit();
    ChangeNotes notes = newNotes(c);
    PatchSetApproval psa = Iterables.getOnlyElement(notes.getApprovals().get(c.currentPatchSetId()));
    assertThat(psa.getAccountId()).isEqualTo(otherUserId);
    assertThat(psa.getLabel()).isEqualTo("Not-For-Long");
    assertThat(psa.getValue()).isEqualTo((short) 1);
    update = newUpdate(c, changeOwner);
    update.removeApprovalFor(otherUserId, "Not-For-Long");
    update.commit();
    notes = newNotes(c);
    assertThat(notes.getApprovals()).containsExactlyEntriesIn(ImmutableMultimap.of(psa.getPatchSetId(), new PatchSetApproval(psa.getKey(), (short) 0, update.getWhen())));
    // Add back approval on same label.
    update = newUpdate(c, otherUser);
    update.putApproval("Not-For-Long", (short) 2);
    update.commit();
    notes = newNotes(c);
    psa = Iterables.getOnlyElement(notes.getApprovals().get(c.currentPatchSetId()));
    assertThat(psa.getAccountId()).isEqualTo(otherUserId);
    assertThat(psa.getLabel()).isEqualTo("Not-For-Long");
    assertThat(psa.getValue()).isEqualTo((short) 2);
}
#end_block

#method_before
@Test
public void pushCertificate() throws Exception {
    String pushCert = "certificate version 0.1\n" + "pusher This is not a real push cert\n" + "-----BEGIN PGP SIGNATURE-----\n" + "Version: GnuPG v1\n" + "\n" + "Nor is this a real signature.\n" + "-----END PGP SIGNATURE-----\n";
    // ps2 with push cert
    Change c = newChange();
    PatchSet.Id psId1 = c.currentPatchSetId();
    incrementPatchSet(c);
    PatchSet.Id psId2 = c.currentPatchSetId();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.setPatchSetId(psId2);
    RevCommit commit = tr.commit().message("PS2").create();
    update.setCommit(rw, commit, pushCert);
    update.commit();
    ChangeNotes notes = newNotes(c);
    String note = readNote(notes, commit);
    assertThat(note).isEqualTo(pushCert);
    Map<PatchSet.Id, PatchSet> patchSets = notes.getPatchSets();
    assertThat(patchSets.get(psId1).getPushCertificate()).isNull();
    assertThat(patchSets.get(psId2).getPushCertificate()).isEqualTo(pushCert);
    assertThat(notes.getComments()).isEmpty();
    // comment on ps2
    update = newUpdate(c, changeOwner);
    update.setPatchSetId(psId2);
    Timestamp ts = TimeUtil.nowTs();
    update.putComment(newPublishedComment(psId2, "a.txt", "uuid1", new CommentRange(1, 2, 3, 4), 1, changeOwner, null, ts, "Comment", (short) 1, commit.name()));
    update.commit();
    notes = newNotes(c);
    // TODO(hanwen): test fails. What do we really want to check here?
    assertThat(readNote(notes, commit)).isEqualTo(pushCert + "Revision: " + commit.name() + "\n" + "Patch-set: 2\n" + "File: a.txt\n" + "\n" + "1:2-3:4\n" + ChangeNoteUtil.formatTime(serverIdent, ts) + "\n" + "Author: Change Owner <1@gerrit>\n" + "UUID: uuid1\n" + "Bytes: 7\n" + "Comment\n" + "\n");
    patchSets = notes.getPatchSets();
    assertThat(patchSets.get(psId1).getPushCertificate()).isNull();
    assertThat(patchSets.get(psId2).getPushCertificate()).isEqualTo(pushCert);
    assertThat(notes.getComments()).isNotEmpty();
}
#method_after
@Test
public void pushCertificate() throws Exception {
    String pushCert = "certificate version 0.1\n" + "pusher This is not a real push cert\n" + "-----BEGIN PGP SIGNATURE-----\n" + "Version: GnuPG v1\n" + "\n" + "Nor is this a real signature.\n" + "-----END PGP SIGNATURE-----\n";
    // ps2 with push cert
    Change c = newChange();
    PatchSet.Id psId1 = c.currentPatchSetId();
    incrementPatchSet(c);
    PatchSet.Id psId2 = c.currentPatchSetId();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.setPatchSetId(psId2);
    RevCommit commit = tr.commit().message("PS2").create();
    update.setCommit(rw, commit, pushCert);
    update.commit();
    ChangeNotes notes = newNotes(c);
    String note = readNote(notes, commit);
    if (!testJson()) {
        assertThat(note).isEqualTo(pushCert);
    }
    Map<PatchSet.Id, PatchSet> patchSets = notes.getPatchSets();
    assertThat(patchSets.get(psId1).getPushCertificate()).isNull();
    assertThat(patchSets.get(psId2).getPushCertificate()).isEqualTo(pushCert);
    assertThat(notes.getComments()).isEmpty();
    // comment on ps2
    update = newUpdate(c, changeOwner);
    update.setPatchSetId(psId2);
    Timestamp ts = TimeUtil.nowTs();
    update.putComment(newPublishedComment(psId2, "a.txt", "uuid1", new CommentRange(1, 2, 3, 4), 1, changeOwner, null, ts, "Comment", (short) 1, commit.name()));
    update.commit();
    notes = newNotes(c);
    patchSets = notes.getPatchSets();
    assertThat(patchSets.get(psId1).getPushCertificate()).isNull();
    assertThat(patchSets.get(psId2).getPushCertificate()).isEqualTo(pushCert);
    assertThat(notes.getComments()).isNotEmpty();
    if (!testJson()) {
        assertThat(readNote(notes, commit)).isEqualTo(pushCert + "Revision: " + commit.name() + "\n" + "Patch-set: 2\n" + "File: a.txt\n" + "\n" + "1:2-3:4\n" + ChangeNoteUtil.formatTime(serverIdent, ts) + "\n" + "Author: Change Owner <1@gerrit>\n" + "UUID: uuid1\n" + "Bytes: 7\n" + "Comment\n" + "\n");
    }
}
#end_block

#method_before
@Test
public void patchLineCommentNotesFormatSide1() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, otherUser);
    String uuid1 = "uuid1";
    String uuid2 = "uuid2";
    String uuid3 = "uuid3";
    String message1 = "comment 1";
    String message2 = "comment 2";
    String message3 = "comment 3";
    CommentRange range1 = new CommentRange(1, 1, 2, 1);
    Timestamp time1 = TimeUtil.nowTs();
    Timestamp time2 = TimeUtil.nowTs();
    Timestamp time3 = TimeUtil.nowTs();
    PatchSet.Id psId = c.currentPatchSetId();
    PatchLineComment comment1 = newPublishedComment(psId, "file1", uuid1, range1, range1.getEndLine(), otherUser, null, time1, message1, (short) 1, "abcd1234abcd1234abcd1234abcd1234abcd1234");
    update.setPatchSetId(psId);
    update.putComment(comment1);
    update.commit();
    update = newUpdate(c, otherUser);
    CommentRange range2 = new CommentRange(2, 1, 3, 1);
    PatchLineComment comment2 = newPublishedComment(psId, "file1", uuid2, range2, range2.getEndLine(), otherUser, null, time2, message2, (short) 1, "abcd1234abcd1234abcd1234abcd1234abcd1234");
    update.setPatchSetId(psId);
    update.putComment(comment2);
    update.commit();
    update = newUpdate(c, otherUser);
    CommentRange range3 = new CommentRange(3, 0, 4, 1);
    PatchLineComment comment3 = newPublishedComment(psId, "file2", uuid3, range3, range3.getEndLine(), otherUser, null, time3, message3, (short) 1, "abcd1234abcd1234abcd1234abcd1234abcd1234");
    update.setPatchSetId(psId);
    update.putComment(comment3);
    update.commit();
    ChangeNotes notes = newNotes(c);
    try (RevWalk walk = new RevWalk(repo)) {
        ArrayList<Note> notesInTree = Lists.newArrayList(notes.revisionNoteMap.noteMap.iterator());
        Note note = Iterables.getOnlyElement(notesInTree);
        byte[] bytes = walk.getObjectReader().open(note.getData(), Constants.OBJ_BLOB).getBytes();
        String noteString = new String(bytes, UTF_8);
        // TODO(hanwen): test fails. What do we really want to check here?
        assertThat(noteString).isEqualTo("Revision: abcd1234abcd1234abcd1234abcd1234abcd1234\n" + "Patch-set: 1\n" + "File: file1\n" + "\n" + "1:1-2:1\n" + ChangeNoteUtil.formatTime(serverIdent, time1) + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid1\n" + "Bytes: 9\n" + "comment 1\n" + "\n" + "2:1-3:1\n" + ChangeNoteUtil.formatTime(serverIdent, time2) + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid2\n" + "Bytes: 9\n" + "comment 2\n" + "\n" + "File: file2\n" + "\n" + "3:0-4:1\n" + ChangeNoteUtil.formatTime(serverIdent, time3) + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid3\n" + "Bytes: 9\n" + "comment 3\n" + "\n");
    }
}
#method_after
@Test
public void patchLineCommentNotesFormatSide1() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, otherUser);
    String uuid1 = "uuid1";
    String uuid2 = "uuid2";
    String uuid3 = "uuid3";
    String message1 = "comment 1";
    String message2 = "comment 2";
    String message3 = "comment 3";
    CommentRange range1 = new CommentRange(1, 1, 2, 1);
    Timestamp time1 = TimeUtil.nowTs();
    Timestamp time2 = TimeUtil.nowTs();
    Timestamp time3 = TimeUtil.nowTs();
    PatchSet.Id psId = c.currentPatchSetId();
    PatchLineComment comment1 = newPublishedComment(psId, "file1", uuid1, range1, range1.getEndLine(), otherUser, null, time1, message1, (short) 1, "abcd1234abcd1234abcd1234abcd1234abcd1234");
    update.setPatchSetId(psId);
    update.putComment(comment1);
    update.commit();
    update = newUpdate(c, otherUser);
    CommentRange range2 = new CommentRange(2, 1, 3, 1);
    PatchLineComment comment2 = newPublishedComment(psId, "file1", uuid2, range2, range2.getEndLine(), otherUser, null, time2, message2, (short) 1, "abcd1234abcd1234abcd1234abcd1234abcd1234");
    update.setPatchSetId(psId);
    update.putComment(comment2);
    update.commit();
    update = newUpdate(c, otherUser);
    CommentRange range3 = new CommentRange(3, 0, 4, 1);
    PatchLineComment comment3 = newPublishedComment(psId, "file2", uuid3, range3, range3.getEndLine(), otherUser, null, time3, message3, (short) 1, "abcd1234abcd1234abcd1234abcd1234abcd1234");
    update.setPatchSetId(psId);
    update.putComment(comment3);
    update.commit();
    ChangeNotes notes = newNotes(c);
    try (RevWalk walk = new RevWalk(repo)) {
        ArrayList<Note> notesInTree = Lists.newArrayList(notes.revisionNoteMap.noteMap.iterator());
        Note note = Iterables.getOnlyElement(notesInTree);
        byte[] bytes = walk.getObjectReader().open(note.getData(), Constants.OBJ_BLOB).getBytes();
        String noteString = new String(bytes, UTF_8);
        if (!testJson()) {
            assertThat(noteString).isEqualTo("Revision: abcd1234abcd1234abcd1234abcd1234abcd1234\n" + "Patch-set: 1\n" + "File: file1\n" + "\n" + "1:1-2:1\n" + ChangeNoteUtil.formatTime(serverIdent, time1) + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid1\n" + "Bytes: 9\n" + "comment 1\n" + "\n" + "2:1-3:1\n" + ChangeNoteUtil.formatTime(serverIdent, time2) + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid2\n" + "Bytes: 9\n" + "comment 2\n" + "\n" + "File: file2\n" + "\n" + "3:0-4:1\n" + ChangeNoteUtil.formatTime(serverIdent, time3) + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid3\n" + "Bytes: 9\n" + "comment 3\n" + "\n");
        }
    }
}
#end_block

#method_before
@Test
public void patchLineCommentNotesFormatSide0() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, otherUser);
    String uuid1 = "uuid1";
    String uuid2 = "uuid2";
    String message1 = "comment 1";
    String message2 = "comment 2";
    CommentRange range1 = new CommentRange(1, 1, 2, 1);
    Timestamp time1 = TimeUtil.nowTs();
    Timestamp time2 = TimeUtil.nowTs();
    PatchSet.Id psId = c.currentPatchSetId();
    PatchLineComment comment1 = newPublishedComment(psId, "file1", uuid1, range1, range1.getEndLine(), otherUser, null, time1, message1, (short) 0, "abcd1234abcd1234abcd1234abcd1234abcd1234");
    update.setPatchSetId(psId);
    update.putComment(comment1);
    update.commit();
    update = newUpdate(c, otherUser);
    CommentRange range2 = new CommentRange(2, 1, 3, 1);
    PatchLineComment comment2 = newPublishedComment(psId, "file1", uuid2, range2, range2.getEndLine(), otherUser, null, time2, message2, (short) 0, "abcd1234abcd1234abcd1234abcd1234abcd1234");
    update.setPatchSetId(psId);
    update.putComment(comment2);
    update.commit();
    ChangeNotes notes = newNotes(c);
    try (RevWalk walk = new RevWalk(repo)) {
        ArrayList<Note> notesInTree = Lists.newArrayList(notes.revisionNoteMap.noteMap.iterator());
        Note note = Iterables.getOnlyElement(notesInTree);
        byte[] bytes = walk.getObjectReader().open(note.getData(), Constants.OBJ_BLOB).getBytes();
        String noteString = new String(bytes, UTF_8);
        // TODO(hanwen): test fails. What do we really want to check here?
        assertThat(noteString).isEqualTo("Revision: abcd1234abcd1234abcd1234abcd1234abcd1234\n" + "Base-for-patch-set: 1\n" + "File: file1\n" + "\n" + "1:1-2:1\n" + ChangeNoteUtil.formatTime(serverIdent, time1) + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid1\n" + "Bytes: 9\n" + "comment 1\n" + "\n" + "2:1-3:1\n" + ChangeNoteUtil.formatTime(serverIdent, time2) + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid2\n" + "Bytes: 9\n" + "comment 2\n" + "\n");
    }
}
#method_after
@Test
public void patchLineCommentNotesFormatSide0() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, otherUser);
    String uuid1 = "uuid1";
    String uuid2 = "uuid2";
    String message1 = "comment 1";
    String message2 = "comment 2";
    CommentRange range1 = new CommentRange(1, 1, 2, 1);
    Timestamp time1 = TimeUtil.nowTs();
    Timestamp time2 = TimeUtil.nowTs();
    PatchSet.Id psId = c.currentPatchSetId();
    PatchLineComment comment1 = newPublishedComment(psId, "file1", uuid1, range1, range1.getEndLine(), otherUser, null, time1, message1, (short) 0, "abcd1234abcd1234abcd1234abcd1234abcd1234");
    update.setPatchSetId(psId);
    update.putComment(comment1);
    update.commit();
    update = newUpdate(c, otherUser);
    CommentRange range2 = new CommentRange(2, 1, 3, 1);
    PatchLineComment comment2 = newPublishedComment(psId, "file1", uuid2, range2, range2.getEndLine(), otherUser, null, time2, message2, (short) 0, "abcd1234abcd1234abcd1234abcd1234abcd1234");
    update.setPatchSetId(psId);
    update.putComment(comment2);
    update.commit();
    ChangeNotes notes = newNotes(c);
    try (RevWalk walk = new RevWalk(repo)) {
        ArrayList<Note> notesInTree = Lists.newArrayList(notes.revisionNoteMap.noteMap.iterator());
        Note note = Iterables.getOnlyElement(notesInTree);
        byte[] bytes = walk.getObjectReader().open(note.getData(), Constants.OBJ_BLOB).getBytes();
        String noteString = new String(bytes, UTF_8);
        if (!testJson()) {
            assertThat(noteString).isEqualTo("Revision: abcd1234abcd1234abcd1234abcd1234abcd1234\n" + "Base-for-patch-set: 1\n" + "File: file1\n" + "\n" + "1:1-2:1\n" + ChangeNoteUtil.formatTime(serverIdent, time1) + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid1\n" + "Bytes: 9\n" + "comment 1\n" + "\n" + "2:1-3:1\n" + ChangeNoteUtil.formatTime(serverIdent, time2) + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid2\n" + "Bytes: 9\n" + "comment 2\n" + "\n");
        }
    }
}
#end_block

#method_before
@Test
public void patchLineCommentNotesFormatMultiplePatchSetsSameRevId() throws Exception {
    Change c = newChange();
    String uuid1 = "uuid1";
    String uuid2 = "uuid2";
    String uuid3 = "uuid3";
    String message1 = "comment 1";
    String message2 = "comment 2";
    String message3 = "comment 3";
    CommentRange range1 = new CommentRange(1, 1, 2, 1);
    CommentRange range2 = new CommentRange(2, 1, 3, 1);
    Timestamp time = TimeUtil.nowTs();
    RevId revId = new RevId("abcd1234abcd1234abcd1234abcd1234abcd1234");
    PatchSet.Id psId1 = c.currentPatchSetId();
    PatchSet.Id psId2 = new PatchSet.Id(c.getId(), psId1.get() + 1);
    PatchLineComment comment1 = newPublishedComment(psId1, "file1", uuid1, range1, range1.getEndLine(), otherUser, null, time, message1, (short) 0, revId.get());
    PatchLineComment comment2 = newPublishedComment(psId1, "file1", uuid2, range2, range2.getEndLine(), otherUser, null, time, message2, (short) 0, revId.get());
    PatchLineComment comment3 = newPublishedComment(psId2, "file1", uuid3, range1, range1.getEndLine(), otherUser, null, time, message3, (short) 0, revId.get());
    ChangeUpdate update = newUpdate(c, otherUser);
    update.setPatchSetId(psId2);
    update.putComment(comment3);
    update.putComment(comment2);
    update.putComment(comment1);
    update.commit();
    ChangeNotes notes = newNotes(c);
    try (RevWalk walk = new RevWalk(repo)) {
        ArrayList<Note> notesInTree = Lists.newArrayList(notes.revisionNoteMap.noteMap.iterator());
        Note note = Iterables.getOnlyElement(notesInTree);
        byte[] bytes = walk.getObjectReader().open(note.getData(), Constants.OBJ_BLOB).getBytes();
        String noteString = new String(bytes, UTF_8);
        String timeStr = ChangeNoteUtil.formatTime(serverIdent, time);
        // TODO(hanwen): test fails. What do we really want to check here?
        assertThat(noteString).isEqualTo("Revision: abcd1234abcd1234abcd1234abcd1234abcd1234\n" + "Base-for-patch-set: 1\n" + "File: file1\n" + "\n" + "1:1-2:1\n" + timeStr + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid1\n" + "Bytes: 9\n" + "comment 1\n" + "\n" + "2:1-3:1\n" + timeStr + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid2\n" + "Bytes: 9\n" + "comment 2\n" + "\n" + "Base-for-patch-set: 2\n" + "File: file1\n" + "\n" + "1:1-2:1\n" + timeStr + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid3\n" + "Bytes: 9\n" + "comment 3\n" + "\n");
    }
    assertThat(notes.getComments()).isEqualTo(ImmutableMultimap.of(revId, comment1, revId, comment2, revId, comment3));
}
#method_after
@Test
public void patchLineCommentNotesFormatMultiplePatchSetsSameRevId() throws Exception {
    Change c = newChange();
    String uuid1 = "uuid1";
    String uuid2 = "uuid2";
    String uuid3 = "uuid3";
    String message1 = "comment 1";
    String message2 = "comment 2";
    String message3 = "comment 3";
    CommentRange range1 = new CommentRange(1, 1, 2, 1);
    CommentRange range2 = new CommentRange(2, 1, 3, 1);
    Timestamp time = TimeUtil.nowTs();
    RevId revId = new RevId("abcd1234abcd1234abcd1234abcd1234abcd1234");
    PatchSet.Id psId1 = c.currentPatchSetId();
    PatchSet.Id psId2 = new PatchSet.Id(c.getId(), psId1.get() + 1);
    PatchLineComment comment1 = newPublishedComment(psId1, "file1", uuid1, range1, range1.getEndLine(), otherUser, null, time, message1, (short) 0, revId.get());
    PatchLineComment comment2 = newPublishedComment(psId1, "file1", uuid2, range2, range2.getEndLine(), otherUser, null, time, message2, (short) 0, revId.get());
    PatchLineComment comment3 = newPublishedComment(psId2, "file1", uuid3, range1, range1.getEndLine(), otherUser, null, time, message3, (short) 0, revId.get());
    ChangeUpdate update = newUpdate(c, otherUser);
    update.setPatchSetId(psId2);
    update.putComment(comment3);
    update.putComment(comment2);
    update.putComment(comment1);
    update.commit();
    ChangeNotes notes = newNotes(c);
    try (RevWalk walk = new RevWalk(repo)) {
        ArrayList<Note> notesInTree = Lists.newArrayList(notes.revisionNoteMap.noteMap.iterator());
        Note note = Iterables.getOnlyElement(notesInTree);
        byte[] bytes = walk.getObjectReader().open(note.getData(), Constants.OBJ_BLOB).getBytes();
        String noteString = new String(bytes, UTF_8);
        String timeStr = ChangeNoteUtil.formatTime(serverIdent, time);
        if (!testJson()) {
            assertThat(noteString).isEqualTo("Revision: abcd1234abcd1234abcd1234abcd1234abcd1234\n" + "Base-for-patch-set: 1\n" + "File: file1\n" + "\n" + "1:1-2:1\n" + timeStr + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid1\n" + "Bytes: 9\n" + "comment 1\n" + "\n" + "2:1-3:1\n" + timeStr + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid2\n" + "Bytes: 9\n" + "comment 2\n" + "\n" + "Base-for-patch-set: 2\n" + "File: file1\n" + "\n" + "1:1-2:1\n" + timeStr + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid3\n" + "Bytes: 9\n" + "comment 3\n" + "\n");
        }
    }
    assertThat(notes.getComments()).isEqualTo(ImmutableMultimap.of(revId, comment1, revId, comment2, revId, comment3));
}
#end_block

#method_before
@Test
public void patchLineCommentNotesFormatWeirdUser() throws Exception {
    Account account = new Account(new Account.Id(3), TimeUtil.nowTs());
    account.setFullName("Weird\n\u0002<User>\n");
    account.setPreferredEmail(" we\r\nird@ex>ample<.com");
    accountCache.put(account);
    IdentifiedUser user = userFactory.create(account.getId());
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, user);
    String uuid = "uuid";
    CommentRange range = new CommentRange(1, 1, 2, 1);
    Timestamp time = TimeUtil.nowTs();
    PatchSet.Id psId = c.currentPatchSetId();
    PatchLineComment comment = newPublishedComment(psId, "file1", uuid, range, range.getEndLine(), user, null, time, "comment", (short) 1, "abcd1234abcd1234abcd1234abcd1234abcd1234");
    update.setPatchSetId(psId);
    update.putComment(comment);
    update.commit();
    ChangeNotes notes = newNotes(c);
    try (RevWalk walk = new RevWalk(repo)) {
        ArrayList<Note> notesInTree = Lists.newArrayList(notes.revisionNoteMap.noteMap.iterator());
        Note note = Iterables.getOnlyElement(notesInTree);
        byte[] bytes = walk.getObjectReader().open(note.getData(), Constants.OBJ_BLOB).getBytes();
        String noteString = new String(bytes, UTF_8);
        String timeStr = ChangeNoteUtil.formatTime(serverIdent, time);
        // TODO(hanwen): test fails. What do we really want to check here?
        assertThat(noteString).isEqualTo("Revision: abcd1234abcd1234abcd1234abcd1234abcd1234\n" + "Patch-set: 1\n" + "File: file1\n" + "\n" + "1:1-2:1\n" + timeStr + "\n" + "Author: Weird\u0002User <3@gerrit>\n" + "UUID: uuid\n" + "Bytes: 7\n" + "comment\n" + "\n");
    }
    assertThat(notes.getComments()).isEqualTo(ImmutableMultimap.of(comment.getRevId(), comment));
}
#method_after
@Test
public void patchLineCommentNotesFormatWeirdUser() throws Exception {
    Account account = new Account(new Account.Id(3), TimeUtil.nowTs());
    account.setFullName("Weird\n\u0002<User>\n");
    account.setPreferredEmail(" we\r\nird@ex>ample<.com");
    accountCache.put(account);
    IdentifiedUser user = userFactory.create(account.getId());
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, user);
    String uuid = "uuid";
    CommentRange range = new CommentRange(1, 1, 2, 1);
    Timestamp time = TimeUtil.nowTs();
    PatchSet.Id psId = c.currentPatchSetId();
    PatchLineComment comment = newPublishedComment(psId, "file1", uuid, range, range.getEndLine(), user, null, time, "comment", (short) 1, "abcd1234abcd1234abcd1234abcd1234abcd1234");
    update.setPatchSetId(psId);
    update.putComment(comment);
    update.commit();
    ChangeNotes notes = newNotes(c);
    try (RevWalk walk = new RevWalk(repo)) {
        ArrayList<Note> notesInTree = Lists.newArrayList(notes.revisionNoteMap.noteMap.iterator());
        Note note = Iterables.getOnlyElement(notesInTree);
        byte[] bytes = walk.getObjectReader().open(note.getData(), Constants.OBJ_BLOB).getBytes();
        String noteString = new String(bytes, UTF_8);
        String timeStr = ChangeNoteUtil.formatTime(serverIdent, time);
        if (!testJson()) {
            assertThat(noteString).isEqualTo("Revision: abcd1234abcd1234abcd1234abcd1234abcd1234\n" + "Patch-set: 1\n" + "File: file1\n" + "\n" + "1:1-2:1\n" + timeStr + "\n" + "Author: Weird\u0002User <3@gerrit>\n" + "UUID: uuid\n" + "Bytes: 7\n" + "comment\n" + "\n");
        }
    }
    assertThat(notes.getComments()).isEqualTo(ImmutableMultimap.of(comment.getRevId(), comment));
}
#end_block

#method_before
@Test
public void patchLineCommentsDeleteAllDrafts() throws Exception {
    Change c = newChange();
    String uuid = "uuid";
    String rev = "abcd1234abcd1234abcd1234abcd1234abcd1234";
    ObjectId objId = ObjectId.fromString(rev);
    CommentRange range = new CommentRange(1, 1, 2, 1);
    PatchSet.Id psId = c.currentPatchSetId();
    String filename = "filename";
    short side = (short) 1;
    ChangeUpdate update = newUpdate(c, otherUser);
    Timestamp now = TimeUtil.nowTs();
    PatchLineComment comment = newComment(psId, filename, uuid, range, range.getEndLine(), otherUser, null, now, "comment on ps1", side, rev, Status.DRAFT);
    update.setPatchSetId(psId);
    update.putComment(comment);
    update.commit();
    ChangeNotes notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId)).hasSize(1);
    assertThat(notes.getDraftCommentNotes().getNoteMap().contains(objId)).isTrue();
    update = newUpdate(c, otherUser);
    now = TimeUtil.nowTs();
    update.setPatchSetId(psId);
    update.deleteComment(comment);
    update.commit();
    notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId)).isEmpty();
    // TODO
    assertThat(notes.getDraftCommentNotes().getNoteMap()).isNull();
}
#method_after
@Test
public void patchLineCommentsDeleteAllDrafts() throws Exception {
    Change c = newChange();
    String uuid = "uuid";
    String rev = "abcd1234abcd1234abcd1234abcd1234abcd1234";
    ObjectId objId = ObjectId.fromString(rev);
    CommentRange range = new CommentRange(1, 1, 2, 1);
    PatchSet.Id psId = c.currentPatchSetId();
    String filename = "filename";
    short side = (short) 1;
    ChangeUpdate update = newUpdate(c, otherUser);
    Timestamp now = TimeUtil.nowTs();
    PatchLineComment comment = newComment(psId, filename, uuid, range, range.getEndLine(), otherUser, null, now, "comment on ps1", side, rev, Status.DRAFT);
    update.setPatchSetId(psId);
    update.putComment(comment);
    update.commit();
    ChangeNotes notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId)).hasSize(1);
    assertThat(notes.getDraftCommentNotes().getNoteMap().contains(objId)).isTrue();
    update = newUpdate(c, otherUser);
    now = TimeUtil.nowTs();
    update.setPatchSetId(psId);
    update.deleteComment(comment);
    update.commit();
    notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId)).isEmpty();
    assertThat(notes.getDraftCommentNotes().getNoteMap()).isNull();
}
#end_block

#method_before
public List<PatchLineComment> parseNote(byte[] note, MutableInteger p, Change.Id changeId, Status status) throws ConfigInvalidException {
    if (p.value >= note.length) {
        return ImmutableList.of();
    }
    Set<PatchLineComment.Key> seen = new HashSet<>();
    List<PatchLineComment> result = new ArrayList<>();
    int sizeOfNote = note.length;
    byte[] psb = PATCH_SET.getBytes(UTF_8);
    byte[] bpsb = BASE_PATCH_SET.getBytes(UTF_8);
    byte[] bpn = PARENT_NUMBER.getBytes(UTF_8);
    if (note[p.value] == '{' || note[p.value] == '[') {
        return parseNoteJSON(note, p);
    }
    RevId revId = new RevId(parseStringField(note, p, changeId, REVISION));
    String fileName = null;
    PatchSet.Id psId = null;
    boolean isForBase = false;
    Integer parentNumber = null;
    while (p.value < sizeOfNote) {
        boolean matchPs = match(note, p, psb);
        boolean matchBase = match(note, p, bpsb);
        if (matchPs) {
            fileName = null;
            psId = parsePsId(note, p, changeId, PATCH_SET);
            isForBase = false;
        } else if (matchBase) {
            fileName = null;
            psId = parsePsId(note, p, changeId, BASE_PATCH_SET);
            isForBase = true;
            if (match(note, p, bpn)) {
                parentNumber = parseParentNumber(note, p, changeId);
            }
        } else if (psId == null) {
            throw parseException(changeId, "missing %s or %s header", PATCH_SET, BASE_PATCH_SET);
        }
        PatchLineComment c = parseComment(note, p, fileName, psId, revId, isForBase, parentNumber, status);
        fileName = c.getKey().getParentKey().getFileName();
        if (!seen.add(c.getKey())) {
            throw parseException(changeId, "multiple comments for %s in note", c.getKey());
        }
        result.add(c);
    }
    return result;
}
#method_after
public List<PatchLineComment> parseNote(byte[] note, MutableInteger p, Change.Id changeId, Status status) throws ConfigInvalidException {
    if (p.value >= note.length) {
        return ImmutableList.of();
    }
    Set<PatchLineComment.Key> seen = new HashSet<>();
    List<PatchLineComment> result = new ArrayList<>();
    int sizeOfNote = note.length;
    byte[] psb = PATCH_SET.getBytes(UTF_8);
    byte[] bpsb = BASE_PATCH_SET.getBytes(UTF_8);
    byte[] bpn = PARENT_NUMBER.getBytes(UTF_8);
    RevId revId = new RevId(parseStringField(note, p, changeId, REVISION));
    String fileName = null;
    PatchSet.Id psId = null;
    boolean isForBase = false;
    Integer parentNumber = null;
    while (p.value < sizeOfNote) {
        boolean matchPs = match(note, p, psb);
        boolean matchBase = match(note, p, bpsb);
        if (matchPs) {
            fileName = null;
            psId = parsePsId(note, p, changeId, PATCH_SET);
            isForBase = false;
        } else if (matchBase) {
            fileName = null;
            psId = parsePsId(note, p, changeId, BASE_PATCH_SET);
            isForBase = true;
            if (match(note, p, bpn)) {
                parentNumber = parseParentNumber(note, p, changeId);
            }
        } else if (psId == null) {
            throw parseException(changeId, "missing %s or %s header", PATCH_SET, BASE_PATCH_SET);
        }
        PatchLineComment c = parseComment(note, p, fileName, psId, revId, isForBase, parentNumber, status);
        fileName = c.getKey().getParentKey().getFileName();
        if (!seen.add(c.getKey())) {
            throw parseException(changeId, "multiple comments for %s in note", c.getKey());
        }
        result.add(c);
    }
    return result;
}
#end_block

#method_before
void buildNote(Multimap<PatchSet.Id, PatchLineComment> comments, OutputStream out) {
    if (gson != null) {
        buildNoteJSON(comments, out);
        return;
    }
    if (comments.isEmpty()) {
        return;
    }
    List<PatchSet.Id> psIds = ReviewDbUtil.intKeyOrdering().sortedCopy(comments.keySet());
    OutputStreamWriter streamWriter = new OutputStreamWriter(out, UTF_8);
    try (PrintWriter writer = new PrintWriter(streamWriter)) {
        RevId revId = comments.values().iterator().next().getRevId();
        appendHeaderField(writer, REVISION, revId.get());
        for (PatchSet.Id psId : psIds) {
            List<PatchLineComment> psComments = PLC_ORDER.sortedCopy(comments.get(psId));
            PatchLineComment first = psComments.get(0);
            short side = first.getSide();
            appendHeaderField(writer, side <= 0 ? BASE_PATCH_SET : PATCH_SET, Integer.toString(psId.get()));
            if (side < 0) {
                appendHeaderField(writer, PARENT_NUMBER, Integer.toString(-side));
            }
            String currentFilename = null;
            for (PatchLineComment c : psComments) {
                checkArgument(revId.equals(c.getRevId()), "All comments being added must have all the same RevId. The " + "comment below does not have the same RevId as the others " + "(%s).\n%s", revId, c);
                checkArgument(side == c.getSide(), "All comments being added must all have the same side. The " + "comment below does not have the same side as the others " + "(%s).\n%s", side, c);
                String commentFilename = QuotedString.GIT_PATH.quote(c.getKey().getParentKey().getFileName());
                if (!commentFilename.equals(currentFilename)) {
                    currentFilename = commentFilename;
                    writer.print("File: ");
                    writer.print(commentFilename);
                    writer.print("\n\n");
                }
                appendOneComment(writer, c);
            }
        }
    }
}
#method_after
void buildNote(Multimap<PatchSet.Id, PatchLineComment> comments, OutputStream out) {
    if (comments.isEmpty()) {
        return;
    }
    List<PatchSet.Id> psIds = ReviewDbUtil.intKeyOrdering().sortedCopy(comments.keySet());
    OutputStreamWriter streamWriter = new OutputStreamWriter(out, UTF_8);
    try (PrintWriter writer = new PrintWriter(streamWriter)) {
        RevId revId = comments.values().iterator().next().getRevId();
        appendHeaderField(writer, REVISION, revId.get());
        for (PatchSet.Id psId : psIds) {
            List<PatchLineComment> psComments = PLC_ORDER.sortedCopy(comments.get(psId));
            PatchLineComment first = psComments.get(0);
            short side = first.getSide();
            appendHeaderField(writer, side <= 0 ? BASE_PATCH_SET : PATCH_SET, Integer.toString(psId.get()));
            if (side < 0) {
                appendHeaderField(writer, PARENT_NUMBER, Integer.toString(-side));
            }
            String currentFilename = null;
            for (PatchLineComment c : psComments) {
                checkArgument(revId.equals(c.getRevId()), "All comments being added must have all the same RevId. The " + "comment below does not have the same RevId as the others " + "(%s).\n%s", revId, c);
                checkArgument(side == c.getSide(), "All comments being added must all have the same side. The " + "comment below does not have the same side as the others " + "(%s).\n%s", side, c);
                String commentFilename = QuotedString.GIT_PATH.quote(c.getKey().getParentKey().getFileName());
                if (!commentFilename.equals(currentFilename)) {
                    currentFilename = commentFilename;
                    writer.print("File: ");
                    writer.print(commentFilename);
                    writer.print("\n\n");
                }
                appendOneComment(writer, c);
            }
        }
    }
}
#end_block

#method_before
public static Set<String> fields(Schema<ChangeData> schema, QueryOptions opts) {
    // Ensure we request enough fields to construct a ChangeData.
    Set<String> fs = opts.fields();
    if (fs.contains(CHANGE.getName())) {
        // A Change is always sufficient.
        return fs;
    }
    if (!schema.hasField(PROJECT)) {
        // field, and call createOnlyWhenNoteDbDisabled from toChangeData below.
        if (fs.contains(LEGACY_ID.getName())) {
            return fs;
        }
        return Sets.union(fs, ImmutableSet.of(LEGACY_ID.getName()));
    }
    // New enough schema to have project field, so ensure that is requested.
    if (fs.contains(PROJECT.getName()) && fs.contains(LEGACY_ID.getName())) {
        return fs;
    }
    return Sets.union(fs, ImmutableSet.of(LEGACY_ID.getName(), PROJECT.getName()));
}
#method_after
public static Set<String> fields(QueryOptions opts) {
    // Ensure we request enough fields to construct a ChangeData. We need both
    // change ID and project, which can either come via the Change field or
    // separate fields.
    Set<String> fs = opts.fields();
    if (fs.contains(CHANGE.getName())) {
        // A Change is always sufficient.
        return fs;
    }
    if (fs.contains(PROJECT.getName()) && fs.contains(LEGACY_ID.getName())) {
        return fs;
    }
    return Sets.union(fs, ImmutableSet.of(LEGACY_ID.getName(), PROJECT.getName()));
}
#end_block

#method_before
@Override
protected String getMappings() {
    return "{\"mappings\" : " + getMappingProperties("open_changes") + "," + getMappingProperties("closed_changes") + "}";
}
#method_after
@Override
protected String getMappings() {
    return gson.toJson(ImmutableMap.of("mappings", mapping));
}
#end_block

#method_before
@Override
public void close() {
    MoreExecutors.shutdownAndAwaitTermination(executor, Long.MAX_VALUE, TimeUnit.SECONDS);
    try {
        openIndex.close();
    } finally {
        closedIndex.close();
    }
}
#method_after
@Override
public void close() {
    List<ListenableFuture<?>> closeFutures = Lists.newArrayListWithCapacity(2);
    closeFutures.add(executor.submit(new Runnable() {

        @Override
        public void run() {
            openIndex.close();
        }
    }));
    closeFutures.add(executor.submit(new Runnable() {

        @Override
        public void run() {
            closedIndex.close();
        }
    }));
    Futures.getUnchecked(Futures.allAsList(closeFutures));
}
#end_block

#method_before
@Override
public ResultSet<ChangeData> read() throws OrmException {
    if (Thread.interrupted()) {
        Thread.currentThread().interrupt();
        throw new OrmException("interrupted");
    }
    final Set<String> fields = IndexUtils.fields(schema, opts);
    return new ChangeDataResults(executor.submit(new Callable<List<Document>>() {

        @Override
        public List<Document> call() throws IOException {
            return doRead(fields);
        }

        @Override
        public String toString() {
            return predicate.toString();
        }
    }), fields);
}
#method_after
@Override
public ResultSet<ChangeData> read() throws OrmException {
    if (Thread.interrupted()) {
        Thread.currentThread().interrupt();
        throw new OrmException("interrupted");
    }
    final Set<String> fields = IndexUtils.fields(opts);
    return new ChangeDataResults(executor.submit(new Callable<List<Document>>() {

        @Override
        public List<Document> call() throws IOException {
            return doRead(fields);
        }

        @Override
        public String toString() {
            return predicate.toString();
        }
    }), fields);
}
#end_block

#method_before
private ChangeData toChangeData(Multimap<String, IndexableField> doc, Set<String> fields, String idFieldName) {
    ChangeData cd;
    // Either change or the ID field was guaranteed to be included in the call
    // to fields() above.
    IndexableField cb = Iterables.getFirst(doc.get(CHANGE_FIELD), null);
    if (cb != null) {
        BytesRef proto = cb.binaryValue();
        cd = changeDataFactory.create(db.get(), ChangeProtoField.CODEC.decode(proto.bytes, proto.offset, proto.length));
    } else {
        IndexableField f = Iterables.getFirst(doc.get(idFieldName), null);
        Change.Id id = new Change.Id(f.numericValue().intValue());
        IndexableField project = Iterables.getFirst(doc.get(PROJECT.getName()), null);
        if (project == null) {
            // Old schema without project field: we can safely assume NoteDb is
            // disabled.
            cd = changeDataFactory.createOnlyWhenNoteDbDisabled(db.get(), id);
        } else {
            cd = changeDataFactory.create(db.get(), new Project.NameKey(project.stringValue()), id);
        }
    }
    if (fields.contains(PATCH_SET_FIELD)) {
        decodePatchSets(doc, cd);
    }
    if (fields.contains(APPROVAL_FIELD)) {
        decodeApprovals(doc, cd);
    }
    if (fields.contains(ADDED_FIELD) && fields.contains(DELETED_FIELD)) {
        decodeChangedLines(doc, cd);
    }
    if (fields.contains(MERGEABLE_FIELD)) {
        decodeMergeable(doc, cd);
    }
    if (fields.contains(REVIEWEDBY_FIELD)) {
        decodeReviewedBy(doc, cd);
    }
    if (fields.contains(HASHTAG_FIELD)) {
        decodeHashtags(doc, cd);
    }
    if (fields.contains(STARREDBY_FIELD)) {
        decodeStarredBy(doc, cd);
    }
    if (fields.contains(STAR_FIELD)) {
        decodeStar(doc, cd);
    }
    if (fields.contains(REVIEWER_FIELD)) {
        decodeReviewers(doc, cd);
    }
    return cd;
}
#method_after
private ChangeData toChangeData(Multimap<String, IndexableField> doc, Set<String> fields, String idFieldName) {
    ChangeData cd;
    // Either change or the ID field was guaranteed to be included in the call
    // to fields() above.
    IndexableField cb = Iterables.getFirst(doc.get(CHANGE_FIELD), null);
    if (cb != null) {
        BytesRef proto = cb.binaryValue();
        cd = changeDataFactory.create(db.get(), ChangeProtoField.CODEC.decode(proto.bytes, proto.offset, proto.length));
    } else {
        IndexableField f = Iterables.getFirst(doc.get(idFieldName), null);
        Change.Id id = new Change.Id(f.numericValue().intValue());
        IndexableField project = Iterables.getFirst(doc.get(PROJECT.getName()), null);
        if (project == null) {
            // Old schema without project field: we can safely assume NoteDb is
            // disabled.
            cd = changeDataFactory.createOnlyWhenNoteDbDisabled(db.get(), id);
        } else {
            cd = changeDataFactory.create(db.get(), new Project.NameKey(project.stringValue()), id);
        }
    }
    if (fields.contains(PATCH_SET_FIELD)) {
        decodePatchSets(doc, cd);
    }
    if (fields.contains(APPROVAL_FIELD)) {
        decodeApprovals(doc, cd);
    }
    if (fields.contains(ADDED_FIELD) && fields.contains(DELETED_FIELD)) {
        decodeChangedLines(doc, cd);
    }
    if (fields.contains(MERGEABLE_FIELD)) {
        decodeMergeable(doc, cd);
    }
    if (fields.contains(REVIEWEDBY_FIELD)) {
        decodeReviewedBy(doc, cd);
    }
    if (fields.contains(HASHTAG_FIELD)) {
        decodeHashtags(doc, cd);
    }
    if (fields.contains(STAR_FIELD)) {
        decodeStar(doc, cd);
    }
    if (fields.contains(REVIEWER_FIELD)) {
        decodeReviewers(doc, cd);
    }
    return cd;
}
#end_block

#method_before
public final boolean canEdit(Account.FieldName f) {
    return editableAccountFields().contains(f);
}
#method_after
public final boolean canEdit(AccountFieldName f) {
    return editableAccountFields().contains(f);
}
#end_block

#method_before
public final List<Account.FieldName> editableAccountFields() {
    List<Account.FieldName> fields = new ArrayList<>();
    for (String f : Natives.asList(_editableAccountFields())) {
        fields.add(Account.FieldName.valueOf(f));
    }
    return fields;
}
#method_after
public final List<AccountFieldName> editableAccountFields() {
    List<AccountFieldName> fields = new ArrayList<>();
    for (String f : Natives.asList(_editableAccountFields())) {
        fields.add(AccountFieldName.valueOf(f));
    }
    return fields;
}
#end_block

#method_before
public final boolean siteHasUsernames() {
    if (isCustomExtension() && httpPasswordUrl() != null && !canEdit(FieldName.USER_NAME)) {
        return false;
    }
    return true;
}
#method_after
public final boolean siteHasUsernames() {
    if (isCustomExtension() && httpPasswordUrl() != null && !canEdit(AccountFieldName.USER_NAME)) {
        return false;
    }
    return true;
}
#end_block

#method_before
private boolean verify(HttpServletRequest req, Response rsp) throws IOException {
    final String hdr = req.getHeader(AUTHORIZATION);
    if (hdr == null || !hdr.startsWith(LIT_BASIC)) {
        // session cookie instead of basic authentication.
        return true;
    }
    final byte[] decoded = Base64.decodeBase64(hdr.substring(LIT_BASIC.length()));
    String usernamePassword = new String(decoded, encoding(req));
    int splitPos = usernamePassword.indexOf(':');
    if (splitPos < 1) {
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
    String username = usernamePassword.substring(0, splitPos);
    String password = usernamePassword.substring(splitPos + 1);
    if (Strings.isNullOrEmpty(password)) {
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
    if (authConfig.isUserNameToLowerCase()) {
        username = username.toLowerCase(Locale.US);
    }
    final AccountState who = accountCache.getByUsername(username);
    if (who == null || !who.getAccount().isActive()) {
        log.warn("Authentication failed for " + username + ": account inactive or not provisioned in Gerrit");
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
    if (passwordMatchesTheUserGeneratedOne(who, username, password)) {
        setUserIdentified(who.getAccount().getId());
        return true;
    } else if (!authConfig.isLdapAuthType()) {
        log.warn("Authentication failed for {}: password does not match the one" + " stored in Gerrit", username);
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
    AuthRequest whoAuth = AuthRequest.forUser(username);
    whoAuth.setPassword(password);
    try {
        AuthResult whoAuthResult = accountManager.authenticate(whoAuth);
        setUserIdentified(whoAuthResult.getAccountId());
        return true;
    } catch (NoSuchUserException e) {
        if (password.equals(who.getPassword(who.getUserName()))) {
            setUserIdentified(who.getAccount().getId());
            return true;
        }
        log.warn("Authentication failed for " + username, e);
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    } catch (AuthenticationFailedException e) {
        log.warn("Authentication failed for " + username + ": " + e.getMessage());
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    } catch (AccountException e) {
        log.warn("Authentication failed for " + username, e);
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
}
#method_after
private boolean verify(HttpServletRequest req, Response rsp) throws IOException {
    final String hdr = req.getHeader(AUTHORIZATION);
    if (hdr == null || !hdr.startsWith(LIT_BASIC)) {
        // session cookie instead of basic authentication.
        return true;
    }
    final byte[] decoded = Base64.decodeBase64(hdr.substring(LIT_BASIC.length()));
    String usernamePassword = new String(decoded, encoding(req));
    int splitPos = usernamePassword.indexOf(':');
    if (splitPos < 1) {
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
    String username = usernamePassword.substring(0, splitPos);
    String password = usernamePassword.substring(splitPos + 1);
    if (Strings.isNullOrEmpty(password)) {
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
    if (authConfig.isUserNameToLowerCase()) {
        username = username.toLowerCase(Locale.US);
    }
    final AccountState who = accountCache.getByUsername(username);
    if (who == null || !who.getAccount().isActive()) {
        log.warn("Authentication failed for " + username + ": account inactive or not provisioned in Gerrit");
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
    GitBasicAuthPolicy gitBasicAuthPolicy = authConfig.getGitBasicAuthPolicy();
    if (gitBasicAuthPolicy == GitBasicAuthPolicy.HTTP || gitBasicAuthPolicy == GitBasicAuthPolicy.HTTP_LDAP) {
        if (passwordMatchesTheUserGeneratedOne(who, username, password)) {
            return succeedAuthentication(who);
        }
    }
    if (gitBasicAuthPolicy == GitBasicAuthPolicy.HTTP) {
        return failAuthentication(rsp, username);
    }
    AuthRequest whoAuth = AuthRequest.forUser(username);
    whoAuth.setPassword(password);
    try {
        AuthResult whoAuthResult = accountManager.authenticate(whoAuth);
        setUserIdentified(whoAuthResult.getAccountId());
        return true;
    } catch (NoSuchUserException e) {
        if (password.equals(who.getPassword(who.getUserName()))) {
            return succeedAuthentication(who);
        }
        log.warn("Authentication failed for " + username, e);
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    } catch (AuthenticationFailedException e) {
        log.warn("Authentication failed for " + username + ": " + e.getMessage());
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    } catch (AccountException e) {
        log.warn("Authentication failed for " + username, e);
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
}
#end_block

#method_before
private void setUserIdentified(final Account.Id id) {
    WebSession ws = session.get();
    ws.setUserAccountId(id);
    ws.setAccessPathOk(AccessPath.GIT, true);
    ws.setAccessPathOk(AccessPath.REST_API, true);
}
#method_after
private void setUserIdentified(Account.Id id) {
    WebSession ws = session.get();
    ws.setUserAccountId(id);
    ws.setAccessPathOk(AccessPath.GIT, true);
    ws.setAccessPathOk(AccessPath.REST_API, true);
}
#end_block

#method_before
@Override
protected void applyDataRowStyle(final int row) {
    super.applyDataRowStyle(row);
    final CellFormatter fmt = table.getCellFormatter();
    fmt.addStyleName(row, C_STAR, Gerrit.RESOURCES.css().iconCell());
    for (int i = C_ID; i < columns; i++) {
        fmt.addStyleName(row, i, Gerrit.RESOURCES.css().dataCell());
    }
    if (!showLegacyId) {
        fmt.addStyleName(row, C_ID, Gerrit.RESOURCES.css().dataCellHidden());
    }
    fmt.addStyleName(row, C_SUBJECT, Gerrit.RESOURCES.css().cSUBJECT());
    fmt.addStyleName(row, C_STATUS, Gerrit.RESOURCES.css().cSTATUS());
    fmt.addStyleName(row, C_OWNER, Gerrit.RESOURCES.css().cOWNER());
    fmt.addStyleName(row, C_ASSIGNEE, Gerrit.info().change().showAssignee() ? Gerrit.RESOURCES.css().cASSIGNEE() : Gerrit.RESOURCES.css().dataCellHidden());
    fmt.addStyleName(row, C_LAST_UPDATE, Gerrit.RESOURCES.css().cLastUpdate());
    fmt.addStyleName(row, C_SIZE, Gerrit.RESOURCES.css().cSIZE());
    for (int i = C_SIZE + 1; i < columns; i++) {
        fmt.addStyleName(row, i, Gerrit.RESOURCES.css().cAPPROVAL());
    }
}
#method_after
@Override
protected void applyDataRowStyle(final int row) {
    super.applyDataRowStyle(row);
    final CellFormatter fmt = table.getCellFormatter();
    fmt.addStyleName(row, C_STAR, Gerrit.RESOURCES.css().iconCell());
    for (int i = C_ID; i < columns; i++) {
        fmt.addStyleName(row, i, Gerrit.RESOURCES.css().dataCell());
    }
    if (!showLegacyId) {
        fmt.addStyleName(row, C_ID, Gerrit.RESOURCES.css().dataCellHidden());
    }
    fmt.addStyleName(row, C_SUBJECT, Gerrit.RESOURCES.css().cSUBJECT());
    fmt.addStyleName(row, C_STATUS, Gerrit.RESOURCES.css().cSTATUS());
    fmt.addStyleName(row, C_OWNER, Gerrit.RESOURCES.css().cOWNER());
    fmt.addStyleName(row, C_ASSIGNEE, showAssignee ? Gerrit.RESOURCES.css().cASSIGNEE() : Gerrit.RESOURCES.css().dataCellHidden());
    fmt.addStyleName(row, C_LAST_UPDATE, Gerrit.RESOURCES.css().cLastUpdate());
    fmt.addStyleName(row, C_SIZE, Gerrit.RESOURCES.css().cSIZE());
    for (int i = C_SIZE + 1; i < columns; i++) {
        fmt.addStyleName(row, i, Gerrit.RESOURCES.css().cAPPROVAL());
    }
}
#end_block

#method_before
private void populateChangeRow(final int row, final ChangeInfo c, boolean highlightUnreviewed) {
    CellFormatter fmt = table.getCellFormatter();
    if (Gerrit.isSignedIn()) {
        table.setWidget(row, C_STAR, StarredChanges.createIcon(c.legacyId(), c.starred()));
    }
    table.setWidget(row, C_ID, new TableChangeLink(String.valueOf(c.legacyId()), c));
    String subject = Util.cropSubject(c.subject());
    table.setWidget(row, C_SUBJECT, new TableChangeLink(subject, c));
    Change.Status status = c.status();
    if (status != Change.Status.NEW) {
        table.setText(row, C_STATUS, Util.toLongString(status));
    } else if (!c.mergeable()) {
        table.setText(row, C_STATUS, Util.C.changeTableNotMergeable());
    }
    if (c.owner() != null) {
        table.setWidget(row, C_OWNER, new AccountLinkPanel(c.owner(), status));
    } else {
        table.setText(row, C_OWNER, "");
    }
    if (Gerrit.info().change().showAssignee()) {
        if (c.assignee() != null) {
            table.setWidget(row, C_ASSIGNEE, new AssigneeLinkPanel(c.assignee()));
            if (c.assignee().getId().get() == Gerrit.getUserAccount().getId().get()) {
                table.getRowFormatter().addStyleName(row, Gerrit.RESOURCES.css().cASSIGNEDTOME());
            }
        } else {
            table.setText(row, C_ASSIGNEE, "");
        }
    }
    table.setWidget(row, C_PROJECT, new ProjectLink(c.projectNameKey()));
    table.setWidget(row, C_BRANCH, new BranchLink(c.projectNameKey(), c.status(), c.branch(), c.topic()));
    if (Gerrit.getUserPreferences().relativeDateInChangeTable()) {
        table.setText(row, C_LAST_UPDATE, relativeFormat(c.updated()));
    } else {
        table.setText(row, C_LAST_UPDATE, shortFormat(c.updated()));
    }
    int col = C_SIZE;
    if (!Gerrit.getUserPreferences().sizeBarInChangeTable()) {
        table.setText(row, col, Util.M.insertionsAndDeletions(c.insertions(), c.deletions()));
    } else {
        table.setWidget(row, col, getSizeWidget(c));
        fmt.getElement(row, col).setTitle(Util.M.insertionsAndDeletions(c.insertions(), c.deletions()));
    }
    col++;
    for (int idx = 0; idx < labelNames.size(); idx++, col++) {
        String name = labelNames.get(idx);
        LabelInfo label = c.label(name);
        if (label == null) {
            fmt.getElement(row, col).setTitle(Gerrit.C.labelNotApplicable());
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().labelNotApplicable());
            continue;
        }
        String user;
        String info;
        ReviewCategoryStrategy reviewCategoryStrategy = Gerrit.getUserPreferences().reviewCategoryStrategy();
        if (label.rejected() != null) {
            user = label.rejected().name();
            info = getReviewCategoryDisplayInfo(reviewCategoryStrategy, label.rejected());
            if (info != null) {
                FlowPanel panel = new FlowPanel();
                panel.add(new Image(Gerrit.RESOURCES.redNot()));
                panel.add(new InlineLabel(info));
                table.setWidget(row, col, panel);
            } else {
                table.setWidget(row, col, new Image(Gerrit.RESOURCES.redNot()));
            }
        } else if (label.approved() != null) {
            user = label.approved().name();
            info = getReviewCategoryDisplayInfo(reviewCategoryStrategy, label.approved());
            if (info != null) {
                FlowPanel panel = new FlowPanel();
                panel.add(new Image(Gerrit.RESOURCES.greenCheck()));
                panel.add(new InlineLabel(info));
                table.setWidget(row, col, panel);
            } else {
                table.setWidget(row, col, new Image(Gerrit.RESOURCES.greenCheck()));
            }
        } else if (label.disliked() != null) {
            user = label.disliked().name();
            info = getReviewCategoryDisplayInfo(reviewCategoryStrategy, label.disliked());
            String vstr = String.valueOf(label._value());
            if (info != null) {
                vstr = vstr + " " + info;
            }
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().negscore());
            table.setText(row, col, vstr);
        } else if (label.recommended() != null) {
            user = label.recommended().name();
            info = getReviewCategoryDisplayInfo(reviewCategoryStrategy, label.recommended());
            String vstr = "+" + label._value();
            if (info != null) {
                vstr = vstr + " " + info;
            }
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().posscore());
            table.setText(row, col, vstr);
        } else {
            table.clearCell(row, col);
            continue;
        }
        fmt.addStyleName(row, col, Gerrit.RESOURCES.css().singleLine());
        if (user != null) {
            // Some web browsers ignore the embedded newline; some like it;
            // so we include a space before the newline to accommodate both.
            fmt.getElement(row, col).setTitle(name + " \nby " + user);
        }
    }
    boolean needHighlight = false;
    if (highlightUnreviewed && !c.reviewed()) {
        needHighlight = true;
    }
    final Element tr = fmt.getElement(row, 0).getParentElement();
    UIObject.setStyleName(tr, Gerrit.RESOURCES.css().needsReview(), needHighlight);
    setRowItem(row, c);
}
#method_after
private void populateChangeRow(final int row, final ChangeInfo c, boolean highlightUnreviewed) {
    CellFormatter fmt = table.getCellFormatter();
    if (Gerrit.isSignedIn()) {
        table.setWidget(row, C_STAR, StarredChanges.createIcon(c.legacyId(), c.starred()));
    }
    table.setWidget(row, C_ID, new TableChangeLink(String.valueOf(c.legacyId()), c));
    String subject = Util.cropSubject(c.subject());
    table.setWidget(row, C_SUBJECT, new TableChangeLink(subject, c));
    Change.Status status = c.status();
    if (status != Change.Status.NEW) {
        table.setText(row, C_STATUS, Util.toLongString(status));
    } else if (!c.mergeable()) {
        table.setText(row, C_STATUS, Util.C.changeTableNotMergeable());
    }
    if (c.owner() != null) {
        table.setWidget(row, C_OWNER, AccountLinkPanel.withStatus(c.owner(), status));
    } else {
        table.setText(row, C_OWNER, "");
    }
    if (showAssignee) {
        if (c.assignee() != null) {
            table.setWidget(row, C_ASSIGNEE, AccountLinkPanel.forAssignee(c.assignee()));
            if (Objects.equals(c.assignee().getId(), Gerrit.getUserAccount().getId())) {
                table.getRowFormatter().addStyleName(row, Gerrit.RESOURCES.css().cASSIGNEDTOME());
            }
        } else {
            table.setText(row, C_ASSIGNEE, "");
        }
    }
    table.setWidget(row, C_PROJECT, new ProjectLink(c.projectNameKey()));
    table.setWidget(row, C_BRANCH, new BranchLink(c.projectNameKey(), c.status(), c.branch(), c.topic()));
    if (Gerrit.getUserPreferences().relativeDateInChangeTable()) {
        table.setText(row, C_LAST_UPDATE, relativeFormat(c.updated()));
    } else {
        table.setText(row, C_LAST_UPDATE, shortFormat(c.updated()));
    }
    int col = C_SIZE;
    if (!Gerrit.getUserPreferences().sizeBarInChangeTable()) {
        table.setText(row, col, Util.M.insertionsAndDeletions(c.insertions(), c.deletions()));
    } else {
        table.setWidget(row, col, getSizeWidget(c));
        fmt.getElement(row, col).setTitle(Util.M.insertionsAndDeletions(c.insertions(), c.deletions()));
    }
    col++;
    for (int idx = 0; idx < labelNames.size(); idx++, col++) {
        String name = labelNames.get(idx);
        LabelInfo label = c.label(name);
        if (label == null) {
            fmt.getElement(row, col).setTitle(Gerrit.C.labelNotApplicable());
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().labelNotApplicable());
            continue;
        }
        String user;
        String info;
        ReviewCategoryStrategy reviewCategoryStrategy = Gerrit.getUserPreferences().reviewCategoryStrategy();
        if (label.rejected() != null) {
            user = label.rejected().name();
            info = getReviewCategoryDisplayInfo(reviewCategoryStrategy, label.rejected());
            if (info != null) {
                FlowPanel panel = new FlowPanel();
                panel.add(new Image(Gerrit.RESOURCES.redNot()));
                panel.add(new InlineLabel(info));
                table.setWidget(row, col, panel);
            } else {
                table.setWidget(row, col, new Image(Gerrit.RESOURCES.redNot()));
            }
        } else if (label.approved() != null) {
            user = label.approved().name();
            info = getReviewCategoryDisplayInfo(reviewCategoryStrategy, label.approved());
            if (info != null) {
                FlowPanel panel = new FlowPanel();
                panel.add(new Image(Gerrit.RESOURCES.greenCheck()));
                panel.add(new InlineLabel(info));
                table.setWidget(row, col, panel);
            } else {
                table.setWidget(row, col, new Image(Gerrit.RESOURCES.greenCheck()));
            }
        } else if (label.disliked() != null) {
            user = label.disliked().name();
            info = getReviewCategoryDisplayInfo(reviewCategoryStrategy, label.disliked());
            String vstr = String.valueOf(label._value());
            if (info != null) {
                vstr = vstr + " " + info;
            }
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().negscore());
            table.setText(row, col, vstr);
        } else if (label.recommended() != null) {
            user = label.recommended().name();
            info = getReviewCategoryDisplayInfo(reviewCategoryStrategy, label.recommended());
            String vstr = "+" + label._value();
            if (info != null) {
                vstr = vstr + " " + info;
            }
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().posscore());
            table.setText(row, col, vstr);
        } else {
            table.clearCell(row, col);
            continue;
        }
        fmt.addStyleName(row, col, Gerrit.RESOURCES.css().singleLine());
        if (user != null) {
            // Some web browsers ignore the embedded newline; some like it;
            // so we include a space before the newline to accommodate both.
            fmt.getElement(row, col).setTitle(name + " \nby " + user);
        }
    }
    boolean needHighlight = false;
    if (highlightUnreviewed && !c.reviewed()) {
        needHighlight = true;
    }
    final Element tr = fmt.getElement(row, 0).getParentElement();
    UIObject.setStyleName(tr, Gerrit.RESOURCES.css().needsReview(), needHighlight);
    setRowItem(row, c);
}
#end_block

#method_before
static Description forTestClass(org.junit.runner.Description testDesc, String configName) {
    return new AutoValue_GerritServer_Description(configName, // @UseLocalDisk is only valid on methods.
    true, !has(NoHttpd.class, testDesc.getTestClass()), !has(Hermetic.class, testDesc.getTestClass()), // @GerritConfig is only valid on methods.
    null, // @GerritConfigs is only valid on methods.
    null);
}
#method_after
static Description forTestClass(org.junit.runner.Description testDesc, String configName) {
    return new AutoValue_GerritServer_Description(configName, // @UseLocalDisk is only valid on methods.
    true, !has(NoHttpd.class, testDesc.getTestClass()), has(Sandboxed.class, testDesc.getTestClass()), // @GerritConfig is only valid on methods.
    null, // @GerritConfigs is only valid on methods.
    null);
}
#end_block

#method_before
static Description forTestMethod(org.junit.runner.Description testDesc, String configName) {
    return new AutoValue_GerritServer_Description(configName, testDesc.getAnnotation(UseLocalDisk.class) == null, testDesc.getAnnotation(NoHttpd.class) == null && !has(NoHttpd.class, testDesc.getTestClass()), testDesc.getAnnotation(Hermetic.class) == null && !has(Hermetic.class, testDesc.getTestClass()), testDesc.getAnnotation(GerritConfig.class), testDesc.getAnnotation(GerritConfigs.class));
}
#method_after
static Description forTestMethod(org.junit.runner.Description testDesc, String configName) {
    return new AutoValue_GerritServer_Description(configName, testDesc.getAnnotation(UseLocalDisk.class) == null, testDesc.getAnnotation(NoHttpd.class) == null && !has(NoHttpd.class, testDesc.getTestClass()), testDesc.getAnnotation(Sandboxed.class) != null || has(Sandboxed.class, testDesc.getTestClass()), testDesc.getAnnotation(GerritConfig.class), testDesc.getAnnotation(GerritConfigs.class));
}
#end_block

#method_before
protected void beforeTest(Description description) throws Exception {
    GerritServer.Description classDesc = GerritServer.Description.forTestClass(description, configName);
    GerritServer.Description methodDesc = GerritServer.Description.forTestMethod(description, configName);
    baseConfig.setString("gerrit", null, "tempSiteDir", tempSiteDir.getRoot().getPath());
    baseConfig.setInt("receive", null, "changeUpdateThreads", 4);
    if (classDesc.equals(methodDesc) || classDesc.hermethic()) {
        if (commonServer == null) {
            commonServer = GerritServer.start(classDesc, baseConfig);
        }
        server = commonServer;
    } else {
        server = GerritServer.start(methodDesc, baseConfig);
    }
    server.getTestInjector().injectMembers(this);
    notesMigration.setFromEnv();
    Transport.register(inProcessProtocol);
    toClose = Collections.synchronizedList(new ArrayList<Repository>());
    admin = accounts.admin();
    user = accounts.user();
    // Evict cached user state in case tests modify it.
    accountCache.evict(admin.getId());
    accountCache.evict(user.getId());
    adminRestSession = new RestSession(server, admin);
    userRestSession = new RestSession(server, user);
    initSsh(admin);
    db = reviewDbProvider.open();
    Context ctx = newRequestContext(user);
    atrScope.set(ctx);
    userSshSession = ctx.getSession();
    userSshSession.open();
    ctx = newRequestContext(admin);
    atrScope.set(ctx);
    adminSshSession = ctx.getSession();
    adminSshSession.open();
    resourcePrefix = UNSAFE_PROJECT_NAME.matcher(description.getClassName() + "_" + description.getMethodName() + "_").replaceAll("");
    project = createProject(projectInput(description));
    testRepo = cloneProject(project, getCloneAsAccount(description));
}
#method_after
protected void beforeTest(Description description) throws Exception {
    GerritServer.Description classDesc = GerritServer.Description.forTestClass(description, configName);
    GerritServer.Description methodDesc = GerritServer.Description.forTestMethod(description, configName);
    baseConfig.setString("gerrit", null, "tempSiteDir", tempSiteDir.getRoot().getPath());
    baseConfig.setInt("receive", null, "changeUpdateThreads", 4);
    if (classDesc.equals(methodDesc) && !classDesc.sandboxed() && !methodDesc.sandboxed()) {
        if (commonServer == null) {
            commonServer = GerritServer.start(classDesc, baseConfig);
        }
        server = commonServer;
    } else {
        server = GerritServer.start(methodDesc, baseConfig);
    }
    server.getTestInjector().injectMembers(this);
    notesMigration.setFromEnv();
    Transport.register(inProcessProtocol);
    toClose = Collections.synchronizedList(new ArrayList<Repository>());
    admin = accounts.admin();
    user = accounts.user();
    // Evict cached user state in case tests modify it.
    accountCache.evict(admin.getId());
    accountCache.evict(user.getId());
    adminRestSession = new RestSession(server, admin);
    userRestSession = new RestSession(server, user);
    initSsh(admin);
    db = reviewDbProvider.open();
    Context ctx = newRequestContext(user);
    atrScope.set(ctx);
    userSshSession = ctx.getSession();
    userSshSession.open();
    ctx = newRequestContext(admin);
    atrScope.set(ctx);
    adminSshSession = ctx.getSession();
    adminSshSession.open();
    resourcePrefix = UNSAFE_PROJECT_NAME.matcher(description.getClassName() + "_" + description.getMethodName() + "_").replaceAll("");
    project = createProject(projectInput(description));
    testRepo = cloneProject(project, getCloneAsAccount(description));
}
#end_block

#method_before
Arguments asUser(CurrentUser otherUser) {
    return new Arguments(db, queryProvider, rewriter, opFactories, userFactory, Providers.of(otherUser), capabilityControlFactory, changeControlGenericFactory, notesFactory, changeDataFactory, fillArgs, plcUtil, accountResolver, groupBackend, allProjectsName, allUsersName, patchListCache, repoManager, projectCache, listChildProjects, submitDryRun, conflictsCache, trackingFooters, index, indexConfig, listMembers, starredChangesUtil, allowsDrafts);
}
#method_after
Arguments asUser(CurrentUser otherUser) {
    return new Arguments(db, queryProvider, rewriter, opFactories, userFactory, Providers.of(otherUser), capabilityControlFactory, changeControlGenericFactory, notesFactory, changeDataFactory, fillArgs, commentsUtil, accountResolver, groupBackend, allProjectsName, allUsersName, patchListCache, repoManager, projectCache, listChildProjects, submitDryRun, conflictsCache, trackingFooters, index, indexConfig, listMembers, starredChangesUtil, accountCache, allowsDrafts);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> is(String value) throws QueryParseException {
    if ("starred".equalsIgnoreCase(value)) {
        return starredby(self());
    }
    if ("watched".equalsIgnoreCase(value)) {
        return new IsWatchedByPredicate(args, false);
    }
    if ("visible".equalsIgnoreCase(value)) {
        return is_visible();
    }
    if ("reviewed".equalsIgnoreCase(value)) {
        return IsReviewedPredicate.create();
    }
    if ("owner".equalsIgnoreCase(value)) {
        return new OwnerPredicate(self());
    }
    if ("reviewer".equalsIgnoreCase(value)) {
        return ReviewerPredicate.create(args, self());
    }
    if ("mergeable".equalsIgnoreCase(value)) {
        return new IsMergeablePredicate(args.fillArgs);
    }
    try {
        return status(value);
    } catch (IllegalArgumentException e) {
    // not status: alias?
    }
    throw error("Invalid query");
}
#method_after
@Operator
public Predicate<ChangeData> is(String value) throws QueryParseException {
    if ("starred".equalsIgnoreCase(value)) {
        return starredby(self());
    }
    if ("watched".equalsIgnoreCase(value)) {
        return new IsWatchedByPredicate(args, false);
    }
    if ("visible".equalsIgnoreCase(value)) {
        return is_visible();
    }
    if ("reviewed".equalsIgnoreCase(value)) {
        return IsReviewedPredicate.create();
    }
    if ("owner".equalsIgnoreCase(value)) {
        return new OwnerPredicate(self());
    }
    if ("reviewer".equalsIgnoreCase(value)) {
        return ReviewerPredicate.create(args, self());
    }
    if ("mergeable".equalsIgnoreCase(value)) {
        return new IsMergeablePredicate(args.fillArgs);
    }
    if ("assigned".equalsIgnoreCase(value)) {
        return Predicate.not(new AssigneePredicate(new Account.Id(ChangeField.NO_ASSIGNEE)));
    }
    if ("unassigned".equalsIgnoreCase(value)) {
        return new AssigneePredicate(new Account.Id(ChangeField.NO_ASSIGNEE));
    }
    try {
        return status(value);
    } catch (IllegalArgumentException e) {
    // not status: alias?
    }
    throw error("Invalid query");
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> label(String name) throws QueryParseException, OrmException {
    Set<Account.Id> accounts = null;
    AccountGroup.UUID group = null;
    // Parse for:
    // label:CodeReview=1,user=jsmith or
    // label:CodeReview=1,jsmith or
    // label:CodeReview=1,group=android_approvers or
    // label:CodeReview=1,android_approvers
    // user/groups without a label will first attempt to match user
    // Special case: votes by owners can be tracked with ",change_owner":
    // label:Code-Review+2,user=0
    // label:Code-Review+2,change_owner
    // label:Code-Review+2,user=change_owner
    String[] splitReviewer = name.split(",", 2);
    // remove all but the vote piece, e.g.'CodeReview=1'
    name = splitReviewer[0];
    if (splitReviewer.length == 2) {
        // process the user/group piece
        PredicateArgs lblArgs = new PredicateArgs(splitReviewer[1]);
        for (Map.Entry<String, String> pair : lblArgs.keyValue.entrySet()) {
            if (pair.getKey().equalsIgnoreCase(ARG_ID_USER)) {
                accounts = parseAccount(pair.getValue());
            } else if (pair.getKey().equalsIgnoreCase(ARG_ID_GROUP)) {
                group = parseGroup(pair.getValue()).getUUID();
            } else {
                throw new QueryParseException("Invalid argument identifier '" + pair.getKey() + "'");
            }
        }
        for (String value : lblArgs.positional) {
            if (accounts != null || group != null) {
                throw new QueryParseException("more than one user/group specified (" + value + ")");
            }
            try {
                accounts = parseAccount(value);
            } catch (QueryParseException qpex) {
                // (accounts get precedence)
                try {
                    group = parseGroup(value).getUUID();
                } catch (QueryParseException e) {
                    throw error("Neither user nor group " + value + " found");
                }
            }
        }
    }
    // expand a group predicate into multiple user predicates
    if (group != null) {
        Set<Account.Id> allMembers = new HashSet<>(Lists.transform(args.listMembers.get().setRecursive(true).apply(group), new Function<AccountInfo, Account.Id>() {

            @Override
            public Account.Id apply(AccountInfo accountInfo) {
                return new Account.Id(accountInfo._accountId);
            }
        }));
        int maxLimit = args.indexConfig.maxLimit();
        if (allMembers.size() > maxLimit) {
            // limit the number of query terms otherwise Gerrit will barf
            accounts = ImmutableSet.copyOf(Iterables.limit(allMembers, maxLimit));
        } else {
            accounts = allMembers;
        }
    }
    return new LabelPredicate(args.projectCache, args.changeControlGenericFactory, args.userFactory, args.db, name, accounts, group);
}
#method_after
@Operator
public Predicate<ChangeData> label(String name) throws QueryParseException, OrmException {
    Set<Account.Id> accounts = null;
    AccountGroup.UUID group = null;
    // Parse for:
    // label:CodeReview=1,user=jsmith or
    // label:CodeReview=1,jsmith or
    // label:CodeReview=1,group=android_approvers or
    // label:CodeReview=1,android_approvers
    // user/groups without a label will first attempt to match user
    // Special case: votes by owners can be tracked with ",owner":
    // label:Code-Review+2,owner
    // label:Code-Review+2,user=owner
    String[] splitReviewer = name.split(",", 2);
    // remove all but the vote piece, e.g.'CodeReview=1'
    name = splitReviewer[0];
    if (splitReviewer.length == 2) {
        // process the user/group piece
        PredicateArgs lblArgs = new PredicateArgs(splitReviewer[1]);
        for (Map.Entry<String, String> pair : lblArgs.keyValue.entrySet()) {
            if (pair.getKey().equalsIgnoreCase(ARG_ID_USER)) {
                if (pair.getValue().equals(ARG_ID_OWNER)) {
                    accounts = Collections.singleton(OWNER_ACCOUNT_ID);
                } else {
                    accounts = parseAccount(pair.getValue());
                }
            } else if (pair.getKey().equalsIgnoreCase(ARG_ID_GROUP)) {
                group = parseGroup(pair.getValue()).getUUID();
            } else {
                throw new QueryParseException("Invalid argument identifier '" + pair.getKey() + "'");
            }
        }
        for (String value : lblArgs.positional) {
            if (accounts != null || group != null) {
                throw new QueryParseException("more than one user/group specified (" + value + ")");
            }
            try {
                if (value.equals(ARG_ID_OWNER)) {
                    accounts = Collections.singleton(OWNER_ACCOUNT_ID);
                } else {
                    accounts = parseAccount(value);
                }
            } catch (QueryParseException qpex) {
                // (accounts get precedence)
                try {
                    group = parseGroup(value).getUUID();
                } catch (QueryParseException e) {
                    throw error("Neither user nor group " + value + " found");
                }
            }
        }
    }
    // expand a group predicate into multiple user predicates
    if (group != null) {
        Set<Account.Id> allMembers = args.listMembers.get().setRecursive(true).apply(group).stream().map(a -> new Account.Id(a._accountId)).collect(toSet());
        int maxLimit = args.indexConfig.maxLimit();
        if (allMembers.size() > maxLimit) {
            // limit the number of query terms otherwise Gerrit will barf
            accounts = ImmutableSet.copyOf(Iterables.limit(allMembers, maxLimit));
        } else {
            accounts = allMembers;
        }
    }
    return new LabelPredicate(args, name, accounts, group);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> visibleto(String who) throws QueryParseException, OrmException {
    if ("self".equals(who)) {
        return is_visible();
    }
    Set<Account.Id> m = args.accountResolver.findAll(who);
    if (!m.isEmpty()) {
        List<Predicate<ChangeData>> p = Lists.newArrayListWithCapacity(m.size());
        for (Account.Id id : m) {
            return visibleto(args.userFactory.create(id));
        }
        return Predicate.or(p);
    }
    // If its not an account, maybe its a group?
    // 
    Collection<GroupReference> suggestions = args.groupBackend.suggest(who, null);
    if (!suggestions.isEmpty()) {
        HashSet<AccountGroup.UUID> ids = new HashSet<>();
        for (GroupReference ref : suggestions) {
            ids.add(ref.getUUID());
        }
        return visibleto(new SingleGroupUser(args.capabilityControlFactory, ids));
    }
    throw error("No user or group matches \"" + who + "\".");
}
#method_after
@Operator
public Predicate<ChangeData> visibleto(String who) throws QueryParseException, OrmException {
    if ("self".equals(who)) {
        return is_visible();
    }
    Set<Account.Id> m = args.accountResolver.findAll(args.db.get(), who);
    if (!m.isEmpty()) {
        List<Predicate<ChangeData>> p = Lists.newArrayListWithCapacity(m.size());
        for (Account.Id id : m) {
            return visibleto(args.userFactory.create(id));
        }
        return Predicate.or(p);
    }
    // If its not an account, maybe its a group?
    // 
    Collection<GroupReference> suggestions = args.groupBackend.suggest(who, null);
    if (!suggestions.isEmpty()) {
        HashSet<AccountGroup.UUID> ids = new HashSet<>();
        for (GroupReference ref : suggestions) {
            ids.add(ref.getUUID());
        }
        return visibleto(new SingleGroupUser(args.capabilityControlFactory, ids));
    }
    throw error("No user or group matches \"" + who + "\".");
}
#end_block

#method_before
@Override
protected Predicate<ChangeData> defaultField(String query) throws QueryParseException {
    if (query.startsWith("refs/")) {
        return ref(query);
    } else if (DEF_CHANGE.matcher(query).matches()) {
        try {
            return change(query);
        } catch (QueryParseException e) {
        // Skip.
        }
    }
    List<Predicate<ChangeData>> predicates = Lists.newArrayListWithCapacity(9);
    try {
        predicates.add(commit(query));
    } catch (IllegalArgumentException e) {
    // Skip.
    }
    try {
        predicates.add(owner(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    try {
        predicates.add(reviewer(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    predicates.add(file(query));
    try {
        predicates.add(label(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    predicates.add(message(query));
    predicates.add(comment(query));
    predicates.add(projects(query));
    predicates.add(ref(query));
    predicates.add(branch(query));
    predicates.add(topic(query));
    return Predicate.or(predicates);
}
#method_after
@Override
protected Predicate<ChangeData> defaultField(String query) throws QueryParseException {
    if (query.startsWith("refs/")) {
        return ref(query);
    } else if (DEF_CHANGE.matcher(query).matches()) {
        try {
            return change(query);
        } catch (QueryParseException e) {
        // Skip.
        }
    }
    // Adapt the capacity of this list when adding more default predicates.
    List<Predicate<ChangeData>> predicates = Lists.newArrayListWithCapacity(11);
    try {
        predicates.add(commit(query));
    } catch (IllegalArgumentException e) {
    // Skip.
    }
    try {
        predicates.add(owner(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    try {
        predicates.add(reviewer(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    predicates.add(file(query));
    try {
        predicates.add(label(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    predicates.add(message(query));
    predicates.add(comment(query));
    predicates.add(projects(query));
    predicates.add(ref(query));
    predicates.add(branch(query));
    predicates.add(topic(query));
    // predicates.
    return Predicate.or(predicates);
}
#end_block

#method_before
private Set<Account.Id> parseAccount(String who) throws QueryParseException, OrmException {
    if ("self".equals(who)) {
        return Collections.singleton(self());
    }
    if (who.equals(ARG_ID_CHANGE_OWNER) || who.equals(CHANGE_OWNER_ACCOUNT_ID.toString())) {
        return Collections.singleton(CHANGE_OWNER_ACCOUNT_ID);
    }
    Set<Account.Id> matches = args.accountResolver.findAll(who);
    if (matches.isEmpty()) {
        throw error("User " + who + " not found");
    }
    return matches;
}
#method_after
private Set<Account.Id> parseAccount(String who) throws QueryParseException, OrmException {
    if ("self".equals(who)) {
        return Collections.singleton(self());
    }
    Set<Account.Id> matches = args.accountResolver.findAll(args.db.get(), who);
    if (matches.isEmpty()) {
        throw error("User " + who + " not found");
    }
    return matches;
}
#end_block

#method_before
private static String formatAccount(Account.Id accountId) {
    if (ChangeQueryBuilder.CHANGE_OWNER_ACCOUNT_ID.equals(accountId)) {
        return ChangeQueryBuilder.ARG_ID_CHANGE_OWNER;
    }
    return Integer.toString(accountId.get());
}
#method_after
private static String formatAccount(Account.Id accountId) {
    if (ChangeQueryBuilder.OWNER_ACCOUNT_ID.equals(accountId)) {
        return ChangeQueryBuilder.ARG_ID_OWNER;
    }
    return Integer.toString(accountId.get());
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    CallbackGroup group = new CallbackGroup();
    if (Gerrit.isSignedIn()) {
        ChangeList.query("change:" + changeId.get() + " has:draft", Collections.<ListChangesOption>emptySet(), group.add(new AsyncCallback<ChangeList>() {

            @Override
            public void onSuccess(ChangeList result) {
                hasDraftComments = result.length() > 0;
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        }));
        ChangeApi.editWithFiles(changeId.get(), group.add(new AsyncCallback<EditInfo>() {

            @Override
            public void onSuccess(EditInfo result) {
                edit = result;
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        }));
    }
    loadChangeInfo(true, group.addFinal(new GerritCallback<ChangeInfo>() {

        @Override
        public void onSuccess(ChangeInfo info) {
            info.init();
            loadConfigInfo(info, base);
        }
    }));
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    CallbackGroup group = new CallbackGroup();
    if (Gerrit.isSignedIn()) {
        ChangeList.query("change:" + changeId.get() + " has:draft", Collections.<ListChangesOption>emptySet(), group.add(new AsyncCallback<ChangeList>() {

            @Override
            public void onSuccess(ChangeList result) {
                hasDraftComments = result.length() > 0;
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        }));
        ChangeApi.editWithFiles(changeId.get(), group.add(new AsyncCallback<EditInfo>() {

            @Override
            public void onSuccess(EditInfo result) {
                edit = result;
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        }));
    }
    loadChangeInfo(true, group.addFinal(new GerritCallback<ChangeInfo>() {

        @Override
        public void onSuccess(final ChangeInfo info) {
            info.init();
            addExtensionPoints(info, initCurrentRevision(info));
            final RevisionInfo rev = info.revision(revision);
            CallbackGroup group = new CallbackGroup();
            loadCommit(rev, group);
            group.addListener(new GerritCallback<Void>() {

                @Override
                public void onSuccess(Void result) {
                    if (base == null && rev.commit().parents().length() > 1) {
                        base = Gerrit.getUserPreferences().defaultBaseForMerges().getBase();
                    }
                    loadConfigInfo(info, base);
                }
            });
            group.done();
        }
    }));
}
#end_block

#method_before
private void addExtensionPoints(ChangeInfo change, RevisionInfo rev) {
    addExtensionPoint(GerritUiExtensionPoint.CHANGE_SCREEN_HEADER, headerExtension, change, rev);
    addExtensionPoint(GerritUiExtensionPoint.CHANGE_SCREEN_HEADER_RIGHT_OF_BUTTONS, headerExtensionMiddle, change, rev);
    addExtensionPoint(GerritUiExtensionPoint.CHANGE_SCREEN_HEADER_RIGHT_OF_POP_DOWNS, headerExtensionRight, change, rev);
    addExtensionPoint(GerritUiExtensionPoint.CHANGE_SCREEN_BELOW_CHANGE_INFO_BLOCK, changeExtension, change, rev);
}
#method_after
private void addExtensionPoints(ChangeInfo change, RevisionInfo rev) {
    addExtensionPoint(GerritUiExtensionPoint.CHANGE_SCREEN_HEADER, headerExtension, change, rev);
    addExtensionPoint(GerritUiExtensionPoint.CHANGE_SCREEN_HEADER_RIGHT_OF_BUTTONS, headerExtensionMiddle, change, rev);
    addExtensionPoint(GerritUiExtensionPoint.CHANGE_SCREEN_HEADER_RIGHT_OF_POP_DOWNS, headerExtensionRight, change, rev);
    addExtensionPoint(GerritUiExtensionPoint.CHANGE_SCREEN_BELOW_CHANGE_INFO_BLOCK, changeExtension, change, rev);
    addExtensionPoint(GerritUiExtensionPoint.CHANGE_SCREEN_BELOW_RELATED_INFO_BLOCK, relatedExtension, change, rev);
    addExtensionPoint(GerritUiExtensionPoint.CHANGE_SCREEN_BELOW_COMMIT_INFO_BLOCK, commitExtension, change, rev);
    addExtensionPoint(GerritUiExtensionPoint.CHANGE_SCREEN_HISTORY_RIGHT_OF_BUTTONS, historyExtensionRight, change, rev);
}
#end_block

#method_before
private void gotoSibling(final int offset) {
    if (offset > 0 && changeInfo.currentRevision().equals(revision)) {
        return;
    }
    if (offset < 0 && changeInfo.revision(revision)._number() == 1) {
        return;
    }
    JsArray<RevisionInfo> revisions = changeInfo.revisions().values();
    RevisionInfo.sortRevisionInfoByNumber(revisions);
    for (int i = 0; i < revisions.length(); i++) {
        if (revision.equals(revisions.get(i).name())) {
            if (0 <= i + offset && i + offset < revisions.length()) {
                Gerrit.display(PageLinks.toChange(new PatchSet.Id(changeInfo.legacyId(), revisions.get(i + offset)._number())));
                return;
            }
            return;
        }
    }
}
#method_after
private void gotoSibling(int offset) {
    if (offset > 0 && changeInfo.currentRevision().equals(revision)) {
        return;
    }
    if (offset < 0 && changeInfo.revision(revision)._number() == 1) {
        return;
    }
    JsArray<RevisionInfo> revisions = changeInfo.revisions().values();
    RevisionInfo.sortRevisionInfoByNumber(revisions);
    for (int i = 0; i < revisions.length(); i++) {
        if (revision.equals(revisions.get(i).name())) {
            if (0 <= i + offset && i + offset < revisions.length()) {
                Gerrit.display(PageLinks.toChange(new PatchSet.Id(changeInfo.legacyId(), revisions.get(i + offset)._number())));
                return;
            }
            return;
        }
    }
}
#end_block

#method_before
private void initEditMode(ChangeInfo info, String revision) {
    if (Gerrit.isSignedIn() && info.status().isOpen()) {
        RevisionInfo rev = info.revision(revision);
        if (isEditModeEnabled(info, rev)) {
            editMode.setVisible(fileTableMode == FileTable.Mode.REVIEW);
            addFile.setVisible(!editMode.isVisible());
            deleteFile.setVisible(!editMode.isVisible());
            renameFile.setVisible(!editMode.isVisible());
            reviewMode.setVisible(!editMode.isVisible());
            addFileAction = new AddFileAction(changeId, info.revision(revision), style, addFile, files);
            deleteFileAction = new DeleteFileAction(changeId, info.revision(revision), style, addFile);
            renameFileAction = new RenameFileAction(changeId, info.revision(revision), style, addFile);
        } else {
            editMode.setVisible(false);
            addFile.setVisible(false);
            reviewMode.setVisible(false);
        }
        if (rev.isEdit()) {
            if (info.hasEditBasedOnCurrentPatchSet()) {
                publishEdit.setVisible(true);
            } else {
                rebaseEdit.setVisible(true);
            }
            deleteEdit.setVisible(true);
        }
    }
}
#method_after
private void initEditMode(ChangeInfo info, String revision) {
    if (Gerrit.isSignedIn()) {
        RevisionInfo rev = info.revision(revision);
        if (info.status().isOpen()) {
            if (isEditModeEnabled(info, rev)) {
                editMode.setVisible(fileTableMode == FileTable.Mode.REVIEW);
                addFile.setVisible(!editMode.isVisible());
                deleteFile.setVisible(!editMode.isVisible());
                renameFile.setVisible(!editMode.isVisible());
                reviewMode.setVisible(!editMode.isVisible());
                addFileAction = new AddFileAction(changeId, info.revision(revision), style, addFile, files);
                deleteFileAction = new DeleteFileAction(changeId, info.revision(revision), style, addFile);
                renameFileAction = new RenameFileAction(changeId, info.revision(revision), style, addFile);
            } else {
                editMode.setVisible(false);
                addFile.setVisible(false);
                reviewMode.setVisible(false);
            }
            if (rev.isEdit()) {
                if (info.hasEditBasedOnCurrentPatchSet()) {
                    publishEdit.setVisible(true);
                } else {
                    rebaseEdit.setVisible(true);
                }
                deleteEdit.setVisible(true);
            }
        } else if (rev.isEdit()) {
            deleteEdit.setStyleName(style.highlight());
            deleteEdit.setVisible(true);
        }
    }
}
#end_block

#method_before
@UiHandler("publishEdit")
void onPublishEdit(@SuppressWarnings("unused") ClickEvent e) {
    EditActions.publishEdit(changeId);
}
#method_after
@UiHandler("publishEdit")
void onPublishEdit(@SuppressWarnings("unused") ClickEvent e) {
    EditActions.publishEdit(changeId, publishEdit, rebaseEdit, deleteEdit);
}
#end_block

#method_before
@UiHandler("rebaseEdit")
void onRebaseEdit(@SuppressWarnings("unused") ClickEvent e) {
    EditActions.rebaseEdit(changeId);
}
#method_after
@UiHandler("rebaseEdit")
void onRebaseEdit(@SuppressWarnings("unused") ClickEvent e) {
    EditActions.rebaseEdit(changeId, publishEdit, rebaseEdit, deleteEdit);
}
#end_block

#method_before
@UiHandler("deleteEdit")
void onDeleteEdit(@SuppressWarnings("unused") ClickEvent e) {
    if (Window.confirm(Resources.C.deleteChangeEdit())) {
        EditActions.deleteEdit(changeId);
    }
}
#method_after
@UiHandler("deleteEdit")
void onDeleteEdit(@SuppressWarnings("unused") ClickEvent e) {
    if (Window.confirm(Resources.C.deleteChangeEdit())) {
        EditActions.deleteEdit(changeId, publishEdit, rebaseEdit, deleteEdit);
    }
}
#end_block

#method_before
@UiHandler("publish")
void onPublish(@SuppressWarnings("unused") ClickEvent e) {
    DraftActions.publish(changeId, revision);
}
#method_after
@UiHandler("publish")
void onPublish(@SuppressWarnings("unused") ClickEvent e) {
    DraftActions.publish(changeId, revision, publish, deleteRevision, deleteChange);
}
#end_block

#method_before
@UiHandler("deleteRevision")
void onDeleteRevision(@SuppressWarnings("unused") ClickEvent e) {
    if (Window.confirm(Resources.C.deleteDraftRevision())) {
        DraftActions.delete(changeId, revision);
    }
}
#method_after
@UiHandler("deleteRevision")
void onDeleteRevision(@SuppressWarnings("unused") ClickEvent e) {
    if (Window.confirm(Resources.C.deleteDraftRevision())) {
        DraftActions.delete(changeId, revision, publish, deleteRevision, deleteChange);
    }
}
#end_block

#method_before
@UiHandler("deleteChange")
void onDeleteChange(@SuppressWarnings("unused") ClickEvent e) {
    if (Window.confirm(Resources.C.deleteDraftChange())) {
        DraftActions.delete(changeId);
    }
}
#method_after
@UiHandler("deleteChange")
void onDeleteChange(@SuppressWarnings("unused") ClickEvent e) {
    if (Window.confirm(Resources.C.deleteDraftChange())) {
        DraftActions.delete(changeId, publish, deleteRevision, deleteChange);
    }
}
#end_block

#method_before
@Override
public void registerKeys() {
    super.registerKeys();
    KeyCommandSet keysNavigation = new KeyCommandSet(Gerrit.C.sectionNavigation());
    keysNavigation.add(new KeyCommand(0, 'u', Util.C.upToChangeList()) {

        @Override
        public void onKeyPress(final KeyPressEvent event) {
            Gerrit.displayLastChangeList();
        }
    });
    keysNavigation.add(new KeyCommand(0, 'R', Util.C.keyReloadChange()) {

        @Override
        public void onKeyPress(final KeyPressEvent event) {
            Gerrit.display(PageLinks.toChange(changeId));
        }
    });
    keysNavigation.add(new KeyCommand(0, 'n', Util.C.keyNextPatchSet()) {

        @Override
        public void onKeyPress(final KeyPressEvent event) {
            gotoSibling(1);
        }
    }, new KeyCommand(0, 'p', Util.C.keyPreviousPatchSet()) {

        @Override
        public void onKeyPress(final KeyPressEvent event) {
            gotoSibling(-1);
        }
    });
    handlers.add(GlobalKey.add(this, keysNavigation));
    KeyCommandSet keysAction = new KeyCommandSet(Gerrit.C.sectionActions());
    keysAction.add(new KeyCommand(0, 'a', Util.C.keyPublishComments()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (Gerrit.isSignedIn()) {
                onReply(null);
            } else {
                Gerrit.doSignIn(getToken());
            }
        }
    });
    keysAction.add(new KeyCommand(0, 'x', Util.C.keyExpandAllMessages()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            onExpandAll(null);
        }
    });
    keysAction.add(new KeyCommand(0, 'z', Util.C.keyCollapseAllMessages()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            onCollapseAll(null);
        }
    });
    keysAction.add(new KeyCommand(0, 's', Util.C.changeTableStar()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (Gerrit.isSignedIn()) {
                star.setValue(!star.getValue(), true);
            } else {
                Gerrit.doSignIn(getToken());
            }
        }
    });
    keysAction.add(new KeyCommand(0, 'c', Util.C.keyAddReviewers()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (Gerrit.isSignedIn()) {
                reviewers.onOpenForm();
            } else {
                Gerrit.doSignIn(getToken());
            }
        }
    });
    keysAction.add(new KeyCommand(0, 't', Util.C.keyEditTopic()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (Gerrit.isSignedIn()) {
                // differentiate F5 from 't' by checking the charCode(F5=0, t=116).
                if (event.getNativeEvent().getCharCode() == 0) {
                    Window.Location.reload();
                    return;
                }
                if (topic.canEdit()) {
                    topic.onEdit();
                }
            } else {
                Gerrit.doSignIn(getToken());
            }
        }
    });
    handlers.add(GlobalKey.add(this, keysAction));
    files.registerKeys();
}
#method_after
@Override
public void registerKeys() {
    super.registerKeys();
    KeyCommandSet keysNavigation = new KeyCommandSet(Gerrit.C.sectionNavigation());
    keysNavigation.add(new KeyCommand(0, 'u', Util.C.upToChangeList()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            Gerrit.displayLastChangeList();
        }
    });
    keysNavigation.add(new KeyCommand(0, 'R', Util.C.keyReloadChange()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            Gerrit.display(PageLinks.toChange(changeId));
        }
    });
    keysNavigation.add(new KeyCommand(0, 'n', Util.C.keyNextPatchSet()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            gotoSibling(1);
        }
    }, new KeyCommand(0, 'p', Util.C.keyPreviousPatchSet()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            gotoSibling(-1);
        }
    });
    handlers.add(GlobalKey.add(this, keysNavigation));
    KeyCommandSet keysAction = new KeyCommandSet(Gerrit.C.sectionActions());
    keysAction.add(new KeyCommand(0, 'a', Util.C.keyPublishComments()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (Gerrit.isSignedIn()) {
                onReply(null);
            } else {
                Gerrit.doSignIn(getToken());
            }
        }
    });
    keysAction.add(new KeyCommand(0, 'x', Util.C.keyExpandAllMessages()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            onExpandAll(null);
        }
    });
    keysAction.add(new KeyCommand(0, 'z', Util.C.keyCollapseAllMessages()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            onCollapseAll(null);
        }
    });
    keysAction.add(new KeyCommand(0, 's', Util.C.changeTableStar()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (Gerrit.isSignedIn()) {
                star.setValue(!star.getValue(), true);
            } else {
                Gerrit.doSignIn(getToken());
            }
        }
    });
    keysAction.add(new KeyCommand(0, 'c', Util.C.keyAddReviewers()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (Gerrit.isSignedIn()) {
                reviewers.onOpenForm();
            } else {
                Gerrit.doSignIn(getToken());
            }
        }
    });
    keysAction.add(new KeyCommand(0, 't', Util.C.keyEditTopic()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (Gerrit.isSignedIn()) {
                // differentiate F5 from 't' by checking the charCode(F5=0, t=116).
                if (event.getNativeEvent().getCharCode() == 0) {
                    Window.Location.reload();
                    return;
                }
                if (topic.canEdit()) {
                    topic.onEdit();
                }
            } else {
                Gerrit.doSignIn(getToken());
            }
        }
    });
    handlers.add(GlobalKey.add(this, keysAction));
    files.registerKeys();
}
#end_block

#method_before
private void loadConfigInfo(final ChangeInfo info, final String base) {
    info.revisions().copyKeysIntoChildren("name");
    if (edit != null) {
        edit.setName(edit.commit().commit());
        info.setEdit(edit);
        if (edit.hasFiles()) {
            edit.files().copyKeysIntoChildren("path");
        }
        info.revisions().put(edit.name(), RevisionInfo.fromEdit(edit));
        JsArray<RevisionInfo> list = info.revisions().values();
        // use the edit regardless of which patch set it is based on
        if (revision == null) {
            RevisionInfo.sortRevisionInfoByNumber(list);
            RevisionInfo rev = list.get(list.length() - 1);
            if (rev.isEdit()) {
                info.setCurrentRevision(rev.name());
            }
        } else if (revision.equals("edit") || revision.equals("0")) {
            for (int i = 0; i < list.length(); i++) {
                RevisionInfo r = list.get(i);
                if (r.isEdit()) {
                    info.setCurrentRevision(r.name());
                    break;
                }
            }
        }
    }
    final RevisionInfo rev = resolveRevisionToDisplay(info);
    addExtensionPoints(info, rev);
    final RevisionInfo b = resolveRevisionOrPatchSetId(info, base, null);
    CallbackGroup group = new CallbackGroup();
    Timestamp lastReply = myLastReply(info);
    if (rev.isEdit()) {
        // Comments are filtered for the current revision. Use parent
        // patch set for edits, as edits themself can never have comments.
        RevisionInfo p = RevisionInfo.findEditParentRevision(info.revisions().values());
        List<NativeMap<JsArray<CommentInfo>>> comments = loadComments(p, group);
        loadFileList(b, rev, lastReply, group, comments, null);
    } else {
        loadDiff(b, rev, lastReply, group);
    }
    loadCommit(rev, group);
    if (loaded) {
        group.done();
        return;
    }
    RevisionInfoCache.add(changeId, rev);
    ConfigInfoCache.add(info);
    ConfigInfoCache.get(info.projectNameKey(), group.addFinal(new ScreenLoadCallback<ConfigInfoCache.Entry>(this) {

        @Override
        protected void preDisplay(Entry result) {
            loaded = true;
            commentLinkProcessor = result.getCommentLinkProcessor();
            setTheme(result.getTheme());
            renderChangeInfo(info);
            loadRevisionInfo();
        }
    }));
}
#method_after
private void loadConfigInfo(final ChangeInfo info, String base) {
    final RevisionInfo rev = info.revision(revision);
    RevisionInfo b = resolveRevisionOrPatchSetId(info, base, null);
    CallbackGroup group = new CallbackGroup();
    Timestamp lastReply = myLastReply(info);
    if (rev.isEdit()) {
        // Comments are filtered for the current revision. Use parent
        // patch set for edits, as edits themself can never have comments.
        RevisionInfo p = RevisionInfo.findEditParentRevision(info.revisions().values());
        List<NativeMap<JsArray<CommentInfo>>> comments = loadComments(p, group);
        loadFileList(b, rev, lastReply, group, comments, null);
    } else {
        loadDiff(b, rev, lastReply, group);
    }
    group.addListener(new AsyncCallback<Void>() {

        @Override
        public void onSuccess(Void result) {
            loadConfigInfo(info, rev);
        }

        @Override
        public void onFailure(Throwable caught) {
            logger.log(Level.SEVERE, "Loading file list and inline comments failed: " + caught.getMessage());
            loadConfigInfo(info, rev);
        }
    });
    group.done();
}
#end_block

#method_before
private void loadConfigInfo(final ChangeInfo info, final String base) {
    info.revisions().copyKeysIntoChildren("name");
    if (edit != null) {
        edit.setName(edit.commit().commit());
        info.setEdit(edit);
        if (edit.hasFiles()) {
            edit.files().copyKeysIntoChildren("path");
        }
        info.revisions().put(edit.name(), RevisionInfo.fromEdit(edit));
        JsArray<RevisionInfo> list = info.revisions().values();
        // use the edit regardless of which patch set it is based on
        if (revision == null) {
            RevisionInfo.sortRevisionInfoByNumber(list);
            RevisionInfo rev = list.get(list.length() - 1);
            if (rev.isEdit()) {
                info.setCurrentRevision(rev.name());
            }
        } else if (revision.equals("edit") || revision.equals("0")) {
            for (int i = 0; i < list.length(); i++) {
                RevisionInfo r = list.get(i);
                if (r.isEdit()) {
                    info.setCurrentRevision(r.name());
                    break;
                }
            }
        }
    }
    final RevisionInfo rev = resolveRevisionToDisplay(info);
    addExtensionPoints(info, rev);
    final RevisionInfo b = resolveRevisionOrPatchSetId(info, base, null);
    CallbackGroup group = new CallbackGroup();
    Timestamp lastReply = myLastReply(info);
    if (rev.isEdit()) {
        // Comments are filtered for the current revision. Use parent
        // patch set for edits, as edits themself can never have comments.
        RevisionInfo p = RevisionInfo.findEditParentRevision(info.revisions().values());
        List<NativeMap<JsArray<CommentInfo>>> comments = loadComments(p, group);
        loadFileList(b, rev, lastReply, group, comments, null);
    } else {
        loadDiff(b, rev, lastReply, group);
    }
    loadCommit(rev, group);
    if (loaded) {
        group.done();
        return;
    }
    RevisionInfoCache.add(changeId, rev);
    ConfigInfoCache.add(info);
    ConfigInfoCache.get(info.projectNameKey(), group.addFinal(new ScreenLoadCallback<ConfigInfoCache.Entry>(this) {

        @Override
        protected void preDisplay(Entry result) {
            loaded = true;
            commentLinkProcessor = result.getCommentLinkProcessor();
            setTheme(result.getTheme());
            renderChangeInfo(info);
            loadRevisionInfo();
        }
    }));
}
#method_after
private void loadConfigInfo(final ChangeInfo info, RevisionInfo rev) {
    if (loaded) {
        return;
    }
    RevisionInfoCache.add(changeId, rev);
    ConfigInfoCache.add(info);
    ConfigInfoCache.get(info.projectNameKey(), new ScreenLoadCallback<ConfigInfoCache.Entry>(this) {

        @Override
        protected void preDisplay(Entry result) {
            loaded = true;
            commentLinkProcessor = result.getCommentLinkProcessor();
            setTheme(result.getTheme());
            renderChangeInfo(info);
            loadRevisionInfo();
        }
    });
}
#end_block

#method_before
private void loadDiff(final RevisionInfo base, final RevisionInfo rev, final Timestamp myLastReply, CallbackGroup group) {
    final List<NativeMap<JsArray<CommentInfo>>> comments = loadComments(rev, group);
    final List<NativeMap<JsArray<CommentInfo>>> drafts = loadDrafts(rev, group);
    loadFileList(base, rev, myLastReply, group, comments, drafts);
    if (Gerrit.isSignedIn() && fileTableMode == FileTable.Mode.REVIEW) {
        ChangeApi.revision(changeId.get(), rev.name()).view("files").addParameterTrue("reviewed").get(group.add(new AsyncCallback<JsArrayString>() {

            @Override
            public void onSuccess(JsArrayString result) {
                files.markReviewed(result);
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        }));
    }
}
#method_after
private void loadDiff(RevisionInfo base, RevisionInfo rev, Timestamp myLastReply, CallbackGroup group) {
    List<NativeMap<JsArray<CommentInfo>>> comments = loadComments(rev, group);
    List<NativeMap<JsArray<CommentInfo>>> drafts = loadDrafts(rev, group);
    loadFileList(base, rev, myLastReply, group, comments, drafts);
    if (Gerrit.isSignedIn() && fileTableMode == FileTable.Mode.REVIEW) {
        ChangeApi.revision(changeId.get(), rev.name()).view("files").addParameterTrue("reviewed").get(group.add(new AsyncCallback<JsArrayString>() {

            @Override
            public void onSuccess(JsArrayString result) {
                files.markReviewed(result);
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        }));
    }
}
#end_block

#method_before
private void loadFileList(final RevisionInfo base, final RevisionInfo rev, final Timestamp myLastReply, CallbackGroup group, final List<NativeMap<JsArray<CommentInfo>>> comments, final List<NativeMap<JsArray<CommentInfo>>> drafts) {
    DiffApi.list(changeId.get(), base != null ? base.name() : null, rev.name(), group.add(new AsyncCallback<NativeMap<FileInfo>>() {

        @Override
        public void onSuccess(NativeMap<FileInfo> m) {
            files.set(base != null ? new PatchSet.Id(changeId, base._number()) : null, new PatchSet.Id(changeId, rev._number()), style, reply, fileTableMode, edit != null);
            files.setValue(m, myLastReply, comments != null ? comments.get(0) : null, drafts != null ? drafts.get(0) : null);
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
}
#method_after
private void loadFileList(final RevisionInfo base, final RevisionInfo rev, final Timestamp myLastReply, CallbackGroup group, final List<NativeMap<JsArray<CommentInfo>>> comments, final List<NativeMap<JsArray<CommentInfo>>> drafts) {
    DiffApi.list(changeId.get(), rev.name(), base, group.add(new AsyncCallback<NativeMap<FileInfo>>() {

        @Override
        public void onSuccess(NativeMap<FileInfo> m) {
            files.set(base != null ? new PatchSet.Id(changeId, base._number()) : null, new PatchSet.Id(changeId, rev._number()), style, reply, fileTableMode, edit != null);
            files.setValue(m, myLastReply, comments != null ? comments.get(0) : null, drafts != null ? drafts.get(0) : null);
        }

        @Override
        public void onFailure(Throwable caught) {
            files.showError(caught);
        }
    }));
}
#end_block

#method_before
private void loadCommit(final RevisionInfo rev, CallbackGroup group) {
    if (rev.isEdit()) {
        return;
    }
    ChangeApi.commitWithLinks(changeId.get(), rev.name(), group.add(new AsyncCallback<CommitInfo>() {

        @Override
        public void onSuccess(CommitInfo info) {
            rev.setCommit(info);
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
}
#method_after
private void loadCommit(final RevisionInfo rev, CallbackGroup group) {
    if (rev.isEdit() || rev.commit() != null) {
        return;
    }
    ChangeApi.commitWithLinks(changeId.get(), rev.name(), group.add(new AsyncCallback<CommitInfo>() {

        @Override
        public void onSuccess(CommitInfo info) {
            rev.setCommit(info);
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
}
#end_block

#method_before
private RevisionInfo resolveRevisionToDisplay(ChangeInfo info) {
    RevisionInfo rev = resolveRevisionOrPatchSetId(info, revision, info.currentRevision());
    if (rev != null) {
        revision = rev.name();
        return rev;
    }
    // the revision is not visible to the calling user (maybe it is a draft?)
    // or the change is corrupt, take the last revision that was returned,
    // if no revision was returned display an error
    JsArray<RevisionInfo> revisions = info.revisions().values();
    if (revisions.length() > 0) {
        RevisionInfo.sortRevisionInfoByNumber(revisions);
        rev = revisions.get(revisions.length() - 1);
        revision = rev.name();
        return rev;
    } else {
        new ErrorDialog(Resources.M.changeWithNoRevisions(info.legacyId().get())).center();
        throw new IllegalStateException("no revision, cannot proceed");
    }
}
#method_after
private RevisionInfo resolveRevisionToDisplay(ChangeInfo info) {
    RevisionInfo rev = resolveRevisionOrPatchSetId(info, revision, info.currentRevision());
    if (rev != null) {
        revision = rev.name();
        return rev;
    }
    // the revision is not visible to the calling user (maybe it is a draft?)
    // or the change is corrupt, take the last revision that was returned,
    // if no revision was returned display an error
    JsArray<RevisionInfo> revisions = info.revisions().values();
    if (revisions.length() > 0) {
        RevisionInfo.sortRevisionInfoByNumber(revisions);
        rev = revisions.get(revisions.length() - 1);
        revision = rev.name();
        return rev;
    }
    new ErrorDialog(Resources.M.changeWithNoRevisions(info.legacyId().get())).center();
    throw new IllegalStateException("no revision, cannot proceed");
}
#end_block

#method_before
private RevisionInfo resolveRevisionOrPatchSetId(ChangeInfo info, String revOrId, String defaultValue) {
    if (revOrId == null) {
        revOrId = defaultValue;
    } else if (!info.revisions().containsKey(revOrId)) {
        JsArray<RevisionInfo> list = info.revisions().values();
        for (int i = 0; i < list.length(); i++) {
            RevisionInfo r = list.get(i);
            if (revOrId.equals(String.valueOf(r._number()))) {
                revOrId = r.name();
                break;
            }
        }
    }
    return revOrId != null ? info.revision(revOrId) : null;
}
#method_after
private RevisionInfo resolveRevisionOrPatchSetId(ChangeInfo info, String revOrId, String defaultValue) {
    int parentNum;
    if (revOrId == null) {
        revOrId = defaultValue;
    } else if ((parentNum = toParentNum(revOrId)) > 0) {
        CommitInfo commitInfo = info.revision(revision).commit();
        JsArray<CommitInfo> parents = commitInfo.parents();
        if (parents.length() >= parentNum) {
            return RevisionInfo.forParent(-parentNum, parents.get(parentNum - 1));
        }
    } else if (!info.revisions().containsKey(revOrId)) {
        JsArray<RevisionInfo> list = info.revisions().values();
        for (int i = 0; i < list.length(); i++) {
            RevisionInfo r = list.get(i);
            if (revOrId.equals(String.valueOf(r._number()))) {
                revOrId = r.name();
                break;
            }
        }
    }
    return revOrId != null ? info.revision(revOrId) : null;
}
#end_block

#method_before
private boolean isSubmittable(ChangeInfo info) {
    boolean canSubmit = info.status().isOpen() && revision.equals(info.currentRevision()) && !info.revision(revision).draft();
    if (canSubmit && info.status() == Change.Status.NEW) {
        for (String name : info.labels()) {
            LabelInfo label = info.label(name);
            switch(label.status()) {
                case NEED:
                    statusText.setInnerText("Needs " + name);
                    canSubmit = false;
                    break;
                case REJECT:
                case IMPOSSIBLE:
                    if (label.blocking()) {
                        statusText.setInnerText("Not " + name);
                        canSubmit = false;
                    }
                    break;
                case MAY:
                case OK:
                default:
                    break;
            }
        }
    }
    return canSubmit;
}
#method_after
private boolean isSubmittable(ChangeInfo info) {
    boolean canSubmit = info.status().isOpen() && revision.equals(info.currentRevision()) && !info.revision(revision).draft();
    if (canSubmit && info.status() == Change.Status.NEW) {
        for (String name : info.labels()) {
            LabelInfo label = info.label(name);
            switch(label.status()) {
                case NEED:
                    statusText.setInnerText(Util.M.needs(name));
                    canSubmit = false;
                    break;
                case REJECT:
                case IMPOSSIBLE:
                    if (label.blocking()) {
                        statusText.setInnerText(Util.M.blockedOn(name));
                        canSubmit = false;
                    }
                    break;
                case MAY:
                case OK:
                default:
                    break;
            }
        }
    }
    return canSubmit;
}
#end_block

#method_before
private void renderDiffBaseListBox(ChangeInfo info) {
    JsArray<RevisionInfo> list = info.revisions().values();
    RevisionInfo.sortRevisionInfoByNumber(list);
    int selectedIdx = list.length();
    for (int i = list.length() - 1; i >= 0; i--) {
        RevisionInfo r = list.get(i);
        diffBase.addItem(r.id() + ": " + r.name().substring(0, 6), r.name());
        if (r.name().equals(revision)) {
            SelectElement.as(diffBase.getElement()).getOptions().getItem(diffBase.getItemCount() - 1).setDisabled(true);
        }
        if (base != null && base.equals(String.valueOf(r._number()))) {
            selectedIdx = diffBase.getItemCount() - 1;
        }
    }
    RevisionInfo rev = info.revisions().get(revision);
    JsArray<CommitInfo> parents = rev.commit().parents();
    diffBase.addItem(parents.length() > 1 ? Util.C.autoMerge() : Util.C.baseDiffItem(), "");
    diffBase.setSelectedIndex(selectedIdx);
}
#method_after
private void renderDiffBaseListBox(ChangeInfo info) {
    JsArray<RevisionInfo> list = info.revisions().values();
    RevisionInfo.sortRevisionInfoByNumber(list);
    int selectedIdx = list.length();
    for (int i = list.length() - 1; i >= 0; i--) {
        RevisionInfo r = list.get(i);
        diffBase.addItem(r.id() + ": " + r.name().substring(0, 6), r.name());
        if (r.name().equals(revision)) {
            SelectElement.as(diffBase.getElement()).getOptions().getItem(diffBase.getItemCount() - 1).setDisabled(true);
        }
        if (base != null && base.equals(String.valueOf(r._number()))) {
            selectedIdx = diffBase.getItemCount() - 1;
        }
    }
    RevisionInfo rev = info.revisions().get(revision);
    JsArray<CommitInfo> parents = rev.commit().parents();
    if (parents.length() > 1) {
        diffBase.addItem(Util.C.autoMerge(), "");
        for (int i = 0; i < parents.length(); i++) {
            int parentNum = i + 1;
            diffBase.addItem(Util.M.diffBaseParent(parentNum), String.valueOf(-parentNum));
        }
        int parentNum = toParentNum(base);
        if (parentNum > 0) {
            selectedIdx = list.length() + parentNum;
        }
    } else {
        diffBase.addItem(Util.C.baseDiffItem(), "");
    }
    diffBase.setSelectedIndex(selectedIdx);
}
#end_block

#method_before
public final int getMissingLabelIndex() {
    int i = -1;
    int ret = -1;
    List<LabelInfo> labels = Natives.asList(allLabels().values());
    for (LabelInfo label : labels) {
        i++;
        if (!permittedLabels().containsKey(label.name())) {
            continue;
        }
        JsArrayString values = permittedValues(label.name());
        if (values.length() == 0) {
            continue;
        }
        switch(label.status()) {
            case // Label is required for submit.
            NEED:
                if (ret != -1) {
                    // approve, return -1
                    return -1;
                } else {
                    ret = i;
                }
                continue;
            // Label already applied.
            case OK:
            case // Label is not required.
            MAY:
                continue;
            // Submit cannot happen, do not quick approve.
            case REJECT:
            case IMPOSSIBLE:
                return -1;
        }
    }
    return ret;
}
#method_after
public final int getMissingLabelIndex() {
    int i = -1;
    int ret = -1;
    List<LabelInfo> labels = Natives.asList(allLabels().values());
    for (LabelInfo label : labels) {
        i++;
        if (!permittedLabels().containsKey(label.name())) {
            continue;
        }
        JsArrayString values = permittedValues(label.name());
        if (values.length() == 0) {
            continue;
        }
        switch(label.status()) {
            case // Label is required for submit.
            NEED:
                if (ret != -1) {
                    // approve, return -1
                    return -1;
                }
                ret = i;
                continue;
            // Label already applied.
            case OK:
            case // Label is not required.
            MAY:
                continue;
            // Submit cannot happen, do not quick approve.
            case REJECT:
            case IMPOSSIBLE:
                return -1;
        }
    }
    return ret;
}
#end_block

#method_before
@Override
public boolean match(final ChangeData object) throws OrmException {
    return id.equals(object.notes().load().getAssignee());
}
#method_after
@Override
public boolean match(final ChangeData object) throws OrmException {
    if (id.get() == ChangeField.NO_ASSIGNEE) {
        return object.notes().load().getAssignee() == null;
    }
    return id.equals(object.notes().load().getAssignee());
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> is(String value) throws QueryParseException {
    if ("starred".equalsIgnoreCase(value)) {
        return starredby(self());
    }
    if ("watched".equalsIgnoreCase(value)) {
        return new IsWatchedByPredicate(args, false);
    }
    if ("visible".equalsIgnoreCase(value)) {
        return is_visible();
    }
    if ("reviewed".equalsIgnoreCase(value)) {
        return IsReviewedPredicate.create();
    }
    if ("owner".equalsIgnoreCase(value)) {
        return new OwnerPredicate(self());
    }
    if ("reviewer".equalsIgnoreCase(value)) {
        return ReviewerPredicate.create(args, self());
    }
    if ("mergeable".equalsIgnoreCase(value)) {
        return new IsMergeablePredicate(args.fillArgs);
    }
    try {
        return status(value);
    } catch (IllegalArgumentException e) {
    // not status: alias?
    }
    throw error("Invalid query");
}
#method_after
@Operator
public Predicate<ChangeData> is(String value) throws QueryParseException {
    if ("starred".equalsIgnoreCase(value)) {
        return starredby(self());
    }
    if ("watched".equalsIgnoreCase(value)) {
        return new IsWatchedByPredicate(args, false);
    }
    if ("visible".equalsIgnoreCase(value)) {
        return is_visible();
    }
    if ("reviewed".equalsIgnoreCase(value)) {
        return IsReviewedPredicate.create();
    }
    if ("owner".equalsIgnoreCase(value)) {
        return new OwnerPredicate(self());
    }
    if ("reviewer".equalsIgnoreCase(value)) {
        return ReviewerPredicate.create(args, self());
    }
    if ("mergeable".equalsIgnoreCase(value)) {
        return new IsMergeablePredicate(args.fillArgs);
    }
    if ("assigned".equalsIgnoreCase(value)) {
        return Predicate.not(new AssigneePredicate(new Account.Id(ChangeField.NO_ASSIGNEE)));
    }
    if ("unassigned".equalsIgnoreCase(value)) {
        return new AssigneePredicate(new Account.Id(ChangeField.NO_ASSIGNEE));
    }
    try {
        return status(value);
    } catch (IllegalArgumentException e) {
    // not status: alias?
    }
    throw error("Invalid query");
}
#end_block

#method_before
@Override
protected void configure() {
    install(new RestApiModule() {

        @Override
        protected void configure() {
            get(PROJECT_KIND, "lfs:config").to(GetLfsConfig.class);
            get(PROJECT_KIND, "lfs:settings").to(GetLfsSettings.class);
            put(PROJECT_KIND, "lfs:settings").to(PutLfsSettings.class);
        }
    });
}
#method_after
@Override
protected void configure() {
    install(new RestApiModule() {

        @Override
        protected void configure() {
            get(PROJECT_KIND, "lfs:config-project").to(GetLfsProjectConfig.class);
            get(PROJECT_KIND, "lfs:config-global").to(GetLfsGlobalConfig.class);
            put(PROJECT_KIND, "lfs:config-global").to(PutLfsGlobalConfig.class);
        }
    });
}
#end_block

#method_before
private Paths getPaths() {
    if (paths == null) {
        paths = new Paths();
    }
    return paths;
}
#method_after
@Provides
@Singleton
private Paths getPaths() {
    if (paths == null) {
        paths = new Paths(options);
    }
    return paths;
}
#end_block

#method_before
@Override
protected void configureServlets() {
    serveRegex("^/Documentation/(.+)$").with(named(DOC_SERVLET));
    serve("/static/*").with(SiteStaticDirectoryServlet.class);
    install(new CacheModule() {

        @Override
        protected void configure() {
            cache(CACHE, Path.class, Resource.class).maximumWeight(1 << 20).weigher(ResourceServlet.Weigher.class);
        }
    });
    install(new CoreStaticModule());
    if (options.enablePolyGWT()) {
        filter("/*").through(PolyGWTFilter.class);
        install(new GwtUiModule());
        install(new PolyGerritUiModule(true));
    } else if (options.enablePolyGerrit()) {
        install(new PolyGerritUiModule(false));
    } else if (options.enableDefaultUi()) {
        install(new GwtUiModule());
    }
}
#method_after
@Override
protected void configureServlets() {
    serveRegex("^/Documentation/(.+)$").with(named(DOC_SERVLET));
    serve("/static/*").with(SiteStaticDirectoryServlet.class);
    install(new CacheModule() {

        @Override
        protected void configure() {
            cache(CACHE, Path.class, Resource.class).maximumWeight(1 << 20).weigher(ResourceServlet.Weigher.class);
        }
    });
    if (!options.headless()) {
        install(new CoreStaticModule());
    }
    if (options.enablePolyGerrit()) {
        install(new PolyGerritModule());
    }
    if (options.enableGwtUi()) {
        install(new GwtUiModule());
    }
}
#end_block

#method_before
@Provides
@Singleton
@Named(ROBOTS_TXT_SERVLET)
HttpServlet getRobotsTxtServlet(@GerritServerConfig Config cfg, SitePaths sitePaths, @Named(CACHE) Cache<Path, Resource> cache) {
    Path configPath = sitePaths.resolve(cfg.getString("httpd", null, "robotsFile"));
    if (configPath != null) {
        if (exists(configPath) && isReadable(configPath)) {
            return new SingleFileServlet(cache, configPath, true);
        } else {
            log.warn("Cannot read httpd.robotsFile, using default");
        }
    }
    Paths p = getPaths();
    if (p.warFs != null) {
        return new SingleFileServlet(cache, p.warFs.getPath("/robots.txt"), false);
    } else {
        return new SingleFileServlet(cache, webappSourcePath("robots.txt"), true);
    }
}
#method_after
@Provides
@Singleton
@Named(ROBOTS_TXT_SERVLET)
HttpServlet getRobotsTxtServlet(@GerritServerConfig Config cfg, SitePaths sitePaths, @Named(CACHE) Cache<Path, Resource> cache) {
    Path configPath = sitePaths.resolve(cfg.getString("httpd", null, "robotsFile"));
    if (configPath != null) {
        if (exists(configPath) && isReadable(configPath)) {
            return new SingleFileServlet(cache, configPath, true);
        }
        log.warn("Cannot read httpd.robotsFile, using default");
    }
    Paths p = getPaths();
    if (p.warFs != null) {
        return new SingleFileServlet(cache, p.warFs.getPath("/robots.txt"), false);
    }
    return new SingleFileServlet(cache, webappSourcePath("robots.txt"), true);
}
#end_block

#method_before
@Provides
@Singleton
@Named(FAVICON_SERVLET)
HttpServlet getFaviconServlet(@Named(CACHE) Cache<Path, Resource> cache) {
    Paths p = getPaths();
    if (p.warFs != null) {
        return new SingleFileServlet(cache, p.warFs.getPath("/favicon.ico"), false);
    } else {
        return new SingleFileServlet(cache, webappSourcePath("favicon.ico"), true);
    }
}
#method_after
@Provides
@Singleton
@Named(FAVICON_SERVLET)
HttpServlet getFaviconServlet(@Named(CACHE) Cache<Path, Resource> cache) {
    Paths p = getPaths();
    if (p.warFs != null) {
        return new SingleFileServlet(cache, p.warFs.getPath("/favicon.ico"), false);
    }
    return new SingleFileServlet(cache, webappSourcePath("favicon.ico"), true);
}
#end_block

#method_before
@Provides
@Singleton
@Named(GWT_UI_SERVLET)
HttpServlet getGwtUiServlet(@Named(CACHE) Cache<Path, Resource> cache) throws IOException {
    Paths p = getPaths();
    if (p.warFs != null) {
        return new WarGwtUiServlet(cache, p.warFs);
    } else {
        return new DirectoryGwtUiServlet(cache, p.unpackedWar, p.isDev());
    }
}
#method_after
@Provides
@Singleton
@Named(GWT_UI_SERVLET)
HttpServlet getGwtUiServlet(@Named(CACHE) Cache<Path, Resource> cache) throws IOException {
    Paths p = getPaths();
    if (p.warFs != null) {
        return new WarGwtUiServlet(cache, p.warFs);
    }
    return new DirectoryGwtUiServlet(cache, p.unpackedWar, p.isDev());
}
#end_block

#method_before
private File getLauncherLoadedFrom() {
    File war;
    try {
        war = GerritLauncher.getDistributionArchive();
    } catch (IOException e) {
        if ((e instanceof FileNotFoundException) && GerritLauncher.NOT_ARCHIVED.equals(e.getMessage())) {
            return null;
        } else {
            ProvisionException pe = new ProvisionException("Error reading gerrit.war");
            pe.initCause(e);
            throw pe;
        }
    }
    return war;
}
#method_after
private File getLauncherLoadedFrom() {
    File war;
    try {
        war = GerritLauncher.getDistributionArchive();
    } catch (IOException e) {
        if ((e instanceof FileNotFoundException) && GerritLauncher.NOT_ARCHIVED.equals(e.getMessage())) {
            return null;
        }
        ProvisionException pe = new ProvisionException("Error reading gerrit.war");
        pe.initCause(e);
        throw pe;
    }
    return war;
}
#end_block

#method_before
@Override
protected void configureServlets() {
    filter("/*").through(Key.get(CacheControlFilter.class));
    bind(Key.get(CacheControlFilter.class)).in(SINGLETON);
    if (options.enableDefaultUi() || options.enablePolyGWT()) {
        filter("/").through(XsrfCookieFilter.class);
        serve("/").with(HostPageServlet.class);
        serve("/Gerrit").with(LegacyGerritServlet.class);
        serve("/Gerrit/*").with(legacyGerritScreen());
    }
    serve("/cat/*").with(CatServlet.class);
    if (authConfig.getAuthType() != AuthType.OAUTH && authConfig.getAuthType() != AuthType.OPENID) {
        serve("/logout").with(HttpLogoutServlet.class);
        serve("/signout").with(HttpLogoutServlet.class);
    }
    serve("/ssh_info").with(SshInfoServlet.class);
    serve("/Main.class").with(notFound());
    serve("/com/google/gerrit/launcher/*").with(notFound());
    serve("/servlet/*").with(notFound());
    serve("/all").with(query("status:merged"));
    serve("/mine").with(screen(PageLinks.MINE));
    serve("/open").with(query("status:open"));
    serve("/watched").with(query("is:watched status:open"));
    serve("/starred").with(query("is:starred"));
    serveRegex("^/settings/?$").with(screen(PageLinks.SETTINGS));
    serveRegex("^/register/?$").with(screen(PageLinks.REGISTER + "/"));
    serveRegex("^/([1-9][0-9]*)/?$").with(directChangeById());
    serveRegex("^/p/(.*)$").with(queryProjectNew());
    serveRegex("^/r/(.+)/?$").with(DirectChangeByCommit.class);
    filter("/a/*").through(RequireIdentifiedUserFilter.class);
    serveRegex("^/(?:a/)?tools/(.*)$").with(ToolServlet.class);
    serveRegex("^/(?:a/)?access/(.*)$").with(AccessRestApiServlet.class);
    serveRegex("^/(?:a/)?accounts/(.*)$").with(AccountsRestApiServlet.class);
    serveRegex("^/(?:a/)?changes/(.*)$").with(ChangesRestApiServlet.class);
    serveRegex("^/(?:a/)?config/(.*)$").with(ConfigRestApiServlet.class);
    serveRegex("^/(?:a/)?groups/(.*)?$").with(GroupsRestApiServlet.class);
    serveRegex("^/(?:a/)?projects/(.*)?$").with(ProjectsRestApiServlet.class);
    filter("/Documentation/").through(QueryDocumentationFilter.class);
}
#method_after
@Override
protected void configureServlets() {
    filter("/*").through(Key.get(CacheControlFilter.class));
    bind(Key.get(CacheControlFilter.class)).in(SINGLETON);
    if (options.enableGwtUi()) {
        filter("/").through(XsrfCookieFilter.class);
        filter("/accounts/self/detail").through(XsrfCookieFilter.class);
        serve("/").with(HostPageServlet.class);
        serve("/Gerrit").with(LegacyGerritServlet.class);
        serve("/Gerrit/*").with(legacyGerritScreen());
        // Forward PolyGerrit URLs to their respective GWT equivalents.
        serveRegex("^/(c|q|x|admin|dashboard|settings)/(.*)").with(gerritUrl());
    }
    serve("/cat/*").with(CatServlet.class);
    if (authConfig.getAuthType() != AuthType.OAUTH && authConfig.getAuthType() != AuthType.OPENID) {
        serve("/logout").with(HttpLogoutServlet.class);
        serve("/signout").with(HttpLogoutServlet.class);
    }
    serve("/ssh_info").with(SshInfoServlet.class);
    serve("/Main.class").with(notFound());
    serve("/com/google/gerrit/launcher/*").with(notFound());
    serve("/servlet/*").with(notFound());
    serve("/all").with(query("status:merged"));
    serve("/mine").with(screen(PageLinks.MINE));
    serve("/open").with(query("status:open"));
    serve("/watched").with(query("is:watched status:open"));
    serve("/starred").with(query("is:starred"));
    serveRegex("^/settings/?$").with(screen(PageLinks.SETTINGS));
    serveRegex("^/register/?$").with(screen(PageLinks.REGISTER + "/"));
    serveRegex("^/([1-9][0-9]*)/?$").with(directChangeById());
    serveRegex("^/p/(.*)$").with(queryProjectNew());
    serveRegex("^/r/(.+)/?$").with(DirectChangeByCommit.class);
    filter("/a/*").through(RequireIdentifiedUserFilter.class);
    serveRegex("^/(?:a/)?tools/(.*)$").with(ToolServlet.class);
    // Bind servlets for REST root collections.
    // The '/plugins/' root collection is already handled by HttpPluginServlet
    // which is bound in HttpPluginModule. We cannot bind it here again although
    // this means that plugins can't add REST views on PLUGIN_KIND.
    serveRegex("^/(?:a/)?access/(.*)$").with(AccessRestApiServlet.class);
    serveRegex("^/(?:a/)?accounts/(.*)$").with(AccountsRestApiServlet.class);
    serveRegex("^/(?:a/)?changes/(.*)$").with(ChangesRestApiServlet.class);
    serveRegex("^/(?:a/)?config/(.*)$").with(ConfigRestApiServlet.class);
    serveRegex("^/(?:a/)?groups/(.*)?$").with(GroupsRestApiServlet.class);
    serveRegex("^/(?:a/)?projects/(.*)?$").with(ProjectsRestApiServlet.class);
    filter("/Documentation/").through(QueryDocumentationFilter.class);
}
#end_block

#method_before
@Override
protected Path getResourcePath(String pathInfo) throws IOException {
    if (bowerComponents == null) {
        throw new IOException("No polymer components found: " + zip + ". Run `buck build //polygerrit-ui:polygerrit_components`?");
    }
    // Why we need to remove here bower_components suffix?
    if (pathInfo.startsWith("bower_components")) {
        int offset = "bower_components".length() + 1;
        pathInfo = pathInfo.substring(offset, pathInfo.length());
    }
    return bowerComponents.resolve(pathInfo);
}
#method_after
@Override
protected Path getResourcePath(String pathInfo) throws IOException {
    if (bowerComponents == null) {
        throw new IOException("No polymer components found: " + zip + ". Run `buck build //polygerrit-ui:polygerrit_components`?");
    }
    return bowerComponents.resolve(pathInfo);
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ChangesCollection.class);
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(DraftComments.class);
    bind(Comments.class);
    bind(Files.class);
    bind(Votes.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), DRAFT_COMMENT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    DynamicMap.mapOf(binder(), CHANGE_EDIT_KIND);
    DynamicMap.mapOf(binder(), VOTE_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    get(CHANGE_KIND, "in").to(IncludedIn.class);
    get(CHANGE_KIND, "hashtags").to(GetHashtags.class);
    get(CHANGE_KIND, "comments").to(ListChangeComments.class);
    get(CHANGE_KIND, "drafts").to(ListChangeDrafts.class);
    get(CHANGE_KIND, "check").to(Check.class);
    post(CHANGE_KIND, "check").to(Check.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND).to(DeleteDraftChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "hashtags").to(PostHashtags.class);
    post(CHANGE_KIND, "publish").to(PublishDraftPatchSet.CurrentRevision.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    get(CHANGE_KIND, "submitted_together").to(SubmittedTogether.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "index").to(Index.class);
    post(CHANGE_KIND, "rebuild.notedb").to(Rebuild.class);
    post(CHANGE_KIND, "move").to(Move.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    get(CHANGE_KIND, "suggest_reviewers").to(SuggestChangeReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    child(REVIEWER_KIND, "votes").to(Votes.class);
    delete(VOTE_KIND).to(DeleteVote.class);
    post(VOTE_KIND, "delete").to(DeleteVote.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    get(REVISION_KIND, "actions").to(GetRevisionActions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    delete(REVISION_KIND).to(DeleteDraftPatchSet.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    post(REVISION_KIND, "publish").to(PublishDraftPatchSet.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    get(REVISION_KIND, "submit_prediction").to(SubmitPrediction.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    get(REVISION_KIND, "archive").to(GetArchive.class);
    child(REVISION_KIND, "drafts").to(DraftComments.class);
    put(REVISION_KIND, "drafts").to(CreateDraftComment.class);
    get(DRAFT_COMMENT_KIND).to(GetDraftComment.class);
    put(DRAFT_COMMENT_KIND).to(PutDraftComment.class);
    delete(DRAFT_COMMENT_KIND).to(DeleteDraftComment.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "download").to(DownloadContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    get(FILE_KIND, "blame").to(GetBlame.class);
    child(CHANGE_KIND, "edit").to(ChangeEdits.class);
    delete(CHANGE_KIND, "edit").to(DeleteChangeEdit.class);
    child(CHANGE_KIND, "edit:publish").to(PublishChangeEdit.class);
    child(CHANGE_KIND, "edit:rebase").to(RebaseChangeEdit.class);
    put(CHANGE_KIND, "edit:message").to(ChangeEdits.EditMessage.class);
    get(CHANGE_KIND, "edit:message").to(ChangeEdits.GetMessage.class);
    put(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Put.class);
    delete(CHANGE_EDIT_KIND).to(ChangeEdits.DeleteContent.class);
    get(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Get.class);
    get(CHANGE_EDIT_KIND, "meta").to(ChangeEdits.GetMeta.class);
    factory(AccountLoader.Factory.class);
    factory(ChangeEdits.Create.Factory.class);
    factory(ChangeEdits.DeleteFile.Factory.class);
    factory(ChangeInserter.Factory.class);
    factory(EmailReviewComments.Factory.class);
    factory(PatchSetInserter.Factory.class);
    factory(RebaseChangeOp.Factory.class);
    factory(ReviewerResource.Factory.class);
    factory(SetHashtagsOp.Factory.class);
    factory(ChangeResource.Factory.class);
}
#method_after
@Override
protected void configure() {
    bind(ChangesCollection.class);
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(DraftComments.class);
    bind(Comments.class);
    bind(Files.class);
    bind(Votes.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), DRAFT_COMMENT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    DynamicMap.mapOf(binder(), CHANGE_EDIT_KIND);
    DynamicMap.mapOf(binder(), VOTE_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    get(CHANGE_KIND, "in").to(IncludedIn.class);
    get(CHANGE_KIND, "hashtags").to(GetHashtags.class);
    get(CHANGE_KIND, "comments").to(ListChangeComments.class);
    get(CHANGE_KIND, "drafts").to(ListChangeDrafts.class);
    get(CHANGE_KIND, "check").to(Check.class);
    post(CHANGE_KIND, "check").to(Check.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND).to(DeleteDraftChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "hashtags").to(PostHashtags.class);
    post(CHANGE_KIND, "publish").to(PublishDraftPatchSet.CurrentRevision.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    get(CHANGE_KIND, "submitted_together").to(SubmittedTogether.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "index").to(Index.class);
    post(CHANGE_KIND, "rebuild.notedb").to(Rebuild.class);
    post(CHANGE_KIND, "move").to(Move.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    get(CHANGE_KIND, "suggest_reviewers").to(SuggestChangeReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    post(REVIEWER_KIND, "delete").to(DeleteReviewer.class);
    child(REVIEWER_KIND, "votes").to(Votes.class);
    delete(VOTE_KIND).to(DeleteVote.class);
    post(VOTE_KIND, "delete").to(DeleteVote.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    get(REVISION_KIND, "actions").to(GetRevisionActions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    delete(REVISION_KIND).to(DeleteDraftPatchSet.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    post(REVISION_KIND, "publish").to(PublishDraftPatchSet.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    get(REVISION_KIND, "preview_submit").to(PreviewSubmit.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    get(REVISION_KIND, "archive").to(GetArchive.class);
    get(REVISION_KIND, "mergelist").to(GetMergeList.class);
    child(REVISION_KIND, "drafts").to(DraftComments.class);
    put(REVISION_KIND, "drafts").to(CreateDraftComment.class);
    get(DRAFT_COMMENT_KIND).to(GetDraftComment.class);
    put(DRAFT_COMMENT_KIND).to(PutDraftComment.class);
    delete(DRAFT_COMMENT_KIND).to(DeleteDraftComment.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "download").to(DownloadContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    get(FILE_KIND, "blame").to(GetBlame.class);
    child(CHANGE_KIND, "edit").to(ChangeEdits.class);
    delete(CHANGE_KIND, "edit").to(DeleteChangeEdit.class);
    child(CHANGE_KIND, "edit:publish").to(PublishChangeEdit.class);
    child(CHANGE_KIND, "edit:rebase").to(RebaseChangeEdit.class);
    put(CHANGE_KIND, "edit:message").to(ChangeEdits.EditMessage.class);
    get(CHANGE_KIND, "edit:message").to(ChangeEdits.GetMessage.class);
    put(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Put.class);
    delete(CHANGE_EDIT_KIND).to(ChangeEdits.DeleteContent.class);
    get(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Get.class);
    get(CHANGE_EDIT_KIND, "meta").to(ChangeEdits.GetMeta.class);
    factory(AccountLoader.Factory.class);
    factory(ChangeEdits.Create.Factory.class);
    factory(ChangeEdits.DeleteFile.Factory.class);
    factory(ChangeInserter.Factory.class);
    factory(EmailReviewComments.Factory.class);
    factory(PatchSetInserter.Factory.class);
    factory(RebaseChangeOp.Factory.class);
    factory(ReviewerResource.Factory.class);
    factory(SetHashtagsOp.Factory.class);
    factory(ChangeResource.Factory.class);
}
#end_block

#method_before
BatchUpdate getUpdate() {
    checkState(db != null, "call setContext before getUpdate");
    if (update == null) {
        update = batchUpdateFactory.create(db, getProjectName(), caller, ts).setRepository(repo, rw, ins).setRequestId(submissionId);
    }
    return update;
}
#method_after
public BatchUpdate getUpdate() {
    checkState(db != null, "call setContext before getUpdate");
    if (update == null) {
        update = batchUpdateFactory.create(db, getProjectName(), caller, ts).setRepository(repo, rw, ins).setRequestId(submissionId);
    }
    return update;
}
#end_block

#method_before
public OpenRepo openRepo(Project.NameKey project, boolean abortIfOpen) throws NoSuchProjectException, IOException {
    if (abortIfOpen) {
        checkState(!openRepos.containsKey(project), "repo already opened: %s", project);
    }
    if (openRepos.containsKey(project)) {
        return openRepos.get(project);
    }
    ProjectState projectState = projectCache.get(project);
    if (projectState == null) {
        throw new NoSuchProjectException(project);
    }
    try {
        OpenRepo or = new OpenRepo(repoManager.openRepository(project), projectState);
        openRepos.put(project, or);
        return or;
    } catch (RepositoryNotFoundException e) {
        throw new NoSuchProjectException(project);
    }
}
#method_after
public OpenRepo openRepo(Project.NameKey project) throws NoSuchProjectException, IOException {
    if (openRepos.containsKey(project)) {
        return openRepos.get(project);
    }
    ProjectState projectState = projectCache.get(project);
    if (projectState == null) {
        throw new NoSuchProjectException(project);
    }
    try {
        OpenRepo or = new OpenRepo(repoManager.openRepository(project), projectState);
        openRepos.put(project, or);
        return or;
    } catch (RepositoryNotFoundException e) {
        throw new NoSuchProjectException(project);
    }
}
#end_block

#method_before
public void execute(Listener listener) throws UpdateException, RestApiException {
    execute(ImmutableList.of(this), listener, requestId);
}
#method_after
static void execute(Collection<BatchUpdate> updates, Listener listener, @Nullable RequestId requestId, boolean dryrun) throws UpdateException, RestApiException {
    if (updates.isEmpty()) {
        return;
    }
    if (requestId != null) {
        for (BatchUpdate u : updates) {
            checkArgument(u.requestId == null || u.requestId == requestId, "refusing to overwrite RequestId %s in update with %s", u.requestId, requestId);
            u.setRequestId(requestId);
        }
    }
    try {
        Order order = getOrder(updates);
        boolean updateChangesInParallel = getUpdateChangesInParallel(updates);
        switch(order) {
            case REPO_BEFORE_DB:
                for (BatchUpdate u : updates) {
                    u.executeUpdateRepo();
                }
                listener.afterUpdateRepos();
                for (BatchUpdate u : updates) {
                    u.executeRefUpdates(dryrun);
                }
                listener.afterRefUpdates();
                for (BatchUpdate u : updates) {
                    u.executeChangeOps(updateChangesInParallel, dryrun);
                }
                listener.afterUpdateChanges();
                break;
            case DB_BEFORE_REPO:
                for (BatchUpdate u : updates) {
                    u.executeChangeOps(updateChangesInParallel, dryrun);
                }
                listener.afterUpdateChanges();
                for (BatchUpdate u : updates) {
                    u.executeUpdateRepo();
                }
                listener.afterUpdateRepos();
                for (BatchUpdate u : updates) {
                    u.executeRefUpdates(dryrun);
                }
                listener.afterRefUpdates();
                break;
            default:
                throw new IllegalStateException("invalid execution order: " + order);
        }
        List<CheckedFuture<?, IOException>> indexFutures = new ArrayList<>();
        for (BatchUpdate u : updates) {
            indexFutures.addAll(u.indexFutures);
        }
        ChangeIndexer.allAsList(indexFutures).get();
        for (BatchUpdate u : updates) {
            if (u.batchRefUpdate != null) {
                // Fire ref update events only after all mutations are finished, since
                // callers may assume a patch set ref being created means the change
                // was created, or a branch advancing meaning some changes were
                // closed.
                u.gitRefUpdated.fire(u.project, u.batchRefUpdate, u.getUser().isIdentifiedUser() ? u.getUser().getAccountId() : null);
            }
        }
        if (!dryrun) {
            for (BatchUpdate u : updates) {
                u.executePostOps();
            }
        }
    } catch (UpdateException | RestApiException e) {
        // failure.
        throw e;
    // Convert other common non-REST exception types with user-visible
    // messages to corresponding REST exception types
    } catch (InvalidChangeOperationException e) {
        throw new ResourceConflictException(e.getMessage(), e);
    } catch (NoSuchChangeException | NoSuchRefException | NoSuchProjectException e) {
        throw new ResourceNotFoundException(e.getMessage(), e);
    } catch (Exception e) {
        Throwables.propagateIfPossible(e);
        throw new UpdateException(e);
    }
}
#end_block

#method_before
public Collection<ReceiveCommand> getRefUpdates() throws UpdateException, RestApiException {
    executeUpdateRepo();
    return commands.getCommands().values();
}
#method_after
public Collection<ReceiveCommand> getRefUpdates() {
    return commands.getCommands().values();
}
#end_block

#method_before
public void execute(Listener listener) throws UpdateException, RestApiException {
    execute(ImmutableList.of(this), listener, requestId);
}
#method_after
public void execute(Listener listener) throws UpdateException, RestApiException {
    execute(ImmutableList.of(this), listener, requestId, false);
}
#end_block

#method_before
private void executeUpdateRepo() throws UpdateException, RestApiException {
    try {
        logDebug("Executing updateRepo on {} ops", ops.size());
        RepoContext ctx = new RepoContext();
        for (Op op : ops.values()) {
            op.updateRepo(ctx);
        }
        if (!repoOnlyOps.isEmpty()) {
            logDebug("Executing updateRepo on {} RepoOnlyOps", ops.size());
            for (RepoOnlyOp op : repoOnlyOps) {
                op.updateRepo(ctx);
            }
        }
        if (inserter != null) {
            // todo should be optional
            logDebug("Flushing inserter");
            inserter.flush();
        } else {
            logDebug("No objects to flush");
        }
    } catch (Exception e) {
        Throwables.propagateIfPossible(e, RestApiException.class);
        throw new UpdateException(e);
    }
}
#method_after
private void executeUpdateRepo() throws UpdateException, RestApiException {
    try {
        logDebug("Executing updateRepo on {} ops", ops.size());
        RepoContext ctx = new RepoContext();
        for (Op op : ops.values()) {
            op.updateRepo(ctx);
        }
        if (!repoOnlyOps.isEmpty()) {
            logDebug("Executing updateRepo on {} RepoOnlyOps", ops.size());
            for (RepoOnlyOp op : repoOnlyOps) {
                op.updateRepo(ctx);
            }
        }
        if (inserter != null) {
            logDebug("Flushing inserter");
            inserter.flush();
        } else {
            logDebug("No objects to flush");
        }
    } catch (Exception e) {
        Throwables.propagateIfPossible(e, RestApiException.class);
        throw new UpdateException(e);
    }
}
#end_block

#method_before
private void executeRefUpdates() throws IOException, UpdateException {
    if (commands == null || commands.isEmpty()) {
        logDebug("No ref updates to execute");
        return;
    }
    // May not be opened if the caller added ref updates but no new objects.
    initRepository();
    batchRefUpdate = repo.getRefDatabase().newBatchUpdate();
    commands.addTo(batchRefUpdate);
    logDebug("Executing batch of {} ref updates", batchRefUpdate.getCommands().size());
    batchRefUpdate.execute(revWalk, NullProgressMonitor.INSTANCE);
    boolean ok = true;
    for (ReceiveCommand cmd : batchRefUpdate.getCommands()) {
        if (cmd.getResult() != ReceiveCommand.Result.OK) {
            ok = false;
            break;
        }
    }
    if (!ok) {
        throw new UpdateException("BatchRefUpdate failed: " + batchRefUpdate);
    }
}
#method_after
private void executeRefUpdates(boolean dryrun) throws IOException, UpdateException {
    if (commands == null || commands.isEmpty()) {
        logDebug("No ref updates to execute");
        return;
    }
    // May not be opened if the caller added ref updates but no new objects.
    initRepository();
    batchRefUpdate = repo.getRefDatabase().newBatchUpdate();
    commands.addTo(batchRefUpdate);
    logDebug("Executing batch of {} ref updates", batchRefUpdate.getCommands().size());
    if (dryrun) {
        return;
    }
    batchRefUpdate.execute(revWalk, NullProgressMonitor.INSTANCE);
    boolean ok = true;
    for (ReceiveCommand cmd : batchRefUpdate.getCommands()) {
        if (cmd.getResult() != ReceiveCommand.Result.OK) {
            ok = false;
            break;
        }
    }
    if (!ok) {
        throw new UpdateException("BatchRefUpdate failed: " + batchRefUpdate);
    }
}
#end_block

#method_before
private void executeChangeOps(boolean parallel) throws UpdateException, RestApiException {
    logDebug("Executing change ops (parallel? {})", parallel);
    ListeningExecutorService executor = parallel ? changeUpdateExector : MoreExecutors.newDirectExecutorService();
    List<ChangeTask> tasks = new ArrayList<>(ops.keySet().size());
    try {
        if (notesMigration.commitChangeWrites() && repo != null) {
            // A NoteDb change may have been rebuilt since the repo was originally
            // opened, so make sure we see that.
            logDebug("Preemptively scanning for repo changes");
            repo.scanForRepoChanges();
        }
        if (!ops.isEmpty() && notesMigration.failChangeWrites()) {
            // Fail fast before attempting any writes if changes are read-only, as
            // this is a programmer error.
            logDebug("Failing early due to read-only Changes table");
            throw new OrmException(NoteDbUpdateManager.CHANGES_READ_ONLY);
        }
        List<ListenableFuture<?>> futures = new ArrayList<>(ops.keySet().size());
        for (Map.Entry<Change.Id, Collection<Op>> e : ops.asMap().entrySet()) {
            ChangeTask task = new ChangeTask(e.getKey(), e.getValue(), Thread.currentThread());
            tasks.add(task);
            if (!parallel) {
                logDebug("Direct execution of task for ops: {}", ops);
            }
            futures.add(executor.submit(task));
        }
        if (parallel) {
            logDebug("Waiting on futures for {} ops spanning {} changes", ops.size(), ops.keySet().size());
        }
        // TODO(dborowitz): Timing is wrong for non-parallel updates.
        long startNanos = System.nanoTime();
        Futures.allAsList(futures).get();
        maybeLogSlowUpdate(startNanos, "change");
        if (notesMigration.commitChangeWrites()) {
            startNanos = System.nanoTime();
            executeNoteDbUpdates(tasks);
            maybeLogSlowUpdate(startNanos, "NoteDb");
        }
    } catch (ExecutionException | InterruptedException e) {
        Throwables.propagateIfInstanceOf(e.getCause(), UpdateException.class);
        Throwables.propagateIfInstanceOf(e.getCause(), RestApiException.class);
        throw new UpdateException(e);
    } catch (OrmException | IOException e) {
        throw new UpdateException(e);
    }
    // Reindex changes.
    for (ChangeTask task : tasks) {
        if (task.deleted) {
            indexFutures.add(indexer.deleteAsync(task.id));
        } else if (task.dirty) {
            indexFutures.add(indexer.indexAsync(project, task.id));
        }
    }
}
#method_after
private void executeChangeOps(boolean parallel, boolean dryrun) throws UpdateException, RestApiException {
    logDebug("Executing change ops (parallel? {})", parallel);
    ListeningExecutorService executor = parallel ? changeUpdateExector : MoreExecutors.newDirectExecutorService();
    List<ChangeTask> tasks = new ArrayList<>(ops.keySet().size());
    try {
        if (notesMigration.commitChangeWrites() && repo != null) {
            // A NoteDb change may have been rebuilt since the repo was originally
            // opened, so make sure we see that.
            logDebug("Preemptively scanning for repo changes");
            repo.scanForRepoChanges();
        }
        if (!ops.isEmpty() && notesMigration.failChangeWrites()) {
            // Fail fast before attempting any writes if changes are read-only, as
            // this is a programmer error.
            logDebug("Failing early due to read-only Changes table");
            throw new OrmException(NoteDbUpdateManager.CHANGES_READ_ONLY);
        }
        List<ListenableFuture<?>> futures = new ArrayList<>(ops.keySet().size());
        for (Map.Entry<Change.Id, Collection<Op>> e : ops.asMap().entrySet()) {
            ChangeTask task = new ChangeTask(e.getKey(), e.getValue(), Thread.currentThread(), dryrun);
            tasks.add(task);
            if (!parallel) {
                logDebug("Direct execution of task for ops: {}", ops);
            }
            futures.add(executor.submit(task));
        }
        if (parallel) {
            logDebug("Waiting on futures for {} ops spanning {} changes", ops.size(), ops.keySet().size());
        }
        // TODO(dborowitz): Timing is wrong for non-parallel updates.
        long startNanos = System.nanoTime();
        Futures.allAsList(futures).get();
        maybeLogSlowUpdate(startNanos, "change");
        if (notesMigration.commitChangeWrites()) {
            startNanos = System.nanoTime();
            if (!dryrun) {
                executeNoteDbUpdates(tasks);
            }
            maybeLogSlowUpdate(startNanos, "NoteDb");
        }
    } catch (ExecutionException | InterruptedException e) {
        Throwables.propagateIfInstanceOf(e.getCause(), UpdateException.class);
        Throwables.propagateIfInstanceOf(e.getCause(), RestApiException.class);
        throw new UpdateException(e);
    } catch (OrmException | IOException e) {
        throw new UpdateException(e);
    }
    // Reindex changes.
    for (ChangeTask task : tasks) {
        if (task.deleted) {
            indexFutures.add(indexer.deleteAsync(task.id));
        } else if (task.dirty) {
            indexFutures.add(indexer.indexAsync(project, task.id));
        }
    }
}
#end_block

#method_before
private void call(ReviewDb db, Repository repo, RevWalk rw) throws Exception {
    // Not always opened.
    @SuppressWarnings("resource")
    NoteDbUpdateManager updateManager = null;
    try {
        ChangeContext ctx;
        db.changes().beginTransaction(id);
        try {
            ctx = newChangeContext(db, repo, rw, id);
            // Call updateChange on each op.
            logDebug("Calling updateChange on {} ops", changeOps.size());
            for (Op op : changeOps) {
                dirty |= op.updateChange(ctx);
            }
            if (!dirty) {
                logDebug("No ops reported dirty, short-circuiting");
                return;
            }
            deleted = ctx.deleted;
            if (deleted) {
                logDebug("Change was deleted");
            }
            // Stage the NoteDb update and store its state in the Change.
            if (notesMigration.commitChangeWrites()) {
                updateManager = stageNoteDbUpdate(ctx, deleted);
            }
            // Bump lastUpdatedOn or rowVersion and commit.
            Iterable<Change> cs = changesToUpdate(ctx);
            if (newChanges.containsKey(id)) {
                // Insert rather than upsert in case of a race on change IDs.
                logDebug("Inserting change");
                db.changes().insert(cs);
            } else if (deleted) {
                logDebug("Deleting change");
                db.changes().delete(cs);
            } else {
                logDebug("Updating change");
                db.changes().update(cs);
            }
            db.commit();
        } finally {
            db.rollback();
        }
        if (notesMigration.commitChangeWrites()) {
            try {
                // Do not execute the NoteDbUpdateManager, as we don't want too much
                // contention on the underlying repo, and we would rather use a
                // single ObjectInserter/BatchRefUpdate later.
                // 
                // TODO(dborowitz): May or may not be worth trying to batch
                // together flushed inserters as well.
                noteDbResult = updateManager.stage().get(id);
            } catch (IOException ex) {
                // Ignore all errors trying to update NoteDb at this point. We've
                // already written the NoteDbChangeState to ReviewDb, which means
                // if the state is out of date it will be rebuilt the next time it
                // is needed.
                log.debug("Ignoring NoteDb update error after ReviewDb write", ex);
            }
        }
    } catch (Exception e) {
        logDebug("Error updating change (should be rethrown)", e);
        Throwables.propagateIfPossible(e, RestApiException.class);
        throw new UpdateException(e);
    } finally {
        if (updateManager != null) {
            updateManager.close();
        }
    }
}
#method_after
private void call(ReviewDb db, Repository repo, RevWalk rw) throws Exception {
    // Not always opened.
    @SuppressWarnings("resource")
    NoteDbUpdateManager updateManager = null;
    try {
        ChangeContext ctx;
        db.changes().beginTransaction(id);
        try {
            ctx = newChangeContext(db, repo, rw, id);
            // Call updateChange on each op.
            logDebug("Calling updateChange on {} ops", changeOps.size());
            for (Op op : changeOps) {
                dirty |= op.updateChange(ctx);
            }
            if (!dirty) {
                logDebug("No ops reported dirty, short-circuiting");
                return;
            }
            deleted = ctx.deleted;
            if (deleted) {
                logDebug("Change was deleted");
            }
            // Stage the NoteDb update and store its state in the Change.
            if (notesMigration.commitChangeWrites()) {
                updateManager = stageNoteDbUpdate(ctx, deleted);
            }
            // Bump lastUpdatedOn or rowVersion and commit.
            Iterable<Change> cs = changesToUpdate(ctx);
            if (newChanges.containsKey(id)) {
                // Insert rather than upsert in case of a race on change IDs.
                logDebug("Inserting change");
                db.changes().insert(cs);
            } else if (deleted) {
                logDebug("Deleting change");
                db.changes().delete(cs);
            } else {
                logDebug("Updating change");
                db.changes().update(cs);
            }
            if (!dryrun) {
                db.commit();
            }
        } finally {
            db.rollback();
        }
        if (notesMigration.commitChangeWrites()) {
            try {
                // Do not execute the NoteDbUpdateManager, as we don't want too much
                // contention on the underlying repo, and we would rather use a
                // single ObjectInserter/BatchRefUpdate later.
                // 
                // TODO(dborowitz): May or may not be worth trying to batch
                // together flushed inserters as well.
                noteDbResult = updateManager.stage().get(id);
            } catch (IOException ex) {
                // Ignore all errors trying to update NoteDb at this point. We've
                // already written the NoteDbChangeState to ReviewDb, which means
                // if the state is out of date it will be rebuilt the next time it
                // is needed.
                log.debug("Ignoring NoteDb update error after ReviewDb write", ex);
            }
        }
    } catch (Exception e) {
        logDebug("Error updating change (should be rethrown)", e);
        Throwables.propagateIfPossible(e, RestApiException.class);
        throw new UpdateException(e);
    } finally {
        if (updateManager != null) {
            updateManager.close();
        }
    }
}
#end_block

#method_before
void sendMessages() {
    for (CommitValidationMessage m : messages) {
        if (m.isError()) {
            messageSender.sendError(m.getMessage());
        } else {
            messageSender.sendMessage(m.getMessage());
        }
    }
}
#method_after
void sendMessages() {
    for (ValidationMessage m : messages) {
        if (m.isError()) {
            messageSender.sendError(m.getMessage());
        } else {
            messageSender.sendMessage(m.getMessage());
        }
    }
}
#end_block

#method_before
private void reportMessages() {
    Iterable<CreateRequest> created = Iterables.filter(newChanges, new Predicate<CreateRequest>() {

        @Override
        public boolean apply(CreateRequest input) {
            return input.change != null;
        }
    });
    if (!Iterables.isEmpty(created)) {
        addMessage("");
        addMessage("New Changes:");
        for (CreateRequest c : created) {
            addMessage(formatChangeUrl(canonicalWebUrl, c.change, c.change.getSubject(), false));
        }
        addMessage("");
    }
    List<ReplaceRequest> updated = FluentIterable.from(replaceByChange.values()).filter(new Predicate<ReplaceRequest>() {

        @Override
        public boolean apply(ReplaceRequest input) {
            return !input.skip && input.inputCommand.getResult() == OK;
        }
    }).toSortedList(Ordering.natural().onResultOf(new Function<ReplaceRequest, Integer>() {

        @Override
        public Integer apply(ReplaceRequest in) {
            return in.notes.getChangeId().get();
        }
    }));
    if (!updated.isEmpty()) {
        addMessage("");
        addMessage("Updated Changes:");
        boolean edit = magicBranch != null && magicBranch.edit;
        for (ReplaceRequest u : updated) {
            String subject;
            if (edit) {
                try {
                    subject = rp.getRevWalk().parseCommit(u.newCommitId).getShortMessage();
                } catch (IOException e) {
                    // Log and fall back to original change subject
                    logWarn("failed to get subject for edit patch set", e);
                    subject = u.notes.getChange().getSubject();
                }
            } else {
                subject = u.info.getSubject();
            }
            addMessage(formatChangeUrl(canonicalWebUrl, u.notes.getChange(), subject, edit));
        }
        addMessage("");
    }
}
#method_after
private void reportMessages() {
    Iterable<CreateRequest> created = Iterables.filter(newChanges, new Predicate<CreateRequest>() {

        @Override
        public boolean apply(CreateRequest input) {
            return input.change != null;
        }
    });
    if (!Iterables.isEmpty(created)) {
        addMessage("");
        addMessage("New Changes:");
        for (CreateRequest c : created) {
            addMessage(formatChangeUrl(canonicalWebUrl, c.change, c.change.getSubject(), c.change.getStatus() == Change.Status.DRAFT, false));
        }
        addMessage("");
    }
    List<ReplaceRequest> updated = FluentIterable.from(replaceByChange.values()).filter(new Predicate<ReplaceRequest>() {

        @Override
        public boolean apply(ReplaceRequest input) {
            return !input.skip && input.inputCommand.getResult() == OK;
        }
    }).toSortedList(Ordering.natural().onResultOf(new Function<ReplaceRequest, Integer>() {

        @Override
        public Integer apply(ReplaceRequest in) {
            return in.notes.getChangeId().get();
        }
    }));
    if (!updated.isEmpty()) {
        addMessage("");
        addMessage("Updated Changes:");
        boolean edit = magicBranch != null && magicBranch.edit;
        for (ReplaceRequest u : updated) {
            String subject;
            if (edit) {
                try {
                    subject = rp.getRevWalk().parseCommit(u.newCommitId).getShortMessage();
                } catch (IOException e) {
                    // Log and fall back to original change subject
                    logWarn("failed to get subject for edit patch set", e);
                    subject = u.notes.getChange().getSubject();
                }
            } else {
                subject = u.info.getSubject();
            }
            addMessage(formatChangeUrl(canonicalWebUrl, u.notes.getChange(), subject, u.replaceOp != null && u.replaceOp.getPatchSet().isDraft(), edit));
        }
        addMessage("");
    }
}
#end_block

#method_before
private static String formatChangeUrl(String url, Change change, String subject, boolean edit) {
    StringBuilder m = new StringBuilder().append("  ").append(url).append(change.getChangeId()).append(" ").append(ChangeUtil.cropSubject(subject));
    if (change.getStatus() == Change.Status.DRAFT) {
        m.append(" [DRAFT]");
    }
    if (edit) {
        m.append(" [EDIT]");
    }
    return m.toString();
}
#method_after
private static String formatChangeUrl(String url, Change change, String subject, boolean draft, boolean edit) {
    StringBuilder m = new StringBuilder().append("  ").append(url).append(change.getChangeId()).append(" ").append(ChangeUtil.cropSubject(subject));
    if (draft) {
        m.append(" [DRAFT]");
    }
    if (edit) {
        m.append(" [EDIT]");
    }
    return m.toString();
}
#end_block

#method_before
private void parseCommands(Collection<ReceiveCommand> commands) {
    logDebug("Parsing {} commands", commands.size());
    for (ReceiveCommand cmd : commands) {
        if (cmd.getResult() != NOT_ATTEMPTED) {
            // Already rejected by the core receive process.
            logDebug("Already processed by core: {} {}", cmd.getResult(), cmd);
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseMagicBranch(cmd);
            continue;
        }
        if (projectControl.getProjectState().isAllUsers() && RefNames.REFS_USERS_SELF.equals(cmd.getRefName())) {
            String newName = RefNames.refsUsers(user.getAccountId());
            logDebug("Swapping out command for {} to {}", RefNames.REFS_USERS_SELF, newName);
            final ReceiveCommand orgCmd = cmd;
            cmd = new ReceiveCommand(cmd.getOldId(), cmd.getNewId(), newName, cmd.getType()) {

                @Override
                public void setResult(Result s, String m) {
                    super.setResult(s, m);
                    orgCmd.setResult(s, m);
                }
            };
        }
        Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            logDebug("Processing {} command", cmd.getRefName());
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(rp.getRevWalk(), cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            addError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                addError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            logError("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                        Project.NameKey newParent = cfg.getProject().getParent(allProjectsName);
                        Project.NameKey oldParent = project.getParent(allProjectsName);
                        if (oldParent == null) {
                            // update of the 'All-Projects' project
                            if (newParent != null) {
                                reject(cmd, "invalid project configuration: root project cannot have parent");
                                continue;
                            }
                        } else {
                            if (!oldParent.equals(newParent) && !user.getCapabilities().canAdministrateServer()) {
                                reject(cmd, "invalid project configuration: only Gerrit admin can set parent");
                                continue;
                            }
                            if (projectCache.get(newParent) == null) {
                                reject(cmd, "invalid project configuration: parent does not exist");
                                continue;
                            }
                        }
                        for (Entry<ProjectConfigEntry> e : pluginConfigEntries) {
                            PluginConfig pluginCfg = cfg.getPluginConfig(e.getPluginName());
                            ProjectConfigEntry configEntry = e.getProvider().get();
                            String value = pluginCfg.getString(e.getExportName());
                            String oldValue = projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getString(e.getExportName());
                            if (configEntry.getType() == ProjectConfigEntryType.ARRAY) {
                                List<String> l = Arrays.asList(projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getStringList(e.getExportName()));
                                oldValue = Joiner.on("\n").join(l);
                            }
                            if ((value == null ? oldValue != null : !value.equals(oldValue)) && !configEntry.isEditable(projectControl.getProjectState())) {
                                reject(cmd, String.format("invalid project configuration: Not allowed to set parameter" + " '%s' of plugin '%s' on project '%s'.", e.getExportName(), e.getPluginName(), project.getName()));
                                continue;
                            }
                            if (ProjectConfigEntryType.LIST.equals(configEntry.getType()) && value != null && !configEntry.getPermittedValues().contains(value)) {
                                reject(cmd, String.format("invalid project configuration: The value '%s' is " + "not permitted for parameter '%s' of plugin '%s'.", value, e.getExportName(), e.getPluginName()));
                            }
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        logError("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#method_after
private void parseCommands(Collection<ReceiveCommand> commands) {
    List<String> optionList = rp.getPushOptions();
    if (optionList != null) {
        for (String option : optionList) {
            int e = option.indexOf('=');
            if (e > 0) {
                pushOptions.put(option.substring(0, e), option.substring(e + 1));
            } else {
                pushOptions.put(option, "");
            }
        }
    }
    logDebug("Parsing {} commands", commands.size());
    for (ReceiveCommand cmd : commands) {
        if (cmd.getResult() != NOT_ATTEMPTED) {
            // Already rejected by the core receive process.
            logDebug("Already processed by core: {} {}", cmd.getResult(), cmd);
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseMagicBranch(cmd);
            continue;
        }
        if (projectControl.getProjectState().isAllUsers() && RefNames.REFS_USERS_SELF.equals(cmd.getRefName())) {
            String newName = RefNames.refsUsers(user.getAccountId());
            logDebug("Swapping out command for {} to {}", RefNames.REFS_USERS_SELF, newName);
            final ReceiveCommand orgCmd = cmd;
            cmd = new ReceiveCommand(cmd.getOldId(), cmd.getNewId(), newName, cmd.getType()) {

                @Override
                public void setResult(Result s, String m) {
                    super.setResult(s, m);
                    orgCmd.setResult(s, m);
                }
            };
        }
        Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            logDebug("Processing {} command", cmd.getRefName());
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(rp.getRevWalk(), cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            addError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                addError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            logError("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                        Project.NameKey newParent = cfg.getProject().getParent(allProjectsName);
                        Project.NameKey oldParent = project.getParent(allProjectsName);
                        if (oldParent == null) {
                            // update of the 'All-Projects' project
                            if (newParent != null) {
                                reject(cmd, "invalid project configuration: root project cannot have parent");
                                continue;
                            }
                        } else {
                            if (!oldParent.equals(newParent) && !user.getCapabilities().canAdministrateServer()) {
                                reject(cmd, "invalid project configuration: only Gerrit admin can set parent");
                                continue;
                            }
                            if (projectCache.get(newParent) == null) {
                                reject(cmd, "invalid project configuration: parent does not exist");
                                continue;
                            }
                        }
                        for (Entry<ProjectConfigEntry> e : pluginConfigEntries) {
                            PluginConfig pluginCfg = cfg.getPluginConfig(e.getPluginName());
                            ProjectConfigEntry configEntry = e.getProvider().get();
                            String value = pluginCfg.getString(e.getExportName());
                            String oldValue = projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getString(e.getExportName());
                            if (configEntry.getType() == ProjectConfigEntryType.ARRAY) {
                                List<String> l = Arrays.asList(projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getStringList(e.getExportName()));
                                oldValue = Joiner.on("\n").join(l);
                            }
                            if ((value == null ? oldValue != null : !value.equals(oldValue)) && !configEntry.isEditable(projectControl.getProjectState())) {
                                reject(cmd, String.format("invalid project configuration: Not allowed to set parameter" + " '%s' of plugin '%s' on project '%s'.", e.getExportName(), e.getPluginName(), project.getName()));
                                continue;
                            }
                            if (ProjectConfigEntryType.LIST.equals(configEntry.getType()) && value != null && !configEntry.getPermittedValues().contains(value)) {
                                reject(cmd, String.format("invalid project configuration: The value '%s' is " + "not permitted for parameter '%s' of plugin '%s'.", value, e.getExportName(), e.getPluginName()));
                            }
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        logError("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#end_block

#method_before
private void parseCreate(ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        logError("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    logDebug("Creating {}", cmd);
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canCreate(db, rp.getRepository(), obj)) {
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        reject(cmd);
    }
}
#method_after
private void parseCreate(ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        logError("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    logDebug("Creating {}", cmd);
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canCreate(db, rp.getRepository(), obj)) {
        if (!validRefOperation(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        reject(cmd);
    }
}
#end_block

#method_before
private void parseUpdate(ReceiveCommand cmd) {
    logDebug("Updating {}", cmd);
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canUpdate()) {
        if (isHead(cmd) && !isCommit(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        if (RefNames.REFS_CONFIG.equals(ctl.getRefName())) {
            errors.put(Error.CONFIG_UPDATE, RefNames.REFS_CONFIG);
        } else {
            errors.put(Error.UPDATE, ctl.getRefName());
        }
        reject(cmd);
    }
}
#method_after
private void parseUpdate(ReceiveCommand cmd) {
    logDebug("Updating {}", cmd);
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canUpdate()) {
        if (isHead(cmd) && !isCommit(cmd)) {
            return;
        }
        if (!validRefOperation(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        if (RefNames.REFS_CONFIG.equals(ctl.getRefName())) {
            errors.put(Error.CONFIG_UPDATE, RefNames.REFS_CONFIG);
        } else {
            errors.put(Error.UPDATE, ctl.getRefName());
        }
        reject(cmd);
    }
}
#end_block

#method_before
private void parseDelete(ReceiveCommand cmd) {
    logDebug("Deleting {}", cmd);
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.getRefName().startsWith(REFS_CHANGES)) {
        errors.put(Error.DELETE_CHANGES, ctl.getRefName());
        reject(cmd, "cannot delete changes");
    } else if (ctl.canDelete()) {
        batch.addCommand(cmd);
    } else {
        if (RefNames.REFS_CONFIG.equals(ctl.getRefName())) {
            reject(cmd, "cannot delete project configuration");
        } else {
            errors.put(Error.DELETE, ctl.getRefName());
            reject(cmd, "cannot delete references");
        }
    }
}
#method_after
private void parseDelete(ReceiveCommand cmd) {
    logDebug("Deleting {}", cmd);
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.getRefName().startsWith(REFS_CHANGES)) {
        errors.put(Error.DELETE_CHANGES, ctl.getRefName());
        reject(cmd, "cannot delete changes");
    } else if (ctl.canDelete()) {
        if (!validRefOperation(cmd)) {
            return;
        }
        batch.addCommand(cmd);
    } else {
        if (RefNames.REFS_CONFIG.equals(ctl.getRefName())) {
            reject(cmd, "cannot delete project configuration");
        } else {
            errors.put(Error.DELETE, ctl.getRefName());
            reject(cmd, "cannot delete references");
        }
    }
}
#end_block

#method_before
private void parseRewind(ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        logError("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    logDebug("Rewinding {}", cmd);
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
        batch.setAllowNonFastForwards(true).addCommand(cmd);
    } else {
        cmd.setResult(REJECTED_NONFASTFORWARD, " need '" + PermissionRule.FORCE_PUSH + "' privilege.");
    }
}
#method_after
private void parseRewind(ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        logError("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    logDebug("Rewinding {}", cmd);
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
        if (!validRefOperation(cmd)) {
            return;
        }
        batch.setAllowNonFastForwards(true).addCommand(cmd);
    } else {
        cmd.setResult(REJECTED_NONFASTFORWARD, " need '" + PermissionRule.FORCE_PUSH + "' privilege.");
    }
}
#end_block

#method_before
String parse(CmdLineParser clp, Repository repo, Set<String> refs) throws CmdLineException {
    String ref = RefNames.fullName(MagicBranch.getDestBranchName(cmd.getRefName()));
    int optionStart = ref.indexOf('%');
    if (0 < optionStart) {
        ListMultimap<String, String> options = LinkedListMultimap.create();
        for (String s : COMMAS.split(ref.substring(optionStart + 1))) {
            int e = s.indexOf('=');
            if (0 < e) {
                options.put(s.substring(0, e), s.substring(e + 1));
            } else {
                options.put(s, "");
            }
        }
        clp.parseOptionMap(options);
        ref = ref.substring(0, optionStart);
    }
    // Split the destination branch by branch and topic. The topic
    // suffix is entirely optional, so it might not even exist.
    String head = readHEAD(repo);
    int split = ref.length();
    for (; ; ) {
        String name = ref.substring(0, split);
        if (refs.contains(name) || name.equals(head)) {
            break;
        }
        split = name.lastIndexOf('/', split - 1);
        if (split <= Constants.R_REFS.length()) {
            return ref;
        }
    }
    if (split < ref.length()) {
        topic = Strings.emptyToNull(ref.substring(split + 1));
    }
    return ref.substring(0, split);
}
#method_after
String parse(CmdLineParser clp, Repository repo, Set<String> refs, ListMultimap<String, String> pushOptions) throws CmdLineException {
    String ref = RefNames.fullName(MagicBranch.getDestBranchName(cmd.getRefName()));
    ListMultimap<String, String> options = LinkedListMultimap.create(pushOptions);
    int optionStart = ref.indexOf('%');
    if (0 < optionStart) {
        for (String s : COMMAS.split(ref.substring(optionStart + 1))) {
            int e = s.indexOf('=');
            if (0 < e) {
                options.put(s.substring(0, e), s.substring(e + 1));
            } else {
                options.put(s, "");
            }
        }
        ref = ref.substring(0, optionStart);
    }
    if (!options.isEmpty()) {
        clp.parseOptionMap(options);
    }
    // Split the destination branch by branch and topic. The topic
    // suffix is entirely optional, so it might not even exist.
    String head = readHEAD(repo);
    int split = ref.length();
    for (; ; ) {
        String name = ref.substring(0, split);
        if (refs.contains(name) || name.equals(head)) {
            break;
        }
        split = name.lastIndexOf('/', split - 1);
        if (split <= Constants.R_REFS.length()) {
            return ref;
        }
    }
    if (split < ref.length()) {
        topic = Strings.emptyToNull(ref.substring(split + 1));
    }
    return ref.substring(0, split);
}
#end_block

#method_before
private void parseMagicBranch(ReceiveCommand cmd) {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    logDebug("Found magic branch {}", cmd.getRefName());
    magicBranch = new MagicBranchInput(cmd, labelTypes, notesMigration);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    magicBranch.clp = clp;
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet());
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            logDebug("Invalid branch syntax");
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (projectControl.getProjectState().isAllUsers() && RefNames.REFS_USERS_SELF.equals(ref)) {
        logDebug("Handling {}", RefNames.REFS_USERS_SELF);
        ref = RefNames.refsUsers(user.getAccountId());
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        logDebug("Ref {} not found", ref);
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    if (!magicBranch.ctl.canWrite()) {
        reject(cmd, "project is read only");
        return;
    }
    if (magicBranch.draft) {
        if (!receiveConfig.allowDrafts) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "draft workflow is disabled");
            return;
        } else if (projectControl.controlForRef("refs/drafts/" + ref).isBlocked(Permission.PUSH)) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "cannot upload drafts");
            return;
        }
    }
    if (!magicBranch.ctl.canUpload()) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload review");
        return;
    }
    if (magicBranch.draft && magicBranch.submit) {
        reject(cmd, "cannot submit draft");
        return;
    }
    if (magicBranch.submit && !projectControl.controlForRef(MagicBranch.NEW_CHANGE + ref).canSubmit()) {
        reject(cmd, "submit not allowed");
        return;
    }
    RevWalk walk = rp.getRevWalk();
    RevCommit tip;
    try {
        tip = walk.parseCommit(magicBranch.cmd.getNewId());
        logDebug("Tip of push: {}", tip.name());
    } catch (IOException ex) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", ex);
        return;
    }
    // if %base was specified, ignore newChangeForAllNotInTarget
    if (tip.getParentCount() > 1 || magicBranch.base != null || tip.getParentCount() == 0) {
        logDebug("Forcing newChangeForAllNotInTarget = false");
        newChangeForAllNotInTarget = false;
    }
    if (magicBranch.base != null) {
        logDebug("Handling %base: {}", magicBranch.base);
        magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
        for (ObjectId id : magicBranch.base) {
            try {
                magicBranch.baseCommit.add(walk.parseCommit(id));
            } catch (IncorrectObjectTypeException notCommit) {
                reject(cmd, "base must be a commit");
                return;
            } catch (MissingObjectException e) {
                reject(cmd, "base not found");
                return;
            } catch (IOException e) {
                logWarn(String.format("Project %s cannot read %s", project.getName(), id.name()), e);
                reject(cmd, "internal server error");
                return;
            }
        }
    } else if (newChangeForAllNotInTarget) {
        logDebug("Handling newChangeForAllNotInTarget");
        String destBranch = magicBranch.dest.get();
        try {
            Ref r = repo.getRefDatabase().exactRef(destBranch);
            if (r == null) {
                reject(cmd, destBranch + " not found");
                return;
            }
            ObjectId baseHead = r.getObjectId();
            magicBranch.baseCommit = Collections.singletonList(walk.parseCommit(baseHead));
            logDebug("Set baseCommit = {}", magicBranch.baseCommit.get(0).name());
        } catch (IOException ex) {
            logWarn(String.format("Project %s cannot read %s", project.getName(), destBranch), ex);
            reject(cmd, "internal server error");
            return;
        }
    }
    // 
    try {
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // The destination branch does not yet exist. Assume the
            // history being sent for review will start it and thus
            // is "connected" to the branch.
            logDebug("Branch is unborn");
            return;
        }
        RevCommit h = walk.parseCommit(targetRef.getObjectId());
        logDebug("Current branch tip: {}", h.name());
        RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", e);
    }
}
#method_after
private void parseMagicBranch(ReceiveCommand cmd) {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    logDebug("Found magic branch {}", cmd.getRefName());
    magicBranch = new MagicBranchInput(cmd, labelTypes, notesMigration);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    magicBranch.clp = clp;
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet(), pushOptions);
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            logDebug("Invalid branch syntax");
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (projectControl.getProjectState().isAllUsers() && RefNames.REFS_USERS_SELF.equals(ref)) {
        logDebug("Handling {}", RefNames.REFS_USERS_SELF);
        ref = RefNames.refsUsers(user.getAccountId());
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        logDebug("Ref {} not found", ref);
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    if (!magicBranch.ctl.canWrite()) {
        reject(cmd, "project is read only");
        return;
    }
    if (magicBranch.draft) {
        if (!receiveConfig.allowDrafts) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "draft workflow is disabled");
            return;
        } else if (projectControl.controlForRef("refs/drafts/" + ref).isBlocked(Permission.PUSH)) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "cannot upload drafts");
            return;
        }
    }
    if (!magicBranch.ctl.canUpload()) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload review");
        return;
    }
    if (magicBranch.draft && magicBranch.submit) {
        reject(cmd, "cannot submit draft");
        return;
    }
    if (magicBranch.submit && !projectControl.controlForRef(MagicBranch.NEW_CHANGE + ref).canSubmit(true)) {
        reject(cmd, "submit not allowed");
        return;
    }
    RevWalk walk = rp.getRevWalk();
    RevCommit tip;
    try {
        tip = walk.parseCommit(magicBranch.cmd.getNewId());
        logDebug("Tip of push: {}", tip.name());
    } catch (IOException ex) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", ex);
        return;
    }
    String destBranch = magicBranch.dest.get();
    try {
        if (magicBranch.merged) {
            if (magicBranch.draft) {
                reject(cmd, "cannot be draft & merged");
                return;
            }
            if (magicBranch.base != null) {
                reject(cmd, "cannot use merged with base");
                return;
            }
            RevCommit branchTip = readBranchTip(cmd, magicBranch.dest);
            if (branchTip == null) {
                // readBranchTip already rejected cmd.
                return;
            }
            if (!walk.isMergedInto(tip, branchTip)) {
                reject(cmd, "not merged into branch");
                return;
            }
        }
        // if %base or %merged was specified, ignore newChangeForAllNotInTarget.
        if (tip.getParentCount() > 1 || magicBranch.base != null || magicBranch.merged || tip.getParentCount() == 0) {
            logDebug("Forcing newChangeForAllNotInTarget = false");
            newChangeForAllNotInTarget = false;
        }
        if (magicBranch.base != null) {
            logDebug("Handling %base: {}", magicBranch.base);
            magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
            for (ObjectId id : magicBranch.base) {
                try {
                    magicBranch.baseCommit.add(walk.parseCommit(id));
                } catch (IncorrectObjectTypeException notCommit) {
                    reject(cmd, "base must be a commit");
                    return;
                } catch (MissingObjectException e) {
                    reject(cmd, "base not found");
                    return;
                } catch (IOException e) {
                    logWarn(String.format("Project %s cannot read %s", project.getName(), id.name()), e);
                    reject(cmd, "internal server error");
                    return;
                }
            }
        } else if (newChangeForAllNotInTarget) {
            RevCommit branchTip = readBranchTip(cmd, magicBranch.dest);
            if (branchTip == null) {
                // readBranchTip already rejected cmd.
                return;
            }
            magicBranch.baseCommit = Collections.singletonList(branchTip);
            logDebug("Set baseCommit = {}", magicBranch.baseCommit.get(0).name());
        }
    } catch (IOException ex) {
        logWarn(String.format("Error walking to %s in project %s", destBranch, project.getName()), ex);
        reject(cmd, "internal server error");
        return;
    }
    // 
    try {
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // The destination branch does not yet exist. Assume the
            // history being sent for review will start it and thus
            // is "connected" to the branch.
            logDebug("Branch is unborn");
            return;
        }
        RevCommit h = walk.parseCommit(targetRef.getObjectId());
        logDebug("Current branch tip: {}", h.name());
        RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", e);
    }
}
#end_block

#method_before
private void selectNewAndReplacedChangesFromMagicBranch() {
    logDebug("Finding new and replaced changes");
    newChanges = new ArrayList<>();
    SetMultimap<ObjectId, Ref> existing = changeRefsById();
    GroupCollector groupCollector = GroupCollector.create(changeRefsById(), db, psUtil, notesFactory, project.getNameKey());
    rp.getRevWalk().reset();
    rp.getRevWalk().sort(RevSort.TOPO);
    rp.getRevWalk().sort(RevSort.REVERSE, true);
    try {
        rp.getRevWalk().markStart(rp.getRevWalk().parseCommit(magicBranch.cmd.getNewId()));
        if (magicBranch.baseCommit != null) {
            logDebug("Marking {} base commits uninteresting", magicBranch.baseCommit.size());
            for (RevCommit c : magicBranch.baseCommit) {
                rp.getRevWalk().markUninteresting(c);
            }
            Ref targetRef = allRefs.get(magicBranch.ctl.getRefName());
            if (targetRef != null) {
                logDebug("Marking target ref {} ({}) uninteresting", magicBranch.ctl.getRefName(), targetRef.getObjectId().name());
                rp.getRevWalk().markUninteresting(rp.getRevWalk().parseCommit(targetRef.getObjectId()));
            }
        } else {
            markHeadsAsUninteresting(rp.getRevWalk(), magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
        }
        List<ChangeLookup> pending = new ArrayList<>();
        Set<Change.Key> newChangeIds = new HashSet<>();
        int maxBatchChanges = receiveConfig.getEffectiveMaxBatchChangesLimit(user);
        int total = 0;
        int alreadyTracked = 0;
        for (; ; ) {
            RevCommit c = rp.getRevWalk().next();
            if (c == null) {
                break;
            }
            total++;
            String name = c.name();
            groupCollector.visit(c);
            Collection<Ref> existingRefs = existing.get(c);
            if (!existingRefs.isEmpty()) {
                // Commit is already tracked.
                alreadyTracked++;
                // different target branch.
                for (Ref ref : existingRefs) {
                    updateGroups.add(new UpdateGroupsRequest(ref, c));
                }
                if (!(newChangeForAllNotInTarget || magicBranch.base != null)) {
                    continue;
                }
                logDebug("Creating new change for {} even though it is already tracked", name);
            }
            if (!validCommit(rp.getRevWalk(), magicBranch.ctl, magicBranch.cmd, c)) {
                // Not a change the user can propose? Abort as early as possible.
                newChanges = Collections.emptyList();
                logDebug("Aborting early due to invalid commit");
                return;
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
                logDebug("Rejecting merge commit {} with newChangeForAllNotInTarget", name);
            // TODO(dborowitz): Should we early return here?
            }
            List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(c, magicBranch.dest.get()));
                continue;
            }
            String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                newChanges = Collections.emptyList();
                return;
            }
            pending.add(new ChangeLookup(c, new Change.Key(idStr)));
            int n = pending.size() + newChanges.size();
            if (maxBatchChanges != 0 && n > maxBatchChanges) {
                logDebug("{} changes exceeds limit of {}", n, maxBatchChanges);
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                newChanges = Collections.emptyList();
                return;
            }
        }
        logDebug("Finished initial RevWalk with {} commits total: {} already" + " tracked, {} new changes with no Change-Id, and {} deferred" + " lookups", total, alreadyTracked, newChanges.size(), pending.size());
        for (Iterator<ChangeLookup> itr = pending.iterator(); itr.hasNext(); ) {
            ChangeLookup p = itr.next();
            if (newChangeIds.contains(p.changeKey)) {
                logDebug("Multiple commits with Change-Id {}", p.changeKey);
                reject(magicBranch.cmd, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
                newChanges = Collections.emptyList();
                return;
            }
            List<ChangeData> changes = p.destChanges;
            if (changes.size() > 1) {
                logDebug("Multiple changes in project with Change-Id {}: {}", p.changeKey, Lists.transform(changes, new Function<ChangeData, String>() {

                    @Override
                    public String apply(ChangeData in) {
                        return in.getId().toString();
                    }
                }));
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 1) {
                // Schedule as a replacement to this one matching change.
                // 
                RevId currentPs = changes.get(0).currentPatchSet().getRevision();
                // If Commit is already current PatchSet of target Change.
                if (p.commit.name().equals(currentPs.get())) {
                    if (pending.size() == 1) {
                        // There are no commits left to check, all commits in pending were already
                        // current PatchSet of the corresponding target changes.
                        reject(magicBranch.cmd, "commit(s) already exists (as current patchset)");
                    } else {
                        // Commit is already current PatchSet.
                        // Remove from pending and try next commit.
                        itr.remove();
                        continue;
                    }
                }
                if (requestReplace(magicBranch.cmd, false, changes.get(0).change(), p.commit)) {
                    continue;
                }
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    newChanges = Collections.emptyList();
                    return;
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(p.commit, magicBranch.dest.get()));
        }
        logDebug("Finished deferred lookups with {} updates and {} new changes", replaceByChange.size(), newChanges.size());
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", e);
        newChanges = Collections.emptyList();
        return;
    } catch (OrmException e) {
        logError("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        newChanges = Collections.emptyList();
        return;
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return;
    }
    if (!newChanges.isEmpty() && magicBranch.edit) {
        reject(magicBranch.cmd, "edit is not supported for new changes");
        return;
    }
    try {
        SortedSetMultimap<ObjectId, String> groups = groupCollector.getGroups();
        List<Integer> newIds = seq.nextChangeIds(newChanges.size());
        for (int i = 0; i < newChanges.size(); i++) {
            CreateRequest create = newChanges.get(i);
            create.setChangeId(newIds.get(i));
            batch.addCommand(create.cmd);
            create.groups = ImmutableList.copyOf(groups.get(create.commit));
        }
        for (ReplaceRequest replace : replaceByChange.values()) {
            replace.groups = ImmutableList.copyOf(groups.get(replace.newCommitId));
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.groups = ImmutableList.copyOf((groups.get(update.commit)));
        }
        logDebug("Finished updating groups from GroupCollector");
    } catch (OrmException | NoSuchChangeException e) {
        logError("Error collecting groups for changes", e);
        reject(magicBranch.cmd, "internal server error");
        return;
    }
}
#method_after
private void selectNewAndReplacedChangesFromMagicBranch() {
    logDebug("Finding new and replaced changes");
    newChanges = new ArrayList<>();
    SetMultimap<ObjectId, Ref> existing = changeRefsById();
    GroupCollector groupCollector = GroupCollector.create(changeRefsById(), db, psUtil, notesFactory, project.getNameKey());
    try {
        RevCommit start = setUpWalkForSelectingChanges();
        if (start == null) {
            return;
        }
        List<ChangeLookup> pending = new ArrayList<>();
        Set<Change.Key> newChangeIds = new HashSet<>();
        int maxBatchChanges = receiveConfig.getEffectiveMaxBatchChangesLimit(user);
        int total = 0;
        int alreadyTracked = 0;
        boolean rejectImplicitMerges = start.getParentCount() == 1 && projectCache.get(project.getNameKey()).isRejectImplicitMerges() && // late.
        !magicBranch.merged;
        Set<RevCommit> mergedParents;
        if (rejectImplicitMerges) {
            mergedParents = new HashSet<>();
        } else {
            mergedParents = null;
        }
        for (; ; ) {
            RevCommit c = rp.getRevWalk().next();
            if (c == null) {
                break;
            }
            total++;
            String name = c.name();
            groupCollector.visit(c);
            Collection<Ref> existingRefs = existing.get(c);
            if (rejectImplicitMerges) {
                Collections.addAll(mergedParents, c.getParents());
                mergedParents.remove(c);
            }
            if (!existingRefs.isEmpty()) {
                // Commit is already tracked.
                alreadyTracked++;
                // different target branch.
                for (Ref ref : existingRefs) {
                    updateGroups.add(new UpdateGroupsRequest(ref, c));
                }
                if (!(newChangeForAllNotInTarget || magicBranch.base != null)) {
                    continue;
                }
                logDebug("Creating new change for {} even though it is already tracked", name);
            }
            if (!validCommit(rp.getRevWalk(), magicBranch.ctl, magicBranch.cmd, c)) {
                // Not a change the user can propose? Abort as early as possible.
                newChanges = Collections.emptyList();
                logDebug("Aborting early due to invalid commit");
                return;
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
                logDebug("Rejecting merge commit {} with newChangeForAllNotInTarget", name);
            // TODO(dborowitz): Should we early return here?
            }
            List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(c, magicBranch.dest.get()));
                continue;
            }
            String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                newChanges = Collections.emptyList();
                return;
            }
            pending.add(new ChangeLookup(c, new Change.Key(idStr)));
            int n = pending.size() + newChanges.size();
            if (maxBatchChanges != 0 && n > maxBatchChanges) {
                logDebug("{} changes exceeds limit of {}", n, maxBatchChanges);
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                newChanges = Collections.emptyList();
                return;
            }
        }
        logDebug("Finished initial RevWalk with {} commits total: {} already" + " tracked, {} new changes with no Change-Id, and {} deferred" + " lookups", total, alreadyTracked, newChanges.size(), pending.size());
        if (rejectImplicitMerges) {
            rejectImplicitMerges(mergedParents);
        }
        for (Iterator<ChangeLookup> itr = pending.iterator(); itr.hasNext(); ) {
            ChangeLookup p = itr.next();
            if (newChangeIds.contains(p.changeKey)) {
                logDebug("Multiple commits with Change-Id {}", p.changeKey);
                reject(magicBranch.cmd, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
                newChanges = Collections.emptyList();
                return;
            }
            List<ChangeData> changes = p.destChanges;
            if (changes.size() > 1) {
                logDebug("Multiple changes in project with Change-Id {}: {}", p.changeKey, Lists.transform(changes, new Function<ChangeData, String>() {

                    @Override
                    public String apply(ChangeData in) {
                        return in.getId().toString();
                    }
                }));
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 1) {
                // Schedule as a replacement to this one matching change.
                // 
                RevId currentPs = changes.get(0).currentPatchSet().getRevision();
                // If Commit is already current PatchSet of target Change.
                if (p.commit.name().equals(currentPs.get())) {
                    if (pending.size() == 1) {
                        // There are no commits left to check, all commits in pending were already
                        // current PatchSet of the corresponding target changes.
                        reject(magicBranch.cmd, "commit(s) already exists (as current patchset)");
                    } else {
                        // Commit is already current PatchSet.
                        // Remove from pending and try next commit.
                        itr.remove();
                        continue;
                    }
                }
                if (requestReplace(magicBranch.cmd, false, changes.get(0).change(), p.commit)) {
                    continue;
                }
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    newChanges = Collections.emptyList();
                    return;
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(p.commit, magicBranch.dest.get()));
        }
        logDebug("Finished deferred lookups with {} updates and {} new changes", replaceByChange.size(), newChanges.size());
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", e);
        newChanges = Collections.emptyList();
        return;
    } catch (OrmException e) {
        logError("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        newChanges = Collections.emptyList();
        return;
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return;
    }
    if (!newChanges.isEmpty() && magicBranch.edit) {
        reject(magicBranch.cmd, "edit is not supported for new changes");
        return;
    }
    try {
        SortedSetMultimap<ObjectId, String> groups = groupCollector.getGroups();
        List<Integer> newIds = seq.nextChangeIds(newChanges.size());
        for (int i = 0; i < newChanges.size(); i++) {
            CreateRequest create = newChanges.get(i);
            create.setChangeId(newIds.get(i));
            batch.addCommand(create.cmd);
            create.groups = ImmutableList.copyOf(groups.get(create.commit));
        }
        for (ReplaceRequest replace : replaceByChange.values()) {
            replace.groups = ImmutableList.copyOf(groups.get(replace.newCommitId));
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.groups = ImmutableList.copyOf((groups.get(update.commit)));
        }
        logDebug("Finished updating groups from GroupCollector");
    } catch (OrmException | NoSuchChangeException e) {
        logError("Error collecting groups for changes", e);
        reject(magicBranch.cmd, "internal server error");
        return;
    }
}
#end_block

#method_before
private void setChangeId(int id) {
    changeId = new Change.Id(id);
    ins = changeInserterFactory.create(changeId, commit, refName).setDraft(magicBranch.draft).setTopic(magicBranch.topic).setValidatePolicy(CommitValidators.Policy.NONE);
    cmd = new ReceiveCommand(ObjectId.zeroId(), commit, ins.getPatchSetId().toRefName());
    ins.setUpdateRefCommand(cmd);
    if (rp.getPushCertificate() != null) {
        ins.setPushCertificate(rp.getPushCertificate().toTextWithSignature());
    }
}
#method_after
private void setChangeId(int id) {
    changeId = new Change.Id(id);
    ins = changeInserterFactory.create(changeId, commit, refName).setTopic(magicBranch.topic).setValidatePolicy(CommitValidators.Policy.NONE);
    if (magicBranch.draft) {
        ins.setDraft(magicBranch.draft);
    } else if (magicBranch.merged) {
        ins.setStatus(Change.Status.MERGED);
    }
    cmd = new ReceiveCommand(ObjectId.zeroId(), commit, ins.getPatchSetId().toRefName());
    ins.setUpdateRefCommand(cmd);
    if (rp.getPushCertificate() != null) {
        ins.setPushCertificate(rp.getPushCertificate().toTextWithSignature());
    }
}
#end_block

#method_before
private boolean validCommit(RevWalk rw, RefControl ctl, ReceiveCommand cmd, ObjectId id) throws IOException {
    if (validCommits.contains(id)) {
        return true;
    }
    RevCommit c = rw.parseCommit(id);
    rw.parseBody(c);
    CommitReceivedEvent receiveEvent = new CommitReceivedEvent(cmd, project, ctl.getRefName(), c, user);
    CommitValidators commitValidators = commitValidatorsFactory.create(ctl, sshInfo, repo);
    try {
        messages.addAll(commitValidators.validateForReceiveCommits(receiveEvent, rejectCommits));
    } catch (CommitValidationException e) {
        logDebug("Commit validation failed on {}", c.name());
        messages.addAll(e.getMessages());
        reject(cmd, e.getMessage());
        return false;
    }
    validCommits.add(c.copy());
    return true;
}
#method_after
private boolean validCommit(RevWalk rw, RefControl ctl, ReceiveCommand cmd, ObjectId id) throws IOException {
    if (validCommits.contains(id)) {
        return true;
    }
    RevCommit c = rw.parseCommit(id);
    rw.parseBody(c);
    CommitReceivedEvent receiveEvent = new CommitReceivedEvent(cmd, project, ctl.getRefName(), c, user);
    CommitValidators.Policy policy;
    if (magicBranch != null && cmd.getRefName().equals(magicBranch.cmd.getRefName()) && magicBranch.merged) {
        policy = CommitValidators.Policy.MERGED;
    } else {
        policy = CommitValidators.Policy.RECEIVE_COMMITS;
    }
    try {
        messages.addAll(commitValidatorsFactory.create(policy, ctl, sshInfo, repo).validate(receiveEvent));
    } catch (CommitValidationException e) {
        logDebug("Commit validation failed on {}", c.name());
        messages.addAll(e.getMessages());
        reject(cmd, e.getMessage());
        return false;
    }
    validCommits.add(c.copy());
    return true;
}
#end_block

#method_before
@Override
public UiAction.Description getDescription(RevisionResource resource) {
    PatchSet.Id current = resource.getChange().currentPatchSetId();
    String topic = resource.getChange().getTopic();
    boolean visible = !resource.getPatchSet().isDraft() && resource.getChange().getStatus().isOpen() && resource.getPatchSet().getId().equals(current) && resource.getControl().canSubmit();
    ReviewDb db = dbProvider.get();
    ChangeData cd = changeDataFactory.create(db, resource.getControl());
    try {
        MergeOp.checkSubmitRule(cd);
    } catch (ResourceConflictException e) {
        visible = false;
    } catch (OrmException e) {
        log.error("Error checking if change is submittable", e);
        throw new OrmRuntimeException("Could not determine problems for the change", e);
    }
    if (!visible) {
        return new UiAction.Description().setLabel("").setTitle("").setVisible(false);
    }
    ChangeSet cs;
    try {
        cs = mergeSuperSet.completeChangeSet(db, cd.change(), resource.getControl().getUser());
    } catch (OrmException | IOException e) {
        throw new OrmRuntimeException("Could not determine complete set of " + "changes to be submitted", e);
    }
    int topicSize = 0;
    if (!Strings.isNullOrEmpty(topic)) {
        topicSize = getChangesByTopic(topic).size();
    }
    boolean treatWithTopic = submitWholeTopic && !Strings.isNullOrEmpty(topic) && topicSize > 1;
    String submitProblems = problemsForSubmittingChangeset(cd, cs, resource.getUser());
    Boolean enabled;
    try {
        // Recheck mergeability rather than using value stored in the index,
        // which may be stale.
        // TODO(dborowitz): This is ugly; consider providing a way to not read
        // stored fields from the index in the first place.
        // cd.setMergeable(null);
        // That was done in unmergeableChanges which was called by
        // problemsForSubmittingChangeset, so now it is safe to read from
        // the cache, as it yields the same result.
        enabled = cd.isMergeable();
    } catch (OrmException e) {
        throw new OrmRuntimeException("Could not determine mergeability", e);
    }
    if (submitProblems != null) {
        return new UiAction.Description().setLabel(treatWithTopic ? submitTopicLabel : (cs.size() > 1) ? labelWithParents : label).setTitle(submitProblems).setVisible(true).setEnabled(false);
    }
    if (treatWithTopic) {
        Map<String, String> params = ImmutableMap.of("topicSize", String.valueOf(topicSize), "submitSize", String.valueOf(cs.size()));
        return new UiAction.Description().setLabel(submitTopicLabel).setTitle(Strings.emptyToNull(submitTopicTooltip.replace(params))).setVisible(true).setEnabled(Boolean.TRUE.equals(enabled));
    }
    RevId revId = resource.getPatchSet().getRevision();
    Map<String, String> params = ImmutableMap.of("patchSet", String.valueOf(resource.getPatchSet().getPatchSetId()), "branch", resource.getChange().getDest().getShortName(), "commit", ObjectId.fromString(revId.get()).abbreviate(7).name(), "submitSize", String.valueOf(cs.size()));
    ParameterizedString tp = cs.size() > 1 ? titlePatternWithAncestors : titlePattern;
    return new UiAction.Description().setLabel(cs.size() > 1 ? labelWithParents : label).setTitle(Strings.emptyToNull(tp.replace(params))).setVisible(true).setEnabled(Boolean.TRUE.equals(enabled));
}
#method_after
@Override
public UiAction.Description getDescription(RevisionResource resource) {
    PatchSet.Id current = resource.getChange().currentPatchSetId();
    String topic = resource.getChange().getTopic();
    boolean visible = !resource.getPatchSet().isDraft() && resource.getChange().getStatus().isOpen() && resource.getPatchSet().getId().equals(current) && resource.getControl().canSubmit();
    ReviewDb db = dbProvider.get();
    ChangeData cd = changeDataFactory.create(db, resource.getControl());
    try {
        MergeOp.checkSubmitRule(cd);
    } catch (ResourceConflictException e) {
        visible = false;
    } catch (OrmException e) {
        log.error("Error checking if change is submittable", e);
        throw new OrmRuntimeException("Could not determine problems for the change", e);
    }
    if (!visible) {
        return new UiAction.Description().setLabel("").setTitle("").setVisible(false);
    }
    ChangeSet cs;
    try {
        cs = mergeSuperSet.get().completeChangeSet(db, cd.change(), resource.getControl().getUser());
    } catch (OrmException | IOException e) {
        throw new OrmRuntimeException("Could not determine complete set of " + "changes to be submitted", e);
    }
    int topicSize = 0;
    if (!Strings.isNullOrEmpty(topic)) {
        topicSize = getChangesByTopic(topic).size();
    }
    boolean treatWithTopic = submitWholeTopic && !Strings.isNullOrEmpty(topic) && topicSize > 1;
    String submitProblems = problemsForSubmittingChangeset(cd, cs, resource.getUser());
    Boolean enabled;
    try {
        // Recheck mergeability rather than using value stored in the index,
        // which may be stale.
        // TODO(dborowitz): This is ugly; consider providing a way to not read
        // stored fields from the index in the first place.
        // cd.setMergeable(null);
        // That was done in unmergeableChanges which was called by
        // problemsForSubmittingChangeset, so now it is safe to read from
        // the cache, as it yields the same result.
        enabled = cd.isMergeable();
    } catch (OrmException e) {
        throw new OrmRuntimeException("Could not determine mergeability", e);
    }
    if (submitProblems != null) {
        return new UiAction.Description().setLabel(treatWithTopic ? submitTopicLabel : (cs.size() > 1) ? labelWithParents : label).setTitle(submitProblems).setVisible(true).setEnabled(false);
    }
    if (treatWithTopic) {
        Map<String, String> params = ImmutableMap.of("topicSize", String.valueOf(topicSize), "submitSize", String.valueOf(cs.size()));
        return new UiAction.Description().setLabel(submitTopicLabel).setTitle(Strings.emptyToNull(submitTopicTooltip.replace(params))).setVisible(true).setEnabled(Boolean.TRUE.equals(enabled));
    }
    RevId revId = resource.getPatchSet().getRevision();
    Map<String, String> params = ImmutableMap.of("patchSet", String.valueOf(resource.getPatchSet().getPatchSetId()), "branch", resource.getChange().getDest().getShortName(), "commit", ObjectId.fromString(revId.get()).abbreviate(7).name(), "submitSize", String.valueOf(cs.size()));
    ParameterizedString tp = cs.size() > 1 ? titlePatternWithAncestors : titlePattern;
    return new UiAction.Description().setLabel(cs.size() > 1 ? labelWithParents : label).setTitle(Strings.emptyToNull(tp.replace(params))).setVisible(true).setEnabled(Boolean.TRUE.equals(enabled));
}
#end_block

#method_before
public void merge(ReviewDb db, Change change, IdentifiedUser caller, boolean checkSubmitRules, SubmitInput submitInput, boolean dryrun) throws OrmException, RestApiException {
    this.submitInput = submitInput;
    this.caller = caller;
    this.ts = TimeUtil.nowTs();
    submissionId = RequestId.forChange(change);
    this.db = db;
    orm.setContext(db, ts, caller, submissionId);
    logDebug("Beginning integration of {}", change);
    try {
        ChangeSet cs = mergeSuperSet.completeChangeSet(db, change, caller);
        checkState(cs.ids().contains(change.getId()), "change %s missing from %s", change.getId(), cs);
        if (cs.furtherHiddenChanges()) {
            throw new AuthException("A change to be submitted with " + change.getId() + " is not visible");
        }
        this.commits = new CommitStatus(cs);
        MergeSuperSet.reloadChanges(cs);
        logDebug("Calculated to merge {}", cs);
        if (checkSubmitRules) {
            logDebug("Checking submit rules and state");
            checkSubmitRulesAndState(cs);
        } else {
            logDebug("Bypassing submit rules");
            bypassSubmitRules(cs);
        }
        try {
            integrateIntoHistory(cs, dryrun);
        } catch (IntegrationException e) {
            logError("Error from integrateIntoHistory", e);
            throw new ResourceConflictException(e.getMessage(), e);
        }
    } catch (IOException e) {
        // Anything before the merge attempt is an error
        throw new OrmException(e);
    }
}
#method_after
public void merge(ReviewDb db, Change change, IdentifiedUser caller, boolean checkSubmitRules, SubmitInput submitInput, boolean dryrun) throws OrmException, RestApiException {
    this.submitInput = submitInput;
    this.dryrun = dryrun;
    this.caller = caller;
    this.ts = TimeUtil.nowTs();
    submissionId = RequestId.forChange(change);
    this.db = db;
    orm.setContext(db, ts, caller, submissionId);
    logDebug("Beginning integration of {}", change);
    try {
        ChangeSet cs = mergeSuperSet.setMergeOpRepoManager(orm).completeChangeSet(db, change, caller);
        checkState(cs.ids().contains(change.getId()), "change %s missing from %s", change.getId(), cs);
        if (cs.furtherHiddenChanges()) {
            throw new AuthException("A change to be submitted with " + change.getId() + " is not visible");
        }
        this.commits = new CommitStatus(cs);
        MergeSuperSet.reloadChanges(cs);
        logDebug("Calculated to merge {}", cs);
        if (checkSubmitRules) {
            logDebug("Checking submit rules and state");
            checkSubmitRulesAndState(cs);
        } else {
            logDebug("Bypassing submit rules");
            bypassSubmitRules(cs);
        }
        try {
            integrateIntoHistory(cs);
        } catch (IntegrationException e) {
            logError("Error from integrateIntoHistory", e);
            throw new ResourceConflictException(e.getMessage(), e);
        }
    } catch (IOException e) {
        // Anything before the merge attempt is an error
        throw new OrmException(e);
    }
}
#end_block

#method_before
private void integrateIntoHistory(ChangeSet cs, boolean dryrun) throws IntegrationException, RestApiException {
    checkArgument(!cs.furtherHiddenChanges(), "cannot integrate hidden changes into history");
    logDebug("Beginning merge attempt on {}", cs);
    Map<Branch.NameKey, BranchBatch> toSubmit = new HashMap<>();
    logDebug("Perform the merges");
    Multimap<Project.NameKey, Branch.NameKey> br;
    Multimap<Branch.NameKey, ChangeData> cbb;
    try {
        br = cs.branchesByProject();
        cbb = cs.changesByBranch();
    } catch (OrmException e) {
        throw new IntegrationException("Error reading changes to submit", e);
    }
    Set<Project.NameKey> projects = br.keySet();
    Set<Branch.NameKey> branches = cbb.keySet();
    openRepos(projects);
    for (Branch.NameKey branch : branches) {
        OpenRepo or = orm.getRepo(branch.getParentKey());
        toSubmit.put(branch, validateChangeList(or, cbb.get(branch)));
    }
    // Done checks that don't involve running submit strategies.
    commits.maybeFailVerbose();
    SubmoduleOp submoduleOp = subOpFactory.create(branches, orm);
    try {
        List<SubmitStrategy> strategies = getSubmitStrategies(toSubmit, submoduleOp);
        Set<Project.NameKey> allProjects = submoduleOp.getProjectsInOrder();
        // in case superproject subscription is disabled, allProjects would be null
        if (allProjects == null) {
            allProjects = projects;
        }
        this.allProjects = allProjects;
        if (!dryrun) {
            BatchUpdate.execute(orm.batchUpdates(allProjects), new SubmitStrategyListener(submitInput, strategies, commits), submissionId);
        }
    } catch (UpdateException | SubmoduleException e) {
        // BatchUpdate may have inadvertently wrapped an IntegrationException
        // thrown by some legacy SubmitStrategyOp code that intended the error
        // message to be user-visible. Copy the message from the wrapped
        // exception.
        // 
        // If you happen across one of these, the correct fix is to convert the
        // inner IntegrationException to a ResourceConflictException.
        String msg;
        if (e.getCause() instanceof IntegrationException) {
            msg = e.getCause().getMessage();
        } else {
            msg = "Error submitting change" + (cs.size() != 1 ? "s" : "") + ": \n" + e.getMessage();
        }
        throw new IntegrationException(msg, e);
    }
}
#method_after
private void integrateIntoHistory(ChangeSet cs) throws IntegrationException, RestApiException {
    checkArgument(!cs.furtherHiddenChanges(), "cannot integrate hidden changes into history");
    logDebug("Beginning merge attempt on {}", cs);
    Map<Branch.NameKey, BranchBatch> toSubmit = new HashMap<>();
    logDebug("Perform the merges");
    Multimap<Project.NameKey, Branch.NameKey> br;
    Multimap<Branch.NameKey, ChangeData> cbb;
    try {
        br = cs.branchesByProject();
        cbb = cs.changesByBranch();
    } catch (OrmException e) {
        throw new IntegrationException("Error reading changes to submit", e);
    }
    Set<Project.NameKey> projects = br.keySet();
    Set<Branch.NameKey> branches = cbb.keySet();
    openRepos(projects);
    for (Branch.NameKey branch : branches) {
        OpenRepo or = orm.getRepo(branch.getParentKey());
        toSubmit.put(branch, validateChangeList(or, cbb.get(branch)));
    }
    // Done checks that don't involve running submit strategies.
    commits.maybeFailVerbose();
    SubmoduleOp submoduleOp = subOpFactory.create(branches, orm);
    try {
        List<SubmitStrategy> strategies = getSubmitStrategies(toSubmit, submoduleOp, dryrun);
        Set<Project.NameKey> allProjects = submoduleOp.getProjectsInOrder();
        // in case superproject subscription is disabled, allProjects would be null
        if (allProjects == null) {
            allProjects = projects;
        }
        this.allProjects = allProjects;
        BatchUpdate.execute(orm.batchUpdates(allProjects), new SubmitStrategyListener(submitInput, strategies, commits), submissionId, dryrun);
    } catch (UpdateException | SubmoduleException e) {
        // BatchUpdate may have inadvertently wrapped an IntegrationException
        // thrown by some legacy SubmitStrategyOp code that intended the error
        // message to be user-visible. Copy the message from the wrapped
        // exception.
        // 
        // If you happen across one of these, the correct fix is to convert the
        // inner IntegrationException to a ResourceConflictException.
        String msg;
        if (e.getCause() instanceof IntegrationException) {
            msg = e.getCause().getMessage();
        } else {
            msg = "Error submitting change" + (cs.size() != 1 ? "s" : "") + ": \n" + e.getMessage();
        }
        throw new IntegrationException(msg, e);
    }
}
#end_block

#method_before
private List<SubmitStrategy> getSubmitStrategies(Map<Branch.NameKey, BranchBatch> toSubmit, SubmoduleOp submoduleOp) throws IntegrationException {
    List<SubmitStrategy> strategies = new ArrayList<>();
    Set<Branch.NameKey> allBranches = submoduleOp.getBranchesInOrder();
    // in case superproject subscription is disabled, allBranches would be null
    if (allBranches == null) {
        allBranches = toSubmit.keySet();
    }
    for (Branch.NameKey branch : allBranches) {
        OpenRepo or = orm.getRepo(branch.getParentKey());
        if (toSubmit.containsKey(branch)) {
            BranchBatch submitting = toSubmit.get(branch);
            OpenBranch ob = or.getBranch(branch);
            checkNotNull(submitting.submitType(), "null submit type for %s; expected to previously fail fast", submitting);
            Set<CodeReviewCommit> commitsToSubmit = commits(submitting.changes());
            ob.mergeTip = new MergeTip(ob.oldTip, commitsToSubmit);
            SubmitStrategy strategy = createStrategy(or, ob.mergeTip, branch, submitting.submitType(), ob.oldTip, submoduleOp);
            strategies.add(strategy);
            strategy.addOps(or.getUpdate(), commitsToSubmit);
        } else {
            // no open change for this branch
            // add submodule triggered op into BatchUpdate
            submoduleOp.addOp(or.getUpdate(), branch);
        }
    }
    return strategies;
}
#method_after
private List<SubmitStrategy> getSubmitStrategies(Map<Branch.NameKey, BranchBatch> toSubmit, SubmoduleOp submoduleOp, boolean dryrun) throws IntegrationException {
    List<SubmitStrategy> strategies = new ArrayList<>();
    Set<Branch.NameKey> allBranches = submoduleOp.getBranchesInOrder();
    // in case superproject subscription is disabled, allBranches would be null
    if (allBranches == null) {
        allBranches = toSubmit.keySet();
    }
    for (Branch.NameKey branch : allBranches) {
        OpenRepo or = orm.getRepo(branch.getParentKey());
        if (toSubmit.containsKey(branch)) {
            BranchBatch submitting = toSubmit.get(branch);
            OpenBranch ob = or.getBranch(branch);
            checkNotNull(submitting.submitType(), "null submit type for %s; expected to previously fail fast", submitting);
            Set<CodeReviewCommit> commitsToSubmit = commits(submitting.changes());
            ob.mergeTip = new MergeTip(ob.oldTip, commitsToSubmit);
            SubmitStrategy strategy = createStrategy(or, ob.mergeTip, branch, submitting.submitType(), ob.oldTip, submoduleOp, dryrun);
            strategies.add(strategy);
            strategy.addOps(or.getUpdate(), commitsToSubmit);
        } else {
            // no open change for this branch
            // add submodule triggered op into BatchUpdate
            submoduleOp.addOp(or.getUpdate(), branch);
        }
    }
    return strategies;
}
#end_block

#method_before
private SubmitStrategy createStrategy(OpenRepo or, MergeTip mergeTip, Branch.NameKey destBranch, SubmitType submitType, CodeReviewCommit branchTip, SubmoduleOp submoduleOp) throws IntegrationException {
    return submitStrategyFactory.create(submitType, db, or.repo, or.rw, or.ins, or.canMergeFlag, getAlreadyAccepted(or, branchTip), destBranch, caller, mergeTip, commits, submissionId, submitInput.notify, submoduleOp);
}
#method_after
private SubmitStrategy createStrategy(OpenRepo or, MergeTip mergeTip, Branch.NameKey destBranch, SubmitType submitType, CodeReviewCommit branchTip, SubmoduleOp submoduleOp, boolean dryrun) throws IntegrationException {
    return submitStrategyFactory.create(submitType, db, or.repo, or.rw, or.ins, or.canMergeFlag, getAlreadyAccepted(or, branchTip), destBranch, caller, mergeTip, commits, submissionId, submitInput.notify, submoduleOp, dryrun);
}
#end_block

#method_before
private void openRepos(Collection<Project.NameKey> projects) throws IntegrationException {
    for (Project.NameKey project : projects) {
        try {
            orm.openRepo(project, true);
        } catch (NoSuchProjectException noProject) {
            logWarn("Project " + noProject.project() + " no longer exists, " + "abandoning open changes");
            abandonAllOpenChangeForDeletedProject(noProject.project());
        } catch (IOException e) {
            throw new IntegrationException("Error opening project " + project, e);
        }
    }
}
#method_after
private void openRepos(Collection<Project.NameKey> projects) throws IntegrationException {
    for (Project.NameKey project : projects) {
        try {
            orm.openRepo(project);
        } catch (NoSuchProjectException noProject) {
            logWarn("Project " + noProject.project() + " no longer exists, " + "abandoning open changes");
            abandonAllOpenChangeForDeletedProject(noProject.project());
        } catch (IOException e) {
            throw new IntegrationException("Error opening project " + project, e);
        }
    }
}
#end_block

#method_before
private void parseMagicBranch(ReceiveCommand cmd) {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    logDebug("Found magic branch {}", cmd.getRefName());
    magicBranch = new MagicBranchInput(cmd, labelTypes, notesMigration);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    magicBranch.clp = clp;
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet(), pushOptions);
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            logDebug("Invalid branch syntax");
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (projectControl.getProjectState().isAllUsers() && RefNames.REFS_USERS_SELF.equals(ref)) {
        logDebug("Handling {}", RefNames.REFS_USERS_SELF);
        ref = RefNames.refsUsers(user.getAccountId());
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        logDebug("Ref {} not found", ref);
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    if (!magicBranch.ctl.canWrite()) {
        reject(cmd, "project is read only");
        return;
    }
    if (magicBranch.draft) {
        if (!receiveConfig.allowDrafts) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "draft workflow is disabled");
            return;
        } else if (projectControl.controlForRef("refs/drafts/" + ref).isBlocked(Permission.PUSH)) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "cannot upload drafts");
            return;
        }
    }
    if (!magicBranch.ctl.canUpload()) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload review");
        return;
    }
    if (magicBranch.draft && magicBranch.submit) {
        reject(cmd, "cannot submit draft");
        return;
    }
    if (magicBranch.submit && !projectControl.controlForRef(MagicBranch.NEW_CHANGE + ref).canSubmit(true)) {
        reject(cmd, "submit not allowed");
        return;
    }
    if (magicBranch.merged) {
        if (magicBranch.draft) {
            reject(cmd, "cannot be draft & merged");
            return;
        }
        if (magicBranch.base != null) {
            reject(cmd, "cannot use merged with base");
            return;
        }
    }
    RevWalk walk = rp.getRevWalk();
    RevCommit tip;
    try {
        tip = walk.parseCommit(magicBranch.cmd.getNewId());
        logDebug("Tip of push: {}", tip.name());
    } catch (IOException ex) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", ex);
        return;
    }
    // if %base or %merged was specified, ignore newChangeForAllNotInTarget.
    if (tip.getParentCount() > 1 || magicBranch.base != null || magicBranch.merged || tip.getParentCount() == 0) {
        logDebug("Forcing newChangeForAllNotInTarget = false");
        newChangeForAllNotInTarget = false;
    }
    if (magicBranch.base != null) {
        logDebug("Handling %base: {}", magicBranch.base);
        magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
        for (ObjectId id : magicBranch.base) {
            try {
                magicBranch.baseCommit.add(walk.parseCommit(id));
            } catch (IncorrectObjectTypeException notCommit) {
                reject(cmd, "base must be a commit");
                return;
            } catch (MissingObjectException e) {
                reject(cmd, "base not found");
                return;
            } catch (IOException e) {
                logWarn(String.format("Project %s cannot read %s", project.getName(), id.name()), e);
                reject(cmd, "internal server error");
                return;
            }
        }
    } else if (newChangeForAllNotInTarget) {
        logDebug("Handling newChangeForAllNotInTarget");
        String destBranch = magicBranch.dest.get();
        try {
            Ref r = repo.getRefDatabase().exactRef(destBranch);
            if (r == null) {
                reject(cmd, destBranch + " not found");
                return;
            }
            ObjectId baseHead = r.getObjectId();
            magicBranch.baseCommit = Collections.singletonList(walk.parseCommit(baseHead));
            logDebug("Set baseCommit = {}", magicBranch.baseCommit.get(0).name());
        } catch (IOException ex) {
            logWarn(String.format("Project %s cannot read %s", project.getName(), destBranch), ex);
            reject(cmd, "internal server error");
            return;
        }
    }
    // 
    try {
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // The destination branch does not yet exist. Assume the
            // history being sent for review will start it and thus
            // is "connected" to the branch.
            logDebug("Branch is unborn");
            return;
        }
        RevCommit h = walk.parseCommit(targetRef.getObjectId());
        logDebug("Current branch tip: {}", h.name());
        RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", e);
    }
}
#method_after
private void parseMagicBranch(ReceiveCommand cmd) {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    logDebug("Found magic branch {}", cmd.getRefName());
    magicBranch = new MagicBranchInput(cmd, labelTypes, notesMigration);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    magicBranch.clp = clp;
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet(), pushOptions);
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            logDebug("Invalid branch syntax");
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (projectControl.getProjectState().isAllUsers() && RefNames.REFS_USERS_SELF.equals(ref)) {
        logDebug("Handling {}", RefNames.REFS_USERS_SELF);
        ref = RefNames.refsUsers(user.getAccountId());
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        logDebug("Ref {} not found", ref);
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    if (!magicBranch.ctl.canWrite()) {
        reject(cmd, "project is read only");
        return;
    }
    if (magicBranch.draft) {
        if (!receiveConfig.allowDrafts) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "draft workflow is disabled");
            return;
        } else if (projectControl.controlForRef("refs/drafts/" + ref).isBlocked(Permission.PUSH)) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "cannot upload drafts");
            return;
        }
    }
    if (!magicBranch.ctl.canUpload()) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload review");
        return;
    }
    if (magicBranch.draft && magicBranch.submit) {
        reject(cmd, "cannot submit draft");
        return;
    }
    if (magicBranch.submit && !projectControl.controlForRef(MagicBranch.NEW_CHANGE + ref).canSubmit(true)) {
        reject(cmd, "submit not allowed");
        return;
    }
    RevWalk walk = rp.getRevWalk();
    RevCommit tip;
    try {
        tip = walk.parseCommit(magicBranch.cmd.getNewId());
        logDebug("Tip of push: {}", tip.name());
    } catch (IOException ex) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", ex);
        return;
    }
    String destBranch = magicBranch.dest.get();
    try {
        if (magicBranch.merged) {
            if (magicBranch.draft) {
                reject(cmd, "cannot be draft & merged");
                return;
            }
            if (magicBranch.base != null) {
                reject(cmd, "cannot use merged with base");
                return;
            }
            RevCommit branchTip = readBranchTip(cmd, magicBranch.dest);
            if (branchTip == null) {
                // readBranchTip already rejected cmd.
                return;
            }
            if (!walk.isMergedInto(tip, branchTip)) {
                reject(cmd, "not merged into branch");
                return;
            }
        }
        // if %base or %merged was specified, ignore newChangeForAllNotInTarget.
        if (tip.getParentCount() > 1 || magicBranch.base != null || magicBranch.merged || tip.getParentCount() == 0) {
            logDebug("Forcing newChangeForAllNotInTarget = false");
            newChangeForAllNotInTarget = false;
        }
        if (magicBranch.base != null) {
            logDebug("Handling %base: {}", magicBranch.base);
            magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
            for (ObjectId id : magicBranch.base) {
                try {
                    magicBranch.baseCommit.add(walk.parseCommit(id));
                } catch (IncorrectObjectTypeException notCommit) {
                    reject(cmd, "base must be a commit");
                    return;
                } catch (MissingObjectException e) {
                    reject(cmd, "base not found");
                    return;
                } catch (IOException e) {
                    logWarn(String.format("Project %s cannot read %s", project.getName(), id.name()), e);
                    reject(cmd, "internal server error");
                    return;
                }
            }
        } else if (newChangeForAllNotInTarget) {
            RevCommit branchTip = readBranchTip(cmd, magicBranch.dest);
            if (branchTip == null) {
                // readBranchTip already rejected cmd.
                return;
            }
            magicBranch.baseCommit = Collections.singletonList(branchTip);
            logDebug("Set baseCommit = {}", magicBranch.baseCommit.get(0).name());
        }
    } catch (IOException ex) {
        logWarn(String.format("Error walking to %s in project %s", destBranch, project.getName()), ex);
        reject(cmd, "internal server error");
        return;
    }
    // 
    try {
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // The destination branch does not yet exist. Assume the
            // history being sent for review will start it and thus
            // is "connected" to the branch.
            logDebug("Branch is unborn");
            return;
        }
        RevCommit h = walk.parseCommit(targetRef.getObjectId());
        logDebug("Current branch tip: {}", h.name());
        RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", e);
    }
}
#end_block

#method_before
private void selectNewAndReplacedChangesFromMagicBranch() {
    logDebug("Finding new and replaced changes");
    newChanges = new ArrayList<>();
    SetMultimap<ObjectId, Ref> existing = changeRefsById();
    GroupCollector groupCollector = GroupCollector.create(changeRefsById(), db, psUtil, notesFactory, project.getNameKey());
    try {
        RevCommit start = setUpWalkForSelectingChanges();
        List<ChangeLookup> pending = new ArrayList<>();
        Set<Change.Key> newChangeIds = new HashSet<>();
        int maxBatchChanges = receiveConfig.getEffectiveMaxBatchChangesLimit(user);
        int total = 0;
        int alreadyTracked = 0;
        boolean rejectImplicitMerges = start.getParentCount() == 1 && projectCache.get(project.getNameKey()).isRejectImplicitMerges() && // late.
        !magicBranch.merged;
        Set<RevCommit> mergedParents;
        if (rejectImplicitMerges) {
            mergedParents = new HashSet<>();
        } else {
            mergedParents = null;
        }
        for (; ; ) {
            RevCommit c = rp.getRevWalk().next();
            if (c == null) {
                break;
            }
            total++;
            String name = c.name();
            groupCollector.visit(c);
            Collection<Ref> existingRefs = existing.get(c);
            if (rejectImplicitMerges) {
                Collections.addAll(mergedParents, c.getParents());
                mergedParents.remove(c);
            }
            if (!existingRefs.isEmpty()) {
                // Commit is already tracked.
                alreadyTracked++;
                // different target branch.
                for (Ref ref : existingRefs) {
                    updateGroups.add(new UpdateGroupsRequest(ref, c));
                }
                if (!(newChangeForAllNotInTarget || magicBranch.base != null)) {
                    continue;
                }
                logDebug("Creating new change for {} even though it is already tracked", name);
            }
            if (!validCommit(rp.getRevWalk(), magicBranch.ctl, magicBranch.cmd, c)) {
                // Not a change the user can propose? Abort as early as possible.
                newChanges = Collections.emptyList();
                logDebug("Aborting early due to invalid commit");
                return;
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
                logDebug("Rejecting merge commit {} with newChangeForAllNotInTarget", name);
            // TODO(dborowitz): Should we early return here?
            }
            List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(c, magicBranch.dest.get()));
                continue;
            }
            String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                newChanges = Collections.emptyList();
                return;
            }
            pending.add(new ChangeLookup(c, new Change.Key(idStr)));
            int n = pending.size() + newChanges.size();
            if (maxBatchChanges != 0 && n > maxBatchChanges) {
                logDebug("{} changes exceeds limit of {}", n, maxBatchChanges);
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                newChanges = Collections.emptyList();
                return;
            }
        }
        logDebug("Finished initial RevWalk with {} commits total: {} already" + " tracked, {} new changes with no Change-Id, and {} deferred" + " lookups", total, alreadyTracked, newChanges.size(), pending.size());
        if (rejectImplicitMerges) {
            rejectImplicitMerges(mergedParents);
        }
        for (Iterator<ChangeLookup> itr = pending.iterator(); itr.hasNext(); ) {
            ChangeLookup p = itr.next();
            if (newChangeIds.contains(p.changeKey)) {
                logDebug("Multiple commits with Change-Id {}", p.changeKey);
                reject(magicBranch.cmd, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
                newChanges = Collections.emptyList();
                return;
            }
            List<ChangeData> changes = p.destChanges;
            if (changes.size() > 1) {
                logDebug("Multiple changes in project with Change-Id {}: {}", p.changeKey, Lists.transform(changes, new Function<ChangeData, String>() {

                    @Override
                    public String apply(ChangeData in) {
                        return in.getId().toString();
                    }
                }));
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 1) {
                // Schedule as a replacement to this one matching change.
                // 
                RevId currentPs = changes.get(0).currentPatchSet().getRevision();
                // If Commit is already current PatchSet of target Change.
                if (p.commit.name().equals(currentPs.get())) {
                    if (pending.size() == 1) {
                        // There are no commits left to check, all commits in pending were already
                        // current PatchSet of the corresponding target changes.
                        reject(magicBranch.cmd, "commit(s) already exists (as current patchset)");
                    } else {
                        // Commit is already current PatchSet.
                        // Remove from pending and try next commit.
                        itr.remove();
                        continue;
                    }
                }
                if (requestReplace(magicBranch.cmd, false, changes.get(0).change(), p.commit)) {
                    continue;
                }
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    newChanges = Collections.emptyList();
                    return;
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(p.commit, magicBranch.dest.get()));
        }
        logDebug("Finished deferred lookups with {} updates and {} new changes", replaceByChange.size(), newChanges.size());
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", e);
        newChanges = Collections.emptyList();
        return;
    } catch (OrmException e) {
        logError("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        newChanges = Collections.emptyList();
        return;
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return;
    }
    if (!newChanges.isEmpty() && magicBranch.edit) {
        reject(magicBranch.cmd, "edit is not supported for new changes");
        return;
    }
    try {
        SortedSetMultimap<ObjectId, String> groups = groupCollector.getGroups();
        List<Integer> newIds = seq.nextChangeIds(newChanges.size());
        for (int i = 0; i < newChanges.size(); i++) {
            CreateRequest create = newChanges.get(i);
            create.setChangeId(newIds.get(i));
            batch.addCommand(create.cmd);
            create.groups = ImmutableList.copyOf(groups.get(create.commit));
        }
        for (ReplaceRequest replace : replaceByChange.values()) {
            replace.groups = ImmutableList.copyOf(groups.get(replace.newCommitId));
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.groups = ImmutableList.copyOf((groups.get(update.commit)));
        }
        logDebug("Finished updating groups from GroupCollector");
    } catch (OrmException | NoSuchChangeException e) {
        logError("Error collecting groups for changes", e);
        reject(magicBranch.cmd, "internal server error");
        return;
    }
}
#method_after
private void selectNewAndReplacedChangesFromMagicBranch() {
    logDebug("Finding new and replaced changes");
    newChanges = new ArrayList<>();
    SetMultimap<ObjectId, Ref> existing = changeRefsById();
    GroupCollector groupCollector = GroupCollector.create(changeRefsById(), db, psUtil, notesFactory, project.getNameKey());
    try {
        RevCommit start = setUpWalkForSelectingChanges();
        if (start == null) {
            return;
        }
        List<ChangeLookup> pending = new ArrayList<>();
        Set<Change.Key> newChangeIds = new HashSet<>();
        int maxBatchChanges = receiveConfig.getEffectiveMaxBatchChangesLimit(user);
        int total = 0;
        int alreadyTracked = 0;
        boolean rejectImplicitMerges = start.getParentCount() == 1 && projectCache.get(project.getNameKey()).isRejectImplicitMerges() && // late.
        !magicBranch.merged;
        Set<RevCommit> mergedParents;
        if (rejectImplicitMerges) {
            mergedParents = new HashSet<>();
        } else {
            mergedParents = null;
        }
        for (; ; ) {
            RevCommit c = rp.getRevWalk().next();
            if (c == null) {
                break;
            }
            total++;
            String name = c.name();
            groupCollector.visit(c);
            Collection<Ref> existingRefs = existing.get(c);
            if (rejectImplicitMerges) {
                Collections.addAll(mergedParents, c.getParents());
                mergedParents.remove(c);
            }
            if (!existingRefs.isEmpty()) {
                // Commit is already tracked.
                alreadyTracked++;
                // different target branch.
                for (Ref ref : existingRefs) {
                    updateGroups.add(new UpdateGroupsRequest(ref, c));
                }
                if (!(newChangeForAllNotInTarget || magicBranch.base != null)) {
                    continue;
                }
                logDebug("Creating new change for {} even though it is already tracked", name);
            }
            if (!validCommit(rp.getRevWalk(), magicBranch.ctl, magicBranch.cmd, c)) {
                // Not a change the user can propose? Abort as early as possible.
                newChanges = Collections.emptyList();
                logDebug("Aborting early due to invalid commit");
                return;
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
                logDebug("Rejecting merge commit {} with newChangeForAllNotInTarget", name);
            // TODO(dborowitz): Should we early return here?
            }
            List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(c, magicBranch.dest.get()));
                continue;
            }
            String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                newChanges = Collections.emptyList();
                return;
            }
            pending.add(new ChangeLookup(c, new Change.Key(idStr)));
            int n = pending.size() + newChanges.size();
            if (maxBatchChanges != 0 && n > maxBatchChanges) {
                logDebug("{} changes exceeds limit of {}", n, maxBatchChanges);
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                newChanges = Collections.emptyList();
                return;
            }
        }
        logDebug("Finished initial RevWalk with {} commits total: {} already" + " tracked, {} new changes with no Change-Id, and {} deferred" + " lookups", total, alreadyTracked, newChanges.size(), pending.size());
        if (rejectImplicitMerges) {
            rejectImplicitMerges(mergedParents);
        }
        for (Iterator<ChangeLookup> itr = pending.iterator(); itr.hasNext(); ) {
            ChangeLookup p = itr.next();
            if (newChangeIds.contains(p.changeKey)) {
                logDebug("Multiple commits with Change-Id {}", p.changeKey);
                reject(magicBranch.cmd, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
                newChanges = Collections.emptyList();
                return;
            }
            List<ChangeData> changes = p.destChanges;
            if (changes.size() > 1) {
                logDebug("Multiple changes in project with Change-Id {}: {}", p.changeKey, Lists.transform(changes, new Function<ChangeData, String>() {

                    @Override
                    public String apply(ChangeData in) {
                        return in.getId().toString();
                    }
                }));
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 1) {
                // Schedule as a replacement to this one matching change.
                // 
                RevId currentPs = changes.get(0).currentPatchSet().getRevision();
                // If Commit is already current PatchSet of target Change.
                if (p.commit.name().equals(currentPs.get())) {
                    if (pending.size() == 1) {
                        // There are no commits left to check, all commits in pending were already
                        // current PatchSet of the corresponding target changes.
                        reject(magicBranch.cmd, "commit(s) already exists (as current patchset)");
                    } else {
                        // Commit is already current PatchSet.
                        // Remove from pending and try next commit.
                        itr.remove();
                        continue;
                    }
                }
                if (requestReplace(magicBranch.cmd, false, changes.get(0).change(), p.commit)) {
                    continue;
                }
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    newChanges = Collections.emptyList();
                    return;
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(p.commit, magicBranch.dest.get()));
        }
        logDebug("Finished deferred lookups with {} updates and {} new changes", replaceByChange.size(), newChanges.size());
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", e);
        newChanges = Collections.emptyList();
        return;
    } catch (OrmException e) {
        logError("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        newChanges = Collections.emptyList();
        return;
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return;
    }
    if (!newChanges.isEmpty() && magicBranch.edit) {
        reject(magicBranch.cmd, "edit is not supported for new changes");
        return;
    }
    try {
        SortedSetMultimap<ObjectId, String> groups = groupCollector.getGroups();
        List<Integer> newIds = seq.nextChangeIds(newChanges.size());
        for (int i = 0; i < newChanges.size(); i++) {
            CreateRequest create = newChanges.get(i);
            create.setChangeId(newIds.get(i));
            batch.addCommand(create.cmd);
            create.groups = ImmutableList.copyOf(groups.get(create.commit));
        }
        for (ReplaceRequest replace : replaceByChange.values()) {
            replace.groups = ImmutableList.copyOf(groups.get(replace.newCommitId));
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.groups = ImmutableList.copyOf((groups.get(update.commit)));
        }
        logDebug("Finished updating groups from GroupCollector");
    } catch (OrmException | NoSuchChangeException e) {
        logError("Error collecting groups for changes", e);
        reject(magicBranch.cmd, "internal server error");
        return;
    }
}
#end_block

#method_before
private RevCommit setUpWalkForSelectingChanges() throws IOException {
    RevWalk rw = rp.getRevWalk();
    rw.reset();
    rw.sort(RevSort.TOPO);
    rw.sort(RevSort.REVERSE, true);
    RevCommit start = rw.parseCommit(magicBranch.cmd.getNewId());
    rp.getRevWalk().markStart(start);
    if (magicBranch.baseCommit != null) {
        markExplicitBasesUninteresting();
    } else if (magicBranch.merged) {
        logDebug("Marking parents of merged commit {} uninteresting", start.name());
        for (RevCommit c : start.getParents()) {
            rw.markUninteresting(c);
        }
    } else {
        markHeadsAsUninteresting(rw, magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
    }
    return start;
}
#method_after
private RevCommit setUpWalkForSelectingChanges() throws IOException {
    RevWalk rw = rp.getRevWalk();
    RevCommit start = rw.parseCommit(magicBranch.cmd.getNewId());
    rw.reset();
    rw.sort(RevSort.TOPO);
    rw.sort(RevSort.REVERSE, true);
    rp.getRevWalk().markStart(start);
    if (magicBranch.baseCommit != null) {
        markExplicitBasesUninteresting();
    } else if (magicBranch.merged) {
        logDebug("Marking parents of merged commit {} uninteresting", start.name());
        for (RevCommit c : start.getParents()) {
            rw.markUninteresting(c);
        }
    } else {
        markHeadsAsUninteresting(rw, magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
    }
    return start;
}
#end_block

#method_before
private boolean validCommit(RevWalk rw, RefControl ctl, ReceiveCommand cmd, ObjectId id) throws IOException {
    if (validCommits.contains(id)) {
        return true;
    }
    RevCommit c = rw.parseCommit(id);
    rw.parseBody(c);
    CommitReceivedEvent receiveEvent = new CommitReceivedEvent(cmd, project, ctl.getRefName(), c, user);
    CommitValidators commitValidators = commitValidatorsFactory.create(ctl, sshInfo, repo);
    if (magicBranch != null && cmd.getRefName().equals(magicBranch.cmd.getRefName()) && magicBranch.merged) {
        // When a commit is already merged, the user can't go back and add a
        // Change-Id line if missing. However, we still want perform the rest of
        // the validation for things like Forge Committer.
        // TODO(dborowitz): Do we want to use all other validation checks? If we
        // need some defined subset, then we probably need a new validateFor*
        // method on CommitValidators.
        commitValidators.setValidateChangeId(false);
    }
    try {
        messages.addAll(commitValidators.validateForReceiveCommits(receiveEvent, rejectCommits));
    } catch (CommitValidationException e) {
        logDebug("Commit validation failed on {}", c.name());
        messages.addAll(e.getMessages());
        reject(cmd, e.getMessage());
        return false;
    }
    validCommits.add(c.copy());
    return true;
}
#method_after
private boolean validCommit(RevWalk rw, RefControl ctl, ReceiveCommand cmd, ObjectId id) throws IOException {
    if (validCommits.contains(id)) {
        return true;
    }
    RevCommit c = rw.parseCommit(id);
    rw.parseBody(c);
    CommitReceivedEvent receiveEvent = new CommitReceivedEvent(cmd, project, ctl.getRefName(), c, user);
    CommitValidators.Policy policy;
    if (magicBranch != null && cmd.getRefName().equals(magicBranch.cmd.getRefName()) && magicBranch.merged) {
        policy = CommitValidators.Policy.MERGED;
    } else {
        policy = CommitValidators.Policy.RECEIVE_COMMITS;
    }
    try {
        messages.addAll(commitValidatorsFactory.create(policy, ctl, sshInfo, repo).validate(receiveEvent));
    } catch (CommitValidationException e) {
        logDebug("Commit validation failed on {}", c.name());
        messages.addAll(e.getMessages());
        reject(cmd, e.getMessage());
        return false;
    }
    validCommits.add(c.copy());
    return true;
}
#end_block

#method_before
@Test
public void createChangeForMergedCommit() throws Exception {
    String master = "refs/heads/master";
    grant(Permission.PUSH, project, master, true);
    // Update master with a direct push.
    RevCommit c1;
    RevCommit c2;
    String changeId;
    c1 = testRepo.commit().message("Non-change 1").create();
    c2 = testRepo.parseBody(testRepo.commit().parent(c1).message("Non-change 2").insertChangeId().create());
    changeId = Iterables.getOnlyElement(c2.getFooterLines(CHANGE_ID));
    testRepo.reset(c2);
    assertPushOk(pushHead(testRepo, master, false, true), master);
    String q = "commit:" + c1.name() + " OR commit:" + c2.name() + " OR change:" + changeId;
    assertThat(gApi.changes().query(q).get()).isEmpty();
    // Push c2 as a merged change.
    String r = "refs/for/master%merged";
    assertPushOk(pushHead(testRepo, r, false), r);
    EnumSet<ListChangesOption> opts = EnumSet.of(ListChangesOption.CURRENT_REVISION);
    ChangeInfo info = gApi.changes().id(changeId).get(opts);
    assertThat(info.currentRevision).isEqualTo(c2.name());
    assertThat(info.status).isEqualTo(ChangeStatus.MERGED);
    // Only c2 was created as a change.
    String q1 = "commit: " + c1.name();
    assertThat(gApi.changes().query(q1).get()).isEmpty();
    // Push c1 as a merged change.
    testRepo.reset(c1);
    assertPushOk(pushHead(testRepo, r, false), r);
    List<ChangeInfo> infos = gApi.changes().query(q1).withOptions(opts).get();
    assertThat(infos).hasSize(1);
    info = infos.get(0);
    assertThat(info.currentRevision).isEqualTo(c1.name());
    assertThat(info.status).isEqualTo(ChangeStatus.MERGED);
}
#method_after
@Test
public void createChangeForMergedCommit() throws Exception {
    String master = "refs/heads/master";
    grant(Permission.PUSH, project, master, true);
    // Update master with a direct push.
    RevCommit c1 = testRepo.commit().message("Non-change 1").create();
    RevCommit c2 = testRepo.parseBody(testRepo.commit().parent(c1).message("Non-change 2").insertChangeId().create());
    String changeId = Iterables.getOnlyElement(c2.getFooterLines(CHANGE_ID));
    testRepo.reset(c2);
    assertPushOk(pushHead(testRepo, master, false, true), master);
    String q = "commit:" + c1.name() + " OR commit:" + c2.name() + " OR change:" + changeId;
    assertThat(gApi.changes().query(q).get()).isEmpty();
    // Push c2 as a merged change.
    String r = "refs/for/master%merged";
    assertPushOk(pushHead(testRepo, r, false), r);
    EnumSet<ListChangesOption> opts = EnumSet.of(ListChangesOption.CURRENT_REVISION);
    ChangeInfo info = gApi.changes().id(changeId).get(opts);
    assertThat(info.currentRevision).isEqualTo(c2.name());
    assertThat(info.status).isEqualTo(ChangeStatus.MERGED);
    // Only c2 was created as a change.
    String q1 = "commit: " + c1.name();
    assertThat(gApi.changes().query(q1).get()).isEmpty();
    // Push c1 as a merged change.
    testRepo.reset(c1);
    assertPushOk(pushHead(testRepo, r, false), r);
    List<ChangeInfo> infos = gApi.changes().query(q1).withOptions(opts).get();
    assertThat(infos).hasSize(1);
    info = infos.get(0);
    assertThat(info.currentRevision).isEqualTo(c1.name());
    assertThat(info.status).isEqualTo(ChangeStatus.MERGED);
}
#end_block

#method_before
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    RevCommit commit = receiveEvent.commit;
    List<CommitValidationMessage> messages = new LinkedList<>();
    List<String> idList = commit.getFooterLines(FooterConstants.CHANGE_ID);
    String sha1 = commit.abbreviate(SHA1_LENGTH).name();
    if (idList.isEmpty()) {
        if (projectControl.getProjectState().isRequireChangeID()) {
            String shortMsg = commit.getShortMessage();
            if (shortMsg.startsWith(CHANGE_ID_PREFIX) && CHANGE_ID.matcher(shortMsg.substring(CHANGE_ID_PREFIX.length()).trim()).matches()) {
                String errMsg = String.format(MISSING_SUBJECT_MSG, sha1);
                throw new CommitValidationException(errMsg);
            }
            String errMsg = String.format(MISSING_CHANGE_ID_MSG, sha1);
            messages.add(getMissingChangeIdErrorMsg(errMsg, commit));
            throw new CommitValidationException(errMsg, messages);
        }
    } else if (idList.size() > 1) {
        String errMsg = String.format(MULTIPLE_CHANGE_ID_MSG, sha1);
        throw new CommitValidationException(errMsg, messages);
    } else {
        String v = idList.get(idList.size() - 1).trim();
        if (!CHANGE_ID.matcher(v).matches()) {
            String errMsg = String.format(INVALID_CHANGE_ID_MSG, sha1);
            messages.add(getMissingChangeIdErrorMsg(errMsg, receiveEvent.commit));
            throw new CommitValidationException(errMsg, messages);
        }
    }
    return Collections.emptyList();
}
#method_after
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    if (!shouldValidateChangeId(receiveEvent)) {
        return Collections.emptyList();
    }
    RevCommit commit = receiveEvent.commit;
    List<CommitValidationMessage> messages = new LinkedList<>();
    List<String> idList = commit.getFooterLines(FooterConstants.CHANGE_ID);
    String sha1 = commit.abbreviate(SHA1_LENGTH).name();
    if (idList.isEmpty()) {
        if (projectControl.getProjectState().isRequireChangeID()) {
            String shortMsg = commit.getShortMessage();
            if (shortMsg.startsWith(CHANGE_ID_PREFIX) && CHANGE_ID.matcher(shortMsg.substring(CHANGE_ID_PREFIX.length()).trim()).matches()) {
                String errMsg = String.format(MISSING_SUBJECT_MSG, sha1);
                throw new CommitValidationException(errMsg);
            }
            String errMsg = String.format(MISSING_CHANGE_ID_MSG, sha1);
            messages.add(getMissingChangeIdErrorMsg(errMsg, commit));
            throw new CommitValidationException(errMsg, messages);
        }
    } else if (idList.size() > 1) {
        String errMsg = String.format(MULTIPLE_CHANGE_ID_MSG, sha1);
        throw new CommitValidationException(errMsg, messages);
    } else {
        String v = idList.get(idList.size() - 1).trim();
        if (!CHANGE_ID.matcher(v).matches()) {
            String errMsg = String.format(INVALID_CHANGE_ID_MSG, sha1);
            messages.add(getMissingChangeIdErrorMsg(errMsg, receiveEvent.commit));
            throw new CommitValidationException(errMsg, messages);
        }
    }
    return Collections.emptyList();
}
#end_block

#method_before
public void send() throws EmailException {
    if (NotifyHandling.NONE.equals(notify)) {
        return;
    }
    if (!args.emailSender.isEnabled()) {
        // 
        return;
    }
    init();
    format();
    appendText(textTemplate("Footer"));
    if (useHtml()) {
        appendHtml(soyHtmlTemplate("FooterHtml"));
    }
    if (shouldSendMessage()) {
        if (fromId != null) {
            final Account fromUser = args.accountCache.get(fromId).getAccount();
            GeneralPreferencesInfo senderPrefs = fromUser.getGeneralPreferencesInfo();
            if (senderPrefs != null && senderPrefs.getEmailStrategy() == CC_ON_OWN_COMMENTS) {
                // If we are impersonating a user, make sure they receive a CC of
                // this message so they can always review and audit what we sent
                // on their behalf to others.
                // 
                add(RecipientType.CC, fromId);
            } else if (rcptTo.remove(fromId)) {
                // If they don't want a copy, but we queued one up anyway,
                // drop them from the recipient lists.
                // 
                removeUser(fromUser);
            }
            // his email notifications then drop him from recipients' list
            for (Account.Id id : rcptTo) {
                Account thisUser = args.accountCache.get(id).getAccount();
                GeneralPreferencesInfo prefs = thisUser.getGeneralPreferencesInfo();
                if (prefs == null || prefs.getEmailStrategy() == DISABLED) {
                    removeUser(thisUser);
                }
                if (smtpRcptTo.isEmpty()) {
                    return;
                }
            }
        }
        OutgoingEmailValidationListener.Args va = new OutgoingEmailValidationListener.Args();
        va.messageClass = messageClass;
        va.smtpFromAddress = smtpFromAddress;
        va.smtpRcptTo = smtpRcptTo;
        va.headers = headers;
        va.body = textBody.toString();
        va.htmlBody = htmlBody.toString();
        for (OutgoingEmailValidationListener validator : args.outgoingEmailValidationListeners) {
            try {
                validator.validateOutgoingEmail(va);
            } catch (ValidationException e) {
                return;
            }
        }
        args.emailSender.send(va.smtpFromAddress, va.smtpRcptTo, va.headers, va.body, useHtml() ? va.htmlBody : null);
    }
}
#method_after
public void send() throws EmailException {
    if (NotifyHandling.NONE.equals(notify)) {
        return;
    }
    if (!args.emailSender.isEnabled()) {
        // 
        return;
    }
    init();
    format();
    appendText(textTemplate("Footer"));
    if (useHtml()) {
        appendHtml(soyHtmlTemplate("FooterHtml"));
    }
    if (shouldSendMessage()) {
        if (fromId != null) {
            final Account fromUser = args.accountCache.get(fromId).getAccount();
            GeneralPreferencesInfo senderPrefs = fromUser.getGeneralPreferencesInfo();
            if (senderPrefs != null && senderPrefs.getEmailStrategy() == CC_ON_OWN_COMMENTS) {
                // If we are impersonating a user, make sure they receive a CC of
                // this message so they can always review and audit what we sent
                // on their behalf to others.
                // 
                add(RecipientType.CC, fromId);
            } else if (rcptTo.remove(fromId)) {
                // If they don't want a copy, but we queued one up anyway,
                // drop them from the recipient lists.
                // 
                removeUser(fromUser);
            }
            // his email notifications then drop him from recipients' list
            for (Account.Id id : rcptTo) {
                Account thisUser = args.accountCache.get(id).getAccount();
                GeneralPreferencesInfo prefs = thisUser.getGeneralPreferencesInfo();
                if (prefs == null || prefs.getEmailStrategy() == DISABLED) {
                    removeUser(thisUser);
                }
                if (smtpRcptTo.isEmpty()) {
                    return;
                }
            }
        }
        String textPart = textBody.toString();
        OutgoingEmailValidationListener.Args va = new OutgoingEmailValidationListener.Args();
        va.messageClass = messageClass;
        va.smtpFromAddress = smtpFromAddress;
        va.smtpRcptTo = smtpRcptTo;
        va.headers = headers;
        if (useHtml()) {
            String htmlPart = htmlBody.toString();
            String boundary = generateMultipartBoundary(textPart, htmlPart);
            va.body = buildMultipartBody(boundary, textPart, htmlPart);
            va.textBody = textPart;
            va.htmlBody = htmlPart;
            va.headers.put("Content-Type", new EmailHeader.String("multipart/alternative; " + "boundary=\"" + boundary + "\"; " + "charset=UTF-8"));
        } else {
            va.body = textPart;
            va.textBody = textPart;
        }
        for (OutgoingEmailValidationListener validator : args.outgoingEmailValidationListeners) {
            try {
                validator.validateOutgoingEmail(va);
            } catch (ValidationException e) {
                return;
            }
        }
        args.emailSender.send(va.smtpFromAddress, va.smtpRcptTo, va.headers, va.body);
    }
}
#end_block

#method_before
protected void appendHtml(final String html) {
    if (html != null) {
        htmlBody.append(html);
    }
}
#method_after
protected void appendHtml(String html) {
    if (html != null) {
        htmlBody.append(html);
    }
}
#end_block

#method_before
protected String soyTextTemplate(String name) {
    return args.soyTofu.newRenderer("com.google.gerrit.server.mail.template." + name).setContentKind(SanitizedContent.ContentKind.TEXT).setData(soyContext).render();
}
#method_after
protected String soyTextTemplate(String name) {
    return soyTemplate(name, SanitizedContent.ContentKind.TEXT);
}
#end_block

#method_before
protected String soyHtmlTemplate(String name) {
    return args.soyTofu.newRenderer("com.google.gerrit.server.mail.template." + name).setContentKind(SanitizedContent.ContentKind.HTML).setData(soyContext).render();
}
#method_after
protected String soyHtmlTemplate(String name) {
    return soyTemplate(name, SanitizedContent.ContentKind.HTML);
}
#end_block

#method_before
protected String textTemplate(String name) throws EmailException {
    String velocityName = name + ".vm";
    Path filePath = args.site.mail_dir.resolve(velocityName);
    if (Files.isRegularFile(filePath)) {
        return velocifyFile(velocityName);
    } else {
        return soyTextTemplate(name);
    }
}
#method_after
protected String textTemplate(String name) throws EmailException {
    String velocityName = name + ".vm";
    Path filePath = args.site.mail_dir.resolve(velocityName);
    if (Files.isRegularFile(filePath)) {
        return velocifyFile(velocityName);
    }
    return soyTextTemplate(name);
}
#end_block

#method_before
@Test
public void fastForward() throws Exception {
    for (TagType tagType : TagType.values()) {
        allowTagCreation(tagType);
        String tagName = pushTagForExistingCommit(tagType, Status.OK);
        fastForwardTagToExistingCommit(tagType, tagName, Status.REJECTED_OTHER_REASON);
        fastForwardTagToNewCommit(tagType, tagName, Status.REJECTED_OTHER_REASON);
        allowPushOnRefsTags();
        if (TagType.ANNOTATED.equals(tagType)) {
            fastForwardTagToExistingCommit(tagType, tagName, Status.REJECTED_OTHER_REASON);
            fastForwardTagToNewCommit(tagType, tagName, Status.REJECTED_OTHER_REASON);
        } else {
            fastForwardTagToExistingCommit(tagType, tagName, Status.OK);
            fastForwardTagToNewCommit(tagType, tagName, Status.OK);
        }
        allowForcePushOnRefsTags();
        fastForwardTagToExistingCommit(tagType, tagName, Status.OK);
        fastForwardTagToNewCommit(tagType, tagName, Status.OK);
        removePushFromRefsTags();
    }
}
#method_after
@Test
public void fastForward() throws Exception {
    for (TagType tagType : TagType.values()) {
        allowTagCreation(tagType);
        String tagName = pushTagForExistingCommit(tagType, Status.OK);
        fastForwardTagToExistingCommit(tagType, tagName, Status.REJECTED_OTHER_REASON);
        fastForwardTagToNewCommit(tagType, tagName, Status.REJECTED_OTHER_REASON);
        allowTagDeletion();
        fastForwardTagToExistingCommit(tagType, tagName, Status.REJECTED_OTHER_REASON);
        fastForwardTagToNewCommit(tagType, tagName, Status.REJECTED_OTHER_REASON);
        allowPushOnRefsTags();
        Status expectedStatus = tagType == ANNOTATED ? Status.REJECTED_OTHER_REASON : Status.OK;
        fastForwardTagToExistingCommit(tagType, tagName, expectedStatus);
        fastForwardTagToNewCommit(tagType, tagName, expectedStatus);
        allowForcePushOnRefsTags();
        fastForwardTagToExistingCommit(tagType, tagName, Status.OK);
        fastForwardTagToNewCommit(tagType, tagName, Status.OK);
        removePushFromRefsTags();
    }
}
#end_block

#method_before
@Test
public void forceUpdate() throws Exception {
    for (TagType tagType : TagType.values()) {
        allowTagCreation(tagType);
        String tagName = pushTagForExistingCommit(tagType, Status.OK);
        forceUpdateTagToExistingCommit(tagType, tagName, Status.REJECTED_OTHER_REASON);
        forceUpdateTagToNewCommit(tagType, tagName, Status.REJECTED_OTHER_REASON);
        allowPushOnRefsTags();
        forceUpdateTagToExistingCommit(tagType, tagName, Status.REJECTED_OTHER_REASON);
        forceUpdateTagToNewCommit(tagType, tagName, Status.REJECTED_OTHER_REASON);
        allowForcePushOnRefsTags();
        forceUpdateTagToExistingCommit(tagType, tagName, Status.OK);
        forceUpdateTagToNewCommit(tagType, tagName, Status.OK);
        removePushFromRefsTags();
    }
}
#method_after
@Test
public void forceUpdate() throws Exception {
    for (TagType tagType : TagType.values()) {
        allowTagCreation(tagType);
        String tagName = pushTagForExistingCommit(tagType, Status.OK);
        forceUpdateTagToExistingCommit(tagType, tagName, Status.REJECTED_OTHER_REASON);
        forceUpdateTagToNewCommit(tagType, tagName, Status.REJECTED_OTHER_REASON);
        allowPushOnRefsTags();
        forceUpdateTagToExistingCommit(tagType, tagName, Status.REJECTED_OTHER_REASON);
        forceUpdateTagToNewCommit(tagType, tagName, Status.REJECTED_OTHER_REASON);
        allowTagDeletion();
        forceUpdateTagToExistingCommit(tagType, tagName, Status.REJECTED_OTHER_REASON);
        forceUpdateTagToNewCommit(tagType, tagName, Status.REJECTED_OTHER_REASON);
        allowForcePushOnRefsTags();
        forceUpdateTagToExistingCommit(tagType, tagName, Status.OK);
        forceUpdateTagToNewCommit(tagType, tagName, Status.OK);
        removePushFromRefsTags();
    }
}
#end_block

#method_before
@Test
public void delete() throws Exception {
    for (TagType tagType : TagType.values()) {
        allowTagCreation(tagType);
        String tagName = pushTagForExistingCommit(tagType, Status.OK);
        pushTagDeletion(tagType, tagName, Status.REJECTED_OTHER_REASON);
        allowPushOnRefsTags();
        pushTagDeletion(tagType, tagName, Status.REJECTED_OTHER_REASON);
    }
    allowForcePushOnRefsTags();
    for (TagType tagType : TagType.values()) {
        String tagName = pushTagForExistingCommit(tagType, Status.OK);
        pushTagDeletion(tagType, tagName, Status.OK);
    }
}
#method_after
@Test
public void delete() throws Exception {
    for (TagType tagType : TagType.values()) {
        allowTagCreation(tagType);
        String tagName = pushTagForExistingCommit(tagType, Status.OK);
        pushTagDeletion(tagType, tagName, Status.REJECTED_OTHER_REASON);
        allowPushOnRefsTags();
        pushTagDeletion(tagType, tagName, Status.REJECTED_OTHER_REASON);
    }
    allowForcePushOnRefsTags();
    for (TagType tagType : TagType.values()) {
        String tagName = pushTagForExistingCommit(tagType, Status.OK);
        pushTagDeletion(tagType, tagName, Status.OK);
    }
    removePushFromRefsTags();
    allowTagDeletion();
    for (TagType tagType : TagType.values()) {
        String tagName = pushTagForExistingCommit(tagType, Status.OK);
        pushTagDeletion(tagType, tagName, Status.OK);
    }
}
#end_block

#method_before
private String pushTag(TagType tagType, String tagName, boolean newCommit, boolean force, Status expectedStatus) throws Exception {
    if (force) {
        testRepo.reset(initialHead);
    }
    commit(user.getIdent(), "subject");
    boolean createTag = tagName == null;
    tagName = MoreObjects.firstNonNull(tagName, "v1" + "_" + System.nanoTime());
    switch(tagType) {
        case LIGHTWEIGHT:
            break;
        case ANNOTATED:
            if (createTag) {
                createAnnotatedTag(testRepo, tagName, user.getIdent());
            } else {
                updateAnnotatedTag(testRepo, tagName, user.getIdent());
            }
            break;
        default:
            throw new IllegalStateException("unexpected tag type: " + tagType);
    }
    if (!newCommit) {
        grant(Permission.SUBMIT, project, "refs/for/refs/heads/master", false, REGISTERED_USERS);
        pushHead(testRepo, "refs/for/master%submit");
    }
    String tagRef = tagRef(tagName);
    PushResult r = tagType == TagType.LIGHTWEIGHT ? pushHead(testRepo, tagRef, false, force) : GitUtil.pushTag(testRepo, tagName, !createTag);
    RemoteRefUpdate refUpdate = r.getRemoteUpdate(tagRef);
    assertThat(refUpdate.getStatus()).named(tagType.name()).isEqualTo(expectedStatus);
    return tagName;
}
#method_after
private String pushTag(TagType tagType, String tagName, boolean newCommit, boolean force, Status expectedStatus) throws Exception {
    if (force) {
        testRepo.reset(initialHead);
    }
    commit(user.getIdent(), "subject");
    boolean createTag = tagName == null;
    tagName = MoreObjects.firstNonNull(tagName, "v1" + "_" + System.nanoTime());
    switch(tagType) {
        case LIGHTWEIGHT:
            break;
        case ANNOTATED:
            if (createTag) {
                createAnnotatedTag(testRepo, tagName, user.getIdent());
            } else {
                updateAnnotatedTag(testRepo, tagName, user.getIdent());
            }
            break;
        default:
            throw new IllegalStateException("unexpected tag type: " + tagType);
    }
    if (!newCommit) {
        grant(Permission.SUBMIT, project, "refs/for/refs/heads/master", false, REGISTERED_USERS);
        pushHead(testRepo, "refs/for/master%submit");
    }
    String tagRef = tagRef(tagName);
    PushResult r = tagType == LIGHTWEIGHT ? pushHead(testRepo, tagRef, false, force) : GitUtil.pushTag(testRepo, tagName, !createTag);
    RemoteRefUpdate refUpdate = r.getRemoteUpdate(tagRef);
    assertThat(refUpdate.getStatus()).named(tagType.name()).isEqualTo(expectedStatus);
    return tagName;
}
#end_block

#method_before
public boolean isOwner() {
    return isDeclaredOwner() || user.getCapabilities().canAdministrateServer();
}
#method_after
public boolean isOwner() {
    return (isDeclaredOwner() && !controlForRef("refs/*").isBlocked(Permission.OWNER)) || user.getCapabilities().canAdministrateServer();
}
#end_block

#method_before
public Capable canPushToAtLeastOneRef() {
    if (!canPerformOnAnyRef(Permission.PUSH)) {
        String pName = state.getProject().getName();
        return new Capable("Upload denied for project '" + pName + "'");
    }
    if (state.isUseContributorAgreements()) {
        return verifyActiveContributorAgreement();
    }
    return Capable.OK;
}
#method_after
public Capable canPushToAtLeastOneRef() {
    if (!canPerformOnAnyRef(Permission.PUSH) && !canPerformOnAnyRef(Permission.CREATE_TAG)) {
        String pName = state.getProject().getName();
        return new Capable("Upload denied for project '" + pName + "'");
    }
    if (state.isUseContributorAgreements()) {
        return verifyActiveContributorAgreement();
    }
    return Capable.OK;
}
#end_block

#method_before
private void loadLabelSections(Config rc) {
    Map<String, String> lowerNames = Maps.newHashMapWithExpectedSize(2);
    labelSections = new LinkedHashMap<>();
    for (String name : rc.getSubsections(LABEL)) {
        String lower = name.toLowerCase();
        if (lowerNames.containsKey(lower)) {
            error(new ValidationError(PROJECT_CONFIG, String.format("Label \"%s\" conflicts with \"%s\"", name, lowerNames.get(lower))));
        }
        lowerNames.put(lower, name);
        List<LabelValue> values = new ArrayList<>();
        for (String value : rc.getStringList(LABEL, name, KEY_VALUE)) {
            try {
                values.add(parseLabelValue(value));
            } catch (IllegalArgumentException notValue) {
                error(new ValidationError(PROJECT_CONFIG, String.format("Invalid %s \"%s\" for label \"%s\": %s", KEY_VALUE, value, name, notValue.getMessage())));
            }
        }
        LabelType label;
        try {
            label = new LabelType(name, values);
        } catch (IllegalArgumentException badName) {
            error(new ValidationError(PROJECT_CONFIG, String.format("Invalid label \"%s\"", name)));
            continue;
        }
        String functionName = MoreObjects.firstNonNull(rc.getString(LABEL, name, KEY_FUNCTION), "MaxWithBlock");
        if (LABEL_FUNCTIONS.contains(functionName)) {
            label.setFunctionName(functionName);
        } else {
            error(new ValidationError(PROJECT_CONFIG, String.format("Invalid %s for label \"%s\". Valid names are: %s", KEY_FUNCTION, name, Joiner.on(", ").join(LABEL_FUNCTIONS))));
            label.setFunctionName(null);
        }
        if (!values.isEmpty()) {
            short dv = (short) rc.getInt(LABEL, name, KEY_DEFAULT_VALUE, 0);
            if (isInRange(dv, values)) {
                label.setDefaultValue(dv);
            } else {
                error(new ValidationError(PROJECT_CONFIG, String.format("Invalid %s \"%s\" for label \"%s\"", KEY_DEFAULT_VALUE, dv, name)));
            }
        }
        label.setCopyMinScore(rc.getBoolean(LABEL, name, KEY_COPY_MIN_SCORE, LabelType.DEF_COPY_MIN_SCORE));
        label.setCopyMaxScore(rc.getBoolean(LABEL, name, KEY_COPY_MAX_SCORE, LabelType.DEF_COPY_MAX_SCORE));
        label.setCopyAllScoresOnMergeFirstParentUpdate(rc.getBoolean(LABEL, name, KEY_COPY_ALL_SCORES_ON_MERGE_FIRST_PARENT_UPDATE, LabelType.DEF_COPY_ALL_SCORES_ON_MERGE_FIRST_PARENT_UPDATE));
        label.setCopyAllScoresOnTrivialRebase(rc.getBoolean(LABEL, name, KEY_COPY_ALL_SCORES_ON_TRIVIAL_REBASE, LabelType.DEF_COPY_ALL_SCORES_ON_TRIVIAL_REBASE));
        label.setCopyAllScoresIfNoCodeChange(rc.getBoolean(LABEL, name, KEY_COPY_ALL_SCORES_IF_NO_CODE_CHANGE, LabelType.DEF_COPY_ALL_SCORES_IF_NO_CODE_CHANGE));
        label.setCopyAllScoresIfNoChange(rc.getBoolean(LABEL, name, KEY_COPY_ALL_SCORES_IF_NO_CHANGE, LabelType.DEF_COPY_ALL_SCORES_IF_NO_CHANGE));
        label.setCanOverride(rc.getBoolean(LABEL, name, KEY_CAN_OVERRIDE, LabelType.DEF_CAN_OVERRIDE));
        label.setRefPatterns(getStringListOrNull(rc, LABEL, name, KEY_Branch));
        labelSections.put(name, label);
    }
}
#method_after
private void loadLabelSections(Config rc) {
    Map<String, String> lowerNames = Maps.newHashMapWithExpectedSize(2);
    labelSections = new LinkedHashMap<>();
    for (String name : rc.getSubsections(LABEL)) {
        String lower = name.toLowerCase();
        if (lowerNames.containsKey(lower)) {
            error(new ValidationError(PROJECT_CONFIG, String.format("Label \"%s\" conflicts with \"%s\"", name, lowerNames.get(lower))));
        }
        lowerNames.put(lower, name);
        List<LabelValue> values = new ArrayList<>();
        for (String value : rc.getStringList(LABEL, name, KEY_VALUE)) {
            try {
                values.add(parseLabelValue(value));
            } catch (IllegalArgumentException notValue) {
                error(new ValidationError(PROJECT_CONFIG, String.format("Invalid %s \"%s\" for label \"%s\": %s", KEY_VALUE, value, name, notValue.getMessage())));
            }
        }
        LabelType label;
        try {
            label = new LabelType(name, values);
        } catch (IllegalArgumentException badName) {
            error(new ValidationError(PROJECT_CONFIG, String.format("Invalid label \"%s\"", name)));
            continue;
        }
        String functionName = MoreObjects.firstNonNull(rc.getString(LABEL, name, KEY_FUNCTION), "MaxWithBlock");
        if (LABEL_FUNCTIONS.contains(functionName)) {
            label.setFunctionName(functionName);
        } else {
            error(new ValidationError(PROJECT_CONFIG, String.format("Invalid %s for label \"%s\". Valid names are: %s", KEY_FUNCTION, name, Joiner.on(", ").join(LABEL_FUNCTIONS))));
            label.setFunctionName(null);
        }
        if (!values.isEmpty()) {
            short dv = (short) rc.getInt(LABEL, name, KEY_DEFAULT_VALUE, 0);
            if (isInRange(dv, values)) {
                label.setDefaultValue(dv);
            } else {
                error(new ValidationError(PROJECT_CONFIG, String.format("Invalid %s \"%s\" for label \"%s\"", KEY_DEFAULT_VALUE, dv, name)));
            }
        }
        label.setCopyMinScore(rc.getBoolean(LABEL, name, KEY_COPY_MIN_SCORE, LabelType.DEF_COPY_MIN_SCORE));
        label.setCopyMaxScore(rc.getBoolean(LABEL, name, KEY_COPY_MAX_SCORE, LabelType.DEF_COPY_MAX_SCORE));
        label.setCopyAllScoresOnMergeFirstParentUpdate(rc.getBoolean(LABEL, name, KEY_COPY_ALL_SCORES_ON_MERGE_FIRST_PARENT_UPDATE, LabelType.DEF_COPY_ALL_SCORES_ON_MERGE_FIRST_PARENT_UPDATE));
        label.setCopyAllScoresOnTrivialRebase(rc.getBoolean(LABEL, name, KEY_COPY_ALL_SCORES_ON_TRIVIAL_REBASE, LabelType.DEF_COPY_ALL_SCORES_ON_TRIVIAL_REBASE));
        label.setCopyAllScoresIfNoCodeChange(rc.getBoolean(LABEL, name, KEY_COPY_ALL_SCORES_IF_NO_CODE_CHANGE, LabelType.DEF_COPY_ALL_SCORES_IF_NO_CODE_CHANGE));
        label.setCopyAllScoresIfNoChange(rc.getBoolean(LABEL, name, KEY_COPY_ALL_SCORES_IF_NO_CHANGE, LabelType.DEF_COPY_ALL_SCORES_IF_NO_CHANGE));
        label.setCanOverride(rc.getBoolean(LABEL, name, KEY_CAN_OVERRIDE, LabelType.DEF_CAN_OVERRIDE));
        label.setRefPatterns(getStringListOrNull(rc, LABEL, name, KEY_BRANCH));
        labelSections.put(name, label);
    }
}
#end_block

#method_before
public boolean hasLegacyPermissions() {
    return hasLagacyPermissions;
}
#method_after
public boolean hasLegacyPermissions() {
    return hasLegacyPermissions;
}
#end_block

#method_before
private String convertLegacyPermission(String permissionName) {
    switch(permissionName) {
        case LEGACY_PERMISSION_PUSH_TAG:
            hasLagacyPermissions = true;
            return Permission.CREATE_TAG;
        case LEGACY_PERMISSION_PUSH_SIGNED_TAG:
            hasLagacyPermissions = true;
            return Permission.CREATE_SIGNED_TAG;
        default:
            return permissionName;
    }
}
#method_after
private String convertLegacyPermission(String permissionName) {
    switch(permissionName) {
        case LEGACY_PERMISSION_PUSH_TAG:
            hasLegacyPermissions = true;
            return Permission.CREATE_TAG;
        case LEGACY_PERMISSION_PUSH_SIGNED_TAG:
            hasLegacyPermissions = true;
            return Permission.CREATE_SIGNED_TAG;
        default:
            return permissionName;
    }
}
#end_block

#method_before
private void initAllProjects(Repository git) throws IOException, ConfigInvalidException {
    try (MetaDataUpdate md = new MetaDataUpdate(GitReferenceUpdated.DISABLED, allProjectsName, git)) {
        md.getCommitBuilder().setAuthor(serverUser);
        md.getCommitBuilder().setCommitter(serverUser);
        md.setMessage(MoreObjects.firstNonNull(Strings.emptyToNull(message), "Initialized Gerrit Code Review " + Version.getVersion()));
        ProjectConfig config = ProjectConfig.read(md);
        Project p = config.getProject();
        p.setDescription("Access inherited by all other projects.");
        p.setRequireChangeID(InheritableBoolean.TRUE);
        p.setUseContentMerge(InheritableBoolean.TRUE);
        p.setUseContributorAgreements(InheritableBoolean.FALSE);
        p.setUseSignedOffBy(InheritableBoolean.FALSE);
        p.setEnableSignedPush(InheritableBoolean.FALSE);
        AccessSection cap = config.getAccessSection(AccessSection.GLOBAL_CAPABILITIES, true);
        AccessSection all = config.getAccessSection(AccessSection.ALL, true);
        AccessSection heads = config.getAccessSection(AccessSection.HEADS, true);
        AccessSection tags = config.getAccessSection("refs/tags/*", true);
        AccessSection meta = config.getAccessSection(RefNames.REFS_CONFIG, true);
        AccessSection refsFor = config.getAccessSection("refs/for/*", true);
        AccessSection magic = config.getAccessSection("refs/for/" + AccessSection.ALL, true);
        grant(config, cap, GlobalCapability.ADMINISTRATE_SERVER, admin);
        grant(config, all, Permission.READ, admin, anonymous);
        grant(config, refsFor, Permission.ADD_PATCH_SET, registered);
        if (batch != null) {
            Permission priority = cap.getPermission(GlobalCapability.PRIORITY, true);
            PermissionRule r = rule(config, batch);
            r.setAction(Action.BATCH);
            priority.add(r);
            Permission stream = cap.getPermission(GlobalCapability.STREAM_EVENTS, true);
            stream.add(rule(config, batch));
        }
        LabelType cr = initCodeReviewLabel(config);
        grant(config, heads, cr, -1, 1, registered);
        grant(config, heads, cr, -2, 2, admin, owners);
        grant(config, heads, Permission.CREATE, admin, owners);
        grant(config, heads, Permission.PUSH, admin, owners);
        grant(config, heads, Permission.SUBMIT, admin, owners);
        grant(config, heads, Permission.FORGE_AUTHOR, registered);
        grant(config, heads, Permission.FORGE_COMMITTER, admin, owners);
        grant(config, heads, Permission.EDIT_TOPIC_NAME, true, admin, owners);
        grant(config, tags, Permission.CREATE_TAG, admin, owners);
        grant(config, tags, Permission.CREATE_SIGNED_TAG, admin, owners);
        grant(config, magic, Permission.PUSH, registered);
        grant(config, magic, Permission.PUSH_MERGE, registered);
        meta.getPermission(Permission.READ, true).setExclusiveGroup(true);
        grant(config, meta, Permission.READ, admin, owners);
        grant(config, meta, cr, -2, 2, admin, owners);
        grant(config, meta, Permission.PUSH, admin, owners);
        grant(config, meta, Permission.SUBMIT, admin, owners);
        config.commitToNewRef(md, RefNames.REFS_CONFIG);
    }
}
#method_after
private void initAllProjects(Repository git) throws IOException, ConfigInvalidException {
    try (MetaDataUpdate md = new MetaDataUpdate(GitReferenceUpdated.DISABLED, allProjectsName, git)) {
        md.getCommitBuilder().setAuthor(serverUser);
        md.getCommitBuilder().setCommitter(serverUser);
        md.setMessage(MoreObjects.firstNonNull(Strings.emptyToNull(message), "Initialized Gerrit Code Review " + Version.getVersion()));
        ProjectConfig config = ProjectConfig.read(md);
        Project p = config.getProject();
        p.setDescription("Access inherited by all other projects.");
        p.setRequireChangeID(InheritableBoolean.TRUE);
        p.setUseContentMerge(InheritableBoolean.TRUE);
        p.setUseContributorAgreements(InheritableBoolean.FALSE);
        p.setUseSignedOffBy(InheritableBoolean.FALSE);
        p.setEnableSignedPush(InheritableBoolean.FALSE);
        AccessSection cap = config.getAccessSection(AccessSection.GLOBAL_CAPABILITIES, true);
        AccessSection all = config.getAccessSection(AccessSection.ALL, true);
        AccessSection heads = config.getAccessSection(AccessSection.HEADS, true);
        AccessSection tags = config.getAccessSection("refs/tags/*", true);
        AccessSection meta = config.getAccessSection(RefNames.REFS_CONFIG, true);
        AccessSection refsFor = config.getAccessSection("refs/for/*", true);
        AccessSection magic = config.getAccessSection("refs/for/" + AccessSection.ALL, true);
        grant(config, cap, GlobalCapability.ADMINISTRATE_SERVER, admin);
        grant(config, all, Permission.READ, admin, anonymous);
        grant(config, refsFor, Permission.ADD_PATCH_SET, registered);
        if (batch != null) {
            Permission priority = cap.getPermission(GlobalCapability.PRIORITY, true);
            PermissionRule r = rule(config, batch);
            r.setAction(Action.BATCH);
            priority.add(r);
            Permission stream = cap.getPermission(GlobalCapability.STREAM_EVENTS, true);
            stream.add(rule(config, batch));
        }
        LabelType cr = initCodeReviewLabel(config);
        grant(config, heads, cr, -1, 1, registered);
        grant(config, heads, cr, -2, 2, admin, owners);
        grant(config, heads, Permission.CREATE, admin, owners);
        grant(config, heads, Permission.PUSH, admin, owners);
        grant(config, heads, Permission.SUBMIT, admin, owners);
        grant(config, heads, Permission.FORGE_AUTHOR, registered);
        grant(config, heads, Permission.FORGE_COMMITTER, admin, owners);
        grant(config, heads, Permission.EDIT_TOPIC_NAME, true, admin, owners);
        grant(config, tags, Permission.CREATE, admin, owners);
        grant(config, tags, Permission.CREATE_TAG, admin, owners);
        grant(config, tags, Permission.CREATE_SIGNED_TAG, admin, owners);
        grant(config, magic, Permission.PUSH, registered);
        grant(config, magic, Permission.PUSH_MERGE, registered);
        meta.getPermission(Permission.READ, true).setExclusiveGroup(true);
        grant(config, meta, Permission.READ, admin, owners);
        grant(config, meta, cr, -2, 2, admin, owners);
        grant(config, meta, Permission.PUSH, admin, owners);
        grant(config, meta, Permission.SUBMIT, admin, owners);
        config.commitToNewRef(md, RefNames.REFS_CONFIG);
    }
}
#end_block

#method_before
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException {
    for (Project.NameKey projectName : repoManager.list()) {
        try (Repository git = repoManager.openRepository(projectName);
            MetaDataUpdate md = new MetaDataUpdate(GitReferenceUpdated.DISABLED, projectName, git)) {
            ProjectConfig config = ProjectConfig.read(md);
            boolean update = false;
            for (AccessSection accessSection : config.getAccessSections()) {
                Permission pushTagPermission = accessSection.getPermission("pushTag");
                if (pushTagPermission == null) {
                    continue;
                }
                for (PermissionRule rule : pushTagPermission.getRules()) {
                    if (rule.getForce()) {
                        rule.setForce(false);
                        update = true;
                    }
                }
            }
            if (!update) {
                continue;
            }
            md.getCommitBuilder().setAuthor(serverUser);
            md.getCommitBuilder().setCommitter(serverUser);
            md.setMessage(COMMIT_MSG);
            config.commit(md);
        } catch (ConfigInvalidException | IOException ex) {
            throw new OrmException(ex);
        }
    }
}
#method_after
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException {
    for (Project.NameKey projectName : repoManager.list()) {
        try (Repository git = repoManager.openRepository(projectName);
            MetaDataUpdate md = new MetaDataUpdate(GitReferenceUpdated.DISABLED, projectName, git)) {
            ProjectConfigSchemaUpdate cfg = ProjectConfigSchemaUpdate.read(md);
            cfg.removeForceFromPermission("pushTag");
            cfg.save(serverUser, COMMIT_MSG);
        } catch (ConfigInvalidException | IOException ex) {
            throw new OrmException(ex);
        }
    }
}
#end_block

#method_before
@Test
public void createTagNotAllowed() throws Exception {
    TagInput input = new TagInput();
    input.ref = "test";
    exception.expect(AuthException.class);
    exception.expectMessage("Cannot create tag \"" + R_TAGS + "test\"");
    tag(input.ref).create(input);
}
#method_after
@Test
public void createTagNotAllowed() throws Exception {
    block(Permission.CREATE, REGISTERED_USERS, R_TAGS + "*");
    TagInput input = new TagInput();
    input.ref = "test";
    exception.expect(AuthException.class);
    exception.expectMessage("Cannot create tag \"" + R_TAGS + "test\"");
    tag(input.ref).create(input);
}
#end_block

#method_before
public boolean canForceUpdate() {
    return (canPushWithForce() || canDelete()) && canWrite();
}
#method_after
public boolean canForceUpdate() {
    if (!canWrite()) {
        return false;
    }
    if (canPushWithForce()) {
        return true;
    }
    switch(getUser().getAccessPath()) {
        case GIT:
            return false;
        case JSON_RPC:
        case REST_API:
        case SSH_COMMAND:
        case UNKNOWN:
        case WEB_BROWSER:
        default:
            return getUser().getCapabilities().canAdministrateServer() || (isOwner() && !isForceBlocked(Permission.PUSH));
    }
}
#end_block

#method_before
public boolean canCreate(ReviewDb db, Repository repo, RevObject object) {
    if (!canWrite()) {
        return false;
    }
    boolean owner;
    boolean admin;
    switch(getUser().getAccessPath()) {
        case REST_API:
        case JSON_RPC:
        case UNKNOWN:
            owner = isOwner();
            admin = getUser().getCapabilities().canAdministrateServer();
            break;
        case GIT:
        case SSH_COMMAND:
        case WEB_BROWSER:
        default:
            owner = false;
            admin = false;
    }
    if (object instanceof RevCommit) {
        if (admin || (owner && !isBlocked(Permission.CREATE))) {
            // Admin or project owner; bypass visibility check.
            return true;
        } else if (!canPerform(Permission.CREATE)) {
            // No create permissions.
            return false;
        }
        return canCreateCommit(db, repo, (RevCommit) object, admin, owner);
    } else if (object instanceof RevTag) {
        final RevTag tag = (RevTag) object;
        try (RevWalk rw = new RevWalk(repo)) {
            rw.parseBody(tag);
        } catch (IOException e) {
            return false;
        }
        // If tagger is present, require it matches the user's email.
        // 
        final PersonIdent tagger = tag.getTaggerIdent();
        if (tagger != null) {
            boolean valid;
            if (getUser().isIdentifiedUser()) {
                final String addr = tagger.getEmailAddress();
                valid = getUser().asIdentifiedUser().hasEmailAddress(addr);
            } else {
                valid = false;
            }
            if (!valid && !owner && !canForgeCommitter()) {
                return false;
            }
        }
        RevObject tagObject = tag.getObject();
        if (tagObject instanceof RevCommit) {
            if (!canCreateCommit(db, repo, (RevCommit) tagObject, admin, owner)) {
                return false;
            }
        } else {
            if (!canCreate(db, repo, tagObject)) {
                return false;
            }
        }
        // 
        if (tag.getFullMessage().contains("-----BEGIN PGP SIGNATURE-----\n")) {
            return owner || canPerform(Permission.CREATE_SIGNED_TAG);
        }
        return owner || canPerform(Permission.CREATE_TAG);
    } else {
        return false;
    }
}
#method_after
public boolean canCreate(ReviewDb db, Repository repo, RevObject object) {
    if (!canWrite()) {
        return false;
    }
    if (object instanceof RevCommit) {
        if (!canPerform(Permission.CREATE)) {
            // No create permissions.
            return false;
        }
        return canCreateCommit(db, repo, (RevCommit) object);
    } else if (object instanceof RevTag) {
        final RevTag tag = (RevTag) object;
        try (RevWalk rw = new RevWalk(repo)) {
            rw.parseBody(tag);
        } catch (IOException e) {
            return false;
        }
        // If tagger is present, require it matches the user's email.
        // 
        final PersonIdent tagger = tag.getTaggerIdent();
        if (tagger != null) {
            boolean valid;
            if (getUser().isIdentifiedUser()) {
                final String addr = tagger.getEmailAddress();
                valid = getUser().asIdentifiedUser().hasEmailAddress(addr);
            } else {
                valid = false;
            }
            if (!valid && !canForgeCommitter()) {
                return false;
            }
        }
        RevObject tagObject = tag.getObject();
        if (tagObject instanceof RevCommit) {
            if (!canCreateCommit(db, repo, (RevCommit) tagObject)) {
                return false;
            }
        } else {
            if (!canCreate(db, repo, tagObject)) {
                return false;
            }
        }
        // 
        if (tag.getFullMessage().contains("-----BEGIN PGP SIGNATURE-----\n")) {
            return canPerform(Permission.CREATE_SIGNED_TAG);
        }
        return canPerform(Permission.CREATE_TAG);
    } else {
        return false;
    }
}
#end_block

#method_before
private boolean canCreateCommit(ReviewDb db, Repository repo, RevCommit commit, boolean admin, boolean owner) {
    if (admin || (owner && !isBlocked(Permission.CREATE))) {
        // Admin or project owner; bypass visibility check.
        return true;
    } else if (canUpdate()) {
        // of whether they are pushing any new objects along with the create.
        return true;
    } else if (isMergedIntoBranchOrTag(db, repo, commit)) {
        // even if they don't have push permission.
        return true;
    }
    return false;
}
#method_after
private boolean canCreateCommit(ReviewDb db, Repository repo, RevCommit commit) {
    if (canUpdate()) {
        // of whether they are pushing any new objects along with the create.
        return true;
    } else if (isMergedIntoBranchOrTag(db, repo, commit)) {
        // even if they don't have push permission.
        return true;
    }
    return false;
}
#end_block

#method_before
public boolean canDelete() {
    if (!canWrite() || (RefNames.REFS_CONFIG.equals(refName))) {
        // should be removed first.
        return false;
    }
    switch(getUser().getAccessPath()) {
        case GIT:
            return canPushWithForce();
        case JSON_RPC:
        case REST_API:
        case SSH_COMMAND:
        case UNKNOWN:
        case WEB_BROWSER:
        default:
            return getUser().getCapabilities().canAdministrateServer() || (isOwner() && !isForceBlocked(Permission.PUSH)) || canPushWithForce();
    }
}
#method_after
public boolean canDelete() {
    if (!canWrite() || (RefNames.REFS_CONFIG.equals(refName))) {
        // should be removed first.
        return false;
    }
    switch(getUser().getAccessPath()) {
        case GIT:
            return canPushWithForce() || canPerform(Permission.DELETE);
        case JSON_RPC:
        case REST_API:
        case SSH_COMMAND:
        case UNKNOWN:
        case WEB_BROWSER:
        default:
            return getUser().getCapabilities().canAdministrateServer() || (isOwner() && !isForceBlocked(Permission.PUSH)) || canPushWithForce() || canPerform(Permission.DELETE);
    }
}
#end_block

#method_before
private void pushTag(TagType tagType, boolean newCommit, Status expectedStatus) throws Exception {
    commit(user.getIdent(), "subject");
    String tagName = "v1" + "_" + System.nanoTime();
    switch(tagType) {
        case LIGHTWEIGHT:
            break;
        case ANNOTATED:
            createAnnotatedTag(testRepo, tagName, user.getIdent());
            break;
        default:
            throw new IllegalStateException("unexpected tag type: " + tagType);
    }
    if (!newCommit) {
        grant(Permission.SUBMIT, project, "refs/for/refs/heads/master", false, REGISTERED_USERS);
        pushHead(testRepo, "refs/for/master%submit");
    }
    PushResult r = tagType == TagType.LIGHTWEIGHT ? pushHead(testRepo, "refs/tags/" + tagName) : GitUtil.pushTag(testRepo, tagName);
    RemoteRefUpdate refUpdate = r.getRemoteUpdate("refs/tags/" + tagName);
    assertThat(refUpdate.getStatus()).named(tagType.name()).isEqualTo(expectedStatus);
}
#method_after
private void pushTag(TagType tagType, boolean newCommit, Status expectedStatus) throws Exception {
    commit(user.getIdent(), "subject");
    String tagName = "v1" + "_" + System.nanoTime();
    switch(tagType) {
        case LIGHTWEIGHT:
            break;
        case ANNOTATED:
            createAnnotatedTag(testRepo, tagName, user.getIdent());
            break;
        default:
            throw new IllegalStateException("unexpected tag type: " + tagType);
    }
    if (!newCommit) {
        grant(Permission.SUBMIT, project, "refs/for/refs/heads/master", false, REGISTERED_USERS);
        pushHead(testRepo, "refs/for/master%submit");
    }
    PushResult r = tagType == LIGHTWEIGHT ? pushHead(testRepo, "refs/tags/" + tagName) : GitUtil.pushTag(testRepo, tagName);
    RemoteRefUpdate refUpdate = r.getRemoteUpdate("refs/tags/" + tagName);
    assertThat(refUpdate.getStatus()).named(tagType.name()).isEqualTo(expectedStatus);
}
#end_block

#method_before
@Override
protected void formatChange() throws EmailException {
    appendText(textTemplate("Reverted.soy"));
}
#method_after
@Override
protected void formatChange() throws EmailException {
    appendText(textTemplate("Reverted"));
}
#end_block

#method_before
@Override
protected void formatChange() throws EmailException {
    appendText(textTemplate("Restored.soy"));
}
#method_after
@Override
protected void formatChange() throws EmailException {
    appendText(textTemplate("Restored"));
}
#end_block

#method_before
@Test
public void submitNoPermission() throws Exception {
    // create project where submit is blocked
    Project.NameKey p = createProject("p");
    ProjectConfig cfg = projectCache.checkedGet(p).getConfig();
    Util.block(cfg, Permission.SUBMIT, REGISTERED_USERS, "refs/*");
    saveProjectConfig(p, cfg);
    TestRepository<InMemoryRepository> repo = cloneProject(p, admin);
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), repo);
    PushOneCommit.Result result = push.to("refs/for/master");
    result.assertOkStatus();
    submit(result.getChangeId(), new SubmitInput(), AuthException.class, "submit not permitted");
}
#method_after
@Test
public void submitNoPermission() throws Exception {
    // create project where submit is blocked
    Project.NameKey p = createProject("p");
    block(Permission.SUBMIT, REGISTERED_USERS, "refs/*", p);
    TestRepository<InMemoryRepository> repo = cloneProject(p, admin);
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), repo);
    PushOneCommit.Result result = push.to("refs/for/master");
    result.assertOkStatus();
    submit(result.getChangeId(), new SubmitInput(), AuthException.class, "submit not permitted");
}
#end_block

#method_before
protected void setupSoyContext() {
    soyContext = new LinkedHashMap<String, Object>();
    soyContext.put("messageClass", messageClass);
    soyContextEmailData = new LinkedHashMap<String, Object>();
    soyContextEmailData.put("settingsUrl", getSettingsUrl());
    soyContextEmailData.put("gerritHost", getGerritHost());
    soyContextEmailData.put("gerritUrl", getGerritUrl());
    soyContext.put("email", soyContextEmailData);
}
#method_after
protected void setupSoyContext() {
    soyContext = new HashMap<>();
    soyContext.put("messageClass", messageClass);
    soyContextEmailData = new HashMap<>();
    soyContextEmailData.put("settingsUrl", getSettingsUrl());
    soyContextEmailData.put("gerritHost", getGerritHost());
    soyContextEmailData.put("gerritUrl", getGerritUrl());
    soyContext.put("email", soyContextEmailData);
}
#end_block

#method_before
@Override
protected void setupSoyContext() {
    super.setupSoyContext();
    soyContext.put("changeId", change.getKey().get());
    soyContext.put("coverLetter", getCoverLetter());
    soyContext.put("fromName", getNameFor(fromId));
    soyContextEmailData.put("unifiedDiff", getUnifiedDiff());
    soyContextEmailData.put("changeDetail", getChangeDetail());
    soyContextEmailData.put("changeUrl", getChangeUrl());
    soyContextEmailData.put("includeDiff", getIncludeDiff());
    LinkedHashMap<String, String> changeData = new LinkedHashMap<String, String>();
    changeData.put("subject", change.getSubject());
    changeData.put("originalSubject", change.getOriginalSubject());
    changeData.put("ownerEmail", getNameEmailFor(change.getOwner()));
    soyContext.put("change", changeData);
    LinkedHashMap<String, Object> patchSetData = new LinkedHashMap<String, Object>();
    patchSetData.put("patchSetId", patchSet.getPatchSetId());
    patchSetData.put("refName", patchSet.getRefName());
    soyContext.put("patchSet", patchSetData);
// TODO(wyatta): patchSetInfo
}
#method_after
@Override
protected void setupSoyContext() {
    super.setupSoyContext();
    soyContext.put("changeId", change.getKey().get());
    soyContext.put("coverLetter", getCoverLetter());
    soyContext.put("fromName", getNameFor(fromId));
    soyContextEmailData.put("unifiedDiff", getUnifiedDiff());
    soyContextEmailData.put("changeDetail", getChangeDetail());
    soyContextEmailData.put("changeUrl", getChangeUrl());
    soyContextEmailData.put("includeDiff", getIncludeDiff());
    Map<String, String> changeData = new HashMap<>();
    changeData.put("subject", change.getSubject());
    changeData.put("originalSubject", change.getOriginalSubject());
    changeData.put("ownerEmail", getNameEmailFor(change.getOwner()));
    soyContext.put("change", changeData);
    Map<String, Object> patchSetData = new HashMap<>();
    patchSetData.put("patchSetId", patchSet.getPatchSetId());
    patchSetData.put("refName", patchSet.getRefName());
    soyContext.put("patchSet", patchSetData);
// TODO(wyatta): patchSetInfo
}
#end_block

#method_before
@Override
protected void setupSoyContext() {
    super.setupSoyContext();
    soyContext.put("projectName", branch.getParentKey().get());
    soyContextEmailData.put("sshHost", getSshHost());
    LinkedHashMap<String, String> branchData = new LinkedHashMap<String, String>();
    branchData.put("shortName", branch.getShortName());
    soyContext.put("branch", branchData);
}
#method_after
@Override
protected void setupSoyContext() {
    super.setupSoyContext();
    soyContext.put("projectName", branch.getParentKey().get());
    soyContextEmailData.put("sshHost", getSshHost());
    Map<String, String> branchData = new HashMap<>();
    branchData.put("shortName", branch.getShortName());
    soyContext.put("branch", branchData);
}
#end_block

#method_before
void sendMessages() {
    for (CommitValidationMessage m : messages) {
        if (m.isError()) {
            messageSender.sendError(m.getMessage());
        } else {
            messageSender.sendMessage(m.getMessage());
        }
    }
}
#method_after
void sendMessages() {
    for (ValidationMessage m : messages) {
        if (m.isError()) {
            messageSender.sendError(m.getMessage());
        } else {
            messageSender.sendMessage(m.getMessage());
        }
    }
}
#end_block

#method_before
void processCommands(Collection<ReceiveCommand> commands, MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    batch = repo.getRefDatabase().newBatchUpdate();
    batch.setPushCertificate(rp.getPushCertificate());
    batch.setRefLogIdent(rp.getRefLogIdent());
    batch.setRefLogMessage("push", true);
    parseCommands(commands);
    if (magicBranch != null && magicBranch.cmd.getResult() == NOT_ATTEMPTED) {
        selectNewAndReplacedChangesFromMagicBranch();
    }
    preparePatchSetsForReplace();
    if (!batch.getCommands().isEmpty()) {
        try {
            if (!batch.isAllowNonFastForwards() && magicBranch != null && magicBranch.edit) {
                batch.setAllowNonFastForwards(true);
            }
            batch.execute(rp.getRevWalk(), commandProgress);
        } catch (IOException err) {
            int cnt = 0;
            for (ReceiveCommand cmd : batch.getCommands()) {
                if (cmd.getResult() == NOT_ATTEMPTED) {
                    cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
                    cnt++;
                }
            }
            log.error(String.format("Failed to store %d refs in %s", cnt, project.getName()), err);
        }
    }
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(user)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    Set<Branch.NameKey> branches = new HashSet<>();
    for (ReceiveCommand c : batch.getCommands()) {
        if (c.getResult() == OK) {
            String refName = c.getRefName();
            if (c.getType() == ReceiveCommand.Type.UPDATE) {
                // aka fast-forward
                tagCache.updateFastForward(project.getNameKey(), refName, c.getOldId(), c.getNewId());
            }
            if (isHead(c) || isConfig(c)) {
                switch(c.getType()) {
                    case CREATE:
                    case UPDATE:
                    case UPDATE_NONFASTFORWARD:
                        autoCloseChanges(c);
                        branches.add(new Branch.NameKey(project.getNameKey(), refName));
                        break;
                    case DELETE:
                        break;
                }
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(refName) && !refName.startsWith(REFS_CHANGES)) {
                // We only fire gitRefUpdated for direct refs updates.
                // Events for change refs are fired when they are created.
                // 
                gitRefUpdated.fire(project.getNameKey(), c, user.getAccount());
            }
        }
    }
    // Update superproject gitlinks if required.
    try (MergeOpRepoManager orm = ormProvider.get()) {
        orm.setContext(db, TimeUtil.nowTs(), user, "receiveID");
        SubmoduleOp op = subOpFactory.create(branches, orm);
        op.updateSuperProjects();
    } catch (SubmoduleException e) {
        log.error("Can't update the superprojects", e);
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    reportMessages();
}
#method_after
void processCommands(Collection<ReceiveCommand> commands, MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    batch = repo.getRefDatabase().newBatchUpdate();
    batch.setPushCertificate(rp.getPushCertificate());
    batch.setRefLogIdent(rp.getRefLogIdent());
    batch.setRefLogMessage("push", true);
    parseCommands(commands);
    if (magicBranch != null && magicBranch.cmd.getResult() == NOT_ATTEMPTED) {
        selectNewAndReplacedChangesFromMagicBranch();
    }
    preparePatchSetsForReplace();
    logDebug("Executing batch with {} commands", batch.getCommands().size());
    if (!batch.getCommands().isEmpty()) {
        try {
            if (!batch.isAllowNonFastForwards() && magicBranch != null && magicBranch.edit) {
                logDebug("Allowing non-fast-forward for edit ref");
                batch.setAllowNonFastForwards(true);
            }
            batch.execute(rp.getRevWalk(), commandProgress);
        } catch (IOException err) {
            int cnt = 0;
            for (ReceiveCommand cmd : batch.getCommands()) {
                if (cmd.getResult() == NOT_ATTEMPTED) {
                    cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
                    cnt++;
                }
            }
            logError(String.format("Failed to store %d refs in %s", cnt, project.getName()), err);
        }
    }
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        logDebug("Handling error conditions: {}", errors.keySet());
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(user)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    Set<Branch.NameKey> branches = new HashSet<>();
    for (ReceiveCommand c : batch.getCommands()) {
        if (c.getResult() == OK) {
            String refName = c.getRefName();
            if (c.getType() == ReceiveCommand.Type.UPDATE) {
                // aka fast-forward
                logDebug("Updating tag cache on fast-forward of {}", c.getRefName());
                tagCache.updateFastForward(project.getNameKey(), refName, c.getOldId(), c.getNewId());
            }
            if (isHead(c) || isConfig(c)) {
                switch(c.getType()) {
                    case CREATE:
                    case UPDATE:
                    case UPDATE_NONFASTFORWARD:
                        autoCloseChanges(c);
                        branches.add(new Branch.NameKey(project.getNameKey(), refName));
                        break;
                    case DELETE:
                        break;
                }
            }
            if (isConfig(c)) {
                logDebug("Reloading project in cache");
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(refName) && !refName.startsWith(REFS_CHANGES)) {
                logDebug("Firing ref update for {}", c.getRefName());
                // We only fire gitRefUpdated for direct refs updates.
                // Events for change refs are fired when they are created.
                // 
                gitRefUpdated.fire(project.getNameKey(), c, user.getAccount());
            } else {
                logDebug("Assuming ref update event for {} has fired", c.getRefName());
            }
        }
    }
    // Update superproject gitlinks if required.
    try (MergeOpRepoManager orm = ormProvider.get()) {
        orm.setContext(db, TimeUtil.nowTs(), user, receiveId);
        SubmoduleOp op = subOpFactory.create(branches, orm);
        op.updateSuperProjects();
    } catch (SubmoduleException e) {
        logError("Can't update the superprojects", e);
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    reportMessages();
}
#end_block

#method_before
private void reportMessages() {
    Iterable<CreateRequest> created = Iterables.filter(newChanges, new Predicate<CreateRequest>() {

        @Override
        public boolean apply(CreateRequest input) {
            return input.change != null;
        }
    });
    if (!Iterables.isEmpty(created)) {
        addMessage("");
        addMessage("New Changes:");
        for (CreateRequest c : created) {
            addMessage(formatChangeUrl(canonicalWebUrl, c.change, c.change.getSubject(), false));
        }
        addMessage("");
    }
    List<ReplaceRequest> updated = FluentIterable.from(replaceByChange.values()).filter(new Predicate<ReplaceRequest>() {

        @Override
        public boolean apply(ReplaceRequest input) {
            return !input.skip && input.inputCommand.getResult() == OK;
        }
    }).toSortedList(Ordering.natural().onResultOf(new Function<ReplaceRequest, Integer>() {

        @Override
        public Integer apply(ReplaceRequest in) {
            return in.notes.getChangeId().get();
        }
    }));
    if (!updated.isEmpty()) {
        addMessage("");
        addMessage("Updated Changes:");
        boolean edit = magicBranch != null && magicBranch.edit;
        for (ReplaceRequest u : updated) {
            String subject;
            if (edit) {
                try {
                    subject = rp.getRevWalk().parseCommit(u.newCommitId).getShortMessage();
                } catch (IOException e) {
                    // Log and fall back to original change subject
                    log.warn("failed to get subject for edit patch set", e);
                    subject = u.notes.getChange().getSubject();
                }
            } else {
                subject = u.info.getSubject();
            }
            addMessage(formatChangeUrl(canonicalWebUrl, u.notes.getChange(), subject, edit));
        }
        addMessage("");
    }
}
#method_after
private void reportMessages() {
    Iterable<CreateRequest> created = Iterables.filter(newChanges, new Predicate<CreateRequest>() {

        @Override
        public boolean apply(CreateRequest input) {
            return input.change != null;
        }
    });
    if (!Iterables.isEmpty(created)) {
        addMessage("");
        addMessage("New Changes:");
        for (CreateRequest c : created) {
            addMessage(formatChangeUrl(canonicalWebUrl, c.change, c.change.getSubject(), c.change.getStatus() == Change.Status.DRAFT, false));
        }
        addMessage("");
    }
    List<ReplaceRequest> updated = FluentIterable.from(replaceByChange.values()).filter(new Predicate<ReplaceRequest>() {

        @Override
        public boolean apply(ReplaceRequest input) {
            return !input.skip && input.inputCommand.getResult() == OK;
        }
    }).toSortedList(Ordering.natural().onResultOf(new Function<ReplaceRequest, Integer>() {

        @Override
        public Integer apply(ReplaceRequest in) {
            return in.notes.getChangeId().get();
        }
    }));
    if (!updated.isEmpty()) {
        addMessage("");
        addMessage("Updated Changes:");
        boolean edit = magicBranch != null && magicBranch.edit;
        for (ReplaceRequest u : updated) {
            String subject;
            if (edit) {
                try {
                    subject = rp.getRevWalk().parseCommit(u.newCommitId).getShortMessage();
                } catch (IOException e) {
                    // Log and fall back to original change subject
                    logWarn("failed to get subject for edit patch set", e);
                    subject = u.notes.getChange().getSubject();
                }
            } else {
                subject = u.info.getSubject();
            }
            addMessage(formatChangeUrl(canonicalWebUrl, u.notes.getChange(), subject, u.replaceOp != null && u.replaceOp.getPatchSet().isDraft(), edit));
        }
        addMessage("");
    }
}
#end_block

#method_before
private static String formatChangeUrl(String url, Change change, String subject, boolean edit) {
    StringBuilder m = new StringBuilder().append("  ").append(url).append(change.getChangeId()).append(" ").append(ChangeUtil.cropSubject(subject));
    if (change.getStatus() == Change.Status.DRAFT) {
        m.append(" [DRAFT]");
    }
    if (edit) {
        m.append(" [EDIT]");
    }
    return m.toString();
}
#method_after
private static String formatChangeUrl(String url, Change change, String subject, boolean draft, boolean edit) {
    StringBuilder m = new StringBuilder().append("  ").append(url).append(change.getChangeId()).append(" ").append(ChangeUtil.cropSubject(subject));
    if (draft) {
        m.append(" [DRAFT]");
    }
    if (edit) {
        m.append(" [EDIT]");
    }
    return m.toString();
}
#end_block

#method_before
private void insertChangesAndPatchSets() {
    int replaceCount = 0;
    int okToInsert = 0;
    for (Map.Entry<Change.Id, ReplaceRequest> e : replaceByChange.entrySet()) {
        ReplaceRequest replace = e.getValue();
        if (magicBranch != null && replace.inputCommand == magicBranch.cmd) {
            replaceCount++;
            if (replace.cmd != null && replace.cmd.getResult() == OK) {
                okToInsert++;
            }
        } else if (replace.cmd != null && replace.cmd.getResult() == OK) {
            checkState(NEW_PATCHSET.matcher(replace.inputCommand.getRefName()).matches(), "expected a new patch set command as input when creating %s;" + " got %s", replace.cmd.getRefName(), replace.inputCommand.getRefName());
            try {
                replace.insertPatchSetWithoutBatchUpdate();
                replace.inputCommand.setResult(OK);
            } catch (IOException | UpdateException | RestApiException err) {
                reject(replace.inputCommand, "internal server error");
                log.error(String.format("Cannot add patch set to change %d in project %s", e.getKey().get(), project.getName()), err);
            }
        } else if (replace.inputCommand.getResult() == NOT_ATTEMPTED) {
            reject(replace.inputCommand, "internal server error");
            log.error(String.format("Replacement for project %s was not attempted", project.getName()));
        }
    }
    if (magicBranch == null || magicBranch.cmd.getResult() != NOT_ATTEMPTED) {
        // No need to continue.
        return;
    }
    List<String> lastCreateChangeErrors = new ArrayList<>();
    for (CreateRequest create : newChanges) {
        if (create.cmd.getResult() == OK) {
            okToInsert++;
        } else {
            String createChangeResult = String.format("%s %s", create.cmd.getResult(), Strings.nullToEmpty(create.cmd.getMessage())).trim();
            lastCreateChangeErrors.add(createChangeResult);
            log.error(String.format("Command %s on %s:%s not completed: %s", create.cmd.getType(), project.getName(), create.cmd.getRefName(), createChangeResult));
        }
    }
    if (okToInsert != replaceCount + newChanges.size()) {
        // One or more new references failed to create. Assume the
        // system isn't working correctly anymore and abort.
        reject(magicBranch.cmd, "Unable to create changes: " + Joiner.on(' ').join(lastCreateChangeErrors));
        log.error(String.format("Only %d of %d new change refs created in %s; aborting", okToInsert, replaceCount + newChanges.size(), project.getName()));
        return;
    }
    try (BatchUpdate bu = batchUpdateFactory.create(db, magicBranch.dest.getParentKey(), user, TimeUtil.nowTs());
        ObjectInserter ins = repo.newObjectInserter()) {
        bu.setRepository(repo, rp.getRevWalk(), ins).updateChangesInParallel();
        for (ReplaceRequest replace : replaceByChange.values()) {
            if (replace.inputCommand == magicBranch.cmd) {
                replace.addOps(bu, replaceProgress);
            }
        }
        for (CreateRequest create : newChanges) {
            create.addOps(bu);
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.addOps(bu);
        }
        try {
            bu.execute();
        } catch (UpdateException e) {
            throw INSERT_EXCEPTION.apply(e);
        }
        magicBranch.cmd.setResult(OK);
        for (ReplaceRequest replace : replaceByChange.values()) {
            String rejectMessage = replace.getRejectMessage();
            if (rejectMessage != null) {
                reject(replace.inputCommand, rejectMessage);
            }
        }
    } catch (ResourceConflictException e) {
        addMessage(e.getMessage());
        reject(magicBranch.cmd, "conflict");
    } catch (RestApiException | IOException err) {
        log.error("Can't insert change/patch set for " + project.getName(), err);
        reject(magicBranch.cmd, "internal server error: " + err.getMessage());
    }
    if (magicBranch != null && magicBranch.submit) {
        try {
            submit(newChanges, replaceByChange.values());
        } catch (ResourceConflictException e) {
            addMessage(e.getMessage());
            reject(magicBranch.cmd, "conflict");
        } catch (RestApiException | OrmException e) {
            log.error("Error submit changes to " + project.getName(), e);
            reject(magicBranch.cmd, "error during submit");
        }
    }
}
#method_after
private void insertChangesAndPatchSets() {
    int replaceCount = 0;
    int okToInsert = 0;
    for (Map.Entry<Change.Id, ReplaceRequest> e : replaceByChange.entrySet()) {
        ReplaceRequest replace = e.getValue();
        if (magicBranch != null && replace.inputCommand == magicBranch.cmd) {
            replaceCount++;
            if (replace.cmd != null && replace.cmd.getResult() == OK) {
                okToInsert++;
            }
        } else if (replace.cmd != null && replace.cmd.getResult() == OK) {
            String refName = replace.inputCommand.getRefName();
            checkState(NEW_PATCHSET.matcher(refName).matches(), "expected a new patch set command as input when creating %s;" + " got %s", replace.cmd.getRefName(), refName);
            try {
                logDebug("One-off insertion of patch set for {}", refName);
                replace.insertPatchSetWithoutBatchUpdate();
                replace.inputCommand.setResult(OK);
            } catch (IOException | UpdateException | RestApiException err) {
                reject(replace.inputCommand, "internal server error");
                logError(String.format("Cannot add patch set to change %d in project %s", e.getKey().get(), project.getName()), err);
            }
        } else if (replace.inputCommand.getResult() == NOT_ATTEMPTED) {
            reject(replace.inputCommand, "internal server error");
            logError(String.format("Replacement for project %s was not attempted", project.getName()));
        }
    }
    // No need to continue.
    if (magicBranch == null) {
        logDebug("No magic branch, nothing more to do");
        return;
    } else if (magicBranch.cmd.getResult() != NOT_ATTEMPTED) {
        logWarn(String.format("Skipping change updates on %s because ref update failed: %s %s", project.getName(), magicBranch.cmd.getResult(), Strings.nullToEmpty(magicBranch.cmd.getMessage())));
        return;
    }
    List<String> lastCreateChangeErrors = new ArrayList<>();
    for (CreateRequest create : newChanges) {
        if (create.cmd.getResult() == OK) {
            okToInsert++;
        } else {
            String createChangeResult = String.format("%s %s", create.cmd.getResult(), Strings.nullToEmpty(create.cmd.getMessage())).trim();
            lastCreateChangeErrors.add(createChangeResult);
            logError(String.format("Command %s on %s:%s not completed: %s", create.cmd.getType(), project.getName(), create.cmd.getRefName(), createChangeResult));
        }
    }
    logDebug("Counted {} ok to insert, out of {} to replace and {} new", okToInsert, replaceCount, newChanges.size());
    if (okToInsert != replaceCount + newChanges.size()) {
        // One or more new references failed to create. Assume the
        // system isn't working correctly anymore and abort.
        reject(magicBranch.cmd, "Unable to create changes: " + Joiner.on(' ').join(lastCreateChangeErrors));
        logError(String.format("Only %d of %d new change refs created in %s; aborting", okToInsert, replaceCount + newChanges.size(), project.getName()));
        return;
    }
    try (BatchUpdate bu = batchUpdateFactory.create(db, magicBranch.dest.getParentKey(), user, TimeUtil.nowTs());
        ObjectInserter ins = repo.newObjectInserter()) {
        bu.setRepository(repo, rp.getRevWalk(), ins).updateChangesInParallel();
        bu.setRequestId(receiveId);
        for (ReplaceRequest replace : replaceByChange.values()) {
            if (replace.inputCommand == magicBranch.cmd) {
                replace.addOps(bu, replaceProgress);
            }
        }
        for (CreateRequest create : newChanges) {
            create.addOps(bu);
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.addOps(bu);
        }
        logDebug("Executing batch");
        try {
            bu.execute();
        } catch (UpdateException e) {
            throw INSERT_EXCEPTION.apply(e);
        }
        magicBranch.cmd.setResult(OK);
        for (ReplaceRequest replace : replaceByChange.values()) {
            String rejectMessage = replace.getRejectMessage();
            if (rejectMessage != null) {
                logDebug("Rejecting due to message from ReplaceOp");
                reject(replace.inputCommand, rejectMessage);
            }
        }
    } catch (ResourceConflictException e) {
        addMessage(e.getMessage());
        reject(magicBranch.cmd, "conflict");
    } catch (RestApiException | IOException err) {
        logError("Can't insert change/patch set for " + project.getName(), err);
        reject(magicBranch.cmd, "internal server error: " + err.getMessage());
    }
    if (magicBranch != null && magicBranch.submit) {
        try {
            submit(newChanges, replaceByChange.values());
        } catch (ResourceConflictException e) {
            addMessage(e.getMessage());
            reject(magicBranch.cmd, "conflict");
        } catch (RestApiException | OrmException e) {
            logError("Error submitting changes to " + project.getName(), e);
            reject(magicBranch.cmd, "error during submit");
        }
    }
}
#end_block

#method_before
private void parseCommands(Collection<ReceiveCommand> commands) {
    for (ReceiveCommand cmd : commands) {
        if (cmd.getResult() != NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseMagicBranch(cmd);
            continue;
        }
        if (projectControl.getProjectState().isAllUsers() && RefNames.REFS_USERS_SELF.equals(cmd.getRefName())) {
            final ReceiveCommand orgCmd = cmd;
            cmd = new ReceiveCommand(cmd.getOldId(), cmd.getNewId(), RefNames.refsUsers(user.getAccountId()), cmd.getType()) {

                @Override
                public void setResult(Result s, String m) {
                    super.setResult(s, m);
                    orgCmd.setResult(s, m);
                }
            };
        }
        Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(rp.getRevWalk(), cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            addError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                addError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                        Project.NameKey newParent = cfg.getProject().getParent(allProjectsName);
                        Project.NameKey oldParent = project.getParent(allProjectsName);
                        if (oldParent == null) {
                            // update of the 'All-Projects' project
                            if (newParent != null) {
                                reject(cmd, "invalid project configuration: root project cannot have parent");
                                continue;
                            }
                        } else {
                            if (!oldParent.equals(newParent) && !user.getCapabilities().canAdministrateServer()) {
                                reject(cmd, "invalid project configuration: only Gerrit admin can set parent");
                                continue;
                            }
                            if (projectCache.get(newParent) == null) {
                                reject(cmd, "invalid project configuration: parent does not exist");
                                continue;
                            }
                        }
                        for (Entry<ProjectConfigEntry> e : pluginConfigEntries) {
                            PluginConfig pluginCfg = cfg.getPluginConfig(e.getPluginName());
                            ProjectConfigEntry configEntry = e.getProvider().get();
                            String value = pluginCfg.getString(e.getExportName());
                            String oldValue = projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getString(e.getExportName());
                            if (configEntry.getType() == ProjectConfigEntryType.ARRAY) {
                                List<String> l = Arrays.asList(projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getStringList(e.getExportName()));
                                oldValue = Joiner.on("\n").join(l);
                            }
                            if ((value == null ? oldValue != null : !value.equals(oldValue)) && !configEntry.isEditable(projectControl.getProjectState())) {
                                reject(cmd, String.format("invalid project configuration: Not allowed to set parameter" + " '%s' of plugin '%s' on project '%s'.", e.getExportName(), e.getPluginName(), project.getName()));
                                continue;
                            }
                            if (ProjectConfigEntryType.LIST.equals(configEntry.getType()) && value != null && !configEntry.getPermittedValues().contains(value)) {
                                reject(cmd, String.format("invalid project configuration: The value '%s' is " + "not permitted for parameter '%s' of plugin '%s'.", value, e.getExportName(), e.getPluginName()));
                            }
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#method_after
private void parseCommands(Collection<ReceiveCommand> commands) {
    List<String> optionList = rp.getPushOptions();
    if (optionList != null) {
        for (String option : optionList) {
            int e = option.indexOf('=');
            if (e > 0) {
                pushOptions.put(option.substring(0, e), option.substring(e + 1));
            } else {
                pushOptions.put(option, "");
            }
        }
    }
    logDebug("Parsing {} commands", commands.size());
    for (ReceiveCommand cmd : commands) {
        if (cmd.getResult() != NOT_ATTEMPTED) {
            // Already rejected by the core receive process.
            logDebug("Already processed by core: {} {}", cmd.getResult(), cmd);
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseMagicBranch(cmd);
            continue;
        }
        if (projectControl.getProjectState().isAllUsers() && RefNames.REFS_USERS_SELF.equals(cmd.getRefName())) {
            String newName = RefNames.refsUsers(user.getAccountId());
            logDebug("Swapping out command for {} to {}", RefNames.REFS_USERS_SELF, newName);
            final ReceiveCommand orgCmd = cmd;
            cmd = new ReceiveCommand(cmd.getOldId(), cmd.getNewId(), newName, cmd.getType()) {

                @Override
                public void setResult(Result s, String m) {
                    super.setResult(s, m);
                    orgCmd.setResult(s, m);
                }
            };
        }
        Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            logDebug("Processing {} command", cmd.getRefName());
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(rp.getRevWalk(), cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            addError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                addError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            logError("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                        Project.NameKey newParent = cfg.getProject().getParent(allProjectsName);
                        Project.NameKey oldParent = project.getParent(allProjectsName);
                        if (oldParent == null) {
                            // update of the 'All-Projects' project
                            if (newParent != null) {
                                reject(cmd, "invalid project configuration: root project cannot have parent");
                                continue;
                            }
                        } else {
                            if (!oldParent.equals(newParent) && !user.getCapabilities().canAdministrateServer()) {
                                reject(cmd, "invalid project configuration: only Gerrit admin can set parent");
                                continue;
                            }
                            if (projectCache.get(newParent) == null) {
                                reject(cmd, "invalid project configuration: parent does not exist");
                                continue;
                            }
                        }
                        for (Entry<ProjectConfigEntry> e : pluginConfigEntries) {
                            PluginConfig pluginCfg = cfg.getPluginConfig(e.getPluginName());
                            ProjectConfigEntry configEntry = e.getProvider().get();
                            String value = pluginCfg.getString(e.getExportName());
                            String oldValue = projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getString(e.getExportName());
                            if (configEntry.getType() == ProjectConfigEntryType.ARRAY) {
                                List<String> l = Arrays.asList(projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getStringList(e.getExportName()));
                                oldValue = Joiner.on("\n").join(l);
                            }
                            if ((value == null ? oldValue != null : !value.equals(oldValue)) && !configEntry.isEditable(projectControl.getProjectState())) {
                                reject(cmd, String.format("invalid project configuration: Not allowed to set parameter" + " '%s' of plugin '%s' on project '%s'.", e.getExportName(), e.getPluginName(), project.getName()));
                                continue;
                            }
                            if (ProjectConfigEntryType.LIST.equals(configEntry.getType()) && value != null && !configEntry.getPermittedValues().contains(value)) {
                                reject(cmd, String.format("invalid project configuration: The value '%s' is " + "not permitted for parameter '%s' of plugin '%s'.", value, e.getExportName(), e.getPluginName()));
                            }
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        logError("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#end_block

#method_before
private void parseCreate(ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canCreate(db, rp.getRepository(), obj)) {
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        reject(cmd);
    }
}
#method_after
private void parseCreate(ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        logError("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    logDebug("Creating {}", cmd);
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canCreate(db, rp.getRepository(), obj)) {
        if (!validRefOperation(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        reject(cmd);
    }
}
#end_block

#method_before
private void parseUpdate(ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canUpdate()) {
        if (isHead(cmd) && !isCommit(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        if (RefNames.REFS_CONFIG.equals(ctl.getRefName())) {
            errors.put(Error.CONFIG_UPDATE, RefNames.REFS_CONFIG);
        } else {
            errors.put(Error.UPDATE, ctl.getRefName());
        }
        reject(cmd);
    }
}
#method_after
private void parseUpdate(ReceiveCommand cmd) {
    logDebug("Updating {}", cmd);
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canUpdate()) {
        if (isHead(cmd) && !isCommit(cmd)) {
            return;
        }
        if (!validRefOperation(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        if (RefNames.REFS_CONFIG.equals(ctl.getRefName())) {
            errors.put(Error.CONFIG_UPDATE, RefNames.REFS_CONFIG);
        } else {
            errors.put(Error.UPDATE, ctl.getRefName());
        }
        reject(cmd);
    }
}
#end_block

#method_before
private boolean isCommit(ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName(), err);
        reject(cmd, "invalid object");
        return false;
    }
    if (obj instanceof RevCommit) {
        return true;
    }
    reject(cmd, "not a commit");
    return false;
}
#method_after
private boolean isCommit(ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        logError("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName(), err);
        reject(cmd, "invalid object");
        return false;
    }
    if (obj instanceof RevCommit) {
        return true;
    }
    reject(cmd, "not a commit");
    return false;
}
#end_block

#method_before
private void parseDelete(ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.getRefName().startsWith(REFS_CHANGES)) {
        errors.put(Error.DELETE_CHANGES, ctl.getRefName());
        reject(cmd, "cannot delete changes");
    } else if (ctl.canDelete()) {
        batch.addCommand(cmd);
    } else {
        if (RefNames.REFS_CONFIG.equals(ctl.getRefName())) {
            reject(cmd, "cannot delete project configuration");
        } else {
            errors.put(Error.DELETE, ctl.getRefName());
            reject(cmd, "cannot delete references");
        }
    }
}
#method_after
private void parseDelete(ReceiveCommand cmd) {
    logDebug("Deleting {}", cmd);
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.getRefName().startsWith(REFS_CHANGES)) {
        errors.put(Error.DELETE_CHANGES, ctl.getRefName());
        reject(cmd, "cannot delete changes");
    } else if (ctl.canDelete()) {
        if (!validRefOperation(cmd)) {
            return;
        }
        batch.addCommand(cmd);
    } else {
        if (RefNames.REFS_CONFIG.equals(ctl.getRefName())) {
            reject(cmd, "cannot delete project configuration");
        } else {
            errors.put(Error.DELETE, ctl.getRefName());
            reject(cmd, "cannot delete references");
        }
    }
}
#end_block

#method_before
private void parseRewind(ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
        batch.setAllowNonFastForwards(true).addCommand(cmd);
    } else {
        cmd.setResult(REJECTED_NONFASTFORWARD, " need '" + PermissionRule.FORCE_PUSH + "' privilege.");
    }
}
#method_after
private void parseRewind(ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        logError("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    logDebug("Rewinding {}", cmd);
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
        if (!validRefOperation(cmd)) {
            return;
        }
        batch.setAllowNonFastForwards(true).addCommand(cmd);
    } else {
        cmd.setResult(REJECTED_NONFASTFORWARD, " need '" + PermissionRule.FORCE_PUSH + "' privilege.");
    }
}
#end_block

#method_before
String parse(CmdLineParser clp, Repository repo, Set<String> refs) throws CmdLineException {
    String ref = RefNames.fullName(MagicBranch.getDestBranchName(cmd.getRefName()));
    int optionStart = ref.indexOf('%');
    if (0 < optionStart) {
        ListMultimap<String, String> options = LinkedListMultimap.create();
        for (String s : COMMAS.split(ref.substring(optionStart + 1))) {
            int e = s.indexOf('=');
            if (0 < e) {
                options.put(s.substring(0, e), s.substring(e + 1));
            } else {
                options.put(s, "");
            }
        }
        clp.parseOptionMap(options);
        ref = ref.substring(0, optionStart);
    }
    // Split the destination branch by branch and topic. The topic
    // suffix is entirely optional, so it might not even exist.
    String head = readHEAD(repo);
    int split = ref.length();
    for (; ; ) {
        String name = ref.substring(0, split);
        if (refs.contains(name) || name.equals(head)) {
            break;
        }
        split = name.lastIndexOf('/', split - 1);
        if (split <= Constants.R_REFS.length()) {
            return ref;
        }
    }
    if (split < ref.length()) {
        topic = Strings.emptyToNull(ref.substring(split + 1));
    }
    return ref.substring(0, split);
}
#method_after
String parse(CmdLineParser clp, Repository repo, Set<String> refs, ListMultimap<String, String> pushOptions) throws CmdLineException {
    String ref = RefNames.fullName(MagicBranch.getDestBranchName(cmd.getRefName()));
    ListMultimap<String, String> options = LinkedListMultimap.create(pushOptions);
    int optionStart = ref.indexOf('%');
    if (0 < optionStart) {
        for (String s : COMMAS.split(ref.substring(optionStart + 1))) {
            int e = s.indexOf('=');
            if (0 < e) {
                options.put(s.substring(0, e), s.substring(e + 1));
            } else {
                options.put(s, "");
            }
        }
        ref = ref.substring(0, optionStart);
    }
    if (!options.isEmpty()) {
        clp.parseOptionMap(options);
    }
    // Split the destination branch by branch and topic. The topic
    // suffix is entirely optional, so it might not even exist.
    String head = readHEAD(repo);
    int split = ref.length();
    for (; ; ) {
        String name = ref.substring(0, split);
        if (refs.contains(name) || name.equals(head)) {
            break;
        }
        split = name.lastIndexOf('/', split - 1);
        if (split <= Constants.R_REFS.length()) {
            return ref;
        }
    }
    if (split < ref.length()) {
        topic = Strings.emptyToNull(ref.substring(split + 1));
    }
    return ref.substring(0, split);
}
#end_block

#method_before
private void parseMagicBranch(ReceiveCommand cmd) {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    magicBranch = new MagicBranchInput(cmd, labelTypes, notesMigration);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    magicBranch.clp = clp;
    try {
        ListMultimap<String, String> options = LinkedListMultimap.create();
        for (String pushOption : pushOptions) {
            int e = pushOption.indexOf('=');
            if (0 < e) {
                options.put(pushOption.substring(0, e), pushOption.substring(e + 1));
            } else {
                options.put(pushOption, "");
            }
        }
        clp.parseOptionMap(options);
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet());
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (projectControl.getProjectState().isAllUsers() && RefNames.REFS_USERS_SELF.equals(ref)) {
        ref = RefNames.refsUsers(user.getAccountId());
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    if (!magicBranch.ctl.canWrite()) {
        reject(cmd, "project is read only");
        return;
    }
    if (magicBranch.draft) {
        if (!receiveConfig.allowDrafts) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "draft workflow is disabled");
            return;
        } else if (projectControl.controlForRef("refs/drafts/" + ref).isBlocked(Permission.PUSH)) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "cannot upload drafts");
            return;
        }
    }
    if (!magicBranch.ctl.canUpload()) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload review");
        return;
    }
    if (magicBranch.draft && magicBranch.submit) {
        reject(cmd, "cannot submit draft");
        return;
    }
    if (magicBranch.submit && !projectControl.controlForRef(MagicBranch.NEW_CHANGE + ref).canSubmit()) {
        reject(cmd, "submit not allowed");
        return;
    }
    RevWalk walk = rp.getRevWalk();
    RevCommit tip;
    try {
        tip = walk.parseCommit(magicBranch.cmd.getNewId());
    } catch (IOException ex) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", ex);
        return;
    }
    // if %base was specified, ignore newChangeForAllNotInTarget
    if (tip.getParentCount() > 1 || magicBranch.base != null || tip.getParentCount() == 0) {
        newChangeForAllNotInTarget = false;
    }
    if (magicBranch.base != null) {
        magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
        for (ObjectId id : magicBranch.base) {
            try {
                magicBranch.baseCommit.add(walk.parseCommit(id));
            } catch (IncorrectObjectTypeException notCommit) {
                reject(cmd, "base must be a commit");
                return;
            } catch (MissingObjectException e) {
                reject(cmd, "base not found");
                return;
            } catch (IOException e) {
                log.warn(String.format("Project %s cannot read %s", project.getName(), id.name()), e);
                reject(cmd, "internal server error");
                return;
            }
        }
    } else if (newChangeForAllNotInTarget) {
        String destBranch = magicBranch.dest.get();
        try {
            Ref r = repo.getRefDatabase().exactRef(destBranch);
            if (r == null) {
                reject(cmd, destBranch + " not found");
                return;
            }
            ObjectId baseHead = r.getObjectId();
            magicBranch.baseCommit = Collections.singletonList(walk.parseCommit(baseHead));
        } catch (IOException ex) {
            log.warn(String.format("Project %s cannot read %s", project.getName(), destBranch), ex);
            reject(cmd, "internal server error");
            return;
        }
    }
    // 
    try {
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        RevCommit h = walk.parseCommit(targetRef.getObjectId());
        RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
    }
}
#method_after
private void parseMagicBranch(ReceiveCommand cmd) {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    logDebug("Found magic branch {}", cmd.getRefName());
    magicBranch = new MagicBranchInput(cmd, labelTypes, notesMigration);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    magicBranch.clp = clp;
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet(), pushOptions);
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            logDebug("Invalid branch syntax");
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (projectControl.getProjectState().isAllUsers() && RefNames.REFS_USERS_SELF.equals(ref)) {
        logDebug("Handling {}", RefNames.REFS_USERS_SELF);
        ref = RefNames.refsUsers(user.getAccountId());
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        logDebug("Ref {} not found", ref);
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    if (!magicBranch.ctl.canWrite()) {
        reject(cmd, "project is read only");
        return;
    }
    if (magicBranch.draft) {
        if (!receiveConfig.allowDrafts) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "draft workflow is disabled");
            return;
        } else if (projectControl.controlForRef("refs/drafts/" + ref).isBlocked(Permission.PUSH)) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "cannot upload drafts");
            return;
        }
    }
    if (!magicBranch.ctl.canUpload()) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload review");
        return;
    }
    if (magicBranch.draft && magicBranch.submit) {
        reject(cmd, "cannot submit draft");
        return;
    }
    if (magicBranch.submit && !projectControl.controlForRef(MagicBranch.NEW_CHANGE + ref).canSubmit()) {
        reject(cmd, "submit not allowed");
        return;
    }
    RevWalk walk = rp.getRevWalk();
    RevCommit tip;
    try {
        tip = walk.parseCommit(magicBranch.cmd.getNewId());
        logDebug("Tip of push: {}", tip.name());
    } catch (IOException ex) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", ex);
        return;
    }
    // if %base was specified, ignore newChangeForAllNotInTarget
    if (tip.getParentCount() > 1 || magicBranch.base != null || tip.getParentCount() == 0) {
        logDebug("Forcing newChangeForAllNotInTarget = false");
        newChangeForAllNotInTarget = false;
    }
    if (magicBranch.base != null) {
        logDebug("Handling %base: {}", magicBranch.base);
        magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
        for (ObjectId id : magicBranch.base) {
            try {
                magicBranch.baseCommit.add(walk.parseCommit(id));
            } catch (IncorrectObjectTypeException notCommit) {
                reject(cmd, "base must be a commit");
                return;
            } catch (MissingObjectException e) {
                reject(cmd, "base not found");
                return;
            } catch (IOException e) {
                logWarn(String.format("Project %s cannot read %s", project.getName(), id.name()), e);
                reject(cmd, "internal server error");
                return;
            }
        }
    } else if (newChangeForAllNotInTarget) {
        logDebug("Handling newChangeForAllNotInTarget");
        String destBranch = magicBranch.dest.get();
        try {
            Ref r = repo.getRefDatabase().exactRef(destBranch);
            if (r == null) {
                reject(cmd, destBranch + " not found");
                return;
            }
            ObjectId baseHead = r.getObjectId();
            magicBranch.baseCommit = Collections.singletonList(walk.parseCommit(baseHead));
            logDebug("Set baseCommit = {}", magicBranch.baseCommit.get(0).name());
        } catch (IOException ex) {
            logWarn(String.format("Project %s cannot read %s", project.getName(), destBranch), ex);
            reject(cmd, "internal server error");
            return;
        }
    }
    // 
    try {
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // The destination branch does not yet exist. Assume the
            // history being sent for review will start it and thus
            // is "connected" to the branch.
            logDebug("Branch is unborn");
            return;
        }
        RevCommit h = walk.parseCommit(targetRef.getObjectId());
        logDebug("Current branch tip: {}", h.name());
        RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", e);
    }
}
#end_block

#method_before
private void parseReplaceCommand(ReceiveCommand cmd, Change.Id changeId) {
    if (cmd.getType() != ReceiveCommand.Type.CREATE) {
        reject(cmd, "invalid usage");
        return;
    }
    RevCommit newCommit;
    try {
        newCommit = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IOException e) {
        log.error("Cannot parse " + cmd.getNewId().name() + " as commit", e);
        reject(cmd, "invalid commit");
        return;
    }
    Change changeEnt;
    try {
        changeEnt = notesFactory.createChecked(db, project.getNameKey(), changeId).getChange();
    } catch (OrmException e) {
        log.error("Cannot lookup existing change " + changeId, e);
        reject(cmd, "database error");
        return;
    } catch (NoSuchChangeException e) {
        log.error("Change not found " + changeId, e);
        reject(cmd, "change " + changeId + " not found");
        return;
    }
    if (!project.getNameKey().equals(changeEnt.getProject())) {
        reject(cmd, "change " + changeId + " does not belong to project " + project.getName());
        return;
    }
    requestReplace(cmd, true, changeEnt, newCommit);
}
#method_after
private void parseReplaceCommand(ReceiveCommand cmd, Change.Id changeId) {
    logDebug("Parsing replace command");
    if (cmd.getType() != ReceiveCommand.Type.CREATE) {
        reject(cmd, "invalid usage");
        return;
    }
    RevCommit newCommit;
    try {
        newCommit = rp.getRevWalk().parseCommit(cmd.getNewId());
        logDebug("Replacing with {}", newCommit);
    } catch (IOException e) {
        logError("Cannot parse " + cmd.getNewId().name() + " as commit", e);
        reject(cmd, "invalid commit");
        return;
    }
    Change changeEnt;
    try {
        changeEnt = notesFactory.createChecked(db, project.getNameKey(), changeId).getChange();
    } catch (OrmException e) {
        logError("Cannot lookup existing change " + changeId, e);
        reject(cmd, "database error");
        return;
    } catch (NoSuchChangeException e) {
        logError("Change not found " + changeId, e);
        reject(cmd, "change " + changeId + " not found");
        return;
    }
    if (!project.getNameKey().equals(changeEnt.getProject())) {
        reject(cmd, "change " + changeId + " does not belong to project " + project.getName());
        return;
    }
    logDebug("Replacing change {}", changeEnt.getId());
    requestReplace(cmd, true, changeEnt, newCommit);
}
#end_block

#method_before
private void selectNewAndReplacedChangesFromMagicBranch() {
    newChanges = new ArrayList<>();
    SetMultimap<ObjectId, Ref> existing = changeRefsById();
    GroupCollector groupCollector = GroupCollector.create(changeRefsById(), db, psUtil, notesFactory, project.getNameKey());
    rp.getRevWalk().reset();
    rp.getRevWalk().sort(RevSort.TOPO);
    rp.getRevWalk().sort(RevSort.REVERSE, true);
    try {
        rp.getRevWalk().markStart(rp.getRevWalk().parseCommit(magicBranch.cmd.getNewId()));
        if (magicBranch.baseCommit != null) {
            for (RevCommit c : magicBranch.baseCommit) {
                rp.getRevWalk().markUninteresting(c);
            }
            Ref targetRef = allRefs.get(magicBranch.ctl.getRefName());
            if (targetRef != null) {
                rp.getRevWalk().markUninteresting(rp.getRevWalk().parseCommit(targetRef.getObjectId()));
            }
        } else {
            markHeadsAsUninteresting(rp.getRevWalk(), magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
        }
        List<ChangeLookup> pending = new ArrayList<>();
        Set<Change.Key> newChangeIds = new HashSet<>();
        int maxBatchChanges = receiveConfig.getEffectiveMaxBatchChangesLimit(user);
        for (; ; ) {
            RevCommit c = rp.getRevWalk().next();
            if (c == null) {
                break;
            }
            groupCollector.visit(c);
            Collection<Ref> existingRefs = existing.get(c);
            if (!existingRefs.isEmpty()) {
                // different target branch.
                for (Ref ref : existingRefs) {
                    updateGroups.add(new UpdateGroupsRequest(ref, c));
                }
                if (!(newChangeForAllNotInTarget || magicBranch.base != null)) {
                    continue;
                }
            }
            if (!validCommit(rp.getRevWalk(), magicBranch.ctl, magicBranch.cmd, c)) {
                // Not a change the user can propose? Abort as early as possible.
                newChanges = Collections.emptyList();
                return;
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
            }
            List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(c, magicBranch.dest.get()));
                continue;
            }
            String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                newChanges = Collections.emptyList();
                return;
            }
            pending.add(new ChangeLookup(c, new Change.Key(idStr)));
            if (maxBatchChanges != 0 && pending.size() + newChanges.size() > maxBatchChanges) {
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                newChanges = Collections.emptyList();
                return;
            }
        }
        for (Iterator<ChangeLookup> itr = pending.iterator(); itr.hasNext(); ) {
            ChangeLookup p = itr.next();
            if (newChangeIds.contains(p.changeKey)) {
                reject(magicBranch.cmd, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
                newChanges = Collections.emptyList();
                return;
            }
            List<ChangeData> changes = p.destChanges;
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 1) {
                // Schedule as a replacement to this one matching change.
                // 
                RevId currentPs = changes.get(0).currentPatchSet().getRevision();
                // If Commit is already current PatchSet of target Change.
                if (p.commit.name().equals(currentPs.get())) {
                    if (pending.size() == 1) {
                        // There are no commits left to check, all commits in pending were already
                        // current PatchSet of the corresponding target changes.
                        reject(magicBranch.cmd, "commit(s) already exists (as current patchset)");
                    } else {
                        // Commit is already current PatchSet.
                        // Remove from pending and try next commit.
                        itr.remove();
                        continue;
                    }
                }
                if (requestReplace(magicBranch.cmd, false, changes.get(0).change(), p.commit)) {
                    continue;
                }
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    newChanges = Collections.emptyList();
                    return;
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(p.commit, magicBranch.dest.get()));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        newChanges = Collections.emptyList();
        return;
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        newChanges = Collections.emptyList();
        return;
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return;
    }
    if (!newChanges.isEmpty() && magicBranch.edit) {
        reject(magicBranch.cmd, "edit is not supported for new changes");
        return;
    }
    try {
        SortedSetMultimap<ObjectId, String> groups = groupCollector.getGroups();
        List<Integer> newIds = seq.nextChangeIds(newChanges.size());
        for (int i = 0; i < newChanges.size(); i++) {
            CreateRequest create = newChanges.get(i);
            create.setChangeId(newIds.get(i));
            batch.addCommand(create.cmd);
            create.groups = ImmutableList.copyOf(groups.get(create.commit));
        }
        for (ReplaceRequest replace : replaceByChange.values()) {
            replace.groups = ImmutableList.copyOf(groups.get(replace.newCommitId));
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.groups = ImmutableList.copyOf((groups.get(update.commit)));
        }
    } catch (OrmException | NoSuchChangeException e) {
        log.error("Error collecting groups for changes", e);
        reject(magicBranch.cmd, "internal server error");
        return;
    }
}
#method_after
private void selectNewAndReplacedChangesFromMagicBranch() {
    logDebug("Finding new and replaced changes");
    newChanges = new ArrayList<>();
    SetMultimap<ObjectId, Ref> existing = changeRefsById();
    GroupCollector groupCollector = GroupCollector.create(changeRefsById(), db, psUtil, notesFactory, project.getNameKey());
    rp.getRevWalk().reset();
    rp.getRevWalk().sort(RevSort.TOPO);
    rp.getRevWalk().sort(RevSort.REVERSE, true);
    try {
        rp.getRevWalk().markStart(rp.getRevWalk().parseCommit(magicBranch.cmd.getNewId()));
        if (magicBranch.baseCommit != null) {
            logDebug("Marking {} base commits uninteresting", magicBranch.baseCommit.size());
            for (RevCommit c : magicBranch.baseCommit) {
                rp.getRevWalk().markUninteresting(c);
            }
            Ref targetRef = allRefs.get(magicBranch.ctl.getRefName());
            if (targetRef != null) {
                logDebug("Marking target ref {} ({}) uninteresting", magicBranch.ctl.getRefName(), targetRef.getObjectId().name());
                rp.getRevWalk().markUninteresting(rp.getRevWalk().parseCommit(targetRef.getObjectId()));
            }
        } else {
            markHeadsAsUninteresting(rp.getRevWalk(), magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
        }
        List<ChangeLookup> pending = new ArrayList<>();
        Set<Change.Key> newChangeIds = new HashSet<>();
        int maxBatchChanges = receiveConfig.getEffectiveMaxBatchChangesLimit(user);
        int total = 0;
        int alreadyTracked = 0;
        for (; ; ) {
            RevCommit c = rp.getRevWalk().next();
            if (c == null) {
                break;
            }
            total++;
            String name = c.name();
            groupCollector.visit(c);
            Collection<Ref> existingRefs = existing.get(c);
            if (!existingRefs.isEmpty()) {
                // Commit is already tracked.
                alreadyTracked++;
                // different target branch.
                for (Ref ref : existingRefs) {
                    updateGroups.add(new UpdateGroupsRequest(ref, c));
                }
                if (!(newChangeForAllNotInTarget || magicBranch.base != null)) {
                    continue;
                }
                logDebug("Creating new change for {} even though it is already tracked", name);
            }
            if (!validCommit(rp.getRevWalk(), magicBranch.ctl, magicBranch.cmd, c)) {
                // Not a change the user can propose? Abort as early as possible.
                newChanges = Collections.emptyList();
                logDebug("Aborting early due to invalid commit");
                return;
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
                logDebug("Rejecting merge commit {} with newChangeForAllNotInTarget", name);
            // TODO(dborowitz): Should we early return here?
            }
            List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(c, magicBranch.dest.get()));
                continue;
            }
            String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                newChanges = Collections.emptyList();
                return;
            }
            pending.add(new ChangeLookup(c, new Change.Key(idStr)));
            int n = pending.size() + newChanges.size();
            if (maxBatchChanges != 0 && n > maxBatchChanges) {
                logDebug("{} changes exceeds limit of {}", n, maxBatchChanges);
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                newChanges = Collections.emptyList();
                return;
            }
        }
        logDebug("Finished initial RevWalk with {} commits total: {} already" + " tracked, {} new changes with no Change-Id, and {} deferred" + " lookups", total, alreadyTracked, newChanges.size(), pending.size());
        for (Iterator<ChangeLookup> itr = pending.iterator(); itr.hasNext(); ) {
            ChangeLookup p = itr.next();
            if (newChangeIds.contains(p.changeKey)) {
                logDebug("Multiple commits with Change-Id {}", p.changeKey);
                reject(magicBranch.cmd, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
                newChanges = Collections.emptyList();
                return;
            }
            List<ChangeData> changes = p.destChanges;
            if (changes.size() > 1) {
                logDebug("Multiple changes in project with Change-Id {}: {}", p.changeKey, Lists.transform(changes, new Function<ChangeData, String>() {

                    @Override
                    public String apply(ChangeData in) {
                        return in.getId().toString();
                    }
                }));
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 1) {
                // Schedule as a replacement to this one matching change.
                // 
                RevId currentPs = changes.get(0).currentPatchSet().getRevision();
                // If Commit is already current PatchSet of target Change.
                if (p.commit.name().equals(currentPs.get())) {
                    if (pending.size() == 1) {
                        // There are no commits left to check, all commits in pending were already
                        // current PatchSet of the corresponding target changes.
                        reject(magicBranch.cmd, "commit(s) already exists (as current patchset)");
                    } else {
                        // Commit is already current PatchSet.
                        // Remove from pending and try next commit.
                        itr.remove();
                        continue;
                    }
                }
                if (requestReplace(magicBranch.cmd, false, changes.get(0).change(), p.commit)) {
                    continue;
                }
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    newChanges = Collections.emptyList();
                    return;
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(p.commit, magicBranch.dest.get()));
        }
        logDebug("Finished deferred lookups with {} updates and {} new changes", replaceByChange.size(), newChanges.size());
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", e);
        newChanges = Collections.emptyList();
        return;
    } catch (OrmException e) {
        logError("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        newChanges = Collections.emptyList();
        return;
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return;
    }
    if (!newChanges.isEmpty() && magicBranch.edit) {
        reject(magicBranch.cmd, "edit is not supported for new changes");
        return;
    }
    try {
        SortedSetMultimap<ObjectId, String> groups = groupCollector.getGroups();
        List<Integer> newIds = seq.nextChangeIds(newChanges.size());
        for (int i = 0; i < newChanges.size(); i++) {
            CreateRequest create = newChanges.get(i);
            create.setChangeId(newIds.get(i));
            batch.addCommand(create.cmd);
            create.groups = ImmutableList.copyOf(groups.get(create.commit));
        }
        for (ReplaceRequest replace : replaceByChange.values()) {
            replace.groups = ImmutableList.copyOf(groups.get(replace.newCommitId));
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.groups = ImmutableList.copyOf((groups.get(update.commit)));
        }
        logDebug("Finished updating groups from GroupCollector");
    } catch (OrmException | NoSuchChangeException e) {
        logError("Error collecting groups for changes", e);
        reject(magicBranch.cmd, "internal server error");
        return;
    }
}
#end_block

#method_before
private void markHeadsAsUninteresting(RevWalk rw, @Nullable String forRef) {
    for (Ref ref : allRefs.values()) {
        if ((ref.getName().startsWith(R_HEADS) || ref.getName().equals(forRef)) && ref.getObjectId() != null) {
            try {
                rw.markUninteresting(rw.parseCommit(ref.getObjectId()));
            } catch (IOException e) {
                log.warn(String.format("Invalid ref %s in %s", ref.getName(), project.getName()), e);
            }
        }
    }
}
#method_after
private void markHeadsAsUninteresting(RevWalk rw, @Nullable String forRef) {
    int i = 0;
    for (Ref ref : allRefs.values()) {
        if ((ref.getName().startsWith(R_HEADS) || ref.getName().equals(forRef)) && ref.getObjectId() != null) {
            try {
                rw.markUninteresting(rw.parseCommit(ref.getObjectId()));
                i++;
            } catch (IOException e) {
                logWarn(String.format("Invalid ref %s in %s", ref.getName(), project.getName()), e);
            }
        }
    }
    logDebug("Marked {} heads as uninteresting", i);
}
#end_block

#method_before
private void addOps(BatchUpdate bu) throws RestApiException {
    checkState(changeId != null, "must call setChangeId before addOps");
    try {
        RevWalk rw = rp.getRevWalk();
        rw.parseBody(commit);
        final PatchSet.Id psId = ins.setGroups(groups).getPatchSetId();
        Account.Id me = user.getAccountId();
        List<FooterLine> footerLines = commit.getFooterLines();
        MailRecipients recipients = new MailRecipients();
        Map<String, Short> approvals = new HashMap<>();
        checkNotNull(magicBranch);
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.labels;
        recipients.add(getRecipientsFromFooters(accountResolver, magicBranch.draft, footerLines));
        recipients.remove(me);
        StringBuilder msg = new StringBuilder(ApprovalsUtil.renderMessageWithApprovals(psId.get(), approvals, Collections.<String, PatchSetApproval>emptyMap()));
        msg.append('.');
        if (!Strings.isNullOrEmpty(magicBranch.message)) {
            msg.append("\n").append(magicBranch.message);
        }
        bu.insertChange(ins.setReviewers(recipients.getReviewers()).setExtraCC(recipients.getCcOnly()).setApprovals(approvals).setMessage(msg.toString()).setNotify(magicBranch.notify).setRequestScopePropagator(requestScopePropagator).setSendMail(true).setUpdateRef(true));
        if (!magicBranch.hashtags.isEmpty()) {
            bu.addOp(changeId, hashtagsFactory.create(new HashtagsInput(magicBranch.hashtags)).setFireEvent(false));
        }
        if (!Strings.isNullOrEmpty(magicBranch.topic)) {
            bu.addOp(changeId, new BatchUpdate.Op() {

                @Override
                public boolean updateChange(ChangeContext ctx) {
                    ctx.getUpdate(psId).setTopic(magicBranch.topic);
                    return true;
                }
            });
        }
        bu.addOp(changeId, new BatchUpdate.Op() {

            @Override
            public boolean updateChange(ChangeContext ctx) {
                change = ctx.getChange();
                return false;
            }
        });
        bu.addOp(changeId, new ChangeProgressOp(newProgress));
    } catch (Exception e) {
        throw INSERT_EXCEPTION.apply(e);
    }
}
#method_after
private void addOps(BatchUpdate bu) throws RestApiException {
    checkState(changeId != null, "must call setChangeId before addOps");
    try {
        RevWalk rw = rp.getRevWalk();
        rw.parseBody(commit);
        final PatchSet.Id psId = ins.setGroups(groups).getPatchSetId();
        Account.Id me = user.getAccountId();
        List<FooterLine> footerLines = commit.getFooterLines();
        MailRecipients recipients = new MailRecipients();
        Map<String, Short> approvals = new HashMap<>();
        checkNotNull(magicBranch);
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.labels;
        recipients.add(getRecipientsFromFooters(db, accountResolver, magicBranch.draft, footerLines));
        recipients.remove(me);
        StringBuilder msg = new StringBuilder(ApprovalsUtil.renderMessageWithApprovals(psId.get(), approvals, Collections.<String, PatchSetApproval>emptyMap()));
        msg.append('.');
        if (!Strings.isNullOrEmpty(magicBranch.message)) {
            msg.append("\n").append(magicBranch.message);
        }
        bu.insertChange(ins.setReviewers(recipients.getReviewers()).setExtraCC(recipients.getCcOnly()).setApprovals(approvals).setMessage(msg.toString()).setNotify(magicBranch.notify).setRequestScopePropagator(requestScopePropagator).setSendMail(true).setUpdateRef(true));
        if (!magicBranch.hashtags.isEmpty()) {
            bu.addOp(changeId, hashtagsFactory.create(new HashtagsInput(magicBranch.hashtags)).setFireEvent(false));
        }
        if (!Strings.isNullOrEmpty(magicBranch.topic)) {
            bu.addOp(changeId, new BatchUpdate.Op() {

                @Override
                public boolean updateChange(ChangeContext ctx) {
                    ctx.getUpdate(psId).setTopic(magicBranch.topic);
                    return true;
                }
            });
        }
        bu.addOp(changeId, new BatchUpdate.Op() {

            @Override
            public boolean updateChange(ChangeContext ctx) {
                change = ctx.getChange();
                return false;
            }
        });
        bu.addOp(changeId, new ChangeProgressOp(newProgress));
    } catch (Exception e) {
        throw INSERT_EXCEPTION.apply(e);
    }
}
#end_block

#method_before
private void submit(Collection<CreateRequest> create, Collection<ReplaceRequest> replace) throws OrmException, RestApiException {
    Map<ObjectId, Change> bySha = Maps.newHashMapWithExpectedSize(create.size() + replace.size());
    for (CreateRequest r : create) {
        checkNotNull(r.change, "cannot submit new change %s; op may not have run", r.changeId);
        bySha.put(r.commit, r.change);
    }
    for (ReplaceRequest r : replace) {
        bySha.put(r.newCommitId, r.notes.getChange());
    }
    Change tipChange = bySha.get(magicBranch.cmd.getNewId());
    checkNotNull(tipChange, "tip of push does not correspond to a change; found these changes: %s", bySha);
    try (MergeOp op = mergeOpProvider.get()) {
        op.merge(db, tipChange, user, false, new SubmitInput());
    }
}
#method_after
private void submit(Collection<CreateRequest> create, Collection<ReplaceRequest> replace) throws OrmException, RestApiException {
    Map<ObjectId, Change> bySha = Maps.newHashMapWithExpectedSize(create.size() + replace.size());
    for (CreateRequest r : create) {
        checkNotNull(r.change, "cannot submit new change %s; op may not have run", r.changeId);
        bySha.put(r.commit, r.change);
    }
    for (ReplaceRequest r : replace) {
        bySha.put(r.newCommitId, r.notes.getChange());
    }
    Change tipChange = bySha.get(magicBranch.cmd.getNewId());
    checkNotNull(tipChange, "tip of push does not correspond to a change; found these changes: %s", bySha);
    logDebug("Processing submit with tip change {} ({})", tipChange.getId(), magicBranch.cmd.getNewId());
    try (MergeOp op = mergeOpProvider.get()) {
        op.merge(db, tipChange, user, false, new SubmitInput());
    }
}
#end_block

#method_before
private void preparePatchSetsForReplace() {
    try {
        readChangesForReplace();
        for (Iterator<ReplaceRequest> itr = replaceByChange.values().iterator(); itr.hasNext(); ) {
            ReplaceRequest req = itr.next();
            if (req.inputCommand.getResult() == NOT_ATTEMPTED) {
                req.validate(false);
                if (req.skip && req.cmd == null) {
                    itr.remove();
                }
            }
        }
    } catch (OrmException err) {
        log.error(String.format("Cannot read database before replacement for project %s", project.getName()), err);
        for (ReplaceRequest req : replaceByChange.values()) {
            if (req.inputCommand.getResult() == NOT_ATTEMPTED) {
                req.inputCommand.setResult(REJECTED_OTHER_REASON, "internal server error");
            }
        }
    } catch (IOException err) {
        log.error(String.format("Cannot read repository before replacement for project %s", project.getName()), err);
        for (ReplaceRequest req : replaceByChange.values()) {
            if (req.inputCommand.getResult() == NOT_ATTEMPTED) {
                req.inputCommand.setResult(REJECTED_OTHER_REASON, "internal server error");
            }
        }
    }
    for (ReplaceRequest req : replaceByChange.values()) {
        if (req.inputCommand.getResult() == NOT_ATTEMPTED && req.cmd != null) {
            if (req.prev != null) {
                batch.addCommand(req.prev);
            }
            batch.addCommand(req.cmd);
        }
    }
    if (magicBranch != null && magicBranch.cmd.getResult() != NOT_ATTEMPTED) {
        // Cancel creations tied to refs/for/ or refs/drafts/ command.
        for (ReplaceRequest req : replaceByChange.values()) {
            if (req.inputCommand == magicBranch.cmd && req.cmd != null) {
                req.cmd.setResult(Result.REJECTED_OTHER_REASON, "aborted");
            }
        }
        for (CreateRequest req : newChanges) {
            req.cmd.setResult(Result.REJECTED_OTHER_REASON, "aborted");
        }
    }
}
#method_after
private void preparePatchSetsForReplace() {
    try {
        readChangesForReplace();
        for (Iterator<ReplaceRequest> itr = replaceByChange.values().iterator(); itr.hasNext(); ) {
            ReplaceRequest req = itr.next();
            if (req.inputCommand.getResult() == NOT_ATTEMPTED) {
                req.validate(false);
                if (req.skip && req.cmd == null) {
                    itr.remove();
                }
            }
        }
    } catch (OrmException err) {
        logError(String.format("Cannot read database before replacement for project %s", project.getName()), err);
        for (ReplaceRequest req : replaceByChange.values()) {
            if (req.inputCommand.getResult() == NOT_ATTEMPTED) {
                req.inputCommand.setResult(REJECTED_OTHER_REASON, "internal server error");
            }
        }
    } catch (IOException err) {
        logError(String.format("Cannot read repository before replacement for project %s", project.getName()), err);
        for (ReplaceRequest req : replaceByChange.values()) {
            if (req.inputCommand.getResult() == NOT_ATTEMPTED) {
                req.inputCommand.setResult(REJECTED_OTHER_REASON, "internal server error");
            }
        }
    }
    logDebug("Read {} changes to replace", replaceByChange.size());
    for (ReplaceRequest req : replaceByChange.values()) {
        if (req.inputCommand.getResult() == NOT_ATTEMPTED && req.cmd != null) {
            if (req.prev != null) {
                batch.addCommand(req.prev);
            }
            batch.addCommand(req.cmd);
        }
    }
    if (magicBranch != null && magicBranch.cmd.getResult() != NOT_ATTEMPTED) {
        // Cancel creations tied to refs/for/ or refs/drafts/ command.
        for (ReplaceRequest req : replaceByChange.values()) {
            if (req.inputCommand == magicBranch.cmd && req.cmd != null) {
                req.cmd.setResult(Result.REJECTED_OTHER_REASON, "aborted");
            }
        }
        for (CreateRequest req : newChanges) {
            req.cmd.setResult(Result.REJECTED_OTHER_REASON, "aborted");
        }
    }
}
#end_block

#method_before
private boolean newEdit() {
    psId = notes.getChange().currentPatchSetId();
    Optional<ChangeEdit> edit = null;
    try {
        edit = editUtil.byChange(changeCtl);
    } catch (AuthException | IOException e) {
        log.error("Cannot retrieve edit", e);
        return false;
    }
    if (edit.isPresent()) {
        if (edit.get().getBasePatchSet().getId().equals(psId)) {
            // replace edit
            cmd = new ReceiveCommand(edit.get().getRef().getObjectId(), newCommitId, edit.get().getRefName());
        } else {
            // delete old edit ref on rebase
            prev = new ReceiveCommand(edit.get().getRef().getObjectId(), ObjectId.zeroId(), edit.get().getRefName());
            createEditCommand();
        }
    } else {
        createEditCommand();
    }
    return true;
}
#method_after
private boolean newEdit() {
    psId = notes.getChange().currentPatchSetId();
    Optional<ChangeEdit> edit = null;
    try {
        edit = editUtil.byChange(changeCtl);
    } catch (AuthException | IOException e) {
        logError("Cannot retrieve edit", e);
        return false;
    }
    if (edit.isPresent()) {
        if (edit.get().getBasePatchSet().getId().equals(psId)) {
            // replace edit
            cmd = new ReceiveCommand(edit.get().getRef().getObjectId(), newCommitId, edit.get().getRefName());
        } else {
            // delete old edit ref on rebase
            prev = new ReceiveCommand(edit.get().getRef().getObjectId(), ObjectId.zeroId(), edit.get().getRefName());
            createEditCommand();
        }
    } else {
        createEditCommand();
    }
    return true;
}
#end_block

#method_before
void insertPatchSetWithoutBatchUpdate() throws IOException, UpdateException, RestApiException {
    try (BatchUpdate bu = batchUpdateFactory.create(db, projectControl.getProject().getNameKey(), user, TimeUtil.nowTs());
        ObjectInserter ins = repo.newObjectInserter()) {
        bu.setRepository(repo, rp.getRevWalk(), ins);
        addOps(bu, replaceProgress);
        bu.execute();
    }
}
#method_after
void insertPatchSetWithoutBatchUpdate() throws IOException, UpdateException, RestApiException {
    try (BatchUpdate bu = batchUpdateFactory.create(db, projectControl.getProject().getNameKey(), user, TimeUtil.nowTs());
        ObjectInserter ins = repo.newObjectInserter()) {
        bu.setRepository(repo, rp.getRevWalk(), ins);
        bu.setRequestId(receiveId);
        addOps(bu, replaceProgress);
        bu.execute();
    }
}
#end_block

#method_before
static boolean parentsEqual(RevCommit a, RevCommit b) {
    if (a.getParentCount() != b.getParentCount()) {
        return false;
    }
    for (int i = 0; i < a.getParentCount(); i++) {
        if (a.getParent(i) != b.getParent(i)) {
            return false;
        }
    }
    return true;
}
#method_after
static boolean parentsEqual(RevCommit a, RevCommit b) {
    if (a.getParentCount() != b.getParentCount()) {
        return false;
    }
    for (int i = 0; i < a.getParentCount(); i++) {
        if (!a.getParent(i).equals(b.getParent(i))) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    if (ctl.canForgeAuthor() && ctl.canForgeCommitter() && ctl.canForgeGerritServerIdentity() && ctl.canUploadMerges() && !projectControl.getProjectState().isUseSignedOffBy() && Iterables.isEmpty(rejectCommits) && !RefNames.REFS_CONFIG.equals(ctl.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        return;
    }
    boolean defaultName = Strings.isNullOrEmpty(user.getAccount().getFullName());
    RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        RevObject parsedObject = walk.parseAny(cmd.getNewId());
        if (!(parsedObject instanceof RevCommit)) {
            return;
        }
        SetMultimap<ObjectId, Ref> existing = changeRefsById();
        walk.markStart((RevCommit) parsedObject);
        markHeadsAsUninteresting(walk, cmd.getRefName());
        for (RevCommit c; (c = walk.next()) != null; ) {
            if (existing.keySet().contains(c)) {
                continue;
            } else if (!validCommit(walk, ctl, cmd, c)) {
                break;
            }
            if (defaultName && user.hasEmailAddress(c.getCommitterIdent().getEmailAddress())) {
                try {
                    Account a = db.accounts().get(user.getAccountId());
                    if (a != null && Strings.isNullOrEmpty(a.getFullName())) {
                        a.setFullName(c.getCommitterIdent().getName());
                        db.accounts().update(Collections.singleton(a));
                        user.getAccount().setFullName(a.getFullName());
                        accountCache.evict(a.getId());
                    }
                } catch (OrmException e) {
                    log.warn("Cannot default full_name", e);
                } finally {
                    defaultName = false;
                }
            }
        }
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#method_after
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    if (ctl.canForgeAuthor() && ctl.canForgeCommitter() && ctl.canForgeGerritServerIdentity() && ctl.canUploadMerges() && !projectControl.getProjectState().isUseSignedOffBy() && Iterables.isEmpty(rejectCommits) && !RefNames.REFS_CONFIG.equals(ctl.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        logDebug("Short-circuiting new commit validation");
        return;
    }
    boolean defaultName = Strings.isNullOrEmpty(user.getAccount().getFullName());
    RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        RevObject parsedObject = walk.parseAny(cmd.getNewId());
        if (!(parsedObject instanceof RevCommit)) {
            return;
        }
        SetMultimap<ObjectId, Ref> existing = changeRefsById();
        walk.markStart((RevCommit) parsedObject);
        markHeadsAsUninteresting(walk, cmd.getRefName());
        int i = 0;
        for (RevCommit c; (c = walk.next()) != null; ) {
            i++;
            if (existing.keySet().contains(c)) {
                continue;
            } else if (!validCommit(walk, ctl, cmd, c)) {
                break;
            }
            if (defaultName && user.hasEmailAddress(c.getCommitterIdent().getEmailAddress())) {
                try {
                    Account a = db.accounts().get(user.getAccountId());
                    if (a != null && Strings.isNullOrEmpty(a.getFullName())) {
                        a.setFullName(c.getCommitterIdent().getName());
                        db.accounts().update(Collections.singleton(a));
                        user.getAccount().setFullName(a.getFullName());
                        accountCache.evict(a.getId());
                    }
                } catch (OrmException e) {
                    logWarn("Cannot default full_name", e);
                } finally {
                    defaultName = false;
                }
            }
        }
        logDebug("Validated {} new commits", i);
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#end_block

#method_before
private boolean validCommit(RevWalk rw, RefControl ctl, ReceiveCommand cmd, ObjectId id) throws IOException {
    if (validCommits.contains(id)) {
        return true;
    }
    RevCommit c = rw.parseCommit(id);
    rw.parseBody(c);
    CommitReceivedEvent receiveEvent = new CommitReceivedEvent(cmd, project, ctl.getRefName(), c, user);
    CommitValidators commitValidators = commitValidatorsFactory.create(ctl, sshInfo, repo);
    try {
        messages.addAll(commitValidators.validateForReceiveCommits(receiveEvent, rejectCommits));
    } catch (CommitValidationException e) {
        messages.addAll(e.getMessages());
        reject(cmd, e.getMessage());
        return false;
    }
    validCommits.add(c.copy());
    return true;
}
#method_after
private boolean validCommit(RevWalk rw, RefControl ctl, ReceiveCommand cmd, ObjectId id) throws IOException {
    if (validCommits.contains(id)) {
        return true;
    }
    RevCommit c = rw.parseCommit(id);
    rw.parseBody(c);
    CommitReceivedEvent receiveEvent = new CommitReceivedEvent(cmd, project, ctl.getRefName(), c, user);
    CommitValidators commitValidators = commitValidatorsFactory.create(ctl, sshInfo, repo);
    try {
        messages.addAll(commitValidators.validateForReceiveCommits(receiveEvent, rejectCommits));
    } catch (CommitValidationException e) {
        logDebug("Commit validation failed on {}", c.name());
        messages.addAll(e.getMessages());
        reject(cmd, e.getMessage());
        return false;
    }
    validCommits.add(c.copy());
    return true;
}
#end_block

#method_before
private void autoCloseChanges(final ReceiveCommand cmd) {
    String refName = cmd.getRefName();
    checkState(!MagicBranch.isMagicBranch(refName), "shouldn't be auto-closing changes on magic branch %s", refName);
    RevWalk rw = rp.getRevWalk();
    // insertChangesAndPatchSets.
    try (BatchUpdate bu = batchUpdateFactory.create(db, projectControl.getProject().getNameKey(), user, TimeUtil.nowTs());
        ObjectInserter ins = repo.newObjectInserter()) {
        bu.setRepository(repo, rp.getRevWalk(), ins).updateChangesInParallel();
        // TODO(dborowitz): Teach BatchUpdate to ignore missing changes.
        RevCommit newTip = rw.parseCommit(cmd.getNewId());
        Branch.NameKey branch = new Branch.NameKey(project.getNameKey(), refName);
        rw.reset();
        rw.markStart(newTip);
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        SetMultimap<ObjectId, Ref> byCommit = changeRefsById();
        Map<Change.Key, ChangeNotes> byKey = null;
        List<ReplaceRequest> replaceAndClose = new ArrayList<>();
        COMMIT: for (RevCommit c; (c = rw.next()) != null; ) {
            rw.parseBody(c);
            for (Ref ref : byCommit.get(c.copy())) {
                PatchSet.Id psId = PatchSet.Id.fromRef(ref.getName());
                bu.addOp(psId.getParentKey(), mergedByPushOpFactory.create(requestScopePropagator, psId, refName));
                continue COMMIT;
            }
            for (String changeId : c.getFooterLines(CHANGE_ID)) {
                if (byKey == null) {
                    byKey = openChangesByBranch(branch);
                }
                ChangeNotes onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    // Hold onto this until we're done with the walk, as the call to
                    // req.validate below calls isMergedInto which resets the walk.
                    ReplaceRequest req = new ReplaceRequest(onto.getChangeId(), c, cmd, false);
                    req.notes = onto;
                    replaceAndClose.add(req);
                    continue COMMIT;
                }
            }
        }
        for (final ReplaceRequest req : replaceAndClose) {
            Change.Id id = req.notes.getChangeId();
            if (!req.validate(true)) {
                continue;
            }
            req.addOps(bu, null);
            bu.addOp(id, mergedByPushOpFactory.create(requestScopePropagator, req.psId, refName).setPatchSetProvider(new Provider<PatchSet>() {

                @Override
                public PatchSet get() {
                    return req.replaceOp.getPatchSet();
                }
            }));
            bu.addOp(id, new ChangeProgressOp(closeProgress));
        }
        bu.execute();
    } catch (RestApiException e) {
        log.error("Can't insert patchset", e);
    } catch (IOException | OrmException | UpdateException e) {
        log.error("Can't scan for changes to close", e);
    }
}
#method_after
private void autoCloseChanges(final ReceiveCommand cmd) {
    logDebug("Starting auto-closing of changes");
    String refName = cmd.getRefName();
    checkState(!MagicBranch.isMagicBranch(refName), "shouldn't be auto-closing changes on magic branch %s", refName);
    RevWalk rw = rp.getRevWalk();
    // insertChangesAndPatchSets.
    try (BatchUpdate bu = batchUpdateFactory.create(db, projectControl.getProject().getNameKey(), user, TimeUtil.nowTs());
        ObjectInserter ins = repo.newObjectInserter()) {
        bu.setRepository(repo, rp.getRevWalk(), ins).updateChangesInParallel();
        bu.setRequestId(receiveId);
        // TODO(dborowitz): Teach BatchUpdate to ignore missing changes.
        RevCommit newTip = rw.parseCommit(cmd.getNewId());
        Branch.NameKey branch = new Branch.NameKey(project.getNameKey(), refName);
        rw.reset();
        rw.markStart(newTip);
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        SetMultimap<ObjectId, Ref> byCommit = changeRefsById();
        Map<Change.Key, ChangeNotes> byKey = null;
        List<ReplaceRequest> replaceAndClose = new ArrayList<>();
        int existingPatchSets = 0;
        int newPatchSets = 0;
        COMMIT: for (RevCommit c; (c = rw.next()) != null; ) {
            rw.parseBody(c);
            for (Ref ref : byCommit.get(c.copy())) {
                existingPatchSets++;
                PatchSet.Id psId = PatchSet.Id.fromRef(ref.getName());
                bu.addOp(psId.getParentKey(), mergedByPushOpFactory.create(requestScopePropagator, psId, refName));
                continue COMMIT;
            }
            for (String changeId : c.getFooterLines(CHANGE_ID)) {
                if (byKey == null) {
                    byKey = openChangesByBranch(branch);
                }
                ChangeNotes onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    newPatchSets++;
                    // Hold onto this until we're done with the walk, as the call to
                    // req.validate below calls isMergedInto which resets the walk.
                    ReplaceRequest req = new ReplaceRequest(onto.getChangeId(), c, cmd, false);
                    req.notes = onto;
                    replaceAndClose.add(req);
                    continue COMMIT;
                }
            }
        }
        for (final ReplaceRequest req : replaceAndClose) {
            Change.Id id = req.notes.getChangeId();
            if (!req.validate(true)) {
                logDebug("Not closing {} because validation failed", id);
                continue;
            }
            req.addOps(bu, null);
            bu.addOp(id, mergedByPushOpFactory.create(requestScopePropagator, req.psId, refName).setPatchSetProvider(new Provider<PatchSet>() {

                @Override
                public PatchSet get() {
                    return req.replaceOp.getPatchSet();
                }
            }));
            bu.addOp(id, new ChangeProgressOp(closeProgress));
        }
        logDebug("Auto-closing {} changes with existing patch sets and {} with" + " new patch sets", existingPatchSets, newPatchSets);
        bu.execute();
    } catch (RestApiException e) {
        logError("Can't insert patchset", e);
    } catch (IOException | OrmException | UpdateException e) {
        logError("Can't scan for changes to close", e);
    }
}
#end_block

#method_before
@Override
public IncludedInInfo apply(ChangeResource rsrc) throws BadRequestException, ResourceConflictException, OrmException, IOException {
    ChangeControl ctl = rsrc.getControl();
    PatchSet ps = psUtil.current(db.get(), rsrc.getNotes());
    Project.NameKey project = ctl.getProject().getNameKey();
    try (Repository r = repoManager.openRepository(project);
        RevWalk rw = new RevWalk(r)) {
        rw.setRetainBody(false);
        RevCommit rev;
        try {
            rev = rw.parseCommit(ObjectId.fromString(ps.getRevision().get()));
        } catch (IncorrectObjectTypeException err) {
            throw new BadRequestException(err.getMessage());
        } catch (MissingObjectException err) {
            throw new ResourceConflictException(err.getMessage());
        }
        IncludedInResolver.Result d = IncludedInResolver.resolve(r, rw, rev);
        Map<String, Collection<String>> external = new HashMap<>();
        for (ExternalIncludedIn ext : includedIn) {
            Multimap<String, String> m = ext.getIncludedIn(project.get(), rev.name(), d.getTags(), d.getBranches());
            for (Map.Entry<String, Collection<String>> e : m.asMap().entrySet()) {
                external.put(e.getKey(), e.getValue());
            }
        }
        return new IncludedInInfo(d, (!external.isEmpty() ? external : null));
    }
}
#method_after
@Override
public IncludedInInfo apply(ChangeResource rsrc) throws BadRequestException, ResourceConflictException, OrmException, IOException {
    ChangeControl ctl = rsrc.getControl();
    PatchSet ps = psUtil.current(db.get(), rsrc.getNotes());
    Project.NameKey project = ctl.getProject().getNameKey();
    try (Repository r = repoManager.openRepository(project);
        RevWalk rw = new RevWalk(r)) {
        rw.setRetainBody(false);
        RevCommit rev;
        try {
            rev = rw.parseCommit(ObjectId.fromString(ps.getRevision().get()));
        } catch (IncorrectObjectTypeException err) {
            throw new BadRequestException(err.getMessage());
        } catch (MissingObjectException err) {
            throw new ResourceConflictException(err.getMessage());
        }
        IncludedInResolver.Result d = IncludedInResolver.resolve(r, rw, rev);
        Multimap<String, String> external = ArrayListMultimap.create();
        for (ExternalIncludedIn ext : includedIn) {
            external.putAll(ext.getIncludedIn(project.get(), rev.name(), d.getTags(), d.getBranches()));
        }
        return new IncludedInInfo(d, (!external.isEmpty() ? external.asMap() : null));
    }
}
#end_block

#method_before
@Override
protected LargeFileRepository getLargeFileRepository(LfsRequest request, String path) throws LfsException {
    String pathInfo = path.startsWith("/") ? path : "/" + path;
    Matcher matcher = URL_PATTERN.matcher(pathInfo);
    if (!matcher.matches()) {
        return null;
    }
    Project.NameKey project = Project.NameKey.parse(ProjectUtil.stripGitSuffix(matcher.group(1)));
    ProjectState state = projectCache.get(project);
    if (state == null || state.getProject().getState() == HIDDEN) {
        throw new LfsRepositoryNotFound(project.get());
    }
    if (request.getOperation().equals("upload") && state.getProject().getState() == READ_ONLY) {
        throw new LfsRepositoryReadOnly(project.get());
    }
    Config config = pluginConfigFactory.getProjectPluginConfigWithInheritance(state, pluginName);
    // Only accept requests for projects where LFS is enabled
    if (!config.getBoolean("lfs", "enabled", false)) {
        return null;
    }
    if (request.getOperation().equals("upload")) {
        // Check object sizes against limit, if configured
        long maxObjectSize = config.getLong("lfs", "maxObjectSize", 0);
        if (maxObjectSize > 0) {
            for (LfsObject object : request.getObjects()) {
                if (object.getSize() > maxObjectSize) {
                    throw new LfsValidationError("size of object " + object.getOid() + " exceeds limit");
                }
            }
        }
    }
    return getRepository();
}
#method_after
@Override
protected LargeFileRepository getLargeFileRepository(LfsRequest request, String path) throws LfsException {
    String pathInfo = path.startsWith("/") ? path : "/" + path;
    Matcher matcher = URL_PATTERN.matcher(pathInfo);
    if (!matcher.matches()) {
        return null;
    }
    Project.NameKey project = Project.NameKey.parse(ProjectUtil.stripGitSuffix(matcher.group(1)));
    ProjectState state = projectCache.get(project);
    if (state == null || state.getProject().getState() == HIDDEN) {
        throw new LfsRepositoryNotFound(project.get());
    }
    if (request.getOperation().equals("upload") && state.getProject().getState() == READ_ONLY) {
        throw new LfsRepositoryReadOnly(project.get());
    }
    Config config = pluginConfigFactory.getProjectPluginConfigWithInheritance(state, pluginName);
    // Only accept requests for projects where LFS is enabled
    if (!config.getBoolean("lfs", "enabled", false)) {
        return null;
    }
    if (request.getOperation().equals("upload")) {
        // Check object sizes against limit, if configured
        long maxObjectSize = config.getLong("lfs", "maxObjectSize", 0);
        if (maxObjectSize > 0) {
            for (LfsObject object : request.getObjects()) {
                if (object.getSize() > maxObjectSize) {
                    throw new LfsValidationError(String.format("size of object %s (%d bytes) exceeds limit (%d bytes)", object.getOid(), object.getSize(), maxObjectSize));
                }
            }
        }
    }
    return getRepository();
}
#end_block

#method_before
protected void setApiHeaders(HttpServletRequest req, HttpServletResponse res, String contentType) throws IOException {
    if (!Strings.isNullOrEmpty(contentType)) {
        res.setContentType(contentType);
    }
    res.setCharacterEncoding(UTF_8.name());
    res.setHeader(HttpHeaders.CONTENT_DISPOSITION, "attachment");
    GitilesAccess access = getAccess(req);
    String[] allowOrigin = access.getConfig().getStringList("gitiles", null, "allowOriginRegex");
    if (allowOrigin.length > 0) {
        String origin = req.getHeader(HttpHeaders.ORIGIN);
        Pattern allowOriginPattern = Pattern.compile(Joiner.on("|").skipNulls().join(allowOrigin));
        if (!(origin == null || origin.isEmpty()) && allowOriginPattern.matcher(origin).matches()) {
            res.setHeader(HttpHeaders.ACCESS_CONTROL_ALLOW_ORIGIN, origin);
        }
    } else {
        res.setHeader(HttpHeaders.ACCESS_CONTROL_ALLOW_ORIGIN, "*");
    }
    setCacheHeaders(res);
}
#method_after
protected void setApiHeaders(HttpServletRequest req, HttpServletResponse res, String contentType) throws IOException {
    if (!Strings.isNullOrEmpty(contentType)) {
        res.setContentType(contentType);
    }
    res.setCharacterEncoding(UTF_8.name());
    res.setHeader(HttpHeaders.CONTENT_DISPOSITION, "attachment");
    GitilesAccess access = getAccess(req);
    String[] allowOrigin = access.getConfig().getStringList("gitiles", null, "allowOriginRegex");
    if (allowOrigin.length > 0) {
        String origin = req.getHeader(HttpHeaders.ORIGIN);
        Pattern allowOriginPattern = Pattern.compile(Joiner.on("|").join(allowOrigin));
        if (!Strings.isNullOrEmpty(origin) && allowOriginPattern.matcher(origin).matches()) {
            res.setHeader(HttpHeaders.ACCESS_CONTROL_ALLOW_ORIGIN, origin);
        }
    } else {
        res.setHeader(HttpHeaders.ACCESS_CONTROL_ALLOW_ORIGIN, "*");
    }
    setCacheHeaders(res);
}
#end_block

#method_before
protected FakeHttpServletResponse buildResponse(String path, String queryString, int expectedStatus) throws Exception {
    FakeHttpServletRequest req = FakeHttpServletRequest.newRequest();
    req.setHeader(HttpHeaders.ORIGIN, "http://localhost");
    req.setPathInfo(path);
    if (queryString != null) {
        req.setQueryString(queryString);
    }
    FakeHttpServletResponse res = new FakeHttpServletResponse();
    servlet.service(req, res);
    assertThat(res.getStatus()).isEqualTo(expectedStatus);
    return res;
}
#method_after
protected FakeHttpServletResponse buildResponse(String path, String queryString, int expectedStatus, String origin) throws Exception {
    FakeHttpServletRequest req = FakeHttpServletRequest.newRequest();
    req.setHeader(HttpHeaders.ORIGIN, origin);
    req.setPathInfo(path);
    if (queryString != null) {
        req.setQueryString(queryString);
    }
    FakeHttpServletResponse res = new FakeHttpServletResponse();
    servlet.service(req, res);
    assertThat(res.getStatus()).isEqualTo(expectedStatus);
    return res;
}
#end_block

#method_before
protected FakeHttpServletResponse buildResponse(String path, String queryString, int expectedStatus) throws Exception {
    FakeHttpServletRequest req = FakeHttpServletRequest.newRequest();
    req.setHeader(HttpHeaders.ORIGIN, "http://localhost");
    req.setPathInfo(path);
    if (queryString != null) {
        req.setQueryString(queryString);
    }
    FakeHttpServletResponse res = new FakeHttpServletResponse();
    servlet.service(req, res);
    assertThat(res.getStatus()).isEqualTo(expectedStatus);
    return res;
}
#method_after
protected FakeHttpServletResponse buildResponse(String path, String queryString, int expectedStatus) throws Exception {
    return buildResponse(path, queryString, expectedStatus, "http://localhost");
}
#end_block

#method_before
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    bind(BlameCache.class).to(BlameCacheImpl.class);
    bind(Sequences.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(ChangeKindCacheImpl.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(MergeabilityCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(SubmitStrategy.module());
    install(TagCache.module());
    install(OAuthTokenCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new GitModule());
    install(new GroupModule());
    install(new NoteDbModule(cfg));
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(DeleteReviewerSender.Factory.class);
    factory(AddKeySender.Factory.class);
    factory(BatchUpdate.Factory.class);
    factory(CapabilityCollection.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeData.Factory.class);
    factory(ChangeJson.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupInfoCache.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(EmailMerge.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    factory(ProjectOwnerGroupsProvider.Factory.class);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(GcConfig.class);
    bind(ChangeCleanupConfig.class);
    bind(ApprovalsUtil.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class);
    bind(SoyTofu.class).toProvider(SoyTofuProvider.class);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(Boolean.class).annotatedWith(DisableReverseDnsLookup.class).toProvider(DisableReverseDnsLookupProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), ChangeAbandonedListener.class);
    DynamicSet.setOf(binder(), CommentAddedListener.class);
    DynamicSet.setOf(binder(), DraftPublishedListener.class);
    DynamicSet.setOf(binder(), HashtagsEditedListener.class);
    DynamicSet.setOf(binder(), ChangeMergedListener.class);
    DynamicSet.setOf(binder(), ChangeRestoredListener.class);
    DynamicSet.setOf(binder(), ChangeRevertedListener.class);
    DynamicSet.setOf(binder(), ReviewerAddedListener.class);
    DynamicSet.setOf(binder(), ReviewerDeletedListener.class);
    DynamicSet.setOf(binder(), VoteDeletedListener.class);
    DynamicSet.setOf(binder(), RevisionCreatedListener.class);
    DynamicSet.setOf(binder(), TopicEditedListener.class);
    DynamicSet.setOf(binder(), AgreementSignupListener.class);
    DynamicSet.setOf(binder(), PluginEventListener.class);
    DynamicSet.setOf(binder(), ReceivePackInitializer.class);
    DynamicSet.setOf(binder(), PostReceiveHook.class);
    DynamicSet.setOf(binder(), PreUploadHook.class);
    DynamicSet.setOf(binder(), PostUploadHook.class);
    DynamicSet.setOf(binder(), ChangeIndexedListener.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), GarbageCollectorListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.setOf(binder(), UsageDataPublishedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ReindexAfterUpdate.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ProjectConfigEntry.UpdateChecker.class);
    DynamicSet.setOf(binder(), EventListener.class);
    DynamicSet.bind(binder(), EventListener.class).to(EventsMetrics.class);
    DynamicSet.setOf(binder(), UserScopedEventListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), RefOperationValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicSet.setOf(binder(), ProjectCreationValidationListener.class);
    DynamicSet.setOf(binder(), GroupCreationValidationListener.class);
    DynamicSet.setOf(binder(), HashtagValidationListener.class);
    DynamicSet.setOf(binder(), OutgoingEmailValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), CloneCommand.class);
    DynamicSet.setOf(binder(), ExternalIncludedIn.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    DynamicSet.setOf(binder(), PatchSetWebLink.class);
    DynamicSet.setOf(binder(), FileWebLink.class);
    DynamicSet.setOf(binder(), FileHistoryWebLink.class);
    DynamicSet.setOf(binder(), DiffWebLink.class);
    DynamicSet.setOf(binder(), ProjectWebLink.class);
    DynamicSet.setOf(binder(), BranchWebLink.class);
    DynamicMap.mapOf(binder(), OAuthLoginProvider.class);
    DynamicItem.itemOf(binder(), OAuthTokenEncrypter.class);
    DynamicSet.setOf(binder(), AccountExternalIdCreator.class);
    DynamicSet.setOf(binder(), WebUiPlugin.class);
    DynamicItem.itemOf(binder(), AccountPatchReviewStore.class);
    factory(UploadValidators.Factory.class);
    DynamicSet.setOf(binder(), UploadValidationListener.class);
    DynamicMap.mapOf(binder(), ChangeQueryBuilder.ChangeOperatorFactory.class);
    install(new GitwebConfig.LegacyModule(cfg));
    bind(AnonymousUser.class);
    factory(CommitValidators.Factory.class);
    factory(RefOperationValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    factory(ReplaceOp.Factory.class);
    factory(MergedByPushOp.Factory.class);
    factory(GitModules.Factory.class);
    factory(VersionedAuthorizedKeys.Factory.class);
    factory(SubmoduleOp.Factory.class);
    bind(AccountManager.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#method_after
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    bind(BlameCache.class).to(BlameCacheImpl.class);
    bind(Sequences.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(ChangeKindCacheImpl.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(MergeabilityCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(SubmitStrategy.module());
    install(TagCache.module());
    install(OAuthTokenCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new GitModule());
    install(new GroupModule());
    install(new NoteDbModule(cfg));
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(DeleteReviewerSender.Factory.class);
    factory(AddKeySender.Factory.class);
    factory(BatchUpdate.Factory.class);
    factory(CapabilityCollection.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeData.Factory.class);
    factory(ChangeJson.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupInfoCache.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(EmailMerge.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    factory(ProjectOwnerGroupsProvider.Factory.class);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(GcConfig.class);
    bind(ChangeCleanupConfig.class);
    bind(ApprovalsUtil.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class);
    bind(SoyTofu.class).annotatedWith(MailTemplates.class).toProvider(MailSoyTofuProvider.class);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(Boolean.class).annotatedWith(DisableReverseDnsLookup.class).toProvider(DisableReverseDnsLookupProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), ChangeAbandonedListener.class);
    DynamicSet.setOf(binder(), CommentAddedListener.class);
    DynamicSet.setOf(binder(), DraftPublishedListener.class);
    DynamicSet.setOf(binder(), HashtagsEditedListener.class);
    DynamicSet.setOf(binder(), ChangeMergedListener.class);
    DynamicSet.setOf(binder(), ChangeRestoredListener.class);
    DynamicSet.setOf(binder(), ChangeRevertedListener.class);
    DynamicSet.setOf(binder(), ReviewerAddedListener.class);
    DynamicSet.setOf(binder(), ReviewerDeletedListener.class);
    DynamicSet.setOf(binder(), VoteDeletedListener.class);
    DynamicSet.setOf(binder(), RevisionCreatedListener.class);
    DynamicSet.setOf(binder(), TopicEditedListener.class);
    DynamicSet.setOf(binder(), AgreementSignupListener.class);
    DynamicSet.setOf(binder(), PluginEventListener.class);
    DynamicSet.setOf(binder(), ReceivePackInitializer.class);
    DynamicSet.setOf(binder(), PostReceiveHook.class);
    DynamicSet.setOf(binder(), PreUploadHook.class);
    DynamicSet.setOf(binder(), PostUploadHook.class);
    DynamicSet.setOf(binder(), ChangeIndexedListener.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), GarbageCollectorListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.setOf(binder(), UsageDataPublishedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ReindexAfterUpdate.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ProjectConfigEntry.UpdateChecker.class);
    DynamicSet.setOf(binder(), EventListener.class);
    DynamicSet.bind(binder(), EventListener.class).to(EventsMetrics.class);
    DynamicSet.setOf(binder(), UserScopedEventListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), RefOperationValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicSet.setOf(binder(), ProjectCreationValidationListener.class);
    DynamicSet.setOf(binder(), GroupCreationValidationListener.class);
    DynamicSet.setOf(binder(), HashtagValidationListener.class);
    DynamicSet.setOf(binder(), OutgoingEmailValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), CloneCommand.class);
    DynamicSet.setOf(binder(), ExternalIncludedIn.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    DynamicSet.setOf(binder(), PatchSetWebLink.class);
    DynamicSet.setOf(binder(), FileWebLink.class);
    DynamicSet.setOf(binder(), FileHistoryWebLink.class);
    DynamicSet.setOf(binder(), DiffWebLink.class);
    DynamicSet.setOf(binder(), ProjectWebLink.class);
    DynamicSet.setOf(binder(), BranchWebLink.class);
    DynamicMap.mapOf(binder(), OAuthLoginProvider.class);
    DynamicItem.itemOf(binder(), OAuthTokenEncrypter.class);
    DynamicSet.setOf(binder(), AccountExternalIdCreator.class);
    DynamicSet.setOf(binder(), WebUiPlugin.class);
    DynamicItem.itemOf(binder(), AccountPatchReviewStore.class);
    factory(UploadValidators.Factory.class);
    DynamicSet.setOf(binder(), UploadValidationListener.class);
    DynamicMap.mapOf(binder(), ChangeQueryBuilder.ChangeOperatorFactory.class);
    install(new GitwebConfig.LegacyModule(cfg));
    bind(AnonymousUser.class);
    factory(CommitValidators.Factory.class);
    factory(RefOperationValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    factory(ReplaceOp.Factory.class);
    factory(MergedByPushOp.Factory.class);
    factory(GitModules.Factory.class);
    factory(VersionedAuthorizedKeys.Factory.class);
    factory(SubmoduleOp.Factory.class);
    bind(AccountManager.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    AccountApi.getAgreements("self", new GerritCallback<JsArray<AgreementInfo>>() {

        @Override
        public void onSuccess(JsArray<AgreementInfo> result) {
            mySigned = new HashSet<>();
            for (AgreementInfo info : Natives.asList(result)) {
                mySigned.add(info.name());
            }
            postRPC();
        }
    });
    Gerrit.SYSTEM_SVC.contributorAgreements(new GerritCallback<List<ContributorAgreement>>() {

        @Override
        public void onSuccess(final List<ContributorAgreement> result) {
            if (isAttached()) {
                available = result;
                postRPC();
            }
        }
    });
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    AccountApi.getAgreements("self", new GerritCallback<JsArray<AgreementInfo>>() {

        @Override
        public void onSuccess(JsArray<AgreementInfo> result) {
            if (isAttached()) {
                mySigned = new HashSet<>();
                for (AgreementInfo info : Natives.asList(result)) {
                    mySigned.add(info.name());
                }
                postRPC();
            }
        }
    });
    Gerrit.SYSTEM_SVC.contributorAgreements(new GerritCallback<List<ContributorAgreement>>() {

        @Override
        public void onSuccess(final List<ContributorAgreement> result) {
            if (isAttached()) {
                available = result;
                postRPC();
            }
        }
    });
}
#end_block

#method_before
@Override
public BranchInfo apply(ProjectResource rsrc, Input input) throws BadRequestException, AuthException, ResourceConflictException, IOException {
    if (input == null) {
        input = new Input();
    }
    if (input.ref != null && !ref.equals(input.ref)) {
        throw new BadRequestException("ref must match URL");
    }
    if (input.revision == null) {
        input.revision = Constants.HEAD;
    }
    while (ref.startsWith("/")) {
        ref = ref.substring(1);
    }
    if (!ref.startsWith(Constants.R_REFS)) {
        ref = Constants.R_HEADS + ref;
    }
    if (!Repository.isValidRefName(ref)) {
        throw new BadRequestException("invalid branch name \"" + ref + "\"");
    }
    if (MagicBranch.isMagicBranch(ref)) {
        throw new BadRequestException("not allowed to create branches under \"" + MagicBranch.getMagicRefNamePrefix(ref) + "\"");
    }
    final Branch.NameKey name = new Branch.NameKey(rsrc.getNameKey(), ref);
    final RefControl refControl = rsrc.getControl().controlForRef(name);
    final Repository repo = repoManager.openRepository(rsrc.getNameKey());
    try {
        final ObjectId revid = parseBaseRevision(repo, rsrc.getNameKey(), input.revision);
        final RevWalk rw = verifyConnected(repo, revid);
        RevObject object = rw.parseAny(revid);
        if (ref.startsWith(Constants.R_HEADS)) {
            // 
            try {
                object = rw.parseCommit(object);
            } catch (IncorrectObjectTypeException notCommit) {
                throw new BadRequestException("\"" + input.revision + "\" not a commit");
            }
        }
        rw.reset();
        if (!refControl.canCreate(db.get(), rw, object)) {
            throw new AuthException("Cannot create \"" + ref + "\"");
        }
        try {
            final RefUpdate u = repo.updateRef(ref);
            u.setExpectedOldObjectId(ObjectId.zeroId());
            u.setNewObjectId(object.copy());
            u.setRefLogIdent(identifiedUser.get().newRefLogIdent());
            u.setRefLogMessage("created via REST from " + input.revision, false);
            Optional<String> notValid = validateRefCreation(rsrc, u);
            if (notValid.isPresent()) {
                throw new ResourceConflictException(notValid.get());
            }
            final RefUpdate.Result result = u.update(rw);
            switch(result) {
                case FAST_FORWARD:
                case NEW:
                case NO_CHANGE:
                    referenceUpdated.fire(name.getParentKey(), u);
                    hooks.doRefUpdatedHook(name, u, identifiedUser.get().getAccount());
                    break;
                case LOCK_FAILURE:
                    if (repo.getRef(ref) != null) {
                        throw new ResourceConflictException("branch \"" + ref + "\" already exists");
                    }
                    String refPrefix = getRefPrefix(ref);
                    while (!Constants.R_HEADS.equals(refPrefix)) {
                        if (repo.getRef(refPrefix) != null) {
                            throw new ResourceConflictException("Cannot create branch \"" + ref + "\" since it conflicts with branch \"" + refPrefix + "\".");
                        }
                        refPrefix = getRefPrefix(refPrefix);
                    }
                default:
                    {
                        throw new IOException(result.name());
                    }
            }
            return new BranchInfo(ref, revid.getName(), refControl.canDelete());
        } catch (IOException err) {
            log.error("Cannot create branch \"" + name + "\"", err);
            throw err;
        }
    } catch (InvalidRevisionException e) {
        throw new BadRequestException("invalid revision \"" + input.revision + "\"");
    } finally {
        repo.close();
    }
}
#method_after
@Override
public BranchInfo apply(ProjectResource rsrc, BranchInput input) throws BadRequestException, AuthException, ResourceConflictException, IOException {
    if (input == null) {
        input = new BranchInput();
    }
    if (input.ref != null && !ref.equals(input.ref)) {
        throw new BadRequestException("ref must match URL");
    }
    if (input.revision == null) {
        input.revision = Constants.HEAD;
    }
    while (ref.startsWith("/")) {
        ref = ref.substring(1);
    }
    ref = RefNames.fullName(ref);
    if (!Repository.isValidRefName(ref)) {
        throw new BadRequestException("invalid branch name \"" + ref + "\"");
    }
    if (MagicBranch.isMagicBranch(ref)) {
        throw new BadRequestException("not allowed to create branches under \"" + MagicBranch.getMagicRefNamePrefix(ref) + "\"");
    }
    final Branch.NameKey name = new Branch.NameKey(rsrc.getNameKey(), ref);
    final RefControl refControl = rsrc.getControl().controlForRef(name);
    try (Repository repo = repoManager.openRepository(rsrc.getNameKey())) {
        ObjectId revid = RefUtil.parseBaseRevision(repo, rsrc.getNameKey(), input.revision);
        RevWalk rw = RefUtil.verifyConnected(repo, revid);
        RevObject object = rw.parseAny(revid);
        if (ref.startsWith(Constants.R_HEADS)) {
            // 
            try {
                object = rw.parseCommit(object);
            } catch (IncorrectObjectTypeException notCommit) {
                throw new BadRequestException("\"" + input.revision + "\" not a commit");
            }
        }
        if (!refControl.canCreate(db.get(), repo, object)) {
            throw new AuthException("Cannot create \"" + ref + "\"");
        }
        try {
            final RefUpdate u = repo.updateRef(ref);
            u.setExpectedOldObjectId(ObjectId.zeroId());
            u.setNewObjectId(object.copy());
            u.setRefLogIdent(identifiedUser.get().newRefLogIdent());
            u.setRefLogMessage("created via REST from " + input.revision, false);
            refCreationValidator.validateRefOperation(rsrc.getName(), identifiedUser.get(), u);
            final RefUpdate.Result result = u.update(rw);
            switch(result) {
                case FAST_FORWARD:
                case NEW:
                case NO_CHANGE:
                    referenceUpdated.fire(name.getParentKey(), u, ReceiveCommand.Type.CREATE, identifiedUser.get().getAccount());
                    break;
                case LOCK_FAILURE:
                    if (repo.getRefDatabase().exactRef(ref) != null) {
                        throw new ResourceConflictException("branch \"" + ref + "\" already exists");
                    }
                    String refPrefix = RefUtil.getRefPrefix(ref);
                    while (!Constants.R_HEADS.equals(refPrefix)) {
                        if (repo.getRefDatabase().exactRef(refPrefix) != null) {
                            throw new ResourceConflictException("Cannot create branch \"" + ref + "\" since it conflicts with branch \"" + refPrefix + "\".");
                        }
                        refPrefix = RefUtil.getRefPrefix(refPrefix);
                    }
                // $FALL-THROUGH$
                case FORCED:
                case IO_FAILURE:
                case NOT_ATTEMPTED:
                case REJECTED:
                case REJECTED_CURRENT_BRANCH:
                case RENAMED:
                default:
                    {
                        throw new IOException(result.name());
                    }
            }
            BranchInfo info = new BranchInfo();
            info.ref = ref;
            info.revision = revid.getName();
            info.canDelete = refControl.canDelete() ? true : null;
            return info;
        } catch (IOException err) {
            log.error("Cannot create branch \"" + name + "\"", err);
            throw err;
        }
    } catch (RefUtil.InvalidRevisionException e) {
        throw new BadRequestException("invalid revision \"" + input.revision + "\"");
    }
}
#end_block

#method_before
@Override
public Response<?> apply(BranchResource rsrc, Input input) throws AuthException, ResourceConflictException, OrmException, IOException {
    if (!rsrc.getControl().controlForRef(rsrc.getBranchKey()).canDelete()) {
        throw new AuthException("Cannot delete branch");
    }
    if (dbProvider.get().changes().byBranchOpenAll(rsrc.getBranchKey()).iterator().hasNext()) {
        throw new ResourceConflictException("branch " + rsrc.getBranchKey() + " has open changes");
    }
    Repository r = repoManager.openRepository(rsrc.getNameKey());
    try {
        RefUpdate.Result result;
        RefUpdate u;
        try {
            u = r.updateRef(rsrc.getRef());
            u.setForceUpdate(true);
            Optional<String> notValid = validateRefDeletion(rsrc, u);
            if (notValid.isPresent()) {
                throw new ResourceConflictException(notValid.get());
            }
            result = u.delete();
        } catch (IOException e) {
            log.error("Cannot delete " + rsrc.getBranchKey(), e);
            throw e;
        }
        switch(result) {
            case NEW:
            case NO_CHANGE:
            case FAST_FORWARD:
            case FORCED:
                referenceUpdated.fire(rsrc.getNameKey(), u);
                hooks.doRefUpdatedHook(rsrc.getBranchKey(), u, identifiedUser.get().getAccount());
                break;
            case REJECTED_CURRENT_BRANCH:
                log.warn("Cannot delete " + rsrc.getBranchKey() + ": " + result.name());
                throw new ResourceConflictException("cannot delete current branch");
            default:
                log.error("Cannot delete " + rsrc.getBranchKey() + ": " + result.name());
                throw new ResourceConflictException("cannot delete branch: " + result.name());
        }
    } finally {
        r.close();
    }
    return Response.none();
}
#method_after
@Override
public Response<?> apply(BranchResource rsrc, Input input) throws AuthException, ResourceConflictException, OrmException, IOException {
    if (!rsrc.getControl().controlForRef(rsrc.getBranchKey()).canDelete()) {
        throw new AuthException("Cannot delete branch");
    }
    if (!queryProvider.get().setLimit(1).byBranchOpen(rsrc.getBranchKey()).isEmpty()) {
        throw new ResourceConflictException("branch " + rsrc.getBranchKey() + " has open changes");
    }
    try (Repository r = repoManager.openRepository(rsrc.getNameKey())) {
        RefUpdate.Result result;
        RefUpdate u = r.updateRef(rsrc.getRef());
        u.setForceUpdate(true);
        refDeletionValidator.validateRefOperation(rsrc.getName(), identifiedUser.get(), u);
        int remainingLockFailureCalls = MAX_LOCK_FAILURE_CALLS;
        for (; ; ) {
            try {
                result = u.delete();
            } catch (LockFailedException e) {
                result = RefUpdate.Result.LOCK_FAILURE;
            } catch (IOException e) {
                log.error("Cannot delete " + rsrc.getBranchKey(), e);
                throw e;
            }
            if (result == RefUpdate.Result.LOCK_FAILURE && --remainingLockFailureCalls > 0) {
                try {
                    Thread.sleep(SLEEP_ON_LOCK_FAILURE_MS);
                } catch (InterruptedException ie) {
                // ignore
                }
            } else {
                break;
            }
        }
        switch(result) {
            case NEW:
            case NO_CHANGE:
            case FAST_FORWARD:
            case FORCED:
                referenceUpdated.fire(rsrc.getNameKey(), u, ReceiveCommand.Type.DELETE, identifiedUser.get().getAccount());
                break;
            case REJECTED_CURRENT_BRANCH:
                log.error("Cannot delete " + rsrc.getBranchKey() + ": " + result.name());
                throw new ResourceConflictException("cannot delete current branch");
            case IO_FAILURE:
            case LOCK_FAILURE:
            case NOT_ATTEMPTED:
            case REJECTED:
            case RENAMED:
            default:
                log.error("Cannot delete " + rsrc.getBranchKey() + ": " + result.name());
                throw new ResourceConflictException("cannot delete branch: " + result.name());
        }
    }
    return Response.none();
}
#end_block

#method_before
public void setMessageSender(final MessageSender ms) {
    messageSender = ms != null ? ms : new ReceivePackMessageSender();
}
#method_after
public void setMessageSender(MessageSender ms) {
    messageSender = ms != null ? ms : new ReceivePackMessageSender();
}
#end_block

#method_before
void processCommands(final Collection<ReceiveCommand> commands, final MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    batch = repo.getRefDatabase().newBatchUpdate();
    batch.setRefLogIdent(rp.getRefLogIdent());
    batch.setRefLogMessage("push", true);
    parseCommands(commands);
    if (magicBranch != null && magicBranch.cmd.getResult() == NOT_ATTEMPTED) {
        newChanges = selectNewChanges();
    }
    preparePatchSetsForReplace();
    if (!batch.getCommands().isEmpty()) {
        try {
            batch.execute(rp.getRevWalk(), commandProgress);
        } catch (IOException err) {
            int cnt = 0;
            for (ReceiveCommand cmd : batch.getCommands()) {
                if (cmd.getResult() == NOT_ATTEMPTED) {
                    cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
                    cnt++;
                }
            }
            log.error(String.format("Failed to store %d refs in %s", cnt, project.getName()), err);
        }
    }
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(currentUser)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == OK) {
            try {
                switch(c.getType()) {
                    case CREATE:
                        if (isHead(c) || isConfig(c)) {
                            autoCloseChanges(c);
                        }
                        break;
                    case // otherwise known as a fast-forward
                    UPDATE:
                        tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                        if (isHead(c) || isConfig(c)) {
                            autoCloseChanges(c);
                        }
                        break;
                    case UPDATE_NONFASTFORWARD:
                        if (isHead(c) || isConfig(c)) {
                            autoCloseChanges(c);
                        }
                        break;
                    case DELETE:
                        break;
                }
                if (isConfig(c)) {
                    projectCache.evict(project);
                    ProjectState ps = projectCache.get(project.getNameKey());
                    // 
                    repoManager.setProjectDescription(// 
                    project.getNameKey(), ps.getProject().getDescription());
                }
                if (!MagicBranch.isMagicBranch(c.getRefName())) {
                    // We only fire gitRefUpdated for direct refs updates.
                    // Events for change refs are fired when they are created.
                    // 
                    gitRefUpdated.fire(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                    hooks.doRefUpdatedHook(new Branch.NameKey(project.getNameKey(), c.getRefName()), c.getOldId(), c.getNewId(), currentUser.getAccount());
                }
            } catch (NoSuchChangeException e) {
                c.setResult(REJECTED_OTHER_REASON, "No such change: " + e.getMessage());
            }
        }
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    reportMessages();
}
#method_after
void processCommands(Collection<ReceiveCommand> commands, MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    batch = repo.getRefDatabase().newBatchUpdate();
    batch.setPushCertificate(rp.getPushCertificate());
    batch.setRefLogIdent(rp.getRefLogIdent());
    batch.setRefLogMessage("push", true);
    parseCommands(commands);
    if (magicBranch != null && magicBranch.cmd.getResult() == NOT_ATTEMPTED) {
        selectNewAndReplacedChangesFromMagicBranch();
    }
    preparePatchSetsForReplace();
    logDebug("Executing batch with {} commands", batch.getCommands().size());
    if (!batch.getCommands().isEmpty()) {
        try {
            if (!batch.isAllowNonFastForwards() && magicBranch != null && magicBranch.edit) {
                logDebug("Allowing non-fast-forward for edit ref");
                batch.setAllowNonFastForwards(true);
            }
            batch.execute(rp.getRevWalk(), commandProgress);
        } catch (IOException err) {
            int cnt = 0;
            for (ReceiveCommand cmd : batch.getCommands()) {
                if (cmd.getResult() == NOT_ATTEMPTED) {
                    cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
                    cnt++;
                }
            }
            logError(String.format("Failed to store %d refs in %s", cnt, project.getName()), err);
        }
    }
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        logDebug("Handling error conditions: {}", errors.keySet());
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(user)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    Set<Branch.NameKey> branches = new HashSet<>();
    for (ReceiveCommand c : batch.getCommands()) {
        if (c.getResult() == OK) {
            String refName = c.getRefName();
            if (c.getType() == ReceiveCommand.Type.UPDATE) {
                // aka fast-forward
                logDebug("Updating tag cache on fast-forward of {}", c.getRefName());
                tagCache.updateFastForward(project.getNameKey(), refName, c.getOldId(), c.getNewId());
            }
            if (isHead(c) || isConfig(c)) {
                switch(c.getType()) {
                    case CREATE:
                    case UPDATE:
                    case UPDATE_NONFASTFORWARD:
                        autoCloseChanges(c);
                        branches.add(new Branch.NameKey(project.getNameKey(), refName));
                        break;
                    case DELETE:
                        break;
                }
            }
            if (isConfig(c)) {
                logDebug("Reloading project in cache");
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(refName) && !refName.startsWith(REFS_CHANGES)) {
                logDebug("Firing ref update for {}", c.getRefName());
                // We only fire gitRefUpdated for direct refs updates.
                // Events for change refs are fired when they are created.
                // 
                gitRefUpdated.fire(project.getNameKey(), c, user.getAccount());
            } else {
                logDebug("Assuming ref update event for {} has fired", c.getRefName());
            }
        }
    }
    // Update superproject gitlinks if required.
    try (MergeOpRepoManager orm = ormProvider.get()) {
        orm.setContext(db, TimeUtil.nowTs(), user, receiveId);
        SubmoduleOp op = subOpFactory.create(branches, orm);
        op.updateSuperProjects();
    } catch (SubmoduleException e) {
        logError("Can't update the superprojects", e);
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    reportMessages();
}
#end_block

#method_before
private void reportMessages() {
    Iterable<CreateRequest> created = Iterables.filter(newChanges, new Predicate<CreateRequest>() {

        @Override
        public boolean apply(CreateRequest input) {
            return input.created;
        }
    });
    if (!Iterables.isEmpty(created)) {
        addMessage("");
        addMessage("New Changes:");
        for (CreateRequest c : created) {
            addMessage(formatChangeUrl(canonicalWebUrl, c.change));
        }
        addMessage("");
    }
    List<ReplaceRequest> updated = FluentIterable.from(replaceByChange.values()).filter(new Predicate<ReplaceRequest>() {

        @Override
        public boolean apply(ReplaceRequest input) {
            return !input.skip && input.inputCommand.getResult() == OK;
        }
    }).toSortedList(Ordering.natural().onResultOf(new Function<ReplaceRequest, Integer>() {

        @Override
        public Integer apply(ReplaceRequest in) {
            return in.change.getId().get();
        }
    }));
    if (!updated.isEmpty()) {
        addMessage("");
        addMessage("Updated Changes:");
        for (ReplaceRequest u : updated) {
            addMessage(formatChangeUrl(canonicalWebUrl, u.change));
        }
        addMessage("");
    }
}
#method_after
private void reportMessages() {
    Iterable<CreateRequest> created = Iterables.filter(newChanges, new Predicate<CreateRequest>() {

        @Override
        public boolean apply(CreateRequest input) {
            return input.change != null;
        }
    });
    if (!Iterables.isEmpty(created)) {
        addMessage("");
        addMessage("New Changes:");
        for (CreateRequest c : created) {
            addMessage(formatChangeUrl(canonicalWebUrl, c.change, c.change.getSubject(), c.change.getStatus() == Change.Status.DRAFT, false));
        }
        addMessage("");
    }
    List<ReplaceRequest> updated = FluentIterable.from(replaceByChange.values()).filter(new Predicate<ReplaceRequest>() {

        @Override
        public boolean apply(ReplaceRequest input) {
            return !input.skip && input.inputCommand.getResult() == OK;
        }
    }).toSortedList(Ordering.natural().onResultOf(new Function<ReplaceRequest, Integer>() {

        @Override
        public Integer apply(ReplaceRequest in) {
            return in.notes.getChangeId().get();
        }
    }));
    if (!updated.isEmpty()) {
        addMessage("");
        addMessage("Updated Changes:");
        boolean edit = magicBranch != null && magicBranch.edit;
        for (ReplaceRequest u : updated) {
            String subject;
            if (edit) {
                try {
                    subject = rp.getRevWalk().parseCommit(u.newCommitId).getShortMessage();
                } catch (IOException e) {
                    // Log and fall back to original change subject
                    logWarn("failed to get subject for edit patch set", e);
                    subject = u.notes.getChange().getSubject();
                }
            } else {
                subject = u.info.getSubject();
            }
            addMessage(formatChangeUrl(canonicalWebUrl, u.notes.getChange(), subject, u.replaceOp != null && u.replaceOp.getPatchSet().isDraft(), edit));
        }
        addMessage("");
    }
}
#end_block

#method_before
private static String formatChangeUrl(String url, Change change) {
    StringBuilder m = new StringBuilder().append("  ").append(url).append(change.getChangeId()).append(" ").append(ChangeUtil.cropSubject(change.getSubject()));
    if (change.getStatus() == Change.Status.DRAFT) {
        m.append(" [DRAFT]");
    }
    return m.toString();
}
#method_after
private static String formatChangeUrl(String url, Change change, String subject, boolean draft, boolean edit) {
    StringBuilder m = new StringBuilder().append("  ").append(url).append(change.getChangeId()).append(" ").append(ChangeUtil.cropSubject(subject));
    if (draft) {
        m.append(" [DRAFT]");
    }
    if (edit) {
        m.append(" [EDIT]");
    }
    return m.toString();
}
#end_block

#method_before
private void insertChangesAndPatchSets() {
    int replaceCount = 0;
    int okToInsert = 0;
    for (Map.Entry<Change.Id, ReplaceRequest> e : replaceByChange.entrySet()) {
        ReplaceRequest replace = e.getValue();
        if (magicBranch != null && replace.inputCommand == magicBranch.cmd) {
            replaceCount++;
            if (replace.cmd != null && replace.cmd.getResult() == OK) {
                okToInsert++;
            }
        } else if (replace.cmd != null && replace.cmd.getResult() == OK) {
            try {
                if (replace.insertPatchSet().checkedGet() != null) {
                    replace.inputCommand.setResult(OK);
                }
            } catch (IOException err) {
                reject(replace.inputCommand, "internal server error");
                log.error(String.format("Cannot add patch set to %d of %s", e.getKey().get(), project.getName()), err);
            } catch (InsertException err) {
                reject(replace.inputCommand, "internal server error");
                log.error(String.format("Cannot add patch set to %d of %s", e.getKey().get(), project.getName()), err);
            }
        } else if (replace.inputCommand.getResult() == NOT_ATTEMPTED) {
            reject(replace.inputCommand, "internal server error");
            log.error(String.format("Replacement for project %s was not attempted", project.getName()));
        }
    }
    if (magicBranch == null || magicBranch.cmd.getResult() != NOT_ATTEMPTED) {
        // No need to continue.
        return;
    }
    List<String> lastCreateChangeErrors = Lists.newArrayList();
    for (CreateRequest create : newChanges) {
        if (create.cmd.getResult() == OK) {
            okToInsert++;
        } else {
            String createChangeResult = String.format("%s %s", create.cmd.getResult(), Strings.nullToEmpty(create.cmd.getMessage())).trim();
            lastCreateChangeErrors.add(createChangeResult);
            log.error(String.format("Command %s on %s:%s not completed: %s", create.cmd.getType(), project.getName(), create.cmd.getRefName(), createChangeResult));
        }
    }
    if (okToInsert != replaceCount + newChanges.size()) {
        // One or more new references failed to create. Assume the
        // system isn't working correctly anymore and abort.
        reject(magicBranch.cmd, "Unable to create changes: " + Joiner.on(' ').join(lastCreateChangeErrors));
        log.error(String.format("Only %d of %d new change refs created in %s; aborting", okToInsert, replaceCount + newChanges.size(), project.getName()));
        return;
    }
    try {
        List<CheckedFuture<?, InsertException>> futures = Lists.newArrayList();
        for (ReplaceRequest replace : replaceByChange.values()) {
            if (magicBranch != null && replace.inputCommand == magicBranch.cmd) {
                futures.add(replace.insertPatchSet());
            }
        }
        for (CreateRequest create : newChanges) {
            futures.add(create.insertChange());
        }
        for (CheckedFuture<?, InsertException> f : futures) {
            f.checkedGet();
        }
        magicBranch.cmd.setResult(OK);
    } catch (InsertException err) {
        log.error("Can't insert change/patchset for " + project.getName(), err);
        reject(magicBranch.cmd, "internal server error");
    } catch (IOException err) {
        log.error("Can't read commits for " + project.getName(), err);
        reject(magicBranch.cmd, "internal server error");
    }
}
#method_after
private void insertChangesAndPatchSets() {
    int replaceCount = 0;
    int okToInsert = 0;
    for (Map.Entry<Change.Id, ReplaceRequest> e : replaceByChange.entrySet()) {
        ReplaceRequest replace = e.getValue();
        if (magicBranch != null && replace.inputCommand == magicBranch.cmd) {
            replaceCount++;
            if (replace.cmd != null && replace.cmd.getResult() == OK) {
                okToInsert++;
            }
        } else if (replace.cmd != null && replace.cmd.getResult() == OK) {
            String refName = replace.inputCommand.getRefName();
            checkState(NEW_PATCHSET.matcher(refName).matches(), "expected a new patch set command as input when creating %s;" + " got %s", replace.cmd.getRefName(), refName);
            try {
                logDebug("One-off insertion of patch set for {}", refName);
                replace.insertPatchSetWithoutBatchUpdate();
                replace.inputCommand.setResult(OK);
            } catch (IOException | UpdateException | RestApiException err) {
                reject(replace.inputCommand, "internal server error");
                logError(String.format("Cannot add patch set to change %d in project %s", e.getKey().get(), project.getName()), err);
            }
        } else if (replace.inputCommand.getResult() == NOT_ATTEMPTED) {
            reject(replace.inputCommand, "internal server error");
            logError(String.format("Replacement for project %s was not attempted", project.getName()));
        }
    }
    // No need to continue.
    if (magicBranch == null) {
        logDebug("No magic branch, nothing more to do");
        return;
    } else if (magicBranch.cmd.getResult() != NOT_ATTEMPTED) {
        logWarn(String.format("Skipping change updates on %s because ref update failed: %s %s", project.getName(), magicBranch.cmd.getResult(), Strings.nullToEmpty(magicBranch.cmd.getMessage())));
        return;
    }
    List<String> lastCreateChangeErrors = new ArrayList<>();
    for (CreateRequest create : newChanges) {
        if (create.cmd.getResult() == OK) {
            okToInsert++;
        } else {
            String createChangeResult = String.format("%s %s", create.cmd.getResult(), Strings.nullToEmpty(create.cmd.getMessage())).trim();
            lastCreateChangeErrors.add(createChangeResult);
            logError(String.format("Command %s on %s:%s not completed: %s", create.cmd.getType(), project.getName(), create.cmd.getRefName(), createChangeResult));
        }
    }
    logDebug("Counted {} ok to insert, out of {} to replace and {} new", okToInsert, replaceCount, newChanges.size());
    if (okToInsert != replaceCount + newChanges.size()) {
        // One or more new references failed to create. Assume the
        // system isn't working correctly anymore and abort.
        reject(magicBranch.cmd, "Unable to create changes: " + Joiner.on(' ').join(lastCreateChangeErrors));
        logError(String.format("Only %d of %d new change refs created in %s; aborting", okToInsert, replaceCount + newChanges.size(), project.getName()));
        return;
    }
    try (BatchUpdate bu = batchUpdateFactory.create(db, magicBranch.dest.getParentKey(), user, TimeUtil.nowTs());
        ObjectInserter ins = repo.newObjectInserter()) {
        bu.setRepository(repo, rp.getRevWalk(), ins).updateChangesInParallel();
        bu.setRequestId(receiveId);
        for (ReplaceRequest replace : replaceByChange.values()) {
            if (replace.inputCommand == magicBranch.cmd) {
                replace.addOps(bu, replaceProgress);
            }
        }
        for (CreateRequest create : newChanges) {
            create.addOps(bu);
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.addOps(bu);
        }
        logDebug("Executing batch");
        try {
            bu.execute();
        } catch (UpdateException e) {
            throw INSERT_EXCEPTION.apply(e);
        }
        magicBranch.cmd.setResult(OK);
        for (ReplaceRequest replace : replaceByChange.values()) {
            String rejectMessage = replace.getRejectMessage();
            if (rejectMessage != null) {
                logDebug("Rejecting due to message from ReplaceOp");
                reject(replace.inputCommand, rejectMessage);
            }
        }
    } catch (ResourceConflictException e) {
        addMessage(e.getMessage());
        reject(magicBranch.cmd, "conflict");
    } catch (RestApiException | IOException err) {
        logError("Can't insert change/patch set for " + project.getName(), err);
        reject(magicBranch.cmd, "internal server error: " + err.getMessage());
    }
    if (magicBranch != null && magicBranch.submit) {
        try {
            submit(newChanges, replaceByChange.values());
        } catch (ResourceConflictException e) {
            addMessage(e.getMessage());
            reject(magicBranch.cmd, "conflict");
        } catch (RestApiException | OrmException e) {
            logError("Error submitting changes to " + project.getName(), e);
            reject(magicBranch.cmd, "error during submit");
        }
    }
}
#end_block

#method_before
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        HookResult result = hooks.doRefUpdateHook(project, cmd.getRefName(), currentUser.getAccount(), cmd.getOldId(), cmd.getNewId());
        if (result != null) {
            final String message = result.toString().trim();
            if (result.getExitValue() != 0) {
                reject(cmd, message);
                continue;
            }
            rp.sendMessage(message);
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseMagicBranch(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(repo, cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            addError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                addError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                        Project.NameKey newParent = cfg.getProject().getParent(allProjectsName);
                        Project.NameKey oldParent = project.getParent(allProjectsName);
                        if (oldParent == null) {
                            // update of the 'All-Projects' project
                            if (newParent != null) {
                                reject(cmd, "invalid project configuration: root project cannot have parent");
                                continue;
                            }
                        } else {
                            if (!oldParent.equals(newParent) && !currentUser.getCapabilities().canAdministrateServer()) {
                                reject(cmd, "invalid project configuration: only Gerrit admin can set parent");
                                continue;
                            }
                            if (projectCache.get(newParent) == null) {
                                reject(cmd, "invalid project configuration: parent does not exist");
                                continue;
                            }
                        }
                        for (Entry<ProjectConfigEntry> e : pluginConfigEntries) {
                            PluginConfig pluginCfg = cfg.getPluginConfig(e.getPluginName());
                            ProjectConfigEntry configEntry = e.getProvider().get();
                            String value = pluginCfg.getString(e.getExportName());
                            String oldValue = projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getString(e.getExportName());
                            if (configEntry.getType() == ProjectConfigEntry.Type.ARRAY) {
                                List<String> l = Arrays.asList(projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getStringList(e.getExportName()));
                                oldValue = Joiner.on("\n").join(l);
                            }
                            if ((value == null ? oldValue != null : !value.equals(oldValue)) && !configEntry.isEditable(projectControl.getProjectState())) {
                                reject(cmd, String.format("invalid project configuration: Not allowed to set parameter" + " '%s' of plugin '%s' on project '%s'.", e.getExportName(), e.getPluginName(), project.getName()));
                                continue;
                            }
                            if (ProjectConfigEntry.Type.LIST.equals(configEntry.getType()) && value != null && !configEntry.getPermittedValues().contains(value)) {
                                reject(cmd, String.format("invalid project configuration: The value '%s' is " + "not permitted for parameter '%s' of plugin '%s'.", value, e.getExportName(), e.getPluginName()));
                            }
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#method_after
private void parseCommands(Collection<ReceiveCommand> commands) {
    logDebug("Parsing {} commands", commands.size());
    for (ReceiveCommand cmd : commands) {
        if (cmd.getResult() != NOT_ATTEMPTED) {
            // Already rejected by the core receive process.
            logDebug("Already processed by core: {} {}", cmd.getResult(), cmd);
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseMagicBranch(cmd);
            continue;
        }
        if (projectControl.getProjectState().isAllUsers() && RefNames.REFS_USERS_SELF.equals(cmd.getRefName())) {
            String newName = RefNames.refsUsers(user.getAccountId());
            logDebug("Swapping out command for {} to {}", RefNames.REFS_USERS_SELF, newName);
            final ReceiveCommand orgCmd = cmd;
            cmd = new ReceiveCommand(cmd.getOldId(), cmd.getNewId(), newName, cmd.getType()) {

                @Override
                public void setResult(Result s, String m) {
                    super.setResult(s, m);
                    orgCmd.setResult(s, m);
                }
            };
        }
        Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            logDebug("Processing {} command", cmd.getRefName());
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(rp.getRevWalk(), cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            addError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                addError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            logError("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                        Project.NameKey newParent = cfg.getProject().getParent(allProjectsName);
                        Project.NameKey oldParent = project.getParent(allProjectsName);
                        if (oldParent == null) {
                            // update of the 'All-Projects' project
                            if (newParent != null) {
                                reject(cmd, "invalid project configuration: root project cannot have parent");
                                continue;
                            }
                        } else {
                            if (!oldParent.equals(newParent) && !user.getCapabilities().canAdministrateServer()) {
                                reject(cmd, "invalid project configuration: only Gerrit admin can set parent");
                                continue;
                            }
                            if (projectCache.get(newParent) == null) {
                                reject(cmd, "invalid project configuration: parent does not exist");
                                continue;
                            }
                        }
                        for (Entry<ProjectConfigEntry> e : pluginConfigEntries) {
                            PluginConfig pluginCfg = cfg.getPluginConfig(e.getPluginName());
                            ProjectConfigEntry configEntry = e.getProvider().get();
                            String value = pluginCfg.getString(e.getExportName());
                            String oldValue = projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getString(e.getExportName());
                            if (configEntry.getType() == ProjectConfigEntryType.ARRAY) {
                                List<String> l = Arrays.asList(projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getStringList(e.getExportName()));
                                oldValue = Joiner.on("\n").join(l);
                            }
                            if ((value == null ? oldValue != null : !value.equals(oldValue)) && !configEntry.isEditable(projectControl.getProjectState())) {
                                reject(cmd, String.format("invalid project configuration: Not allowed to set parameter" + " '%s' of plugin '%s' on project '%s'.", e.getExportName(), e.getPluginName(), project.getName()));
                                continue;
                            }
                            if (ProjectConfigEntryType.LIST.equals(configEntry.getType()) && value != null && !configEntry.getPermittedValues().contains(value)) {
                                reject(cmd, String.format("invalid project configuration: The value '%s' is " + "not permitted for parameter '%s' of plugin '%s'.", value, e.getExportName(), e.getPluginName()));
                            }
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        logError("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#end_block

#method_before
private void parseCreate(final ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    rp.getRevWalk().reset();
    if (ctl.canCreate(db, rp.getRevWalk(), obj)) {
        if (!validRefOperation(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        reject(cmd);
    }
}
#method_after
private void parseCreate(ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        logError("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    logDebug("Creating {}", cmd);
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canCreate(db, rp.getRepository(), obj)) {
        if (!validRefOperation(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        reject(cmd);
    }
}
#end_block

#method_before
private void parseUpdate(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canUpdate()) {
        if (isHead(cmd) && !isCommit(cmd)) {
            return;
        }
        if (!validRefOperation(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        if (RefNames.REFS_CONFIG.equals(ctl.getRefName())) {
            errors.put(Error.CONFIG_UPDATE, RefNames.REFS_CONFIG);
        } else {
            errors.put(Error.UPDATE, ctl.getRefName());
        }
        reject(cmd);
    }
}
#method_after
private void parseUpdate(ReceiveCommand cmd) {
    logDebug("Updating {}", cmd);
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canUpdate()) {
        if (isHead(cmd) && !isCommit(cmd)) {
            return;
        }
        if (!validRefOperation(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        if (RefNames.REFS_CONFIG.equals(ctl.getRefName())) {
            errors.put(Error.CONFIG_UPDATE, RefNames.REFS_CONFIG);
        } else {
            errors.put(Error.UPDATE, ctl.getRefName());
        }
        reject(cmd);
    }
}
#end_block

#method_before
private boolean isCommit(final ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName(), err);
        reject(cmd, "invalid object");
        return false;
    }
    if (obj instanceof RevCommit) {
        return true;
    } else {
        reject(cmd, "not a commit");
        return false;
    }
}
#method_after
private boolean isCommit(ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        logError("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName(), err);
        reject(cmd, "invalid object");
        return false;
    }
    if (obj instanceof RevCommit) {
        return true;
    }
    reject(cmd, "not a commit");
    return false;
}
#end_block

#method_before
private void parseDelete(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.getRefName().startsWith(REFS_CHANGES)) {
        errors.put(Error.DELETE_CHANGES, ctl.getRefName());
        reject(cmd, "cannot delete changes");
    } else if (ctl.canDelete()) {
        if (!validRefOperation(cmd)) {
            return;
        }
        batch.addCommand(cmd);
    } else {
        if (RefNames.REFS_CONFIG.equals(ctl.getRefName())) {
            reject(cmd, "cannot delete project configuration");
        } else {
            errors.put(Error.DELETE, ctl.getRefName());
            reject(cmd, "cannot delete references");
        }
    }
}
#method_after
private void parseDelete(ReceiveCommand cmd) {
    logDebug("Deleting {}", cmd);
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.getRefName().startsWith(REFS_CHANGES)) {
        errors.put(Error.DELETE_CHANGES, ctl.getRefName());
        reject(cmd, "cannot delete changes");
    } else if (ctl.canDelete()) {
        if (!validRefOperation(cmd)) {
            return;
        }
        batch.addCommand(cmd);
    } else {
        if (RefNames.REFS_CONFIG.equals(ctl.getRefName())) {
            reject(cmd, "cannot delete project configuration");
        } else {
            errors.put(Error.DELETE, ctl.getRefName());
            reject(cmd, "cannot delete references");
        }
    }
}
#end_block

#method_before
private void parseRewind(final ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
        if (!validRefOperation(cmd)) {
            return;
        }
        batch.setAllowNonFastForwards(true).addCommand(cmd);
    } else {
        cmd.setResult(REJECTED_NONFASTFORWARD, " need '" + PermissionRule.FORCE_PUSH + "' privilege.");
    }
}
#method_after
private void parseRewind(ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        logError("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    logDebug("Rewinding {}", cmd);
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
        if (!validRefOperation(cmd)) {
            return;
        }
        batch.setAllowNonFastForwards(true).addCommand(cmd);
    } else {
        cmd.setResult(REJECTED_NONFASTFORWARD, " need '" + PermissionRule.FORCE_PUSH + "' privilege.");
    }
}
#end_block

#method_before
@Option(name = "-r", metaVar = "EMAIL", usage = "add reviewer to changes")
void reviewer(Account.Id id) {
    reviewer.add(id);
}
#method_after
@Option(name = "--reviewer", aliases = { "-r" }, metaVar = "EMAIL", usage = "add reviewer to changes")
void reviewer(Account.Id id) {
    reviewer.add(id);
}
#end_block

#method_before
@Option(name = "-l", metaVar = "LABEL+VALUE", usage = "label(s) to assign (defaults to +1 if no value provided")
void addLabel(final String token) throws CmdLineException {
    LabelVote v = LabelVote.parse(token);
    try {
        LabelType.checkName(v.getLabel());
        ApprovalsUtil.checkLabel(labelTypes, v.getLabel(), v.getValue());
    } catch (IllegalArgumentException e) {
        throw clp.reject(e.getMessage());
    }
    labels.put(v.getLabel(), v.getValue());
}
#method_after
@Option(name = "--label", aliases = { "-l" }, metaVar = "LABEL+VALUE", usage = "label(s) to assign (defaults to +1 if no value provided")
void addLabel(String token) throws CmdLineException {
    LabelVote v = LabelVote.parse(token);
    try {
        LabelType.checkName(v.label());
        ApprovalsUtil.checkLabel(labelTypes, v.label(), v.value());
    } catch (IllegalArgumentException e) {
        throw clp.reject(e.getMessage());
    }
    labels.put(v.label(), v.value());
}
#end_block

#method_before
String parse(CmdLineParser clp, Repository repo, Set<String> refs) throws CmdLineException {
    String ref = MagicBranch.getDestBranchName(cmd.getRefName());
    if (!ref.startsWith(Constants.R_REFS)) {
        ref = Constants.R_HEADS + ref;
    }
    int optionStart = ref.indexOf('%');
    if (0 < optionStart) {
        ListMultimap<String, String> options = LinkedListMultimap.create();
        for (String s : COMMAS.split(ref.substring(optionStart + 1))) {
            int e = s.indexOf('=');
            if (0 < e) {
                options.put(s.substring(0, e), s.substring(e + 1));
            } else {
                options.put(s, "");
            }
        }
        clp.parseOptionMap(options);
        ref = ref.substring(0, optionStart);
    }
    // Split the destination branch by branch and topic. The topic
    // suffix is entirely optional, so it might not even exist.
    String head = readHEAD(repo);
    int split = ref.length();
    for (; ; ) {
        String name = ref.substring(0, split);
        if (refs.contains(name) || name.equals(head)) {
            break;
        }
        split = name.lastIndexOf('/', split - 1);
        if (split <= Constants.R_REFS.length()) {
            return ref;
        }
    }
    if (split < ref.length()) {
        topic = Strings.emptyToNull(ref.substring(split + 1));
    }
    return ref.substring(0, split);
}
#method_after
String parse(CmdLineParser clp, Repository repo, Set<String> refs) throws CmdLineException {
    String ref = RefNames.fullName(MagicBranch.getDestBranchName(cmd.getRefName()));
    int optionStart = ref.indexOf('%');
    if (0 < optionStart) {
        ListMultimap<String, String> options = LinkedListMultimap.create();
        for (String s : COMMAS.split(ref.substring(optionStart + 1))) {
            int e = s.indexOf('=');
            if (0 < e) {
                options.put(s.substring(0, e), s.substring(e + 1));
            } else {
                options.put(s, "");
            }
        }
        clp.parseOptionMap(options);
        ref = ref.substring(0, optionStart);
    }
    // Split the destination branch by branch and topic. The topic
    // suffix is entirely optional, so it might not even exist.
    String head = readHEAD(repo);
    int split = ref.length();
    for (; ; ) {
        String name = ref.substring(0, split);
        if (refs.contains(name) || name.equals(head)) {
            break;
        }
        split = name.lastIndexOf('/', split - 1);
        if (split <= Constants.R_REFS.length()) {
            return ref;
        }
    }
    if (split < ref.length()) {
        topic = Strings.emptyToNull(ref.substring(split + 1));
    }
    return ref.substring(0, split);
}
#end_block

#method_before
private void parseMagicBranch(final ReceiveCommand cmd) {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    magicBranch = new MagicBranchInput(cmd, labelTypes);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    magicBranch.setCmdLineParser(clp);
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet());
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    if (!magicBranch.ctl.canWrite()) {
        reject(cmd, "project is read only");
        return;
    }
    if (magicBranch.isDraft() && (!receiveConfig.allowDrafts || projectControl.controlForRef("refs/drafts/" + ref).isBlocked(Permission.PUSH))) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload drafts");
        return;
    }
    if (!magicBranch.ctl.canUpload()) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload review");
        return;
    }
    if (magicBranch.isDraft() && magicBranch.isSubmit()) {
        reject(cmd, "cannot submit draft");
        return;
    }
    if (magicBranch.isSubmit() && !projectControl.controlForRef(MagicBranch.NEW_CHANGE + ref).canSubmit()) {
        reject(cmd, "submit not allowed");
    }
    RevWalk walk = rp.getRevWalk();
    if (magicBranch.base != null) {
        magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
        for (ObjectId id : magicBranch.base) {
            try {
                magicBranch.baseCommit.add(walk.parseCommit(id));
            } catch (IncorrectObjectTypeException notCommit) {
                reject(cmd, "base must be a commit");
                return;
            } catch (MissingObjectException e) {
                reject(cmd, "base not found");
                return;
            } catch (IOException e) {
                log.warn(String.format("Project %s cannot read %s", project.getName(), id.name()), e);
                reject(cmd, "internal server error");
                return;
            }
        }
    }
    // 
    try {
        final RevCommit tip = walk.parseCommit(magicBranch.cmd.getNewId());
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
    }
}
#method_after
private void parseMagicBranch(ReceiveCommand cmd) {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    logDebug("Found magic branch {}", cmd.getRefName());
    magicBranch = new MagicBranchInput(cmd, labelTypes, notesMigration);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    magicBranch.clp = clp;
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet());
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            logDebug("Invalid branch syntax");
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (projectControl.getProjectState().isAllUsers() && RefNames.REFS_USERS_SELF.equals(ref)) {
        logDebug("Handling {}", RefNames.REFS_USERS_SELF);
        ref = RefNames.refsUsers(user.getAccountId());
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        logDebug("Ref {} not found", ref);
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    if (!magicBranch.ctl.canWrite()) {
        reject(cmd, "project is read only");
        return;
    }
    if (magicBranch.draft) {
        if (!receiveConfig.allowDrafts) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "draft workflow is disabled");
            return;
        } else if (projectControl.controlForRef("refs/drafts/" + ref).isBlocked(Permission.PUSH)) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "cannot upload drafts");
            return;
        }
    }
    if (!magicBranch.ctl.canUpload()) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload review");
        return;
    }
    if (magicBranch.draft && magicBranch.submit) {
        reject(cmd, "cannot submit draft");
        return;
    }
    if (magicBranch.submit && !projectControl.controlForRef(MagicBranch.NEW_CHANGE + ref).canSubmit()) {
        reject(cmd, "submit not allowed");
        return;
    }
    RevWalk walk = rp.getRevWalk();
    RevCommit tip;
    try {
        tip = walk.parseCommit(magicBranch.cmd.getNewId());
        logDebug("Tip of push: {}", tip.name());
    } catch (IOException ex) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", ex);
        return;
    }
    // if %base was specified, ignore newChangeForAllNotInTarget
    if (tip.getParentCount() > 1 || magicBranch.base != null || tip.getParentCount() == 0) {
        logDebug("Forcing newChangeForAllNotInTarget = false");
        newChangeForAllNotInTarget = false;
    }
    if (magicBranch.base != null) {
        logDebug("Handling %base: {}", magicBranch.base);
        magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
        for (ObjectId id : magicBranch.base) {
            try {
                magicBranch.baseCommit.add(walk.parseCommit(id));
            } catch (IncorrectObjectTypeException notCommit) {
                reject(cmd, "base must be a commit");
                return;
            } catch (MissingObjectException e) {
                reject(cmd, "base not found");
                return;
            } catch (IOException e) {
                logWarn(String.format("Project %s cannot read %s", project.getName(), id.name()), e);
                reject(cmd, "internal server error");
                return;
            }
        }
    } else if (newChangeForAllNotInTarget) {
        logDebug("Handling newChangeForAllNotInTarget");
        String destBranch = magicBranch.dest.get();
        try {
            Ref r = repo.getRefDatabase().exactRef(destBranch);
            if (r == null) {
                reject(cmd, destBranch + " not found");
                return;
            }
            ObjectId baseHead = r.getObjectId();
            magicBranch.baseCommit = Collections.singletonList(walk.parseCommit(baseHead));
            logDebug("Set baseCommit = {}", magicBranch.baseCommit.get(0).name());
        } catch (IOException ex) {
            logWarn(String.format("Project %s cannot read %s", project.getName(), destBranch), ex);
            reject(cmd, "internal server error");
            return;
        }
    }
    // 
    try {
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // The destination branch does not yet exist. Assume the
            // history being sent for review will start it and thus
            // is "connected" to the branch.
            logDebug("Branch is unborn");
            return;
        }
        RevCommit h = walk.parseCommit(targetRef.getObjectId());
        logDebug("Current branch tip: {}", h.name());
        RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", e);
    }
}
#end_block

#method_before
private void parseReplaceCommand(final ReceiveCommand cmd, final Change.Id changeId) {
    if (cmd.getType() != ReceiveCommand.Type.CREATE) {
        reject(cmd, "invalid usage");
        return;
    }
    final RevCommit newCommit;
    try {
        newCommit = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IOException e) {
        log.error("Cannot parse " + cmd.getNewId().name() + " as commit", e);
        reject(cmd, "invalid commit");
        return;
    }
    final Change changeEnt;
    try {
        changeEnt = db.changes().get(changeId);
    } catch (OrmException e) {
        log.error("Cannot lookup existing change " + changeId, e);
        reject(cmd, "database error");
        return;
    }
    if (changeEnt == null) {
        reject(cmd, "change " + changeId + " not found");
        return;
    }
    if (!project.getNameKey().equals(changeEnt.getProject())) {
        reject(cmd, "change " + changeId + " does not belong to project " + project.getName());
        return;
    }
    requestReplace(cmd, true, changeEnt, newCommit);
}
#method_after
private void parseReplaceCommand(ReceiveCommand cmd, Change.Id changeId) {
    logDebug("Parsing replace command");
    if (cmd.getType() != ReceiveCommand.Type.CREATE) {
        reject(cmd, "invalid usage");
        return;
    }
    RevCommit newCommit;
    try {
        newCommit = rp.getRevWalk().parseCommit(cmd.getNewId());
        logDebug("Replacing with {}", newCommit);
    } catch (IOException e) {
        logError("Cannot parse " + cmd.getNewId().name() + " as commit", e);
        reject(cmd, "invalid commit");
        return;
    }
    Change changeEnt;
    try {
        changeEnt = notesFactory.createChecked(db, project.getNameKey(), changeId).getChange();
    } catch (OrmException e) {
        logError("Cannot lookup existing change " + changeId, e);
        reject(cmd, "database error");
        return;
    } catch (NoSuchChangeException e) {
        logError("Change not found " + changeId, e);
        reject(cmd, "change " + changeId + " not found");
        return;
    }
    if (!project.getNameKey().equals(changeEnt.getProject())) {
        reject(cmd, "change " + changeId + " does not belong to project " + project.getName());
        return;
    }
    logDebug("Replacing change {}", changeEnt.getId());
    requestReplace(cmd, true, changeEnt, newCommit);
}
#end_block

#method_before
private boolean requestReplace(final ReceiveCommand cmd, final boolean checkMergedInto, final Change change, final RevCommit newCommit) {
    if (change.getStatus().isClosed()) {
        reject(cmd, "change " + change.getId() + " closed");
        return false;
    }
    final ReplaceRequest req = new ReplaceRequest(change.getId(), newCommit, cmd, checkMergedInto);
    if (replaceByChange.containsKey(req.ontoChange)) {
        reject(cmd, "duplicate request");
        return false;
    }
    if (replaceByCommit.containsKey(req.newCommit)) {
        reject(cmd, "duplicate request");
        return false;
    }
    replaceByChange.put(req.ontoChange, req);
    replaceByCommit.put(req.newCommit, req);
    return true;
}
#method_after
private boolean requestReplace(ReceiveCommand cmd, boolean checkMergedInto, Change change, RevCommit newCommit) {
    if (change.getStatus().isClosed()) {
        reject(cmd, "change " + canonicalWebUrl + change.getId() + " closed");
        return false;
    }
    ReplaceRequest req = new ReplaceRequest(change.getId(), newCommit, cmd, checkMergedInto);
    if (replaceByChange.containsKey(req.ontoChange)) {
        reject(cmd, "duplicate request");
        return false;
    }
    replaceByChange.put(req.ontoChange, req);
    return true;
}
#end_block

#method_before
private void markHeadsAsUninteresting(final RevWalk walk, Set<ObjectId> existing, @Nullable String forRef) {
    for (Ref ref : allRefs.values()) {
        if (ref.getObjectId() == null) {
            continue;
        } else if (ref.getName().startsWith(REFS_CHANGES)) {
            existing.add(ref.getObjectId());
        } else if (ref.getName().startsWith(R_HEADS) || (forRef != null && forRef.equals(ref.getName()))) {
            try {
                walk.markUninteresting(walk.parseCommit(ref.getObjectId()));
            } catch (IOException e) {
                log.warn(String.format("Invalid ref %s in %s", ref.getName(), project.getName()), e);
                continue;
            }
        }
    }
}
#method_after
private void markHeadsAsUninteresting(RevWalk rw, @Nullable String forRef) {
    int i = 0;
    for (Ref ref : allRefs.values()) {
        if ((ref.getName().startsWith(R_HEADS) || ref.getName().equals(forRef)) && ref.getObjectId() != null) {
            try {
                rw.markUninteresting(rw.parseCommit(ref.getObjectId()));
                i++;
            } catch (IOException e) {
                logWarn(String.format("Invalid ref %s in %s", ref.getName(), project.getName()), e);
            }
        }
    }
    logDebug("Marked {} heads as uninteresting", i);
}
#end_block

#method_before
private void submit(ChangeControl changeCtl, PatchSet ps) throws OrmException, IOException {
    Submit submit = submitProvider.get();
    RevisionResource rsrc = new RevisionResource(changes.parse(changeCtl), ps);
    Change c;
    try {
        // Force submit even if submit rule evaluation fails.
        c = submit.submit(rsrc, currentUser, true);
    } catch (ResourceConflictException e) {
        throw new IOException(e);
    }
    if (c == null) {
        addError("Submitting change " + changeCtl.getChange().getChangeId() + " failed.");
    } else {
        addMessage("");
        mergeQueue.merge(c.getDest());
        c = db.changes().get(c.getId());
        switch(c.getStatus()) {
            case SUBMITTED:
                addMessage("Change " + c.getChangeId() + " submitted.");
                break;
            case MERGED:
                addMessage("Change " + c.getChangeId() + " merged.");
                break;
            case NEW:
                ChangeMessage msg = submit.getConflictMessage(rsrc);
                if (msg != null) {
                    addMessage("Change " + c.getChangeId() + ": " + msg.getMessage());
                    break;
                }
            default:
                addMessage("change " + c.getChangeId() + " is " + c.getStatus().name().toLowerCase());
        }
    }
}
#method_after
private void submit(Collection<CreateRequest> create, Collection<ReplaceRequest> replace) throws OrmException, RestApiException {
    Map<ObjectId, Change> bySha = Maps.newHashMapWithExpectedSize(create.size() + replace.size());
    for (CreateRequest r : create) {
        checkNotNull(r.change, "cannot submit new change %s; op may not have run", r.changeId);
        bySha.put(r.commit, r.change);
    }
    for (ReplaceRequest r : replace) {
        bySha.put(r.newCommitId, r.notes.getChange());
    }
    Change tipChange = bySha.get(magicBranch.cmd.getNewId());
    checkNotNull(tipChange, "tip of push does not correspond to a change; found these changes: %s", bySha);
    logDebug("Processing submit with tip change {} ({})", tipChange.getId(), magicBranch.cmd.getNewId());
    try (MergeOp op = mergeOpProvider.get()) {
        op.merge(db, tipChange, user, false, new SubmitInput());
    }
}
#end_block

#method_before
private void preparePatchSetsForReplace() {
    try {
        readChangesForReplace();
        for (Iterator<ReplaceRequest> itr = replaceByChange.values().iterator(); itr.hasNext(); ) {
            ReplaceRequest req = itr.next();
            if (req.inputCommand.getResult() == NOT_ATTEMPTED) {
                req.validate(false);
                if (req.skip && req.cmd == null) {
                    itr.remove();
                    replaceByCommit.remove(req.newCommit);
                }
            }
        }
    } catch (OrmException err) {
        log.error(String.format("Cannot read database before replacement for project %s", project.getName()), err);
        for (ReplaceRequest req : replaceByChange.values()) {
            if (req.inputCommand.getResult() == NOT_ATTEMPTED) {
                req.inputCommand.setResult(REJECTED_OTHER_REASON, "internal server error");
            }
        }
    } catch (IOException err) {
        log.error(String.format("Cannot read repository before replacement for project %s", project.getName()), err);
        for (ReplaceRequest req : replaceByChange.values()) {
            if (req.inputCommand.getResult() == NOT_ATTEMPTED) {
                req.inputCommand.setResult(REJECTED_OTHER_REASON, "internal server error");
            }
        }
    }
    for (ReplaceRequest req : replaceByChange.values()) {
        if (req.inputCommand.getResult() == NOT_ATTEMPTED && req.cmd != null) {
            batch.addCommand(req.cmd);
        }
    }
    if (magicBranch != null && magicBranch.cmd.getResult() != NOT_ATTEMPTED) {
        // Cancel creations tied to refs/for/ or refs/drafts/ command.
        for (ReplaceRequest req : replaceByChange.values()) {
            if (req.inputCommand == magicBranch.cmd && req.cmd != null) {
                req.cmd.setResult(Result.REJECTED_OTHER_REASON, "aborted");
            }
        }
        for (CreateRequest req : newChanges) {
            req.cmd.setResult(Result.REJECTED_OTHER_REASON, "aborted");
        }
    }
}
#method_after
private void preparePatchSetsForReplace() {
    try {
        readChangesForReplace();
        for (Iterator<ReplaceRequest> itr = replaceByChange.values().iterator(); itr.hasNext(); ) {
            ReplaceRequest req = itr.next();
            if (req.inputCommand.getResult() == NOT_ATTEMPTED) {
                req.validate(false);
                if (req.skip && req.cmd == null) {
                    itr.remove();
                }
            }
        }
    } catch (OrmException err) {
        logError(String.format("Cannot read database before replacement for project %s", project.getName()), err);
        for (ReplaceRequest req : replaceByChange.values()) {
            if (req.inputCommand.getResult() == NOT_ATTEMPTED) {
                req.inputCommand.setResult(REJECTED_OTHER_REASON, "internal server error");
            }
        }
    } catch (IOException err) {
        logError(String.format("Cannot read repository before replacement for project %s", project.getName()), err);
        for (ReplaceRequest req : replaceByChange.values()) {
            if (req.inputCommand.getResult() == NOT_ATTEMPTED) {
                req.inputCommand.setResult(REJECTED_OTHER_REASON, "internal server error");
            }
        }
    }
    logDebug("Read {} changes to replace", replaceByChange.size());
    for (ReplaceRequest req : replaceByChange.values()) {
        if (req.inputCommand.getResult() == NOT_ATTEMPTED && req.cmd != null) {
            if (req.prev != null) {
                batch.addCommand(req.prev);
            }
            batch.addCommand(req.cmd);
        }
    }
    if (magicBranch != null && magicBranch.cmd.getResult() != NOT_ATTEMPTED) {
        // Cancel creations tied to refs/for/ or refs/drafts/ command.
        for (ReplaceRequest req : replaceByChange.values()) {
            if (req.inputCommand == magicBranch.cmd && req.cmd != null) {
                req.cmd.setResult(Result.REJECTED_OTHER_REASON, "aborted");
            }
        }
        for (CreateRequest req : newChanges) {
            req.cmd.setResult(Result.REJECTED_OTHER_REASON, "aborted");
        }
    }
}
#end_block

#method_before
private void readChangesForReplace() throws OrmException {
    List<CheckedFuture<Change, OrmException>> futures = Lists.newArrayListWithCapacity(replaceByChange.size());
    for (ReplaceRequest request : replaceByChange.values()) {
        futures.add(db.changes().getAsync(request.ontoChange));
    }
    for (CheckedFuture<Change, OrmException> f : futures) {
        Change c = f.checkedGet();
        if (c != null) {
            replaceByChange.get(c.getId()).change = c;
        }
    }
}
#method_after
private void readChangesForReplace() throws OrmException {
    Collection<ChangeNotes> allNotes = notesFactory.create(db, Collections2.transform(replaceByChange.values(), new Function<ReplaceRequest, Change.Id>() {

        @Override
        public Change.Id apply(ReplaceRequest in) {
            return in.ontoChange;
        }
    }));
    for (ChangeNotes notes : allNotes) {
        replaceByChange.get(notes.getChangeId()).notes = notes;
    }
}
#end_block

#method_before
boolean validate(boolean autoClose) throws IOException {
    if (!autoClose && inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    } else if (change == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    priorPatchSet = change.currentPatchSetId();
    if (!revisions.containsValue(priorPatchSet)) {
        reject(inputCommand, "change " + ontoChange + " missing revisions");
        return false;
    }
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    if (newCommit == priorCommit) {
        // Ignore requests to make the change its current state.
        skip = true;
        reject(inputCommand, "commit already exists (as current patchset)");
        return false;
    }
    changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(inputCommand, "cannot replace " + ontoChange);
        return false;
    } else if (change.getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    } else if (revisions.containsKey(newCommit)) {
        reject(inputCommand, "commit already exists (in the change)");
        return false;
    }
    for (final Ref r : rp.getRepository().getRefDatabase().getRefs("refs/changes").values()) {
        if (r.getObjectId().equals(newCommit)) {
            reject(inputCommand, "commit already exists (in the project)");
            return false;
        }
    }
    for (RevCommit prior : revisions.keySet()) {
        // amending when trying to address review comments.
        if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
            reject(inputCommand, "squash commits first");
            return false;
        }
    }
    rp.getRevWalk().parseBody(newCommit);
    if (!validCommit(changeCtl.getRefControl(), inputCommand, newCommit)) {
        return false;
    }
    rp.getRevWalk().parseBody(priorCommit);
    // of the commit was modified.
    if (newCommit.getTree() == priorCommit.getTree()) {
        final boolean messageEq = eq(newCommit.getFullMessage(), priorCommit.getFullMessage());
        final boolean parentsEq = parentsEqual(newCommit, priorCommit);
        final boolean authorEq = authorEqual(newCommit, priorCommit);
        final ObjectReader reader = rp.getRevWalk().getObjectReader();
        if (messageEq && parentsEq && authorEq && !autoClose) {
            addMessage(String.format("(W) No changes between prior commit %s and new commit %s", reader.abbreviate(priorCommit).name(), reader.abbreviate(newCommit).name()));
            reject(inputCommand, "no changes made");
            return false;
        } else {
            StringBuilder msg = new StringBuilder();
            msg.append("(W) ");
            msg.append(reader.abbreviate(newCommit).name());
            msg.append(":");
            msg.append(" no files changed");
            if (!authorEq) {
                msg.append(", author changed");
            }
            if (!messageEq) {
                msg.append(", message updated");
            }
            if (!parentsEq) {
                msg.append(", was rebased");
            }
            addMessage(msg.toString());
        }
    }
    PatchSet.Id id = ChangeUtil.nextPatchSetId(allRefs, change.currentPatchSetId());
    newPatchSet = new PatchSet(id);
    newPatchSet.setCreatedOn(TimeUtil.nowTs());
    newPatchSet.setUploader(currentUser.getAccountId());
    newPatchSet.setRevision(toRevId(newCommit));
    if (magicBranch != null && magicBranch.isDraft()) {
        newPatchSet.setDraft(true);
    }
    info = patchSetInfoFactory.get(newCommit, newPatchSet.getId());
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommit, newPatchSet.getRefName());
    return true;
}
#method_after
boolean validate(boolean autoClose) throws IOException, OrmException {
    if (!autoClose && inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    } else if (notes == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    priorPatchSet = notes.getChange().currentPatchSetId();
    if (!revisions.containsValue(priorPatchSet)) {
        reject(inputCommand, "change " + ontoChange + " missing revisions");
        return false;
    }
    RevCommit newCommit = rp.getRevWalk().parseCommit(newCommitId);
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    changeCtl = projectControl.controlFor(notes);
    if (!changeCtl.canAddPatchSet(db)) {
        String locked = ".";
        if (changeCtl.isPatchSetLocked(db)) {
            locked = ". Change is patch set locked.";
        }
        reject(inputCommand, "cannot add patch set to " + ontoChange + locked);
        return false;
    } else if (notes.getChange().getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    } else if (revisions.containsKey(newCommit)) {
        reject(inputCommand, "commit already exists (in the change)");
        return false;
    }
    for (Ref r : rp.getRepository().getRefDatabase().getRefs("refs/changes").values()) {
        if (r.getObjectId().equals(newCommit)) {
            reject(inputCommand, "commit already exists (in the project)");
            return false;
        }
    }
    for (RevCommit prior : revisions.keySet()) {
        // amending when trying to address review comments.
        if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
            reject(inputCommand, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
            return false;
        }
    }
    if (!validCommit(rp.getRevWalk(), changeCtl.getRefControl(), inputCommand, newCommit)) {
        return false;
    }
    rp.getRevWalk().parseBody(priorCommit);
    // of the commit was modified.
    if (newCommit.getTree().equals(priorCommit.getTree())) {
        boolean messageEq = eq(newCommit.getFullMessage(), priorCommit.getFullMessage());
        boolean parentsEq = parentsEqual(newCommit, priorCommit);
        boolean authorEq = authorEqual(newCommit, priorCommit);
        ObjectReader reader = rp.getRevWalk().getObjectReader();
        if (messageEq && parentsEq && authorEq && !autoClose) {
            addMessage(String.format("(W) No changes between prior commit %s and new commit %s", reader.abbreviate(priorCommit).name(), reader.abbreviate(newCommit).name()));
        } else {
            StringBuilder msg = new StringBuilder();
            msg.append("(I) ");
            msg.append(reader.abbreviate(newCommit).name());
            msg.append(":");
            msg.append(" no files changed");
            if (!authorEq) {
                msg.append(", author changed");
            }
            if (!messageEq) {
                msg.append(", message updated");
            }
            if (!parentsEq) {
                msg.append(", was rebased");
            }
            addMessage(msg.toString());
        }
    }
    if (magicBranch != null && magicBranch.edit) {
        return newEdit();
    }
    newPatchSet();
    return true;
}
#end_block

#method_before
private List<Ref> refs(Change.Id changeId) {
    if (refsByChange == null) {
        int estRefsPerChange = 4;
        refsByChange = ArrayListMultimap.create(allRefs.size() / estRefsPerChange, estRefsPerChange);
        for (Ref ref : allRefs.values()) {
            if (ref.getObjectId() != null) {
                PatchSet.Id psId = PatchSet.Id.fromRef(ref.getName());
                if (psId != null) {
                    refsByChange.put(psId.getParentKey(), ref);
                }
            }
        }
    }
    return refsByChange.get(changeId);
}
#method_after
private List<Ref> refs(Change.Id changeId) {
    return refsByChange().get(changeId);
}
#end_block

#method_before
private SetMultimap<ObjectId, Ref> changeRefsById() throws IOException {
    if (refsById == null) {
        refsById = HashMultimap.create();
        for (Ref r : repo.getRefDatabase().getRefs(REFS_CHANGES).values()) {
            if (PatchSet.isRef(r.getName())) {
                refsById.put(r.getObjectId(), r);
            }
        }
    }
    return refsById;
}
#method_after
private SetMultimap<ObjectId, Ref> changeRefsById() {
    initChangeRefMaps();
    return refsById;
}
#end_block

#method_before
static boolean parentsEqual(RevCommit a, RevCommit b) {
    if (a.getParentCount() != b.getParentCount()) {
        return false;
    }
    for (int i = 0; i < a.getParentCount(); i++) {
        if (a.getParent(i) != b.getParent(i)) {
            return false;
        }
    }
    return true;
}
#method_after
static boolean parentsEqual(RevCommit a, RevCommit b) {
    if (a.getParentCount() != b.getParentCount()) {
        return false;
    }
    for (int i = 0; i < a.getParentCount(); i++) {
        if (!a.getParent(i).equals(b.getParent(i))) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private boolean validRefOperation(final ReceiveCommand cmd) {
    RefOperationValidators refValidators = refValidatorsFactory.create(getProject(), currentUser, cmd);
    try {
        messages.addAll(refValidators.validateForRefOperation());
    } catch (RefOperationValidationException e) {
        messages.addAll(Lists.newArrayList(e.getMessages()));
        reject(cmd, e.getMessage());
        return false;
    }
    return true;
}
#method_after
private boolean validRefOperation(ReceiveCommand cmd) {
    RefOperationValidators refValidators = refValidatorsFactory.create(getProject(), user, cmd);
    try {
        messages.addAll(refValidators.validateForRefOperation());
    } catch (RefOperationValidationException e) {
        messages.addAll(Lists.newArrayList(e.getMessages()));
        reject(cmd, e.getMessage());
        return false;
    }
    return true;
}
#end_block

#method_before
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    if (ctl.canForgeAuthor() && ctl.canForgeCommitter() && ctl.canForgeGerritServerIdentity() && ctl.canUploadMerges() && !projectControl.getProjectState().isUseSignedOffBy() && Iterables.isEmpty(rejectCommits) && !RefNames.REFS_CONFIG.equals(ctl.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        return;
    }
    boolean defaultName = Strings.isNullOrEmpty(currentUser.getAccount().getFullName());
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        Set<ObjectId> existing = Sets.newHashSet();
        walk.markStart(walk.parseCommit(cmd.getNewId()));
        markHeadsAsUninteresting(walk, existing, cmd.getRefName());
        RevCommit c;
        while ((c = walk.next()) != null) {
            if (existing.contains(c)) {
                continue;
            } else if (!validCommit(ctl, cmd, c)) {
                break;
            }
            if (defaultName && currentUser.getEmailAddresses().contains(c.getCommitterIdent().getEmailAddress())) {
                try {
                    Account a = db.accounts().get(currentUser.getAccountId());
                    if (a != null && Strings.isNullOrEmpty(a.getFullName())) {
                        a.setFullName(c.getCommitterIdent().getName());
                        db.accounts().update(Collections.singleton(a));
                        currentUser.getAccount().setFullName(a.getFullName());
                        accountCache.evict(a.getId());
                    }
                } catch (OrmException e) {
                    log.warn("Cannot default full_name", e);
                } finally {
                    defaultName = false;
                }
            }
        }
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#method_after
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    if (ctl.canForgeAuthor() && ctl.canForgeCommitter() && ctl.canForgeGerritServerIdentity() && ctl.canUploadMerges() && !projectControl.getProjectState().isUseSignedOffBy() && Iterables.isEmpty(rejectCommits) && !RefNames.REFS_CONFIG.equals(ctl.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        logDebug("Short-circuiting new commit validation");
        return;
    }
    boolean defaultName = Strings.isNullOrEmpty(user.getAccount().getFullName());
    RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        RevObject parsedObject = walk.parseAny(cmd.getNewId());
        if (!(parsedObject instanceof RevCommit)) {
            return;
        }
        SetMultimap<ObjectId, Ref> existing = changeRefsById();
        walk.markStart((RevCommit) parsedObject);
        markHeadsAsUninteresting(walk, cmd.getRefName());
        int i = 0;
        for (RevCommit c; (c = walk.next()) != null; ) {
            i++;
            if (existing.keySet().contains(c)) {
                continue;
            } else if (!validCommit(walk, ctl, cmd, c)) {
                break;
            }
            if (defaultName && user.hasEmailAddress(c.getCommitterIdent().getEmailAddress())) {
                try {
                    Account a = db.accounts().get(user.getAccountId());
                    if (a != null && Strings.isNullOrEmpty(a.getFullName())) {
                        a.setFullName(c.getCommitterIdent().getName());
                        db.accounts().update(Collections.singleton(a));
                        user.getAccount().setFullName(a.getFullName());
                        accountCache.evict(a.getId());
                    }
                } catch (OrmException e) {
                    logWarn("Cannot default full_name", e);
                } finally {
                    defaultName = false;
                }
            }
        }
        logDebug("Validated {} new commits", i);
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#end_block

#method_before
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    if (validCommits.contains(c)) {
        return true;
    }
    CommitReceivedEvent receiveEvent = new CommitReceivedEvent(cmd, project, ctl.getRefName(), c, currentUser);
    CommitValidators commitValidators = commitValidatorsFactory.create(ctl, sshInfo, repo);
    try {
        messages.addAll(commitValidators.validateForReceiveCommits(receiveEvent, rejectCommits));
    } catch (CommitValidationException e) {
        messages.addAll(e.getMessages());
        reject(cmd, e.getMessage());
        return false;
    }
    validCommits.add(c);
    return true;
}
#method_after
private boolean validCommit(RevWalk rw, RefControl ctl, ReceiveCommand cmd, ObjectId id) throws IOException {
    if (validCommits.contains(id)) {
        return true;
    }
    RevCommit c = rw.parseCommit(id);
    rw.parseBody(c);
    CommitReceivedEvent receiveEvent = new CommitReceivedEvent(cmd, project, ctl.getRefName(), c, user);
    CommitValidators commitValidators = commitValidatorsFactory.create(ctl, sshInfo, repo);
    try {
        messages.addAll(commitValidators.validateForReceiveCommits(receiveEvent, rejectCommits));
    } catch (CommitValidationException e) {
        logDebug("Commit validation failed on {}", c.name());
        messages.addAll(e.getMessages());
        reject(cmd, e.getMessage());
        return false;
    }
    validCommits.add(c.copy());
    return true;
}
#end_block

#method_before
private void autoCloseChanges(final ReceiveCommand cmd) throws NoSuchChangeException {
    final RevWalk rw = rp.getRevWalk();
    try {
        rw.reset();
        rw.markStart(rw.parseCommit(cmd.getNewId()));
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final SetMultimap<ObjectId, Ref> byCommit = changeRefsById();
        final Map<Change.Key, Change.Id> byKey = openChangesByKey(new Branch.NameKey(project.getNameKey(), cmd.getRefName()));
        final List<ReplaceRequest> toClose = new ArrayList<>();
        RevCommit c;
        while ((c = rw.next()) != null) {
            final Set<Ref> refs = byCommit.get(c.copy());
            for (Ref ref : refs) {
                if (ref != null) {
                    rw.parseBody(c);
                    Change.Key closedChange = closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                    closeProgress.update(1);
                    if (closedChange != null) {
                        byKey.remove(closedChange);
                    }
                }
            }
            rw.parseBody(c);
            for (final String changeId : c.getFooterLines(CHANGE_ID)) {
                final Change.Id onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    final ReplaceRequest req = new ReplaceRequest(onto, c, cmd, false);
                    req.change = db.changes().get(onto);
                    toClose.add(req);
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = req.validate(true) ? req.insertPatchSet().checkedGet() : null;
            if (psi != null) {
                closeChange(req.inputCommand, psi, req.newCommit);
                closeProgress.update(1);
            }
        }
        // It handles gitlinks if required.
        rw.reset();
        final RevCommit codeReviewCommit = rw.parseCommit(cmd.getNewId());
        final SubmoduleOp subOp = subOpFactory.create(new Branch.NameKey(project.getNameKey(), cmd.getRefName()), codeReviewCommit, rw, repo, project, new ArrayList<Change>(), new HashMap<Change.Id, CodeReviewCommit>(), currentUser.getAccount());
        subOp.update();
    } catch (InsertException e) {
        log.error("Can't insert patchset", e);
    } catch (IOException e) {
        log.error("Can't scan for changes to close", e);
    } catch (OrmException e) {
        log.error("Can't scan for changes to close", e);
    } catch (SubmoduleException e) {
        log.error("Can't complete git links check", e);
    }
}
#method_after
private void autoCloseChanges(final ReceiveCommand cmd) {
    logDebug("Starting auto-closing of changes");
    String refName = cmd.getRefName();
    checkState(!MagicBranch.isMagicBranch(refName), "shouldn't be auto-closing changes on magic branch %s", refName);
    RevWalk rw = rp.getRevWalk();
    // insertChangesAndPatchSets.
    try (BatchUpdate bu = batchUpdateFactory.create(db, projectControl.getProject().getNameKey(), user, TimeUtil.nowTs());
        ObjectInserter ins = repo.newObjectInserter()) {
        bu.setRepository(repo, rp.getRevWalk(), ins).updateChangesInParallel();
        bu.setRequestId(receiveId);
        // TODO(dborowitz): Teach BatchUpdate to ignore missing changes.
        RevCommit newTip = rw.parseCommit(cmd.getNewId());
        Branch.NameKey branch = new Branch.NameKey(project.getNameKey(), refName);
        rw.reset();
        rw.markStart(newTip);
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        SetMultimap<ObjectId, Ref> byCommit = changeRefsById();
        Map<Change.Key, ChangeNotes> byKey = null;
        List<ReplaceRequest> replaceAndClose = new ArrayList<>();
        int existingPatchSets = 0;
        int newPatchSets = 0;
        COMMIT: for (RevCommit c; (c = rw.next()) != null; ) {
            rw.parseBody(c);
            for (Ref ref : byCommit.get(c.copy())) {
                existingPatchSets++;
                PatchSet.Id psId = PatchSet.Id.fromRef(ref.getName());
                bu.addOp(psId.getParentKey(), mergedByPushOpFactory.create(requestScopePropagator, psId, refName));
                continue COMMIT;
            }
            for (String changeId : c.getFooterLines(CHANGE_ID)) {
                if (byKey == null) {
                    byKey = openChangesByBranch(branch);
                }
                ChangeNotes onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    newPatchSets++;
                    // Hold onto this until we're done with the walk, as the call to
                    // req.validate below calls isMergedInto which resets the walk.
                    ReplaceRequest req = new ReplaceRequest(onto.getChangeId(), c, cmd, false);
                    req.notes = onto;
                    replaceAndClose.add(req);
                    continue COMMIT;
                }
            }
        }
        for (final ReplaceRequest req : replaceAndClose) {
            Change.Id id = req.notes.getChangeId();
            if (!req.validate(true)) {
                logDebug("Not closing {} because validation failed", id);
                continue;
            }
            req.addOps(bu, null);
            bu.addOp(id, mergedByPushOpFactory.create(requestScopePropagator, req.psId, refName).setPatchSetProvider(new Provider<PatchSet>() {

                @Override
                public PatchSet get() {
                    return req.replaceOp.getPatchSet();
                }
            }));
            bu.addOp(id, new ChangeProgressOp(closeProgress));
        }
        logDebug("Auto-closing {} changes with existing patch sets and {} with" + " new patch sets", existingPatchSets, newPatchSets);
        bu.execute();
    } catch (RestApiException e) {
        logError("Can't insert patchset", e);
    } catch (IOException | OrmException | UpdateException e) {
        logError("Can't scan for changes to close", e);
    }
}
#end_block

#method_before
private void reject(final ReceiveCommand cmd) {
    reject(cmd, "prohibited by Gerrit");
}
#method_after
private void reject(ReceiveCommand cmd) {
    reject(cmd, "prohibited by Gerrit");
}
#end_block

#method_before
private void reject(final ReceiveCommand cmd, final String why) {
    cmd.setResult(REJECTED_OTHER_REASON, why);
    commandProgress.update(1);
}
#method_after
private void reject(ReceiveCommand cmd, String why) {
    cmd.setResult(REJECTED_OTHER_REASON, why);
    commandProgress.update(1);
}
#end_block

#method_before
private static boolean isHead(final ReceiveCommand cmd) {
    return cmd.getRefName().startsWith(Constants.R_HEADS);
}
#method_after
private static boolean isHead(ReceiveCommand cmd) {
    return cmd.getRefName().startsWith(Constants.R_HEADS);
}
#end_block

#method_before
private static boolean isConfig(final ReceiveCommand cmd) {
    return cmd.getRefName().equals(RefNames.REFS_CONFIG);
}
#method_after
private static boolean isConfig(ReceiveCommand cmd) {
    return cmd.getRefName().equals(RefNames.REFS_CONFIG);
}
#end_block

#method_before
@Test
public void testUSER_NoPreferredEmailUser() {
    setFrom("USER");
    final String name = "A U. Thor";
    final Account.Id user = user(name, null);
    replay(accountCache);
    final Address r = create().from(user);
    assertThat(r).isNotNull();
    assertThat(r.name).isEqualTo(name);
    assertThat(r.email).isEqualTo(ident.getEmailAddress());
    verify(accountCache);
}
#method_after
@Test
public void testUSER_NoPreferredEmailUser() {
    setFrom("USER");
    final String name = "A U. Thor";
    final Account.Id user = user(name, null);
    replay(accountCache);
    final Address r = create().from(user);
    assertThat(r).isNotNull();
    assertThat(r.name).isEqualTo(name + " (Code Review)");
    assertThat(r.email).isEqualTo(ident.getEmailAddress());
    verify(accountCache);
}
#end_block

#method_before
@Test
public void testUSERAllowDomain() {
    setFrom("USER");
    setDomain(Arrays.asList("*.example.com"));
    final String name = "A U. Thor";
    final String email = "a.u.thor@test.example.com";
    final Account.Id user = user(name, email);
    replay(accountCache);
    final Address r = create().from(user);
    assertThat(r).isNotNull();
    assertThat(r.name).isEqualTo(name);
    assertThat(r.email).isEqualTo(email);
    verify(accountCache);
}
#method_after
@Test
public void testUSERAllowDomain() {
    setFrom("USER");
    setDomains(Arrays.asList("*.example.com"));
    final String name = "A U. Thor";
    final String email = "a.u.thor@test.example.com";
    final Account.Id user = user(name, email);
    replay(accountCache);
    final Address r = create().from(user);
    assertThat(r).isNotNull();
    assertThat(r.name).isEqualTo(name);
    assertThat(r.email).isEqualTo(email);
    verify(accountCache);
}
#end_block

#method_before
@Test
public void testUSERNoAllowDomain() {
    setFrom("USER");
    setDomain(Arrays.asList("example.com"));
    final String name = "A U. Thor";
    final String email = "a.u.thor@test.com";
    final Account.Id user = user(name, email);
    replay(accountCache);
    final Address r = create().from(user);
    assertThat(r).isNotNull();
    assertThat(r.name).isEqualTo(name);
    assertThat(r.email).isEqualTo(ident.getEmailAddress());
    verify(accountCache);
}
#method_after
@Test
public void testUSERNoAllowDomain() {
    setFrom("USER");
    setDomains(Arrays.asList("example.com"));
    final String name = "A U. Thor";
    final String email = "a.u.thor@test.com";
    final Account.Id user = user(name, email);
    replay(accountCache);
    final Address r = create().from(user);
    assertThat(r).isNotNull();
    assertThat(r.name).isEqualTo(name + " (Code Review)");
    assertThat(r.email).isEqualTo(ident.getEmailAddress());
    verify(accountCache);
}
#end_block

#method_before
@Override
public Address from(final Account.Id fromId) {
    if (fromId != null) {
        Account a = accountCache.get(fromId).getAccount();
        String userEmail = a.getPreferredEmail();
        return new Address(a.getFullName(), canRelay(domains, userEmail) ? userEmail : srvAddr.getEmail());
    }
    return srvAddr;
}
#method_after
@Override
public Address from(final Account.Id fromId) {
    String senderName;
    if (fromId != null) {
        Account a = accountCache.get(fromId).getAccount();
        String fullName = a.getFullName();
        String userEmail = a.getPreferredEmail();
        if (canRelay(userEmail)) {
            return new Address(fullName, userEmail);
        }
        if (fullName == null || "".equals(fullName.trim())) {
            fullName = anonymousCowardName;
        }
        senderName = nameRewriteTmpl.replace("user", fullName).toString();
    } else {
        senderName = serverAddress.name;
    }
    String senderEmail;
    ParameterizedString senderEmailPattern = new ParameterizedString(serverAddress.email);
    if (senderEmailPattern.getParameterNames().isEmpty()) {
        senderEmail = senderEmailPattern.getRawPattern();
    } else {
        senderEmail = senderEmailPattern.replace("userHash", hashOf(senderName)).toString();
    }
    return new Address(senderName, senderEmail);
}
#end_block

#method_before
private boolean canRelay(String[] domains, String userEmail) {
    if (userEmail == null) {
        return false;
    }
    int index = userEmail.indexOf("@");
    if (index == -1) {
        return false;
    }
    String userDomain = userEmail.substring(index + 1);
    for (String domain : domains) {
        // Support wildcard
        domain = Pattern.quote(domain).replace("*", "\\E.*\\Q");
        if (userDomain.matches(domain)) {
            return true;
        }
    }
    return false;
}
#method_after
private boolean canRelay(String userEmail) {
    if (userEmail != null) {
        int index = userEmail.indexOf('@');
        if (index > 0 && index < userEmail.length() - 1) {
            return domainPattern.matcher(userEmail.substring(index + 1)).matches();
        }
    }
    return false;
}
#end_block

#method_before
public void addApprovals(ReviewDb db, ChangeUpdate update, LabelTypes labelTypes, PatchSet ps, ChangeControl changeCtl, Map<String, Short> approvals) throws OrmException {
    Iterable<PatchSetApproval> cells = makeApprovals(update, labelTypes, ps, changeCtl, approvals);
    db.patchSetApprovals().insert(cells);
}
#method_after
public Iterable<PatchSetApproval> addApprovals(ReviewDb db, ChangeUpdate update, LabelTypes labelTypes, PatchSet ps, ChangeControl changeCtl, Map<String, Short> approvals) throws OrmException {
    if (approvals.isEmpty()) {
        return Collections.emptyList();
    }
    checkApprovals(approvals, changeCtl);
    List<PatchSetApproval> cells = new ArrayList<>(approvals.size());
    Date ts = update.getWhen();
    for (Map.Entry<String, Short> vote : approvals.entrySet()) {
        LabelType lt = labelTypes.byLabel(vote.getKey());
        cells.add(new PatchSetApproval(new PatchSetApproval.Key(ps.getId(), ps.getUploader(), lt.getLabelId()), vote.getValue(), ts));
    }
    for (PatchSetApproval psa : cells) {
        update.putApproval(psa.getLabel(), psa.getValue());
    }
    db.patchSetApprovals().insert(cells);
    return cells;
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, IOException {
    change = ctx.getChange();
    if (change == null || change.getStatus().isClosed()) {
        rejectMessage = CHANGE_IS_CLOSED;
        return false;
    }
    if (groups.isEmpty()) {
        PatchSet prevPs = psUtil.current(ctx.getDb(), ctx.getNotes());
        groups = prevPs != null ? prevPs.getGroups() : ImmutableList.<String>of();
    }
    ChangeUpdate update = ctx.getUpdate(patchSetId);
    update.setSubjectForCommit("Create patch set " + patchSetId.get());
    String reviewMessage = null;
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        reviewMessage = magicBranch.message;
        approvals.putAll(magicBranch.labels);
        Set<String> hashtags = magicBranch.hashtags;
        if (hashtags != null && !hashtags.isEmpty()) {
            hashtags.addAll(ctx.getNotes().getHashtags());
            update.setHashtags(hashtags);
        }
        if (magicBranch.topic != null && !magicBranch.topic.equals(ctx.getChange().getTopic())) {
            update.setTopic(magicBranch.topic);
        }
    }
    boolean draft = magicBranch != null && magicBranch.draft;
    if (change.getStatus() == Change.Status.DRAFT && !draft) {
        update.setStatus(Change.Status.NEW);
    }
    newPatchSet = psUtil.insert(ctx.getDb(), ctx.getRevWalk(), update, patchSetId, commit, draft, groups, pushCertificate != null ? pushCertificate.toTextWithSignature() : null);
    recipients.add(getRecipientsFromFooters(ctx.getDb(), accountResolver, draft, commit.getFooterLines()));
    recipients.remove(ctx.getAccountId());
    ChangeData cd = changeDataFactory.create(ctx.getDb(), ctx.getControl());
    MailRecipients oldRecipients = getRecipientsFromReviewers(cd.reviewers());
    Iterable<PatchSetApproval> incomingApprovals = approvalsUtil.makeApprovals(update, projectControl.getLabelTypes(), newPatchSet, ctx.getControl(), approvals);
    approvalCopier.copy(ctx.getDb(), ctx.getControl(), newPatchSet, incomingApprovals);
    approvalsUtil.addReviewers(ctx.getDb(), update, projectControl.getLabelTypes(), change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
    ctx.getDb().patchSetApprovals().insert(incomingApprovals);
    recipients.add(oldRecipients);
    String approvalMessage = ApprovalsUtil.renderMessageWithApprovals(patchSetId.get(), approvals, scanLabels(ctx, approvals));
    String kindMessage = changeKindMessage(changeKind);
    StringBuilder message = new StringBuilder(approvalMessage);
    if (!Strings.isNullOrEmpty(kindMessage)) {
        message.append(kindMessage);
    } else {
        message.append('.');
    }
    if (!Strings.isNullOrEmpty(reviewMessage)) {
        message.append("\n").append(reviewMessage);
    }
    msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(ctx.getDb())), ctx.getAccountId(), ctx.getWhen(), patchSetId);
    msg.setMessage(message.toString());
    cmUtil.addChangeMessage(ctx.getDb(), update, msg);
    if (mergedByPushOp == null) {
        resetChange(ctx, msg);
    } else {
        mergedByPushOp.setPatchSetProvider(Providers.of(newPatchSet)).updateChange(ctx);
    }
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, IOException {
    change = ctx.getChange();
    if (change == null || change.getStatus().isClosed()) {
        rejectMessage = CHANGE_IS_CLOSED;
        return false;
    }
    if (groups.isEmpty()) {
        PatchSet prevPs = psUtil.current(ctx.getDb(), ctx.getNotes());
        groups = prevPs != null ? prevPs.getGroups() : ImmutableList.<String>of();
    }
    ChangeUpdate update = ctx.getUpdate(patchSetId);
    update.setSubjectForCommit("Create patch set " + patchSetId.get());
    String reviewMessage = null;
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        reviewMessage = magicBranch.message;
        approvals.putAll(magicBranch.labels);
        Set<String> hashtags = magicBranch.hashtags;
        if (hashtags != null && !hashtags.isEmpty()) {
            hashtags.addAll(ctx.getNotes().getHashtags());
            update.setHashtags(hashtags);
        }
        if (magicBranch.topic != null && !magicBranch.topic.equals(ctx.getChange().getTopic())) {
            update.setTopic(magicBranch.topic);
        }
    }
    boolean draft = magicBranch != null && magicBranch.draft;
    if (change.getStatus() == Change.Status.DRAFT && !draft) {
        update.setStatus(Change.Status.NEW);
    }
    newPatchSet = psUtil.insert(ctx.getDb(), ctx.getRevWalk(), update, patchSetId, commit, draft, groups, pushCertificate != null ? pushCertificate.toTextWithSignature() : null);
    recipients.add(getRecipientsFromFooters(ctx.getDb(), accountResolver, draft, commit.getFooterLines()));
    recipients.remove(ctx.getAccountId());
    ChangeData cd = changeDataFactory.create(ctx.getDb(), ctx.getControl());
    MailRecipients oldRecipients = getRecipientsFromReviewers(cd.reviewers());
    Iterable<PatchSetApproval> newApprovals = approvalsUtil.addApprovals(ctx.getDb(), update, projectControl.getLabelTypes(), newPatchSet, ctx.getControl(), approvals);
    approvalCopier.copy(ctx.getDb(), ctx.getControl(), newPatchSet, newApprovals);
    approvalsUtil.addReviewers(ctx.getDb(), update, projectControl.getLabelTypes(), change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
    recipients.add(oldRecipients);
    String approvalMessage = ApprovalsUtil.renderMessageWithApprovals(patchSetId.get(), approvals, scanLabels(ctx, approvals));
    String kindMessage = changeKindMessage(changeKind);
    StringBuilder message = new StringBuilder(approvalMessage);
    if (!Strings.isNullOrEmpty(kindMessage)) {
        message.append(kindMessage);
    } else {
        message.append('.');
    }
    if (!Strings.isNullOrEmpty(reviewMessage)) {
        message.append("\n").append(reviewMessage);
    }
    msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(ctx.getDb())), ctx.getAccountId(), ctx.getWhen(), patchSetId);
    msg.setMessage(message.toString());
    cmUtil.addChangeMessage(ctx.getDb(), update, msg);
    if (mergedByPushOp == null) {
        resetChange(ctx, msg);
    } else {
        mergedByPushOp.setPatchSetProvider(Providers.of(newPatchSet)).updateChange(ctx);
    }
    return true;
}
#end_block

#method_before
@Test
public void pushNewPatchsetOverridingStickyLabel() throws Exception {
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    LabelType codeReview = Util.codeReview();
    codeReview.setCopyMaxScore(true);
    cfg.getLabelSections().put(codeReview.getName(), codeReview);
    PushOneCommit.Result r = pushTo("refs/for/master%l=Code-Review+2");
    r.assertOkStatus();
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "b.txt", "anotherContent", r.getChangeId());
    r = push.to("refs/for/master%l=Code-Review+1");
    r.assertOkStatus();
}
#method_after
@Test
public void pushNewPatchsetOverridingStickyLabel() throws Exception {
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    LabelType codeReview = Util.codeReview();
    codeReview.setCopyMaxScore(true);
    cfg.getLabelSections().put(codeReview.getName(), codeReview);
    saveProjectConfig(cfg);
    PushOneCommit.Result r = pushTo("refs/for/master%l=Code-Review+2");
    r.assertOkStatus();
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "b.txt", "anotherContent", r.getChangeId());
    r = push.to("refs/for/master%l=Code-Review+1");
    r.assertOkStatus();
}
#end_block

#method_before
public void copy(ReviewDb db, ChangeControl ctl, PatchSet ps) throws OrmException {
    Iterable<PatchSetApproval> incomingApprovals = Collections.emptyList();
    copy(db, ctl, ps, incomingApprovals);
}
#method_after
public void copy(ReviewDb db, ChangeControl ctl, PatchSet ps) throws OrmException {
    copy(db, ctl, ps, Collections.<PatchSetApproval>emptyList());
}
#end_block

#method_before
public void copy(ReviewDb db, ChangeControl ctl, PatchSet ps, Iterable<PatchSetApproval> incomingApprovals) throws OrmException {
    db.patchSetApprovals().insert(getForPatchSet(db, ctl, ps, incomingApprovals));
}
#method_after
public void copy(ReviewDb db, ChangeControl ctl, PatchSet ps, Iterable<PatchSetApproval> dontCopy) throws OrmException {
    db.patchSetApprovals().insert(getForPatchSet(db, ctl, ps, dontCopy));
}
#end_block

#method_before
Iterable<PatchSetApproval> getForPatchSet(ReviewDb db, ChangeControl ctl, PatchSet.Id psId) throws OrmException {
    Iterable<PatchSetApproval> incomingApprovals = Collections.emptyList();
    return getForPatchSet(db, ctl, psId, incomingApprovals);
}
#method_after
Iterable<PatchSetApproval> getForPatchSet(ReviewDb db, ChangeControl ctl, PatchSet.Id psId) throws OrmException {
    return getForPatchSet(db, ctl, psId, Collections.<PatchSetApproval>emptyList());
}
#end_block

#method_before
Iterable<PatchSetApproval> getForPatchSet(ReviewDb db, ChangeControl ctl, PatchSet.Id psId, Iterable<PatchSetApproval> incomingApprovals) throws OrmException {
    PatchSet ps = psUtil.get(db, ctl.getNotes(), psId);
    if (ps == null) {
        return Collections.emptyList();
    }
    return getForPatchSet(db, ctl, ps, incomingApprovals);
}
#method_after
Iterable<PatchSetApproval> getForPatchSet(ReviewDb db, ChangeControl ctl, PatchSet.Id psId, Iterable<PatchSetApproval> dontCopy) throws OrmException {
    PatchSet ps = psUtil.get(db, ctl.getNotes(), psId);
    if (ps == null) {
        return Collections.emptyList();
    }
    return getForPatchSet(db, ctl, ps, dontCopy);
}
#end_block

#method_before
private Iterable<PatchSetApproval> getForPatchSet(ReviewDb db, ChangeControl ctl, PatchSet ps, Iterable<PatchSetApproval> incomingApprovals) throws OrmException {
    checkNotNull(ps, "ps should not be null");
    ChangeData cd = changeDataFactory.create(db, ctl);
    try {
        ProjectState project = projectCache.checkedGet(cd.change().getDest().getParentKey());
        ListMultimap<PatchSet.Id, PatchSetApproval> all = cd.approvals();
        checkNotNull(all, "all should not be null");
        Table<String, Account.Id, PatchSetApproval> wontCopy = HashBasedTable.create();
        for (PatchSetApproval psa : incomingApprovals) {
            wontCopy.put(psa.getLabel(), psa.getAccountId(), psa);
        }
        Table<String, Account.Id, PatchSetApproval> byUser = HashBasedTable.create();
        for (PatchSetApproval psa : all.get(ps.getId())) {
            byUser.put(psa.getLabel(), psa.getAccountId(), psa);
        }
        TreeMap<Integer, PatchSet> patchSets = getPatchSets(cd);
        try (Repository repo = repoManager.openRepository(project.getProject().getNameKey())) {
            // Walk patch sets strictly less than current in descending order.
            Collection<PatchSet> allPrior = patchSets.descendingMap().tailMap(ps.getId().get(), false).values();
            for (PatchSet priorPs : allPrior) {
                List<PatchSetApproval> priorApprovals = all.get(priorPs.getId());
                if (priorApprovals.isEmpty()) {
                    continue;
                }
                ChangeKind kind = changeKindCache.getChangeKind(project, repo, ObjectId.fromString(priorPs.getRevision().get()), ObjectId.fromString(ps.getRevision().get()));
                for (PatchSetApproval psa : priorApprovals) {
                    if (wontCopy.contains(psa.getLabel(), psa.getAccountId())) {
                        continue;
                    }
                    if (byUser.contains(psa.getLabel(), psa.getAccountId())) {
                        continue;
                    }
                    if (!canCopy(project, psa, ps.getId(), kind)) {
                        wontCopy.put(psa.getLabel(), psa.getAccountId(), psa);
                        continue;
                    }
                    byUser.put(psa.getLabel(), psa.getAccountId(), copy(psa, ps.getId()));
                }
            }
            return labelNormalizer.normalize(ctl, byUser.values()).getNormalized();
        }
    } catch (IOException e) {
        throw new OrmException(e);
    }
}
#method_after
private Iterable<PatchSetApproval> getForPatchSet(ReviewDb db, ChangeControl ctl, PatchSet ps, Iterable<PatchSetApproval> dontCopy) throws OrmException {
    checkNotNull(ps, "ps should not be null");
    ChangeData cd = changeDataFactory.create(db, ctl);
    try {
        ProjectState project = projectCache.checkedGet(cd.change().getDest().getParentKey());
        ListMultimap<PatchSet.Id, PatchSetApproval> all = cd.approvals();
        checkNotNull(all, "all should not be null");
        Table<String, Account.Id, PatchSetApproval> wontCopy = HashBasedTable.create();
        for (PatchSetApproval psa : dontCopy) {
            wontCopy.put(psa.getLabel(), psa.getAccountId(), psa);
        }
        Table<String, Account.Id, PatchSetApproval> byUser = HashBasedTable.create();
        for (PatchSetApproval psa : all.get(ps.getId())) {
            if (!wontCopy.contains(psa.getLabel(), psa.getAccountId())) {
                byUser.put(psa.getLabel(), psa.getAccountId(), psa);
            }
        }
        TreeMap<Integer, PatchSet> patchSets = getPatchSets(cd);
        try (Repository repo = repoManager.openRepository(project.getProject().getNameKey())) {
            // Walk patch sets strictly less than current in descending order.
            Collection<PatchSet> allPrior = patchSets.descendingMap().tailMap(ps.getId().get(), false).values();
            for (PatchSet priorPs : allPrior) {
                List<PatchSetApproval> priorApprovals = all.get(priorPs.getId());
                if (priorApprovals.isEmpty()) {
                    continue;
                }
                ChangeKind kind = changeKindCache.getChangeKind(project, repo, ObjectId.fromString(priorPs.getRevision().get()), ObjectId.fromString(ps.getRevision().get()));
                for (PatchSetApproval psa : priorApprovals) {
                    if (wontCopy.contains(psa.getLabel(), psa.getAccountId())) {
                        continue;
                    }
                    if (byUser.contains(psa.getLabel(), psa.getAccountId())) {
                        continue;
                    }
                    if (!canCopy(project, psa, ps.getId(), kind)) {
                        wontCopy.put(psa.getLabel(), psa.getAccountId(), psa);
                        continue;
                    }
                    byUser.put(psa.getLabel(), psa.getAccountId(), copy(psa, ps.getId()));
                }
            }
            return labelNormalizer.normalize(ctl, byUser.values()).getNormalized();
        }
    } catch (IOException e) {
        throw new OrmException(e);
    }
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws AuthException, ResourceNotFoundException, OrmException {
    Account.Id reviewerId = reviewer.getId();
    currChange = ctx.getChange();
    currPs = psUtil.current(dbProvider.get(), ctx.getNotes());
    LabelTypes labelTypes = ctx.getControl().getLabelTypes();
    // removing a reviewer will remove all her votes
    for (LabelType lt : labelTypes.getLabelTypes()) {
        newApprovals.put(lt.getName(), (short) 0);
    }
    StringBuilder msg = new StringBuilder();
    for (PatchSetApproval a : approvals(ctx, reviewerId)) {
        if (ctx.getControl().canRemoveReviewer(a)) {
            del.add(a);
            if (a.getPatchSetId().equals(currPs.getId()) && a.getValue() != 0) {
                oldApprovals.put(a.getLabel(), a.getValue());
                if (msg.length() == 0) {
                    msg.append("Removed the following votes:\n\n");
                }
                msg.append("* ").append(a.getLabel()).append(formatLabelValue(a.getValue())).append(" by ").append(userFactory.create(a.getAccountId()).getNameEmail()).append("\n");
            }
        } else {
            throw new AuthException("delete not permitted");
        }
    }
    if (del.isEmpty()) {
        throw new ResourceNotFoundException();
    }
    msg.insert(0, "Removed the following reviewer: " + reviewer.getFullName() + "\n");
    ctx.getDb().patchSetApprovals().delete(del);
    ChangeUpdate update = ctx.getUpdate(currPs.getId());
    update.removeReviewer(reviewerId);
    changeMessage = new ChangeMessage(new ChangeMessage.Key(currChange.getId(), ChangeUtil.messageUUID(ctx.getDb())), ctx.getUser().getAccountId(), ctx.getWhen(), currPs.getId());
    changeMessage.setMessage(msg.toString());
    cmUtil.addChangeMessage(ctx.getDb(), update, changeMessage);
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws AuthException, ResourceNotFoundException, OrmException {
    Account.Id reviewerId = reviewer.getId();
    if (!approvalsUtil.getReviewers(ctx.getDb(), ctx.getNotes()).all().contains(reviewerId)) {
        throw new ResourceNotFoundException();
    }
    currChange = ctx.getChange();
    currPs = psUtil.current(ctx.getDb(), ctx.getNotes());
    LabelTypes labelTypes = ctx.getControl().getLabelTypes();
    // removing a reviewer will remove all her votes
    for (LabelType lt : labelTypes.getLabelTypes()) {
        newApprovals.put(lt.getName(), (short) 0);
    }
    StringBuilder msg = new StringBuilder();
    msg.append("Removed reviewer " + reviewer.getFullName());
    StringBuilder removedVotesMsg = new StringBuilder();
    removedVotesMsg.append(" with the following votes:\n\n");
    boolean votesRemoved = false;
    for (PatchSetApproval a : approvals(ctx, reviewerId)) {
        if (ctx.getControl().canRemoveReviewer(a)) {
            del.add(a);
            if (a.getPatchSetId().equals(currPs.getId()) && a.getValue() != 0) {
                oldApprovals.put(a.getLabel(), a.getValue());
                removedVotesMsg.append("* ").append(a.getLabel()).append(formatLabelValue(a.getValue())).append(" by ").append(userFactory.create(a.getAccountId()).getNameEmail()).append("\n");
                votesRemoved = true;
            }
        } else {
            throw new AuthException("delete reviewer not permitted");
        }
    }
    if (votesRemoved) {
        msg.append(removedVotesMsg);
    } else {
        msg.append(".");
    }
    ctx.getDb().patchSetApprovals().delete(del);
    ChangeUpdate update = ctx.getUpdate(currPs.getId());
    update.removeReviewer(reviewerId);
    changeMessage = new ChangeMessage(new ChangeMessage.Key(currChange.getId(), ChangeUtil.messageUUID(ctx.getDb())), ctx.getAccountId(), ctx.getWhen(), currPs.getId());
    changeMessage.setMessage(msg.toString());
    cmUtil.addChangeMessage(ctx.getDb(), update, changeMessage);
    return true;
}
#end_block

#method_before
@Override
public void postUpdate(Context ctx) {
    emailReviewers(ctx.getProject(), currChange, del, changeMessage);
    try {
        hooks.doReviewerDeletedHook(currChange, reviewer, currPs, changeMessage.getMessage(), newApprovals, oldApprovals, dbProvider.get());
    } catch (OrmException e) {
        log.warn("ChangeHook.doCommentAddedHook delivery failed", e);
    }
}
#method_after
@Override
public void postUpdate(Context ctx) {
    emailReviewers(ctx.getProject(), currChange, del, changeMessage);
    reviewerDeleted.fire(currChange, currPs, reviewer, ctx.getAccount(), changeMessage.getMessage(), newApprovals, oldApprovals, ctx.getWhen());
}
#end_block

#method_before
private Iterable<PatchSetApproval> approvals(ChangeContext ctx, final Account.Id accountId) throws OrmException {
    return Iterables.filter(approvalsUtil.byChange(ctx.getDb(), ctx.getNotes()).values(), new Predicate<PatchSetApproval>() {

        @Override
        public boolean apply(PatchSetApproval input) {
            return accountId.equals(input.getAccountId());
        }
    });
}
#method_after
private Iterable<PatchSetApproval> approvals(ChangeContext ctx, final Account.Id accountId) throws OrmException {
    Change.Id changeId = ctx.getNotes().getChangeId();
    Iterable<PatchSetApproval> approvals;
    if (migration.readChanges()) {
        // Because NoteDb and ReviewDb have different semantics for zero-value
        // approvals, we must fall back to ReviewDb as the source of truth here.
        ReviewDb db = ctx.getDb();
        if (db instanceof BatchUpdateReviewDb) {
            db = ((BatchUpdateReviewDb) db).unsafeGetDelegate();
        }
        db = ReviewDbUtil.unwrapDb(db);
        approvals = db.patchSetApprovals().byChange(changeId);
    } else {
        approvals = approvalsUtil.byChange(ctx.getDb(), ctx.getNotes()).values();
    }
    return Iterables.filter(approvals, new Predicate<PatchSetApproval>() {

        @Override
        public boolean apply(PatchSetApproval input) {
            return accountId.equals(input.getAccountId());
        }
    });
}
#end_block

#method_before
private String formatLabelValue(short value) {
    if (value > 0) {
        return "+" + value;
    } else {
        return Short.toString(value);
    }
}
#method_after
private String formatLabelValue(short value) {
    if (value > 0) {
        return "+" + value;
    }
    return Short.toString(value);
}
#end_block

#method_before
private void emailReviewers(Project.NameKey projectName, Change change, List<PatchSetApproval> dels, ChangeMessage changeMessage) {
    // The user knows they removed themselves, don't bother emailing them.
    List<Account.Id> toMail = Lists.newArrayListWithCapacity(dels.size());
    Account.Id userId = user.get().getAccountId();
    for (PatchSetApproval psa : dels) {
        if (!psa.getAccountId().equals(userId)) {
            toMail.add(psa.getAccountId());
        }
    }
    if (!toMail.isEmpty()) {
        try {
            DeleteReviewerSender cm = deleteReviewerSenderFactory.create(projectName, change.getId());
            cm.setFrom(userId);
            cm.addReviewers(toMail);
            cm.setChangeMessage(changeMessage);
            cm.send();
        } catch (Exception err) {
            log.error("Cannot email update for change " + change.getId(), err);
        }
    }
}
#method_after
private void emailReviewers(Project.NameKey projectName, Change change, List<PatchSetApproval> dels, ChangeMessage changeMessage) {
    // The user knows they removed themselves, don't bother emailing them.
    List<Account.Id> toMail = Lists.newArrayListWithCapacity(dels.size());
    Account.Id userId = user.get().getAccountId();
    for (PatchSetApproval psa : dels) {
        if (!psa.getAccountId().equals(userId)) {
            toMail.add(psa.getAccountId());
        }
    }
    if (!toMail.isEmpty()) {
        try {
            DeleteReviewerSender cm = deleteReviewerSenderFactory.create(projectName, change.getId());
            cm.setFrom(userId);
            cm.addReviewers(toMail);
            cm.setChangeMessage(changeMessage.getMessage(), changeMessage.getWrittenOn());
            cm.send();
        } catch (Exception err) {
            log.error("Cannot email update for change " + change.getId(), err);
        }
    }
}
#end_block

#method_before
@Override
public List<ValidationMessage> onRefOperation(RefOperationReceivedEvent event) throws ValidationException {
    ArrayList<ValidationMessage> messages = Lists.newArrayList();
    if (event.command.getRefName().startsWith("invalidate-")) {
        throw new ValidationException(String.format("Invalid ref's %s %s operation in project was performed!", event.command.getRefName(), event.command.getType(), event.project.getName()));
    }
    return messages;
}
#method_after
@Override
public List<ValidationMessage> onRefOperation(RefReceivedEvent event) throws ValidationException {
    ArrayList<ValidationMessage> messages = Lists.newArrayList();
    if (event.command.getRefName().startsWith(RefNames.REFS_HEADS + "protected-") && !event.user.getCapabilities().canAdministrateServer()) {
        throw new ValidationException(String.format("Operation %s on %s branch in project %s is not valid!", event.command.getType(), event.command.getRefName(), event.project.getName()));
    }
    return messages;
}
#end_block

#method_before
@Override
protected void configure() {
    DynamicSet.bind(binder(), TopMenu.class).to(HelloTopMenu.class);
    DynamicSet.bind(binder(), PatchSetWebLink.class).to(HelloWeblink.class);
    DynamicSet.bind(binder(), ProjectWebLink.class).to(HelloWeblink.class);
    DynamicSet.bind(binder(), ServerPluginProvider.class).to(HelloSshPluginProvider.class);
    DynamicSet.bind(binder(), UsageDataPublishedListener.class).to(UsageDataLogger.class);
    install(new RestApiModule() {

        @Override
        protected void configure() {
            post(REVISION_KIND, "hello-revision").to(HelloRevisionAction.class);
            post(PROJECT_KIND, "hello-project").to(HelloProjectAction.class);
            get(REVISION_KIND, "greetings").to(Greetings.class);
        }
    });
    DynamicSet.bind(binder(), UploadValidationListener.class).to(DenyUploadExample.class);
    DynamicSet.bind(binder(), RefOperationValidationListener.class).to(RefOperationValidationExample.class);
    configurePluginParameters();
}
#method_after
@Override
protected void configure() {
    DynamicSet.bind(binder(), TopMenu.class).to(HelloTopMenu.class);
    DynamicSet.bind(binder(), PatchSetWebLink.class).to(HelloWeblink.class);
    DynamicSet.bind(binder(), ProjectWebLink.class).to(HelloWeblink.class);
    DynamicSet.bind(binder(), BranchWebLink.class).to(HelloWeblink.class);
    DynamicSet.bind(binder(), FileHistoryWebLink.class).to(HelloWeblink.class);
    DynamicSet.bind(binder(), ServerPluginProvider.class).to(HelloSshPluginProvider.class);
    DynamicSet.bind(binder(), UsageDataPublishedListener.class).to(UsageDataLogger.class);
    DynamicSet.bind(binder(), LifecycleListener.class).to(ConsoleMetricReporter.class);
    install(new RestApiModule() {

        @Override
        protected void configure() {
            post(REVISION_KIND, "hello-revision").to(HelloRevisionAction.class);
            post(PROJECT_KIND, "hello-project").to(HelloProjectAction.class);
            get(REVISION_KIND, "greetings").to(Greetings.class);
        }
    });
    DynamicSet.bind(binder(), UploadValidationListener.class).to(DenyUploadExample.class);
    DynamicSet.bind(binder(), MergeValidationListener.class).to(MergeUserValidator.class);
    DynamicSet.bind(binder(), HashtagValidationListener.class).to(HashtagValidator.class);
    DynamicSet.bind(binder(), CommitValidationListener.class).to(CommitValidator.class);
    DynamicSet.bind(binder(), NewProjectCreatedListener.class).to(ProjectCreatedListener.class);
    DynamicSet.bind(binder(), RefOperationValidationListener.class).to(RefOperationValidationExample.class);
    configurePluginParameters();
    DynamicSet.bind(binder(), ExternalIncludedIn.class).to(DeployedOnIncludedInExtension.class);
    bind(ChangeOperatorFactory.class).annotatedWith(Exports.named("sample")).to(SampleOperator.class);
    DynamicSet.bind(binder(), WebUiPlugin.class).toInstance(new JavaScriptPlugin("greetings.js"));
    DynamicSet.bind(binder(), WebUiPlugin.class).toInstance(new JavaScriptPlugin("hello-change.js"));
    DynamicSet.bind(binder(), WebUiPlugin.class).toInstance(new JavaScriptPlugin("hello-project.js"));
    DynamicSet.bind(binder(), WebUiPlugin.class).toInstance(new JavaScriptPlugin("hello-revision.js"));
    DynamicSet.bind(binder(), WebUiPlugin.class).toInstance(new GwtPlugin("cookbook"));
}
#end_block

#method_before
private void configurePluginParameters() {
    bind(ProjectConfigEntry.class).annotatedWith(Exports.named("enable-hello")).toInstance(new ProjectConfigEntry("Enable Greeting", true));
    bind(ProjectConfigEntry.class).annotatedWith(Exports.named("enable-goodbye")).toInstance(new ProjectConfigEntry("Enable Say Goodbye", InheritableBoolean.TRUE, InheritableBoolean.class, true));
    bind(ProjectConfigEntry.class).annotatedWith(Exports.named("default-greeting")).toInstance(new ProjectConfigEntry("Default Greeting", "Hey dude, how are you?", true));
    bind(ProjectConfigEntry.class).annotatedWith(Exports.named("language")).toInstance(new ProjectConfigEntry("Preferred Language", "en", ImmutableList.of("en", "de", "fr"), true));
    bind(ProjectConfigEntry.class).annotatedWith(Exports.named("greet-number-per-week")).toInstance(new ProjectConfigEntry("Greets Per Week", 42, true));
    bind(ProjectConfigEntry.class).annotatedWith(Exports.named("greet-number-per-year")).toInstance(new ProjectConfigEntry("Greets Per Year", 4711L, true));
    bind(ProjectConfigEntry.class).annotatedWith(Exports.named("reviewers")).toInstance(new ProjectConfigEntry("Reviewers", null, ProjectConfigEntry.Type.ARRAY, null, false, "Users or groups can be provided as reviewers"));
}
#method_after
private void configurePluginParameters() {
    bind(ProjectConfigEntry.class).annotatedWith(Exports.named("enable-hello")).toInstance(new ProjectConfigEntry("Enable Greeting", true));
    bind(ProjectConfigEntry.class).annotatedWith(Exports.named("enable-goodbye")).toInstance(new ProjectConfigEntry("Enable Say Goodbye", InheritableBoolean.TRUE, InheritableBoolean.class, true));
    bind(ProjectConfigEntry.class).annotatedWith(Exports.named("default-greeting")).toInstance(new ProjectConfigEntry("Default Greeting", "Hey dude, how are you?", true));
    bind(ProjectConfigEntry.class).annotatedWith(Exports.named("language")).toInstance(new ProjectConfigEntry("Preferred Language", "en", ImmutableList.of("en", "de", "fr"), true));
    bind(ProjectConfigEntry.class).annotatedWith(Exports.named("greet-number-per-week")).toInstance(new ProjectConfigEntry("Greets Per Week", 42, true));
    bind(ProjectConfigEntry.class).annotatedWith(Exports.named("greet-number-per-year")).toInstance(new ProjectConfigEntry("Greets Per Year", 4711L, true));
    bind(ProjectConfigEntry.class).annotatedWith(Exports.named("reviewers")).toInstance(new ProjectConfigEntry("Reviewers", null, ProjectConfigEntryType.ARRAY, null, false, "Users or groups can be provided as reviewers"));
}
#end_block

#method_before
@Provides
@Singleton
@Named(POLYGERRIT_INDEX_SERVLET)
HttpServlet getPolyGerritUiIndexServlet(@Named(CACHE) Cache<Path, Resource> cache) {
    return new SingleFileServlet(cache, polyGerritBasePath().resolve("index.html"), true, true);
}
#method_after
@Provides
@Singleton
@Named(POLYGERRIT_INDEX_SERVLET)
HttpServlet getPolyGerritUiIndexServlet(@Named(CACHE) Cache<Path, Resource> cache) {
    return new SingleFileServlet(cache, polyGerritBasePath().resolve("index.html"), getPaths().isDev(), false);
}
#end_block

#method_before
@Override
protected void doGet(HttpServletRequest req, HttpServletResponse rsp) throws IOException {
    String name;
    if (req.getPathInfo() == null) {
        name = "/";
    } else {
        name = CharMatcher.is('/').trimFrom(req.getPathInfo());
    }
    if (isUnreasonableName(name)) {
        notFound(rsp);
        return;
    }
    Path p = getResourcePath(name);
    if (p == null) {
        notFound(rsp);
        return;
    }
    Resource r = cache.getIfPresent(p);
    try {
        if (r == null) {
            if (maybeStream(p, req, rsp)) {
                // Bypass cache for large resource.
                return;
            }
            r = cache.get(p, newLoader(p));
        }
        if (noClientCache) {
            CacheHeaders.setNotCacheable(rsp);
        }
        if (refresh && r.isStale(p, this)) {
            cache.invalidate(p);
            r = cache.get(p, newLoader(p));
        }
    } catch (ExecutionException e) {
        log.warn("Cannot load static resource " + req.getPathInfo(), e);
        CacheHeaders.setNotCacheable(rsp);
        rsp.setStatus(SC_INTERNAL_SERVER_ERROR);
        return;
    }
    if (r == Resource.NOT_FOUND) {
        // Cached not found response.
        notFound(rsp);
        return;
    }
    String e = req.getParameter("e");
    if (e != null && !r.etag.equals(e)) {
        CacheHeaders.setNotCacheable(rsp);
        rsp.setStatus(SC_NOT_FOUND);
        return;
    } else if (r.etag.equals(req.getHeader(IF_NONE_MATCH))) {
        rsp.setStatus(SC_NOT_MODIFIED);
        return;
    }
    byte[] tosend = r.raw;
    if (!r.contentType.equals(JS) && RPCServletUtils.acceptsGzipEncoding(req)) {
        byte[] gz = HtmlDomUtil.compress(tosend);
        if ((gz.length + 24) < tosend.length) {
            rsp.setHeader(CONTENT_ENCODING, "gzip");
            tosend = gz;
        }
    }
    if (!CacheHeaders.hasCacheHeader(rsp)) {
        if (e != null && r.etag.equals(e)) {
            CacheHeaders.setCacheable(req, rsp, 360, DAYS, false);
        } else {
            CacheHeaders.setCacheable(req, rsp, 15, MINUTES, refresh);
        }
    }
    if (!noClientCache) {
        rsp.setHeader(ETAG, r.etag);
    }
    rsp.setContentType(r.contentType);
    rsp.setContentLength(tosend.length);
    try (OutputStream out = rsp.getOutputStream()) {
        out.write(tosend);
    }
}
#method_after
@Override
protected void doGet(HttpServletRequest req, HttpServletResponse rsp) throws IOException {
    String name;
    if (req.getPathInfo() == null) {
        name = "/";
    } else {
        name = CharMatcher.is('/').trimFrom(req.getPathInfo());
    }
    if (isUnreasonableName(name)) {
        notFound(rsp);
        return;
    }
    Path p = getResourcePath(name);
    if (p == null) {
        notFound(rsp);
        return;
    }
    Resource r = cache.getIfPresent(p);
    try {
        if (r == null) {
            if (maybeStream(p, req, rsp)) {
                // Bypass cache for large resource.
                return;
            }
            r = cache.get(p, newLoader(p));
        }
        if (refresh && r.isStale(p, this)) {
            cache.invalidate(p);
            r = cache.get(p, newLoader(p));
        }
    } catch (ExecutionException e) {
        log.warn("Cannot load static resource " + req.getPathInfo(), e);
        CacheHeaders.setNotCacheable(rsp);
        rsp.setStatus(SC_INTERNAL_SERVER_ERROR);
        return;
    }
    if (r == Resource.NOT_FOUND) {
        // Cached not found response.
        notFound(rsp);
        return;
    }
    String e = req.getParameter("e");
    if (e != null && !r.etag.equals(e)) {
        CacheHeaders.setNotCacheable(rsp);
        rsp.setStatus(SC_NOT_FOUND);
        return;
    } else if (cacheOnClient && r.etag.equals(req.getHeader(IF_NONE_MATCH))) {
        rsp.setStatus(SC_NOT_MODIFIED);
        return;
    }
    byte[] tosend = r.raw;
    if (!r.contentType.equals(JS) && RPCServletUtils.acceptsGzipEncoding(req)) {
        byte[] gz = HtmlDomUtil.compress(tosend);
        if ((gz.length + 24) < tosend.length) {
            rsp.setHeader(CONTENT_ENCODING, "gzip");
            tosend = gz;
        }
    }
    if (cacheOnClient) {
        rsp.setHeader(ETAG, r.etag);
    } else {
        CacheHeaders.setNotCacheable(rsp);
    }
    if (!CacheHeaders.hasCacheHeader(rsp)) {
        if (e != null && r.etag.equals(e)) {
            CacheHeaders.setCacheable(req, rsp, 360, DAYS, false);
        } else {
            CacheHeaders.setCacheable(req, rsp, 15, MINUTES, refresh);
        }
    }
    rsp.setContentType(r.contentType);
    rsp.setContentLength(tosend.length);
    try (OutputStream out = rsp.getOutputStream()) {
        out.write(tosend);
    }
}
#end_block

#method_before
@Test
public void checkAlreadyMergedCommit() throws Exception {
    ObjectId c0 = testRepo.branch("HEAD").commit().insertChangeId().message("first commit").add("a.txt", "a contents ").create();
    testRepo.git().push().setRemote("origin").setRefSpecs(new RefSpec("HEAD:refs/heads/master")).call();
    testRepo.branch("HEAD").commit().insertChangeId().message("second commit").add("b.txt", "b contents ").create();
    testRepo.git().push().setRemote("origin").setRefSpecs(new RefSpec("HEAD:refs/heads/master")).call();
    assertAlreadyMerged("master", c0.getName(), "");
}
#method_after
@Test
public void checkAlreadyMergedCommit() throws Exception {
    ObjectId c0 = testRepo.branch("HEAD").commit().insertChangeId().message("first commit").add("a.txt", "a contents ").create();
    testRepo.git().push().setRemote("origin").setRefSpecs(new RefSpec("HEAD:refs/heads/master")).call();
    testRepo.branch("HEAD").commit().insertChangeId().message("second commit").add("b.txt", "b contents ").create();
    testRepo.git().push().setRemote("origin").setRefSpecs(new RefSpec("HEAD:refs/heads/master")).call();
    assertCommitMerged("master", c0.getName(), "");
}
#end_block

#method_before
@Test
@TestProjectInput(submitType = SubmitType.CHERRY_PICK)
public void checkContentMergedCommit() throws Exception {
    testRepo.branch("HEAD").commit().insertChangeId().message("first commit").add("a.txt", "a contents ").create();
    testRepo.git().push().setRemote("origin").setRefSpecs(new RefSpec("HEAD:refs/heads/master")).call();
    // create a change, and cherrypick into master
    PushOneCommit.Result cId = createChange();
    approve(cId.getChangeId());
    RevCommit commitId = cId.getCommit();
    gApi.changes().id(cId.getChangeId()).current().submit();
    ObjectId remoteId = getRemoteHead();
    assertThat(remoteId).isNotEqualTo(commitId);
    assertMergeable("master", commitId.getName(), "recursive");
}
#method_after
@Test
public void checkContentMergedCommit() throws Exception {
    testRepo.branch("HEAD").commit().insertChangeId().message("first commit").add("a.txt", "a contents ").create();
    testRepo.git().push().setRemote("origin").setRefSpecs(new RefSpec("HEAD:refs/heads/master")).call();
    // create a change, and cherrypick into master
    PushOneCommit.Result cId = createChange();
    RevCommit commitId = cId.getCommit();
    CherryPickInput cpi = new CherryPickInput();
    cpi.destination = "master";
    cpi.message = "cherry pick the commit";
    ChangeApi orig = gApi.changes().id(cId.getChangeId());
    ChangeApi cherry = orig.current().cherryPick(cpi);
    cherry.current().review(ReviewInput.approve());
    cherry.current().submit();
    ObjectId remoteId = getRemoteHead();
    assertThat(remoteId).isNotEqualTo(commitId);
    assertContentMerged("master", commitId.getName(), "recursive");
}
#end_block

#method_before
@Test
public void checkInvalidSource() throws Exception {
    testRepo.branch("HEAD").commit().insertChangeId().message("first commit").add("a.txt", "a contents ").create();
    testRepo.git().push().setRemote("origin").setRefSpecs(new RefSpec("HEAD:refs/heads/master")).call();
    assertBadRequest("master", "fdsafsdf", "recursive", "Cannot resolve 'fdsafsdf' into a commit");
}
#method_after
@Test
public void checkInvalidSource() throws Exception {
    testRepo.branch("HEAD").commit().insertChangeId().message("first commit").add("a.txt", "a contents ").create();
    testRepo.git().push().setRemote("origin").setRefSpecs(new RefSpec("HEAD:refs/heads/master")).call();
    assertBadRequest("master", "fdsafsdf", "recursive", "Cannot resolve 'fdsafsdf' to a commit");
}
#end_block

#method_before
private void assertUnMergeable(String targetBranch, String source, String strategy, String... conflicts) throws Exception {
    MergeableInfo mergeableInfo = getMergeableInfo(targetBranch, source, strategy);
    assertThat(mergeableInfo.mergeable).isFalse();
    assertThat(mergeableInfo.conflicts).containsExactly(conflicts);
}
#method_after
private void assertUnMergeable(String targetBranch, String source, String strategy, String... conflicts) throws Exception {
    MergeableInfo mergeableInfo = getMergeableInfo(targetBranch, source, strategy);
    assertThat(mergeableInfo.mergeable).isFalse();
    assertThat(mergeableInfo.conflicts).containsExactly((Object[]) conflicts);
}
#end_block

#method_before
public static RevCommit createMergeCommit(Repository repo, ObjectInserter inserter, RevCommit mergeTip, RevCommit originalCommit, String mergeStrategy, PersonIdent committerIndent, String commitMsg, RevWalk rw) throws IOException, MergeIdenticalTreeException, MergeConflictException {
    if (rw.isMergedInto(originalCommit, mergeTip)) {
        throw new ChangeAlreadyMergedException("'" + originalCommit.getName() + "' has already been merged!");
    }
    Merger m = newMerger(repo, inserter, mergeStrategy);
    if (m.merge(false, mergeTip, originalCommit)) {
        ObjectId tree = m.getResultTreeId();
        CommitBuilder mergeCommit = new CommitBuilder();
        mergeCommit.setTreeId(tree);
        mergeCommit.setParentIds(mergeTip, originalCommit);
        mergeCommit.setAuthor(committerIndent);
        mergeCommit.setCommitter(committerIndent);
        mergeCommit.setMessage(commitMsg);
        return rw.parseCommit(inserter.insert(mergeCommit));
    }
    List<String> conflicts = ImmutableList.of();
    if (m instanceof ResolveMerger) {
        conflicts = ((ResolveMerger) m).getUnmergedPaths();
    }
    throw new MergeConflictException(createConflictMessage(conflicts));
}
#method_after
public static RevCommit createMergeCommit(Repository repo, ObjectInserter inserter, RevCommit mergeTip, RevCommit originalCommit, String mergeStrategy, PersonIdent committerIndent, String commitMsg, RevWalk rw) throws IOException, MergeIdenticalTreeException, MergeConflictException {
    if (rw.isMergedInto(originalCommit, mergeTip)) {
        throw new ChangeAlreadyMergedException("'" + originalCommit.getName() + "' has already been merged");
    }
    Merger m = newMerger(repo, inserter, mergeStrategy);
    if (m.merge(false, mergeTip, originalCommit)) {
        ObjectId tree = m.getResultTreeId();
        CommitBuilder mergeCommit = new CommitBuilder();
        mergeCommit.setTreeId(tree);
        mergeCommit.setParentIds(mergeTip, originalCommit);
        mergeCommit.setAuthor(committerIndent);
        mergeCommit.setCommitter(committerIndent);
        mergeCommit.setMessage(commitMsg);
        return rw.parseCommit(inserter.insert(mergeCommit));
    }
    List<String> conflicts = ImmutableList.of();
    if (m instanceof ResolveMerger) {
        conflicts = ((ResolveMerger) m).getUnmergedPaths();
    }
    throw new MergeConflictException(createConflictMessage(conflicts));
}
#end_block

#method_before
public static RevCommit resolveCommit(Repository repo, RevWalk rw, String str) throws BadRequestException, ResourceNotFoundException, IOException {
    try {
        ObjectId commitId = repo.resolve(str);
        if (commitId == null) {
            throw new BadRequestException("Cannot resolve '" + str + "' into a commit");
        }
        return rw.parseCommit(commitId);
    } catch (AmbiguousObjectException | IncorrectObjectTypeException | RevisionSyntaxException e) {
        throw new BadRequestException(e.getMessage());
    } catch (MissingObjectException e) {
        throw new ResourceNotFoundException(e.getMessage());
    }
}
#method_after
public static RevCommit resolveCommit(Repository repo, RevWalk rw, String str) throws BadRequestException, ResourceNotFoundException, IOException {
    try {
        ObjectId commitId = repo.resolve(str);
        if (commitId == null) {
            throw new BadRequestException("Cannot resolve '" + str + "' to a commit");
        }
        return rw.parseCommit(commitId);
    } catch (AmbiguousObjectException | IncorrectObjectTypeException | RevisionSyntaxException e) {
        throw new BadRequestException(e.getMessage());
    } catch (MissingObjectException e) {
        throw new ResourceNotFoundException(e.getMessage());
    }
}
#end_block

#method_before
@Test
public void invalidSource() throws Exception {
    changeInTwoBranches("branchA", "a.txt", "branchB", "b.txt");
    ChangeInput in = newMergeChangeInput("branchA", "invalid", "");
    assertCreateFails(in, BadRequestException.class, "Cannot resolve 'invalid' into a commit");
}
#method_after
@Test
public void invalidSource() throws Exception {
    changeInTwoBranches("branchA", "a.txt", "branchB", "b.txt");
    ChangeInput in = newMergeChangeInput("branchA", "invalid", "");
    assertCreateFails(in, BadRequestException.class, "Cannot resolve 'invalid' to a commit");
}
#end_block

#method_before
@Test
public void alreadyMerged() throws Exception {
    ObjectId c0 = testRepo.branch("HEAD").commit().insertChangeId().message("first commit").add("a.txt", "a contents ").create();
    testRepo.git().push().setRemote("origin").setRefSpecs(new RefSpec("HEAD:refs/heads/master")).call();
    testRepo.branch("HEAD").commit().insertChangeId().message("second commit").add("b.txt", "b contents ").create();
    testRepo.git().push().setRemote("origin").setRefSpecs(new RefSpec("HEAD:refs/heads/master")).call();
    ChangeInput in = newMergeChangeInput("master", c0.getName(), "");
    assertCreateFails(in, BadRequestException.class, "'" + c0.getName() + "' has already been merged!");
}
#method_after
@Test
public void alreadyMerged() throws Exception {
    ObjectId c0 = testRepo.branch("HEAD").commit().insertChangeId().message("first commit").add("a.txt", "a contents ").create();
    testRepo.git().push().setRemote("origin").setRefSpecs(new RefSpec("HEAD:refs/heads/master")).call();
    testRepo.branch("HEAD").commit().insertChangeId().message("second commit").add("b.txt", "b contents ").create();
    testRepo.git().push().setRemote("origin").setRefSpecs(new RefSpec("HEAD:refs/heads/master")).call();
    ChangeInput in = newMergeChangeInput("master", c0.getName(), "");
    assertCreateFails(in, ChangeAlreadyMergedException.class, "'" + c0.getName() + "' has already been merged");
}
#end_block

#method_before
@Test
@TestProjectInput(submitType = SubmitType.CHERRY_PICK)
public void onlyContentMerged() throws Exception {
    testRepo.branch("HEAD").commit().insertChangeId().message("first commit").add("a.txt", "a contents ").create();
    testRepo.git().push().setRemote("origin").setRefSpecs(new RefSpec("HEAD:refs/heads/master")).call();
    // create a change, and cherrypick into master
    PushOneCommit.Result cId = createChange();
    approve(cId.getChangeId());
    RevCommit commitId = cId.getCommit();
    gApi.changes().id(cId.getChangeId()).current().submit();
    ObjectId remoteId = getRemoteHead();
    assertThat(remoteId).isNotEqualTo(commitId);
    ChangeInput in = newMergeChangeInput("master", commitId.getName(), "");
    assertCreateSucceeds(in);
}
#method_after
@Test
public void onlyContentMerged() throws Exception {
    testRepo.branch("HEAD").commit().insertChangeId().message("first commit").add("a.txt", "a contents ").create();
    testRepo.git().push().setRemote("origin").setRefSpecs(new RefSpec("HEAD:refs/heads/master")).call();
    // create a change, and cherrypick into master
    PushOneCommit.Result cId = createChange();
    RevCommit commitId = cId.getCommit();
    CherryPickInput cpi = new CherryPickInput();
    cpi.destination = "master";
    cpi.message = "cherry pick the commit";
    ChangeApi orig = gApi.changes().id(cId.getChangeId());
    ChangeApi cherry = orig.current().cherryPick(cpi);
    cherry.current().review(ReviewInput.approve());
    cherry.current().submit();
    ObjectId remoteId = getRemoteHead();
    assertThat(remoteId).isNotEqualTo(commitId);
    ChangeInput in = newMergeChangeInput("master", commitId.getName(), "");
    assertCreateSucceeds(in);
}
#end_block

#method_before
private void changeInTwoBranches(String branchA, String fileA, String branchB, String fileB) throws Exception {
    // create a initial commit in master
    Result initialCommit = pushFactory.create(db, user.getIdent(), testRepo, "initial commit", "readme.txt", "initial commit").to("refs/heads/master");
    initialCommit.assertOkStatus();
    // create a new branch branchA
    createBranch(new Branch.NameKey(project, branchA));
    createBranch(new Branch.NameKey(project, branchB));
    // create a commit in branchA
    Result changeA = pushFactory.create(db, user.getIdent(), testRepo, "change A", fileA, "A content").to("refs/heads/" + branchA);
    changeA.assertOkStatus();
    // create a commit in branchB
    PushOneCommit commitB = pushFactory.create(db, user.getIdent(), testRepo, "change B", fileB, "B content");
    commitB.setParent(initialCommit.getCommit());
    Result changeB = commitB.to("refs/heads/" + branchB);
    changeB.assertOkStatus();
}
#method_after
private void changeInTwoBranches(String branchA, String fileA, String branchB, String fileB) throws Exception {
    // create a initial commit in master
    Result initialCommit = pushFactory.create(db, user.getIdent(), testRepo, "initial commit", "readme.txt", "initial commit").to("refs/heads/master");
    initialCommit.assertOkStatus();
    // create two new branches
    createBranch(new Branch.NameKey(project, branchA));
    createBranch(new Branch.NameKey(project, branchB));
    // create a commit in branchA
    Result changeA = pushFactory.create(db, user.getIdent(), testRepo, "change A", fileA, "A content").to("refs/heads/" + branchA);
    changeA.assertOkStatus();
    // create a commit in branchB
    PushOneCommit commitB = pushFactory.create(db, user.getIdent(), testRepo, "change B", fileB, "B content");
    commitB.setParent(initialCommit.getCommit());
    Result changeB = commitB.to("refs/heads/" + branchB);
    changeB.assertOkStatus();
}
#end_block

#method_before
@Override
public MergeableInfo apply(BranchResource resource) throws IOException, BadRequestException, ResourceNotFoundException {
    MergeableInfo result = new MergeableInfo();
    result.strategy = strategy;
    try (Repository git = gitManager.openRepository(resource.getNameKey());
        RevWalk rw = new RevWalk(git);
        ObjectInserter inserter = new InMemoryInserter(git)) {
        Merger m = MergeUtil.newMerger(git, inserter, strategy);
        Ref destRef = git.getRefDatabase().exactRef(resource.getRef());
        if (destRef == null) {
            throw new ResourceNotFoundException(resource.getRef());
        }
        RevCommit targetCommit = rw.parseCommit(destRef.getObjectId());
        RevCommit sourceCommit = MergeUtil.resolveCommit(git, rw, source);
        if (!resource.getControl().canReadCommit(db.get(), git, sourceCommit)) {
            throw new BadRequestException("Do not have read permission for: " + source);
        }
        if (rw.isMergedInto(sourceCommit, targetCommit)) {
            throw new ChangeAlreadyMergedException("'" + source + "' has already been merged!");
        }
        result.mergeable = m.merge(false, targetCommit, sourceCommit);
        if (m instanceof ResolveMerger) {
            result.conflicts = ((ResolveMerger) m).getUnmergedPaths();
        }
    } catch (IllegalArgumentException e) {
        throw new BadRequestException(e.getMessage());
    }
    return result;
}
#method_after
@Override
public MergeableInfo apply(BranchResource resource) throws IOException, BadRequestException, ResourceNotFoundException {
    if (!(submitType.equals(SubmitType.MERGE_ALWAYS) || submitType.equals(SubmitType.MERGE_IF_NECESSARY))) {
        throw new BadRequestException("Submit type: " + submitType + " is not supported");
    }
    MergeableInfo result = new MergeableInfo();
    result.submitType = submitType;
    result.strategy = strategy;
    try (Repository git = gitManager.openRepository(resource.getNameKey());
        RevWalk rw = new RevWalk(git);
        ObjectInserter inserter = new InMemoryInserter(git)) {
        Merger m = MergeUtil.newMerger(git, inserter, strategy);
        Ref destRef = git.getRefDatabase().exactRef(resource.getRef());
        if (destRef == null) {
            throw new ResourceNotFoundException(resource.getRef());
        }
        RevCommit targetCommit = rw.parseCommit(destRef.getObjectId());
        RevCommit sourceCommit = MergeUtil.resolveCommit(git, rw, source);
        if (!resource.getControl().canReadCommit(db.get(), git, sourceCommit)) {
            throw new BadRequestException("do not have read permission for: " + source);
        }
        if (rw.isMergedInto(sourceCommit, targetCommit)) {
            result.mergeable = true;
            result.commitMerged = true;
            result.contentMerged = true;
            return result;
        }
        if (m.merge(false, targetCommit, sourceCommit)) {
            result.mergeable = true;
            result.commitMerged = false;
            result.contentMerged = m.getResultTreeId().equals(targetCommit.getTree());
        } else {
            result.mergeable = false;
            if (m instanceof ResolveMerger) {
                result.conflicts = ((ResolveMerger) m).getUnmergedPaths();
            }
        }
    } catch (IllegalArgumentException e) {
        throw new BadRequestException(e.getMessage());
    }
    return result;
}
#end_block

#method_before
@Override
public Response<ChangeInfo> apply(TopLevelResource parent, ChangeInput input) throws OrmException, IOException, InvalidChangeOperationException, RestApiException, UpdateException {
    if (Strings.isNullOrEmpty(input.project)) {
        throw new BadRequestException("project must be non-empty");
    }
    if (Strings.isNullOrEmpty(input.branch)) {
        throw new BadRequestException("branch must be non-empty");
    }
    if (Strings.isNullOrEmpty(input.subject)) {
        throw new BadRequestException("commit message must be non-empty");
    }
    if (input.status != null) {
        if (input.status != ChangeStatus.NEW && input.status != ChangeStatus.DRAFT) {
            throw new BadRequestException("unsupported change status");
        }
        if (!allowDrafts && input.status == ChangeStatus.DRAFT) {
            throw new MethodNotAllowedException("draft workflow is disabled");
        }
    }
    String refName = RefNames.fullName(input.branch);
    ProjectResource rsrc = projectsCollection.parse(input.project);
    Capable r = rsrc.getControl().canPushToAtLeastOneRef();
    if (r != Capable.OK) {
        throw new AuthException(r.getMessage());
    }
    RefControl refControl = rsrc.getControl().controlForRef(refName);
    if (!refControl.canUpload() || !refControl.canRead()) {
        throw new AuthException("cannot upload review");
    }
    Project.NameKey project = rsrc.getNameKey();
    try (Repository git = gitManager.openRepository(project);
        ObjectInserter oi = git.newObjectInserter();
        RevWalk rw = new RevWalk(oi.newReader())) {
        ObjectId parentCommit;
        List<String> groups;
        if (input.baseChange != null) {
            List<ChangeControl> ctls = changeFinder.find(input.baseChange, rsrc.getControl().getUser());
            if (ctls.size() != 1) {
                throw new InvalidChangeOperationException("Base change not found: " + input.baseChange);
            }
            ChangeControl ctl = Iterables.getOnlyElement(ctls);
            if (!ctl.isVisible(db.get())) {
                throw new InvalidChangeOperationException("Base change not found: " + input.baseChange);
            }
            PatchSet ps = psUtil.current(db.get(), ctl.getNotes());
            parentCommit = ObjectId.fromString(ps.getRevision().get());
            groups = ps.getGroups();
        } else {
            Ref destRef = git.getRefDatabase().exactRef(refName);
            if (destRef != null) {
                if (Boolean.TRUE.equals(input.newBranch)) {
                    throw new ResourceConflictException(String.format("Branch %s already exists.", refName));
                }
                parentCommit = destRef.getObjectId();
            } else {
                if (Boolean.TRUE.equals(input.newBranch)) {
                    parentCommit = null;
                } else {
                    throw new UnprocessableEntityException(String.format("Branch %s does not exist.", refName));
                }
            }
            groups = Collections.emptyList();
        }
        RevCommit mergeTip = parentCommit == null ? null : rw.parseCommit(parentCommit);
        Timestamp now = TimeUtil.nowTs();
        IdentifiedUser me = user.get().asIdentifiedUser();
        PersonIdent author = me.newCommitterIdent(now, serverTimeZone);
        AccountState account = accountCache.get(me.getAccountId());
        GeneralPreferencesInfo info = account.getAccount().getGeneralPreferencesInfo();
        ObjectId treeId = mergeTip == null ? emptyTreeId(oi) : mergeTip.getTree();
        ObjectId id = ChangeIdUtil.computeChangeId(treeId, mergeTip, author, author, input.subject);
        String commitMessage = ChangeIdUtil.insertId(input.subject, id);
        if (Boolean.TRUE.equals(info.signedOffBy)) {
            commitMessage += String.format("%s%s", SIGNED_OFF_BY_TAG, account.getAccount().getNameEmail(anonymousCowardName));
        }
        RevCommit c;
        if (input.merge != null) {
            // create a merge commit
            c = newMergeCommit(git, oi, rw, rsrc.getControl(), mergeTip, input.merge, author, commitMessage);
        } else {
            // create an empty commit
            c = newCommit(oi, rw, author, mergeTip, commitMessage);
        }
        Change.Id changeId = new Change.Id(seq.nextChangeId());
        ChangeInserter ins = changeInserterFactory.create(changeId, c, refName).setValidatePolicy(CommitValidators.Policy.GERRIT);
        ins.setMessage(String.format("Uploaded patch set %s.", ins.getPatchSetId().get()));
        String topic = input.topic;
        if (topic != null) {
            topic = Strings.emptyToNull(topic.trim());
        }
        ins.setTopic(topic);
        ins.setDraft(input.status == ChangeStatus.DRAFT);
        ins.setGroups(groups);
        try (BatchUpdate bu = updateFactory.create(db.get(), project, me, now)) {
            bu.setRepository(git, rw, oi);
            bu.insertChange(ins);
            bu.execute();
        }
        ChangeJson json = jsonFactory.create(ChangeJson.NO_OPTIONS);
        return Response.created(json.format(ins.getChange()));
    } catch (IllegalArgumentException e) {
        throw new BadRequestException(e.getMessage());
    }
}
#method_after
@Override
public Response<ChangeInfo> apply(TopLevelResource parent, ChangeInput input) throws OrmException, IOException, InvalidChangeOperationException, RestApiException, UpdateException {
    if (Strings.isNullOrEmpty(input.project)) {
        throw new BadRequestException("project must be non-empty");
    }
    if (Strings.isNullOrEmpty(input.branch)) {
        throw new BadRequestException("branch must be non-empty");
    }
    if (Strings.isNullOrEmpty(input.subject)) {
        throw new BadRequestException("commit message must be non-empty");
    }
    if (input.status != null) {
        if (input.status != ChangeStatus.NEW && input.status != ChangeStatus.DRAFT) {
            throw new BadRequestException("unsupported change status");
        }
        if (!allowDrafts && input.status == ChangeStatus.DRAFT) {
            throw new MethodNotAllowedException("draft workflow is disabled");
        }
    }
    String refName = RefNames.fullName(input.branch);
    ProjectResource rsrc = projectsCollection.parse(input.project);
    Capable r = rsrc.getControl().canPushToAtLeastOneRef();
    if (r != Capable.OK) {
        throw new AuthException(r.getMessage());
    }
    RefControl refControl = rsrc.getControl().controlForRef(refName);
    if (!refControl.canUpload() || !refControl.canRead()) {
        throw new AuthException("cannot upload review");
    }
    Project.NameKey project = rsrc.getNameKey();
    try (Repository git = gitManager.openRepository(project);
        ObjectInserter oi = git.newObjectInserter();
        RevWalk rw = new RevWalk(oi.newReader())) {
        ObjectId parentCommit;
        List<String> groups;
        if (input.baseChange != null) {
            List<ChangeControl> ctls = changeFinder.find(input.baseChange, rsrc.getControl().getUser());
            if (ctls.size() != 1) {
                throw new InvalidChangeOperationException("Base change not found: " + input.baseChange);
            }
            ChangeControl ctl = Iterables.getOnlyElement(ctls);
            if (!ctl.isVisible(db.get())) {
                throw new InvalidChangeOperationException("Base change not found: " + input.baseChange);
            }
            PatchSet ps = psUtil.current(db.get(), ctl.getNotes());
            parentCommit = ObjectId.fromString(ps.getRevision().get());
            groups = ps.getGroups();
        } else {
            Ref destRef = git.getRefDatabase().exactRef(refName);
            if (destRef != null) {
                if (Boolean.TRUE.equals(input.newBranch)) {
                    throw new ResourceConflictException(String.format("Branch %s already exists.", refName));
                }
                parentCommit = destRef.getObjectId();
            } else {
                if (Boolean.TRUE.equals(input.newBranch)) {
                    parentCommit = null;
                } else {
                    throw new UnprocessableEntityException(String.format("Branch %s does not exist.", refName));
                }
            }
            groups = Collections.emptyList();
        }
        RevCommit mergeTip = parentCommit == null ? null : rw.parseCommit(parentCommit);
        Timestamp now = TimeUtil.nowTs();
        IdentifiedUser me = user.get().asIdentifiedUser();
        PersonIdent author = me.newCommitterIdent(now, serverTimeZone);
        AccountState account = accountCache.get(me.getAccountId());
        GeneralPreferencesInfo info = account.getAccount().getGeneralPreferencesInfo();
        ObjectId treeId = mergeTip == null ? emptyTreeId(oi) : mergeTip.getTree();
        ObjectId id = ChangeIdUtil.computeChangeId(treeId, mergeTip, author, author, input.subject);
        String commitMessage = ChangeIdUtil.insertId(input.subject, id);
        if (Boolean.TRUE.equals(info.signedOffBy)) {
            commitMessage += String.format("%s%s", SIGNED_OFF_BY_TAG, account.getAccount().getNameEmail(anonymousCowardName));
        }
        RevCommit c;
        if (input.merge != null) {
            // create a merge commit
            if (!(submitType.equals(SubmitType.MERGE_ALWAYS) || submitType.equals(SubmitType.MERGE_IF_NECESSARY))) {
                throw new BadRequestException("Submit type: " + submitType + " is not supported");
            }
            c = newMergeCommit(git, oi, rw, rsrc.getControl(), mergeTip, input.merge, author, commitMessage);
        } else {
            // create an empty commit
            c = newCommit(oi, rw, author, mergeTip, commitMessage);
        }
        Change.Id changeId = new Change.Id(seq.nextChangeId());
        ChangeInserter ins = changeInserterFactory.create(changeId, c, refName).setValidatePolicy(CommitValidators.Policy.GERRIT);
        ins.setMessage(String.format("Uploaded patch set %s.", ins.getPatchSetId().get()));
        String topic = input.topic;
        if (topic != null) {
            topic = Strings.emptyToNull(topic.trim());
        }
        ins.setTopic(topic);
        ins.setDraft(input.status == ChangeStatus.DRAFT);
        ins.setGroups(groups);
        try (BatchUpdate bu = updateFactory.create(db.get(), project, me, now)) {
            bu.setRepository(git, rw, oi);
            bu.insertChange(ins);
            bu.execute();
        }
        ChangeJson json = jsonFactory.create(ChangeJson.NO_OPTIONS);
        return Response.created(json.format(ins.getChange()));
    } catch (IllegalArgumentException e) {
        throw new BadRequestException(e.getMessage());
    }
}
#end_block

#method_before
int shutdown() {
    int cnt = 0;
    if (pool != null) {
        cnt = pool.shutdownNow().size();
        pool.unregisterWorkQueue();
        pool = null;
    }
    return cnt;
}
#method_after
int shutdown() {
    int cnt = 0;
    if (pool != null) {
        for (Runnable r : pool.getQueue()) {
            repLog.warn(String.format("Cancelling replication event %s", r));
        }
        cnt = pool.shutdownNow().size();
        pool.unregisterWorkQueue();
        pool = null;
    }
    return cnt;
}
#end_block

#method_before
@After
public void cleanUp() throws Exception {
    TestRepository<InMemoryRepository> allUsersRepo = cloneProject(allUsers);
    try {
        fetch(allUsersRepo, RefNames.REFS_USERS_DEFAULT + ":defaults");
    } catch (TransportException e) {
        if (e.getMessage().equals("Remote does not have " + RefNames.REFS_USERS_DEFAULT + " available for fetch.")) {
            return;
        }
        throw e;
    }
    allUsersRepo.reset("defaults");
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), allUsersRepo, "Delete default preferences", VersionedAccountPreferences.PREFERENCES, "");
    push.rm(RefNames.REFS_USERS_DEFAULT).assertOkStatus();
}
#method_after
@After
public void cleanUp() throws Exception {
    try (Repository git = repoManager.openRepository(allUsers)) {
        if (git.exactRef(RefNames.REFS_USERS_DEFAULT) != null) {
            RefUpdate u = git.updateRef(RefNames.REFS_USERS_DEFAULT);
            u.setForceUpdate(true);
            assertThat(u.delete()).isEqualTo(RefUpdate.Result.FORCED);
        }
    }
    accountCache.evictAll();
}
#end_block

#method_before
private static AccountState newState(Account account) {
    return new AccountState(account, ImmutableSet.<AccountGroup.UUID>of(), ImmutableSet.<AccountExternalId>of(), ImmutableSet.<AccountProjectWatch>of());
}
#method_after
private static AccountState newState(Account account) {
    return new AccountState(account, ImmutableSet.<AccountGroup.UUID>of(), ImmutableSet.<AccountExternalId>of(), new HashMap<ProjectWatchKey, Set<NotifyType>>());
}
#end_block

#method_before
@After
public void cleanUp() throws Exception {
    gApi.accounts().id(user42.getId().toString()).setPreferences(GeneralPreferencesInfo.defaults());
    TestRepository<InMemoryRepository> allUsersRepo = cloneProject(allUsers);
    try {
        fetch(allUsersRepo, RefNames.REFS_USERS_DEFAULT + ":defaults");
    } catch (TransportException e) {
        if (e.getMessage().equals("Remote does not have " + RefNames.REFS_USERS_DEFAULT + " available for fetch.")) {
            return;
        }
        throw e;
    }
    allUsersRepo.reset("defaults");
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), allUsersRepo, "Delete default preferences", VersionedAccountPreferences.PREFERENCES, "");
    push.rm(RefNames.REFS_USERS_DEFAULT).assertOkStatus();
}
#method_after
@After
public void cleanUp() throws Exception {
    gApi.accounts().id(user42.getId().toString()).setPreferences(GeneralPreferencesInfo.defaults());
    try (Repository git = repoManager.openRepository(allUsers)) {
        if (git.exactRef(RefNames.REFS_USERS_DEFAULT) != null) {
            RefUpdate u = git.updateRef(RefNames.REFS_USERS_DEFAULT);
            u.setForceUpdate(true);
            assertThat(u.delete()).isEqualTo(RefUpdate.Result.FORCED);
        }
    }
    accountCache.evictAll();
}
#end_block

#method_before
private static AccountState missing(Account.Id accountId) {
    Account account = new Account(accountId, TimeUtil.nowTs());
    account.setActive(false);
    Collection<AccountExternalId> ids = Collections.emptySet();
    Collection<AccountProjectWatch> projectWatches = Collections.emptySet();
    Set<AccountGroup.UUID> anon = ImmutableSet.of();
    return new AccountState(account, anon, ids, projectWatches);
}
#method_after
private static AccountState missing(Account.Id accountId) {
    Account account = new Account(accountId, TimeUtil.nowTs());
    account.setActive(false);
    Collection<AccountExternalId> ids = Collections.emptySet();
    Set<AccountGroup.UUID> anon = ImmutableSet.of();
    return new AccountState(account, anon, ids, new HashMap<ProjectWatchKey, Set<NotifyType>>());
}
#end_block

#method_before
private AccountState load(final ReviewDb db, final Account.Id who) throws OrmException {
    Account account = db.accounts().get(who);
    if (account == null) {
        // Account no longer exists? They are anonymous.
        return missing(who);
    }
    Collection<AccountExternalId> externalIds = Collections.unmodifiableCollection(db.accountExternalIds().byAccount(who).toList());
    Set<AccountGroup.UUID> internalGroups = new HashSet<>();
    for (AccountGroupMember g : db.accountGroupMembers().byAccount(who)) {
        final AccountGroup.Id groupId = g.getAccountGroupId();
        final AccountGroup group = groupCache.get(groupId);
        if (group != null && group.getGroupUUID() != null) {
            internalGroups.add(group.getGroupUUID());
        }
    }
    internalGroups = Collections.unmodifiableSet(internalGroups);
    try {
        account.setGeneralPreferences(loader.load(who));
    } catch (IOException | ConfigInvalidException e) {
        log.warn("Cannot load GeneralPreferences for " + who + " (using default)", e);
        account.setGeneralPreferences(GeneralPreferencesInfo.defaults());
    }
    Collection<AccountProjectWatch> projectWatches = Collections.unmodifiableCollection(db.accountProjectWatches().byAccount(who).toList());
    return new AccountState(account, internalGroups, externalIds, projectWatches);
}
#method_after
private AccountState load(final ReviewDb db, final Account.Id who) throws OrmException, IOException, ConfigInvalidException {
    Account account = db.accounts().get(who);
    if (account == null) {
        // Account no longer exists? They are anonymous.
        return missing(who);
    }
    Collection<AccountExternalId> externalIds = Collections.unmodifiableCollection(db.accountExternalIds().byAccount(who).toList());
    Set<AccountGroup.UUID> internalGroups = new HashSet<>();
    for (AccountGroupMember g : db.accountGroupMembers().byAccount(who)) {
        final AccountGroup.Id groupId = g.getAccountGroupId();
        final AccountGroup group = groupCache.get(groupId);
        if (group != null && group.getGroupUUID() != null) {
            internalGroups.add(group.getGroupUUID());
        }
    }
    internalGroups = Collections.unmodifiableSet(internalGroups);
    try {
        account.setGeneralPreferences(loader.load(who));
    } catch (IOException | ConfigInvalidException e) {
        log.warn("Cannot load GeneralPreferences for " + who + " (using default)", e);
        account.setGeneralPreferences(GeneralPreferencesInfo.defaults());
    }
    Map<ProjectWatchKey, Set<NotifyType>> projectWatches = readFromGit ? watchConfig.get().getProjectWatches(who) : GetWatchedProjects.readProjectWatchesFromDb(db, who);
    return new AccountState(account, internalGroups, externalIds, projectWatches);
}
#end_block

#method_before
@Override
public Optional<Account.Id> load(String username) throws Exception {
    try (ReviewDb db = schema.open()) {
        final AccountExternalId.Key key = new // 
        AccountExternalId.Key(// 
        AccountExternalId.SCHEME_USERNAME, username);
        final AccountExternalId id = db.accountExternalIds().get(key);
        if (id != null) {
            return Optional.of(id.getAccountId());
        }
        return Optional.absent();
    }
}
#method_after
@Override
public Optional<Account.Id> load(String username) throws Exception {
    AccountExternalId.Key key = new // 
    AccountExternalId.Key(// 
    AccountExternalId.SCHEME_USERNAME, username);
    if (accountIndexes.getSearchIndex() != null) {
        AccountState accountState = accountQueryProvider.get().oneByExternalId(key.get());
        return accountState != null ? Optional.of(accountState.getAccount().getId()) : Optional.<Account.Id>absent();
    }
    try (ReviewDb db = schema.open()) {
        AccountExternalId id = db.accountExternalIds().get(key);
        if (id != null) {
            return Optional.of(id.getAccountId());
        }
        return Optional.absent();
    }
}
#end_block

#method_before
@Test
public void testSubmoduleSubjectCommitMessage() throws Exception {
    TestRepository<?> superRepo = createProjectWithPush("super-project");
    TestRepository<?> subRepo = createProjectWithPush("subscribed-to-project");
    allowSubmoduleSubscription("subscribed-to-project", "refs/heads/master", "super-project", "refs/heads/master");
    pushChangeTo(subRepo, "master");
    createSubmoduleSubscription(superRepo, "master", "subscribed-to-project", "master");
    ObjectId subHEAD = pushChangeTo(subRepo, "master");
    // The first update doesn't include the rev log
    RevWalk rw = subRepo.getRevWalk();
    expectToHaveCommitMessage(superRepo, "master", "Update git submodules\n\n" + "* Update " + name("subscribed-to-project") + " from branch 'master'");
    // The next commit should generate only its commit message,
    // omitting previous commit logs
    subHEAD = pushChangeTo(subRepo, "master");
    RevCommit subCommitMsg = rw.parseCommit(subHEAD);
    expectToHaveCommitMessage(superRepo, "master", "Update git submodules\n\n" + "* Update " + name("subscribed-to-project") + " from branch 'master'" + "\n  - " + subCommitMsg.getShortMessage());
}
#method_after
@Test
@GerritConfig(name = "submodule.verboseSuperprojectUpdate", value = "SUBJECT_ONLY")
public void testSubmoduleSubjectCommitMessage() throws Exception {
    TestRepository<?> superRepo = createProjectWithPush("super-project");
    TestRepository<?> subRepo = createProjectWithPush("subscribed-to-project");
    allowSubmoduleSubscription("subscribed-to-project", "refs/heads/master", "super-project", "refs/heads/master");
    pushChangeTo(subRepo, "master");
    createSubmoduleSubscription(superRepo, "master", "subscribed-to-project", "master");
    ObjectId subHEAD = pushChangeTo(subRepo, "master");
    // The first update doesn't include the rev log
    RevWalk rw = subRepo.getRevWalk();
    expectToHaveCommitMessage(superRepo, "master", "Update git submodules\n\n" + "* Update " + name("subscribed-to-project") + " from branch 'master'");
    // The next commit should generate only its commit message,
    // omitting previous commit logs
    subHEAD = pushChangeTo(subRepo, "master");
    RevCommit subCommitMsg = rw.parseCommit(subHEAD);
    expectToHaveCommitMessage(superRepo, "master", "Update git submodules\n\n" + "* Update " + name("subscribed-to-project") + " from branch 'master'" + "\n  - " + subCommitMsg.getShortMessage());
}
#end_block

#method_before
@Test
@GerritConfig(name = "submodule.verboseSuperprojectUpdate", value = "true")
public void testSubmoduleCommitMessage() throws Exception {
    TestRepository<?> superRepo = createProjectWithPush("super-project");
    TestRepository<?> subRepo = createProjectWithPush("subscribed-to-project");
    allowSubmoduleSubscription("subscribed-to-project", "refs/heads/master", "super-project", "refs/heads/master");
    pushChangeTo(subRepo, "master");
    createSubmoduleSubscription(superRepo, "master", "subscribed-to-project", "master");
    ObjectId subHEAD = pushChangeTo(subRepo, "master");
    // The first update doesn't include the rev log
    RevWalk rw = subRepo.getRevWalk();
    expectToHaveCommitMessage(superRepo, "master", "Update git submodules\n\n" + "* Update " + name("subscribed-to-project") + " from branch 'master'");
    // The next commit should generate only its commit message,
    // omitting previous commit logs
    subHEAD = pushChangeTo(subRepo, "master");
    RevCommit subCommitMsg = rw.parseCommit(subHEAD);
    expectToHaveCommitMessage(superRepo, "master", "Update git submodules\n\n" + "* Update " + name("subscribed-to-project") + " from branch 'master'" + "\n  - " + subCommitMsg.getFullMessage().replace("\n", "\n    "));
}
#method_after
@Test
public void testSubmoduleCommitMessage() throws Exception {
    TestRepository<?> superRepo = createProjectWithPush("super-project");
    TestRepository<?> subRepo = createProjectWithPush("subscribed-to-project");
    allowSubmoduleSubscription("subscribed-to-project", "refs/heads/master", "super-project", "refs/heads/master");
    pushChangeTo(subRepo, "master");
    createSubmoduleSubscription(superRepo, "master", "subscribed-to-project", "master");
    ObjectId subHEAD = pushChangeTo(subRepo, "master");
    // The first update doesn't include the rev log
    RevWalk rw = subRepo.getRevWalk();
    expectToHaveCommitMessage(superRepo, "master", "Update git submodules\n\n" + "* Update " + name("subscribed-to-project") + " from branch 'master'");
    // The next commit should generate only its commit message,
    // omitting previous commit logs
    subHEAD = pushChangeTo(subRepo, "master");
    RevCommit subCommitMsg = rw.parseCommit(subHEAD);
    expectToHaveCommitMessage(superRepo, "master", "Update git submodules\n\n" + "* Update " + name("subscribed-to-project") + " from branch 'master'" + "\n  - " + subCommitMsg.getFullMessage().replace("\n", "\n    "));
}
#end_block

#method_before
public CodeReviewCommit composeGitlinksCommit(final Branch.NameKey subscriber) throws IOException, SubmoduleException {
    OpenRepo or;
    try {
        or = orm.openRepo(subscriber.getParentKey(), false);
    } catch (NoSuchProjectException | IOException e) {
        throw new SubmoduleException("Cannot access superproject", e);
    }
    CodeReviewCommit currentCommit;
    Ref r = or.repo.exactRef(subscriber.get());
    if (r == null) {
        throw new SubmoduleException("The branch was probably deleted from the subscriber repository");
    }
    currentCommit = or.rw.parseCommit(r.getObjectId());
    StringBuilder msgbuf = new StringBuilder("");
    PersonIdent author = null;
    DirCache dc = readTree(or.rw, currentCommit);
    DirCacheEditor ed = dc.editor();
    for (SubmoduleSubscription s : targets.get(subscriber)) {
        RevCommit newCommit = updateSubmodule(dc, ed, msgbuf, s);
        if (newCommit != null) {
            if (author == null) {
                author = newCommit.getAuthorIdent();
            } else if (!author.equals(newCommit.getAuthorIdent())) {
                author = myIdent;
            }
        }
    }
    ed.finish();
    ObjectId newTreeId = dc.writeTree(or.ins);
    // Gitlinks are already in the branch, return null
    if (newTreeId.equals(currentCommit.getTree())) {
        return null;
    }
    CommitBuilder commit = new CommitBuilder();
    commit.setTreeId(newTreeId);
    commit.setParentId(currentCommit);
    StringBuilder commitMsg = new StringBuilder("Update git submodules\n\n");
    if (!verboseSuperProject.equals(VerboseSuperprojectUpdate.FALSE)) {
        commitMsg.append(msgbuf);
    }
    commit.setMessage(commitMsg.toString());
    commit.setAuthor(author);
    commit.setCommitter(myIdent);
    ObjectId id = or.ins.insert(commit);
    return or.rw.parseCommit(id);
}
#method_after
public CodeReviewCommit composeGitlinksCommit(final Branch.NameKey subscriber) throws IOException, SubmoduleException {
    OpenRepo or;
    try {
        or = orm.openRepo(subscriber.getParentKey(), false);
    } catch (NoSuchProjectException | IOException e) {
        throw new SubmoduleException("Cannot access superproject", e);
    }
    CodeReviewCommit currentCommit;
    Ref r = or.repo.exactRef(subscriber.get());
    if (r == null) {
        throw new SubmoduleException("The branch was probably deleted from the subscriber repository");
    }
    currentCommit = or.rw.parseCommit(r.getObjectId());
    StringBuilder msgbuf = new StringBuilder("");
    PersonIdent author = null;
    DirCache dc = readTree(or.rw, currentCommit);
    DirCacheEditor ed = dc.editor();
    for (SubmoduleSubscription s : targets.get(subscriber)) {
        RevCommit newCommit = updateSubmodule(dc, ed, msgbuf, s);
        if (newCommit != null) {
            if (author == null) {
                author = newCommit.getAuthorIdent();
            } else if (!author.equals(newCommit.getAuthorIdent())) {
                author = myIdent;
            }
        }
    }
    ed.finish();
    ObjectId newTreeId = dc.writeTree(or.ins);
    // Gitlinks are already in the branch, return null
    if (newTreeId.equals(currentCommit.getTree())) {
        return null;
    }
    CommitBuilder commit = new CommitBuilder();
    commit.setTreeId(newTreeId);
    commit.setParentId(currentCommit);
    StringBuilder commitMsg = new StringBuilder("Update git submodules\n\n");
    if (verboseSuperProject != VerboseSuperprojectUpdate.FALSE) {
        commitMsg.append(msgbuf);
    }
    commit.setMessage(commitMsg.toString());
    commit.setAuthor(author);
    commit.setCommitter(myIdent);
    ObjectId id = or.ins.insert(commit);
    return or.rw.parseCommit(id);
}
#end_block

#method_before
public CodeReviewCommit composeGitlinksCommit(final Branch.NameKey subscriber, CodeReviewCommit currentCommit) throws IOException, SubmoduleException {
    OpenRepo or;
    try {
        or = orm.openRepo(subscriber.getParentKey(), false);
    } catch (NoSuchProjectException | IOException e) {
        throw new SubmoduleException("Cannot access superproject", e);
    }
    StringBuilder msgbuf = new StringBuilder("");
    DirCache dc = readTree(or.rw, currentCommit);
    DirCacheEditor ed = dc.editor();
    for (SubmoduleSubscription s : targets.get(subscriber)) {
        updateSubmodule(dc, ed, msgbuf, s);
    }
    ed.finish();
    ObjectId newTreeId = dc.writeTree(or.ins);
    // Gitlinks are already updated, just return the commit
    if (newTreeId.equals(currentCommit.getTree())) {
        return currentCommit;
    }
    or.rw.parseBody(currentCommit);
    CommitBuilder commit = new CommitBuilder();
    commit.setTreeId(newTreeId);
    commit.setParentIds(currentCommit.getParents());
    if (!verboseSuperProject.equals(VerboseSuperprojectUpdate.FALSE)) {
        commit.setMessage(currentCommit.getFullMessage() + "\n\n*submodules:\n" + msgbuf.toString());
    } else {
        commit.setMessage(currentCommit.getFullMessage());
    }
    commit.setAuthor(currentCommit.getAuthorIdent());
    commit.setCommitter(myIdent);
    ObjectId id = or.ins.insert(commit);
    return or.rw.parseCommit(id);
}
#method_after
public CodeReviewCommit composeGitlinksCommit(final Branch.NameKey subscriber, CodeReviewCommit currentCommit) throws IOException, SubmoduleException {
    OpenRepo or;
    try {
        or = orm.openRepo(subscriber.getParentKey(), false);
    } catch (NoSuchProjectException | IOException e) {
        throw new SubmoduleException("Cannot access superproject", e);
    }
    StringBuilder msgbuf = new StringBuilder("");
    DirCache dc = readTree(or.rw, currentCommit);
    DirCacheEditor ed = dc.editor();
    for (SubmoduleSubscription s : targets.get(subscriber)) {
        updateSubmodule(dc, ed, msgbuf, s);
    }
    ed.finish();
    ObjectId newTreeId = dc.writeTree(or.ins);
    // Gitlinks are already updated, just return the commit
    if (newTreeId.equals(currentCommit.getTree())) {
        return currentCommit;
    }
    or.rw.parseBody(currentCommit);
    CommitBuilder commit = new CommitBuilder();
    commit.setTreeId(newTreeId);
    commit.setParentIds(currentCommit.getParents());
    if (verboseSuperProject != VerboseSuperprojectUpdate.FALSE) {
        // TODO:czhen handle cherrypick footer
        commit.setMessage(currentCommit.getFullMessage() + "\n\n*submodules:\n" + msgbuf.toString());
    } else {
        commit.setMessage(currentCommit.getFullMessage());
    }
    commit.setAuthor(currentCommit.getAuthorIdent());
    commit.setCommitter(myIdent);
    ObjectId id = or.ins.insert(commit);
    return or.rw.parseCommit(id);
}
#end_block

#method_before
private RevCommit updateSubmodule(DirCache dc, DirCacheEditor ed, StringBuilder msgbuf, final SubmoduleSubscription s) throws SubmoduleException, IOException {
    OpenRepo subOr;
    try {
        subOr = orm.openRepo(s.getSubmodule().getParentKey(), false);
    } catch (NoSuchProjectException | IOException e) {
        throw new SubmoduleException("Cannot access submodule", e);
    }
    DirCacheEntry dce = dc.getEntry(s.getPath());
    RevCommit oldCommit = null;
    if (dce != null) {
        if (!dce.getFileMode().equals(FileMode.GITLINK)) {
            String errMsg = "Requested to update gitlink " + s.getPath() + " in " + s.getSubmodule().getParentKey().get() + " but entry " + "doesn't have gitlink file mode.";
            throw new SubmoduleException(errMsg);
        }
        oldCommit = subOr.rw.parseCommit(dce.getObjectId());
    }
    final RevCommit newCommit;
    if (branchTips.containsKey(s.getSubmodule())) {
        newCommit = branchTips.get(s.getSubmodule());
    } else {
        Ref ref = subOr.repo.getRefDatabase().exactRef(s.getSubmodule().get());
        if (ref == null) {
            ed.add(new DeletePath(s.getPath()));
            return null;
        }
        newCommit = subOr.rw.parseCommit(ref.getObjectId());
    }
    if (Objects.equals(newCommit, oldCommit)) {
        // gitlink have already been updated for this submodule
        return null;
    }
    ed.add(new PathEdit(s.getPath()) {

        @Override
        public void apply(DirCacheEntry ent) {
            ent.setFileMode(FileMode.GITLINK);
            ent.setObjectId(newCommit.getId());
        }
    });
    if (!verboseSuperProject.equals(VerboseSuperprojectUpdate.FALSE)) {
        createSubmoduleCommitMsg(msgbuf, s, subOr, newCommit, oldCommit);
    }
    subOr.rw.parseBody(newCommit);
    return newCommit;
}
#method_after
private RevCommit updateSubmodule(DirCache dc, DirCacheEditor ed, StringBuilder msgbuf, final SubmoduleSubscription s) throws SubmoduleException, IOException {
    OpenRepo subOr;
    try {
        subOr = orm.openRepo(s.getSubmodule().getParentKey(), false);
    } catch (NoSuchProjectException | IOException e) {
        throw new SubmoduleException("Cannot access submodule", e);
    }
    DirCacheEntry dce = dc.getEntry(s.getPath());
    RevCommit oldCommit = null;
    if (dce != null) {
        if (!dce.getFileMode().equals(FileMode.GITLINK)) {
            String errMsg = "Requested to update gitlink " + s.getPath() + " in " + s.getSubmodule().getParentKey().get() + " but entry " + "doesn't have gitlink file mode.";
            throw new SubmoduleException(errMsg);
        }
        oldCommit = subOr.rw.parseCommit(dce.getObjectId());
    }
    final RevCommit newCommit;
    if (branchTips.containsKey(s.getSubmodule())) {
        newCommit = branchTips.get(s.getSubmodule());
    } else {
        Ref ref = subOr.repo.getRefDatabase().exactRef(s.getSubmodule().get());
        if (ref == null) {
            ed.add(new DeletePath(s.getPath()));
            return null;
        }
        newCommit = subOr.rw.parseCommit(ref.getObjectId());
    }
    if (Objects.equals(newCommit, oldCommit)) {
        // gitlink have already been updated for this submodule
        return null;
    }
    ed.add(new PathEdit(s.getPath()) {

        @Override
        public void apply(DirCacheEntry ent) {
            ent.setFileMode(FileMode.GITLINK);
            ent.setObjectId(newCommit.getId());
        }
    });
    if (verboseSuperProject != VerboseSuperprojectUpdate.FALSE) {
        createSubmoduleCommitMsg(msgbuf, s, subOr, newCommit, oldCommit);
    }
    subOr.rw.parseBody(newCommit);
    return newCommit;
}
#end_block

#method_before
private void createSubmoduleCommitMsg(StringBuilder msgbuf, SubmoduleSubscription s, OpenRepo subOr, RevCommit newCommit, RevCommit oldCommit) throws SubmoduleException {
    msgbuf.append("* Update " + s.getPath());
    msgbuf.append(" from branch '" + s.getSubmodule().getShortName() + "'");
    // newly created submodule gitlink, do not append whole history
    if (oldCommit == null) {
        return;
    }
    try {
        subOr.rw.resetRetain(subOr.canMergeFlag);
        subOr.rw.markStart(newCommit);
        subOr.rw.markUninteresting(oldCommit);
        for (RevCommit c : subOr.rw) {
            subOr.rw.parseBody(c);
            if (verboseSuperProject.equals(VerboseSuperprojectUpdate.SUBJECT_ONLY)) {
                msgbuf.append("\n  - " + c.getShortMessage());
            } else if (verboseSuperProject.equals(VerboseSuperprojectUpdate.TRUE)) {
                msgbuf.append("\n  - " + c.getFullMessage().replace("\n", "\n    "));
            }
        }
    } catch (IOException e) {
        throw new SubmoduleException("Could not perform a revwalk to " + "create superproject commit message", e);
    }
}
#method_after
private void createSubmoduleCommitMsg(StringBuilder msgbuf, SubmoduleSubscription s, OpenRepo subOr, RevCommit newCommit, RevCommit oldCommit) throws SubmoduleException {
    msgbuf.append("* Update " + s.getPath());
    msgbuf.append(" from branch '" + s.getSubmodule().getShortName() + "'");
    // newly created submodule gitlink, do not append whole history
    if (oldCommit == null) {
        return;
    }
    try {
        subOr.rw.resetRetain(subOr.canMergeFlag);
        subOr.rw.markStart(newCommit);
        subOr.rw.markUninteresting(oldCommit);
        for (RevCommit c : subOr.rw) {
            subOr.rw.parseBody(c);
            if (verboseSuperProject == VerboseSuperprojectUpdate.SUBJECT_ONLY) {
                msgbuf.append("\n  - " + c.getShortMessage());
            } else if (verboseSuperProject == VerboseSuperprojectUpdate.TRUE) {
                msgbuf.append("\n  - " + c.getFullMessage().replace("\n", "\n    "));
            }
        }
    } catch (IOException e) {
        throw new SubmoduleException("Could not perform a revwalk to " + "create superproject commit message", e);
    }
}
#end_block

#method_before
@Override
public void close() {
    writerThread.shutdown();
    try {
        if (!writerThread.awaitTermination(5, TimeUnit.SECONDS)) {
            log.warn("shutting down with pending Lucene writes");
        }
    } catch (InterruptedException e) {
        log.warn("interrupted waiting for pending Lucene writes", e);
    }
    reopenThread.close();
    // not have flushed.
    try {
        searcherManager.maybeRefreshBlocking();
    } catch (IOException e) {
        log.warn("error finishing pending Lucene writes", e);
    }
    try {
        writer.getIndexWriter().close();
    } catch (AlreadyClosedException e) {
    // Ignore.
    } catch (IOException e) {
        log.warn("error closing Lucene writer", e);
    }
    try {
        dir.close();
    } catch (IOException e) {
        log.warn("error closing Lucene directory", e);
    }
}
#method_after
@Override
public void close() {
    if (autoCommitExecutor != null) {
        autoCommitExecutor.shutdown();
    }
    writerThread.shutdown();
    try {
        if (!writerThread.awaitTermination(5, TimeUnit.SECONDS)) {
            log.warn("shutting down " + name + " index with pending Lucene writes");
        }
    } catch (InterruptedException e) {
        log.warn("interrupted waiting for pending Lucene writes of " + name + " index", e);
    }
    reopenThread.close();
    // not have flushed.
    try {
        searcherManager.maybeRefreshBlocking();
    } catch (IOException e) {
        log.warn("error finishing pending Lucene writes", e);
    }
    try {
        writer.getIndexWriter().close();
    } catch (AlreadyClosedException e) {
    // Ignore.
    } catch (IOException e) {
        log.warn("error closing Lucene writer", e);
    }
    try {
        dir.close();
    } catch (IOException e) {
        log.warn("error closing Lucene directory", e);
    }
}
#end_block

#method_before
private void decodeChangedLines(Multimap<String, IndexableField> doc, ChangeData cd) {
    IndexableField added = Iterables.getFirst(doc.get(ADDED_FIELD), null);
    IndexableField deleted = Iterables.getFirst(doc.get(DELETED_FIELD), null);
    if (added != null && deleted != null) {
        cd.setChangedLines(added.numericValue().intValue(), deleted.numericValue().intValue());
    }
}
#method_after
private void decodeChangedLines(Multimap<String, IndexableField> doc, ChangeData cd) {
    IndexableField added = Iterables.getFirst(doc.get(ADDED_FIELD), null);
    IndexableField deleted = Iterables.getFirst(doc.get(DELETED_FIELD), null);
    if (added != null && deleted != null) {
        cd.setChangedLines(added.numericValue().intValue(), deleted.numericValue().intValue());
    } else {
        // No ChangedLines stored, likely due to failure during reindexing, for
        // example due to LargeObjectException. But we know the field was
        // requested, so update ChangeData to prevent callers from trying to
        // lazily load it, as that would probably also fail.
        cd.setNoChangedLines();
    }
}
#end_block

#method_before
public synchronized GlobalPluginConfig getGlobalPluginConfig(String pluginName) {
    if (pluginConfigs.containsKey(pluginName)) {
        return pluginConfigs.get(pluginName);
    }
    Path pluginConfigFile = site.etc_dir.resolve(pluginName + ".config");
    FileBasedConfig cfg = new FileBasedConfig(pluginConfigFile.toFile(), FS.DETECTED);
    GlobalPluginConfig pluginConfig = new GlobalPluginConfig(pluginName, cfg, secureStore);
    pluginConfigs.put(pluginName, pluginConfig);
    if (!cfg.getFile().exists()) {
        log.info("No " + pluginConfigFile.toAbsolutePath() + "; assuming defaults");
        return pluginConfig;
    }
    try {
        cfg.load();
    } catch (IOException | ConfigInvalidException e) {
        log.warn("Failed to load " + pluginConfigFile.toAbsolutePath(), e);
    }
    return pluginConfig;
}
#method_after
public synchronized Config getGlobalPluginConfig(String pluginName) {
    if (pluginConfigs.containsKey(pluginName)) {
        return pluginConfigs.get(pluginName);
    }
    Path pluginConfigFile = site.etc_dir.resolve(pluginName + ".config");
    FileBasedConfig cfg = new FileBasedConfig(pluginConfigFile.toFile(), FS.DETECTED);
    GlobalPluginConfig pluginConfig = new GlobalPluginConfig(pluginName, cfg, secureStore);
    pluginConfigs.put(pluginName, pluginConfig);
    if (!cfg.getFile().exists()) {
        log.info("No " + pluginConfigFile.toAbsolutePath() + "; assuming defaults");
        return pluginConfig;
    }
    try {
        cfg.load();
    } catch (IOException | ConfigInvalidException e) {
        log.warn("Failed to load " + pluginConfigFile.toAbsolutePath(), e);
    }
    return pluginConfig;
}
#end_block

#method_before
@Override
public String[] getListForPlugin(String pluginName, String section, String subsection, String name) {
    File pluginConfigFile = site.etc_dir.resolve(pluginName + ".secure.config").toFile();
    if (pluginConfigFile.exists()) {
        FileBasedConfig cfg = new FileBasedConfig(pluginConfigFile, FS.DETECTED);
        try {
            cfg.load();
            return cfg.getStringList(section, subsection, name);
        } catch (Exception e) {
        // Do nothing for now
        }
    }
    return null;
}
#method_after
@Override
public synchronized String[] getListForPlugin(String pluginName, String section, String subsection, String name) {
    FileBasedConfig cfg = null;
    if (pluginSec.containsKey(pluginName)) {
        cfg = pluginSec.get(pluginName);
    } else {
        String filename = pluginName + ".secure.config";
        File pluginConfigFile = site.etc_dir.resolve(filename).toFile();
        if (pluginConfigFile.exists()) {
            cfg = new FileBasedConfig(pluginConfigFile, FS.DETECTED);
            try {
                cfg.load();
                pluginSec.put(pluginName, cfg);
            } catch (IOException | ConfigInvalidException e) {
                throw new RuntimeException("Cannot load " + filename, e);
            }
        }
    }
    return cfg != null ? cfg.getStringList(section, subsection, name) : null;
}
#end_block

#method_before
@Test
public void deleteNonExistingProjectWatch() throws Exception {
    String projectName = project.get();
    // Let another user watch a project
    setApiUser(admin);
    List<ProjectWatchInfo> projectsToWatch = new LinkedList<>();
    ProjectWatchInfo pwi = new ProjectWatchInfo();
    pwi.project = projectName;
    pwi.notifyAbandonedChanges = true;
    pwi.notifyNewChanges = true;
    pwi.notifyAllComments = true;
    projectsToWatch.add(pwi);
    gApi.accounts().self().setWatchedProjects(projectsToWatch);
    // Try to delete a watched project using a different user
    List<ProjectWatchInfo> d = Lists.newArrayList(pwi);
    gApi.accounts().self().deleteWatchedProjects(d);
    // Check that trying to delete a non-existing watch doesn't fail
    gApi.accounts().self().deleteWatchedProjects(d);
}
#method_after
@Test
public void deleteNonExistingProjectWatch() throws Exception {
    String projectName = project.get();
    // Let another user watch a project
    setApiUser(admin);
    List<ProjectWatchInfo> projectsToWatch = new LinkedList<>();
    ProjectWatchInfo pwi = new ProjectWatchInfo();
    pwi.project = projectName;
    pwi.notifyAbandonedChanges = true;
    pwi.notifyNewChanges = true;
    pwi.notifyAllComments = true;
    projectsToWatch.add(pwi);
    gApi.accounts().self().setWatchedProjects(projectsToWatch);
    // Try to delete a watched project using a different user
    List<ProjectWatchInfo> d = Lists.newArrayList(pwi);
    gApi.accounts().self().deleteWatchedProjects(d);
    // Check that trying to delete a non-existing watch doesn't fail
    setApiUser(user);
    gApi.accounts().self().deleteWatchedProjects(d);
}
#end_block

#method_before
public Map<ProjectWatchKey, Collection<NotifyType>> getProjectWatches(Account.Id accountId) throws IOException, ConfigInvalidException {
    try (Repository git = repoManager.openRepository(allUsersName);
        WatchConfig watchConfig = new WatchConfig(accountId)) {
        watchConfig.load(git);
        return watchConfig.getProjectWatches();
    }
}
#method_after
public Map<ProjectWatchKey, Set<NotifyType>> getProjectWatches(Account.Id accountId) throws IOException, ConfigInvalidException {
    try (Repository git = repoManager.openRepository(allUsersName);
        WatchConfig watchConfig = new WatchConfig(accountId)) {
        watchConfig.load(git);
        return watchConfig.getProjectWatches();
    }
}
#end_block

#method_before
public void upsertProjectWatches(Account.Id accountId, Map<ProjectWatchKey, Collection<NotifyType>> newProjectWatches) throws IOException, ConfigInvalidException {
    try (WatchConfig watchConfig = open(accountId)) {
        Map<ProjectWatchKey, Collection<NotifyType>> projectWatches = watchConfig.getProjectWatches();
        projectWatches.putAll(newProjectWatches);
        commit(watchConfig);
    }
}
#method_after
public void upsertProjectWatches(Account.Id accountId, Map<ProjectWatchKey, Set<NotifyType>> newProjectWatches) throws IOException, ConfigInvalidException {
    try (WatchConfig watchConfig = open(accountId)) {
        Map<ProjectWatchKey, Set<NotifyType>> projectWatches = watchConfig.getProjectWatches();
        projectWatches.putAll(newProjectWatches);
        commit(watchConfig);
    }
}
#end_block

#method_before
public void deleteProjectWatches(Account.Id accountId, Collection<ProjectWatchKey> projectWatchKeys) throws IOException, ConfigInvalidException {
    try (WatchConfig watchConfig = open(accountId)) {
        Map<ProjectWatchKey, Collection<NotifyType>> projectWatches = watchConfig.getProjectWatches();
        for (ProjectWatchKey key : projectWatchKeys) {
            projectWatches.remove(key);
        }
        commit(watchConfig);
    }
}
#method_after
public void deleteProjectWatches(Account.Id accountId, Collection<ProjectWatchKey> projectWatchKeys) throws IOException, ConfigInvalidException {
    try (WatchConfig watchConfig = open(accountId)) {
        Map<ProjectWatchKey, Set<NotifyType>> projectWatches = watchConfig.getProjectWatches();
        boolean commit = false;
        for (ProjectWatchKey key : projectWatchKeys) {
            if (projectWatches.remove(key) != null) {
                commit = true;
            }
        }
        if (commit) {
            commit(watchConfig);
        }
    }
}
#end_block

#method_before
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    projectWatches = new HashMap<>();
    Config cfg = readConfig(WATCH_CONFIG);
    for (String projectWatchKey : cfg.getSubsections(PROJECT)) {
        ProjectWatchKey key = ProjectWatchKey.parse(projectWatchKey);
        projectWatches.put(key, new HashSet<NotifyType>());
        List<String> notifyValues = Arrays.asList(cfg.getStringList(PROJECT, projectWatchKey, KEY_NOTIFY));
        if (!notifyValues.contains(NOTIFY_NONE)) {
            for (String notify : notifyValues) {
                try {
                    projectWatches.get(key).add(AccountProjectWatch.NotifyType.valueOf(notify));
                } catch (IllegalArgumentException e) {
                    log.warn(String.format("Project watch configuration %s of account %d" + " contains invalid notify type: %s", projectWatchKey, accountId.get(), notify), e);
                }
            }
        }
    }
}
#method_after
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    Config cfg = readConfig(WATCH_CONFIG);
    projectWatches = parse(accountId, cfg);
}
#end_block

#method_before
Map<ProjectWatchKey, Collection<NotifyType>> getProjectWatches() {
    checkLoaded();
    return projectWatches;
}
#method_after
Map<ProjectWatchKey, Set<NotifyType>> getProjectWatches() {
    checkLoaded();
    return projectWatches;
}
#end_block

#method_before
@Override
protected boolean onSave(CommitBuilder commit) throws IOException, ConfigInvalidException {
    checkLoaded();
    if (commit.getMessage() == null || "".equals(commit.getMessage())) {
        commit.setMessage("Updated watch configuration\n");
    }
    Config cfg = readConfig(WATCH_CONFIG);
    clearSection(cfg, PROJECT);
    for (Map.Entry<ProjectWatchKey, Collection<NotifyType>> e : projectWatches.entrySet()) {
        if (e.getValue().isEmpty()) {
            // set notify to 'none' since empty sections are not persisted
            cfg.setString(PROJECT, e.getKey().toString(), KEY_NOTIFY, NOTIFY_NONE);
        } else {
            List<String> notifyValues = FluentIterable.from(e.getValue()).transform(new Function<NotifyType, String>() {

                @Override
                public String apply(NotifyType notify) {
                    return notify.name();
                }
            }).toList();
            cfg.setStringList(PROJECT, e.getKey().toString(), KEY_NOTIFY, notifyValues);
        }
    }
    saveConfig(WATCH_CONFIG, cfg);
    return true;
}
#method_after
@Override
protected boolean onSave(CommitBuilder commit) throws IOException, ConfigInvalidException {
    checkLoaded();
    if (Strings.isNullOrEmpty(commit.getMessage())) {
        commit.setMessage("Updated watch configuration\n");
    }
    Config cfg = readConfig(WATCH_CONFIG);
    for (String projectName : cfg.getSubsections(PROJECT)) {
        cfg.unset(PROJECT, projectName, KEY_NOTIFY);
    }
    Multimap<String, String> notifyValuesByProject = ArrayListMultimap.create();
    for (Map.Entry<ProjectWatchKey, Set<NotifyType>> e : projectWatches.entrySet()) {
        NotifyValue notifyValue = NotifyValue.create(e.getKey().filter(), e.getValue());
        notifyValuesByProject.put(e.getKey().project().get(), notifyValue.toString());
    }
    for (Map.Entry<String, Collection<String>> e : notifyValuesByProject.asMap().entrySet()) {
        cfg.setStringList(PROJECT, e.getKey(), KEY_NOTIFY, new ArrayList<>(e.getValue()));
    }
    saveConfig(WATCH_CONFIG, cfg);
    return true;
}
#end_block

#method_before
private void checkLoaded() {
    checkNotNull(projectWatches, "project watches not loaded yet");
}
#method_after
private void checkLoaded() {
    checkState(projectWatches != null, "project watches not loaded yet");
}
#end_block

#method_before
public final Watchers getWatchers(NotifyType type) throws OrmException {
    Watchers matching = new Watchers();
    Set<Account.Id> projectWatchers = new HashSet<>();
    for (AccountState a : args.accountQueryProvider.get().byWatchedProject(project)) {
        Account.Id accountId = a.getAccount().getId();
        for (Map.Entry<ProjectWatchKey, Collection<NotifyType>> e : a.getProjectWatches().entrySet()) {
            if (add(matching, accountId, e.getKey(), e.getValue(), type)) {
                // We only want to prevent matching All-Projects if this filter hits
                projectWatchers.add(accountId);
            }
        }
    }
    for (AccountState a : args.accountQueryProvider.get().byWatchedProject(args.allProjectsName)) {
        for (Map.Entry<ProjectWatchKey, Collection<NotifyType>> e : a.getProjectWatches().entrySet()) {
            Account.Id accountId = a.getAccount().getId();
            if (!projectWatchers.contains(accountId)) {
                add(matching, accountId, e.getKey(), e.getValue(), type);
            }
        }
    }
    for (ProjectState state : projectState.tree()) {
        for (NotifyConfig nc : state.getConfig().getNotifyConfigs()) {
            if (nc.isNotify(type)) {
                try {
                    add(matching, nc);
                } catch (QueryParseException e) {
                    log.warn("Project {} has invalid notify {} filter \"{}\": {}", state.getProject().getName(), nc.getName(), nc.getFilter(), e.getMessage());
                }
            }
        }
    }
    return matching;
}
#method_after
public final Watchers getWatchers(NotifyType type) throws OrmException {
    Watchers matching;
    if (args.accountIndexes.getSearchIndex() != null) {
        matching = getWatchersFromIndex(type);
    } else {
        matching = getWatchersFromDb(type);
    }
    for (ProjectState state : projectState.tree()) {
        for (NotifyConfig nc : state.getConfig().getNotifyConfigs()) {
            if (nc.isNotify(type)) {
                try {
                    add(matching, nc);
                } catch (QueryParseException e) {
                    log.warn("Project {} has invalid notify {} filter \"{}\": {}", state.getProject().getName(), nc.getName(), nc.getFilter(), e.getMessage());
                }
            }
        }
    }
    return matching;
}
#end_block

#method_before
private boolean add(Watchers matching, Account.Id accountId, ProjectWatchKey key, Collection<NotifyType> watchedTypes, NotifyType type) throws OrmException {
    IdentifiedUser user = args.identifiedUserFactory.create(accountId);
    try {
        if (filterMatch(user, key.filter())) {
            // Otherwise, still return true to stop notifications for this user.
            if (watchedTypes.contains(type)) {
                matching.bcc.accounts.add(accountId);
            }
            return true;
        }
    } catch (QueryParseException e) {
    // Ignore broken filter expressions.
    }
    return false;
}
#method_after
private boolean add(Watchers matching, Account.Id accountId, ProjectWatchKey key, Set<NotifyType> watchedTypes, NotifyType type) throws OrmException {
    IdentifiedUser user = args.identifiedUserFactory.create(accountId);
    try {
        if (filterMatch(user, key.filter())) {
            // Otherwise, still return true to stop notifications for this user.
            if (watchedTypes.contains(type)) {
                matching.bcc.accounts.add(accountId);
            }
            return true;
        }
    } catch (QueryParseException e) {
    // Ignore broken filter expressions.
    }
    return false;
}
#end_block

#method_before
private AccountState makeUser(final String name, final String email) {
    final Account.Id userId = new Account.Id(42);
    final Account account = new Account(userId, TimeUtil.nowTs());
    account.setFullName(name);
    account.setPreferredEmail(email);
    return new AccountState(account, Collections.<AccountGroup.UUID>emptySet(), Collections.<AccountExternalId>emptySet(), new HashMap<ProjectWatchKey, Collection<NotifyType>>());
}
#method_after
private AccountState makeUser(final String name, final String email) {
    final Account.Id userId = new Account.Id(42);
    final Account account = new Account(userId, TimeUtil.nowTs());
    account.setFullName(name);
    account.setPreferredEmail(email);
    return new AccountState(account, Collections.<AccountGroup.UUID>emptySet(), Collections.<AccountExternalId>emptySet(), new HashMap<ProjectWatchKey, Set<NotifyType>>());
}
#end_block

#method_before
private void updateInDb(Account.Id accountId, List<ProjectWatchInfo> input) throws BadRequestException, UnprocessableEntityException, IOException, OrmException {
    Set<AccountProjectWatch.Key> keys = new HashSet<>();
    List<AccountProjectWatch> watchedProjects = new LinkedList<>();
    for (ProjectWatchInfo a : input) {
        if (a.project == null) {
            throw new BadRequestException("project name must be specified");
        }
        Project.NameKey projectKey = projectsCollection.parse(a.project).getNameKey();
        AccountProjectWatch.Key key = new AccountProjectWatch.Key(accountId, projectKey, a.filter);
        if (!keys.add(key)) {
            throw new BadRequestException("duplicate entry for project " + key.getProjectName().get() + (!AccountProjectWatch.FILTER_ALL.equals(key.getFilter().get()) ? " and filter " + key.getFilter().get() : ""));
        }
        AccountProjectWatch apw = new AccountProjectWatch(key);
        apw.setNotify(AccountProjectWatch.NotifyType.ABANDONED_CHANGES, toBoolean(a.notifyAbandonedChanges));
        apw.setNotify(AccountProjectWatch.NotifyType.ALL_COMMENTS, toBoolean(a.notifyAllComments));
        apw.setNotify(AccountProjectWatch.NotifyType.NEW_CHANGES, toBoolean(a.notifyNewChanges));
        apw.setNotify(AccountProjectWatch.NotifyType.NEW_PATCHSETS, toBoolean(a.notifyNewPatchSets));
        apw.setNotify(AccountProjectWatch.NotifyType.SUBMITTED_CHANGES, toBoolean(a.notifySubmittedChanges));
        watchedProjects.add(apw);
    }
    dbProvider.get().accountProjectWatches().upsert(watchedProjects);
}
#method_after
private void updateInDb(Account.Id accountId, List<ProjectWatchInfo> input) throws BadRequestException, UnprocessableEntityException, IOException, OrmException {
    Set<AccountProjectWatch.Key> keys = new HashSet<>();
    List<AccountProjectWatch> watchedProjects = new LinkedList<>();
    for (ProjectWatchInfo a : input) {
        if (a.project == null) {
            throw new BadRequestException("project name must be specified");
        }
        Project.NameKey projectKey = projectsCollection.parse(a.project).getNameKey();
        AccountProjectWatch.Key key = new AccountProjectWatch.Key(accountId, projectKey, a.filter);
        if (!keys.add(key)) {
            throw new BadRequestException("duplicate entry for project " + format(key.getProjectName().get(), key.getFilter().get()));
        }
        AccountProjectWatch apw = new AccountProjectWatch(key);
        apw.setNotify(AccountProjectWatch.NotifyType.ABANDONED_CHANGES, toBoolean(a.notifyAbandonedChanges));
        apw.setNotify(AccountProjectWatch.NotifyType.ALL_COMMENTS, toBoolean(a.notifyAllComments));
        apw.setNotify(AccountProjectWatch.NotifyType.NEW_CHANGES, toBoolean(a.notifyNewChanges));
        apw.setNotify(AccountProjectWatch.NotifyType.NEW_PATCHSETS, toBoolean(a.notifyNewPatchSets));
        apw.setNotify(AccountProjectWatch.NotifyType.SUBMITTED_CHANGES, toBoolean(a.notifySubmittedChanges));
        watchedProjects.add(apw);
    }
    dbProvider.get().accountProjectWatches().upsert(watchedProjects);
}
#end_block

#method_before
private Map<ProjectWatchKey, Collection<NotifyType>> asMap(List<ProjectWatchInfo> input) throws BadRequestException, UnprocessableEntityException, IOException {
    Map<ProjectWatchKey, Collection<NotifyType>> m = new HashMap<>();
    for (ProjectWatchInfo info : input) {
        if (info.project == null) {
            throw new BadRequestException("project name must be specified");
        }
        ProjectWatchKey key = ProjectWatchKey.create(projectsCollection.parse(info.project).getNameKey(), info.filter);
        if (m.containsKey(key)) {
            throw new BadRequestException("duplicate entry for project " + info.project + (info.filter != null ? " and filter " + info.filter : ""));
        }
        Set<NotifyType> notifyValues = new HashSet<>();
        if (toBoolean(info.notifyAbandonedChanges)) {
            notifyValues.add(NotifyType.ABANDONED_CHANGES);
        }
        if (toBoolean(info.notifyAllComments)) {
            notifyValues.add(NotifyType.ALL_COMMENTS);
        }
        if (toBoolean(info.notifyNewChanges)) {
            notifyValues.add(NotifyType.NEW_CHANGES);
        }
        if (toBoolean(info.notifyNewPatchSets)) {
            notifyValues.add(NotifyType.NEW_PATCHSETS);
        }
        if (toBoolean(info.notifySubmittedChanges)) {
            notifyValues.add(NotifyType.SUBMITTED_CHANGES);
        }
        m.put(key, notifyValues);
    }
    return m;
}
#method_after
private Map<ProjectWatchKey, Set<NotifyType>> asMap(List<ProjectWatchInfo> input) throws BadRequestException, UnprocessableEntityException, IOException {
    Map<ProjectWatchKey, Set<NotifyType>> m = new HashMap<>();
    for (ProjectWatchInfo info : input) {
        if (info.project == null) {
            throw new BadRequestException("project name must be specified");
        }
        ProjectWatchKey key = ProjectWatchKey.create(projectsCollection.parse(info.project).getNameKey(), info.filter);
        if (m.containsKey(key)) {
            throw new BadRequestException("duplicate entry for project " + format(info.project, info.filter));
        }
        Set<NotifyType> notifyValues = EnumSet.noneOf(NotifyType.class);
        if (toBoolean(info.notifyAbandonedChanges)) {
            notifyValues.add(NotifyType.ABANDONED_CHANGES);
        }
        if (toBoolean(info.notifyAllComments)) {
            notifyValues.add(NotifyType.ALL_COMMENTS);
        }
        if (toBoolean(info.notifyNewChanges)) {
            notifyValues.add(NotifyType.NEW_CHANGES);
        }
        if (toBoolean(info.notifyNewPatchSets)) {
            notifyValues.add(NotifyType.NEW_PATCHSETS);
        }
        if (toBoolean(info.notifySubmittedChanges)) {
            notifyValues.add(NotifyType.SUBMITTED_CHANGES);
        }
        m.put(key, notifyValues);
    }
    return m;
}
#end_block

#method_before
private static AccountState newState(Account account) {
    return new AccountState(account, ImmutableSet.<AccountGroup.UUID>of(), ImmutableSet.<AccountExternalId>of(), new HashMap<ProjectWatchKey, Collection<NotifyType>>());
}
#method_after
private static AccountState newState(Account account) {
    return new AccountState(account, ImmutableSet.<AccountGroup.UUID>of(), ImmutableSet.<AccountExternalId>of(), new HashMap<ProjectWatchKey, Set<NotifyType>>());
}
#end_block

#method_before
public Map<ProjectWatchKey, Collection<NotifyType>> getProjectWatches() {
    return projectWatches;
}
#method_after
public Map<ProjectWatchKey, Set<NotifyType>> getProjectWatches() {
    return projectWatches;
}
#end_block

#method_before
private static AccountState missing(Account.Id accountId) {
    Account account = new Account(accountId, TimeUtil.nowTs());
    account.setActive(false);
    Collection<AccountExternalId> ids = Collections.emptySet();
    Set<AccountGroup.UUID> anon = ImmutableSet.of();
    return new AccountState(account, anon, ids, new HashMap<ProjectWatchKey, Collection<NotifyType>>());
}
#method_after
private static AccountState missing(Account.Id accountId) {
    Account account = new Account(accountId, TimeUtil.nowTs());
    account.setActive(false);
    Collection<AccountExternalId> ids = Collections.emptySet();
    Set<AccountGroup.UUID> anon = ImmutableSet.of();
    return new AccountState(account, anon, ids, new HashMap<ProjectWatchKey, Set<NotifyType>>());
}
#end_block

#method_before
private AccountState load(final ReviewDb db, final Account.Id who) throws OrmException, IOException, ConfigInvalidException {
    Account account = db.accounts().get(who);
    if (account == null) {
        // Account no longer exists? They are anonymous.
        return missing(who);
    }
    Collection<AccountExternalId> externalIds = Collections.unmodifiableCollection(db.accountExternalIds().byAccount(who).toList());
    Set<AccountGroup.UUID> internalGroups = new HashSet<>();
    for (AccountGroupMember g : db.accountGroupMembers().byAccount(who)) {
        final AccountGroup.Id groupId = g.getAccountGroupId();
        final AccountGroup group = groupCache.get(groupId);
        if (group != null && group.getGroupUUID() != null) {
            internalGroups.add(group.getGroupUUID());
        }
    }
    internalGroups = Collections.unmodifiableSet(internalGroups);
    try {
        account.setGeneralPreferences(loader.load(who));
    } catch (IOException | ConfigInvalidException e) {
        log.warn("Cannot load GeneralPreferences for " + who + " (using default)", e);
        account.setGeneralPreferences(GeneralPreferencesInfo.defaults());
    }
    Map<ProjectWatchKey, Collection<NotifyType>> projectWatches = readFromGit ? watchConfig.get().getProjectWatches(who) : GetWatchedProjects.readProjectWatchesFromDb(db, who);
    return new AccountState(account, internalGroups, externalIds, projectWatches);
}
#method_after
private AccountState load(final ReviewDb db, final Account.Id who) throws OrmException, IOException, ConfigInvalidException {
    Account account = db.accounts().get(who);
    if (account == null) {
        // Account no longer exists? They are anonymous.
        return missing(who);
    }
    Collection<AccountExternalId> externalIds = Collections.unmodifiableCollection(db.accountExternalIds().byAccount(who).toList());
    Set<AccountGroup.UUID> internalGroups = new HashSet<>();
    for (AccountGroupMember g : db.accountGroupMembers().byAccount(who)) {
        final AccountGroup.Id groupId = g.getAccountGroupId();
        final AccountGroup group = groupCache.get(groupId);
        if (group != null && group.getGroupUUID() != null) {
            internalGroups.add(group.getGroupUUID());
        }
    }
    internalGroups = Collections.unmodifiableSet(internalGroups);
    try {
        account.setGeneralPreferences(loader.load(who));
    } catch (IOException | ConfigInvalidException e) {
        log.warn("Cannot load GeneralPreferences for " + who + " (using default)", e);
        account.setGeneralPreferences(GeneralPreferencesInfo.defaults());
    }
    Map<ProjectWatchKey, Set<NotifyType>> projectWatches = readFromGit ? watchConfig.get().getProjectWatches(who) : GetWatchedProjects.readProjectWatchesFromDb(db, who);
    return new AccountState(account, internalGroups, externalIds, projectWatches);
}
#end_block

#method_before
@Override
public Optional<Account.Id> load(String username) throws Exception {
    try (ReviewDb db = schema.open()) {
        final AccountExternalId.Key key = new // 
        AccountExternalId.Key(// 
        AccountExternalId.SCHEME_USERNAME, username);
        final AccountExternalId id = db.accountExternalIds().get(key);
        if (id != null) {
            return Optional.of(id.getAccountId());
        }
        return Optional.absent();
    }
}
#method_after
@Override
public Optional<Account.Id> load(String username) throws Exception {
    AccountExternalId.Key key = new // 
    AccountExternalId.Key(// 
    AccountExternalId.SCHEME_USERNAME, username);
    if (accountIndexes.getSearchIndex() != null) {
        AccountState accountState = accountQueryProvider.get().oneByExternalId(key.get());
        return accountState != null ? Optional.of(accountState.getAccount().getId()) : Optional.<Account.Id>absent();
    }
    try (ReviewDb db = schema.open()) {
        AccountExternalId id = db.accountExternalIds().get(key);
        if (id != null) {
            return Optional.of(id.getAccountId());
        }
        return Optional.absent();
    }
}
#end_block

#method_before
private void deleteFromDb(Account.Id accountId, List<ProjectWatchInfo> input) throws OrmException, IOException {
    ResultSet<AccountProjectWatch> watchedProjects = dbProvider.get().accountProjectWatches().byAccount(accountId);
    HashMap<AccountProjectWatch.Key, AccountProjectWatch> watchedProjectsMap = new HashMap<>();
    for (AccountProjectWatch watchedProject : watchedProjects) {
        watchedProjectsMap.put(watchedProject.getKey(), watchedProject);
    }
    List<AccountProjectWatch> watchesToDelete = new LinkedList<>();
    for (ProjectWatchInfo projectInfo : input) {
        AccountProjectWatch.Key key = new AccountProjectWatch.Key(accountId, new Project.NameKey(projectInfo.project), projectInfo.filter);
        if (watchedProjectsMap.containsKey(key)) {
            watchesToDelete.add(watchedProjectsMap.get(key));
        }
    }
    dbProvider.get().accountProjectWatches().delete(watchesToDelete);
    accountCache.evict(accountId);
}
#method_after
private void deleteFromDb(Account.Id accountId, List<ProjectWatchInfo> input) throws OrmException, IOException {
    ResultSet<AccountProjectWatch> watchedProjects = dbProvider.get().accountProjectWatches().byAccount(accountId);
    HashMap<AccountProjectWatch.Key, AccountProjectWatch> watchedProjectsMap = new HashMap<>();
    for (AccountProjectWatch watchedProject : watchedProjects) {
        watchedProjectsMap.put(watchedProject.getKey(), watchedProject);
    }
    List<AccountProjectWatch> watchesToDelete = new LinkedList<>();
    for (ProjectWatchInfo projectInfo : input) {
        AccountProjectWatch.Key key = new AccountProjectWatch.Key(accountId, new Project.NameKey(projectInfo.project), projectInfo.filter);
        if (watchedProjectsMap.containsKey(key)) {
            watchesToDelete.add(watchedProjectsMap.get(key));
        }
    }
    if (!watchesToDelete.isEmpty()) {
        dbProvider.get().accountProjectWatches().delete(watchesToDelete);
        accountCache.evict(accountId);
    }
}
#end_block

#method_before
@Override
public List<ProjectWatchInfo> apply(AccountResource rsrc) throws OrmException, AuthException, IOException, ConfigInvalidException {
    if (self.get() != rsrc.getUser() && !self.get().getCapabilities().canAdministrateServer()) {
        throw new AuthException("It is not allowed to list project watches " + "of other users");
    }
    Account.Id accountId = rsrc.getUser().getAccountId();
    Map<ProjectWatchKey, Collection<NotifyType>> projectWatches = readFromGit ? watchConfig.getProjectWatches(accountId) : readProjectWatchesFromDb(dbProvider.get(), accountId);
    List<ProjectWatchInfo> projectWatchInfos = new LinkedList<>();
    for (Map.Entry<ProjectWatchKey, Collection<NotifyType>> e : projectWatches.entrySet()) {
        ProjectWatchInfo pwi = new ProjectWatchInfo();
        pwi.filter = e.getKey().filter();
        pwi.project = e.getKey().project().get();
        pwi.notifyAbandonedChanges = toBoolean(e.getValue().contains(NotifyType.ABANDONED_CHANGES));
        pwi.notifyNewChanges = toBoolean(e.getValue().contains(NotifyType.NEW_CHANGES));
        pwi.notifyNewPatchSets = toBoolean(e.getValue().contains(NotifyType.NEW_PATCHSETS));
        pwi.notifySubmittedChanges = toBoolean(e.getValue().contains(NotifyType.SUBMITTED_CHANGES));
        pwi.notifyAllComments = toBoolean(e.getValue().contains(NotifyType.ALL_COMMENTS));
        projectWatchInfos.add(pwi);
    }
    return projectWatchInfos;
}
#method_after
@Override
public List<ProjectWatchInfo> apply(AccountResource rsrc) throws OrmException, AuthException, IOException, ConfigInvalidException {
    if (self.get() != rsrc.getUser() && !self.get().getCapabilities().canAdministrateServer()) {
        throw new AuthException("It is not allowed to list project watches " + "of other users");
    }
    Account.Id accountId = rsrc.getUser().getAccountId();
    Map<ProjectWatchKey, Set<NotifyType>> projectWatches = readFromGit ? watchConfig.getProjectWatches(accountId) : readProjectWatchesFromDb(dbProvider.get(), accountId);
    List<ProjectWatchInfo> projectWatchInfos = new LinkedList<>();
    for (Map.Entry<ProjectWatchKey, Set<NotifyType>> e : projectWatches.entrySet()) {
        ProjectWatchInfo pwi = new ProjectWatchInfo();
        pwi.filter = e.getKey().filter();
        pwi.project = e.getKey().project().get();
        pwi.notifyAbandonedChanges = toBoolean(e.getValue().contains(NotifyType.ABANDONED_CHANGES));
        pwi.notifyNewChanges = toBoolean(e.getValue().contains(NotifyType.NEW_CHANGES));
        pwi.notifyNewPatchSets = toBoolean(e.getValue().contains(NotifyType.NEW_PATCHSETS));
        pwi.notifySubmittedChanges = toBoolean(e.getValue().contains(NotifyType.SUBMITTED_CHANGES));
        pwi.notifyAllComments = toBoolean(e.getValue().contains(NotifyType.ALL_COMMENTS));
        projectWatchInfos.add(pwi);
    }
    Collections.sort(projectWatchInfos, new Comparator<ProjectWatchInfo>() {

        @Override
        public int compare(ProjectWatchInfo pwi1, ProjectWatchInfo pwi2) {
            return ComparisonChain.start().compare(pwi1.project, pwi2.project).compare(Strings.nullToEmpty(pwi1.filter), Strings.nullToEmpty(pwi2.filter)).result();
        }
    });
    return projectWatchInfos;
}
#end_block

#method_before
public static Map<ProjectWatchKey, Collection<NotifyType>> readProjectWatchesFromDb(ReviewDb db, Account.Id who) throws OrmException {
    Map<ProjectWatchKey, Collection<NotifyType>> projectWatches = new HashMap<>();
    Collection<AccountProjectWatch> accountProjectWatches = Collections.unmodifiableCollection(db.accountProjectWatches().byAccount(who).toList());
    for (AccountProjectWatch apw : accountProjectWatches) {
        ProjectWatchKey key = ProjectWatchKey.create(apw.getProjectNameKey(), apw.getFilter());
        Set<NotifyType> notifyValues = new HashSet<>();
        if (apw.isNotify(NotifyType.ABANDONED_CHANGES)) {
            notifyValues.add(NotifyType.ABANDONED_CHANGES);
        }
        if (apw.isNotify(NotifyType.ALL_COMMENTS)) {
            notifyValues.add(NotifyType.ALL_COMMENTS);
        }
        if (apw.isNotify(NotifyType.NEW_CHANGES)) {
            notifyValues.add(NotifyType.NEW_CHANGES);
        }
        if (apw.isNotify(NotifyType.NEW_PATCHSETS)) {
            notifyValues.add(NotifyType.NEW_PATCHSETS);
        }
        if (apw.isNotify(NotifyType.SUBMITTED_CHANGES)) {
            notifyValues.add(NotifyType.SUBMITTED_CHANGES);
        }
        projectWatches.put(key, notifyValues);
    }
    return projectWatches;
}
#method_after
public static Map<ProjectWatchKey, Set<NotifyType>> readProjectWatchesFromDb(ReviewDb db, Account.Id who) throws OrmException {
    Map<ProjectWatchKey, Set<NotifyType>> projectWatches = new HashMap<>();
    for (AccountProjectWatch apw : db.accountProjectWatches().byAccount(who)) {
        ProjectWatchKey key = ProjectWatchKey.create(apw.getProjectNameKey(), apw.getFilter());
        Set<NotifyType> notifyValues = EnumSet.noneOf(NotifyType.class);
        for (NotifyType notifyType : NotifyType.values()) {
            if (apw.isNotify(notifyType)) {
                notifyValues.add(notifyType);
            }
        }
        projectWatches.put(key, notifyValues);
    }
    return projectWatches;
}
#end_block

#method_before
@Override
public void updateRepoImpl(RepoContext ctx) throws IntegrationException, IOException {
    CodeReviewCommit merged = toMerge;
    // Modify the fast forward commit with gitlink update
    if (args.submoduleOp.hasSubscription(args.destBranch)) {
        try {
            merged = args.submoduleOp.composeGitlinksCommit(args.destBranch, merged);
        } catch (SubmoduleException | OrmException e) {
            logError("can not update gitlink for the merge commit at branch: " + args.destBranch);
        }
    }
    args.mergeTip.moveTipTo(merged, toMerge);
}
#method_after
@Override
protected void updateRepoImpl(RepoContext ctx) throws IntegrationException {
    args.mergeTip.moveTipTo(amendGitlink(toMerge), toMerge);
}
#end_block

#method_before
@Override
public void updateRepoImpl(RepoContext ctx) throws IntegrationException, IOException {
    PersonIdent caller = ctx.getUser().asIdentifiedUser().newCommitterIdent(ctx.getWhen(), ctx.getTimeZone());
    if (args.mergeTip.getCurrentTip() == null) {
        throw new IllegalStateException("cannot merge commit " + toMerge.name() + " onto a null tip; expected at least one fast-forward prior to" + " this operation");
    }
    // TODO(dborowitz): args.rw is needed because it's a CodeReviewRevWalk.
    // When hoisting BatchUpdate into MergeOp, we will need to teach
    // BatchUpdate how to produce CodeReviewRevWalks.
    CodeReviewCommit merged = args.mergeUtil.mergeOneCommit(caller, args.serverIdent, ctx.getRepository(), args.rw, ctx.getInserter(), args.destBranch, args.mergeTip.getCurrentTip(), toMerge);
    // Modify the mergy commit with gitlink update
    if (args.submoduleOp.hasSubscription(args.destBranch)) {
        try {
            merged = args.submoduleOp.composeGitlinksCommit(args.destBranch, merged);
        } catch (SubmoduleException | OrmException e) {
            logError("can not update gitlink for the merge commit at branch: " + args.destBranch);
        }
    }
    args.mergeTip.moveTipTo(merged, toMerge);
}
#method_after
@Override
public void updateRepoImpl(RepoContext ctx) throws IntegrationException, IOException {
    PersonIdent caller = ctx.getIdentifiedUser().newCommitterIdent(ctx.getWhen(), ctx.getTimeZone());
    if (args.mergeTip.getCurrentTip() == null) {
        throw new IllegalStateException("cannot merge commit " + toMerge.name() + " onto a null tip; expected at least one fast-forward prior to" + " this operation");
    }
    // TODO(dborowitz): args.rw is needed because it's a CodeReviewRevWalk.
    // When hoisting BatchUpdate into MergeOp, we will need to teach
    // BatchUpdate how to produce CodeReviewRevWalks.
    CodeReviewCommit merged = args.mergeUtil.mergeOneCommit(caller, args.serverIdent, ctx.getRepository(), args.rw, ctx.getInserter(), args.destBranch, args.mergeTip.getCurrentTip(), toMerge);
    args.mergeTip.moveTipTo(amendGitlink(merged), toMerge);
}
#end_block

#method_before
private void checkSubmitRulesAndState() throws ResourceConflictException {
    for (ChangeData cd : commits.changes.values()) {
        try {
            if (cd.change().getStatus() != Change.Status.NEW) {
                commits.problem(cd.getId(), "Change " + cd.getId() + " is " + cd.change().getStatus().toString().toLowerCase());
            } else {
                checkSubmitRule(cd);
            }
        } catch (ResourceConflictException e) {
            commits.problem(cd.getId(), e.getMessage());
        } catch (OrmException e) {
            String msg = "Error checking submit rules for change";
            log.warn(msg + " " + cd.getId(), e);
            commits.problem(cd.getId(), msg);
        }
    }
    commits.maybeFailVerbose();
}
#method_after
private void checkSubmitRulesAndState(ChangeSet cs) throws ResourceConflictException {
    checkArgument(!cs.furtherHiddenChanges(), "checkSubmitRulesAndState called for topic with hidden change");
    for (ChangeData cd : cs.changes()) {
        try {
            if (cd.change().getStatus() != Change.Status.NEW) {
                commits.problem(cd.getId(), "Change " + cd.getId() + " is " + cd.change().getStatus().toString().toLowerCase());
            } else {
                checkSubmitRule(cd);
            }
        } catch (ResourceConflictException e) {
            commits.problem(cd.getId(), e.getMessage());
        } catch (OrmException e) {
            String msg = "Error checking submit rules for change";
            log.warn(msg + " " + cd.getId(), e);
            commits.problem(cd.getId(), msg);
        }
    }
    commits.maybeFailVerbose();
}
#end_block

#method_before
private void bypassSubmitRules(ChangeSet cs) {
    for (ChangeData cd : cs.changes()) {
        List<SubmitRecord> records;
        try {
            records = new ArrayList<>(getSubmitRecords(cd));
        } catch (OrmException e) {
            log.warn("Error checking submit rules for change " + cd.getId(), e);
            records = new ArrayList<>(1);
        }
        SubmitRecord forced = new SubmitRecord();
        forced.status = SubmitRecord.Status.FORCED;
        records.add(forced);
        cd.setSubmitRecords(records);
    }
}
#method_after
private void bypassSubmitRules(ChangeSet cs) {
    checkArgument(!cs.furtherHiddenChanges(), "cannot bypass submit rules for topic with hidden change");
    for (ChangeData cd : cs.changes()) {
        List<SubmitRecord> records;
        try {
            records = new ArrayList<>(getSubmitRecords(cd));
        } catch (OrmException e) {
            log.warn("Error checking submit rules for change " + cd.getId(), e);
            records = new ArrayList<>(1);
        }
        SubmitRecord forced = new SubmitRecord();
        forced.status = SubmitRecord.Status.FORCED;
        records.add(forced);
        cd.setSubmitRecords(records);
    }
}
#end_block

#method_before
public void merge(ReviewDb db, Change change, IdentifiedUser caller, boolean checkSubmitRules, SubmitInput submitInput) throws OrmException, RestApiException {
    this.submitInput = submitInput;
    this.caller = caller;
    updateSubmissionId(change);
    this.db = db;
    orm.setContext(db, ts, caller, submissionId);
    logDebug("Beginning integration of {}", change);
    try {
        ChangeSet cs = mergeSuperSet.completeChangeSet(db, change, caller);
        checkState(cs.ids().contains(change.getId()), "change %s missing from %s", change.getId(), cs);
        this.commits = new CommitStatus(cs);
        MergeSuperSet.reloadChanges(cs);
        logDebug("Calculated to merge {}", cs);
        if (checkSubmitRules) {
            logDebug("Checking submit rules and state");
            checkSubmitRulesAndState();
        } else {
            logDebug("Bypassing submit rules");
            bypassSubmitRules(cs);
        }
        try {
            integrateIntoHistory(cs);
        } catch (IntegrationException e) {
            logError("Error from integrateIntoHistory", e);
            throw new ResourceConflictException(e.getMessage(), e);
        }
    } catch (IOException e) {
        // Anything before the merge attempt is an error
        throw new OrmException(e);
    }
}
#method_after
public void merge(ReviewDb db, Change change, IdentifiedUser caller, boolean checkSubmitRules, SubmitInput submitInput) throws OrmException, RestApiException {
    this.submitInput = submitInput;
    this.caller = caller;
    updateSubmissionId(change);
    this.db = db;
    orm.setContext(db, ts, caller, submissionId);
    logDebug("Beginning integration of {}", change);
    try {
        ChangeSet cs = mergeSuperSet.completeChangeSet(db, change, caller);
        checkState(cs.ids().contains(change.getId()), "change %s missing from %s", change.getId(), cs);
        if (cs.furtherHiddenChanges()) {
            throw new AuthException("A change to be submitted with " + change.getId() + " is not visible");
        }
        this.commits = new CommitStatus(cs);
        MergeSuperSet.reloadChanges(cs);
        logDebug("Calculated to merge {}", cs);
        if (checkSubmitRules) {
            logDebug("Checking submit rules and state");
            checkSubmitRulesAndState(cs);
        } else {
            logDebug("Bypassing submit rules");
            bypassSubmitRules(cs);
        }
        try {
            integrateIntoHistory(cs);
        } catch (IntegrationException e) {
            logError("Error from integrateIntoHistory", e);
            throw new ResourceConflictException(e.getMessage(), e);
        }
    } catch (IOException e) {
        // Anything before the merge attempt is an error
        throw new OrmException(e);
    }
}
#end_block

#method_before
private void integrateIntoHistory(ChangeSet cs) throws IntegrationException, RestApiException {
    logDebug("Beginning merge attempt on {}", cs);
    Map<Branch.NameKey, BranchBatch> toSubmit = new HashMap<>();
    logDebug("Perform the merges");
    Multimap<Project.NameKey, Branch.NameKey> br;
    Multimap<Branch.NameKey, ChangeData> cbb;
    try {
        br = cs.branchesByProject();
        cbb = cs.changesByBranch();
    } catch (OrmException e) {
        throw new IntegrationException("Error reading changes to submit", e);
    }
    Set<Project.NameKey> projectsWithChanges = br.keySet();
    Collection<Branch.NameKey> branchesWithChanges = cbb.keySet();
    openRepos(projectsWithChanges);
    for (Branch.NameKey branch : branchesWithChanges) {
        OpenRepo or = orm.getRepo(branch.getParentKey());
        toSubmit.put(branch, validateChangeList(or, cbb.get(branch)));
    }
    // Done checks that don't involve running submit strategies.
    commits.maybeFailVerbose();
    List<SubmitStrategy> strategies = new ArrayList<>();
    SubmoduleOp submoduleOp = subOpFactory.create(br.values(), orm);
    try {
        LinkedHashSet<Branch.NameKey> branches = submoduleOp.getOrdedBranches();
        for (Branch.NameKey branch : branchesWithChanges) {
            if (!branches.contains(branch)) {
                branches.add(branch);
            }
        }
        for (Branch.NameKey branch : branches) {
            OpenRepo or = orm.getRepo(branch.getParentKey());
            if (cbb.containsKey(branch)) {
                BranchBatch submitting = toSubmit.get(branch);
                OpenBranch ob = or.getBranch(branch);
                checkNotNull(submitting.submitType(), "null submit type for %s; expected to previously fail fast", submitting);
                Set<CodeReviewCommit> commitsToSubmit = commits(submitting.changes());
                ob.mergeTip = new MergeTip(ob.oldTip, commitsToSubmit);
                SubmitStrategy strategy = createStrategy(or, ob.mergeTip, branch, submitting.submitType(), ob.oldTip, submoduleOp);
                strategies.add(strategy);
                strategy.addOps(or.getUpdate(), commitsToSubmit);
            } else {
                // no open change for this branch
                // add submodule triggered op into BatchUpdate
                or.getUpdate().addRepoOnlyOp(new SubmoduleOp.RepoOnlyOp(submoduleOp, branch));
            }
        }
        LinkedHashSet<Project.NameKey> projects = submoduleOp.getOrdedProjects();
        for (Project.NameKey project : projectsWithChanges) {
            if (!projects.contains(project)) {
                projects.add(project);
            }
        }
        BatchUpdate.execute(orm.batchUpdates(projects), new SubmitStrategyListener(submitInput, strategies, commits));
    } catch (UpdateException | SubmoduleException e) {
        // BatchUpdate may have inadvertently wrapped an IntegrationException
        // thrown by some legacy SubmitStrategyOp code that intended the error
        // message to be user-visible. Copy the message from the wrapped
        // exception.
        // 
        // If you happen across one of these, the correct fix is to convert the
        // inner IntegrationException to a ResourceConflictException.
        String msg;
        if (e.getCause() instanceof IntegrationException) {
            msg = e.getCause().getMessage();
        } else {
            msg = "Error submitting change" + (cs.size() != 1 ? "s" : "");
        }
        throw new IntegrationException(msg, e);
    }
}
#method_after
private void integrateIntoHistory(ChangeSet cs) throws IntegrationException, RestApiException {
    checkArgument(!cs.furtherHiddenChanges(), "cannot integrate hidden changes into history");
    logDebug("Beginning merge attempt on {}", cs);
    Map<Branch.NameKey, BranchBatch> toSubmit = new HashMap<>();
    logDebug("Perform the merges");
    Multimap<Project.NameKey, Branch.NameKey> br;
    Multimap<Branch.NameKey, ChangeData> cbb;
    try {
        br = cs.branchesByProject();
        cbb = cs.changesByBranch();
    } catch (OrmException e) {
        throw new IntegrationException("Error reading changes to submit", e);
    }
    Set<Project.NameKey> projects = br.keySet();
    Set<Branch.NameKey> branches = cbb.keySet();
    openRepos(projects);
    for (Branch.NameKey branch : branches) {
        OpenRepo or = orm.getRepo(branch.getParentKey());
        toSubmit.put(branch, validateChangeList(or, cbb.get(branch)));
    }
    // Done checks that don't involve running submit strategies.
    commits.maybeFailVerbose();
    SubmoduleOp submoduleOp = subOpFactory.create(branches, orm);
    try {
        List<SubmitStrategy> strategies = getSubmitStrategies(toSubmit, submoduleOp);
        Set<Project.NameKey> allProjects = submoduleOp.getProjectsInOrder();
        // in case superproject subscription is disabled, allProjects would be null
        if (allProjects == null) {
            allProjects = projects;
        }
        BatchUpdate.execute(orm.batchUpdates(allProjects), new SubmitStrategyListener(submitInput, strategies, commits));
    } catch (UpdateException | SubmoduleException e) {
        // BatchUpdate may have inadvertently wrapped an IntegrationException
        // thrown by some legacy SubmitStrategyOp code that intended the error
        // message to be user-visible. Copy the message from the wrapped
        // exception.
        // 
        // If you happen across one of these, the correct fix is to convert the
        // inner IntegrationException to a ResourceConflictException.
        String msg;
        if (e.getCause() instanceof IntegrationException) {
            msg = e.getCause().getMessage();
        } else {
            msg = "Error submitting change" + (cs.size() != 1 ? "s" : "") + ": \n" + e.getMessage();
        }
        throw new IntegrationException(msg, e);
    }
}
#end_block

#method_before
private Set<RevCommit> getAlreadyAccepted(OpenRepo or, CodeReviewCommit branchTip) throws IntegrationException {
    Set<RevCommit> alreadyAccepted = new HashSet<>();
    if (branchTip != null) {
        alreadyAccepted.add(branchTip);
    }
    try {
        for (Ref r : or.repo.getRefDatabase().getRefs(Constants.R_HEADS).values()) {
            try {
                alreadyAccepted.add(or.rw.parseCommit(r.getObjectId()));
            } catch (IncorrectObjectTypeException iote) {
            // Not a commit? Skip over it.
            }
        }
    } catch (IOException e) {
        throw new IntegrationException("Failed to determine already accepted commits.", e);
    }
    logDebug("Found {} existing heads", alreadyAccepted.size());
    return alreadyAccepted;
}
#method_after
private Set<RevCommit> getAlreadyAccepted(OpenRepo or, CodeReviewCommit branchTip) throws IntegrationException {
    Set<RevCommit> alreadyAccepted = new HashSet<>();
    if (branchTip != null) {
        alreadyAccepted.add(branchTip);
    }
    try {
        for (Ref r : or.repo.getRefDatabase().getRefs(Constants.R_HEADS).values()) {
            try {
                CodeReviewCommit aac = or.rw.parseCommit(r.getObjectId());
                if (!commits.commits.values().contains(aac)) {
                    alreadyAccepted.add(aac);
                }
            } catch (IncorrectObjectTypeException iote) {
            // Not a commit? Skip over it.
            }
        }
    } catch (IOException e) {
        throw new IntegrationException("Failed to determine already accepted commits.", e);
    }
    logDebug("Found {} existing heads", alreadyAccepted.size());
    return alreadyAccepted;
}
#end_block

#method_before
private LabelNormalizer.Result approve(ChangeContext ctx, ChangeUpdate update) throws OrmException {
    PatchSet.Id psId = update.getPatchSetId();
    Map<PatchSetApproval.Key, PatchSetApproval> byKey = new HashMap<>();
    for (PatchSetApproval psa : args.approvalsUtil.byPatchSet(ctx.getDb(), ctx.getControl(), psId)) {
        byKey.put(psa.getKey(), psa);
    }
    submitter = new PatchSetApproval(new PatchSetApproval.Key(psId, ctx.getUser().getAccountId(), LabelId.legacySubmit()), (short) 1, ctx.getWhen());
    byKey.put(submitter.getKey(), submitter);
    submitter.setValue((short) 1);
    submitter.setGranted(ctx.getWhen());
    // Flatten out existing approvals for this patch set based upon the current
    // permissions. Once the change is closed the approvals are not updated at
    // presentation view time, except for zero votes used to indicate a reviewer
    // was added. So we need to make sure votes are accurate now. This way if
    // permissions get modified in the future, historical records stay accurate.
    LabelNormalizer.Result normalized = args.labelNormalizer.normalize(ctx.getControl(), byKey.values());
    update.putApproval(submitter.getLabel(), submitter.getValue());
    saveApprovals(normalized, ctx, update, false);
    return normalized;
}
#method_after
private LabelNormalizer.Result approve(ChangeContext ctx, ChangeUpdate update) throws OrmException {
    PatchSet.Id psId = update.getPatchSetId();
    Map<PatchSetApproval.Key, PatchSetApproval> byKey = new HashMap<>();
    for (PatchSetApproval psa : args.approvalsUtil.byPatchSet(ctx.getDb(), ctx.getControl(), psId)) {
        byKey.put(psa.getKey(), psa);
    }
    submitter = new PatchSetApproval(new PatchSetApproval.Key(psId, ctx.getAccountId(), LabelId.legacySubmit()), (short) 1, ctx.getWhen());
    byKey.put(submitter.getKey(), submitter);
    submitter.setValue((short) 1);
    submitter.setGranted(ctx.getWhen());
    // Flatten out existing approvals for this patch set based upon the current
    // permissions. Once the change is closed the approvals are not updated at
    // presentation view time, except for zero votes used to indicate a reviewer
    // was added. So we need to make sure votes are accurate now. This way if
    // permissions get modified in the future, historical records stay accurate.
    LabelNormalizer.Result normalized = args.labelNormalizer.normalize(ctx.getControl(), byKey.values());
    update.putApproval(submitter.getLabel(), submitter.getValue());
    saveApprovals(normalized, ctx, update, false);
    return normalized;
}
#end_block

#method_before
private ChangeMessage message(ChangeContext ctx, PatchSet.Id psId, String body) {
    checkNotNull(psId);
    String uuid;
    try {
        uuid = ChangeUtil.messageUUID(ctx.getDb());
    } catch (OrmException e) {
        return null;
    }
    ChangeMessage m = new ChangeMessage(new ChangeMessage.Key(psId.getParentKey(), uuid), ctx.getUser().getAccountId(), ctx.getWhen(), psId);
    m.setMessage(body);
    return m;
}
#method_after
private ChangeMessage message(ChangeContext ctx, PatchSet.Id psId, String body) {
    checkNotNull(psId);
    String uuid;
    try {
        uuid = ChangeUtil.messageUUID(ctx.getDb());
    } catch (OrmException e) {
        return null;
    }
    ChangeMessage m = new ChangeMessage(new ChangeMessage.Key(psId.getParentKey(), uuid), ctx.getAccountId(), ctx.getWhen(), psId);
    m.setMessage(body);
    return m;
}
#end_block

#method_before
@Override
public final void postUpdate(Context ctx) throws Exception {
    postUpdateImpl(ctx);
    if (command != null) {
        args.tagCache.updateFastForward(getProject(), command.getRefName(), command.getOldId(), command.getNewId());
        // per project even if multiple changes to refs/meta/config are submitted.
        if (RefNames.REFS_CONFIG.equals(getDest().get())) {
            args.projectCache.evict(getProject());
            ProjectState p = args.projectCache.get(getProject());
            args.repoManager.setProjectDescription(p.getProject().getNameKey(), p.getProject().getDescription());
        }
    }
    // have failed fast in one of the other steps.
    try {
        args.mergedSenderFactory.create(ctx.getProject(), getId(), submitter.getAccountId(), args.notifyHandling).sendAsync();
    } catch (Exception e) {
        log.error("Cannot email merged notification for " + getId(), e);
    }
    if (mergeResultRev != null) {
        try {
            args.hooks.doChangeMergedHook(updatedChange, args.accountCache.get(submitter.getAccountId()).getAccount(), mergedPatchSet, ctx.getDb(), args.mergeTip.getCurrentTip().name());
        } catch (OrmException ex) {
            logError("Cannot run hook for submitted patch set " + getId(), ex);
        }
    }
}
#method_after
@Override
public final void postUpdate(Context ctx) throws Exception {
    postUpdateImpl(ctx);
    if (command != null) {
        args.tagCache.updateFastForward(getProject(), command.getRefName(), command.getOldId(), command.getNewId());
        // per project even if multiple changes to refs/meta/config are submitted.
        if (RefNames.REFS_CONFIG.equals(getDest().get())) {
            args.projectCache.evict(getProject());
            ProjectState p = args.projectCache.get(getProject());
            args.repoManager.setProjectDescription(p.getProject().getNameKey(), p.getProject().getDescription());
        }
    }
    // have failed fast in one of the other steps.
    try {
        args.mergedSenderFactory.create(ctx.getProject(), getId(), submitter.getAccountId(), args.notifyHandling).sendAsync();
    } catch (Exception e) {
        log.error("Cannot email merged notification for " + getId(), e);
    }
    if (mergeResultRev != null) {
        args.changeMerged.fire(updatedChange, mergedPatchSet, args.accountCache.get(submitter.getAccountId()).getAccount(), args.mergeTip.getCurrentTip().name(), ctx.getWhen());
    }
}
#end_block

#method_before
private Collection<SubmoduleSubscription> superProjectSubscriptionsForSubmoduleBranch(Branch.NameKey srcBranch) throws IOException {
    logDebug("Calculating possible superprojects for " + srcBranch);
    Collection<SubmoduleSubscription> ret = new ArrayList<>();
    Project.NameKey srcProject = srcBranch.getParentKey();
    ProjectConfig cfg = projectCache.get(srcProject).getConfig();
    for (SubscribeSection s : projectStateFactory.create(cfg).getSubscribeSections(srcBranch)) {
        logDebug("Checking subscribe section " + s);
        Collection<Branch.NameKey> branches = getDestinationBranches(srcBranch, s);
        for (Branch.NameKey targetBranch : branches) {
            Project.NameKey targetProject = targetBranch.getParentKey();
            try {
                orm.openRepo(targetProject, false);
                OpenRepo or = orm.getRepo(targetProject);
                ObjectId id = or.repo.resolve(targetBranch.get());
                if (id == null) {
                    logDebug("The branch " + targetBranch + " doesn't exist.");
                    continue;
                }
            } catch (NoSuchProjectException e) {
                logDebug("The project " + targetProject + " doesn't exist");
                continue;
            }
            GitModules m = gitmodulesFactory.create(targetBranch, orm);
            for (SubmoduleSubscription ss : m.subscribedTo(srcBranch)) {
                logDebug("Checking SubmoduleSubscription " + ss);
                if (projectCache.get(ss.getSubmodule().getParentKey()) != null) {
                    logDebug("Adding SubmoduleSubscription " + ss);
                    ret.add(ss);
                }
            }
        }
    }
    logDebug("Calculated superprojects for " + srcBranch + " are " + ret);
    return ret;
}
#method_after
public Collection<SubmoduleSubscription> superProjectSubscriptionsForSubmoduleBranch(Branch.NameKey srcBranch) throws IOException {
    logDebug("Calculating possible superprojects for " + srcBranch);
    Collection<SubmoduleSubscription> ret = new ArrayList<>();
    Project.NameKey srcProject = srcBranch.getParentKey();
    ProjectConfig cfg = projectCache.get(srcProject).getConfig();
    for (SubscribeSection s : projectStateFactory.create(cfg).getSubscribeSections(srcBranch)) {
        logDebug("Checking subscribe section " + s);
        Collection<Branch.NameKey> branches = getDestinationBranches(srcBranch, s);
        for (Branch.NameKey targetBranch : branches) {
            Project.NameKey targetProject = targetBranch.getParentKey();
            try {
                orm.openRepo(targetProject, false);
                OpenRepo or = orm.getRepo(targetProject);
                ObjectId id = or.repo.resolve(targetBranch.get());
                if (id == null) {
                    logDebug("The branch " + targetBranch + " doesn't exist.");
                    continue;
                }
            } catch (NoSuchProjectException e) {
                logDebug("The project " + targetProject + " doesn't exist");
                continue;
            }
            GitModules m = branchGitModules.get(targetBranch);
            if (m == null) {
                m = gitmodulesFactory.create(targetBranch, orm);
                branchGitModules.put(targetBranch, m);
            }
            ret.addAll(m.subscribedTo(srcBranch));
        }
    }
    logDebug("Calculated superprojects for " + srcBranch + " are " + ret);
    return ret;
}
#end_block

#method_before
public void updateSuperProjects() throws SubmoduleException {
    SetMultimap<Project.NameKey, Branch.NameKey> dst = branchesByProject();
    LinkedHashSet<Project.NameKey> projects = getOrdedProjects();
    try {
        for (Project.NameKey project : projects) {
            // get a new BatchUpdate for the project
            orm.openRepo(project, false);
            orm.getRepo(project).resetUpdate();
            for (Branch.NameKey branch : dst.get(project)) {
                SubmoduleOp.RepoOnlyOp op = new SubmoduleOp.RepoOnlyOp(this, branch);
                orm.getRepo(project).getUpdate().addRepoOnlyOp(op);
            }
        }
        BatchUpdate.execute(orm.batchUpdates(projects), new Listener());
    } catch (RestApiException | UpdateException | IOException | NoSuchProjectException e) {
        throw new SubmoduleException("Cannot update gitlinks", e);
    }
}
#method_after
public void updateSuperProjects() throws SubmoduleException {
    ImmutableSet<Project.NameKey> projects = getProjectsInOrder();
    if (projects == null) {
        return;
    }
    SetMultimap<Project.NameKey, Branch.NameKey> dst = branchesByProject();
    LinkedHashSet<Project.NameKey> superProjects = new LinkedHashSet<>();
    try {
        for (Project.NameKey project : projects) {
            // only need superprojects
            if (dst.containsKey(project)) {
                superProjects.add(project);
                // get a new BatchUpdate for the super project
                orm.openRepo(project, false);
                for (Branch.NameKey branch : dst.get(project)) {
                    addOp(orm.getRepo(project).getUpdate(), branch);
                }
            }
        }
        BatchUpdate.execute(orm.batchUpdates(superProjects), Listener.NONE);
    } catch (RestApiException | UpdateException | IOException | NoSuchProjectException e) {
        throw new SubmoduleException("Cannot update gitlinks", e);
    }
}
#end_block

#method_before
public CodeReviewCommit composeGitlinksCommit(final Branch.NameKey subscriber, RevCommit baseCommit) throws IOException, SubmoduleException, OrmException {
    PersonIdent author = null;
    StringBuilder msgbuf = new StringBuilder("Update git submodules\n\n");
    boolean sameAuthorForAll = true;
    try {
        orm.openRepo(subscriber.getParentKey(), false);
    } catch (NoSuchProjectException | IOException e) {
        throw new SubmoduleException("Cannot access superproject", e);
    }
    OpenRepo or = orm.getRepo(subscriber.getParentKey());
    Ref r = or.repo.exactRef(subscriber.get());
    if (r == null) {
        throw new SubmoduleException("The branch was probably deleted from the subscriber repository");
    }
    RevCommit currentCommit = (baseCommit != null) ? baseCommit : or.rw.parseCommit(or.repo.exactRef(subscriber.get()).getObjectId());
    or.rw.parseBody(currentCommit);
    DirCache dc = readTree(or.rw, currentCommit);
    DirCacheEditor ed = dc.editor();
    for (SubmoduleSubscription s : targets.get(subscriber)) {
        try {
            orm.openRepo(s.getSubmodule().getParentKey(), false);
        } catch (NoSuchProjectException | IOException e) {
            throw new SubmoduleException("Cannot access submodule", e);
        }
        OpenRepo subOr = orm.getRepo(s.getSubmodule().getParentKey());
        Repository subRepo = subOr.repo;
        Ref ref = subRepo.getRefDatabase().exactRef(s.getSubmodule().get());
        if (ref == null) {
            ed.add(new DeletePath(s.getPath()));
            continue;
        }
        ObjectId updateTo = ref.getObjectId();
        if (branchTips.containsKey(s.getSubmodule())) {
            updateTo = branchTips.get(s.getSubmodule());
        }
        RevWalk subOrRw = subOr.rw;
        final RevCommit newCommit = subOrRw.parseCommit(updateTo);
        subOrRw.parseBody(newCommit);
        if (author == null) {
            author = newCommit.getAuthorIdent();
        } else if (!author.equals(newCommit.getAuthorIdent())) {
            sameAuthorForAll = false;
        }
        DirCacheEntry dce = dc.getEntry(s.getPath());
        ObjectId oldId;
        if (dce != null) {
            if (!dce.getFileMode().equals(FileMode.GITLINK)) {
                log.error("Requested to update gitlink " + s.getPath() + " in " + s.getSubmodule().getParentKey().get() + " but entry " + "doesn't have gitlink file mode.");
                continue;
            }
            oldId = dce.getObjectId();
        } else {
            // This submodule did not exist before. We do not want to add
            // the full submodule history to the commit message, so omit it.
            oldId = updateTo;
        }
        ed.add(new PathEdit(s.getPath()) {

            @Override
            public void apply(DirCacheEntry ent) {
                ent.setFileMode(FileMode.GITLINK);
                ent.setObjectId(newCommit.getId());
            }
        });
        if (verboseSuperProject) {
            msgbuf.append("Project: " + s.getSubmodule().getParentKey().get());
            msgbuf.append(" " + s.getSubmodule().getShortName());
            msgbuf.append(" " + newCommit.getName());
            msgbuf.append("\n\n");
            try {
                subOrRw.resetRetain(subOr.canMergeFlag);
                subOrRw.markStart(newCommit);
                subOrRw.markUninteresting(subOrRw.parseCommit(oldId));
                for (RevCommit c : subOrRw) {
                    subOrRw.parseBody(c);
                    msgbuf.append(c.getFullMessage() + "\n\n");
                }
            } catch (IOException e) {
                throw new SubmoduleException("Could not perform a revwalk to " + "create superproject commit message", e);
            }
        }
    }
    ed.finish();
    ObjectInserter oi = or.repo.newObjectInserter();
    CodeReviewRevWalk rw = or.rw;
    ObjectId tree = dc.writeTree(oi);
    if (!sameAuthorForAll || author == null) {
        author = myIdent;
    }
    CommitBuilder commit = new CommitBuilder();
    commit.setTreeId(tree);
    if (baseCommit != null) {
        // modify the baseCommit
        commit.setParentIds(baseCommit.getParents());
        commit.setMessage(baseCommit.getFullMessage() + "\n\n" + msgbuf.toString());
        commit.setAuthor(baseCommit.getAuthorIdent());
    } else {
        // create a new commit
        commit.setParentId(currentCommit);
        commit.setMessage(msgbuf.toString());
        commit.setAuthor(author);
    }
    commit.setCommitter(myIdent);
    ObjectId id = oi.insert(commit);
    oi.flush();
    return rw.parseCommit(id);
}
#method_after
public CodeReviewCommit composeGitlinksCommit(final Branch.NameKey subscriber, RevCommit baseCommit) throws IOException, SubmoduleException {
    PersonIdent author = null;
    StringBuilder msgbuf = new StringBuilder("Update git submodules\n\n");
    boolean sameAuthorForAll = true;
    try {
        orm.openRepo(subscriber.getParentKey(), false);
    } catch (NoSuchProjectException | IOException e) {
        throw new SubmoduleException("Cannot access superproject", e);
    }
    OpenRepo or = orm.getRepo(subscriber.getParentKey());
    Ref r = or.repo.exactRef(subscriber.get());
    if (r == null) {
        throw new SubmoduleException("The branch was probably deleted from the subscriber repository");
    }
    RevCommit currentCommit = (baseCommit != null) ? baseCommit : or.rw.parseCommit(or.repo.exactRef(subscriber.get()).getObjectId());
    or.rw.parseBody(currentCommit);
    DirCache dc = readTree(or.rw, currentCommit);
    DirCacheEditor ed = dc.editor();
    for (SubmoduleSubscription s : targets.get(subscriber)) {
        try {
            orm.openRepo(s.getSubmodule().getParentKey(), false);
        } catch (NoSuchProjectException | IOException e) {
            throw new SubmoduleException("Cannot access submodule", e);
        }
        OpenRepo subOr = orm.getRepo(s.getSubmodule().getParentKey());
        Repository subRepo = subOr.repo;
        Ref ref = subRepo.getRefDatabase().exactRef(s.getSubmodule().get());
        if (ref == null) {
            ed.add(new DeletePath(s.getPath()));
            continue;
        }
        ObjectId updateTo = ref.getObjectId();
        if (branchTips.containsKey(s.getSubmodule())) {
            updateTo = branchTips.get(s.getSubmodule());
        }
        RevWalk subOrRw = subOr.rw;
        final RevCommit newCommit = subOrRw.parseCommit(updateTo);
        subOrRw.parseBody(newCommit);
        if (author == null) {
            author = newCommit.getAuthorIdent();
        } else if (!author.equals(newCommit.getAuthorIdent())) {
            sameAuthorForAll = false;
        }
        DirCacheEntry dce = dc.getEntry(s.getPath());
        ObjectId oldId;
        if (dce != null) {
            if (!dce.getFileMode().equals(FileMode.GITLINK)) {
                String errMsg = "Requested to update gitlink " + s.getPath() + " in " + s.getSubmodule().getParentKey().get() + " but entry " + "doesn't have gitlink file mode.";
                throw new SubmoduleException(errMsg);
            }
            oldId = dce.getObjectId();
        } else {
            // This submodule did not exist before. We do not want to add
            // the full submodule history to the commit message, so omit it.
            oldId = updateTo;
        }
        ed.add(new PathEdit(s.getPath()) {

            @Override
            public void apply(DirCacheEntry ent) {
                ent.setFileMode(FileMode.GITLINK);
                ent.setObjectId(newCommit.getId());
            }
        });
        if (verboseSuperProject) {
            msgbuf.append("Project: " + s.getSubmodule().getParentKey().get());
            msgbuf.append(" " + s.getSubmodule().getShortName());
            msgbuf.append(" " + newCommit.getName());
            msgbuf.append("\n\n");
            try {
                subOrRw.resetRetain(subOr.canMergeFlag);
                subOrRw.markStart(newCommit);
                subOrRw.markUninteresting(subOrRw.parseCommit(oldId));
                for (RevCommit c : subOrRw) {
                    subOrRw.parseBody(c);
                    msgbuf.append(c.getFullMessage() + "\n\n");
                }
            } catch (IOException e) {
                throw new SubmoduleException("Could not perform a revwalk to " + "create superproject commit message", e);
            }
        }
    }
    ed.finish();
    ObjectInserter oi = or.ins;
    CodeReviewRevWalk rw = or.rw;
    ObjectId tree = dc.writeTree(oi);
    if (!sameAuthorForAll || author == null) {
        author = myIdent;
    }
    CommitBuilder commit = new CommitBuilder();
    commit.setTreeId(tree);
    if (baseCommit != null) {
        // modify the baseCommit
        commit.setParentIds(baseCommit.getParents());
        commit.setMessage(baseCommit.getFullMessage() + "\n\n" + msgbuf.toString());
        commit.setAuthor(baseCommit.getAuthorIdent());
    } else {
        // create a new commit
        commit.setParentId(currentCommit);
        commit.setMessage(msgbuf.toString());
        commit.setAuthor(author);
    }
    commit.setCommitter(myIdent);
    ObjectId id = oi.insert(commit);
    return rw.parseCommit(id);
}
#end_block

#method_before
private PatchList readPatchList(final PatchListKey key, final Repository repo) throws IOException, PatchListNotAvailableException {
    final RawTextComparator cmp = comparatorFor(key.getWhitespace());
    try (ObjectReader reader = repo.newObjectReader();
        RevWalk rw = new RevWalk(reader);
        DiffFormatter df = new DiffFormatter(DisabledOutputStream.INSTANCE)) {
        // b - current commit object (not a hash commit)
        final RevCommit b = rw.parseCommit(key.getNewId());
        // a - ancestor object
        final RevObject a = aFor(key, repo, rw, b);
        if (a == null) {
            // TODO(sop) Remove this case.
            // This is a merge commit, compared to its ancestor.
            // 
            final PatchListEntry[] entries = new PatchListEntry[1];
            entries[0] = newCommitMessage(cmp, reader, null, b);
            return new PatchList(a, b, true, entries);
        }
        final boolean againstParent = b.getParentCount() > 0 && b.getParent(0) == a;
        RevCommit aCommit = a instanceof RevCommit ? (RevCommit) a : null;
        RevTree aTree = rw.parseTree(a);
        RevTree bTree = b.getTree();
        df.setRepository(repo);
        df.setDiffComparator(cmp);
        df.setDetectRenames(true);
        List<DiffEntry> diffEntries = df.scan(aTree, bTree);
        Set<String> paths = null;
        if (key.getOldId() != null) {
            PatchListKey newKey = new PatchListKey(null, key.getNewId(), key.getWhitespace());
            PatchListKey oldKey = new PatchListKey(null, key.getOldId(), key.getWhitespace());
            paths = FluentIterable.from(patchListCache.get(newKey, project).getPatches()).append(patchListCache.get(oldKey, project).getPatches()).transform(new Function<PatchListEntry, String>() {

                @Override
                public String apply(PatchListEntry entry) {
                    return entry.getNewName();
                }
            }).toSet();
        }
        int cnt = diffEntries.size();
        List<PatchListEntry> entries = new ArrayList<>();
        entries.add(newCommitMessage(cmp, reader, againstParent ? null : aCommit, b));
        for (int i = 0; i < cnt; i++) {
            DiffEntry e = diffEntries.get(i);
            if (paths == null || paths.contains(e.getNewPath()) || paths.contains(e.getOldPath())) {
                FileHeader fh = toFileHeader(key, df, e);
                long oldSize = getFileSize(repo, reader, e.getOldMode(), e.getOldPath(), aTree);
                long newSize = getFileSize(repo, reader, e.getNewMode(), e.getNewPath(), bTree);
                entries.add(newEntry(aTree, fh, newSize - oldSize));
            }
        }
        return new PatchList(a, b, againstParent, entries.toArray(new PatchListEntry[entries.size()]));
    }
}
#method_after
private PatchList readPatchList(final PatchListKey key, final Repository repo) throws IOException, PatchListNotAvailableException {
    final RawTextComparator cmp = comparatorFor(key.getWhitespace());
    try (ObjectInserter ins = repo.newObjectInserter();
        ObjectReader reader = ins.newReader();
        RevWalk rw = new RevWalk(reader);
        DiffFormatter df = new DiffFormatter(DisabledOutputStream.INSTANCE)) {
        final RevCommit b = rw.parseCommit(key.getNewId());
        final RevObject a = aFor(key, repo, rw, ins, b);
        if (a == null) {
            // TODO(sop) Remove this case.
            // This is a merge commit, compared to its ancestor.
            // 
            final PatchListEntry[] entries = new PatchListEntry[1];
            entries[0] = newCommitMessage(cmp, reader, null, b);
            return new PatchList(a, b, true, entries);
        }
        final boolean againstParent = b.getParentCount() > 0 && b.getParent(0) == a;
        RevCommit aCommit = a instanceof RevCommit ? (RevCommit) a : null;
        RevTree aTree = rw.parseTree(a);
        RevTree bTree = b.getTree();
        df.setRepository(repo);
        df.setDiffComparator(cmp);
        df.setDetectRenames(true);
        List<DiffEntry> diffEntries = df.scan(aTree, bTree);
        Set<String> paths = null;
        if (key.getOldId() != null && b.getParentCount() == 1) {
            PatchListKey newKey = PatchListKey.againstDefaultBase(key.getNewId(), key.getWhitespace());
            PatchListKey oldKey = PatchListKey.againstDefaultBase(key.getOldId(), key.getWhitespace());
            paths = FluentIterable.from(patchListCache.get(newKey, project).getPatches()).append(patchListCache.get(oldKey, project).getPatches()).transform(new Function<PatchListEntry, String>() {

                @Override
                public String apply(PatchListEntry entry) {
                    return entry.getNewName();
                }
            }).toSet();
        }
        int cnt = diffEntries.size();
        List<PatchListEntry> entries = new ArrayList<>();
        entries.add(newCommitMessage(cmp, reader, againstParent ? null : aCommit, b));
        for (int i = 0; i < cnt; i++) {
            DiffEntry e = diffEntries.get(i);
            if (paths == null || paths.contains(e.getNewPath()) || paths.contains(e.getOldPath())) {
                FileHeader fh = toFileHeader(key, df, e);
                long oldSize = getFileSize(repo, reader, e.getOldMode(), e.getOldPath(), aTree);
                long newSize = getFileSize(repo, reader, e.getNewMode(), e.getNewPath(), bTree);
                entries.add(newEntry(aTree, fh, newSize, newSize - oldSize));
            }
        }
        return new PatchList(a, b, againstParent, entries.toArray(new PatchListEntry[entries.size()]));
    }
}
#end_block

#method_before
private FileHeader toFileHeader(PatchListKey key, final DiffFormatter diffFormatter, final DiffEntry diffEntry) throws IOException {
    Future<FileHeader> result = diffExecutor.submit(new Callable<FileHeader>() {

        @Override
        public FileHeader call() throws IOException {
            synchronized (lock) {
                return diffFormatter.toFileHeader(diffEntry);
            }
        }
    });
    try {
        return result.get(timeoutMillis, TimeUnit.MILLISECONDS);
    } catch (InterruptedException | TimeoutException e) {
        log.warn(timeoutMillis + " ms timeout reached for Diff loader" + " in project " + project + " on commit " + key.getNewId().name() + " on path " + diffEntry.getNewPath() + " comparing " + diffEntry.getOldId().name() + ".." + diffEntry.getNewId().name());
        result.cancel(true);
        synchronized (lock) {
            return toFileHeaderWithoutMyersDiff(diffFormatter, diffEntry);
        }
    } catch (ExecutionException e) {
        // If there was an error computing the result, carry it
        // up to the caller so the cache knows this key is invalid.
        Throwables.propagateIfInstanceOf(e.getCause(), IOException.class);
        throw new IOException(e.getMessage(), e.getCause());
    }
}
#method_after
private FileHeader toFileHeader(PatchListKey key, final DiffFormatter diffFormatter, final DiffEntry diffEntry) throws IOException {
    Future<FileHeader> result = diffExecutor.submit(new Callable<FileHeader>() {

        @Override
        public FileHeader call() throws IOException {
            synchronized (diffEntry) {
                return diffFormatter.toFileHeader(diffEntry);
            }
        }
    });
    try {
        return result.get(timeoutMillis, TimeUnit.MILLISECONDS);
    } catch (InterruptedException | TimeoutException e) {
        log.warn(timeoutMillis + " ms timeout reached for Diff loader" + " in project " + project + " on commit " + key.getNewId().name() + " on path " + diffEntry.getNewPath() + " comparing " + diffEntry.getOldId().name() + ".." + diffEntry.getNewId().name());
        result.cancel(true);
        synchronized (diffEntry) {
            return toFileHeaderWithoutMyersDiff(diffFormatter, diffEntry);
        }
    } catch (ExecutionException e) {
        // If there was an error computing the result, carry it
        // up to the caller so the cache knows this key is invalid.
        Throwables.propagateIfInstanceOf(e.getCause(), IOException.class);
        throw new IOException(e.getMessage(), e.getCause());
    }
}
#end_block

#method_before
private PatchListEntry newCommitMessage(final RawTextComparator cmp, final ObjectReader reader, final RevCommit aCommit, final RevCommit bCommit) throws IOException {
    StringBuilder hdr = new StringBuilder();
    hdr.append("diff --git");
    if (aCommit != null) {
        hdr.append(" a/").append(Patch.COMMIT_MSG);
    } else {
        hdr.append(" ").append(FileHeader.DEV_NULL);
    }
    hdr.append(" b/").append(Patch.COMMIT_MSG);
    hdr.append("\n");
    if (aCommit != null) {
        hdr.append("--- a/").append(Patch.COMMIT_MSG).append("\n");
    } else {
        hdr.append("--- ").append(FileHeader.DEV_NULL).append("\n");
    }
    hdr.append("+++ b/").append(Patch.COMMIT_MSG).append("\n");
    Text aText = aCommit != null ? Text.forCommit(reader, aCommit) : Text.EMPTY;
    Text bText = Text.forCommit(reader, bCommit);
    byte[] rawHdr = hdr.toString().getBytes(UTF_8);
    byte[] aContent = aText.getContent();
    byte[] bContent = bText.getContent();
    long sizeDelta = bContent.length - aContent.length;
    RawText aRawText = new RawText(aContent);
    RawText bRawText = new RawText(bContent);
    EditList edits = new HistogramDiff().diff(cmp, aRawText, bRawText);
    FileHeader fh = new FileHeader(rawHdr, edits, PatchType.UNIFIED);
    return new PatchListEntry(fh, edits, sizeDelta);
}
#method_after
private PatchListEntry newCommitMessage(final RawTextComparator cmp, final ObjectReader reader, final RevCommit aCommit, final RevCommit bCommit) throws IOException {
    StringBuilder hdr = new StringBuilder();
    hdr.append("diff --git");
    if (aCommit != null) {
        hdr.append(" a/").append(Patch.COMMIT_MSG);
    } else {
        hdr.append(" ").append(FileHeader.DEV_NULL);
    }
    hdr.append(" b/").append(Patch.COMMIT_MSG);
    hdr.append("\n");
    if (aCommit != null) {
        hdr.append("--- a/").append(Patch.COMMIT_MSG).append("\n");
    } else {
        hdr.append("--- ").append(FileHeader.DEV_NULL).append("\n");
    }
    hdr.append("+++ b/").append(Patch.COMMIT_MSG).append("\n");
    Text aText = aCommit != null ? Text.forCommit(reader, aCommit) : Text.EMPTY;
    Text bText = Text.forCommit(reader, bCommit);
    byte[] rawHdr = hdr.toString().getBytes(UTF_8);
    byte[] aContent = aText.getContent();
    byte[] bContent = bText.getContent();
    long size = bContent.length;
    long sizeDelta = bContent.length - aContent.length;
    RawText aRawText = new RawText(aContent);
    RawText bRawText = new RawText(bContent);
    EditList edits = new HistogramDiff().diff(cmp, aRawText, bRawText);
    FileHeader fh = new FileHeader(rawHdr, edits, PatchType.UNIFIED);
    return new PatchListEntry(fh, edits, size, sizeDelta);
}
#end_block

#method_before
private PatchListEntry newEntry(RevTree aTree, FileHeader fileHeader, long sizeDelta) {
    final FileMode oldMode = fileHeader.getOldMode();
    final FileMode newMode = fileHeader.getNewMode();
    if (oldMode == FileMode.GITLINK || newMode == FileMode.GITLINK) {
        return new PatchListEntry(fileHeader, Collections.<Edit>emptyList(), sizeDelta);
    }
    if (// want combined diff
    aTree == null || fileHeader.getPatchType() != PatchType.UNIFIED || fileHeader.getHunks().isEmpty()) {
        return new PatchListEntry(fileHeader, Collections.<Edit>emptyList(), sizeDelta);
    }
    List<Edit> edits = fileHeader.toEditList();
    if (edits.isEmpty()) {
        return new PatchListEntry(fileHeader, Collections.<Edit>emptyList(), sizeDelta);
    } else {
        return new PatchListEntry(fileHeader, edits, sizeDelta);
    }
}
#method_after
private PatchListEntry newEntry(RevTree aTree, FileHeader fileHeader, long size, long sizeDelta) {
    if (// want combined diff
    aTree == null || fileHeader.getPatchType() != PatchType.UNIFIED || fileHeader.getHunks().isEmpty()) {
        return new PatchListEntry(fileHeader, Collections.<Edit>emptyList(), size, sizeDelta);
    }
    List<Edit> edits = fileHeader.toEditList();
    if (edits.isEmpty()) {
        return new PatchListEntry(fileHeader, Collections.<Edit>emptyList(), size, sizeDelta);
    }
    return new PatchListEntry(fileHeader, edits, size, sizeDelta);
}
#end_block

#method_before
private RevObject aFor(final PatchListKey key, final Repository repo, final RevWalk rw, final RevCommit b) throws IOException {
    if (key.getOldId() != null) {
        return rw.parseAny(key.getOldId());
    }
    switch(b.getParentCount()) {
        case 0:
            return rw.parseAny(emptyTree(repo));
        case 1:
            {
                RevCommit r = b.getParent(0);
                rw.parseBody(r);
                return r;
            }
        case 2:
            return automerge(repo, rw, b, mergeStrategy);
        default:
            // TODO(sop) handle an octopus merge.
            return null;
    }
}
#method_after
private RevObject aFor(PatchListKey key, Repository repo, RevWalk rw, ObjectInserter ins, RevCommit b) throws IOException {
    if (key.getOldId() != null) {
        return rw.parseAny(key.getOldId());
    }
    switch(b.getParentCount()) {
        case 0:
            return rw.parseAny(emptyTree(repo));
        case 1:
            {
                RevCommit r = b.getParent(0);
                rw.parseBody(r);
                return r;
            }
        case 2:
            if (key.getParentNum() != null) {
                RevCommit r = b.getParent(key.getParentNum() - 1);
                rw.parseBody(r);
                return r;
            }
            return autoMerger.merge(repo, rw, ins, b, mergeStrategy);
        default:
            // TODO(sop) handle an octopus merge.
            return null;
    }
}
#end_block

#method_before
@Test
public void pushWatchConfigToUserBranch() throws Exception {
    // change something in the user preferences to ensure that the user branch
    // is created
    GeneralPreferencesInfo input = new GeneralPreferencesInfo();
    input.changesPerPage = GeneralPreferencesInfo.defaults().changesPerPage + 10;
    gApi.accounts().self().setPreferences(input);
    TestRepository<InMemoryRepository> allUsersRepo = cloneProject(allUsers);
    fetch(allUsersRepo, RefNames.refsUsers(admin.id) + ":userRef");
    allUsersRepo.reset("userRef");
    Config wc = new Config();
    wc.setString(WatchConfig.PROJECT, project.get(), WatchConfig.KEY_NOTIFY, NotifyValue.create(null, EnumSet.of(NotifyType.ALL_COMMENTS)).toString());
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), allUsersRepo, "Add project watch", WatchConfig.WATCH_CONFIG, wc.toText());
    push.to(RefNames.REFS_USERS_SELF).assertOkStatus();
    String invalidNotifyValue = "]invalid[";
    wc.setString(WatchConfig.PROJECT, project.get(), WatchConfig.KEY_NOTIFY, invalidNotifyValue);
    push = pushFactory.create(db, admin.getIdent(), allUsersRepo, "Add invalid project watch", WatchConfig.WATCH_CONFIG, wc.toText());
    PushOneCommit.Result r = push.to(RefNames.REFS_USERS_SELF);
    r.assertErrorStatus("invalid watch configuration");
    r.assertMessage(String.format("%s: Invalid project watch of account %d for project %s: %s", WatchConfig.WATCH_CONFIG, admin.getId().get(), project.get(), invalidNotifyValue));
}
#method_after
@Test
public void pushWatchConfigToUserBranch() throws Exception {
    // change something in the user preferences to ensure that the user branch
    // is created
    GeneralPreferencesInfo input = new GeneralPreferencesInfo();
    input.changesPerPage = GeneralPreferencesInfo.defaults().changesPerPage + 10;
    gApi.accounts().self().setPreferences(input);
    TestRepository<InMemoryRepository> allUsersRepo = cloneProject(allUsers);
    fetch(allUsersRepo, RefNames.refsUsers(admin.id) + ":userRef");
    allUsersRepo.reset("userRef");
    Config wc = new Config();
    wc.setString(WatchConfig.PROJECT, project.get(), WatchConfig.KEY_NOTIFY, WatchConfig.NotifyValue.create(null, EnumSet.of(NotifyType.ALL_COMMENTS)).toString());
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), allUsersRepo, "Add project watch", WatchConfig.WATCH_CONFIG, wc.toText());
    push.to(RefNames.REFS_USERS_SELF).assertOkStatus();
    String invalidNotifyValue = "]invalid[";
    wc.setString(WatchConfig.PROJECT, project.get(), WatchConfig.KEY_NOTIFY, invalidNotifyValue);
    push = pushFactory.create(db, admin.getIdent(), allUsersRepo, "Add invalid project watch", WatchConfig.WATCH_CONFIG, wc.toText());
    PushOneCommit.Result r = push.to(RefNames.REFS_USERS_SELF);
    r.assertErrorStatus("invalid watch configuration");
    r.assertMessage(String.format("%s: Invalid project watch of account %d for project %s: %s", WatchConfig.WATCH_CONFIG, admin.getId().get(), project.get(), invalidNotifyValue));
}
#end_block

#method_before
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    IdentifiedUser currentUser = refControl.getUser().asIdentifiedUser();
    if (REFS_CONFIG.equals(refControl.getRefName())) {
        List<CommitValidationMessage> messages = new LinkedList<>();
        try {
            ProjectConfig cfg = new ProjectConfig(receiveEvent.project.getNameKey());
            cfg.load(repo, receiveEvent.command.getNewId());
            if (!cfg.getValidationErrors().isEmpty()) {
                addError("Invalid project configuration:", messages);
                for (ValidationError err : cfg.getValidationErrors()) {
                    addError("  " + err.getMessage(), messages);
                }
                throw new ConfigInvalidException("invalid project configuration");
            }
        } catch (Exception e) {
            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + receiveEvent.command.getNewId().name() + " for " + receiveEvent.project.getName(), e);
            throw new CommitValidationException("invalid project configuration", messages);
        }
    }
    if (allUsers.equals(refControl.getProjectControl().getProject().getNameKey()) && RefNames.isRefsUsers(refControl.getRefName())) {
        List<CommitValidationMessage> messages = new LinkedList<>();
        Account.Id accountId = Account.Id.fromRef(refControl.getRefName());
        if (accountId != null) {
            try {
                @SuppressWarnings("resource")
                WatchConfig wc = new WatchConfig(accountId);
                wc.load(repo, receiveEvent.command.getNewId());
                if (!wc.getValidationErrors().isEmpty()) {
                    addError("Invalid project configuration:", messages);
                    for (ValidationError err : wc.getValidationErrors()) {
                        addError("  " + err.getMessage(), messages);
                    }
                    throw new ConfigInvalidException("invalid watch configuration");
                }
            } catch (IOException | ConfigInvalidException e) {
                log.error("User " + currentUser.getUserName() + " tried to push an invalid watch configuration " + receiveEvent.command.getNewId().name() + " for account " + accountId.get(), e);
                throw new CommitValidationException("invalid watch configuration", messages);
            }
        }
    }
    return Collections.emptyList();
}
#method_after
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    IdentifiedUser currentUser = refControl.getUser().asIdentifiedUser();
    if (REFS_CONFIG.equals(refControl.getRefName())) {
        List<CommitValidationMessage> messages = new LinkedList<>();
        try {
            ProjectConfig cfg = new ProjectConfig(receiveEvent.project.getNameKey());
            cfg.load(repo, receiveEvent.command.getNewId());
            if (!cfg.getValidationErrors().isEmpty()) {
                addError("Invalid project configuration:", messages);
                for (ValidationError err : cfg.getValidationErrors()) {
                    addError("  " + err.getMessage(), messages);
                }
                throw new ConfigInvalidException("invalid project configuration");
            }
        } catch (ConfigInvalidException | IOException e) {
            log.error("User " + currentUser.getUserName() + " tried to push an invalid project configuration " + receiveEvent.command.getNewId().name() + " for project " + receiveEvent.project.getName(), e);
            throw new CommitValidationException("invalid project configuration", messages);
        }
    }
    if (allUsers.equals(refControl.getProjectControl().getProject().getNameKey()) && RefNames.isRefsUsers(refControl.getRefName())) {
        List<CommitValidationMessage> messages = new LinkedList<>();
        Account.Id accountId = Account.Id.fromRef(refControl.getRefName());
        if (accountId != null) {
            try {
                @SuppressWarnings("resource")
                WatchConfig wc = new WatchConfig(accountId);
                wc.load(repo, receiveEvent.command.getNewId());
                if (!wc.getValidationErrors().isEmpty()) {
                    addError("Invalid project configuration:", messages);
                    for (ValidationError err : wc.getValidationErrors()) {
                        addError("  " + err.getMessage(), messages);
                    }
                    throw new ConfigInvalidException("invalid watch configuration");
                }
            } catch (IOException | ConfigInvalidException e) {
                log.error("User " + currentUser.getUserName() + " tried to push an invalid watch configuration " + receiveEvent.command.getNewId().name() + " for account " + accountId.get(), e);
                throw new CommitValidationException("invalid watch configuration", messages);
            }
        }
    }
    return Collections.emptyList();
}
#end_block

#method_before
void processCommands(Collection<ReceiveCommand> commands, MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    batch = repo.getRefDatabase().newBatchUpdate();
    batch.setPushCertificate(rp.getPushCertificate());
    batch.setRefLogIdent(rp.getRefLogIdent());
    batch.setRefLogMessage("push", true);
    parseCommands(commands);
    if (magicBranch != null && magicBranch.cmd.getResult() == NOT_ATTEMPTED) {
        selectNewAndReplacedChangesFromMagicBranch();
    }
    preparePatchSetsForReplace();
    if (!batch.getCommands().isEmpty()) {
        try {
            if (!batch.isAllowNonFastForwards() && magicBranch != null && magicBranch.edit) {
                batch.setAllowNonFastForwards(true);
            }
            batch.execute(rp.getRevWalk(), commandProgress);
        } catch (IOException err) {
            int cnt = 0;
            for (ReceiveCommand cmd : batch.getCommands()) {
                if (cmd.getResult() == NOT_ATTEMPTED) {
                    cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
                    cnt++;
                }
            }
            log.error(String.format("Failed to store %d refs in %s", cnt, project.getName()), err);
        }
    }
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(user)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    Set<Branch.NameKey> branches = new HashSet<>();
    for (ReceiveCommand c : batch.getCommands()) {
        if (c.getResult() == OK) {
            String refName = c.getRefName();
            if (c.getType() == ReceiveCommand.Type.UPDATE) {
                // aka fast-forward
                tagCache.updateFastForward(project.getNameKey(), refName, c.getOldId(), c.getNewId());
            }
            if (isHead(c) || isConfig(c)) {
                switch(c.getType()) {
                    case CREATE:
                    case UPDATE:
                    case UPDATE_NONFASTFORWARD:
                        autoCloseChanges(c);
                        branches.add(new Branch.NameKey(project.getNameKey(), refName));
                        break;
                    case DELETE:
                        break;
                }
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(refName) && !refName.startsWith(REFS_CHANGES)) {
                // We only fire gitRefUpdated for direct refs updates.
                // Events for change refs are fired when they are created.
                // 
                gitRefUpdated.fire(project.getNameKey(), c, user.getAccount());
                hooks.doRefUpdatedHook(new Branch.NameKey(project.getNameKey(), refName), c.getOldId(), c.getNewId(), user.getAccount());
            }
        }
    }
    // Update superproject gitlinks if required.
    try (MergeOpRepoManager orm = ormProvider.get()) {
        orm.setContext(db, TimeUtil.nowTs(), user, "receiveID");
        SubmoduleOp op = subOpFactory.create(branches, orm);
        op.updateSuperProjects();
    } catch (SubmoduleException e) {
        log.error("Can't update the superprojects", e);
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    reportMessages();
}
#method_after
void processCommands(Collection<ReceiveCommand> commands, MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    batch = repo.getRefDatabase().newBatchUpdate();
    batch.setPushCertificate(rp.getPushCertificate());
    batch.setRefLogIdent(rp.getRefLogIdent());
    batch.setRefLogMessage("push", true);
    parseCommands(commands);
    if (magicBranch != null && magicBranch.cmd.getResult() == NOT_ATTEMPTED) {
        selectNewAndReplacedChangesFromMagicBranch();
    }
    preparePatchSetsForReplace();
    if (!batch.getCommands().isEmpty()) {
        try {
            if (!batch.isAllowNonFastForwards() && magicBranch != null && magicBranch.edit) {
                batch.setAllowNonFastForwards(true);
            }
            batch.execute(rp.getRevWalk(), commandProgress);
        } catch (IOException err) {
            int cnt = 0;
            for (ReceiveCommand cmd : batch.getCommands()) {
                if (cmd.getResult() == NOT_ATTEMPTED) {
                    cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
                    cnt++;
                }
            }
            log.error(String.format("Failed to store %d refs in %s", cnt, project.getName()), err);
        }
    }
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(user)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    Set<Branch.NameKey> branches = new HashSet<>();
    for (ReceiveCommand c : batch.getCommands()) {
        if (c.getResult() == OK) {
            String refName = c.getRefName();
            if (c.getType() == ReceiveCommand.Type.UPDATE) {
                // aka fast-forward
                tagCache.updateFastForward(project.getNameKey(), refName, c.getOldId(), c.getNewId());
            }
            if (isHead(c) || isConfig(c)) {
                switch(c.getType()) {
                    case CREATE:
                    case UPDATE:
                    case UPDATE_NONFASTFORWARD:
                        autoCloseChanges(c);
                        branches.add(new Branch.NameKey(project.getNameKey(), refName));
                        break;
                    case DELETE:
                        break;
                }
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(refName) && !refName.startsWith(REFS_CHANGES)) {
                // We only fire gitRefUpdated for direct refs updates.
                // Events for change refs are fired when they are created.
                // 
                gitRefUpdated.fire(project.getNameKey(), c, user.getAccount());
            }
        }
    }
    // Update superproject gitlinks if required.
    try (MergeOpRepoManager orm = ormProvider.get()) {
        orm.setContext(db, TimeUtil.nowTs(), user, "receiveID");
        SubmoduleOp op = subOpFactory.create(branches, orm);
        op.updateSuperProjects();
    } catch (SubmoduleException e) {
        log.error("Can't update the superprojects", e);
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    reportMessages();
}
#end_block

#method_before
private void reportMessages() {
    Iterable<CreateRequest> created = Iterables.filter(newChanges, new Predicate<CreateRequest>() {

        @Override
        public boolean apply(CreateRequest input) {
            return input.getChange() != null;
        }
    });
    if (!Iterables.isEmpty(created)) {
        addMessage("");
        addMessage("New Changes:");
        for (CreateRequest c : created) {
            addMessage(formatChangeUrl(canonicalWebUrl, c.getChange(), c.getChange().getSubject(), false));
        }
        addMessage("");
    }
    List<ReplaceRequest> updated = FluentIterable.from(replaceByChange.values()).filter(new Predicate<ReplaceRequest>() {

        @Override
        public boolean apply(ReplaceRequest input) {
            return !input.skip && input.inputCommand.getResult() == OK;
        }
    }).toSortedList(Ordering.natural().onResultOf(new Function<ReplaceRequest, Integer>() {

        @Override
        public Integer apply(ReplaceRequest in) {
            return in.change.getId().get();
        }
    }));
    if (!updated.isEmpty()) {
        addMessage("");
        addMessage("Updated Changes:");
        boolean edit = magicBranch != null && magicBranch.edit;
        for (ReplaceRequest u : updated) {
            addMessage(formatChangeUrl(canonicalWebUrl, u.change, u.info.getSubject(), edit));
        }
        addMessage("");
    }
}
#method_after
private void reportMessages() {
    Iterable<CreateRequest> created = Iterables.filter(newChanges, new Predicate<CreateRequest>() {

        @Override
        public boolean apply(CreateRequest input) {
            return input.change != null;
        }
    });
    if (!Iterables.isEmpty(created)) {
        addMessage("");
        addMessage("New Changes:");
        for (CreateRequest c : created) {
            addMessage(formatChangeUrl(canonicalWebUrl, c.change, c.change.getSubject(), false));
        }
        addMessage("");
    }
    List<ReplaceRequest> updated = FluentIterable.from(replaceByChange.values()).filter(new Predicate<ReplaceRequest>() {

        @Override
        public boolean apply(ReplaceRequest input) {
            return !input.skip && input.inputCommand.getResult() == OK;
        }
    }).toSortedList(Ordering.natural().onResultOf(new Function<ReplaceRequest, Integer>() {

        @Override
        public Integer apply(ReplaceRequest in) {
            return in.notes.getChangeId().get();
        }
    }));
    if (!updated.isEmpty()) {
        addMessage("");
        addMessage("Updated Changes:");
        boolean edit = magicBranch != null && magicBranch.edit;
        for (ReplaceRequest u : updated) {
            String subject;
            if (edit) {
                try {
                    subject = rp.getRevWalk().parseCommit(u.newCommitId).getShortMessage();
                } catch (IOException e) {
                    // Log and fall back to original change subject
                    log.warn("failed to get subject for edit patch set", e);
                    subject = u.notes.getChange().getSubject();
                }
            } else {
                subject = u.info.getMessage();
            }
            addMessage(formatChangeUrl(canonicalWebUrl, u.notes.getChange(), subject, edit));
        }
        addMessage("");
    }
}
#end_block

#method_before
private void insertChangesAndPatchSets() {
    int replaceCount = 0;
    int okToInsert = 0;
    for (Map.Entry<Change.Id, ReplaceRequest> e : replaceByChange.entrySet()) {
        ReplaceRequest replace = e.getValue();
        if (magicBranch != null && replace.inputCommand == magicBranch.cmd) {
            replaceCount++;
            if (replace.cmd != null && replace.cmd.getResult() == OK) {
                okToInsert++;
            }
        } else if (replace.cmd != null && replace.cmd.getResult() == OK) {
            checkState(NEW_PATCHSET.matcher(replace.inputCommand.getRefName()).matches(), "expected a new patch set command as input when creating %s;" + " got %s", replace.cmd.getRefName(), replace.inputCommand.getRefName());
            try {
                replace.insertPatchSetWithoutBatchUpdate();
                replace.inputCommand.setResult(OK);
            } catch (IOException | UpdateException | RestApiException err) {
                reject(replace.inputCommand, "internal server error");
                log.error(String.format("Cannot add patch set to change %d in project %s", e.getKey().get(), project.getName()), err);
            }
        } else if (replace.inputCommand.getResult() == NOT_ATTEMPTED) {
            reject(replace.inputCommand, "internal server error");
            log.error(String.format("Replacement for project %s was not attempted", project.getName()));
        }
    }
    if (magicBranch == null || magicBranch.cmd.getResult() != NOT_ATTEMPTED) {
        // No need to continue.
        return;
    }
    List<String> lastCreateChangeErrors = new ArrayList<>();
    for (CreateRequest create : newChanges) {
        if (create.cmd.getResult() == OK) {
            okToInsert++;
        } else {
            String createChangeResult = String.format("%s %s", create.cmd.getResult(), Strings.nullToEmpty(create.cmd.getMessage())).trim();
            lastCreateChangeErrors.add(createChangeResult);
            log.error(String.format("Command %s on %s:%s not completed: %s", create.cmd.getType(), project.getName(), create.cmd.getRefName(), createChangeResult));
        }
    }
    if (okToInsert != replaceCount + newChanges.size()) {
        // One or more new references failed to create. Assume the
        // system isn't working correctly anymore and abort.
        reject(magicBranch.cmd, "Unable to create changes: " + Joiner.on(' ').join(lastCreateChangeErrors));
        log.error(String.format("Only %d of %d new change refs created in %s; aborting", okToInsert, replaceCount + newChanges.size(), project.getName()));
        return;
    }
    try (BatchUpdate bu = batchUpdateFactory.create(db, magicBranch.dest.getParentKey(), user, TimeUtil.nowTs());
        ObjectInserter ins = repo.newObjectInserter()) {
        bu.setRepository(repo, rp.getRevWalk(), ins).updateChangesInParallel();
        for (ReplaceRequest replace : replaceByChange.values()) {
            if (replace.inputCommand == magicBranch.cmd) {
                replace.addOps(bu);
            }
        }
        for (CreateRequest create : newChanges) {
            create.addOps(bu);
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.addOps(bu);
        }
        try {
            bu.execute();
        } catch (UpdateException e) {
            throw INSERT_EXCEPTION.apply(e);
        }
        newProgress.update(newChanges.size());
        replaceProgress.update(replaceByChange.size());
        magicBranch.cmd.setResult(OK);
        for (ReplaceRequest replace : replaceByChange.values()) {
            String rejectMessage = replace.getRejectMessage();
            if (rejectMessage != null) {
                reject(replace.inputCommand, rejectMessage);
            }
        }
    } catch (ResourceConflictException e) {
        addMessage(e.getMessage());
        reject(magicBranch.cmd, "conflict");
    } catch (RestApiException | IOException err) {
        log.error("Can't insert change/patch set for " + project.getName(), err);
        reject(magicBranch.cmd, "internal server error: " + err.getMessage());
    }
    if (magicBranch != null && magicBranch.submit) {
        try {
            submit(newChanges, replaceByChange.values());
        } catch (ResourceConflictException e) {
            addMessage(e.getMessage());
            reject(magicBranch.cmd, "conflict");
        } catch (RestApiException | OrmException e) {
            log.error("Error submit changes to " + project.getName(), e);
            reject(magicBranch.cmd, "error during submit");
        }
    }
}
#method_after
private void insertChangesAndPatchSets() {
    int replaceCount = 0;
    int okToInsert = 0;
    for (Map.Entry<Change.Id, ReplaceRequest> e : replaceByChange.entrySet()) {
        ReplaceRequest replace = e.getValue();
        if (magicBranch != null && replace.inputCommand == magicBranch.cmd) {
            replaceCount++;
            if (replace.cmd != null && replace.cmd.getResult() == OK) {
                okToInsert++;
            }
        } else if (replace.cmd != null && replace.cmd.getResult() == OK) {
            checkState(NEW_PATCHSET.matcher(replace.inputCommand.getRefName()).matches(), "expected a new patch set command as input when creating %s;" + " got %s", replace.cmd.getRefName(), replace.inputCommand.getRefName());
            try {
                replace.insertPatchSetWithoutBatchUpdate();
                replace.inputCommand.setResult(OK);
            } catch (IOException | UpdateException | RestApiException err) {
                reject(replace.inputCommand, "internal server error");
                log.error(String.format("Cannot add patch set to change %d in project %s", e.getKey().get(), project.getName()), err);
            }
        } else if (replace.inputCommand.getResult() == NOT_ATTEMPTED) {
            reject(replace.inputCommand, "internal server error");
            log.error(String.format("Replacement for project %s was not attempted", project.getName()));
        }
    }
    if (magicBranch == null || magicBranch.cmd.getResult() != NOT_ATTEMPTED) {
        // No need to continue.
        return;
    }
    List<String> lastCreateChangeErrors = new ArrayList<>();
    for (CreateRequest create : newChanges) {
        if (create.cmd.getResult() == OK) {
            okToInsert++;
        } else {
            String createChangeResult = String.format("%s %s", create.cmd.getResult(), Strings.nullToEmpty(create.cmd.getMessage())).trim();
            lastCreateChangeErrors.add(createChangeResult);
            log.error(String.format("Command %s on %s:%s not completed: %s", create.cmd.getType(), project.getName(), create.cmd.getRefName(), createChangeResult));
        }
    }
    if (okToInsert != replaceCount + newChanges.size()) {
        // One or more new references failed to create. Assume the
        // system isn't working correctly anymore and abort.
        reject(magicBranch.cmd, "Unable to create changes: " + Joiner.on(' ').join(lastCreateChangeErrors));
        log.error(String.format("Only %d of %d new change refs created in %s; aborting", okToInsert, replaceCount + newChanges.size(), project.getName()));
        return;
    }
    try (BatchUpdate bu = batchUpdateFactory.create(db, magicBranch.dest.getParentKey(), user, TimeUtil.nowTs());
        ObjectInserter ins = repo.newObjectInserter()) {
        bu.setRepository(repo, rp.getRevWalk(), ins).updateChangesInParallel();
        for (ReplaceRequest replace : replaceByChange.values()) {
            if (replace.inputCommand == magicBranch.cmd) {
                replace.addOps(bu, replaceProgress);
            }
        }
        for (CreateRequest create : newChanges) {
            create.addOps(bu);
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.addOps(bu);
        }
        try {
            bu.execute();
        } catch (UpdateException e) {
            throw INSERT_EXCEPTION.apply(e);
        }
        magicBranch.cmd.setResult(OK);
        for (ReplaceRequest replace : replaceByChange.values()) {
            String rejectMessage = replace.getRejectMessage();
            if (rejectMessage != null) {
                reject(replace.inputCommand, rejectMessage);
            }
        }
    } catch (ResourceConflictException e) {
        addMessage(e.getMessage());
        reject(magicBranch.cmd, "conflict");
    } catch (RestApiException | IOException err) {
        log.error("Can't insert change/patch set for " + project.getName(), err);
        reject(magicBranch.cmd, "internal server error: " + err.getMessage());
    }
    if (magicBranch != null && magicBranch.submit) {
        try {
            submit(newChanges, replaceByChange.values());
        } catch (ResourceConflictException e) {
            addMessage(e.getMessage());
            reject(magicBranch.cmd, "conflict");
        } catch (RestApiException | OrmException e) {
            log.error("Error submit changes to " + project.getName(), e);
            reject(magicBranch.cmd, "error during submit");
        }
    }
}
#end_block

#method_before
private void parseCommands(Collection<ReceiveCommand> commands) {
    for (ReceiveCommand cmd : commands) {
        if (cmd.getResult() != NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseMagicBranch(cmd);
            continue;
        }
        if (projectControl.getProjectState().isAllUsers() && RefNames.REFS_USERS_SELF.equals(cmd.getRefName())) {
            final ReceiveCommand orgCmd = cmd;
            cmd = new ReceiveCommand(cmd.getOldId(), cmd.getNewId(), RefNames.refsUsers(user.getAccountId()), cmd.getType()) {

                @Override
                public void setResult(Result s, String m) {
                    super.setResult(s, m);
                    orgCmd.setResult(s, m);
                }
            };
        }
        Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(rp.getRevWalk(), cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            addError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                addError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                        Project.NameKey newParent = cfg.getProject().getParent(allProjectsName);
                        Project.NameKey oldParent = project.getParent(allProjectsName);
                        if (oldParent == null) {
                            // update of the 'All-Projects' project
                            if (newParent != null) {
                                reject(cmd, "invalid project configuration: root project cannot have parent");
                                continue;
                            }
                        } else {
                            if (!oldParent.equals(newParent) && !user.getCapabilities().canAdministrateServer()) {
                                reject(cmd, "invalid project configuration: only Gerrit admin can set parent");
                                continue;
                            }
                            if (projectCache.get(newParent) == null) {
                                reject(cmd, "invalid project configuration: parent does not exist");
                                continue;
                            }
                        }
                        for (Entry<ProjectConfigEntry> e : pluginConfigEntries) {
                            PluginConfig pluginCfg = cfg.getPluginConfig(e.getPluginName());
                            ProjectConfigEntry configEntry = e.getProvider().get();
                            String value = pluginCfg.getString(e.getExportName());
                            String oldValue = projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getString(e.getExportName());
                            if (configEntry.getType() == ProjectConfigEntry.Type.ARRAY) {
                                List<String> l = Arrays.asList(projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getStringList(e.getExportName()));
                                oldValue = Joiner.on("\n").join(l);
                            }
                            if ((value == null ? oldValue != null : !value.equals(oldValue)) && !configEntry.isEditable(projectControl.getProjectState())) {
                                reject(cmd, String.format("invalid project configuration: Not allowed to set parameter" + " '%s' of plugin '%s' on project '%s'.", e.getExportName(), e.getPluginName(), project.getName()));
                                continue;
                            }
                            if (ProjectConfigEntry.Type.LIST.equals(configEntry.getType()) && value != null && !configEntry.getPermittedValues().contains(value)) {
                                reject(cmd, String.format("invalid project configuration: The value '%s' is " + "not permitted for parameter '%s' of plugin '%s'.", value, e.getExportName(), e.getPluginName()));
                            }
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#method_after
private void parseCommands(Collection<ReceiveCommand> commands) {
    for (ReceiveCommand cmd : commands) {
        if (cmd.getResult() != NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseMagicBranch(cmd);
            continue;
        }
        if (projectControl.getProjectState().isAllUsers() && RefNames.REFS_USERS_SELF.equals(cmd.getRefName())) {
            final ReceiveCommand orgCmd = cmd;
            cmd = new ReceiveCommand(cmd.getOldId(), cmd.getNewId(), RefNames.refsUsers(user.getAccountId()), cmd.getType()) {

                @Override
                public void setResult(Result s, String m) {
                    super.setResult(s, m);
                    orgCmd.setResult(s, m);
                }
            };
        }
        Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(rp.getRevWalk(), cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            addError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                addError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                        Project.NameKey newParent = cfg.getProject().getParent(allProjectsName);
                        Project.NameKey oldParent = project.getParent(allProjectsName);
                        if (oldParent == null) {
                            // update of the 'All-Projects' project
                            if (newParent != null) {
                                reject(cmd, "invalid project configuration: root project cannot have parent");
                                continue;
                            }
                        } else {
                            if (!oldParent.equals(newParent) && !user.getCapabilities().canAdministrateServer()) {
                                reject(cmd, "invalid project configuration: only Gerrit admin can set parent");
                                continue;
                            }
                            if (projectCache.get(newParent) == null) {
                                reject(cmd, "invalid project configuration: parent does not exist");
                                continue;
                            }
                        }
                        for (Entry<ProjectConfigEntry> e : pluginConfigEntries) {
                            PluginConfig pluginCfg = cfg.getPluginConfig(e.getPluginName());
                            ProjectConfigEntry configEntry = e.getProvider().get();
                            String value = pluginCfg.getString(e.getExportName());
                            String oldValue = projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getString(e.getExportName());
                            if (configEntry.getType() == ProjectConfigEntryType.ARRAY) {
                                List<String> l = Arrays.asList(projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getStringList(e.getExportName()));
                                oldValue = Joiner.on("\n").join(l);
                            }
                            if ((value == null ? oldValue != null : !value.equals(oldValue)) && !configEntry.isEditable(projectControl.getProjectState())) {
                                reject(cmd, String.format("invalid project configuration: Not allowed to set parameter" + " '%s' of plugin '%s' on project '%s'.", e.getExportName(), e.getPluginName(), project.getName()));
                                continue;
                            }
                            if (ProjectConfigEntryType.LIST.equals(configEntry.getType()) && value != null && !configEntry.getPermittedValues().contains(value)) {
                                reject(cmd, String.format("invalid project configuration: The value '%s' is " + "not permitted for parameter '%s' of plugin '%s'.", value, e.getExportName(), e.getPluginName()));
                            }
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#end_block

#method_before
private void selectNewAndReplacedChangesFromMagicBranch() {
    newChanges = new ArrayList<>();
    SetMultimap<ObjectId, Ref> existing = changeRefsById();
    GroupCollector groupCollector = GroupCollector.create(refsById, db, psUtil, notesFactory, project.getNameKey());
    rp.getRevWalk().reset();
    rp.getRevWalk().sort(RevSort.TOPO);
    rp.getRevWalk().sort(RevSort.REVERSE, true);
    try {
        rp.getRevWalk().markStart(rp.getRevWalk().parseCommit(magicBranch.cmd.getNewId()));
        if (magicBranch.baseCommit != null) {
            for (RevCommit c : magicBranch.baseCommit) {
                rp.getRevWalk().markUninteresting(c);
            }
            Ref targetRef = allRefs.get(magicBranch.ctl.getRefName());
            if (targetRef != null) {
                rp.getRevWalk().markUninteresting(rp.getRevWalk().parseCommit(targetRef.getObjectId()));
            }
        } else {
            markHeadsAsUninteresting(rp.getRevWalk(), magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
        }
        List<ChangeLookup> pending = new ArrayList<>();
        Set<Change.Key> newChangeIds = new HashSet<>();
        int maxBatchChanges = receiveConfig.getEffectiveMaxBatchChangesLimit(user);
        for (; ; ) {
            RevCommit c = rp.getRevWalk().next();
            if (c == null) {
                break;
            }
            groupCollector.visit(c);
            Collection<Ref> existingRefs = existing.get(c);
            if (!existingRefs.isEmpty()) {
                // A's group.
                for (Ref ref : existingRefs) {
                    updateGroups.add(new UpdateGroupsRequest(ref, c));
                }
                continue;
            }
            if (!validCommit(rp.getRevWalk(), magicBranch.ctl, magicBranch.cmd, c)) {
                // Not a change the user can propose? Abort as early as possible.
                newChanges = Collections.emptyList();
                return;
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
            }
            List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(c, magicBranch.dest.get()));
                continue;
            }
            String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                newChanges = Collections.emptyList();
                return;
            }
            pending.add(new ChangeLookup(c, new Change.Key(idStr)));
            if (maxBatchChanges != 0 && pending.size() + newChanges.size() > maxBatchChanges) {
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                newChanges = Collections.emptyList();
                return;
            }
        }
        for (ChangeLookup p : pending) {
            if (newChangeIds.contains(p.changeKey)) {
                reject(magicBranch.cmd, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
                newChanges = Collections.emptyList();
                return;
            }
            List<ChangeData> changes = p.destChanges;
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 1) {
                // 
                if (requestReplace(magicBranch.cmd, false, changes.get(0).change(), p.commit)) {
                    continue;
                }
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    newChanges = Collections.emptyList();
                    return;
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(p.commit, magicBranch.dest.get()));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        newChanges = Collections.emptyList();
        return;
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        newChanges = Collections.emptyList();
        return;
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return;
    }
    if (!newChanges.isEmpty() && magicBranch.edit) {
        reject(magicBranch.cmd, "edit is not supported for new changes");
        return;
    }
    try {
        SortedSetMultimap<ObjectId, String> groups = groupCollector.getGroups();
        for (CreateRequest create : newChanges) {
            batch.addCommand(create.cmd);
            create.groups = ImmutableList.copyOf(groups.get(create.commitId));
        }
        for (ReplaceRequest replace : replaceByChange.values()) {
            replace.groups = ImmutableList.copyOf(groups.get(replace.newCommitId));
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.groups = ImmutableList.copyOf((groups.get(update.commit)));
        }
    } catch (OrmException | NoSuchChangeException e) {
        log.error("Error collecting groups for changes", e);
        reject(magicBranch.cmd, "internal server error");
        return;
    }
}
#method_after
private void selectNewAndReplacedChangesFromMagicBranch() {
    newChanges = new ArrayList<>();
    SetMultimap<ObjectId, Ref> existing = changeRefsById();
    GroupCollector groupCollector = GroupCollector.create(changeRefsById(), db, psUtil, notesFactory, project.getNameKey());
    rp.getRevWalk().reset();
    rp.getRevWalk().sort(RevSort.TOPO);
    rp.getRevWalk().sort(RevSort.REVERSE, true);
    try {
        rp.getRevWalk().markStart(rp.getRevWalk().parseCommit(magicBranch.cmd.getNewId()));
        if (magicBranch.baseCommit != null) {
            for (RevCommit c : magicBranch.baseCommit) {
                rp.getRevWalk().markUninteresting(c);
            }
            Ref targetRef = allRefs.get(magicBranch.ctl.getRefName());
            if (targetRef != null) {
                rp.getRevWalk().markUninteresting(rp.getRevWalk().parseCommit(targetRef.getObjectId()));
            }
        } else {
            markHeadsAsUninteresting(rp.getRevWalk(), magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
        }
        List<ChangeLookup> pending = new ArrayList<>();
        Set<Change.Key> newChangeIds = new HashSet<>();
        int maxBatchChanges = receiveConfig.getEffectiveMaxBatchChangesLimit(user);
        for (; ; ) {
            RevCommit c = rp.getRevWalk().next();
            if (c == null) {
                break;
            }
            groupCollector.visit(c);
            Collection<Ref> existingRefs = existing.get(c);
            if (!existingRefs.isEmpty()) {
                // different target branch.
                for (Ref ref : existingRefs) {
                    updateGroups.add(new UpdateGroupsRequest(ref, c));
                }
                if (!(newChangeForAllNotInTarget || magicBranch.base != null)) {
                    continue;
                }
            }
            if (!validCommit(rp.getRevWalk(), magicBranch.ctl, magicBranch.cmd, c)) {
                // Not a change the user can propose? Abort as early as possible.
                newChanges = Collections.emptyList();
                return;
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
            }
            List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(c, magicBranch.dest.get()));
                continue;
            }
            String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                newChanges = Collections.emptyList();
                return;
            }
            pending.add(new ChangeLookup(c, new Change.Key(idStr)));
            if (maxBatchChanges != 0 && pending.size() + newChanges.size() > maxBatchChanges) {
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                newChanges = Collections.emptyList();
                return;
            }
        }
        for (Iterator<ChangeLookup> itr = pending.iterator(); itr.hasNext(); ) {
            ChangeLookup p = itr.next();
            if (newChangeIds.contains(p.changeKey)) {
                reject(magicBranch.cmd, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
                newChanges = Collections.emptyList();
                return;
            }
            List<ChangeData> changes = p.destChanges;
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 1) {
                // Schedule as a replacement to this one matching change.
                // 
                RevId currentPs = changes.get(0).currentPatchSet().getRevision();
                // If Commit is already current PatchSet of target Change.
                if (p.commit.name().equals(currentPs.get())) {
                    if (pending.size() == 1) {
                        // There are no commits left to check, all commits in pending were already
                        // current PatchSet of the corresponding target changes.
                        reject(magicBranch.cmd, "commit(s) already exists (as current patchset)");
                    } else {
                        // Commit is already current PatchSet.
                        // Remove from pending and try next commit.
                        itr.remove();
                        continue;
                    }
                }
                if (requestReplace(magicBranch.cmd, false, changes.get(0).change(), p.commit)) {
                    continue;
                }
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    newChanges = Collections.emptyList();
                    return;
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(p.commit, magicBranch.dest.get()));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        newChanges = Collections.emptyList();
        return;
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        newChanges = Collections.emptyList();
        return;
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return;
    }
    if (!newChanges.isEmpty() && magicBranch.edit) {
        reject(magicBranch.cmd, "edit is not supported for new changes");
        return;
    }
    try {
        SortedSetMultimap<ObjectId, String> groups = groupCollector.getGroups();
        for (CreateRequest create : newChanges) {
            batch.addCommand(create.cmd);
            create.groups = ImmutableList.copyOf(groups.get(create.commitId));
        }
        for (ReplaceRequest replace : replaceByChange.values()) {
            replace.groups = ImmutableList.copyOf(groups.get(replace.newCommitId));
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.groups = ImmutableList.copyOf((groups.get(update.commit)));
        }
    } catch (OrmException | NoSuchChangeException e) {
        log.error("Error collecting groups for changes", e);
        reject(magicBranch.cmd, "internal server error");
        return;
    }
}
#end_block

#method_before
private void addOps(BatchUpdate bu) throws RestApiException {
    try {
        RevWalk rw = rp.getRevWalk();
        RevCommit commit = rw.parseCommit(commitId);
        rw.parseBody(commit);
        final PatchSet.Id psId = ins.setGroups(groups).getPatchSetId();
        Account.Id me = user.getAccountId();
        List<FooterLine> footerLines = commit.getFooterLines();
        MailRecipients recipients = new MailRecipients();
        Map<String, Short> approvals = new HashMap<>();
        checkNotNull(magicBranch);
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.labels;
        recipients.add(getRecipientsFromFooters(accountResolver, magicBranch.draft, footerLines));
        recipients.remove(me);
        StringBuilder msg = new StringBuilder(ApprovalsUtil.renderMessageWithApprovals(psId.get(), approvals, Collections.<String, PatchSetApproval>emptyMap()));
        if (!Strings.isNullOrEmpty(magicBranch.message)) {
            msg.append("\n").append(magicBranch.message);
        }
        bu.insertChange(ins.setReviewers(recipients.getReviewers()).setExtraCC(recipients.getCcOnly()).setApprovals(approvals).setMessage(msg.toString()).setNotify(magicBranch.notify).setRequestScopePropagator(requestScopePropagator).setSendMail(true).setUpdateRef(true));
        if (!magicBranch.hashtags.isEmpty()) {
            bu.addOp(changeId, hashtagsFactory.create(new HashtagsInput(magicBranch.hashtags)).setRunHooks(false));
        }
        if (!Strings.isNullOrEmpty(magicBranch.topic)) {
            bu.addOp(changeId, new BatchUpdate.Op() {

                @Override
                public boolean updateChange(ChangeContext ctx) {
                    ctx.getUpdate(psId).setTopic(magicBranch.topic);
                    return true;
                }
            });
        }
    } catch (Exception e) {
        throw INSERT_EXCEPTION.apply(e);
    }
}
#method_after
private void addOps(BatchUpdate bu) throws RestApiException {
    try {
        RevWalk rw = rp.getRevWalk();
        RevCommit commit = rw.parseCommit(commitId);
        rw.parseBody(commit);
        final PatchSet.Id psId = ins.setGroups(groups).getPatchSetId();
        Account.Id me = user.getAccountId();
        List<FooterLine> footerLines = commit.getFooterLines();
        MailRecipients recipients = new MailRecipients();
        Map<String, Short> approvals = new HashMap<>();
        checkNotNull(magicBranch);
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.labels;
        recipients.add(getRecipientsFromFooters(accountResolver, magicBranch.draft, footerLines));
        recipients.remove(me);
        StringBuilder msg = new StringBuilder(ApprovalsUtil.renderMessageWithApprovals(psId.get(), approvals, Collections.<String, PatchSetApproval>emptyMap()));
        if (!Strings.isNullOrEmpty(magicBranch.message)) {
            msg.append("\n").append(magicBranch.message);
        }
        bu.insertChange(ins.setReviewers(recipients.getReviewers()).setExtraCC(recipients.getCcOnly()).setApprovals(approvals).setMessage(msg.toString()).setNotify(magicBranch.notify).setRequestScopePropagator(requestScopePropagator).setSendMail(true).setUpdateRef(true));
        if (!magicBranch.hashtags.isEmpty()) {
            bu.addOp(changeId, hashtagsFactory.create(new HashtagsInput(magicBranch.hashtags)).setFireEvent(false));
        }
        if (!Strings.isNullOrEmpty(magicBranch.topic)) {
            bu.addOp(changeId, new BatchUpdate.Op() {

                @Override
                public boolean updateChange(ChangeContext ctx) {
                    ctx.getUpdate(psId).setTopic(magicBranch.topic);
                    return true;
                }
            });
        }
        bu.addOp(changeId, new BatchUpdate.Op() {

            @Override
            public boolean updateChange(ChangeContext ctx) {
                change = ctx.getChange();
                return false;
            }
        });
        bu.addOp(changeId, new ChangeProgressOp(newProgress));
    } catch (Exception e) {
        throw INSERT_EXCEPTION.apply(e);
    }
}
#end_block

#method_before
private void submit(Collection<CreateRequest> create, Collection<ReplaceRequest> replace) throws OrmException, RestApiException {
    Map<ObjectId, Change> bySha = Maps.newHashMapWithExpectedSize(create.size() + replace.size());
    for (CreateRequest r : create) {
        bySha.put(r.commitId, r.getChange());
    }
    for (ReplaceRequest r : replace) {
        bySha.put(r.newCommitId, r.change);
    }
    Change tipChange = bySha.get(magicBranch.cmd.getNewId());
    checkState(tipChange != null, "tip of push does not correspond to a change; found these changes: %s", bySha);
    try (MergeOp op = mergeOpProvider.get()) {
        op.merge(db, tipChange, user, false, new SubmitInput());
    }
}
#method_after
private void submit(Collection<CreateRequest> create, Collection<ReplaceRequest> replace) throws OrmException, RestApiException {
    Map<ObjectId, Change> bySha = Maps.newHashMapWithExpectedSize(create.size() + replace.size());
    for (CreateRequest r : create) {
        checkNotNull(r.change, "cannot submit new change %s; op may not have run", r.changeId);
        bySha.put(r.commitId, r.change);
    }
    for (ReplaceRequest r : replace) {
        bySha.put(r.newCommitId, r.notes.getChange());
    }
    Change tipChange = bySha.get(magicBranch.cmd.getNewId());
    checkNotNull(tipChange, "tip of push does not correspond to a change; found these changes: %s", bySha);
    try (MergeOp op = mergeOpProvider.get()) {
        op.merge(db, tipChange, user, false, new SubmitInput());
    }
}
#end_block

#method_before
private void readChangesForReplace() throws OrmException {
    List<CheckedFuture<ChangeNotes, OrmException>> futures = Lists.newArrayListWithCapacity(replaceByChange.size());
    for (ReplaceRequest request : replaceByChange.values()) {
        futures.add(notesFactory.createAsync(changeUpdateExector, db, project.getNameKey(), request.ontoChange));
    }
    for (CheckedFuture<ChangeNotes, OrmException> f : futures) {
        ChangeNotes notes = f.checkedGet();
        if (notes.getChange() != null) {
            replaceByChange.get(notes.getChangeId()).change = notes.getChange();
        }
    }
}
#method_after
private void readChangesForReplace() throws OrmException {
    Collection<ChangeNotes> allNotes = notesFactory.create(db, Collections2.transform(replaceByChange.values(), new Function<ReplaceRequest, Change.Id>() {

        @Override
        public Change.Id apply(ReplaceRequest in) {
            return in.ontoChange;
        }
    }));
    for (ChangeNotes notes : allNotes) {
        replaceByChange.get(notes.getChangeId()).notes = notes;
    }
}
#end_block

#method_before
boolean validate(boolean autoClose) throws IOException, OrmException {
    if (!autoClose && inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    } else if (change == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    priorPatchSet = change.currentPatchSetId();
    if (!revisions.containsValue(priorPatchSet)) {
        reject(inputCommand, "change " + ontoChange + " missing revisions");
        return false;
    }
    RevCommit newCommit = rp.getRevWalk().parseCommit(newCommitId);
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    if (newCommit.equals(priorCommit)) {
        // Ignore requests to make the change its current state.
        skip = true;
        reject(inputCommand, "commit already exists (as current patchset)");
        return false;
    }
    changeCtl = projectControl.controlFor(db, change);
    if (!changeCtl.canAddPatchSet(db)) {
        String locked = ".";
        if (changeCtl.isPatchSetLocked(db)) {
            locked = ". Change is patch set locked.";
        }
        reject(inputCommand, "cannot replace " + ontoChange + locked);
        return false;
    } else if (change.getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    } else if (revisions.containsKey(newCommit)) {
        reject(inputCommand, "commit already exists (in the change)");
        return false;
    }
    for (Ref r : rp.getRepository().getRefDatabase().getRefs("refs/changes").values()) {
        if (r.getObjectId().equals(newCommit)) {
            reject(inputCommand, "commit already exists (in the project)");
            return false;
        }
    }
    for (RevCommit prior : revisions.keySet()) {
        // amending when trying to address review comments.
        if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
            reject(inputCommand, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
            return false;
        }
    }
    if (!validCommit(rp.getRevWalk(), changeCtl.getRefControl(), inputCommand, newCommit)) {
        return false;
    }
    rp.getRevWalk().parseBody(priorCommit);
    // of the commit was modified.
    if (newCommit.getTree().equals(priorCommit.getTree())) {
        boolean messageEq = eq(newCommit.getFullMessage(), priorCommit.getFullMessage());
        boolean parentsEq = parentsEqual(newCommit, priorCommit);
        boolean authorEq = authorEqual(newCommit, priorCommit);
        ObjectReader reader = rp.getRevWalk().getObjectReader();
        if (messageEq && parentsEq && authorEq && !autoClose) {
            addMessage(String.format("(W) No changes between prior commit %s and new commit %s", reader.abbreviate(priorCommit).name(), reader.abbreviate(newCommit).name()));
        } else {
            StringBuilder msg = new StringBuilder();
            msg.append("(I) ");
            msg.append(reader.abbreviate(newCommit).name());
            msg.append(":");
            msg.append(" no files changed");
            if (!authorEq) {
                msg.append(", author changed");
            }
            if (!messageEq) {
                msg.append(", message updated");
            }
            if (!parentsEq) {
                msg.append(", was rebased");
            }
            addMessage(msg.toString());
        }
    }
    if (magicBranch != null && magicBranch.edit) {
        return newEdit();
    }
    newPatchSet();
    return true;
}
#method_after
boolean validate(boolean autoClose) throws IOException, OrmException {
    if (!autoClose && inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    } else if (notes == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    priorPatchSet = notes.getChange().currentPatchSetId();
    if (!revisions.containsValue(priorPatchSet)) {
        reject(inputCommand, "change " + ontoChange + " missing revisions");
        return false;
    }
    RevCommit newCommit = rp.getRevWalk().parseCommit(newCommitId);
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    changeCtl = projectControl.controlFor(notes);
    if (!changeCtl.canAddPatchSet(db)) {
        String locked = ".";
        if (changeCtl.isPatchSetLocked(db)) {
            locked = ". Change is patch set locked.";
        }
        reject(inputCommand, "cannot replace " + ontoChange + locked);
        return false;
    } else if (notes.getChange().getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    } else if (revisions.containsKey(newCommit)) {
        reject(inputCommand, "commit already exists (in the change)");
        return false;
    }
    for (Ref r : rp.getRepository().getRefDatabase().getRefs("refs/changes").values()) {
        if (r.getObjectId().equals(newCommit)) {
            reject(inputCommand, "commit already exists (in the project)");
            return false;
        }
    }
    for (RevCommit prior : revisions.keySet()) {
        // amending when trying to address review comments.
        if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
            reject(inputCommand, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
            return false;
        }
    }
    if (!validCommit(rp.getRevWalk(), changeCtl.getRefControl(), inputCommand, newCommit)) {
        return false;
    }
    rp.getRevWalk().parseBody(priorCommit);
    // of the commit was modified.
    if (newCommit.getTree().equals(priorCommit.getTree())) {
        boolean messageEq = eq(newCommit.getFullMessage(), priorCommit.getFullMessage());
        boolean parentsEq = parentsEqual(newCommit, priorCommit);
        boolean authorEq = authorEqual(newCommit, priorCommit);
        ObjectReader reader = rp.getRevWalk().getObjectReader();
        if (messageEq && parentsEq && authorEq && !autoClose) {
            addMessage(String.format("(W) No changes between prior commit %s and new commit %s", reader.abbreviate(priorCommit).name(), reader.abbreviate(newCommit).name()));
        } else {
            StringBuilder msg = new StringBuilder();
            msg.append("(I) ");
            msg.append(reader.abbreviate(newCommit).name());
            msg.append(":");
            msg.append(" no files changed");
            if (!authorEq) {
                msg.append(", author changed");
            }
            if (!messageEq) {
                msg.append(", message updated");
            }
            if (!parentsEq) {
                msg.append(", was rebased");
            }
            addMessage(msg.toString());
        }
    }
    if (magicBranch != null && magicBranch.edit) {
        return newEdit();
    }
    newPatchSet();
    return true;
}
#end_block

#method_before
private boolean newEdit() {
    psId = change.currentPatchSetId();
    Optional<ChangeEdit> edit = null;
    try {
        edit = editUtil.byChange(changeCtl);
    } catch (AuthException | IOException e) {
        log.error("Cannot retrieve edit", e);
        return false;
    }
    if (edit.isPresent()) {
        if (edit.get().getBasePatchSet().getId().equals(psId)) {
            // replace edit
            cmd = new ReceiveCommand(edit.get().getRef().getObjectId(), newCommitId, edit.get().getRefName());
        } else {
            // delete old edit ref on rebase
            prev = new ReceiveCommand(edit.get().getRef().getObjectId(), ObjectId.zeroId(), edit.get().getRefName());
            createEditCommand();
        }
    } else {
        createEditCommand();
    }
    return true;
}
#method_after
private boolean newEdit() {
    psId = notes.getChange().currentPatchSetId();
    Optional<ChangeEdit> edit = null;
    try {
        edit = editUtil.byChange(changeCtl);
    } catch (AuthException | IOException e) {
        log.error("Cannot retrieve edit", e);
        return false;
    }
    if (edit.isPresent()) {
        if (edit.get().getBasePatchSet().getId().equals(psId)) {
            // replace edit
            cmd = new ReceiveCommand(edit.get().getRef().getObjectId(), newCommitId, edit.get().getRefName());
        } else {
            // delete old edit ref on rebase
            prev = new ReceiveCommand(edit.get().getRef().getObjectId(), ObjectId.zeroId(), edit.get().getRefName());
            createEditCommand();
        }
    } else {
        createEditCommand();
    }
    return true;
}
#end_block

#method_before
private void createEditCommand() {
    // create new edit
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommitId, RefNames.refsEdit(user.getAccountId(), change.getId(), psId));
}
#method_after
private void createEditCommand() {
    // create new edit
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommitId, RefNames.refsEdit(user.getAccountId(), notes.getChangeId(), psId));
}
#end_block

#method_before
private void newPatchSet() throws IOException {
    RevCommit newCommit = rp.getRevWalk().parseCommit(newCommitId);
    psId = ChangeUtil.nextPatchSetId(allRefs, change.currentPatchSetId());
    info = patchSetInfoFactory.get(rp.getRevWalk(), newCommit, psId);
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommitId, psId.toRefName());
}
#method_after
private void newPatchSet() throws IOException {
    RevCommit newCommit = rp.getRevWalk().parseCommit(newCommitId);
    psId = ChangeUtil.nextPatchSetId(allRefs, notes.getChange().currentPatchSetId());
    info = patchSetInfoFactory.get(rp.getRevWalk(), newCommit, psId);
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommitId, psId.toRefName());
}
#end_block

#method_before
void addOps(BatchUpdate bu) throws IOException {
    if (cmd.getResult() == NOT_ATTEMPTED) {
        // TODO(dborowitz): When does this happen? Only when an edit ref is
        // involved?
        cmd.execute(rp);
    }
    if (magicBranch != null && magicBranch.edit) {
        return;
    }
    RevWalk rw = rp.getRevWalk();
    // TODO(dborowitz): Move to ReplaceOp#updateRepo.
    RevCommit newCommit = rw.parseCommit(newCommitId);
    rw.parseBody(newCommit);
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    replaceOp = replaceOpFactory.create(requestScopePropagator, projectControl, change.getDest(), checkMergedInto, priorPatchSet, priorCommit, psId, newCommit, info, groups, magicBranch, rp.getPushCertificate());
    bu.addOp(change.getId(), replaceOp);
}
#method_after
void addOps(BatchUpdate bu, @Nullable Task progress) throws IOException {
    if (cmd.getResult() == NOT_ATTEMPTED) {
        // TODO(dborowitz): When does this happen? Only when an edit ref is
        // involved?
        cmd.execute(rp);
    }
    if (magicBranch != null && magicBranch.edit) {
        return;
    }
    RevWalk rw = rp.getRevWalk();
    // TODO(dborowitz): Move to ReplaceOp#updateRepo.
    RevCommit newCommit = rw.parseCommit(newCommitId);
    rw.parseBody(newCommit);
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    replaceOp = replaceOpFactory.create(requestScopePropagator, projectControl, notes.getChange().getDest(), checkMergedInto, priorPatchSet, priorCommit, psId, newCommit, info, groups, magicBranch, rp.getPushCertificate());
    bu.addOp(notes.getChangeId(), replaceOp);
    if (progress != null) {
        bu.addOp(notes.getChangeId(), new ChangeProgressOp(progress));
    }
}
#end_block

#method_before
void insertPatchSetWithoutBatchUpdate() throws IOException, UpdateException, RestApiException {
    try (BatchUpdate bu = batchUpdateFactory.create(db, projectControl.getProject().getNameKey(), user, TimeUtil.nowTs());
        ObjectInserter ins = repo.newObjectInserter()) {
        bu.setRepository(repo, rp.getRevWalk(), ins);
        addOps(bu);
        bu.execute();
    }
}
#method_after
void insertPatchSetWithoutBatchUpdate() throws IOException, UpdateException, RestApiException {
    try (BatchUpdate bu = batchUpdateFactory.create(db, projectControl.getProject().getNameKey(), user, TimeUtil.nowTs());
        ObjectInserter ins = repo.newObjectInserter()) {
        bu.setRepository(repo, rp.getRevWalk(), ins);
        addOps(bu, replaceProgress);
        bu.execute();
    }
}
#end_block

#method_before
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    if (ctl.canForgeAuthor() && ctl.canForgeCommitter() && ctl.canForgeGerritServerIdentity() && ctl.canUploadMerges() && !projectControl.getProjectState().isUseSignedOffBy() && Iterables.isEmpty(rejectCommits) && !RefNames.REFS_CONFIG.equals(ctl.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        return;
    }
    boolean defaultName = Strings.isNullOrEmpty(user.getAccount().getFullName());
    RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        RevObject parsedObject = walk.parseAny(cmd.getNewId());
        if (!(parsedObject instanceof RevCommit)) {
            return;
        }
        walk.markStart((RevCommit) parsedObject);
        markHeadsAsUninteresting(walk, cmd.getRefName());
        Set<ObjectId> existing = changeRefsById().keySet();
        for (RevCommit c; (c = walk.next()) != null; ) {
            if (existing.contains(c)) {
                continue;
            } else if (!validCommit(walk, ctl, cmd, c)) {
                break;
            }
            if (defaultName && user.hasEmailAddress(c.getCommitterIdent().getEmailAddress())) {
                try {
                    Account a = db.accounts().get(user.getAccountId());
                    if (a != null && Strings.isNullOrEmpty(a.getFullName())) {
                        a.setFullName(c.getCommitterIdent().getName());
                        db.accounts().update(Collections.singleton(a));
                        user.getAccount().setFullName(a.getFullName());
                        accountCache.evict(a.getId());
                    }
                } catch (OrmException e) {
                    log.warn("Cannot default full_name", e);
                } finally {
                    defaultName = false;
                }
            }
        }
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#method_after
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    if (ctl.canForgeAuthor() && ctl.canForgeCommitter() && ctl.canForgeGerritServerIdentity() && ctl.canUploadMerges() && !projectControl.getProjectState().isUseSignedOffBy() && Iterables.isEmpty(rejectCommits) && !RefNames.REFS_CONFIG.equals(ctl.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        return;
    }
    boolean defaultName = Strings.isNullOrEmpty(user.getAccount().getFullName());
    RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        RevObject parsedObject = walk.parseAny(cmd.getNewId());
        if (!(parsedObject instanceof RevCommit)) {
            return;
        }
        SetMultimap<ObjectId, Ref> existing = changeRefsById();
        walk.markStart((RevCommit) parsedObject);
        markHeadsAsUninteresting(walk, cmd.getRefName());
        for (RevCommit c; (c = walk.next()) != null; ) {
            if (existing.keySet().contains(c)) {
                continue;
            } else if (!validCommit(walk, ctl, cmd, c)) {
                break;
            }
            if (defaultName && user.hasEmailAddress(c.getCommitterIdent().getEmailAddress())) {
                try {
                    Account a = db.accounts().get(user.getAccountId());
                    if (a != null && Strings.isNullOrEmpty(a.getFullName())) {
                        a.setFullName(c.getCommitterIdent().getName());
                        db.accounts().update(Collections.singleton(a));
                        user.getAccount().setFullName(a.getFullName());
                        accountCache.evict(a.getId());
                    }
                } catch (OrmException e) {
                    log.warn("Cannot default full_name", e);
                } finally {
                    defaultName = false;
                }
            }
        }
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#end_block

#method_before
private void autoCloseChanges(final ReceiveCommand cmd) {
    String refName = cmd.getRefName();
    checkState(!MagicBranch.isMagicBranch(refName), "shouldn't be auto-closing changes on magic branch %s", refName);
    RevWalk rw = rp.getRevWalk();
    // insertChangesAndPatchSets.
    try (BatchUpdate bu = batchUpdateFactory.create(db, projectControl.getProject().getNameKey(), user, TimeUtil.nowTs());
        ObjectInserter ins = repo.newObjectInserter()) {
        bu.setRepository(repo, rp.getRevWalk(), ins).updateChangesInParallel();
        // TODO(dborowitz): Teach BatchUpdate to ignore missing changes.
        RevCommit newTip = rw.parseCommit(cmd.getNewId());
        Branch.NameKey branch = new Branch.NameKey(project.getNameKey(), refName);
        rw.reset();
        rw.markStart(newTip);
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        SetMultimap<ObjectId, Ref> byCommit = changeRefsById();
        Map<Change.Key, Change> byKey = null;
        int n = 0;
        COMMIT: for (RevCommit c; (c = rw.next()) != null; ) {
            rw.parseBody(c);
            for (Ref ref : byCommit.get(c.copy())) {
                n++;
                PatchSet.Id psId = PatchSet.Id.fromRef(ref.getName());
                bu.addOp(psId.getParentKey(), mergedByPushOpFactory.create(requestScopePropagator, psId, refName));
                continue COMMIT;
            }
            for (String changeId : c.getFooterLines(CHANGE_ID)) {
                if (byKey == null) {
                    byKey = openChangesByBranch(branch);
                }
                Change onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    Change.Id id = onto.getId();
                    final ReplaceRequest req = new ReplaceRequest(id, c, cmd, false);
                    req.change = onto;
                    if (req.validate(true)) {
                        n++;
                        req.addOps(bu);
                        bu.addOp(id, mergedByPushOpFactory.create(requestScopePropagator, req.psId, refName).setPatchSetProvider(new Provider<PatchSet>() {

                            @Override
                            public PatchSet get() {
                                return req.replaceOp.getPatchSet();
                            }
                        }));
                    }
                    break;
                }
            }
        }
        bu.execute();
        closeProgress.update(n);
    } catch (RestApiException e) {
        log.error("Can't insert patchset", e);
    } catch (IOException | OrmException | UpdateException e) {
        log.error("Can't scan for changes to close", e);
    }
}
#method_after
private void autoCloseChanges(final ReceiveCommand cmd) {
    String refName = cmd.getRefName();
    checkState(!MagicBranch.isMagicBranch(refName), "shouldn't be auto-closing changes on magic branch %s", refName);
    RevWalk rw = rp.getRevWalk();
    // insertChangesAndPatchSets.
    try (BatchUpdate bu = batchUpdateFactory.create(db, projectControl.getProject().getNameKey(), user, TimeUtil.nowTs());
        ObjectInserter ins = repo.newObjectInserter()) {
        bu.setRepository(repo, rp.getRevWalk(), ins).updateChangesInParallel();
        // TODO(dborowitz): Teach BatchUpdate to ignore missing changes.
        RevCommit newTip = rw.parseCommit(cmd.getNewId());
        Branch.NameKey branch = new Branch.NameKey(project.getNameKey(), refName);
        rw.reset();
        rw.markStart(newTip);
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        SetMultimap<ObjectId, Ref> byCommit = changeRefsById();
        Map<Change.Key, ChangeNotes> byKey = null;
        List<ReplaceRequest> replaceAndClose = new ArrayList<>();
        COMMIT: for (RevCommit c; (c = rw.next()) != null; ) {
            rw.parseBody(c);
            for (Ref ref : byCommit.get(c.copy())) {
                PatchSet.Id psId = PatchSet.Id.fromRef(ref.getName());
                bu.addOp(psId.getParentKey(), mergedByPushOpFactory.create(requestScopePropagator, psId, refName));
                continue COMMIT;
            }
            for (String changeId : c.getFooterLines(CHANGE_ID)) {
                if (byKey == null) {
                    byKey = openChangesByBranch(branch);
                }
                ChangeNotes onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    // Hold onto this until we're done with the walk, as the call to
                    // req.validate below calls isMergedInto which resets the walk.
                    ReplaceRequest req = new ReplaceRequest(onto.getChangeId(), c, cmd, false);
                    req.notes = onto;
                    replaceAndClose.add(req);
                    continue COMMIT;
                }
            }
        }
        for (final ReplaceRequest req : replaceAndClose) {
            Change.Id id = req.notes.getChangeId();
            if (!req.validate(true)) {
                continue;
            }
            req.addOps(bu, null);
            bu.addOp(id, mergedByPushOpFactory.create(requestScopePropagator, req.psId, refName).setPatchSetProvider(new Provider<PatchSet>() {

                @Override
                public PatchSet get() {
                    return req.replaceOp.getPatchSet();
                }
            }));
            bu.addOp(id, new ChangeProgressOp(closeProgress));
        }
        bu.execute();
    } catch (RestApiException e) {
        log.error("Can't insert patchset", e);
    } catch (IOException | OrmException | UpdateException e) {
        log.error("Can't scan for changes to close", e);
    }
}
#end_block

#method_before
private Map<Change.Key, Change> openChangesByBranch(Branch.NameKey branch) throws OrmException {
    Map<Change.Key, Change> r = new HashMap<>();
    for (ChangeData cd : queryProvider.get().byBranchOpen(branch)) {
        r.put(cd.change().getKey(), cd.change());
    }
    return r;
}
#method_after
private Map<Change.Key, ChangeNotes> openChangesByBranch(Branch.NameKey branch) throws OrmException {
    Map<Change.Key, ChangeNotes> r = new HashMap<>();
    for (ChangeData cd : queryProvider.get().byBranchOpen(branch)) {
        r.put(cd.change().getKey(), cd.notes());
    }
    return r;
}
#end_block

#method_before
public void updateSuperProjects() throws SubmoduleException {
    SetMultimap<Project.NameKey, Branch.NameKey> dst = branchesByProject();
    Set<Project.NameKey> projects = dst.keySet();
    try {
        for (Project.NameKey project : projects) {
            // get a new BatchUpdate for the project
            orm.openRepo(project, false);
            orm.getRepo(project).resetUpdate();
            for (Branch.NameKey branch : dst.get(project)) {
                SubmoduleOp.RepoOnlyOp op = new SubmoduleOp.RepoOnlyOp(this, branch);
                orm.getRepo(project).getUpdate().addRepoOnlyOp(op);
            }
        }
        BatchUpdate.execute(orm.batchUpdates(projects), new Listener());
    } catch (RestApiException | UpdateException | IOException | NoSuchProjectException e) {
        throw new SubmoduleException("Cannot update gitlinks", e);
    }
}
#method_after
public void updateSuperProjects() throws SubmoduleException {
    SetMultimap<Project.NameKey, Branch.NameKey> dst = branchesByProject();
    Set<Project.NameKey> projects = dst.keySet();
    try {
        for (Project.NameKey project : projects) {
            // get a new BatchUpdate for the project
            orm.openRepo(project, false);
            // TODO:czhen remove this when MergeOp combine this into BatchUpdate
            orm.getRepo(project).resetUpdate();
            for (Branch.NameKey branch : dst.get(project)) {
                SubmoduleOp.GitlinkOp op = new SubmoduleOp.GitlinkOp(branch);
                orm.getRepo(project).getUpdate().addRepoOnlyOp(op);
            }
        }
        BatchUpdate.execute(orm.batchUpdates(projects), Listener.NONE);
    } catch (RestApiException | UpdateException | IOException | NoSuchProjectException e) {
        throw new SubmoduleException("Cannot update gitlinks", e);
    }
}
#end_block

#method_before
public CodeReviewCommit composeGitlinksCommit(final Branch.NameKey subscriber, RevCommit baseCommit) throws IOException, SubmoduleException, OrmException {
    PersonIdent author = null;
    StringBuilder msgbuf = new StringBuilder("Update git submodules\n\n");
    boolean sameAuthorForAll = true;
    try {
        orm.openRepo(subscriber.getParentKey(), false);
    } catch (NoSuchProjectException | IOException e) {
        throw new SubmoduleException("Cannot access superproject", e);
    }
    OpenRepo or = orm.getRepo(subscriber.getParentKey());
    Ref r = or.repo.exactRef(subscriber.get());
    if (r == null) {
        throw new SubmoduleException("The branch was probably deleted from the subscriber repository");
    }
    RevCommit currentCommit = (baseCommit != null) ? baseCommit : or.rw.parseCommit(or.repo.exactRef(subscriber.get()).getObjectId());
    or.rw.parseBody(currentCommit);
    DirCache dc = readTree(or.rw, currentCommit);
    DirCacheEditor ed = dc.editor();
    for (SubmoduleSubscription s : targets.get(subscriber)) {
        try {
            orm.openRepo(s.getSubmodule().getParentKey(), false);
        } catch (NoSuchProjectException | IOException e) {
            throw new SubmoduleException("Cannot access submodule", e);
        }
        OpenRepo subOr = orm.getRepo(s.getSubmodule().getParentKey());
        Repository subRepo = subOr.repo;
        Ref ref = subRepo.getRefDatabase().exactRef(s.getSubmodule().get());
        if (ref == null) {
            ed.add(new DeletePath(s.getPath()));
            continue;
        }
        ObjectId updateTo = ref.getObjectId();
        if (branchTips.containsKey(s.getSubmodule())) {
            updateTo = branchTips.get(s.getSubmodule());
        }
        RevWalk subOrRw = subOr.rw;
        final RevCommit newCommit = subOrRw.parseCommit(updateTo);
        subOrRw.parseBody(newCommit);
        if (author == null) {
            author = newCommit.getAuthorIdent();
        } else if (!author.equals(newCommit.getAuthorIdent())) {
            sameAuthorForAll = false;
        }
        DirCacheEntry dce = dc.getEntry(s.getPath());
        ObjectId oldId;
        if (dce != null) {
            if (!dce.getFileMode().equals(FileMode.GITLINK)) {
                log.error("Requested to update gitlink " + s.getPath() + " in " + s.getSubmodule().getParentKey().get() + " but entry " + "doesn't have gitlink file mode.");
                continue;
            }
            oldId = dce.getObjectId();
        } else {
            // This submodule did not exist before. We do not want to add
            // the full submodule history to the commit message, so omit it.
            oldId = updateTo;
        }
        ed.add(new PathEdit(s.getPath()) {

            @Override
            public void apply(DirCacheEntry ent) {
                ent.setFileMode(FileMode.GITLINK);
                ent.setObjectId(newCommit.getId());
            }
        });
        if (verboseSuperProject) {
            msgbuf.append("Project: " + s.getSubmodule().getParentKey().get());
            msgbuf.append(" " + s.getSubmodule().getShortName());
            msgbuf.append(" " + newCommit.getName());
            msgbuf.append("\n\n");
            try {
                subOrRw.resetRetain(subOr.canMergeFlag);
                subOrRw.markStart(newCommit);
                subOrRw.markUninteresting(subOrRw.parseCommit(oldId));
                for (RevCommit c : subOrRw) {
                    subOrRw.parseBody(c);
                    msgbuf.append(c.getFullMessage() + "\n\n");
                }
            } catch (IOException e) {
                throw new SubmoduleException("Could not perform a revwalk to " + "create superproject commit message", e);
            }
        }
    }
    ed.finish();
    ObjectInserter oi = or.repo.newObjectInserter();
    CodeReviewRevWalk rw = or.rw;
    ObjectId tree = dc.writeTree(oi);
    if (!sameAuthorForAll || author == null) {
        author = myIdent;
    }
    CommitBuilder commit = new CommitBuilder();
    commit.setTreeId(tree);
    if (baseCommit != null) {
        // modify the baseCommit
        commit.setParentIds(baseCommit.getParents());
        commit.setMessage(baseCommit.getFullMessage() + "\n\n" + msgbuf.toString());
        commit.setAuthor(baseCommit.getAuthorIdent());
    } else {
        // create a new commit
        commit.setParentId(currentCommit);
        commit.setMessage(msgbuf.toString());
        commit.setAuthor(author);
    }
    commit.setCommitter(myIdent);
    ObjectId id = oi.insert(commit);
    oi.flush();
    return rw.parseCommit(id);
}
#method_after
public CodeReviewCommit composeGitlinksCommit(final Branch.NameKey subscriber, RevCommit baseCommit) throws IOException, SubmoduleException, OrmException {
    PersonIdent author = null;
    StringBuilder msgbuf = new StringBuilder("Update git submodules\n\n");
    boolean sameAuthorForAll = true;
    try {
        orm.openRepo(subscriber.getParentKey(), false);
    } catch (NoSuchProjectException | IOException e) {
        throw new SubmoduleException("Cannot access superproject", e);
    }
    OpenRepo or = orm.getRepo(subscriber.getParentKey());
    Ref r = or.repo.exactRef(subscriber.get());
    if (r == null) {
        throw new SubmoduleException("The branch was probably deleted from the subscriber repository");
    }
    RevCommit currentCommit = (baseCommit != null) ? baseCommit : or.rw.parseCommit(or.repo.exactRef(subscriber.get()).getObjectId());
    or.rw.parseBody(currentCommit);
    DirCache dc = readTree(or.rw, currentCommit);
    DirCacheEditor ed = dc.editor();
    for (SubmoduleSubscription s : targets.get(subscriber)) {
        try {
            orm.openRepo(s.getSubmodule().getParentKey(), false);
        } catch (NoSuchProjectException | IOException e) {
            throw new SubmoduleException("Cannot access submodule", e);
        }
        OpenRepo subOr = orm.getRepo(s.getSubmodule().getParentKey());
        Repository subRepo = subOr.repo;
        Ref ref = subRepo.getRefDatabase().exactRef(s.getSubmodule().get());
        if (ref == null) {
            ed.add(new DeletePath(s.getPath()));
            continue;
        }
        ObjectId updateTo = ref.getObjectId();
        if (branchTips.containsKey(s.getSubmodule())) {
            updateTo = branchTips.get(s.getSubmodule());
        }
        RevWalk subOrRw = subOr.rw;
        final RevCommit newCommit = subOrRw.parseCommit(updateTo);
        subOrRw.parseBody(newCommit);
        if (author == null) {
            author = newCommit.getAuthorIdent();
        } else if (!author.equals(newCommit.getAuthorIdent())) {
            sameAuthorForAll = false;
        }
        DirCacheEntry dce = dc.getEntry(s.getPath());
        ObjectId oldId;
        if (dce != null) {
            if (!dce.getFileMode().equals(FileMode.GITLINK)) {
                String errMsg = "Requested to update gitlink " + s.getPath() + " in " + s.getSubmodule().getParentKey().get() + " but entry " + "doesn't have gitlink file mode.";
                throw new SubmoduleException(errMsg);
            }
            oldId = dce.getObjectId();
        } else {
            // This submodule did not exist before. We do not want to add
            // the full submodule history to the commit message, so omit it.
            oldId = updateTo;
        }
        ed.add(new PathEdit(s.getPath()) {

            @Override
            public void apply(DirCacheEntry ent) {
                ent.setFileMode(FileMode.GITLINK);
                ent.setObjectId(newCommit.getId());
            }
        });
        if (verboseSuperProject) {
            msgbuf.append("Project: " + s.getSubmodule().getParentKey().get());
            msgbuf.append(" " + s.getSubmodule().getShortName());
            msgbuf.append(" " + newCommit.getName());
            msgbuf.append("\n\n");
            try {
                subOrRw.resetRetain(subOr.canMergeFlag);
                subOrRw.markStart(newCommit);
                subOrRw.markUninteresting(subOrRw.parseCommit(oldId));
                for (RevCommit c : subOrRw) {
                    subOrRw.parseBody(c);
                    msgbuf.append(c.getFullMessage() + "\n\n");
                }
            } catch (IOException e) {
                throw new SubmoduleException("Could not perform a revwalk to " + "create superproject commit message", e);
            }
        }
    }
    ed.finish();
    ObjectInserter oi = or.ins;
    CodeReviewRevWalk rw = or.rw;
    ObjectId tree = dc.writeTree(oi);
    if (!sameAuthorForAll || author == null) {
        author = myIdent;
    }
    CommitBuilder commit = new CommitBuilder();
    commit.setTreeId(tree);
    if (baseCommit != null) {
        // modify the baseCommit
        commit.setParentIds(baseCommit.getParents());
        commit.setMessage(baseCommit.getFullMessage() + "\n\n" + msgbuf.toString());
        commit.setAuthor(baseCommit.getAuthorIdent());
    } else {
        // create a new commit
        commit.setParentId(currentCommit);
        commit.setMessage(msgbuf.toString());
        commit.setAuthor(author);
    }
    commit.setCommitter(myIdent);
    ObjectId id = oi.insert(commit);
    return rw.parseCommit(id);
}
#end_block

#method_before
private void checkSubmitRulesAndState() throws ResourceConflictException {
    for (ChangeData cd : commits.changes.values()) {
        try {
            if (cd.change().getStatus() != Change.Status.NEW) {
                commits.problem(cd.getId(), "Change " + cd.getId() + " is " + cd.change().getStatus().toString().toLowerCase());
            } else {
                checkSubmitRule(cd);
            }
        } catch (ResourceConflictException e) {
            commits.problem(cd.getId(), e.getMessage());
        } catch (OrmException e) {
            String msg = "Error checking submit rules for change";
            log.warn(msg + " " + cd.getId(), e);
            commits.problem(cd.getId(), msg);
        }
    }
    commits.maybeFailVerbose();
}
#method_after
private void checkSubmitRulesAndState(ChangeSet cs) throws ResourceConflictException {
    checkArgument(!cs.furtherHiddenChanges(), "checkSubmitRulesAndState called for topic with hidden change");
    for (ChangeData cd : cs.changes()) {
        try {
            if (cd.change().getStatus() != Change.Status.NEW) {
                commits.problem(cd.getId(), "Change " + cd.getId() + " is " + cd.change().getStatus().toString().toLowerCase());
            } else {
                checkSubmitRule(cd);
            }
        } catch (ResourceConflictException e) {
            commits.problem(cd.getId(), e.getMessage());
        } catch (OrmException e) {
            String msg = "Error checking submit rules for change";
            log.warn(msg + " " + cd.getId(), e);
            commits.problem(cd.getId(), msg);
        }
    }
    commits.maybeFailVerbose();
}
#end_block

#method_before
private void bypassSubmitRules(ChangeSet cs) {
    for (ChangeData cd : cs.changes()) {
        List<SubmitRecord> records;
        try {
            records = new ArrayList<>(getSubmitRecords(cd));
        } catch (OrmException e) {
            log.warn("Error checking submit rules for change " + cd.getId(), e);
            records = new ArrayList<>(1);
        }
        SubmitRecord forced = new SubmitRecord();
        forced.status = SubmitRecord.Status.FORCED;
        records.add(forced);
        cd.setSubmitRecords(records);
    }
}
#method_after
private void bypassSubmitRules(ChangeSet cs) {
    checkArgument(!cs.furtherHiddenChanges(), "cannot bypass submit rules for topic with hidden change");
    for (ChangeData cd : cs.changes()) {
        List<SubmitRecord> records;
        try {
            records = new ArrayList<>(getSubmitRecords(cd));
        } catch (OrmException e) {
            log.warn("Error checking submit rules for change " + cd.getId(), e);
            records = new ArrayList<>(1);
        }
        SubmitRecord forced = new SubmitRecord();
        forced.status = SubmitRecord.Status.FORCED;
        records.add(forced);
        cd.setSubmitRecords(records);
    }
}
#end_block

#method_before
public void merge(ReviewDb db, Change change, IdentifiedUser caller, boolean checkSubmitRules, SubmitInput submitInput) throws OrmException, RestApiException {
    this.submitInput = submitInput;
    this.caller = caller;
    updateSubmissionId(change);
    this.db = db;
    orm.setContext(db, ts, caller, submissionId);
    logDebug("Beginning integration of {}", change);
    try {
        ChangeSet cs = mergeSuperSet.completeChangeSet(db, change, caller);
        checkState(cs.ids().contains(change.getId()), "change %s missing from %s", change.getId(), cs);
        this.commits = new CommitStatus(cs);
        MergeSuperSet.reloadChanges(cs);
        logDebug("Calculated to merge {}", cs);
        if (checkSubmitRules) {
            logDebug("Checking submit rules and state");
            checkSubmitRulesAndState();
        } else {
            logDebug("Bypassing submit rules");
            bypassSubmitRules(cs);
        }
        try {
            integrateIntoHistory(cs);
        } catch (IntegrationException e) {
            logError("Error from integrateIntoHistory", e);
            throw new ResourceConflictException(e.getMessage(), e);
        }
    } catch (IOException e) {
        // Anything before the merge attempt is an error
        throw new OrmException(e);
    }
}
#method_after
public void merge(ReviewDb db, Change change, IdentifiedUser caller, boolean checkSubmitRules, SubmitInput submitInput) throws OrmException, RestApiException {
    this.submitInput = submitInput;
    this.caller = caller;
    updateSubmissionId(change);
    this.db = db;
    orm.setContext(db, ts, caller, submissionId);
    logDebug("Beginning integration of {}", change);
    try {
        ChangeSet cs = mergeSuperSet.completeChangeSet(db, change, caller);
        checkState(cs.ids().contains(change.getId()), "change %s missing from %s", change.getId(), cs);
        if (cs.furtherHiddenChanges()) {
            throw new AuthException("A change to be submitted with " + change.getId() + " is not visible");
        }
        this.commits = new CommitStatus(cs);
        MergeSuperSet.reloadChanges(cs);
        logDebug("Calculated to merge {}", cs);
        if (checkSubmitRules) {
            logDebug("Checking submit rules and state");
            checkSubmitRulesAndState(cs);
        } else {
            logDebug("Bypassing submit rules");
            bypassSubmitRules(cs);
        }
        try {
            integrateIntoHistory(cs);
        } catch (IntegrationException e) {
            logError("Error from integrateIntoHistory", e);
            throw new ResourceConflictException(e.getMessage(), e);
        }
    } catch (IOException e) {
        // Anything before the merge attempt is an error
        throw new OrmException(e);
    }
}
#end_block

#method_before
private void integrateIntoHistory(ChangeSet cs) throws IntegrationException, RestApiException {
    logDebug("Beginning merge attempt on {}", cs);
    Map<Branch.NameKey, BranchBatch> toSubmit = new HashMap<>();
    logDebug("Perform the merges");
    Multimap<Project.NameKey, Branch.NameKey> br;
    Multimap<Branch.NameKey, ChangeData> cbb;
    try {
        br = cs.branchesByProject();
        cbb = cs.changesByBranch();
    } catch (OrmException e) {
        throw new IntegrationException("Error reading changes to submit", e);
    }
    Set<Project.NameKey> projects = br.keySet();
    Collection<Branch.NameKey> branches = cbb.keySet();
    openRepos(projects);
    for (Branch.NameKey branch : branches) {
        OpenRepo or = orm.getRepo(branch.getParentKey());
        toSubmit.put(branch, validateChangeList(or, cbb.get(branch)));
    }
    // Done checks that don't involve running submit strategies.
    commits.maybeFailVerbose();
    List<SubmitStrategy> strategies = new ArrayList<>(branches.size());
    for (Branch.NameKey branch : branches) {
        OpenRepo or = orm.getRepo(branch.getParentKey());
        OpenBranch ob = or.getBranch(branch);
        BranchBatch submitting = toSubmit.get(branch);
        checkNotNull(submitting.submitType(), "null submit type for %s; expected to previously fail fast", submitting);
        Set<CodeReviewCommit> commitsToSubmit = commits(submitting.changes());
        ob.mergeTip = new MergeTip(ob.oldTip, commitsToSubmit);
        SubmitStrategy strategy = createStrategy(or, ob.mergeTip, branch, submitting.submitType(), ob.oldTip);
        strategies.add(strategy);
        strategy.addOps(or.getUpdate(), commitsToSubmit);
    }
    try {
        BatchUpdate.execute(batchUpdates(projects), new SubmitStrategyListener(submitInput, strategies, commits));
    } catch (UpdateException e) {
        // BatchUpdate may have inadvertently wrapped an IntegrationException
        // thrown by some legacy SubmitStrategyOp code that intended the error
        // message to be user-visible. Copy the message from the wrapped
        // exception.
        // 
        // If you happen across one of these, the correct fix is to convert the
        // inner IntegrationException to a ResourceConflictException.
        String msg;
        if (e.getCause() instanceof IntegrationException) {
            msg = e.getCause().getMessage();
        } else {
            msg = "Error submitting change" + (cs.size() != 1 ? "s" : "");
        }
        throw new IntegrationException(msg, e);
    }
    updateSuperProjects(br.values());
}
#method_after
private void integrateIntoHistory(ChangeSet cs) throws IntegrationException, RestApiException {
    checkArgument(!cs.furtherHiddenChanges(), "cannot integrate hidden changes into history");
    logDebug("Beginning merge attempt on {}", cs);
    Map<Branch.NameKey, BranchBatch> toSubmit = new HashMap<>();
    logDebug("Perform the merges");
    Multimap<Project.NameKey, Branch.NameKey> br;
    Multimap<Branch.NameKey, ChangeData> cbb;
    try {
        br = cs.branchesByProject();
        cbb = cs.changesByBranch();
    } catch (OrmException e) {
        throw new IntegrationException("Error reading changes to submit", e);
    }
    Set<Project.NameKey> projects = br.keySet();
    Collection<Branch.NameKey> branches = cbb.keySet();
    openRepos(projects);
    for (Branch.NameKey branch : branches) {
        OpenRepo or = orm.getRepo(branch.getParentKey());
        toSubmit.put(branch, validateChangeList(or, cbb.get(branch)));
    }
    // Done checks that don't involve running submit strategies.
    commits.maybeFailVerbose();
    List<SubmitStrategy> strategies = new ArrayList<>(branches.size());
    for (Branch.NameKey branch : branches) {
        OpenRepo or = orm.getRepo(branch.getParentKey());
        OpenBranch ob = or.getBranch(branch);
        BranchBatch submitting = toSubmit.get(branch);
        checkNotNull(submitting.submitType(), "null submit type for %s; expected to previously fail fast", submitting);
        Set<CodeReviewCommit> commitsToSubmit = commits(submitting.changes());
        ob.mergeTip = new MergeTip(ob.oldTip, commitsToSubmit);
        SubmitStrategy strategy = createStrategy(or, ob.mergeTip, branch, submitting.submitType(), ob.oldTip);
        strategies.add(strategy);
        strategy.addOps(or.getUpdate(), commitsToSubmit);
    }
    try {
        BatchUpdate.execute(batchUpdates(projects), new SubmitStrategyListener(submitInput, strategies, commits));
    } catch (UpdateException e) {
        // BatchUpdate may have inadvertently wrapped an IntegrationException
        // thrown by some legacy SubmitStrategyOp code that intended the error
        // message to be user-visible. Copy the message from the wrapped
        // exception.
        // 
        // If you happen across one of these, the correct fix is to convert the
        // inner IntegrationException to a ResourceConflictException.
        String msg;
        if (e.getCause() instanceof IntegrationException) {
            msg = e.getCause().getMessage();
        } else {
            msg = "Error submitting change" + (cs.size() != 1 ? "s" : "");
        }
        throw new IntegrationException(msg, e);
    }
    updateSuperProjects(br.values());
}
#end_block

#method_before
private Set<RevCommit> getAlreadyAccepted(OpenRepo or, CodeReviewCommit branchTip) throws IntegrationException {
    Set<RevCommit> alreadyAccepted = new HashSet<>();
    if (branchTip != null) {
        alreadyAccepted.add(branchTip);
    }
    try {
        for (Ref r : or.repo.getRefDatabase().getRefs(Constants.R_HEADS).values()) {
            try {
                alreadyAccepted.add(or.rw.parseCommit(r.getObjectId()));
            } catch (IncorrectObjectTypeException iote) {
            // Not a commit? Skip over it.
            }
        }
    } catch (IOException e) {
        throw new IntegrationException("Failed to determine already accepted commits.", e);
    }
    logDebug("Found {} existing heads", alreadyAccepted.size());
    return alreadyAccepted;
}
#method_after
private Set<RevCommit> getAlreadyAccepted(OpenRepo or, CodeReviewCommit branchTip) throws IntegrationException {
    Set<RevCommit> alreadyAccepted = new HashSet<>();
    if (branchTip != null) {
        alreadyAccepted.add(branchTip);
    }
    try {
        for (Ref r : or.repo.getRefDatabase().getRefs(Constants.R_HEADS).values()) {
            try {
                CodeReviewCommit aac = or.rw.parseCommit(r.getObjectId());
                if (!commits.commits.values().contains(aac)) {
                    alreadyAccepted.add(aac);
                }
            } catch (IncorrectObjectTypeException iote) {
            // Not a commit? Skip over it.
            }
        }
    } catch (IOException e) {
        throw new IntegrationException("Failed to determine already accepted commits.", e);
    }
    logDebug("Found {} existing heads", alreadyAccepted.size());
    return alreadyAccepted;
}
#end_block

#method_before
@Test
public void addGroupAsReviewer() throws Exception {
    // Set up two groups, one that is too large too add as reviewer, and one
    // that is too large to add without confirmation.
    String largeGroup = createGroup("largeGroup");
    String mediumGroup = createGroup("mediumGroup");
    int largeGroupSize = PostReviewers.DEFAULT_MAX_REVIEWERS + 1;
    int mediumGroupSize = PostReviewers.DEFAULT_MAX_REVIEWERS_WITHOUT_CHECK + 1;
    List<TestAccount> users = createAccounts(largeGroupSize, "addGroupAsReviewer");
    List<String> largeGroupUsernames = new ArrayList<>(mediumGroupSize);
    for (TestAccount u : users) {
        largeGroupUsernames.add(u.username);
    }
    List<String> mediumGroupUsernames = largeGroupUsernames.subList(0, mediumGroupSize);
    gApi.groups().id(largeGroup).addMembers(largeGroupUsernames.toArray(new String[largeGroupSize]));
    gApi.groups().id(mediumGroup).addMembers(mediumGroupUsernames.toArray(new String[mediumGroupSize]));
    // Attempt to add overly large group as reviewers.
    PushOneCommit.Result r = createChange();
    String changeId = r.getChangeId();
    AddReviewerResult result = addReviewer(changeId, largeGroup);
    assertThat(result.reviewer).isEqualTo(largeGroup);
    assertThat(result.confirm).isNull();
    assertThat(result.error).contains("has too many members to add them all as reviewers");
    assertThat(result.reviewers).isNull();
    // Attempt to add medium group without confirmation.
    result = addReviewer(changeId, mediumGroup);
    assertThat(result.reviewer).isEqualTo(mediumGroup);
    assertThat(result.confirm).isTrue();
    assertThat(result.error).contains("has " + mediumGroupSize + " members. Do you want to add them" + " all as reviewers?");
    assertThat(result.reviewers).isNull();
    // Add medium group with confirmation.
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = mediumGroup;
    in.confirmed = true;
    result = addReviewer(changeId, in);
    assertThat(result.reviewer).isEqualTo(mediumGroup);
    assertThat(result.confirm).isNull();
    assertThat(result.error).isNull();
    assertThat(result.reviewers).hasSize(mediumGroupSize);
    // Verify that group members were added as reviewers.
    ChangeInfo c = gApi.changes().id(r.getChangeId()).get();
    assertReviewers(c, notesMigration.readChanges() ? REVIEWER : CC, users.subList(0, mediumGroupSize));
}
#method_after
@Test
public void addGroupAsReviewer() throws Exception {
    // Set up two groups, one that is too large too add as reviewer, and one
    // that is too large to add without confirmation.
    String largeGroup = createGroup("largeGroup");
    String mediumGroup = createGroup("mediumGroup");
    int largeGroupSize = PostReviewers.DEFAULT_MAX_REVIEWERS + 1;
    int mediumGroupSize = PostReviewers.DEFAULT_MAX_REVIEWERS_WITHOUT_CHECK + 1;
    List<TestAccount> users = createAccounts(largeGroupSize, "addGroupAsReviewer");
    List<String> largeGroupUsernames = new ArrayList<>(mediumGroupSize);
    for (TestAccount u : users) {
        largeGroupUsernames.add(u.username);
    }
    List<String> mediumGroupUsernames = largeGroupUsernames.subList(0, mediumGroupSize);
    gApi.groups().id(largeGroup).addMembers(largeGroupUsernames.toArray(new String[largeGroupSize]));
    gApi.groups().id(mediumGroup).addMembers(mediumGroupUsernames.toArray(new String[mediumGroupSize]));
    // Attempt to add overly large group as reviewers.
    PushOneCommit.Result r = createChange();
    String changeId = r.getChangeId();
    AddReviewerResult result = addReviewer(changeId, largeGroup);
    assertThat(result.input).isEqualTo(largeGroup);
    assertThat(result.confirm).isNull();
    assertThat(result.error).contains("has too many members to add them all as reviewers");
    assertThat(result.reviewers).isNull();
    // Attempt to add medium group without confirmation.
    result = addReviewer(changeId, mediumGroup);
    assertThat(result.input).isEqualTo(mediumGroup);
    assertThat(result.confirm).isTrue();
    assertThat(result.error).contains("has " + mediumGroupSize + " members. Do you want to add them" + " all as reviewers?");
    assertThat(result.reviewers).isNull();
    // Add medium group with confirmation.
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = mediumGroup;
    in.confirmed = true;
    result = addReviewer(changeId, in);
    assertThat(result.input).isEqualTo(mediumGroup);
    assertThat(result.confirm).isNull();
    assertThat(result.error).isNull();
    assertThat(result.reviewers).hasSize(mediumGroupSize);
    // Verify that group members were added as reviewers.
    ChangeInfo c = gApi.changes().id(r.getChangeId()).get();
    assertReviewers(c, notesMigration.readChanges() ? REVIEWER : CC, users.subList(0, mediumGroupSize));
}
#end_block

#method_before
@Test
public void addCcAccount() throws Exception {
    TestTimeUtil.resetWithClockStep(1, SECONDS);
    sender.clear();
    PushOneCommit.Result r = createChange();
    String changeId = r.getChangeId();
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    in.state = CC;
    AddReviewerResult result = addReviewer(changeId, in);
    assertThat(result.reviewer).isEqualTo(user.email);
    assertThat(result.confirm).isNull();
    assertThat(result.error).isNull();
    ChangeInfo c = gApi.changes().id(r.getChangeId()).get();
    if (notesMigration.readChanges()) {
        assertThat(result.reviewers).isNull();
        assertThat(result.ccs).hasSize(1);
        AccountInfo ai = result.ccs.get(0);
        assertThat(ai._accountId).isEqualTo(user.id.get());
        assertReviewers(c, CC, user);
    } else {
        assertThat(result.ccs).isNull();
        assertThat(result.reviewers).hasSize(1);
        AccountInfo ai = result.reviewers.get(0);
        assertThat(ai._accountId).isEqualTo(user.id.get());
        assertReviewers(c, CC, user);
    }
    // Verify email was sent to CCed account.
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(user.emailAddress);
    if (notesMigration.readChanges()) {
        assertThat(m.body()).contains(admin.fullName + " has uploaded a new change for review.");
    } else {
        assertThat(m.body()).contains("Hello " + user.fullName + ",\n");
        assertThat(m.body()).contains("I'd like you to do a code review.");
    }
}
#method_after
@Test
public void addCcAccount() throws Exception {
    PushOneCommit.Result r = createChange();
    String changeId = r.getChangeId();
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    in.state = CC;
    AddReviewerResult result = addReviewer(changeId, in);
    assertThat(result.input).isEqualTo(user.email);
    assertThat(result.confirm).isNull();
    assertThat(result.error).isNull();
    ChangeInfo c = gApi.changes().id(r.getChangeId()).get();
    if (notesMigration.readChanges()) {
        assertThat(result.reviewers).isNull();
        assertThat(result.ccs).hasSize(1);
        AccountInfo ai = result.ccs.get(0);
        assertThat(ai._accountId).isEqualTo(user.id.get());
        assertReviewers(c, CC, user);
    } else {
        assertThat(result.ccs).isNull();
        assertThat(result.reviewers).hasSize(1);
        AccountInfo ai = result.reviewers.get(0);
        assertThat(ai._accountId).isEqualTo(user.id.get());
        assertReviewers(c, CC, user);
    }
    // Verify email was sent to CCed account.
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(user.emailAddress);
    if (notesMigration.readChanges()) {
        assertThat(m.body()).contains(admin.fullName + " has uploaded a new change for review.");
    } else {
        assertThat(m.body()).contains("Hello " + user.fullName + ",\n");
        assertThat(m.body()).contains("I'd like you to do a code review.");
    }
}
#end_block

#method_before
@Test
public void addCcGroup() throws Exception {
    List<TestAccount> users = createAccounts(6, "addCcGroup");
    List<String> usernames = new ArrayList<>(6);
    for (TestAccount u : users) {
        usernames.add(u.username);
    }
    List<TestAccount> firstUsers = users.subList(0, 3);
    List<String> firstUsernames = usernames.subList(0, 3);
    TestTimeUtil.resetWithClockStep(1, SECONDS);
    sender.clear();
    PushOneCommit.Result r = createChange();
    String changeId = r.getChangeId();
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = createGroup("cc1");
    in.state = CC;
    gApi.groups().id(in.reviewer).addMembers(firstUsernames.toArray(new String[firstUsernames.size()]));
    AddReviewerResult result = addReviewer(changeId, in);
    assertThat(result.reviewer).isEqualTo(in.reviewer);
    assertThat(result.confirm).isNull();
    assertThat(result.error).isNull();
    if (notesMigration.readChanges()) {
        assertThat(result.reviewers).isNull();
    } else {
        assertThat(result.ccs).isNull();
    }
    ChangeInfo c = gApi.changes().id(r.getChangeId()).get();
    assertReviewers(c, CC, firstUsers);
    // Verify emails were sent to each of the group's accounts.
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message m = messages.get(0);
    List<Address> expectedAddresses = new ArrayList<>(firstUsers.size());
    for (TestAccount u : firstUsers) {
        expectedAddresses.add(u.emailAddress);
    }
    assertThat(m.rcpt()).containsExactlyElementsIn(expectedAddresses);
    // CC a group that overlaps with some existing reviewers and CCed accounts.
    TestAccount reviewer = accounts.create(name("reviewer"), "addCcGroup-reviewer@example.com", "Reviewer");
    result = addReviewer(changeId, reviewer.username);
    assertThat(result.error).isNull();
    sender.clear();
    in.reviewer = createGroup("cc2");
    gApi.groups().id(in.reviewer).addMembers(usernames.toArray(new String[usernames.size()]));
    gApi.groups().id(in.reviewer).addMembers(reviewer.username);
    result = addReviewer(changeId, in);
    assertThat(result.reviewer).isEqualTo(in.reviewer);
    assertThat(result.confirm).isNull();
    assertThat(result.error).isNull();
    c = gApi.changes().id(r.getChangeId()).get();
    if (notesMigration.readChanges()) {
        assertThat(result.ccs).hasSize(3);
        assertThat(result.reviewers).isNull();
        assertReviewers(c, REVIEWER, reviewer);
        assertReviewers(c, CC, users);
    } else {
        assertThat(result.ccs).isNull();
        assertThat(result.reviewers).hasSize(3);
        List<TestAccount> expectedUsers = new ArrayList<>(users.size() + 2);
        expectedUsers.addAll(users);
        expectedUsers.add(reviewer);
        assertReviewers(c, CC, expectedUsers);
    }
    messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    m = messages.get(0);
    expectedAddresses = new ArrayList<>(4);
    for (int i = 0; i < 3; i++) {
        expectedAddresses.add(users.get(users.size() - i - 1).emailAddress);
    }
    if (notesMigration.readChanges()) {
        expectedAddresses.add(reviewer.emailAddress);
    }
    assertThat(m.rcpt()).containsExactlyElementsIn(expectedAddresses);
}
#method_after
@Test
public void addCcGroup() throws Exception {
    List<TestAccount> users = createAccounts(6, "addCcGroup");
    List<String> usernames = new ArrayList<>(6);
    for (TestAccount u : users) {
        usernames.add(u.username);
    }
    List<TestAccount> firstUsers = users.subList(0, 3);
    List<String> firstUsernames = usernames.subList(0, 3);
    PushOneCommit.Result r = createChange();
    String changeId = r.getChangeId();
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = createGroup("cc1");
    in.state = CC;
    gApi.groups().id(in.reviewer).addMembers(firstUsernames.toArray(new String[firstUsernames.size()]));
    AddReviewerResult result = addReviewer(changeId, in);
    assertThat(result.input).isEqualTo(in.reviewer);
    assertThat(result.confirm).isNull();
    assertThat(result.error).isNull();
    if (notesMigration.readChanges()) {
        assertThat(result.reviewers).isNull();
    } else {
        assertThat(result.ccs).isNull();
    }
    ChangeInfo c = gApi.changes().id(r.getChangeId()).get();
    assertReviewers(c, CC, firstUsers);
    // Verify emails were sent to each of the group's accounts.
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message m = messages.get(0);
    List<Address> expectedAddresses = new ArrayList<>(firstUsers.size());
    for (TestAccount u : firstUsers) {
        expectedAddresses.add(u.emailAddress);
    }
    assertThat(m.rcpt()).containsExactlyElementsIn(expectedAddresses);
    // CC a group that overlaps with some existing reviewers and CCed accounts.
    TestAccount reviewer = accounts.create(name("reviewer"), "addCcGroup-reviewer@example.com", "Reviewer");
    result = addReviewer(changeId, reviewer.username);
    assertThat(result.error).isNull();
    sender.clear();
    in.reviewer = createGroup("cc2");
    gApi.groups().id(in.reviewer).addMembers(usernames.toArray(new String[usernames.size()]));
    gApi.groups().id(in.reviewer).addMembers(reviewer.username);
    result = addReviewer(changeId, in);
    assertThat(result.input).isEqualTo(in.reviewer);
    assertThat(result.confirm).isNull();
    assertThat(result.error).isNull();
    c = gApi.changes().id(r.getChangeId()).get();
    if (notesMigration.readChanges()) {
        assertThat(result.ccs).hasSize(3);
        assertThat(result.reviewers).isNull();
        assertReviewers(c, REVIEWER, reviewer);
        assertReviewers(c, CC, users);
    } else {
        assertThat(result.ccs).isNull();
        assertThat(result.reviewers).hasSize(3);
        List<TestAccount> expectedUsers = new ArrayList<>(users.size() + 2);
        expectedUsers.addAll(users);
        expectedUsers.add(reviewer);
        assertReviewers(c, CC, expectedUsers);
    }
    messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    m = messages.get(0);
    expectedAddresses = new ArrayList<>(4);
    for (int i = 0; i < 3; i++) {
        expectedAddresses.add(users.get(users.size() - i - 1).emailAddress);
    }
    if (notesMigration.readChanges()) {
        expectedAddresses.add(reviewer.emailAddress);
    }
    assertThat(m.rcpt()).containsExactlyElementsIn(expectedAddresses);
}
#end_block

#method_before
@Test
public void reviewAndAddReviewers() throws Exception {
    TestTimeUtil.resetWithClockStep(1, SECONDS);
    sender.clear();
    TestAccount observer = accounts.user2();
    PushOneCommit.Result r = createChange();
    ReviewInput input = ReviewInput.approve().reviewer(user.email).reviewer(observer.email, CC, false);
    ReviewResult result = review(r.getChangeId(), r.getCommit().name(), input);
    assertThat(result.labels).isNotNull();
    assertThat(result.reviewers).isNotNull();
    assertThat(result.reviewers).hasSize(2);
    // Verify reviewer and CC were added. If not in NoteDb read mode, both
    // parties will be returned as CCed.
    ChangeInfo c = gApi.changes().id(r.getChangeId()).get();
    if (notesMigration.readChanges()) {
        assertReviewers(c, REVIEWER, admin, user);
        assertReviewers(c, CC, observer);
    } else {
        // In legacy mode, change owner should be the only reviewer.
        assertReviewers(c, REVIEWER, admin);
        assertReviewers(c, CC, user, observer);
    }
    // Verify emails were sent to added reviewers.
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(3);
    // First email to user.
    Message m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(user.emailAddress);
    assertThat(m.body()).contains("Hello " + user.fullName + ",\n");
    assertThat(m.body()).contains("I'd like you to do a code review.");
    assertThat(m.body()).contains("Change subject: " + PushOneCommit.SUBJECT + "\n");
    // Second email to reviewer and observer.
    m = messages.get(1);
    if (notesMigration.readChanges()) {
        assertThat(m.rcpt()).containsExactly(user.emailAddress, observer.emailAddress);
        assertThat(m.body()).contains(admin.fullName + " has uploaded a new change for review.");
    } else {
        assertThat(m.rcpt()).containsExactly(observer.emailAddress);
        assertThat(m.body()).contains("Hello " + observer.fullName + ",\n");
        assertThat(m.body()).contains("I'd like you to do a code review.");
    }
    // Third email is review to user and observer.
    m = messages.get(2);
    assertThat(m.rcpt()).containsExactly(user.emailAddress, observer.emailAddress);
    assertThat(m.body()).contains(admin.fullName + " has posted comments on this change.");
    assertThat(m.body()).contains("Change subject: " + PushOneCommit.SUBJECT + "\n");
    assertThat(m.body()).contains("Patch Set 1: Code-Review+2\n");
}
#method_after
@Test
public void reviewAndAddReviewers() throws Exception {
    TestAccount observer = accounts.user2();
    PushOneCommit.Result r = createChange();
    ReviewInput input = ReviewInput.approve().reviewer(user.email).reviewer(observer.email, CC, false);
    ReviewResult result = review(r.getChangeId(), r.getCommit().name(), input);
    assertThat(result.labels).isNotNull();
    assertThat(result.reviewers).isNotNull();
    assertThat(result.reviewers).hasSize(2);
    // Verify reviewer and CC were added. If not in NoteDb read mode, both
    // parties will be returned as CCed.
    ChangeInfo c = gApi.changes().id(r.getChangeId()).get();
    if (notesMigration.readChanges()) {
        assertReviewers(c, REVIEWER, admin, user);
        assertReviewers(c, CC, observer);
    } else {
        // In legacy mode, change owner should be the only reviewer.
        assertReviewers(c, REVIEWER, admin);
        assertReviewers(c, CC, user, observer);
    }
    // Verify emails were sent to added reviewers.
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(3);
    // First email to user.
    Message m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(user.emailAddress);
    assertThat(m.body()).contains("Hello " + user.fullName + ",\n");
    assertThat(m.body()).contains("I'd like you to do a code review.");
    assertThat(m.body()).contains("Change subject: " + PushOneCommit.SUBJECT + "\n");
    // Second email to reviewer and observer.
    m = messages.get(1);
    if (notesMigration.readChanges()) {
        assertThat(m.rcpt()).containsExactly(user.emailAddress, observer.emailAddress);
        assertThat(m.body()).contains(admin.fullName + " has uploaded a new change for review.");
    } else {
        assertThat(m.rcpt()).containsExactly(observer.emailAddress);
        assertThat(m.body()).contains("Hello " + observer.fullName + ",\n");
        assertThat(m.body()).contains("I'd like you to do a code review.");
    }
    // Third email is review to user and observer.
    m = messages.get(2);
    assertThat(m.rcpt()).containsExactly(user.emailAddress, observer.emailAddress);
    assertThat(m.body()).contains(admin.fullName + " has posted comments on this change.");
    assertThat(m.body()).contains("Change subject: " + PushOneCommit.SUBJECT + "\n");
    assertThat(m.body()).contains("Patch Set 1: Code-Review+2\n");
}
#end_block

#method_before
private static void assertReviewers(ChangeInfo c, ReviewerState reviewerState, Iterable<TestAccount> accounts) throws Exception {
    Collection<AccountInfo> actualAccounts = c.reviewers.get(reviewerState);
    assertThat(actualAccounts).isNotNull();
    List<Integer> actualAccountIds = new ArrayList<>(actualAccounts.size());
    for (AccountInfo account : actualAccounts) {
        actualAccountIds.add(account._accountId);
    }
    List<Integer> expectedAccountIds = new ArrayList<>();
    for (TestAccount account : accounts) {
        expectedAccountIds.add(account.getId().get());
    }
    assertThat(actualAccountIds).containsExactlyElementsIn(expectedAccountIds);
}
#method_after
private static void assertReviewers(ChangeInfo c, ReviewerState reviewerState, Iterable<TestAccount> accounts) throws Exception {
    Collection<AccountInfo> actualAccounts = c.reviewers.get(reviewerState);
    if (actualAccounts == null) {
        assertThat(accounts.iterator().hasNext()).isFalse();
        return;
    }
    assertThat(actualAccounts).isNotNull();
    List<Integer> actualAccountIds = new ArrayList<>(actualAccounts.size());
    for (AccountInfo account : actualAccounts) {
        actualAccountIds.add(account._accountId);
    }
    List<Integer> expectedAccountIds = new ArrayList<>();
    for (TestAccount account : accounts) {
        expectedAccountIds.add(account.getId().get());
    }
    assertThat(actualAccountIds).containsExactlyElementsIn(expectedAccountIds);
}
#end_block

#method_before
@Override
public AddReviewerResult apply(ChangeResource rsrc, AddReviewerInput input) throws IOException, OrmException, RestApiException, UpdateException {
    if (input.reviewer == null) {
        throw new BadRequestException("missing reviewer field");
    }
    Addition addition = prepareApplication(rsrc, input);
    addition.apply(rsrc);
    return addition.result;
}
#method_after
@Override
public AddReviewerResult apply(ChangeResource rsrc, AddReviewerInput input) throws IOException, OrmException, RestApiException, UpdateException {
    if (input.reviewer == null) {
        throw new BadRequestException("missing reviewer field");
    }
    Addition addition = prepareApplication(rsrc, input);
    if (addition.op == null) {
        return addition.result;
    }
    try (BatchUpdate bu = batchUpdateFactory.create(dbProvider.get(), rsrc.getProject(), rsrc.getUser(), TimeUtil.nowTs())) {
        Change.Id id = rsrc.getChange().getId();
        bu.addOp(id, addition.op);
        bu.execute();
        addition.gatherResults();
    }
    return addition.result;
}
#end_block

#method_before
public Addition prepareApplication(ChangeResource rsrc, AddReviewerInput input) throws OrmException, RestApiException {
    try {
        Account.Id accountId = accounts.parse(input.reviewer).getAccountId();
        return putAccount(input.reviewer, reviewerFactory.create(rsrc, accountId), input.state());
    } catch (UnprocessableEntityException e) {
        try {
            return putGroup(rsrc, input);
        } catch (UnprocessableEntityException e2) {
            throw new UnprocessableEntityException(MessageFormat.format(ChangeMessages.get().reviewerNotFound, input.reviewer));
        }
    }
}
#method_after
public Addition prepareApplication(ChangeResource rsrc, AddReviewerInput input) throws OrmException, RestApiException, IOException {
    try {
        Account.Id accountId = accounts.parse(input.reviewer).getAccountId();
        return putAccount(input.reviewer, reviewerFactory.create(rsrc, accountId), input.state());
    } catch (UnprocessableEntityException e) {
        try {
            return putGroup(rsrc, input);
        } catch (UnprocessableEntityException e2) {
            throw new UnprocessableEntityException(MessageFormat.format(ChangeMessages.get().reviewerNotFound, input.reviewer));
        }
    }
}
#end_block

#method_before
private Addition putGroup(ChangeResource rsrc, AddReviewerInput input) throws RestApiException, OrmException {
    GroupDescription.Basic group = groupsCollection.parseInternal(input.reviewer);
    if (!isLegalReviewerGroup(group.getGroupUUID())) {
        return fail(input.reviewer, MessageFormat.format(ChangeMessages.get().groupIsNotAllowed, group.getName()));
    }
    Map<Account.Id, ChangeControl> reviewers = new HashMap<>();
    ChangeControl control = rsrc.getControl();
    Set<Account> members;
    try {
        members = groupMembersFactory.create(control.getUser()).listAccounts(group.getGroupUUID(), control.getProject().getNameKey());
    } catch (NoSuchGroupException e) {
        throw new UnprocessableEntityException(e.getMessage());
    } catch (NoSuchProjectException e) {
        throw new BadRequestException(e.getMessage());
    } catch (IOException e) {
        // TODO(logan): return error to client
        throw new UnprocessableEntityException(e.getMessage());
    }
    // if maxAllowed is set to 0, it is allowed to add any number of
    // reviewers
    int maxAllowed = cfg.getInt("addreviewer", "maxAllowed", DEFAULT_MAX_REVIEWERS);
    if (maxAllowed > 0 && members.size() > maxAllowed) {
        return fail(input.reviewer, MessageFormat.format(ChangeMessages.get().groupHasTooManyMembers, group.getName()));
    }
    // if maxWithoutCheck is set to 0, we never ask for confirmation
    int maxWithoutConfirmation = cfg.getInt("addreviewer", "maxWithoutConfirmation", DEFAULT_MAX_REVIEWERS_WITHOUT_CHECK);
    if (!input.confirmed() && maxWithoutConfirmation > 0 && members.size() > maxWithoutConfirmation) {
        return fail(input.reviewer, true, MessageFormat.format(ChangeMessages.get().groupManyMembersConfirmation, group.getName(), members.size()));
    }
    for (Account member : members) {
        if (isValidReviewer(member, control)) {
            reviewers.put(member.getId(), control);
        }
    }
    return new Addition(input.reviewer, rsrc, reviewers, input.state());
}
#method_after
private Addition putGroup(ChangeResource rsrc, AddReviewerInput input) throws RestApiException, OrmException, IOException {
    GroupDescription.Basic group = groupsCollection.parseInternal(input.reviewer);
    if (!isLegalReviewerGroup(group.getGroupUUID())) {
        return fail(input.reviewer, MessageFormat.format(ChangeMessages.get().groupIsNotAllowed, group.getName()));
    }
    Map<Account.Id, ChangeControl> reviewers = new HashMap<>();
    ChangeControl control = rsrc.getControl();
    Set<Account> members;
    try {
        members = groupMembersFactory.create(control.getUser()).listAccounts(group.getGroupUUID(), control.getProject().getNameKey());
    } catch (NoSuchGroupException e) {
        throw new UnprocessableEntityException(e.getMessage());
    } catch (NoSuchProjectException e) {
        throw new BadRequestException(e.getMessage());
    }
    // if maxAllowed is set to 0, it is allowed to add any number of
    // reviewers
    int maxAllowed = cfg.getInt("addreviewer", "maxAllowed", DEFAULT_MAX_REVIEWERS);
    if (maxAllowed > 0 && members.size() > maxAllowed) {
        return fail(input.reviewer, MessageFormat.format(ChangeMessages.get().groupHasTooManyMembers, group.getName()));
    }
    // if maxWithoutCheck is set to 0, we never ask for confirmation
    int maxWithoutConfirmation = cfg.getInt("addreviewer", "maxWithoutConfirmation", DEFAULT_MAX_REVIEWERS_WITHOUT_CHECK);
    if (!input.confirmed() && maxWithoutConfirmation > 0 && members.size() > maxWithoutConfirmation) {
        return fail(input.reviewer, true, MessageFormat.format(ChangeMessages.get().groupManyMembersConfirmation, group.getName(), members.size()));
    }
    for (Account member : members) {
        if (isValidReviewer(member, control)) {
            reviewers.put(member.getId(), control);
        }
    }
    return new Addition(input.reviewer, rsrc, reviewers, input.state());
}
#end_block

#method_before
@Override
public void postUpdate(Context ctx) throws Exception {
    if (addedCCs != null) {
        emailCCs(rsrc.getChange(), addedCCs);
    }
    if (addedReviewers != null) {
        emailReviewers(rsrc.getChange(), addedReviewers);
        if (!addedReviewers.isEmpty()) {
            for (PatchSetApproval psa : addedReviewers) {
                Account account = accountCache.get(psa.getAccountId()).getAccount();
                reviewerAdded.fire(rsrc.getChange(), patchSet, account);
            }
        }
    }
}
#method_after
@Override
public void postUpdate(Context ctx) throws Exception {
    if (addedReviewers != null || addedCCs != null) {
        if (addedReviewers == null) {
            addedReviewers = new ArrayList<>();
        }
        if (addedCCs == null) {
            addedCCs = new ArrayList<>();
        }
        emailReviewers(rsrc.getChange(), addedReviewers, addedCCs);
        if (!addedReviewers.isEmpty()) {
            for (PatchSetApproval psa : addedReviewers) {
                Account account = accountCache.get(psa.getAccountId()).getAccount();
                reviewerAdded.fire(rsrc.getChange(), patchSet, account, ctx.getAccount(), ctx.getWhen());
            }
        }
    }
}
#end_block

#method_before
private void emailReviewers(Change change, List<PatchSetApproval> added) {
    if (added.isEmpty()) {
        return;
    }
    // Email the reviewers
    // 
    // The user knows they added themselves, don't bother emailing them.
    List<Account.Id> toMail = Lists.newArrayListWithCapacity(added.size());
    Account.Id userId = user.get().getAccountId();
    for (PatchSetApproval psa : added) {
        if (!psa.getAccountId().equals(userId)) {
            toMail.add(psa.getAccountId());
        }
    }
    if (!toMail.isEmpty()) {
        try {
            AddReviewerSender cm = addReviewerSenderFactory.create(change.getProject(), change.getId());
            cm.setFrom(userId);
            cm.addReviewers(toMail);
            cm.send();
        } catch (Exception err) {
            log.error("Cannot send email to new reviewers of change " + change.getId(), err);
        }
    }
}
#method_after
private void emailReviewers(Change change, List<PatchSetApproval> added, Collection<Account.Id> copied) {
    if (added.isEmpty() && copied.isEmpty()) {
        return;
    }
    // Email the reviewers
    // 
    // The user knows they added themselves, don't bother emailing them.
    List<Account.Id> toMail = Lists.newArrayListWithCapacity(added.size());
    Account.Id userId = user.get().getAccountId();
    for (PatchSetApproval psa : added) {
        if (!psa.getAccountId().equals(userId)) {
            toMail.add(psa.getAccountId());
        }
    }
    List<Account.Id> toCopy = Lists.newArrayListWithCapacity(copied.size());
    for (Account.Id id : copied) {
        if (!id.equals(userId)) {
            toCopy.add(id);
        }
    }
    if (toMail.isEmpty() && toCopy.isEmpty()) {
        return;
    }
    try {
        AddReviewerSender cm = addReviewerSenderFactory.create(change.getProject(), change.getId());
        cm.setFrom(userId);
        cm.addReviewers(toMail);
        cm.addExtraCC(toCopy);
        cm.send();
    } catch (Exception err) {
        log.error("Cannot send email to new reviewers of change " + change.getId(), err);
    }
}
#end_block

#method_before
@Override
public ReviewResult apply(RevisionResource revision, ReviewInput input) throws RestApiException, UpdateException, OrmException {
    return apply(revision, input, TimeUtil.nowTs());
}
#method_after
@Override
public ReviewResult apply(RevisionResource revision, ReviewInput input) throws RestApiException, UpdateException, OrmException, IOException {
    return apply(revision, input, TimeUtil.nowTs());
}
#end_block

#method_before
public ReviewResult apply(RevisionResource revision, ReviewInput input, Timestamp ts) throws RestApiException, UpdateException, OrmException {
    // Respect timestamp, but truncate at change created-on time.
    ts = Ordering.natural().max(ts, revision.getChange().getCreatedOn());
    if (revision.getEdit().isPresent()) {
        throw new ResourceConflictException("cannot post review on edit");
    }
    if (input.onBehalfOf != null) {
        revision = onBehalfOf(revision, input);
    }
    if (input.labels != null) {
        checkLabels(revision, input.strictLabels, input.labels);
    }
    if (input.comments != null) {
        checkComments(revision, input.comments);
    }
    if (input.notify == null) {
        log.warn("notify = null; assuming notify = NONE");
        input.notify = NotifyHandling.NONE;
    }
    Map<String, AddReviewerResult> reviewerJsonResults = null;
    List<PostReviewers.Addition> reviewerResults = Lists.newArrayList();
    boolean hasError = false;
    boolean confirm = false;
    if (input.reviewers != null) {
        reviewerJsonResults = Maps.newHashMap();
        for (AddReviewerInput reviewerInput : input.reviewers) {
            PostReviewers.Addition result = postReviewers.prepareApplication(revision.getChangeResource(), reviewerInput);
            reviewerJsonResults.put(reviewerInput.reviewer, result.result);
            if (result.result.error != null) {
                hasError = true;
                continue;
            }
            if (result.result.confirm != null) {
                confirm = true;
                continue;
            }
            reviewerResults.add(result);
        // TODO(logan): return new PatchSetApprovals
        }
    }
    ReviewResult output = new ReviewResult();
    output.reviewers = reviewerJsonResults;
    if (hasError || confirm) {
        return output;
    }
    output.labels = input.labels;
    try (BatchUpdate bu = batchUpdateFactory.create(db.get(), revision.getChange().getProject(), revision.getUser(), ts)) {
        // updated set of reviewers.
        for (PostReviewers.Addition reviewerResult : reviewerResults) {
            bu.addOp(revision.getChange().getId(), reviewerResult.op);
        }
        bu.addOp(revision.getChange().getId(), new Op(revision.getPatchSet().getId(), input));
        bu.execute();
        for (PostReviewers.Addition reviewerResult : reviewerResults) {
            // Generate result details and fill AccountLoader. This occurs outside
            // the Op because the accounts are in a different table.
            PostReviewers.Op op = reviewerResult.op;
            if (migration.readChanges() && op.state == ReviewerState.CC) {
                reviewerResult.result.ccs = Lists.newArrayListWithCapacity(op.addedCCs.size());
                for (Account.Id accountId : op.addedCCs) {
                    reviewerResult.result.ccs.add(reviewerJson.format(new ReviewerInfo(accountId.get()), op.reviewers.get(accountId)));
                }
                accountLoaderFactory.create(true).fill(reviewerResult.result.ccs);
            } else {
                reviewerResult.result.reviewers = Lists.newArrayListWithCapacity(op.addedReviewers.size());
                for (PatchSetApproval psa : op.addedReviewers) {
                    // New reviewers have value 0, don't bother normalizing.
                    reviewerResult.result.reviewers.add(reviewerJson.format(new ReviewerInfo(psa.getAccountId().get()), op.reviewers.get(psa.getAccountId()), ImmutableList.of(psa)));
                }
                accountLoaderFactory.create(true).fill(reviewerResult.result.reviewers);
            }
        }
    }
    return output;
}
#method_after
public ReviewResult apply(RevisionResource revision, ReviewInput input, Timestamp ts) throws RestApiException, UpdateException, OrmException, IOException {
    // Respect timestamp, but truncate at change created-on time.
    ts = Ordering.natural().max(ts, revision.getChange().getCreatedOn());
    if (revision.getEdit().isPresent()) {
        throw new ResourceConflictException("cannot post review on edit");
    }
    if (input.onBehalfOf != null) {
        revision = onBehalfOf(revision, input);
    }
    if (input.labels != null) {
        checkLabels(revision, input.strictLabels, input.labels);
    }
    if (input.comments != null) {
        checkComments(revision, input.comments);
    }
    if (input.notify == null) {
        log.warn("notify = null; assuming notify = NONE");
        input.notify = NotifyHandling.NONE;
    }
    Map<String, AddReviewerResult> reviewerJsonResults = null;
    List<PostReviewers.Addition> reviewerResults = Lists.newArrayList();
    boolean hasError = false;
    boolean confirm = false;
    if (input.reviewers != null) {
        reviewerJsonResults = Maps.newHashMap();
        for (AddReviewerInput reviewerInput : input.reviewers) {
            PostReviewers.Addition result = postReviewers.prepareApplication(revision.getChangeResource(), reviewerInput);
            reviewerJsonResults.put(reviewerInput.reviewer, result.result);
            if (result.result.error != null) {
                hasError = true;
                continue;
            }
            if (result.result.confirm != null) {
                confirm = true;
                continue;
            }
            reviewerResults.add(result);
        }
    }
    ReviewResult output = new ReviewResult();
    output.reviewers = reviewerJsonResults;
    if (hasError || confirm) {
        return output;
    }
    output.labels = input.labels;
    try (BatchUpdate bu = batchUpdateFactory.create(db.get(), revision.getChange().getProject(), revision.getUser(), ts)) {
        // updated set of reviewers.
        for (PostReviewers.Addition reviewerResult : reviewerResults) {
            bu.addOp(revision.getChange().getId(), reviewerResult.op);
        }
        bu.addOp(revision.getChange().getId(), new Op(revision.getPatchSet().getId(), input));
        bu.execute();
        for (PostReviewers.Addition reviewerResult : reviewerResults) {
            reviewerResult.gatherResults();
        }
    }
    return output;
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, ResourceConflictException {
    user = ctx.getUser().asIdentifiedUser();
    notes = ctx.getNotes();
    ps = psUtil.get(ctx.getDb(), ctx.getNotes(), psId);
    boolean dirty = false;
    dirty |= insertComments(ctx);
    dirty |= updateLabels(ctx);
    dirty |= insertMessage(ctx);
    return dirty;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, ResourceConflictException {
    user = ctx.getIdentifiedUser();
    notes = ctx.getNotes();
    ps = psUtil.get(ctx.getDb(), ctx.getNotes(), psId);
    boolean dirty = false;
    dirty |= insertComments(ctx);
    dirty |= updateLabels(ctx);
    dirty |= insertMessage(ctx);
    return dirty;
}
#end_block

#method_before
@Test
public void addGroupAsReviewer() throws Exception {
    // Set up two groups, one that is too large too add as reviewer, and one
    // that is too large to add without confirmation.
    String largeGroup = createGroup("largeGroup");
    String mediumGroup = createGroup("mediumGroup");
    TestAccount[] users = new TestAccount[PostReviewers.DEFAULT_MAX_REVIEWERS + 1];
    String[] largeGroupUsernames = new String[PostReviewers.DEFAULT_MAX_REVIEWERS + 1];
    String[] mediumGroupUsernames = new String[PostReviewers.DEFAULT_MAX_REVIEWERS_WITHOUT_CHECK + 1];
    for (int i = 0; i < users.length; i++) {
        users[i] = accounts.create("u" + i, "u" + i + "@example.com", "Full Name " + i);
        largeGroupUsernames[i] = users[i].username;
        if (i < mediumGroupUsernames.length) {
            mediumGroupUsernames[i] = users[i].username;
        }
    }
    gApi.groups().id(largeGroup).addMembers(largeGroupUsernames);
    gApi.groups().id(mediumGroup).addMembers(mediumGroupUsernames);
    // Attempt to add overly large group as reviewers.
    PushOneCommit.Result r = createChange();
    String changeId = r.getChangeId();
    AddReviewerResult result = addReviewer(changeId, largeGroup);
    assertThat(result.reviewer).isEqualTo(largeGroup);
    assertThat(result.confirm).isNull();
    assertThat(result.error).contains("has too many members to add them all as reviewers");
    assertThat(result.reviewers).isNull();
    // Attempt to add medium group without confirmation.
    result = addReviewer(changeId, mediumGroup);
    assertThat(result.reviewer).isEqualTo(mediumGroup);
    assertThat(result.confirm).isTrue();
    assertThat(result.error).contains("has " + mediumGroupUsernames.length + " members. Do you want to add them all" + " as reviewers?");
    assertThat(result.reviewers).isNull();
    // Add medium group with confirmation.
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = mediumGroup;
    in.confirmed = true;
    result = addReviewer(changeId, in);
    assertThat(result.reviewer).isEqualTo(mediumGroup);
    assertThat(result.confirm).isNull();
    assertThat(result.error).isNull();
    assertThat(result.reviewers).hasSize(mediumGroupUsernames.length);
    // Verify that group members were added as reviewers.
    ChangeInfo c = gApi.changes().id(r.getChangeId()).get();
    assertReviewers(c, NoteDbMode.readWrite() ? REVIEWER : CC, Arrays.copyOf(users, mediumGroupUsernames.length));
}
#method_after
@Test
public void addGroupAsReviewer() throws Exception {
    // Set up two groups, one that is too large too add as reviewer, and one
    // that is too large to add without confirmation.
    String largeGroup = createGroup("largeGroup");
    String mediumGroup = createGroup("mediumGroup");
    int largeGroupSize = PostReviewers.DEFAULT_MAX_REVIEWERS + 1;
    int mediumGroupSize = PostReviewers.DEFAULT_MAX_REVIEWERS_WITHOUT_CHECK + 1;
    List<TestAccount> users = createAccounts(largeGroupSize, "addGroupAsReviewer");
    List<String> largeGroupUsernames = new ArrayList<>(mediumGroupSize);
    for (TestAccount u : users) {
        largeGroupUsernames.add(u.username);
    }
    List<String> mediumGroupUsernames = largeGroupUsernames.subList(0, mediumGroupSize);
    gApi.groups().id(largeGroup).addMembers(largeGroupUsernames.toArray(new String[largeGroupSize]));
    gApi.groups().id(mediumGroup).addMembers(mediumGroupUsernames.toArray(new String[mediumGroupSize]));
    // Attempt to add overly large group as reviewers.
    PushOneCommit.Result r = createChange();
    String changeId = r.getChangeId();
    AddReviewerResult result = addReviewer(changeId, largeGroup);
    assertThat(result.input).isEqualTo(largeGroup);
    assertThat(result.confirm).isNull();
    assertThat(result.error).contains("has too many members to add them all as reviewers");
    assertThat(result.reviewers).isNull();
    // Attempt to add medium group without confirmation.
    result = addReviewer(changeId, mediumGroup);
    assertThat(result.input).isEqualTo(mediumGroup);
    assertThat(result.confirm).isTrue();
    assertThat(result.error).contains("has " + mediumGroupSize + " members. Do you want to add them" + " all as reviewers?");
    assertThat(result.reviewers).isNull();
    // Add medium group with confirmation.
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = mediumGroup;
    in.confirmed = true;
    result = addReviewer(changeId, in);
    assertThat(result.input).isEqualTo(mediumGroup);
    assertThat(result.confirm).isNull();
    assertThat(result.error).isNull();
    assertThat(result.reviewers).hasSize(mediumGroupSize);
    // Verify that group members were added as reviewers.
    ChangeInfo c = gApi.changes().id(r.getChangeId()).get();
    assertReviewers(c, notesMigration.readChanges() ? REVIEWER : CC, users.subList(0, mediumGroupSize));
}
#end_block

#method_before
AddReviewerResult addReviewer(String changeId, String reviewer) throws Exception {
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = reviewer;
    return addReviewer(changeId, in);
}
#method_after
private AddReviewerResult addReviewer(String changeId, String reviewer) throws Exception {
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = reviewer;
    return addReviewer(changeId, in);
}
#end_block

#method_before
AddReviewerResult addReviewer(String changeId, AddReviewerInput in) throws Exception {
    RestResponse resp = adminRestSession.post("/changes/" + changeId + "/reviewers", in);
    return readContentFromJson(resp, AddReviewerResult.class);
}
#method_after
private AddReviewerResult addReviewer(String changeId, AddReviewerInput in) throws Exception {
    RestResponse resp = adminRestSession.post("/changes/" + changeId + "/reviewers", in);
    return readContentFromJson(resp, AddReviewerResult.class);
}
#end_block

#method_before
private static void assertReviewers(ChangeInfo c, ReviewerState reviewerState, TestAccount... accounts) throws Exception {
    Collection<AccountInfo> actualAccounts = c.reviewers.get(reviewerState);
    assertThat(actualAccounts).isNotNull();
    List<Integer> actualAccountIds = Lists.newArrayListWithCapacity(actualAccounts.size());
    for (AccountInfo account : actualAccounts) {
        actualAccountIds.add(account._accountId);
    }
    List<Integer> expectedAccountIds = Lists.newArrayListWithCapacity(accounts.length);
    for (TestAccount account : accounts) {
        expectedAccountIds.add(account.getId().get());
    }
    assertThat(actualAccountIds).containsExactlyElementsIn(expectedAccountIds);
}
#method_after
private static void assertReviewers(ChangeInfo c, ReviewerState reviewerState, TestAccount... accounts) throws Exception {
    List<TestAccount> accountList = new ArrayList<>(accounts.length);
    for (TestAccount a : accounts) {
        accountList.add(a);
    }
    assertReviewers(c, reviewerState, accountList);
}
#end_block

#method_before
private static void assertReviewers(ChangeInfo c, ReviewerState reviewerState, TestAccount... accounts) throws Exception {
    Collection<AccountInfo> actualAccounts = c.reviewers.get(reviewerState);
    assertThat(actualAccounts).isNotNull();
    List<Integer> actualAccountIds = Lists.newArrayListWithCapacity(actualAccounts.size());
    for (AccountInfo account : actualAccounts) {
        actualAccountIds.add(account._accountId);
    }
    List<Integer> expectedAccountIds = Lists.newArrayListWithCapacity(accounts.length);
    for (TestAccount account : accounts) {
        expectedAccountIds.add(account.getId().get());
    }
    assertThat(actualAccountIds).containsExactlyElementsIn(expectedAccountIds);
}
#method_after
private static void assertReviewers(ChangeInfo c, ReviewerState reviewerState, Iterable<TestAccount> accounts) throws Exception {
    Collection<AccountInfo> actualAccounts = c.reviewers.get(reviewerState);
    if (actualAccounts == null) {
        assertThat(accounts.iterator().hasNext()).isFalse();
        return;
    }
    assertThat(actualAccounts).isNotNull();
    List<Integer> actualAccountIds = new ArrayList<>(actualAccounts.size());
    for (AccountInfo account : actualAccounts) {
        actualAccountIds.add(account._accountId);
    }
    List<Integer> expectedAccountIds = new ArrayList<>();
    for (TestAccount account : accounts) {
        expectedAccountIds.add(account.getId().get());
    }
    assertThat(actualAccountIds).containsExactlyElementsIn(expectedAccountIds);
}
#end_block

#method_before
@Override
public AddReviewerResult apply(ChangeResource rsrc, AddReviewerInput input) throws UpdateException, OrmException, RestApiException, IOException {
    if (input.reviewer == null) {
        throw new BadRequestException("missing reviewer field");
    }
    try {
        Account.Id accountId = accounts.parse(input.reviewer).getAccountId();
        return putAccount(input.reviewer, reviewerFactory.create(rsrc, accountId), input.cc());
    } catch (UnprocessableEntityException e) {
        try {
            return putGroup(rsrc, input);
        } catch (UnprocessableEntityException e2) {
            throw new UnprocessableEntityException(MessageFormat.format(ChangeMessages.get().reviewerNotFound, input.reviewer));
        }
    }
}
#method_after
@Override
public AddReviewerResult apply(ChangeResource rsrc, AddReviewerInput input) throws UpdateException, OrmException, RestApiException, IOException {
    if (input.reviewer == null) {
        throw new BadRequestException("missing reviewer field");
    }
    try {
        Account.Id accountId = accounts.parse(input.reviewer).getAccountId();
        return putAccount(input.reviewer, reviewerFactory.create(rsrc, accountId), input.state());
    } catch (UnprocessableEntityException e) {
        try {
            return putGroup(rsrc, input);
        } catch (UnprocessableEntityException e2) {
            throw new UnprocessableEntityException(MessageFormat.format(ChangeMessages.get().reviewerNotFound, input.reviewer));
        }
    }
}
#end_block

#method_before
private AddReviewerResult putAccount(String reviewer, ReviewerResource rsrc, boolean cc) throws OrmException, UpdateException, RestApiException {
    Account member = rsrc.getReviewerUser().getAccount();
    ChangeControl control = rsrc.getReviewerControl();
    AddReviewerResult result = new AddReviewerResult(reviewer);
    if (isValidReviewer(member, control)) {
        addReviewers(rsrc.getChangeResource(), result, ImmutableMap.of(member.getId(), control), cc);
    }
    return result;
}
#method_after
private AddReviewerResult putAccount(String reviewer, ReviewerResource rsrc, ReviewerState state) throws OrmException, UpdateException, RestApiException {
    Account member = rsrc.getReviewerUser().getAccount();
    ChangeControl control = rsrc.getReviewerControl();
    AddReviewerResult result = new AddReviewerResult(reviewer);
    if (isValidReviewer(member, control)) {
        addReviewers(rsrc.getChangeResource(), result, ImmutableMap.of(member.getId(), control), state);
    }
    return result;
}
#end_block

#method_before
private AddReviewerResult putGroup(ChangeResource rsrc, AddReviewerInput input) throws UpdateException, RestApiException, OrmException, IOException {
    GroupDescription.Basic group = groupsCollection.parseInternal(input.reviewer);
    AddReviewerResult result = new AddReviewerResult(input.reviewer);
    if (!isLegalReviewerGroup(group.getGroupUUID())) {
        result.error = MessageFormat.format(ChangeMessages.get().groupIsNotAllowed, group.getName());
        return result;
    }
    Map<Account.Id, ChangeControl> reviewers = new HashMap<>();
    ChangeControl control = rsrc.getControl();
    Set<Account> members;
    try {
        members = groupMembersFactory.create(control.getUser()).listAccounts(group.getGroupUUID(), control.getProject().getNameKey());
    } catch (NoSuchGroupException e) {
        throw new UnprocessableEntityException(e.getMessage());
    } catch (NoSuchProjectException e) {
        throw new BadRequestException(e.getMessage());
    }
    // if maxAllowed is set to 0, it is allowed to add any number of
    // reviewers
    int maxAllowed = cfg.getInt("addreviewer", "maxAllowed", DEFAULT_MAX_REVIEWERS);
    if (maxAllowed > 0 && members.size() > maxAllowed) {
        result.error = MessageFormat.format(ChangeMessages.get().groupHasTooManyMembers, group.getName());
        return result;
    }
    // if maxWithoutCheck is set to 0, we never ask for confirmation
    int maxWithoutConfirmation = cfg.getInt("addreviewer", "maxWithoutConfirmation", DEFAULT_MAX_REVIEWERS_WITHOUT_CHECK);
    if (!input.confirmed() && maxWithoutConfirmation > 0 && members.size() > maxWithoutConfirmation) {
        result.confirm = true;
        result.error = MessageFormat.format(ChangeMessages.get().groupManyMembersConfirmation, group.getName(), members.size());
        return result;
    }
    for (Account member : members) {
        if (isValidReviewer(member, control)) {
            reviewers.put(member.getId(), control);
        }
    }
    addReviewers(rsrc, result, reviewers, input.cc());
    return result;
}
#method_after
private AddReviewerResult putGroup(ChangeResource rsrc, AddReviewerInput input) throws UpdateException, RestApiException, OrmException, IOException {
    GroupDescription.Basic group = groupsCollection.parseInternal(input.reviewer);
    AddReviewerResult result = new AddReviewerResult(input.reviewer);
    if (!isLegalReviewerGroup(group.getGroupUUID())) {
        result.error = MessageFormat.format(ChangeMessages.get().groupIsNotAllowed, group.getName());
        return result;
    }
    Map<Account.Id, ChangeControl> reviewers = new HashMap<>();
    ChangeControl control = rsrc.getControl();
    Set<Account> members;
    try {
        members = groupMembersFactory.create(control.getUser()).listAccounts(group.getGroupUUID(), control.getProject().getNameKey());
    } catch (NoSuchGroupException e) {
        throw new UnprocessableEntityException(e.getMessage());
    } catch (NoSuchProjectException e) {
        throw new BadRequestException(e.getMessage());
    }
    // if maxAllowed is set to 0, it is allowed to add any number of
    // reviewers
    int maxAllowed = cfg.getInt("addreviewer", "maxAllowed", DEFAULT_MAX_REVIEWERS);
    if (maxAllowed > 0 && members.size() > maxAllowed) {
        result.error = MessageFormat.format(ChangeMessages.get().groupHasTooManyMembers, group.getName());
        return result;
    }
    // if maxWithoutCheck is set to 0, we never ask for confirmation
    int maxWithoutConfirmation = cfg.getInt("addreviewer", "maxWithoutConfirmation", DEFAULT_MAX_REVIEWERS_WITHOUT_CHECK);
    if (!input.confirmed() && maxWithoutConfirmation > 0 && members.size() > maxWithoutConfirmation) {
        result.confirm = true;
        result.error = MessageFormat.format(ChangeMessages.get().groupManyMembersConfirmation, group.getName(), members.size());
        return result;
    }
    for (Account member : members) {
        if (isValidReviewer(member, control)) {
            reviewers.put(member.getId(), control);
        }
    }
    addReviewers(rsrc, result, reviewers, input.state());
    return result;
}
#end_block

#method_before
private void addReviewers(ChangeResource rsrc, AddReviewerResult result, Map<Account.Id, ChangeControl> reviewers, boolean cc) throws OrmException, RestApiException, UpdateException {
    try (BatchUpdate bu = batchUpdateFactory.create(dbProvider.get(), rsrc.getProject(), rsrc.getUser(), TimeUtil.nowTs())) {
        Op op = new Op(rsrc, reviewers, cc);
        Change.Id id = rsrc.getChange().getId();
        bu.addOp(id, op);
        bu.execute();
        // the Op because the accounts are in a different table.
        if (migration.readChanges() && cc) {
            result.ccs = Lists.newArrayListWithCapacity(op.addedCCs.size());
            for (Account.Id accountId : op.addedCCs) {
                result.ccs.add(json.format(new ReviewerInfo(accountId.get()), reviewers.get(accountId)));
            }
            accountLoaderFactory.create(true).fill(result.ccs);
        } else {
            result.reviewers = Lists.newArrayListWithCapacity(op.addedReviewers.size());
            for (PatchSetApproval psa : op.addedReviewers) {
                // New reviewers have value 0, don't bother normalizing.
                result.reviewers.add(json.format(new ReviewerInfo(psa.getAccountId().get()), reviewers.get(psa.getAccountId()), ImmutableList.of(psa)));
            }
            accountLoaderFactory.create(true).fill(result.reviewers);
        }
    }
}
#method_after
private void addReviewers(ChangeResource rsrc, AddReviewerResult result, Map<Account.Id, ChangeControl> reviewers, ReviewerState state) throws OrmException, RestApiException, UpdateException {
    try (BatchUpdate bu = batchUpdateFactory.create(dbProvider.get(), rsrc.getProject(), rsrc.getUser(), TimeUtil.nowTs())) {
        Op op = new Op(rsrc, reviewers, state);
        Change.Id id = rsrc.getChange().getId();
        bu.addOp(id, op);
        bu.execute();
        // the Op because the accounts are in a different table.
        if (migration.readChanges() && state == CC) {
            result.ccs = Lists.newArrayListWithCapacity(op.addedCCs.size());
            for (Account.Id accountId : op.addedCCs) {
                result.ccs.add(json.format(new ReviewerInfo(accountId.get()), reviewers.get(accountId)));
            }
            accountLoaderFactory.create(true).fill(result.ccs);
        } else {
            result.reviewers = Lists.newArrayListWithCapacity(op.addedReviewers.size());
            for (PatchSetApproval psa : op.addedReviewers) {
                // New reviewers have value 0, don't bother normalizing.
                result.reviewers.add(json.format(new ReviewerInfo(psa.getAccountId().get()), reviewers.get(psa.getAccountId()), ImmutableList.of(psa)));
            }
            accountLoaderFactory.create(true).fill(result.reviewers);
        }
    }
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws RestApiException, OrmException, IOException {
    if (migration.readChanges() && cc) {
        addedCCs = approvalsUtil.addCCs(ctx.getNotes(), ctx.getUpdate(ctx.getChange().currentPatchSetId()), reviewers.keySet());
        if (addedCCs.isEmpty()) {
            return false;
        }
    } else {
        addedReviewers = approvalsUtil.addReviewers(ctx.getDb(), ctx.getNotes(), ctx.getUpdate(ctx.getChange().currentPatchSetId()), rsrc.getControl().getLabelTypes(), rsrc.getChange(), reviewers.keySet());
        if (addedReviewers.isEmpty()) {
            return false;
        }
    }
    patchSet = psUtil.current(dbProvider.get(), rsrc.getNotes());
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws RestApiException, OrmException, IOException {
    if (migration.readChanges() && state == CC) {
        addedCCs = approvalsUtil.addCcs(ctx.getNotes(), ctx.getUpdate(ctx.getChange().currentPatchSetId()), reviewers.keySet());
        if (addedCCs.isEmpty()) {
            return false;
        }
    } else {
        addedReviewers = approvalsUtil.addReviewers(ctx.getDb(), ctx.getNotes(), ctx.getUpdate(ctx.getChange().currentPatchSetId()), rsrc.getControl().getLabelTypes(), rsrc.getChange(), reviewers.keySet());
        if (addedReviewers.isEmpty()) {
            return false;
        }
    }
    patchSet = psUtil.current(dbProvider.get(), rsrc.getNotes());
    return true;
}
#end_block

#method_before
@Override
public void postUpdate(Context ctx) throws Exception {
    if (addedCCs != null) {
        emailCCs(rsrc.getChange(), addedCCs);
    }
    if (addedReviewers != null) {
        emailReviewers(rsrc.getChange(), addedReviewers);
        if (!addedReviewers.isEmpty()) {
            for (PatchSetApproval psa : addedReviewers) {
                Account account = accountCache.get(psa.getAccountId()).getAccount();
                reviewerAdded.fire(rsrc.getChange(), patchSet, account);
            }
        }
    }
}
#method_after
@Override
public void postUpdate(Context ctx) throws Exception {
    if (addedReviewers != null || addedCCs != null) {
        if (addedReviewers == null) {
            addedReviewers = new ArrayList<>();
        }
        if (addedCCs == null) {
            addedCCs = new ArrayList<>();
        }
        emailReviewers(rsrc.getChange(), addedReviewers, addedCCs);
        if (!addedReviewers.isEmpty()) {
            for (PatchSetApproval psa : addedReviewers) {
                Account account = accountCache.get(psa.getAccountId()).getAccount();
                reviewerAdded.fire(rsrc.getChange(), patchSet, account, ctx.getAccount(), ctx.getWhen());
            }
        }
    }
}
#end_block

#method_before
private void emailReviewers(Change change, List<PatchSetApproval> added) {
    if (added.isEmpty()) {
        return;
    }
    // Email the reviewers
    // 
    // The user knows they added themselves, don't bother emailing them.
    List<Account.Id> toMail = Lists.newArrayListWithCapacity(added.size());
    Account.Id userId = user.get().getAccountId();
    for (PatchSetApproval psa : added) {
        if (!psa.getAccountId().equals(userId)) {
            toMail.add(psa.getAccountId());
        }
    }
    if (toMail.isEmpty()) {
        return;
    }
    try {
        AddReviewerSender cm = addReviewerSenderFactory.create(change.getProject(), change.getId());
        cm.setFrom(userId);
        cm.addReviewers(toMail);
        cm.send();
    } catch (Exception err) {
        log.error("Cannot send email to new reviewers of change " + change.getId(), err);
    }
}
#method_after
private void emailReviewers(Change change, List<PatchSetApproval> added, Collection<Account.Id> copied) {
    if (added.isEmpty() && copied.isEmpty()) {
        return;
    }
    // Email the reviewers
    // 
    // The user knows they added themselves, don't bother emailing them.
    List<Account.Id> toMail = Lists.newArrayListWithCapacity(added.size());
    Account.Id userId = user.get().getAccountId();
    for (PatchSetApproval psa : added) {
        if (!psa.getAccountId().equals(userId)) {
            toMail.add(psa.getAccountId());
        }
    }
    List<Account.Id> toCopy = Lists.newArrayListWithCapacity(copied.size());
    for (Account.Id id : copied) {
        if (!id.equals(userId)) {
            toCopy.add(id);
        }
    }
    if (toMail.isEmpty() && toCopy.isEmpty()) {
        return;
    }
    try {
        AddReviewerSender cm = addReviewerSenderFactory.create(change.getProject(), change.getId());
        cm.setFrom(userId);
        cm.addReviewers(toMail);
        cm.addExtraCC(toCopy);
        cm.send();
    } catch (Exception err) {
        log.error("Cannot send email to new reviewers of change " + change.getId(), err);
    }
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, AuthException, ResourceNotFoundException {
    ChangeControl ctl = ctx.getControl();
    change = ctl.getChange();
    PatchSet.Id psId = change.currentPatchSetId();
    ps = psUtil.current(db.get(), ctl.getNotes());
    PatchSetApproval psa = null;
    StringBuilder msg = new StringBuilder();
    // get all of the current approvals
    LabelTypes labelTypes = ctx.getControl().getLabelTypes();
    Map<String, Short> currentApprovals = new HashMap<>();
    for (LabelType lt : labelTypes.getLabelTypes()) {
        currentApprovals.put(lt.getName(), (short) 0);
        for (PatchSetApproval a : approvalsUtil.byPatchSetUser(ctx.getDb(), ctl, psId, accountId)) {
            if (lt.getLabelId().equals(a.getLabelId())) {
                currentApprovals.put(lt.getName(), a.getValue());
            }
        }
    }
    // removing votes so we need to determine the new set of approval scores
    newApprovals.putAll(currentApprovals);
    for (PatchSetApproval a : approvalsUtil.byPatchSetUser(ctx.getDb(), ctl, psId, accountId)) {
        if (ctl.canRemoveReviewer(a)) {
            if (a.getLabel().equals(label)) {
                // set the approval to 0 if vote is being removed
                newApprovals.put(a.getLabel(), (short) 0);
                // set old value only if the vote changed
                oldApprovals.put(a.getLabel(), a.getValue());
                msg.append("Removed ").append(a.getLabel()).append(formatLabelValue(a.getValue())).append(" by ").append(userFactory.create(a.getAccountId()).getNameEmail()).append("\n");
                psa = a;
                a.setValue((short) 0);
                ctx.getUpdate(psId).removeApprovalFor(a.getAccountId(), label);
                break;
            }
        } else {
            throw new AuthException("delete vote not permitted");
        }
    }
    if (psa == null) {
        throw new ResourceNotFoundException();
    }
    ctx.getDb().patchSetApprovals().update(Collections.singleton(psa));
    if (msg.length() > 0) {
        changeMessage = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(ctx.getDb())), ctx.getUser().asIdentifiedUser().getAccountId(), ctx.getWhen(), change.currentPatchSetId());
        changeMessage.setMessage(msg.toString());
        cmUtil.addChangeMessage(ctx.getDb(), ctx.getUpdate(psId), changeMessage);
    }
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, AuthException, ResourceNotFoundException {
    ChangeControl ctl = ctx.getControl();
    change = ctl.getChange();
    PatchSet.Id psId = change.currentPatchSetId();
    ps = psUtil.current(db.get(), ctl.getNotes());
    PatchSetApproval psa = null;
    StringBuilder msg = new StringBuilder();
    // get all of the current approvals
    LabelTypes labelTypes = ctx.getControl().getLabelTypes();
    Map<String, Short> currentApprovals = new HashMap<>();
    for (LabelType lt : labelTypes.getLabelTypes()) {
        currentApprovals.put(lt.getName(), (short) 0);
        for (PatchSetApproval a : approvalsUtil.byPatchSetUser(ctx.getDb(), ctl, psId, accountId)) {
            if (lt.getLabelId().equals(a.getLabelId())) {
                currentApprovals.put(lt.getName(), a.getValue());
            }
        }
    }
    // removing votes so we need to determine the new set of approval scores
    newApprovals.putAll(currentApprovals);
    for (PatchSetApproval a : approvalsUtil.byPatchSetUser(ctx.getDb(), ctl, psId, accountId)) {
        if (ctl.canRemoveReviewer(a)) {
            if (a.getLabel().equals(label)) {
                // set the approval to 0 if vote is being removed
                newApprovals.put(a.getLabel(), (short) 0);
                // set old value only if the vote changed
                oldApprovals.put(a.getLabel(), a.getValue());
                msg.append("Removed ").append(a.getLabel()).append(formatLabelValue(a.getValue())).append(" by ").append(userFactory.create(a.getAccountId()).getNameEmail()).append("\n");
                psa = a;
                a.setValue((short) 0);
                ctx.getUpdate(psId).removeApprovalFor(a.getAccountId(), label);
                break;
            }
        } else {
            throw new AuthException("delete vote not permitted");
        }
    }
    if (psa == null) {
        throw new ResourceNotFoundException();
    }
    ctx.getDb().patchSetApprovals().update(Collections.singleton(psa));
    if (msg.length() > 0) {
        changeMessage = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(ctx.getDb())), ctx.getAccountId(), ctx.getWhen(), change.currentPatchSetId());
        changeMessage.setMessage(msg.toString());
        cmUtil.addChangeMessage(ctx.getDb(), ctx.getUpdate(psId), changeMessage);
    }
    return true;
}
#end_block

#method_before
@Override
public void postUpdate(Context ctx) {
    if (changeMessage == null) {
        return;
    }
    IdentifiedUser user = ctx.getUser().asIdentifiedUser();
    if (input.notify.compareTo(NotifyHandling.NONE) > 0) {
        try {
            ReplyToChangeSender cm = deleteVoteSenderFactory.create(ctx.getProject(), change.getId());
            cm.setFrom(user.getAccountId());
            cm.setChangeMessage(changeMessage.getMessage(), ctx.getWhen());
            cm.setNotify(input.notify);
            cm.send();
        } catch (Exception e) {
            log.error("Cannot email update for change " + change.getId(), e);
        }
    }
    voteDeleted.fire(change, ps, newApprovals, oldApprovals, user.getAccount(), ctx.getWhen());
}
#method_after
@Override
public void postUpdate(Context ctx) {
    if (changeMessage == null) {
        return;
    }
    IdentifiedUser user = ctx.getIdentifiedUser();
    if (input.notify.compareTo(NotifyHandling.NONE) > 0) {
        try {
            ReplyToChangeSender cm = deleteVoteSenderFactory.create(ctx.getProject(), change.getId());
            cm.setFrom(user.getAccountId());
            cm.setChangeMessage(changeMessage.getMessage(), ctx.getWhen());
            cm.setNotify(input.notify);
            cm.send();
        } catch (Exception e) {
            log.error("Cannot email update for change " + change.getId(), e);
        }
    }
    voteDeleted.fire(change, ps, newApprovals, oldApprovals, input.notify, changeMessage.getMessage(), user.getAccount(), ctx.getWhen());
}
#end_block

#method_before
public void fire(Change change, PatchSet ps, Map<String, Short> approvals, Map<String, Short> oldApprovals, Account remover, Timestamp when) {
    if (!listeners.iterator().hasNext()) {
        return;
    }
    try {
        fire(util.changeInfo(change), util.revisionInfo(change.getProject(), ps), util.approvals(remover, approvals, when), util.approvals(remover, oldApprovals, when), util.accountInfo(remover), when);
    } catch (PatchListNotAvailableException | GpgException | IOException | OrmException e) {
        log.error("Couldn't fire event", e);
    }
}
#method_after
public void fire(ChangeInfo change, RevisionInfo revision, Map<String, ApprovalInfo> approvals, Map<String, ApprovalInfo> oldApprovals, NotifyHandling notify, String message, AccountInfo remover, Timestamp when) {
    if (!listeners.iterator().hasNext()) {
        return;
    }
    Event event = new Event(change, revision, approvals, oldApprovals, notify, message, remover, when);
    for (VoteDeletedListener l : listeners) {
        try {
            l.onVoteDeleted(event);
        } catch (Exception e) {
            log.warn("Error in event listener", e);
        }
    }
}
#end_block

#method_before
private AddReviewerResult putGroup(ChangeResource rsrc, AddReviewerInput input) throws UpdateException, RestApiException, OrmException, IOException {
    GroupDescription.Basic group = groupsCollection.parseInternal(input.reviewer);
    AddReviewerResult result = new AddReviewerResult(input.reviewer);
    if (!isLegalReviewerGroup(group.getGroupUUID())) {
        result.error = MessageFormat.format(ChangeMessages.get().groupIsNotAllowed, group.getName());
        return result;
    }
    Map<Account.Id, ChangeControl> reviewers = new HashMap<>();
    ChangeControl control = rsrc.getControl();
    Set<Account> members;
    try {
        members = groupMembersFactory.create(control.getUser()).listAccounts(group.getGroupUUID(), control.getProject().getNameKey());
    } catch (NoSuchGroupException e) {
        throw new UnprocessableEntityException(e.getMessage());
    } catch (NoSuchProjectException e) {
        throw new BadRequestException(e.getMessage());
    }
    // if maxAllowed is set to 0, it is allowed to add any number of
    // reviewers
    int maxAllowed = cfg.getInt("addreviewer", "maxAllowed", DEFAULT_MAX_REVIEWERS);
    if (maxAllowed > 0 && members.size() > maxAllowed) {
        result.error = MessageFormat.format(ChangeMessages.get().groupHasTooManyMembers, group.getName());
        return result;
    }
    // if maxWithoutCheck is set to 0, we never ask for confirmation
    int maxWithoutConfirmation = cfg.getInt("addreviewer", "maxWithoutConfirmation", DEFAULT_MAX_REVIEWERS_WITHOUT_CHECK);
    if (!input.confirmed() && maxWithoutConfirmation > 0 && members.size() > maxWithoutConfirmation) {
        result.needsConfirmation = true;
        result.error = MessageFormat.format(ChangeMessages.get().groupManyMembersConfirmation, group.getName(), members.size());
        return result;
    }
    for (Account member : members) {
        if (isValidReviewer(member, control)) {
            reviewers.put(member.getId(), control);
        }
    }
    addReviewers(rsrc, result, reviewers);
    return result;
}
#method_after
private AddReviewerResult putGroup(ChangeResource rsrc, AddReviewerInput input) throws UpdateException, RestApiException, OrmException, IOException {
    GroupDescription.Basic group = groupsCollection.parseInternal(input.reviewer);
    AddReviewerResult result = new AddReviewerResult(input.reviewer);
    if (!isLegalReviewerGroup(group.getGroupUUID())) {
        result.error = MessageFormat.format(ChangeMessages.get().groupIsNotAllowed, group.getName());
        return result;
    }
    Map<Account.Id, ChangeControl> reviewers = new HashMap<>();
    ChangeControl control = rsrc.getControl();
    Set<Account> members;
    try {
        members = groupMembersFactory.create(control.getUser()).listAccounts(group.getGroupUUID(), control.getProject().getNameKey());
    } catch (NoSuchGroupException e) {
        throw new UnprocessableEntityException(e.getMessage());
    } catch (NoSuchProjectException e) {
        throw new BadRequestException(e.getMessage());
    }
    // if maxAllowed is set to 0, it is allowed to add any number of
    // reviewers
    int maxAllowed = cfg.getInt("addreviewer", "maxAllowed", DEFAULT_MAX_REVIEWERS);
    if (maxAllowed > 0 && members.size() > maxAllowed) {
        result.error = MessageFormat.format(ChangeMessages.get().groupHasTooManyMembers, group.getName());
        return result;
    }
    // if maxWithoutCheck is set to 0, we never ask for confirmation
    int maxWithoutConfirmation = cfg.getInt("addreviewer", "maxWithoutConfirmation", DEFAULT_MAX_REVIEWERS_WITHOUT_CHECK);
    if (!input.confirmed() && maxWithoutConfirmation > 0 && members.size() > maxWithoutConfirmation) {
        result.confirm = true;
        result.error = MessageFormat.format(ChangeMessages.get().groupManyMembersConfirmation, group.getName(), members.size());
        return result;
    }
    for (Account member : members) {
        if (isValidReviewer(member, control)) {
            reviewers.put(member.getId(), control);
        }
    }
    addReviewers(rsrc, result, reviewers);
    return result;
}
#end_block

#method_before
@Override
public void postUpdate(Context ctx) throws Exception {
    emailReviewers(rsrc.getChange(), added);
    if (!added.isEmpty()) {
        for (PatchSetApproval psa : added) {
            Account account = accountCache.get(psa.getAccountId()).getAccount();
            reviewerAdded.fire(rsrc.getChange(), patchSet, account);
        }
    }
}
#method_after
@Override
public void postUpdate(Context ctx) throws Exception {
    emailReviewers(rsrc.getChange(), added);
    if (!added.isEmpty()) {
        for (PatchSetApproval psa : added) {
            Account account = accountCache.get(psa.getAccountId()).getAccount();
            reviewerAdded.fire(rsrc.getChange(), patchSet, account, ctx.getUser().asIdentifiedUser().getAccount(), ctx.getWhen());
        }
    }
}
#end_block

#method_before
@Override
protected void service(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
    if (filter == null) {
        CacheHeaders.setNotCacheable(res);
        res.sendError(SC_NOT_IMPLEMENTED);
        return;
    }
    filter.doFilter(req, res, chain);
}
#method_after
@Override
protected void service(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
    if (filter.get() == null) {
        CacheHeaders.setNotCacheable(res);
        res.sendError(SC_NOT_IMPLEMENTED);
        return;
    }
    filter.get().doFilter(req, res, chain);
}
#end_block

#method_before
private void install(Plugin plugin) {
    if (!plugin.getName().equals(pluginName)) {
        return;
    }
    filter = load(plugin);
}
#method_after
private void install(Plugin plugin) {
    if (!plugin.getName().equals(pluginName)) {
        return;
    }
    final GuiceFilter guiceFilter = load(plugin);
    plugin.add(new RegistrationHandle() {

        @Override
        public void remove() {
            filter.compareAndSet(guiceFilter, null);
        }
    });
    filter.set(guiceFilter);
}
#end_block

#method_before
private GuiceFilter load(Plugin plugin) {
    if (plugin.getHttpInjector() != null) {
        final String name = plugin.getName();
        final GuiceFilter guiceFilter;
        try {
            guiceFilter = plugin.getHttpInjector().getInstance(GuiceFilter.class);
        } catch (RuntimeException e) {
            log.warn(String.format("Plugin %s cannot load GuiceFilter", name), e);
            return null;
        }
        try {
            ServletContext ctx = PluginServletContext.create(plugin, "/");
            guiceFilter.init(new WrappedFilterConfig(ctx));
        } catch (ServletException e) {
            log.warn(String.format("Plugin %s failed to initialize HTTP", name), e);
            return null;
        }
        plugin.add(new RegistrationHandle() {

            @Override
            public void remove() {
                guiceFilter.destroy();
                if (guiceFilter == filter) {
                    filter = null;
                }
            }
        });
        return guiceFilter;
    }
    return null;
}
#method_after
private GuiceFilter load(Plugin plugin) {
    if (plugin.getHttpInjector() != null) {
        final String name = plugin.getName();
        final GuiceFilter guiceFilter;
        try {
            guiceFilter = plugin.getHttpInjector().getInstance(GuiceFilter.class);
        } catch (RuntimeException e) {
            log.warn(String.format("Plugin %s cannot load GuiceFilter", name), e);
            return null;
        }
        try {
            ServletContext ctx = PluginServletContext.create(plugin, "/");
            guiceFilter.init(new WrappedFilterConfig(ctx));
        } catch (ServletException e) {
            log.warn(String.format("Plugin %s failed to initialize HTTP", name), e);
            return null;
        }
        plugin.add(new RegistrationHandle() {

            @Override
            public void remove() {
                guiceFilter.destroy();
            }
        });
        return guiceFilter;
    }
    return null;
}
#end_block

#method_before
private void reportMessages() {
    Iterable<CreateRequest> created = Iterables.filter(newChanges, new Predicate<CreateRequest>() {

        @Override
        public boolean apply(CreateRequest input) {
            return input.change != null;
        }
    });
    if (!Iterables.isEmpty(created)) {
        addMessage("");
        addMessage("New Changes:");
        for (CreateRequest c : created) {
            addMessage(formatChangeUrl(canonicalWebUrl, c.change, c.change.getSubject(), false));
        }
        addMessage("");
    }
    List<ReplaceRequest> updated = FluentIterable.from(replaceByChange.values()).filter(new Predicate<ReplaceRequest>() {

        @Override
        public boolean apply(ReplaceRequest input) {
            return !input.skip && input.inputCommand.getResult() == OK;
        }
    }).toSortedList(Ordering.natural().onResultOf(new Function<ReplaceRequest, Integer>() {

        @Override
        public Integer apply(ReplaceRequest in) {
            return in.notes.getChangeId().get();
        }
    }));
    if (!updated.isEmpty()) {
        addMessage("");
        addMessage("Updated Changes:");
        boolean edit = magicBranch != null && magicBranch.edit;
        for (ReplaceRequest u : updated) {
            addMessage(formatChangeUrl(canonicalWebUrl, u.notes.getChange(), u.info.getSubject(), edit));
        }
        addMessage("");
    }
}
#method_after
private void reportMessages() {
    Iterable<CreateRequest> created = Iterables.filter(newChanges, new Predicate<CreateRequest>() {

        @Override
        public boolean apply(CreateRequest input) {
            return input.change != null;
        }
    });
    if (!Iterables.isEmpty(created)) {
        addMessage("");
        addMessage("New Changes:");
        for (CreateRequest c : created) {
            addMessage(formatChangeUrl(canonicalWebUrl, c.change, c.change.getSubject(), false));
        }
        addMessage("");
    }
    List<ReplaceRequest> updated = FluentIterable.from(replaceByChange.values()).filter(new Predicate<ReplaceRequest>() {

        @Override
        public boolean apply(ReplaceRequest input) {
            return !input.skip && input.inputCommand.getResult() == OK;
        }
    }).toSortedList(Ordering.natural().onResultOf(new Function<ReplaceRequest, Integer>() {

        @Override
        public Integer apply(ReplaceRequest in) {
            return in.notes.getChangeId().get();
        }
    }));
    if (!updated.isEmpty()) {
        addMessage("");
        addMessage("Updated Changes:");
        boolean edit = magicBranch != null && magicBranch.edit;
        for (ReplaceRequest u : updated) {
            String subject;
            if (edit) {
                try {
                    subject = rp.getRevWalk().parseCommit(u.newCommitId).getShortMessage();
                } catch (IOException e) {
                    // Log and fall back to original change subject
                    log.warn("failed to get subject for edit patch set", e);
                    subject = u.notes.getChange().getSubject();
                }
            } else {
                subject = u.info.getMessage();
            }
            addMessage(formatChangeUrl(canonicalWebUrl, u.notes.getChange(), subject, edit));
        }
        addMessage("");
    }
}
#end_block

#method_before
private void selectNewAndReplacedChangesFromMagicBranch() {
    newChanges = new ArrayList<>();
    SetMultimap<ObjectId, Ref> existing = changeRefsById();
    GroupCollector groupCollector = GroupCollector.create(refsById, db, psUtil, notesFactory, project.getNameKey());
    rp.getRevWalk().reset();
    rp.getRevWalk().sort(RevSort.TOPO);
    rp.getRevWalk().sort(RevSort.REVERSE, true);
    try {
        rp.getRevWalk().markStart(rp.getRevWalk().parseCommit(magicBranch.cmd.getNewId()));
        if (magicBranch.baseCommit != null) {
            for (RevCommit c : magicBranch.baseCommit) {
                rp.getRevWalk().markUninteresting(c);
            }
            Ref targetRef = allRefs.get(magicBranch.ctl.getRefName());
            if (targetRef != null) {
                rp.getRevWalk().markUninteresting(rp.getRevWalk().parseCommit(targetRef.getObjectId()));
            }
        } else {
            markHeadsAsUninteresting(rp.getRevWalk(), magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
        }
        List<ChangeLookup> pending = new ArrayList<>();
        Set<Change.Key> newChangeIds = new HashSet<>();
        int maxBatchChanges = receiveConfig.getEffectiveMaxBatchChangesLimit(user);
        for (; ; ) {
            RevCommit c = rp.getRevWalk().next();
            if (c == null) {
                break;
            }
            groupCollector.visit(c);
            Collection<Ref> existingRefs = existing.get(c);
            if (!existingRefs.isEmpty()) {
                // A's group.
                for (Ref ref : existingRefs) {
                    updateGroups.add(new UpdateGroupsRequest(ref, c));
                }
                continue;
            }
            if (!validCommit(rp.getRevWalk(), magicBranch.ctl, magicBranch.cmd, c)) {
                // Not a change the user can propose? Abort as early as possible.
                newChanges = Collections.emptyList();
                return;
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
            }
            List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(c, magicBranch.dest.get()));
                continue;
            }
            String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                newChanges = Collections.emptyList();
                return;
            }
            pending.add(new ChangeLookup(c, new Change.Key(idStr)));
            if (maxBatchChanges != 0 && pending.size() + newChanges.size() > maxBatchChanges) {
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                newChanges = Collections.emptyList();
                return;
            }
        }
        for (ChangeLookup p : pending) {
            if (newChangeIds.contains(p.changeKey)) {
                reject(magicBranch.cmd, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
                newChanges = Collections.emptyList();
                return;
            }
            List<ChangeData> changes = p.destChanges;
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 1) {
                // 
                if (requestReplace(magicBranch.cmd, false, changes.get(0).change(), p.commit)) {
                    continue;
                }
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    newChanges = Collections.emptyList();
                    return;
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(p.commit, magicBranch.dest.get()));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        newChanges = Collections.emptyList();
        return;
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        newChanges = Collections.emptyList();
        return;
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return;
    }
    if (!newChanges.isEmpty() && magicBranch.edit) {
        reject(magicBranch.cmd, "edit is not supported for new changes");
        return;
    }
    try {
        SortedSetMultimap<ObjectId, String> groups = groupCollector.getGroups();
        for (CreateRequest create : newChanges) {
            batch.addCommand(create.cmd);
            create.groups = ImmutableList.copyOf(groups.get(create.commitId));
        }
        for (ReplaceRequest replace : replaceByChange.values()) {
            replace.groups = ImmutableList.copyOf(groups.get(replace.newCommitId));
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.groups = ImmutableList.copyOf((groups.get(update.commit)));
        }
    } catch (OrmException | NoSuchChangeException e) {
        log.error("Error collecting groups for changes", e);
        reject(magicBranch.cmd, "internal server error");
        return;
    }
}
#method_after
private void selectNewAndReplacedChangesFromMagicBranch() {
    newChanges = new ArrayList<>();
    SetMultimap<ObjectId, Ref> existing = changeRefsById();
    GroupCollector groupCollector = GroupCollector.create(changeRefsById(), db, psUtil, notesFactory, project.getNameKey());
    rp.getRevWalk().reset();
    rp.getRevWalk().sort(RevSort.TOPO);
    rp.getRevWalk().sort(RevSort.REVERSE, true);
    try {
        rp.getRevWalk().markStart(rp.getRevWalk().parseCommit(magicBranch.cmd.getNewId()));
        if (magicBranch.baseCommit != null) {
            for (RevCommit c : magicBranch.baseCommit) {
                rp.getRevWalk().markUninteresting(c);
            }
            Ref targetRef = allRefs.get(magicBranch.ctl.getRefName());
            if (targetRef != null) {
                rp.getRevWalk().markUninteresting(rp.getRevWalk().parseCommit(targetRef.getObjectId()));
            }
        } else {
            markHeadsAsUninteresting(rp.getRevWalk(), magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
        }
        List<ChangeLookup> pending = new ArrayList<>();
        Set<Change.Key> newChangeIds = new HashSet<>();
        int maxBatchChanges = receiveConfig.getEffectiveMaxBatchChangesLimit(user);
        for (; ; ) {
            RevCommit c = rp.getRevWalk().next();
            if (c == null) {
                break;
            }
            groupCollector.visit(c);
            Collection<Ref> existingRefs = existing.get(c);
            if (!existingRefs.isEmpty()) {
                // different target branch.
                for (Ref ref : existingRefs) {
                    updateGroups.add(new UpdateGroupsRequest(ref, c));
                }
                if (!(newChangeForAllNotInTarget || magicBranch.base != null)) {
                    continue;
                }
            }
            if (!validCommit(rp.getRevWalk(), magicBranch.ctl, magicBranch.cmd, c)) {
                // Not a change the user can propose? Abort as early as possible.
                newChanges = Collections.emptyList();
                return;
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
            }
            List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(c, magicBranch.dest.get()));
                continue;
            }
            String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                newChanges = Collections.emptyList();
                return;
            }
            pending.add(new ChangeLookup(c, new Change.Key(idStr)));
            if (maxBatchChanges != 0 && pending.size() + newChanges.size() > maxBatchChanges) {
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                newChanges = Collections.emptyList();
                return;
            }
        }
        for (Iterator<ChangeLookup> itr = pending.iterator(); itr.hasNext(); ) {
            ChangeLookup p = itr.next();
            if (newChangeIds.contains(p.changeKey)) {
                reject(magicBranch.cmd, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
                newChanges = Collections.emptyList();
                return;
            }
            List<ChangeData> changes = p.destChanges;
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 1) {
                // Schedule as a replacement to this one matching change.
                // 
                RevId currentPs = changes.get(0).currentPatchSet().getRevision();
                // If Commit is already current PatchSet of target Change.
                if (p.commit.name().equals(currentPs.get())) {
                    if (pending.size() == 1) {
                        // There are no commits left to check, all commits in pending were already
                        // current PatchSet of the corresponding target changes.
                        reject(magicBranch.cmd, "commit(s) already exists (as current patchset)");
                    } else {
                        // Commit is already current PatchSet.
                        // Remove from pending and try next commit.
                        itr.remove();
                        continue;
                    }
                }
                if (requestReplace(magicBranch.cmd, false, changes.get(0).change(), p.commit)) {
                    continue;
                }
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    newChanges = Collections.emptyList();
                    return;
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(p.commit, magicBranch.dest.get()));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        newChanges = Collections.emptyList();
        return;
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        newChanges = Collections.emptyList();
        return;
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return;
    }
    if (!newChanges.isEmpty() && magicBranch.edit) {
        reject(magicBranch.cmd, "edit is not supported for new changes");
        return;
    }
    try {
        SortedSetMultimap<ObjectId, String> groups = groupCollector.getGroups();
        for (CreateRequest create : newChanges) {
            batch.addCommand(create.cmd);
            create.groups = ImmutableList.copyOf(groups.get(create.commitId));
        }
        for (ReplaceRequest replace : replaceByChange.values()) {
            replace.groups = ImmutableList.copyOf(groups.get(replace.newCommitId));
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.groups = ImmutableList.copyOf((groups.get(update.commit)));
        }
    } catch (OrmException | NoSuchChangeException e) {
        log.error("Error collecting groups for changes", e);
        reject(magicBranch.cmd, "internal server error");
        return;
    }
}
#end_block

#method_before
private void addOps(BatchUpdate bu) throws RestApiException {
    try {
        RevWalk rw = rp.getRevWalk();
        RevCommit commit = rw.parseCommit(commitId);
        rw.parseBody(commit);
        final PatchSet.Id psId = ins.setGroups(groups).getPatchSetId();
        Account.Id me = user.getAccountId();
        List<FooterLine> footerLines = commit.getFooterLines();
        MailRecipients recipients = new MailRecipients();
        Map<String, Short> approvals = new HashMap<>();
        checkNotNull(magicBranch);
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.labels;
        recipients.add(getRecipientsFromFooters(accountResolver, magicBranch.draft, footerLines));
        recipients.remove(me);
        StringBuilder msg = new StringBuilder(ApprovalsUtil.renderMessageWithApprovals(psId.get(), approvals, Collections.<String, PatchSetApproval>emptyMap()));
        if (!Strings.isNullOrEmpty(magicBranch.message)) {
            msg.append("\n").append(magicBranch.message);
        }
        bu.insertChange(ins.setReviewers(recipients.getReviewers()).setExtraCC(recipients.getCcOnly()).setApprovals(approvals).setMessage(msg.toString()).setNotify(magicBranch.notify).setRequestScopePropagator(requestScopePropagator).setSendMail(true).setUpdateRef(true));
        if (!magicBranch.hashtags.isEmpty()) {
            bu.addOp(changeId, hashtagsFactory.create(new HashtagsInput(magicBranch.hashtags)).setRunHooks(false));
        }
        if (!Strings.isNullOrEmpty(magicBranch.topic)) {
            bu.addOp(changeId, new BatchUpdate.Op() {

                @Override
                public boolean updateChange(ChangeContext ctx) {
                    ctx.getUpdate(psId).setTopic(magicBranch.topic);
                    return true;
                }
            });
        }
        bu.addOp(changeId, new BatchUpdate.Op() {

            @Override
            public boolean updateChange(ChangeContext ctx) {
                change = ctx.getChange();
                return false;
            }
        });
        bu.addOp(changeId, new ChangeProgressOp(newProgress));
    } catch (Exception e) {
        throw INSERT_EXCEPTION.apply(e);
    }
}
#method_after
private void addOps(BatchUpdate bu) throws RestApiException {
    try {
        RevWalk rw = rp.getRevWalk();
        RevCommit commit = rw.parseCommit(commitId);
        rw.parseBody(commit);
        final PatchSet.Id psId = ins.setGroups(groups).getPatchSetId();
        Account.Id me = user.getAccountId();
        List<FooterLine> footerLines = commit.getFooterLines();
        MailRecipients recipients = new MailRecipients();
        Map<String, Short> approvals = new HashMap<>();
        checkNotNull(magicBranch);
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.labels;
        recipients.add(getRecipientsFromFooters(accountResolver, magicBranch.draft, footerLines));
        recipients.remove(me);
        StringBuilder msg = new StringBuilder(ApprovalsUtil.renderMessageWithApprovals(psId.get(), approvals, Collections.<String, PatchSetApproval>emptyMap()));
        if (!Strings.isNullOrEmpty(magicBranch.message)) {
            msg.append("\n").append(magicBranch.message);
        }
        bu.insertChange(ins.setReviewers(recipients.getReviewers()).setExtraCC(recipients.getCcOnly()).setApprovals(approvals).setMessage(msg.toString()).setNotify(magicBranch.notify).setRequestScopePropagator(requestScopePropagator).setSendMail(true).setUpdateRef(true));
        if (!magicBranch.hashtags.isEmpty()) {
            bu.addOp(changeId, hashtagsFactory.create(new HashtagsInput(magicBranch.hashtags)).setFireEvent(false));
        }
        if (!Strings.isNullOrEmpty(magicBranch.topic)) {
            bu.addOp(changeId, new BatchUpdate.Op() {

                @Override
                public boolean updateChange(ChangeContext ctx) {
                    ctx.getUpdate(psId).setTopic(magicBranch.topic);
                    return true;
                }
            });
        }
        bu.addOp(changeId, new BatchUpdate.Op() {

            @Override
            public boolean updateChange(ChangeContext ctx) {
                change = ctx.getChange();
                return false;
            }
        });
        bu.addOp(changeId, new ChangeProgressOp(newProgress));
    } catch (Exception e) {
        throw INSERT_EXCEPTION.apply(e);
    }
}
#end_block

#method_before
private void submit(Collection<CreateRequest> create, Collection<ReplaceRequest> replace) throws OrmException, RestApiException {
    Map<ObjectId, Change> bySha = Maps.newHashMapWithExpectedSize(create.size() + replace.size());
    for (CreateRequest r : create) {
        checkNotNull(r.change, "cannot submit new change %s; op may not have run", r.changeId);
        bySha.put(r.commitId, r.change);
    }
    for (ReplaceRequest r : replace) {
        bySha.put(r.newCommitId, r.notes.getChange());
    }
    Change tipChange = bySha.get(magicBranch.cmd.getNewId());
    checkState(tipChange != null, "tip of push does not correspond to a change; found these changes: %s", bySha);
    try (MergeOp op = mergeOpProvider.get()) {
        op.merge(db, tipChange, user, false, new SubmitInput());
    }
}
#method_after
private void submit(Collection<CreateRequest> create, Collection<ReplaceRequest> replace) throws OrmException, RestApiException {
    Map<ObjectId, Change> bySha = Maps.newHashMapWithExpectedSize(create.size() + replace.size());
    for (CreateRequest r : create) {
        checkNotNull(r.change, "cannot submit new change %s; op may not have run", r.changeId);
        bySha.put(r.commitId, r.change);
    }
    for (ReplaceRequest r : replace) {
        bySha.put(r.newCommitId, r.notes.getChange());
    }
    Change tipChange = bySha.get(magicBranch.cmd.getNewId());
    checkNotNull(tipChange, "tip of push does not correspond to a change; found these changes: %s", bySha);
    try (MergeOp op = mergeOpProvider.get()) {
        op.merge(db, tipChange, user, false, new SubmitInput());
    }
}
#end_block

#method_before
boolean validate(boolean autoClose) throws IOException, OrmException {
    if (!autoClose && inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    } else if (notes == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    priorPatchSet = notes.getChange().currentPatchSetId();
    if (!revisions.containsValue(priorPatchSet)) {
        reject(inputCommand, "change " + ontoChange + " missing revisions");
        return false;
    }
    RevCommit newCommit = rp.getRevWalk().parseCommit(newCommitId);
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    if (newCommit.equals(priorCommit)) {
        // Ignore requests to make the change its current state.
        skip = true;
        reject(inputCommand, "commit already exists (as current patchset)");
        return false;
    }
    changeCtl = projectControl.controlFor(notes);
    if (!changeCtl.canAddPatchSet(db)) {
        String locked = ".";
        if (changeCtl.isPatchSetLocked(db)) {
            locked = ". Change is patch set locked.";
        }
        reject(inputCommand, "cannot replace " + ontoChange + locked);
        return false;
    } else if (notes.getChange().getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    } else if (revisions.containsKey(newCommit)) {
        reject(inputCommand, "commit already exists (in the change)");
        return false;
    }
    for (Ref r : rp.getRepository().getRefDatabase().getRefs("refs/changes").values()) {
        if (r.getObjectId().equals(newCommit)) {
            reject(inputCommand, "commit already exists (in the project)");
            return false;
        }
    }
    for (RevCommit prior : revisions.keySet()) {
        // amending when trying to address review comments.
        if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
            reject(inputCommand, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
            return false;
        }
    }
    if (!validCommit(rp.getRevWalk(), changeCtl.getRefControl(), inputCommand, newCommit)) {
        return false;
    }
    rp.getRevWalk().parseBody(priorCommit);
    // of the commit was modified.
    if (newCommit.getTree().equals(priorCommit.getTree())) {
        boolean messageEq = eq(newCommit.getFullMessage(), priorCommit.getFullMessage());
        boolean parentsEq = parentsEqual(newCommit, priorCommit);
        boolean authorEq = authorEqual(newCommit, priorCommit);
        ObjectReader reader = rp.getRevWalk().getObjectReader();
        if (messageEq && parentsEq && authorEq && !autoClose) {
            addMessage(String.format("(W) No changes between prior commit %s and new commit %s", reader.abbreviate(priorCommit).name(), reader.abbreviate(newCommit).name()));
        } else {
            StringBuilder msg = new StringBuilder();
            msg.append("(I) ");
            msg.append(reader.abbreviate(newCommit).name());
            msg.append(":");
            msg.append(" no files changed");
            if (!authorEq) {
                msg.append(", author changed");
            }
            if (!messageEq) {
                msg.append(", message updated");
            }
            if (!parentsEq) {
                msg.append(", was rebased");
            }
            addMessage(msg.toString());
        }
    }
    if (magicBranch != null && magicBranch.edit) {
        return newEdit();
    }
    newPatchSet();
    return true;
}
#method_after
boolean validate(boolean autoClose) throws IOException, OrmException {
    if (!autoClose && inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    } else if (notes == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    priorPatchSet = notes.getChange().currentPatchSetId();
    if (!revisions.containsValue(priorPatchSet)) {
        reject(inputCommand, "change " + ontoChange + " missing revisions");
        return false;
    }
    RevCommit newCommit = rp.getRevWalk().parseCommit(newCommitId);
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    changeCtl = projectControl.controlFor(notes);
    if (!changeCtl.canAddPatchSet(db)) {
        String locked = ".";
        if (changeCtl.isPatchSetLocked(db)) {
            locked = ". Change is patch set locked.";
        }
        reject(inputCommand, "cannot replace " + ontoChange + locked);
        return false;
    } else if (notes.getChange().getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    } else if (revisions.containsKey(newCommit)) {
        reject(inputCommand, "commit already exists (in the change)");
        return false;
    }
    for (Ref r : rp.getRepository().getRefDatabase().getRefs("refs/changes").values()) {
        if (r.getObjectId().equals(newCommit)) {
            reject(inputCommand, "commit already exists (in the project)");
            return false;
        }
    }
    for (RevCommit prior : revisions.keySet()) {
        // amending when trying to address review comments.
        if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
            reject(inputCommand, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
            return false;
        }
    }
    if (!validCommit(rp.getRevWalk(), changeCtl.getRefControl(), inputCommand, newCommit)) {
        return false;
    }
    rp.getRevWalk().parseBody(priorCommit);
    // of the commit was modified.
    if (newCommit.getTree().equals(priorCommit.getTree())) {
        boolean messageEq = eq(newCommit.getFullMessage(), priorCommit.getFullMessage());
        boolean parentsEq = parentsEqual(newCommit, priorCommit);
        boolean authorEq = authorEqual(newCommit, priorCommit);
        ObjectReader reader = rp.getRevWalk().getObjectReader();
        if (messageEq && parentsEq && authorEq && !autoClose) {
            addMessage(String.format("(W) No changes between prior commit %s and new commit %s", reader.abbreviate(priorCommit).name(), reader.abbreviate(newCommit).name()));
        } else {
            StringBuilder msg = new StringBuilder();
            msg.append("(I) ");
            msg.append(reader.abbreviate(newCommit).name());
            msg.append(":");
            msg.append(" no files changed");
            if (!authorEq) {
                msg.append(", author changed");
            }
            if (!messageEq) {
                msg.append(", message updated");
            }
            if (!parentsEq) {
                msg.append(", was rebased");
            }
            addMessage(msg.toString());
        }
    }
    if (magicBranch != null && magicBranch.edit) {
        return newEdit();
    }
    newPatchSet();
    return true;
}
#end_block

#method_before
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    if (ctl.canForgeAuthor() && ctl.canForgeCommitter() && ctl.canForgeGerritServerIdentity() && ctl.canUploadMerges() && !projectControl.getProjectState().isUseSignedOffBy() && Iterables.isEmpty(rejectCommits) && !RefNames.REFS_CONFIG.equals(ctl.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        return;
    }
    boolean defaultName = Strings.isNullOrEmpty(user.getAccount().getFullName());
    RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        RevObject parsedObject = walk.parseAny(cmd.getNewId());
        if (!(parsedObject instanceof RevCommit)) {
            return;
        }
        walk.markStart((RevCommit) parsedObject);
        markHeadsAsUninteresting(walk, cmd.getRefName());
        Set<ObjectId> existing = changeRefsById().keySet();
        for (RevCommit c; (c = walk.next()) != null; ) {
            if (existing.contains(c)) {
                continue;
            } else if (!validCommit(walk, ctl, cmd, c)) {
                break;
            }
            if (defaultName && user.hasEmailAddress(c.getCommitterIdent().getEmailAddress())) {
                try {
                    Account a = db.accounts().get(user.getAccountId());
                    if (a != null && Strings.isNullOrEmpty(a.getFullName())) {
                        a.setFullName(c.getCommitterIdent().getName());
                        db.accounts().update(Collections.singleton(a));
                        user.getAccount().setFullName(a.getFullName());
                        accountCache.evict(a.getId());
                    }
                } catch (OrmException e) {
                    log.warn("Cannot default full_name", e);
                } finally {
                    defaultName = false;
                }
            }
        }
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#method_after
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    if (ctl.canForgeAuthor() && ctl.canForgeCommitter() && ctl.canForgeGerritServerIdentity() && ctl.canUploadMerges() && !projectControl.getProjectState().isUseSignedOffBy() && Iterables.isEmpty(rejectCommits) && !RefNames.REFS_CONFIG.equals(ctl.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        return;
    }
    boolean defaultName = Strings.isNullOrEmpty(user.getAccount().getFullName());
    RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        RevObject parsedObject = walk.parseAny(cmd.getNewId());
        if (!(parsedObject instanceof RevCommit)) {
            return;
        }
        SetMultimap<ObjectId, Ref> existing = changeRefsById();
        walk.markStart((RevCommit) parsedObject);
        markHeadsAsUninteresting(walk, cmd.getRefName());
        for (RevCommit c; (c = walk.next()) != null; ) {
            if (existing.keySet().contains(c)) {
                continue;
            } else if (!validCommit(walk, ctl, cmd, c)) {
                break;
            }
            if (defaultName && user.hasEmailAddress(c.getCommitterIdent().getEmailAddress())) {
                try {
                    Account a = db.accounts().get(user.getAccountId());
                    if (a != null && Strings.isNullOrEmpty(a.getFullName())) {
                        a.setFullName(c.getCommitterIdent().getName());
                        db.accounts().update(Collections.singleton(a));
                        user.getAccount().setFullName(a.getFullName());
                        accountCache.evict(a.getId());
                    }
                } catch (OrmException e) {
                    log.warn("Cannot default full_name", e);
                } finally {
                    defaultName = false;
                }
            }
        }
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#end_block

#method_before
@Override
public String getUrl() {
    String database = cfg.getString("database", null, "database");
    Boolean autoserver = cfg.getBoolean("database", "h2", "autoServer", false);
    if (database == null || database.isEmpty()) {
        database = "db/ReviewDB";
    }
    return "jdbc:h2:" + site.resolve(database).toUri().toString() + (autoserver ? ";AUTO_SERVER=TRUE" : "");
}
#method_after
@Override
public String getUrl() {
    String database = cfg.getString("database", null, "database");
    if (database == null || database.isEmpty()) {
        database = "db/ReviewDB";
    }
    return appendUrlOptions(cfg, createUrl(site.resolve(database)));
}
#end_block

#method_before
@Test
public void watchProject() throws Exception {
    // watch project
    String watchedProject = createProject("watchedProject").get();
    setApiUser(user);
    watch(watchedProject);
    // push a change to watched project -> should trigger email notification
    setApiUser(admin);
    TestRepository<InMemoryRepository> watchedRepo = cloneProject(new Project.NameKey(watchedProject), admin);
    PushOneCommit.Result r = pushFactory.create(db, admin.getIdent(), watchedRepo, "my subject", "a", "a1").to("refs/for/master");
    r.assertOkStatus();
    // push a change to non-watched project -> should not trigger email
    // notification
    String notWatchedProject = createProject("otherProject").get();
    TestRepository<InMemoryRepository> notWatchedRepo = cloneProject(new Project.NameKey(notWatchedProject), admin);
    r = pushFactory.create(db, admin.getIdent(), notWatchedRepo, "other subject", "a", "a1").to("refs/for/master");
    r.assertOkStatus();
    // assert email notification
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(user.emailAddress);
    assertThat(m.body()).contains("Change subject: my subject\n");
    assertThat(m.body()).contains("Gerrit-PatchSet: 1\n");
}
#method_after
@Test
public void watchProject() throws Exception {
    // watch project
    String watchedProject = createProject("watchedProject").get();
    setApiUser(user);
    watch(watchedProject, null);
    // push a change to watched project -> should trigger email notification
    setApiUser(admin);
    TestRepository<InMemoryRepository> watchedRepo = cloneProject(new Project.NameKey(watchedProject), admin);
    PushOneCommit.Result r = pushFactory.create(db, admin.getIdent(), watchedRepo, "TRIGGER", "a", "a1").to("refs/for/master");
    r.assertOkStatus();
    // push a change to non-watched project -> should not trigger email
    // notification
    String notWatchedProject = createProject("otherProject").get();
    TestRepository<InMemoryRepository> notWatchedRepo = cloneProject(new Project.NameKey(notWatchedProject), admin);
    r = pushFactory.create(db, admin.getIdent(), notWatchedRepo, "DONT_TRIGGER", "a", "a1").to("refs/for/master");
    r.assertOkStatus();
    // assert email notification
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(user.emailAddress);
    assertThat(m.body()).contains("Change subject: TRIGGER\n");
    assertThat(m.body()).contains("Gerrit-PatchSet: 1\n");
}
#end_block

#method_before
@Test
public void watchFile() throws Exception {
    // watch file in project
    String watchedProject = createProject("watchedProject").get();
    setApiUser(user);
    watch(watchedProject, "file:a.txt");
    // push a change to watched file -> should trigger email notification
    setApiUser(admin);
    TestRepository<InMemoryRepository> watchedRepo = cloneProject(new Project.NameKey(watchedProject), admin);
    PushOneCommit.Result r = pushFactory.create(db, admin.getIdent(), watchedRepo, "my subject", "a.txt", "a1").to("refs/for/master");
    r.assertOkStatus();
    // push a change to non-watched file -> should not trigger email
    // notification
    r = pushFactory.create(db, admin.getIdent(), testRepo, "other subject", "b.txt", "b1").to("refs/for/master");
    r.assertOkStatus();
    // assert email notification
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(user.emailAddress);
    assertThat(m.body()).contains("Change subject: my subject\n");
    assertThat(m.body()).contains("Gerrit-PatchSet: 1\n");
}
#method_after
@Test
public void watchFile() throws Exception {
    // watch file in project
    String watchedProject = createProject("watchedProject").get();
    setApiUser(user);
    watch(watchedProject, "file:a.txt");
    // push a change to watched file -> should trigger email notification
    setApiUser(admin);
    TestRepository<InMemoryRepository> watchedRepo = cloneProject(new Project.NameKey(watchedProject), admin);
    PushOneCommit.Result r = pushFactory.create(db, admin.getIdent(), watchedRepo, "TRIGGER", "a.txt", "a1").to("refs/for/master");
    r.assertOkStatus();
    // push a change to non-watched file -> should not trigger email
    // notification
    r = pushFactory.create(db, admin.getIdent(), testRepo, "DONT_TRIGGER", "b.txt", "b1").to("refs/for/master");
    r.assertOkStatus();
    // assert email notification
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(user.emailAddress);
    assertThat(m.body()).contains("Change subject: TRIGGER\n");
    assertThat(m.body()).contains("Gerrit-PatchSet: 1\n");
}
#end_block

#method_before
private BatchMetaDataUpdate approve(ChangeControl control, PatchSet.Id psId, IdentifiedUser user, ChangeUpdate update, Timestamp timestamp) throws OrmException {
    Map<PatchSetApproval.Key, PatchSetApproval> byKey = Maps.newHashMap();
    for (PatchSetApproval psa : approvalsUtil.byPatchSet(db, control, psId)) {
        if (!byKey.containsKey(psa.getKey())) {
            byKey.put(psa.getKey(), psa);
        }
    }
    PatchSetApproval submit = new PatchSetApproval(new PatchSetApproval.Key(psId, user.getAccountId(), LabelId.SUBMIT), (short) 1, TimeUtil.nowTs());
    byKey.put(submit.getKey(), submit);
    submit.setValue((short) 1);
    submit.setGranted(timestamp);
    // Flatten out existing approvals for this patch set based upon the current
    // permissions. Once the change is closed the approvals are not updated at
    // presentation view time, except for zero votes used to indicate a reviewer
    // was added. So we need to make sure votes are accurate now. This way if
    // permissions get modified in the future, historical records stay accurate.
    LabelNormalizer.Result normalized = labelNormalizer.normalize(control, byKey.values());
    // TODO(dborowitz): Don't use a label in notedb; just check when status
    // change happened.
    update.putApproval(submit.getLabel(), submit.getValue());
    logDebug("Adding submit label " + submit);
    db.patchSetApprovals().upsert(normalized.getNormalized());
    db.patchSetApprovals().delete(normalized.deleted());
    try {
        return saveToBatch(control, update, normalized, timestamp);
    } catch (IOException e) {
        throw new OrmException(e);
    }
}
#method_after
private BatchMetaDataUpdate approve(ChangeControl control, PatchSet.Id psId, IdentifiedUser user, ChangeUpdate update, Timestamp timestamp) throws OrmException {
    Map<PatchSetApproval.Key, PatchSetApproval> byKey = Maps.newHashMap();
    for (PatchSetApproval psa : approvalsUtil.byPatchSet(db, control, psId)) {
        if (!byKey.containsKey(psa.getKey())) {
            byKey.put(psa.getKey(), psa);
        }
    }
    PatchSetApproval submit = new PatchSetApproval(new PatchSetApproval.Key(psId, user.getAccountId(), LabelId.SUBMIT), (short) 1, TimeUtil.nowTs());
    byKey.put(submit.getKey(), submit);
    submit.setValue((short) 1);
    submit.setGranted(timestamp);
    // Flatten out existing approvals for this patch set based upon the current
    // permissions. Once the change is closed the approvals are not updated at
    // presentation view time, except for zero votes used to indicate a reviewer
    // was added. So we need to make sure votes are accurate now. This way if
    // permissions get modified in the future, historical records stay accurate.
    LabelNormalizer.Result normalized = labelNormalizer.normalize(control, byKey.values());
    // TODO(dborowitz): Don't use a label in notedb; just check when status
    // change happened.
    update.putApproval(submit.getLabel(), submit.getValue());
    logDebug("Adding submit label " + submit);
    db.patchSetApprovals().upsert(normalized.getNormalized());
    db.patchSetApprovals().update(zero(normalized.deleted()));
    try {
        return saveToBatch(control, update, normalized, timestamp);
    } catch (IOException e) {
        throw new OrmException(e);
    }
}
#end_block

#method_before
private void selectNewAndReplacedChangesFromMagicBranch() {
    newChanges = Lists.newArrayList();
    SetMultimap<ObjectId, Ref> existing = changeRefsById();
    GroupCollector groupCollector = new GroupCollector(changeRefsById(), db);
    rp.getRevWalk().reset();
    rp.getRevWalk().sort(RevSort.TOPO);
    rp.getRevWalk().sort(RevSort.REVERSE, true);
    try {
        rp.getRevWalk().markStart(rp.getRevWalk().parseCommit(magicBranch.cmd.getNewId()));
        if (magicBranch.baseCommit != null) {
            for (RevCommit c : magicBranch.baseCommit) {
                rp.getRevWalk().markUninteresting(c);
            }
            Ref targetRef = allRefs.get(magicBranch.ctl.getRefName());
            if (targetRef != null) {
                rp.getRevWalk().markUninteresting(rp.getRevWalk().parseCommit(targetRef.getObjectId()));
            }
        } else {
            markHeadsAsUninteresting(rp.getRevWalk(), existing, magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
        }
        List<ChangeLookup> pending = Lists.newArrayList();
        final Set<Change.Key> newChangeIds = new HashSet<>();
        final int maxBatchChanges = receiveConfig.getEffectiveMaxBatchChangesLimit(user);
        for (; ; ) {
            final RevCommit c = rp.getRevWalk().next();
            if (c == null) {
                break;
            }
            groupCollector.visit(c);
            Collection<Ref> existingRefs = existing.get(c);
            if (!existingRefs.isEmpty()) {
                // different target branch.
                for (Ref ref : existingRefs) {
                    updateGroups.add(new UpdateGroupsRequest(ref, c));
                }
                if (!(newChangeForAllNotInTarget || magicBranch.base != null)) {
                    continue;
                }
            }
            if (!validCommit(magicBranch.ctl, magicBranch.cmd, c)) {
                // Not a change the user can propose? Abort as early as possible.
                newChanges = Collections.emptyList();
                return;
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
            }
            Change.Key changeKey = new Change.Key("I" + c.name());
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(magicBranch.ctl, c, changeKey));
                continue;
            }
            final String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                newChanges = Collections.emptyList();
                return;
            }
            changeKey = new Change.Key(idStr);
            pending.add(new ChangeLookup(c, changeKey));
            if (maxBatchChanges != 0 && pending.size() + newChanges.size() > maxBatchChanges) {
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                newChanges = Collections.emptyList();
                return;
            }
        }
        for (Iterator<ChangeLookup> itr = pending.iterator(); itr.hasNext(); ) {
            ChangeLookup p = itr.next();
            if (newChangeIds.contains(p.changeKey)) {
                reject(magicBranch.cmd, "squash commits first");
                newChanges = Collections.emptyList();
                return;
            }
            List<ChangeData> changes = p.destChanges;
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 1) {
                if (p.commit.name().equals(changes.get(0).currentPatchSet().getRevision().get())) {
                    // All PatchSets in push are currentPatchSet of target changes
                    if (pending.size() == 1) {
                        reject(magicBranch.cmd, "commit(s) already exists (as current patchset)");
                    } else {
                        // Commit is already current PatchSet.
                        itr.remove();
                        continue;
                    }
                }
                if (requestReplace(magicBranch.cmd, false, changes.get(0).change(), p.commit)) {
                    continue;
                } else {
                    newChanges = Collections.emptyList();
                    return;
                }
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    newChanges = Collections.emptyList();
                    return;
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(magicBranch.ctl, p.commit, p.changeKey));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        newChanges = Collections.emptyList();
        return;
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        newChanges = Collections.emptyList();
        return;
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return;
    }
    if (!newChanges.isEmpty() && magicBranch.edit) {
        reject(magicBranch.cmd, "edit is not supported for new changes");
        return;
    }
    try {
        Multimap<ObjectId, String> groups = groupCollector.getGroups();
        for (CreateRequest create : newChanges) {
            batch.addCommand(create.cmd);
            create.groups = groups.get(create.commit);
        }
        for (ReplaceRequest replace : replaceByChange.values()) {
            replace.groups = groups.get(replace.newCommit);
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.groups = Sets.newHashSet(groups.get(update.commit));
        }
    } catch (OrmException e) {
        log.error("Error collecting groups for changes", e);
        reject(magicBranch.cmd, "internal server error");
        return;
    }
}
#method_after
private void selectNewAndReplacedChangesFromMagicBranch() {
    newChanges = Lists.newArrayList();
    SetMultimap<ObjectId, Ref> existing = changeRefsById();
    GroupCollector groupCollector = new GroupCollector(changeRefsById(), db);
    rp.getRevWalk().reset();
    rp.getRevWalk().sort(RevSort.TOPO);
    rp.getRevWalk().sort(RevSort.REVERSE, true);
    try {
        rp.getRevWalk().markStart(rp.getRevWalk().parseCommit(magicBranch.cmd.getNewId()));
        if (magicBranch.baseCommit != null) {
            for (RevCommit c : magicBranch.baseCommit) {
                rp.getRevWalk().markUninteresting(c);
            }
            Ref targetRef = allRefs.get(magicBranch.ctl.getRefName());
            if (targetRef != null) {
                rp.getRevWalk().markUninteresting(rp.getRevWalk().parseCommit(targetRef.getObjectId()));
            }
        } else {
            markHeadsAsUninteresting(rp.getRevWalk(), magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
        }
        List<ChangeLookup> pending = Lists.newArrayList();
        final Set<Change.Key> newChangeIds = new HashSet<>();
        final int maxBatchChanges = receiveConfig.getEffectiveMaxBatchChangesLimit(user);
        for (; ; ) {
            final RevCommit c = rp.getRevWalk().next();
            if (c == null) {
                break;
            }
            groupCollector.visit(c);
            Collection<Ref> existingRefs = existing.get(c);
            if (!existingRefs.isEmpty()) {
                // different target branch.
                for (Ref ref : existingRefs) {
                    updateGroups.add(new UpdateGroupsRequest(ref, c));
                }
                if (!(newChangeForAllNotInTarget || magicBranch.base != null)) {
                    continue;
                }
            }
            if (!validCommit(magicBranch.ctl, magicBranch.cmd, c)) {
                // Not a change the user can propose? Abort as early as possible.
                newChanges = Collections.emptyList();
                return;
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
            }
            Change.Key changeKey = new Change.Key("I" + c.name());
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(magicBranch.ctl, c, changeKey));
                continue;
            }
            final String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                newChanges = Collections.emptyList();
                return;
            }
            changeKey = new Change.Key(idStr);
            pending.add(new ChangeLookup(c, changeKey));
            if (maxBatchChanges != 0 && pending.size() + newChanges.size() > maxBatchChanges) {
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                newChanges = Collections.emptyList();
                return;
            }
        }
        for (Iterator<ChangeLookup> itr = pending.iterator(); itr.hasNext(); ) {
            ChangeLookup p = itr.next();
            if (newChangeIds.contains(p.changeKey)) {
                reject(magicBranch.cmd, "squash commits first");
                newChanges = Collections.emptyList();
                return;
            }
            List<ChangeData> changes = p.destChanges;
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 1) {
                // Schedule as a replacement to this one matching change.
                // 
                RevId currentPs = changes.get(0).currentPatchSet().getRevision();
                // If Commit is already current PatchSet of target Change.
                if (p.commit.name().equals(currentPs.get())) {
                    if (pending.size() == 1) {
                        // There are no commits left to check, all commits in pending were already
                        // current PatchSet of the corresponding target changes.
                        reject(magicBranch.cmd, "commit(s) already exists (as current patchset)");
                    } else {
                        // Commit is already current PatchSet.
                        // Remove from pending and try next commit.
                        itr.remove();
                        continue;
                    }
                }
                if (requestReplace(magicBranch.cmd, false, changes.get(0).change(), p.commit)) {
                    continue;
                } else {
                    newChanges = Collections.emptyList();
                    return;
                }
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    newChanges = Collections.emptyList();
                    return;
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(magicBranch.ctl, p.commit, p.changeKey));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        newChanges = Collections.emptyList();
        return;
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        newChanges = Collections.emptyList();
        return;
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return;
    }
    if (!newChanges.isEmpty() && magicBranch.edit) {
        reject(magicBranch.cmd, "edit is not supported for new changes");
        return;
    }
    try {
        Multimap<ObjectId, String> groups = groupCollector.getGroups();
        for (CreateRequest create : newChanges) {
            batch.addCommand(create.cmd);
            create.groups = groups.get(create.commit);
        }
        for (ReplaceRequest replace : replaceByChange.values()) {
            replace.groups = groups.get(replace.newCommit);
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.groups = Sets.newHashSet(groups.get(update.commit));
        }
    } catch (OrmException e) {
        log.error("Error collecting groups for changes", e);
        reject(magicBranch.cmd, "internal server error");
        return;
    }
}
#end_block

#method_before
private void markHeadsAsUninteresting(final RevWalk walk, SetMultimap<ObjectId, Ref> existing, @Nullable String forRef) {
    for (Ref ref : allRefs.values()) {
        if (ref.getObjectId() == null) {
            continue;
        } else if (ref.getName().startsWith(REFS_CHANGES)) {
            existing.put(ref.getObjectId(), ref);
        } else if (ref.getName().startsWith(R_HEADS) || (forRef != null && forRef.equals(ref.getName()))) {
            try {
                walk.markUninteresting(walk.parseCommit(ref.getObjectId()));
            } catch (IOException e) {
                log.warn(String.format("Invalid ref %s in %s", ref.getName(), project.getName()), e);
                continue;
            }
        }
    }
}
#method_after
private void markHeadsAsUninteresting(RevWalk rw, @Nullable String forRef) {
    for (Ref ref : allRefs.values()) {
        if ((ref.getName().startsWith(R_HEADS) || ref.getName().equals(forRef)) && ref.getObjectId() != null) {
            try {
                rw.markUninteresting(rw.parseCommit(ref.getObjectId()));
            } catch (IOException e) {
                log.warn(String.format("Invalid ref %s in %s", ref.getName(), project.getName()), e);
            }
        }
    }
}
#end_block

#method_before
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    if (ctl.canForgeAuthor() && ctl.canForgeCommitter() && ctl.canForgeGerritServerIdentity() && ctl.canUploadMerges() && !projectControl.getProjectState().isUseSignedOffBy() && Iterables.isEmpty(rejectCommits) && !RefNames.REFS_CONFIG.equals(ctl.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        return;
    }
    boolean defaultName = Strings.isNullOrEmpty(user.getAccount().getFullName());
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        RevObject parsedObject = walk.parseAny(cmd.getNewId());
        if (!(parsedObject instanceof RevCommit)) {
            return;
        }
        SetMultimap<ObjectId, Ref> existing = HashMultimap.create();
        walk.markStart((RevCommit) parsedObject);
        markHeadsAsUninteresting(walk, existing, cmd.getRefName());
        for (RevCommit c; (c = walk.next()) != null; ) {
            if (existing.keySet().contains(c)) {
                continue;
            } else if (!validCommit(ctl, cmd, c)) {
                break;
            }
            if (defaultName && user.hasEmailAddress(c.getCommitterIdent().getEmailAddress())) {
                try {
                    Account a = db.accounts().get(user.getAccountId());
                    if (a != null && Strings.isNullOrEmpty(a.getFullName())) {
                        a.setFullName(c.getCommitterIdent().getName());
                        db.accounts().update(Collections.singleton(a));
                        user.getAccount().setFullName(a.getFullName());
                        accountCache.evict(a.getId());
                    }
                } catch (OrmException e) {
                    log.warn("Cannot default full_name", e);
                } finally {
                    defaultName = false;
                }
            }
        }
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#method_after
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    if (ctl.canForgeAuthor() && ctl.canForgeCommitter() && ctl.canForgeGerritServerIdentity() && ctl.canUploadMerges() && !projectControl.getProjectState().isUseSignedOffBy() && Iterables.isEmpty(rejectCommits) && !RefNames.REFS_CONFIG.equals(ctl.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        return;
    }
    boolean defaultName = Strings.isNullOrEmpty(user.getAccount().getFullName());
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        RevObject parsedObject = walk.parseAny(cmd.getNewId());
        if (!(parsedObject instanceof RevCommit)) {
            return;
        }
        SetMultimap<ObjectId, Ref> existing = changeRefsById();
        walk.markStart((RevCommit) parsedObject);
        markHeadsAsUninteresting(walk, cmd.getRefName());
        for (RevCommit c; (c = walk.next()) != null; ) {
            if (existing.keySet().contains(c)) {
                continue;
            } else if (!validCommit(ctl, cmd, c)) {
                break;
            }
            if (defaultName && user.hasEmailAddress(c.getCommitterIdent().getEmailAddress())) {
                try {
                    Account a = db.accounts().get(user.getAccountId());
                    if (a != null && Strings.isNullOrEmpty(a.getFullName())) {
                        a.setFullName(c.getCommitterIdent().getName());
                        db.accounts().update(Collections.singleton(a));
                        user.getAccount().setFullName(a.getFullName());
                        accountCache.evict(a.getId());
                    }
                } catch (OrmException e) {
                    log.warn("Cannot default full_name", e);
                } finally {
                    defaultName = false;
                }
            }
        }
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#end_block

#method_before
@BeforeClass
public static void setTimeForTesting() {
    final long clockStepMs = MILLISECONDS.convert(1, SECONDS);
    final AtomicLong clockMs = new AtomicLong(new DateTime(2009, 9, 30, 17, 0, 0).getMillis());
    DateTimeUtils.setCurrentMillisProvider(new MillisProvider() {

        @Override
        public long getMillis() {
            return clockMs.getAndAdd(clockStepMs);
        }
    });
}
#method_after
@BeforeClass
public static void setTimeForTesting() {
    TestTimeUtil.resetWithClockStep(1, SECONDS);
}
#end_block

#method_before
@AfterClass
public static void restoreTime() {
    DateTimeUtils.setCurrentMillisSystem();
}
#method_after
@AfterClass
public static void restoreTime() {
    TestTimeUtil.useSystemTime();
}
#end_block

#method_before
@Test
public void testCreateNewChangeForAllNotInTarget() throws Exception {
    ProjectConfig config = projectCache.checkedGet(project).getConfig();
    config.getProject().setCreateNewChangeForAllNotInTarget(InheritableBoolean.TRUE);
    saveProjectConfig(project, config);
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "a.txt", "content");
    PushOneCommit.Result r = push.to("refs/for/master");
    r.assertOkStatus();
    push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "b.txt", "anotherContent");
    r = push.to("refs/for/master");
    r.assertOkStatus();
}
#method_after
@Test
public void testCreateNewChangeForAllNotInTarget() throws Exception {
    ProjectConfig config = projectCache.checkedGet(project).getConfig();
    config.getProject().setCreateNewChangeForAllNotInTarget(InheritableBoolean.TRUE);
    saveProjectConfig(project, config);
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "a.txt", "content");
    PushOneCommit.Result r = push.to("refs/for/master");
    r.assertOkStatus();
    push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "b.txt", "anotherContent");
    r = push.to("refs/for/master");
    r.assertOkStatus();
    gApi.projects().name(project.get()).branch("otherBranch").create(new BranchInput());
    PushOneCommit.Result r2 = push.to("refs/for/otherBranch");
    r2.assertOkStatus();
    assertTwoChangesWithSameRevision(r);
}
#end_block

#method_before
@Test
public void testPushSameCommitTwiceUsingMagicBranchBaseOption() throws Exception {
    grant(Permission.PUSH, project, "refs/heads/master");
    PushOneCommit.Result rBase = pushTo("refs/heads/master");
    rBase.assertOkStatus();
    gApi.projects().name(project.get()).branch("foo").create(new BranchInput());
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "b.txt", "anotherContent");
    PushOneCommit.Result r = push.to("refs/for/master");
    r.assertOkStatus();
    PushResult pr = GitUtil.pushHead(testRepo, "refs/for/foo%base=" + rBase.getCommitId().name(), false, false);
    assertThat(pr.getMessages()).contains("changes: new: 1, refs: 1, done");
    List<ChangeInfo> changes = query(r.getCommitId().name());
    assertThat(changes).hasSize(2);
    ChangeInfo c1 = get(changes.get(0).id);
    ChangeInfo c2 = get(changes.get(1).id);
    assertThat(c1.project).isEqualTo(c2.project);
    assertThat(c1.branch).isNotEqualTo(c2.branch);
    assertThat(c1.changeId).isEqualTo(c2.changeId);
    assertThat(c1.currentRevision).isEqualTo(c2.currentRevision);
}
#method_after
@Test
public void testPushSameCommitTwiceUsingMagicBranchBaseOption() throws Exception {
    grant(Permission.PUSH, project, "refs/heads/master");
    PushOneCommit.Result rBase = pushTo("refs/heads/master");
    rBase.assertOkStatus();
    gApi.projects().name(project.get()).branch("foo").create(new BranchInput());
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "b.txt", "anotherContent");
    PushOneCommit.Result r = push.to("refs/for/master");
    r.assertOkStatus();
    PushResult pr = GitUtil.pushHead(testRepo, "refs/for/foo%base=" + rBase.getCommitId().name(), false, false);
    assertThat(pr.getMessages()).contains("changes: new: 1, refs: 1, done");
    assertTwoChangesWithSameRevision(r);
}
#end_block

#method_before
private ChangeInfo toChangeInfo(ChangeData cd, Optional<PatchSet.Id> limitToPsId) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    ChangeInfo out = new ChangeInfo();
    if (has(CHECK)) {
        out.problems = checkerProvider.get().check(cd.change(), fix).problems();
        // If any problems were fixed, the ChangeData needs to be reloaded.
        for (ProblemInfo p : out.problems) {
            if (p.status == ProblemInfo.Status.FIXED) {
                cd = changeDataFactory.create(cd.db(), cd.project(), cd.getId());
                break;
            }
        }
    }
    Change in = cd.change();
    CurrentUser user = userProvider.get();
    ChangeControl ctl = cd.changeControl().forUser(user);
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    out.hashtags = cd.hashtags();
    out.changeId = in.getKey().get();
    if (in.getStatus() != Change.Status.MERGED) {
        SubmitTypeRecord str = cd.submitTypeRecord();
        if (str.isOk()) {
            out.submitType = str.type;
        }
        out.mergeable = cd.isMergeable();
    }
    out.submittable = Submit.submittable(cd);
    ChangedLines changedLines = cd.changedLines();
    if (changedLines != null) {
        out.insertions = changedLines.insertions;
        out.deletions = changedLines.deletions;
    }
    out.subject = in.getSubject();
    out.status = in.getStatus().asChangeStatus();
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    if (user.isIdentifiedUser()) {
        Collection<String> stars = cd.stars().get(user.getAccountId());
        out.starred = stars.contains(StarredChangesUtil.DEFAULT_LABEL) ? true : null;
        if (!stars.isEmpty()) {
            out.stars = stars;
        }
    }
    if (in.getStatus().isOpen() && has(REVIEWED) && user.isIdentifiedUser()) {
        Account.Id accountId = user.getAccountId();
        out.reviewed = cd.reviewedBy().contains(accountId) ? true : null;
    }
    out.labels = labelsFor(ctl, cd, has(LABELS), has(DETAILED_LABELS));
    out.submitted = getSubmittedOn(cd);
    if (out.labels != null && has(DETAILED_LABELS)) {
        // list permitted labels, since users can't vote on those patch sets.
        if (!limitToPsId.isPresent() || limitToPsId.get().equals(in.currentPatchSetId())) {
            out.permittedLabels = permittedLabels(ctl, cd);
        }
        out.removableReviewers = removableReviewers(ctl, out.labels.values());
        out.reviewers = new HashMap<>();
        for (Map.Entry<ReviewerStateInternal, Map<Account.Id, Timestamp>> e : cd.reviewers().asTable().rowMap().entrySet()) {
            out.reviewers.put(e.getKey().asReviewerState(), toAccountInfo(e.getValue().keySet()));
        }
    }
    boolean needMessages = has(MESSAGES);
    boolean needRevisions = has(ALL_REVISIONS) || has(CURRENT_REVISION) || limitToPsId.isPresent();
    Map<PatchSet.Id, PatchSet> src;
    if (needMessages || needRevisions) {
        src = loadPatchSets(cd, limitToPsId);
    } else {
        src = null;
    }
    if (needMessages) {
        out.messages = messages(ctl, cd, src);
    }
    finish(out);
    if (needRevisions) {
        out.revisions = revisions(ctl, src);
        if (out.revisions != null) {
            for (Map.Entry<String, RevisionInfo> entry : out.revisions.entrySet()) {
                if (entry.getValue().isCurrent) {
                    out.currentRevision = entry.getKey();
                    break;
                }
            }
        }
    }
    if (has(CURRENT_ACTIONS) || has(CHANGE_ACTIONS)) {
        actionJson.addChangeActions(out, ctl);
    }
    return out;
}
#method_after
private ChangeInfo toChangeInfo(ChangeData cd, Optional<PatchSet.Id> limitToPsId) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    ChangeInfo out = new ChangeInfo();
    if (has(CHECK)) {
        out.problems = checkerProvider.get().check(cd.change(), fix).problems();
        // If any problems were fixed, the ChangeData needs to be reloaded.
        for (ProblemInfo p : out.problems) {
            if (p.status == ProblemInfo.Status.FIXED) {
                cd = changeDataFactory.create(cd.db(), cd.project(), cd.getId());
                break;
            }
        }
    }
    Change in = cd.change();
    CurrentUser user = userProvider.get();
    ChangeControl ctl = cd.changeControl().forUser(user);
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    out.hashtags = cd.hashtags();
    out.changeId = in.getKey().get();
    if (in.getStatus() != Change.Status.MERGED) {
        SubmitTypeRecord str = cd.submitTypeRecord();
        if (str.isOk()) {
            out.submitType = str.type;
        }
        out.mergeable = cd.isMergeable();
    }
    out.submittable = Submit.submittable(cd);
    Optional<ChangedLines> changedLines = cd.changedLines();
    if (changedLines.isPresent()) {
        out.insertions = changedLines.get().insertions;
        out.deletions = changedLines.get().deletions;
    }
    out.subject = in.getSubject();
    out.status = in.getStatus().asChangeStatus();
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    if (user.isIdentifiedUser()) {
        Collection<String> stars = cd.stars().get(user.getAccountId());
        out.starred = stars.contains(StarredChangesUtil.DEFAULT_LABEL) ? true : null;
        if (!stars.isEmpty()) {
            out.stars = stars;
        }
    }
    if (in.getStatus().isOpen() && has(REVIEWED) && user.isIdentifiedUser()) {
        Account.Id accountId = user.getAccountId();
        out.reviewed = cd.reviewedBy().contains(accountId) ? true : null;
    }
    out.labels = labelsFor(ctl, cd, has(LABELS), has(DETAILED_LABELS));
    out.submitted = getSubmittedOn(cd);
    if (out.labels != null && has(DETAILED_LABELS)) {
        // list permitted labels, since users can't vote on those patch sets.
        if (!limitToPsId.isPresent() || limitToPsId.get().equals(in.currentPatchSetId())) {
            out.permittedLabels = permittedLabels(ctl, cd);
        }
        out.removableReviewers = removableReviewers(ctl, out.labels.values());
        out.reviewers = new HashMap<>();
        for (Map.Entry<ReviewerStateInternal, Map<Account.Id, Timestamp>> e : cd.reviewers().asTable().rowMap().entrySet()) {
            out.reviewers.put(e.getKey().asReviewerState(), toAccountInfo(e.getValue().keySet()));
        }
    }
    boolean needMessages = has(MESSAGES);
    boolean needRevisions = has(ALL_REVISIONS) || has(CURRENT_REVISION) || limitToPsId.isPresent();
    Map<PatchSet.Id, PatchSet> src;
    if (needMessages || needRevisions) {
        src = loadPatchSets(cd, limitToPsId);
    } else {
        src = null;
    }
    if (needMessages) {
        out.messages = messages(ctl, cd, src);
    }
    finish(out);
    if (needRevisions) {
        out.revisions = revisions(ctl, cd, src);
        if (out.revisions != null) {
            for (Map.Entry<String, RevisionInfo> entry : out.revisions.entrySet()) {
                if (entry.getValue().isCurrent) {
                    out.currentRevision = entry.getKey();
                    break;
                }
            }
        }
    }
    if (has(CURRENT_ACTIONS) || has(CHANGE_ACTIONS)) {
        actionJson.addChangeActions(out, ctl);
    }
    return out;
}
#end_block

#method_before
private Map<String, RevisionInfo> revisions(ChangeControl ctl, Map<PatchSet.Id, PatchSet> map) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    Map<String, RevisionInfo> res = new LinkedHashMap<>();
    for (PatchSet in : map.values()) {
        if ((has(ALL_REVISIONS) || in.getId().equals(ctl.getChange().currentPatchSetId())) && ctl.isPatchVisible(in, db.get())) {
            res.put(in.getRevision().get(), toRevisionInfo(ctl, in));
        }
    }
    return res;
}
#method_after
private Map<String, RevisionInfo> revisions(ChangeControl ctl, ChangeData cd, Map<PatchSet.Id, PatchSet> map) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    Map<String, RevisionInfo> res = new LinkedHashMap<>();
    try (Repository repo = repoManager.openRepository(ctl.getProject().getNameKey())) {
        for (PatchSet in : map.values()) {
            if ((has(ALL_REVISIONS) || in.getId().equals(ctl.getChange().currentPatchSetId())) && ctl.isPatchVisible(in, db.get())) {
                res.put(in.getRevision().get(), toRevisionInfo(ctl, cd, in, repo));
            }
        }
        return res;
    }
}
#end_block

#method_before
public RevisionInfo getRevisionInfo(ChangeControl ctl, PatchSet in) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    accountLoader = accountLoaderFactory.create(has(DETAILED_ACCOUNTS));
    RevisionInfo rev = toRevisionInfo(ctl, in);
    accountLoader.fill();
    return rev;
}
#method_after
public RevisionInfo getRevisionInfo(ChangeControl ctl, PatchSet in) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    accountLoader = accountLoaderFactory.create(has(DETAILED_ACCOUNTS));
    try (Repository repo = repoManager.openRepository(ctl.getProject().getNameKey())) {
        RevisionInfo rev = toRevisionInfo(ctl, changeDataFactory.create(db.get(), ctl), in, repo);
        accountLoader.fill();
        return rev;
    }
}
#end_block

#method_before
private RevisionInfo toRevisionInfo(ChangeControl ctl, PatchSet in) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    Change c = ctl.getChange();
    RevisionInfo out = new RevisionInfo();
    out.isCurrent = in.getId().equals(c.currentPatchSetId());
    out._number = in.getId().get();
    out.ref = in.getRefName();
    out.created = in.getCreatedOn();
    out.uploader = accountLoader.get(in.getUploader());
    out.draft = in.isDraft() ? true : null;
    out.fetch = makeFetchMap(ctl, in);
    out.kind = changeKindCache.getChangeKind(db.get(), ctl.getChange(), in);
    boolean setCommit = has(ALL_COMMITS) || (out.isCurrent && has(CURRENT_COMMIT));
    boolean addFooters = out.isCurrent && has(COMMIT_FOOTERS);
    if (setCommit || addFooters) {
        Project.NameKey project = c.getProject();
        try (Repository repo = repoManager.openRepository(project);
            RevWalk rw = new RevWalk(repo)) {
            String rev = in.getRevision().get();
            RevCommit commit = rw.parseCommit(ObjectId.fromString(rev));
            rw.parseBody(commit);
            if (setCommit) {
                out.commit = toCommit(ctl, rw, commit, has(WEB_LINKS));
            }
            if (addFooters) {
                out.commitWithFooters = mergeUtilFactory.create(projectCache.get(project)).createCherryPickCommitMessage(commit, ctl, in.getId());
            }
        }
    }
    if (has(ALL_FILES) || (out.isCurrent && has(CURRENT_FILES))) {
        out.files = fileInfoJson.toFileInfoMap(c, in);
        out.files.remove(Patch.COMMIT_MSG);
    }
    if ((out.isCurrent || (out.draft != null && out.draft)) && has(CURRENT_ACTIONS) && userProvider.get().isIdentifiedUser()) {
        actionJson.addRevisionActions(out, new RevisionResource(changeResourceFactory.create(ctl), in));
    }
    if (has(PUSH_CERTIFICATES)) {
        if (in.getPushCertificate() != null) {
            out.pushCertificate = gpgApi.checkPushCertificate(in.getPushCertificate(), userFactory.create(in.getUploader()));
        } else {
            out.pushCertificate = new PushCertificateInfo();
        }
    }
    return out;
}
#method_after
private RevisionInfo toRevisionInfo(ChangeControl ctl, ChangeData cd, PatchSet in, Repository repo) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    Change c = ctl.getChange();
    RevisionInfo out = new RevisionInfo();
    out.isCurrent = in.getId().equals(c.currentPatchSetId());
    out._number = in.getId().get();
    out.ref = in.getRefName();
    out.created = in.getCreatedOn();
    out.uploader = accountLoader.get(in.getUploader());
    out.draft = in.isDraft() ? true : null;
    out.fetch = makeFetchMap(ctl, in);
    out.kind = changeKindCache.getChangeKind(repo, cd, in);
    boolean setCommit = has(ALL_COMMITS) || (out.isCurrent && has(CURRENT_COMMIT));
    boolean addFooters = out.isCurrent && has(COMMIT_FOOTERS);
    if (setCommit || addFooters) {
        Project.NameKey project = c.getProject();
        try (RevWalk rw = new RevWalk(repo)) {
            String rev = in.getRevision().get();
            RevCommit commit = rw.parseCommit(ObjectId.fromString(rev));
            rw.parseBody(commit);
            if (setCommit) {
                out.commit = toCommit(ctl, rw, commit, has(WEB_LINKS));
            }
            if (addFooters) {
                out.commitWithFooters = mergeUtilFactory.create(projectCache.get(project)).createCherryPickCommitMessage(commit, ctl, in.getId());
            }
        }
    }
    if (has(ALL_FILES) || (out.isCurrent && has(CURRENT_FILES))) {
        out.files = fileInfoJson.toFileInfoMap(c, in);
        out.files.remove(Patch.COMMIT_MSG);
    }
    if ((out.isCurrent || (out.draft != null && out.draft)) && has(CURRENT_ACTIONS) && userProvider.get().isIdentifiedUser()) {
        actionJson.addRevisionActions(out, new RevisionResource(changeResourceFactory.create(ctl), in));
    }
    if (has(PUSH_CERTIFICATES)) {
        if (in.getPushCertificate() != null) {
            out.pushCertificate = gpgApi.checkPushCertificate(in.getPushCertificate(), userFactory.create(in.getUploader()));
        } else {
            out.pushCertificate = new PushCertificateInfo();
        }
    }
    return out;
}
#end_block

#method_before
public Optional<ChangedLines> changedLines() throws OrmException {
    if (changedLines == null) {
        Optional<ChangedLines> cl = Optional.absent();
        Change c = change();
        if (c != null) {
            PatchSet ps = currentPatchSet();
            if (ps != null) {
                PatchList p;
                try {
                    p = patchListCache.get(c, ps);
                    cl = Optional.of(new ChangedLines(p.getInsertions(), p.getDeletions()));
                } catch (PatchListNotAvailableException e) {
                // Leave as absent.
                }
            }
        }
        changedLines = cl;
    }
    return changedLines;
}
#method_after
public Optional<ChangedLines> changedLines() throws OrmException {
    if (changedLines == null) {
        changedLines = computeChangedLines();
    }
    return changedLines;
}
#end_block

#method_before
@Override
protected Predicate<ChangeData> enforceVisibility(Predicate<ChangeData> pred) {
    return new AndChangeSource(ImmutableList.of(pred, new IsVisibleToPredicate(db, notesFactory, changeControlFactory, userProvider.get())), start);
}
#method_after
@Override
public ChangeQueryProcessor enforceVisibility(boolean enforce) {
    super.enforceVisibility(enforce);
    return this;
}
#end_block

#method_before
@Override
public int run() throws Exception {
    mustHaveValidSite();
    dbInjector = createDbInjector(MULTI_USER);
    globalConfig = dbInjector.getInstance(Key.get(Config.class, GerritServerConfig.class));
    threads = ThreadLimiter.limitThreads(dbInjector, threads);
    checkNotSlaveMode();
    disableLuceneAutomaticCommit();
    disableChangeCache();
    LifecycleManager dbManager = new LifecycleManager();
    dbManager.add(dbInjector);
    dbManager.start();
    sysInjector = createSysInjector();
    LifecycleManager sysManager = new LifecycleManager();
    sysManager.add(sysInjector);
    sysManager.start();
    sysInjector.injectMembers(this);
    try {
        boolean ok = true;
        for (IndexDefinition<?, ?, ?> def : indexDefs) {
            if (listIndices) {
                System.out.format("%s\n", def.getName());
            } else {
                ok &= reindex(def);
            }
        }
        return ok ? 0 : 1;
    } catch (Exception e) {
        throw die(e.getMessage(), e);
    } finally {
        sysManager.stop();
        dbManager.stop();
    }
}
#method_after
@Override
public int run() throws Exception {
    mustHaveValidSite();
    dbInjector = createDbInjector(MULTI_USER);
    globalConfig = dbInjector.getInstance(Key.get(Config.class, GerritServerConfig.class));
    threads = ThreadLimiter.limitThreads(dbInjector, threads);
    checkNotSlaveMode();
    disableLuceneAutomaticCommit();
    disableChangeCache();
    LifecycleManager dbManager = new LifecycleManager();
    dbManager.add(dbInjector);
    dbManager.start();
    sysInjector = createSysInjector();
    LifecycleManager sysManager = new LifecycleManager();
    sysManager.add(sysInjector);
    sysManager.start();
    sysInjector.injectMembers(this);
    try {
        boolean ok = list ? list() : reindex();
        return ok ? 0 : 1;
    } catch (Exception e) {
        throw die(e.getMessage(), e);
    } finally {
        sysManager.stop();
        dbManager.stop();
    }
}
#end_block

#method_before
private <K, V, I extends Index<K, V>> boolean reindex(IndexDefinition<K, V, I> def) throws IOException {
    I index = def.getIndexCollection().getSearchIndex();
    checkNotNull(index, "no active search index configured for %s", def.getName());
    index.markReady(false);
    index.deleteAll();
    SiteIndexer<K, V, I> siteIndexer = def.getSiteIndexer();
    siteIndexer.setProgressOut(System.err);
    siteIndexer.setVerboseOut(verbose ? System.out : NullOutputStream.INSTANCE);
    SiteIndexer.Result result = siteIndexer.indexAll(index);
    int n = result.doneCount() + result.failedCount();
    double t = result.elapsed(TimeUnit.MILLISECONDS) / 1000d;
    System.out.format("Reindexed %d documents in %s index in %.01fs (%.01f/s)\n", n, def.getName(), t, n / t);
    if (result.success()) {
        index.markReady(true);
    }
    return result.success();
}
#method_after
private boolean reindex() throws IOException {
    boolean ok = true;
    for (IndexDefinition<?, ?, ?> def : indexDefs) {
        ok &= reindex(def);
    }
    return ok;
}
#end_block

#method_before
private Injector createSysInjector() {
    Map<String, Integer> versions = new HashMap<>();
    if (changesVersion != null) {
        versions.put(ChangeSchemaDefinitions.INSTANCE.getName(), changesVersion);
    }
    List<Module> modules = Lists.newArrayList();
    Module indexModule;
    switch(IndexModule.getIndexType(dbInjector)) {
        case LUCENE:
            indexModule = LuceneIndexModule.singleVersionWithExplicitVersions(versions, threads);
            break;
        default:
            throw new IllegalStateException("unsupported index.type");
    }
    modules.add(indexModule);
    // Scan changes from git instead of relying on the secondary index, as we
    // will have just deleted the old (possibly corrupt) index.
    modules.add(ScanningChangeCacheImpl.module());
    modules.add(dbInjector.getInstance(BatchProgramModule.class));
    return dbInjector.createChildInjector(modules);
}
#method_after
private Injector createSysInjector() {
    Map<String, Integer> versions = new HashMap<>();
    if (changesVersion != null) {
        versions.put(ChangeSchemaDefinitions.INSTANCE.getName(), changesVersion);
    }
    List<Module> modules = new ArrayList<>();
    Module indexModule;
    switch(IndexModule.getIndexType(dbInjector)) {
        case LUCENE:
            indexModule = LuceneIndexModule.singleVersionWithExplicitVersions(versions, threads);
            break;
        default:
            throw new IllegalStateException("unsupported index.type");
    }
    modules.add(indexModule);
    modules.add(dbInjector.getInstance(BatchProgramModule.class));
    modules.add(new FactoryModule() {

        @Override
        protected void configure() {
            factory(ChangeResource.Factory.class);
        }
    });
    return dbInjector.createChildInjector(modules);
}
#end_block

#method_before
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    final List<String> idList = receiveEvent.commit.getFooterLines(FooterConstants.CHANGE_ID);
    List<CommitValidationMessage> messages = new LinkedList<>();
    if (idList.isEmpty()) {
        if (projectControl.getProjectState().isRequireChangeID()) {
            String shortMsg = receiveEvent.commit.getShortMessage();
            String changeIdPrefix = FooterConstants.CHANGE_ID.getName() + ":";
            if (shortMsg.startsWith(changeIdPrefix) && shortMsg.substring(changeIdPrefix.length()).trim().matches("^I[0-9a-f]{8,}.*$")) {
                throw new CommitValidationException("missing subject; Change-Id must be in commit message footer");
            } else {
                String errMsg = "missing Change-Id in commit message footer";
                messages.add(getMissingChangeIdErrorMsg(errMsg, receiveEvent.commit));
                throw new CommitValidationException(errMsg, messages);
            }
        }
    } else if (idList.size() > 1) {
        throw new CommitValidationException("multiple Change-Id lines in commit message footer", messages);
    } else {
        final String v = idList.get(idList.size() - 1).trim();
        if (!v.matches("^I[0-9a-f]{8,}.*$")) {
            final String errMsg = "missing or invalid Change-Id line format in commit message footer";
            messages.add(getMissingChangeIdErrorMsg(errMsg, receiveEvent.commit));
            throw new CommitValidationException(errMsg, messages);
        }
    }
    return Collections.emptyList();
}
#method_after
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    RevCommit commit = receiveEvent.commit;
    List<CommitValidationMessage> messages = new LinkedList<>();
    List<String> idList = commit.getFooterLines(FooterConstants.CHANGE_ID);
    String sha1 = commit.abbreviate(SHA1_LENGTH).name();
    if (idList.isEmpty()) {
        if (projectControl.getProjectState().isRequireChangeID()) {
            String shortMsg = commit.getShortMessage();
            if (shortMsg.startsWith(CHANGE_ID_PREFIX) && CHANGE_ID.matcher(shortMsg.substring(CHANGE_ID_PREFIX.length()).trim()).matches()) {
                String errMsg = String.format(MISSING_SUBJECT_MSG, sha1);
                throw new CommitValidationException(errMsg);
            }
            String errMsg = String.format(MISSING_CHANGE_ID_MSG, sha1);
            messages.add(getMissingChangeIdErrorMsg(errMsg, commit));
            throw new CommitValidationException(errMsg, messages);
        }
    } else if (idList.size() > 1) {
        String errMsg = String.format(MULTIPLE_CHANGE_ID_MSG, sha1);
        throw new CommitValidationException(errMsg, messages);
    } else {
        String v = idList.get(idList.size() - 1).trim();
        if (!CHANGE_ID.matcher(v).matches()) {
            String errMsg = String.format(INVALID_CHANGE_ID_MSG, sha1);
            messages.add(getMissingChangeIdErrorMsg(errMsg, receiveEvent.commit));
            throw new CommitValidationException(errMsg, messages);
        }
    }
    return Collections.emptyList();
}
#end_block

#method_before
private CommitValidationMessage getMissingChangeIdErrorMsg(final String errMsg, final RevCommit c) {
    final String changeId = "Change-Id:";
    StringBuilder sb = new StringBuilder();
    sb.append("ERROR: ").append(errMsg);
    if (c.getFullMessage().indexOf(changeId) >= 0) {
        String[] lines = c.getFullMessage().trim().split("\n");
        String lastLine = lines.length > 0 ? lines[lines.length - 1] : "";
        if (lastLine.indexOf(changeId) == -1) {
            sb.append('\n');
            sb.append('\n');
            sb.append("Hint: A potential Change-Id was found, but it was not in the ");
            sb.append("footer (last paragraph) of the commit message.");
        }
    }
    sb.append('\n');
    sb.append('\n');
    sb.append("Hint: To automatically insert Change-Id, install the hook:\n");
    sb.append(getCommitMessageHookInstallationHint());
    sb.append('\n');
    sb.append("And then amend the commit:\n");
    sb.append("  git commit --amend\n");
    return new CommitValidationMessage(sb.toString(), false);
}
#method_after
private CommitValidationMessage getMissingChangeIdErrorMsg(final String errMsg, final RevCommit c) {
    StringBuilder sb = new StringBuilder();
    sb.append("ERROR: ").append(errMsg);
    if (c.getFullMessage().indexOf(CHANGE_ID_PREFIX) >= 0) {
        String[] lines = c.getFullMessage().trim().split("\n");
        String lastLine = lines.length > 0 ? lines[lines.length - 1] : "";
        if (lastLine.indexOf(CHANGE_ID_PREFIX) == -1) {
            sb.append('\n');
            sb.append('\n');
            sb.append("Hint: A potential ");
            sb.append(FooterConstants.CHANGE_ID.getName());
            sb.append("Change-Id was found, but it was not in the ");
            sb.append("footer (last paragraph) of the commit message.");
        }
    }
    sb.append('\n');
    sb.append('\n');
    sb.append("Hint: To automatically insert ");
    sb.append(FooterConstants.CHANGE_ID.getName());
    sb.append(", install the hook:\n");
    sb.append(getCommitMessageHookInstallationHint());
    sb.append('\n');
    sb.append("And then amend the commit:\n");
    sb.append("  git commit --amend\n");
    return new CommitValidationMessage(sb.toString(), false);
}
#end_block

#method_before
private static String getGerritUrl(String canonicalWebUrl) {
    if (canonicalWebUrl != null) {
        return CharMatcher.is('/').trimTrailingFrom(canonicalWebUrl);
    } else {
        return "http://" + getGerritHost(canonicalWebUrl);
    }
}
#method_after
private static String getGerritUrl(String canonicalWebUrl) {
    if (canonicalWebUrl != null) {
        return CharMatcher.is('/').trimTrailingFrom(canonicalWebUrl);
    }
    return "http://" + getGerritHost(canonicalWebUrl);
}
#end_block

#method_before
@Override
public void updateChange(ChangeContext ctx) throws AuthException, BadRequestException, OrmException, IOException {
    if (input == null || (input.add == null && input.remove == null)) {
        updatedHashtags = ImmutableSortedSet.of();
        return;
    }
    if (!ctx.getChangeControl().canEditHashtags()) {
        throw new AuthException("Editing hashtags not permitted");
    }
    ChangeUpdate update = ctx.getChangeUpdate();
    ChangeNotes notes = update.getChangeNotes().load();
    Set<String> existingHashtags = notes.getHashtags();
    Set<String> updated = new HashSet<>();
    toAdd = new HashSet<>(extractTags(input.add));
    toRemove = new HashSet<>(extractTags(input.remove));
    try {
        for (HashtagValidationListener validator : validationListeners) {
            validator.validateHashtags(update.getChange(), toAdd, toRemove);
        }
    } catch (ValidationException e) {
        throw new BadRequestException(e.getMessage());
    }
    if (existingHashtags != null && !existingHashtags.isEmpty()) {
        updated.addAll(existingHashtags);
        toAdd.removeAll(existingHashtags);
        toRemove.retainAll(existingHashtags);
    }
    if (updated()) {
        updated.addAll(toAdd);
        updated.removeAll(toRemove);
        update.setHashtags(updated);
    }
    change = update.getChange();
    updatedHashtags = ImmutableSortedSet.copyOf(updated);
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws AuthException, BadRequestException, OrmException, IOException {
    if (!notesMigration.readChanges()) {
        throw new BadRequestException("Cannot add hashtags; NoteDb is disabled");
    }
    if (input == null || (input.add == null && input.remove == null)) {
        updatedHashtags = ImmutableSortedSet.of();
        return false;
    }
    if (!ctx.getControl().canEditHashtags()) {
        throw new AuthException("Editing hashtags not permitted");
    }
    change = ctx.getChange();
    ChangeUpdate update = ctx.getUpdate(change.currentPatchSetId());
    ChangeNotes notes = update.getNotes().load();
    Set<String> existingHashtags = notes.getHashtags();
    Set<String> updated = new HashSet<>();
    toAdd = new HashSet<>(extractTags(input.add));
    toRemove = new HashSet<>(extractTags(input.remove));
    try {
        for (HashtagValidationListener validator : validationListeners) {
            validator.validateHashtags(update.getChange(), toAdd, toRemove);
        }
    } catch (ValidationException e) {
        throw new BadRequestException(e.getMessage());
    }
    updated.addAll(existingHashtags);
    toAdd.removeAll(existingHashtags);
    toRemove.retainAll(existingHashtags);
    if (updated()) {
        updated.addAll(toAdd);
        updated.removeAll(toRemove);
        update.setHashtags(updated);
        addMessage(ctx, update);
    }
    updatedHashtags = ImmutableSortedSet.copyOf(updated);
    return true;
}
#end_block

#method_before
@Override
protected ProjectAccess updateProjectConfig(ProjectControl ctl, ProjectConfig config, MetaDataUpdate md, boolean parentProjectUpdate) throws IOException, NoSuchProjectException, ConfigInvalidException {
    RevCommit commit = config.commit(md);
    gitRefUpdated.fire(config.getProject().getNameKey(), RefNames.REFS_CONFIG, base, commit.getId(), user.getAccount());
    projectCache.evict(config.getProject());
    return projectAccessFactory.create(projectName).call();
}
#method_after
@Override
protected ProjectAccess updateProjectConfig(CurrentUser user, ProjectConfig config, MetaDataUpdate md, boolean parentProjectUpdate) throws IOException, NoSuchProjectException, ConfigInvalidException {
    RevCommit commit = config.commit(md);
    gitRefUpdated.fire(config.getProject().getNameKey(), RefNames.REFS_CONFIG, base, commit.getId(), user.asIdentifiedUser().getAccount());
    projectCache.evict(config.getProject());
    return projectAccessFactory.create(projectName).call();
}
#end_block

#method_before
@Override
public Response<?> apply(ProjectResource project, Input input) throws OrmException, IOException, ResourceConflictException {
    input = Input.init(input);
    try (Repository r = repoManager.openRepository(project.getNameKey())) {
        BatchRefUpdate batchUpdate = r.getRefDatabase().newBatchUpdate();
        for (String branch : input.branches) {
            batchUpdate.addCommand(createDeleteCommand(project, r, branch));
        }
        try (RevWalk rw = new RevWalk(r)) {
            batchUpdate.execute(rw, NullProgressMonitor.INSTANCE);
        }
        StringBuilder errorMessages = new StringBuilder();
        for (ReceiveCommand command : batchUpdate.getCommands()) {
            if (command.getResult() == Result.OK) {
                postDeletion(project, command);
            } else {
                appendAndLogErrorMessage(errorMessages, command);
            }
        }
        if (errorMessages.length() > 0) {
            throw new ResourceConflictException(errorMessages.toString());
        }
    }
    return Response.none();
}
#method_after
@Override
public Response<?> apply(ProjectResource project, DeleteBranchesInput input) throws OrmException, IOException, ResourceConflictException {
    if (input == null) {
        input = new DeleteBranchesInput();
    }
    if (input.branches == null) {
        input.branches = Lists.newArrayListWithCapacity(1);
    }
    try (Repository r = repoManager.openRepository(project.getNameKey())) {
        BatchRefUpdate batchUpdate = r.getRefDatabase().newBatchUpdate();
        for (String branch : input.branches) {
            batchUpdate.addCommand(createDeleteCommand(project, r, branch));
        }
        try (RevWalk rw = new RevWalk(r)) {
            batchUpdate.execute(rw, NullProgressMonitor.INSTANCE);
        }
        StringBuilder errorMessages = new StringBuilder();
        for (ReceiveCommand command : batchUpdate.getCommands()) {
            if (command.getResult() == Result.OK) {
                postDeletion(project, command);
            } else {
                appendAndLogErrorMessage(errorMessages, command);
            }
        }
        if (errorMessages.length() > 0) {
            throw new ResourceConflictException(errorMessages.toString());
        }
    }
    return Response.none();
}
#end_block

#method_before
private void appendAndLogErrorMessage(StringBuilder errorMessages, ReceiveCommand cmd) {
    String msg = null;
    switch(cmd.getResult()) {
        case REJECTED_CURRENT_BRANCH:
            msg = format("Cannot delete %s: it is the current branch", cmd.getRefName());
            break;
        case REJECTED_OTHER_REASON:
            msg = format("Cannot delete %s: %s", cmd.getRefName(), cmd.getMessage());
            break;
        default:
            msg = format("Cannot delete %s: %s", cmd.getRefName(), cmd.getResult());
            break;
    }
    log.error(msg);
    errorMessages.append(msg);
    errorMessages.append("\n");
}
#method_after
private void appendAndLogErrorMessage(StringBuilder errorMessages, ReceiveCommand cmd) {
    String msg = null;
    switch(cmd.getResult()) {
        case REJECTED_CURRENT_BRANCH:
            msg = format("Cannot delete %s: it is the current branch", cmd.getRefName());
            break;
        case REJECTED_OTHER_REASON:
            msg = format("Cannot delete %s: %s", cmd.getRefName(), cmd.getMessage());
            break;
        case LOCK_FAILURE:
        case NOT_ATTEMPTED:
        case OK:
        case REJECTED_MISSING_OBJECT:
        case REJECTED_NOCREATE:
        case REJECTED_NODELETE:
        case REJECTED_NONFASTFORWARD:
        default:
            msg = format("Cannot delete %s: %s", cmd.getRefName(), cmd.getResult());
            break;
    }
    log.error(msg);
    errorMessages.append(msg);
    errorMessages.append("\n");
}
#end_block

#method_before
private void postDeletion(ProjectResource project, ReceiveCommand cmd) throws OrmException {
    referenceUpdated.fire(project.getNameKey(), cmd, identifiedUser.get().getAccount());
    Branch.NameKey branchKey = new Branch.NameKey(project.getNameKey(), cmd.getRefName());
    ResultSet<SubmoduleSubscription> submoduleSubscriptions = dbProvider.get().submoduleSubscriptions().bySuperProject(branchKey);
    dbProvider.get().submoduleSubscriptions().delete(submoduleSubscriptions);
}
#method_after
private void postDeletion(ProjectResource project, ReceiveCommand cmd) {
    referenceUpdated.fire(project.getNameKey(), cmd, identifiedUser.get().getAccount());
}
#end_block

#method_before
@Override
public BranchInfo apply(ProjectResource rsrc, Input input) throws BadRequestException, AuthException, ResourceConflictException, IOException {
    if (input == null) {
        input = new Input();
    }
    if (input.ref != null && !ref.equals(input.ref)) {
        throw new BadRequestException("ref must match URL");
    }
    if (input.revision == null) {
        input.revision = Constants.HEAD;
    }
    while (ref.startsWith("/")) {
        ref = ref.substring(1);
    }
    ref = RefNames.fullName(ref);
    if (!Repository.isValidRefName(ref)) {
        throw new BadRequestException("invalid branch name \"" + ref + "\"");
    }
    if (MagicBranch.isMagicBranch(ref)) {
        throw new BadRequestException("not allowed to create branches under \"" + MagicBranch.getMagicRefNamePrefix(ref) + "\"");
    }
    final Branch.NameKey name = new Branch.NameKey(rsrc.getNameKey(), ref);
    final RefControl refControl = rsrc.getControl().controlForRef(name);
    try (Repository repo = repoManager.openRepository(rsrc.getNameKey())) {
        final ObjectId revid = parseBaseRevision(repo, rsrc.getNameKey(), input.revision);
        final RevWalk rw = verifyConnected(repo, revid);
        RevObject object = rw.parseAny(revid);
        if (ref.startsWith(Constants.R_HEADS)) {
            // 
            try {
                object = rw.parseCommit(object);
            } catch (IncorrectObjectTypeException notCommit) {
                throw new BadRequestException("\"" + input.revision + "\" not a commit");
            }
        }
        rw.reset();
        if (!refControl.canCreate(db.get(), rw, object)) {
            throw new AuthException("Cannot create \"" + ref + "\"");
        }
        try {
            final RefUpdate u = repo.updateRef(ref);
            u.setExpectedOldObjectId(ObjectId.zeroId());
            u.setNewObjectId(object.copy());
            u.setRefLogIdent(identifiedUser.get().newRefLogIdent());
            u.setRefLogMessage("created via REST from " + input.revision, false);
            final RefUpdate.Result result = u.update(rw);
            switch(result) {
                case FAST_FORWARD:
                case NEW:
                case NO_CHANGE:
                    referenceUpdated.fire(name.getParentKey(), u, ReceiveCommand.Type.CREATE, identifiedUser.get().getAccount());
                    break;
                case LOCK_FAILURE:
                    if (repo.getRefDatabase().exactRef(ref) != null) {
                        throw new ResourceConflictException("branch \"" + ref + "\" already exists");
                    }
                    String refPrefix = getRefPrefix(ref);
                    while (!Constants.R_HEADS.equals(refPrefix)) {
                        if (repo.getRefDatabase().exactRef(refPrefix) != null) {
                            throw new ResourceConflictException("Cannot create branch \"" + ref + "\" since it conflicts with branch \"" + refPrefix + "\".");
                        }
                        refPrefix = getRefPrefix(refPrefix);
                    }
                // $FALL-THROUGH$
                default:
                    {
                        throw new IOException(result.name());
                    }
            }
            BranchInfo info = new BranchInfo();
            info.ref = ref;
            info.revision = revid.getName();
            info.canDelete = refControl.canDelete() ? true : null;
            return info;
        } catch (IOException err) {
            log.error("Cannot create branch \"" + name + "\"", err);
            throw err;
        }
    } catch (InvalidRevisionException e) {
        throw new BadRequestException("invalid revision \"" + input.revision + "\"");
    }
}
#method_after
@Override
public BranchInfo apply(ProjectResource rsrc, BranchInput input) throws BadRequestException, AuthException, ResourceConflictException, IOException {
    if (input == null) {
        input = new BranchInput();
    }
    if (input.ref != null && !ref.equals(input.ref)) {
        throw new BadRequestException("ref must match URL");
    }
    if (input.revision == null) {
        input.revision = Constants.HEAD;
    }
    while (ref.startsWith("/")) {
        ref = ref.substring(1);
    }
    ref = RefNames.fullName(ref);
    if (!Repository.isValidRefName(ref)) {
        throw new BadRequestException("invalid branch name \"" + ref + "\"");
    }
    if (MagicBranch.isMagicBranch(ref)) {
        throw new BadRequestException("not allowed to create branches under \"" + MagicBranch.getMagicRefNamePrefix(ref) + "\"");
    }
    final Branch.NameKey name = new Branch.NameKey(rsrc.getNameKey(), ref);
    final RefControl refControl = rsrc.getControl().controlForRef(name);
    try (Repository repo = repoManager.openRepository(rsrc.getNameKey())) {
        ObjectId revid = RefUtil.parseBaseRevision(repo, rsrc.getNameKey(), input.revision);
        RevWalk rw = RefUtil.verifyConnected(repo, revid);
        RevObject object = rw.parseAny(revid);
        if (ref.startsWith(Constants.R_HEADS)) {
            // 
            try {
                object = rw.parseCommit(object);
            } catch (IncorrectObjectTypeException notCommit) {
                throw new BadRequestException("\"" + input.revision + "\" not a commit");
            }
        }
        rw.reset();
        if (!refControl.canCreate(db.get(), rw, object)) {
            throw new AuthException("Cannot create \"" + ref + "\"");
        }
        try {
            final RefUpdate u = repo.updateRef(ref);
            u.setExpectedOldObjectId(ObjectId.zeroId());
            u.setNewObjectId(object.copy());
            u.setRefLogIdent(identifiedUser.get().newRefLogIdent());
            u.setRefLogMessage("created via REST from " + input.revision, false);
            final RefUpdate.Result result = u.update(rw);
            switch(result) {
                case FAST_FORWARD:
                case NEW:
                case NO_CHANGE:
                    referenceUpdated.fire(name.getParentKey(), u, ReceiveCommand.Type.CREATE, identifiedUser.get().getAccount());
                    break;
                case LOCK_FAILURE:
                    if (repo.getRefDatabase().exactRef(ref) != null) {
                        throw new ResourceConflictException("branch \"" + ref + "\" already exists");
                    }
                    String refPrefix = RefUtil.getRefPrefix(ref);
                    while (!Constants.R_HEADS.equals(refPrefix)) {
                        if (repo.getRefDatabase().exactRef(refPrefix) != null) {
                            throw new ResourceConflictException("Cannot create branch \"" + ref + "\" since it conflicts with branch \"" + refPrefix + "\".");
                        }
                        refPrefix = RefUtil.getRefPrefix(refPrefix);
                    }
                // $FALL-THROUGH$
                case FORCED:
                case IO_FAILURE:
                case NOT_ATTEMPTED:
                case REJECTED:
                case REJECTED_CURRENT_BRANCH:
                case RENAMED:
                default:
                    {
                        throw new IOException(result.name());
                    }
            }
            BranchInfo info = new BranchInfo();
            info.ref = ref;
            info.revision = revid.getName();
            info.canDelete = refControl.canDelete() ? true : null;
            return info;
        } catch (IOException err) {
            log.error("Cannot create branch \"" + name + "\"", err);
            throw err;
        }
    } catch (RefUtil.InvalidRevisionException e) {
        throw new BadRequestException("invalid revision \"" + input.revision + "\"");
    }
}
#end_block

#method_before
protected void updateSuperProjects(ReviewDb db, Collection<Branch.NameKey> updatedBranches) throws SubmoduleException {
    try {
        // These (repo/branch) will be updated later with all the given
        // individual submodule subscriptions
        Multimap<Branch.NameKey, SubmoduleSubscription> targets = HashMultimap.create();
        for (Branch.NameKey updatedBranch : updatedBranches) {
            for (SubmoduleSubscription sub : db.submoduleSubscriptions().bySubmodule(updatedBranch)) {
                targets.put(sub.getSuperProject(), sub);
            }
        }
        updatedSubscribers.addAll(updatedBranches);
        // Update subscribers.
        for (Branch.NameKey dest : targets.keySet()) {
            try {
                if (!updatedSubscribers.add(dest)) {
                    log.error("Possible circular subscription involving " + dest);
                } else {
                    updateGitlinks(db, dest, targets.get(dest));
                }
            } catch (SubmoduleException e) {
                log.warn("Cannot update gitlinks for " + dest, e);
            }
        }
    } catch (OrmException e) {
        logAndThrowSubmoduleException("Cannot read subscription records", e);
    }
}
#method_after
protected void updateSuperProjects(Collection<Branch.NameKey> updatedBranches) throws SubmoduleException {
    if (!enableSuperProjectSubscriptions) {
        logDebug("Updating superprojects disabled");
        return;
    }
    logDebug("Updating superprojects");
    Multimap<Branch.NameKey, SubmoduleSubscription> targets = HashMultimap.create();
    for (Branch.NameKey updatedBranch : updatedBranches) {
        logDebug("Now processing " + updatedBranch);
        Set<Branch.NameKey> checkedTargets = new HashSet<>();
        Set<Branch.NameKey> targetsToProcess = new HashSet<>();
        targetsToProcess.add(updatedBranch);
        while (!targetsToProcess.isEmpty()) {
            Set<Branch.NameKey> newTargets = new HashSet<>();
            for (Branch.NameKey b : targetsToProcess) {
                try {
                    Collection<SubmoduleSubscription> subs = superProjectSubscriptionsForSubmoduleBranch(b);
                    for (SubmoduleSubscription sub : subs) {
                        Branch.NameKey dst = sub.getSuperProject();
                        targets.put(dst, sub);
                        newTargets.add(dst);
                    }
                } catch (IOException e) {
                    throw new SubmoduleException("Cannot find superprojects for " + b, e);
                }
            }
            logDebug("adding to done " + targetsToProcess);
            checkedTargets.addAll(targetsToProcess);
            logDebug("completely done with " + checkedTargets);
            Set<Branch.NameKey> intersection = new HashSet<>(checkedTargets);
            intersection.retainAll(newTargets);
            if (!intersection.isEmpty()) {
                throw new SubmoduleException("Possible circular subscription involving " + updatedBranch);
            }
            targetsToProcess = newTargets;
        }
    }
    for (Branch.NameKey dst : targets.keySet()) {
        try {
            updateGitlinks(dst, targets.get(dst));
        } catch (SubmoduleException e) {
            throw new SubmoduleException("Cannot update gitlinks for " + dst, e);
        }
    }
}
#end_block

#method_before
private void updateGitlinks(ReviewDb db, Branch.NameKey subscriber, Collection<SubmoduleSubscription> updates) throws SubmoduleException {
    PersonIdent author = null;
    StringBuilder msgbuf = new StringBuilder("Updated git submodules\n\n");
    boolean sameAuthorForAll = true;
    try (Repository pdb = repoManager.openRepository(subscriber.getParentKey())) {
        if (pdb.getRef(subscriber.get()) == null) {
            throw new SubmoduleException("The branch was probably deleted from the subscriber repository");
        }
        DirCache dc = readTree(pdb, pdb.getRef(subscriber.get()));
        DirCacheEditor ed = dc.editor();
        for (SubmoduleSubscription s : updates) {
            try (Repository subrepo = repoManager.openRepository(s.getSubmodule().getParentKey());
                RevWalk rw = CodeReviewCommit.newRevWalk(subrepo)) {
                Ref ref = subrepo.getRefDatabase().exactRef(s.getSubmodule().get());
                if (ref == null) {
                    ed.add(new DeletePath(s.getPath()));
                    continue;
                }
                final ObjectId updateTo = ref.getObjectId();
                RevCommit newCommit = rw.parseCommit(updateTo);
                if (author == null) {
                    author = newCommit.getAuthorIdent();
                } else if (!author.equals(newCommit.getAuthorIdent())) {
                    sameAuthorForAll = false;
                }
                DirCacheEntry dce = dc.getEntry(s.getPath());
                ObjectId oldId;
                if (dce != null) {
                    if (!dce.getFileMode().equals(FileMode.GITLINK)) {
                        log.error("Requested to update gitlink " + s.getPath() + " in " + s.getSubmodule().getParentKey().get() + " but entry " + "doesn't have gitlink file mode.");
                        continue;
                    }
                    oldId = dce.getObjectId();
                } else {
                    // This submodule did not exist before. We do not want to add
                    // the full submodule history to the commit message, so omit it.
                    oldId = updateTo;
                }
                ed.add(new PathEdit(s.getPath()) {

                    @Override
                    public void apply(DirCacheEntry ent) {
                        ent.setFileMode(FileMode.GITLINK);
                        ent.setObjectId(updateTo);
                    }
                });
                if (verboseSuperProject) {
                    msgbuf.append("Project: " + s.getSubmodule().getParentKey().get());
                    msgbuf.append(" " + s.getSubmodule().getShortName());
                    msgbuf.append(" " + updateTo.getName());
                    msgbuf.append("\n\n");
                    try {
                        rw.markStart(newCommit);
                        rw.markUninteresting(rw.parseCommit(oldId));
                        for (RevCommit c : rw) {
                            msgbuf.append(c.getFullMessage() + "\n\n");
                        }
                    } catch (IOException e) {
                        logAndThrowSubmoduleException("Could not perform a revwalk to " + "create superproject commit message", e);
                    }
                }
            }
        }
        ed.finish();
        if (!sameAuthorForAll || author == null) {
            author = myIdent;
        }
        ObjectInserter oi = pdb.newObjectInserter();
        ObjectId tree = dc.writeTree(oi);
        ObjectId currentCommitId = pdb.getRef(subscriber.get()).getObjectId();
        CommitBuilder commit = new CommitBuilder();
        commit.setTreeId(tree);
        commit.setParentIds(new ObjectId[] { currentCommitId });
        commit.setAuthor(author);
        commit.setCommitter(myIdent);
        commit.setMessage(msgbuf.toString());
        oi.insert(commit);
        oi.flush();
        ObjectId commitId = oi.idFor(Constants.OBJ_COMMIT, commit.build());
        final RefUpdate rfu = pdb.updateRef(subscriber.get());
        rfu.setForceUpdate(false);
        rfu.setNewObjectId(commitId);
        rfu.setExpectedOldObjectId(currentCommitId);
        rfu.setRefLogMessage("Submit to " + subscriber.getParentKey().get(), true);
        switch(rfu.update()) {
            case NEW:
            case FAST_FORWARD:
                gitRefUpdated.fire(subscriber.getParentKey(), rfu, account);
                // sent to inform users about the updated branch
                break;
            default:
                throw new IOException(rfu.getResult().name());
        }
        // Recursive call: update subscribers of the subscriber
        updateSuperProjects(db, Sets.newHashSet(subscriber));
    } catch (IOException e) {
        throw new SubmoduleException("Cannot update gitlinks for " + subscriber.get(), e);
    }
}
#method_after
private void updateGitlinks(Branch.NameKey subscriber, Collection<SubmoduleSubscription> updates) throws SubmoduleException {
    PersonIdent author = null;
    StringBuilder msgbuf = new StringBuilder("Update git submodules\n\n");
    boolean sameAuthorForAll = true;
    try {
        orm.openRepo(subscriber.getParentKey(), false);
    } catch (NoSuchProjectException | IOException e) {
        throw new SubmoduleException("Cannot access superproject", e);
    }
    OpenRepo or = orm.getRepo(subscriber.getParentKey());
    try {
        Ref r = or.repo.exactRef(subscriber.get());
        if (r == null) {
            throw new SubmoduleException("The branch was probably deleted from the subscriber repository");
        }
        DirCache dc = readTree(r, or.rw);
        DirCacheEditor ed = dc.editor();
        for (SubmoduleSubscription s : updates) {
            try {
                orm.openRepo(s.getSubmodule().getParentKey(), false);
            } catch (NoSuchProjectException | IOException e) {
                throw new SubmoduleException("Cannot access submodule", e);
            }
            OpenRepo subOr = orm.getRepo(s.getSubmodule().getParentKey());
            Repository subrepo = subOr.repo;
            Ref ref = subrepo.getRefDatabase().exactRef(s.getSubmodule().get());
            if (ref == null) {
                ed.add(new DeletePath(s.getPath()));
                continue;
            }
            final ObjectId updateTo = ref.getObjectId();
            RevCommit newCommit = subOr.rw.parseCommit(updateTo);
            subOr.rw.parseBody(newCommit);
            if (author == null) {
                author = newCommit.getAuthorIdent();
            } else if (!author.equals(newCommit.getAuthorIdent())) {
                sameAuthorForAll = false;
            }
            DirCacheEntry dce = dc.getEntry(s.getPath());
            ObjectId oldId;
            if (dce != null) {
                if (!dce.getFileMode().equals(FileMode.GITLINK)) {
                    log.error("Requested to update gitlink " + s.getPath() + " in " + s.getSubmodule().getParentKey().get() + " but entry " + "doesn't have gitlink file mode.");
                    continue;
                }
                oldId = dce.getObjectId();
            } else {
                // This submodule did not exist before. We do not want to add
                // the full submodule history to the commit message, so omit it.
                oldId = updateTo;
            }
            ed.add(new PathEdit(s.getPath()) {

                @Override
                public void apply(DirCacheEntry ent) {
                    ent.setFileMode(FileMode.GITLINK);
                    ent.setObjectId(updateTo);
                }
            });
            if (verboseSuperProject) {
                msgbuf.append("Project: " + s.getSubmodule().getParentKey().get());
                msgbuf.append(" " + s.getSubmodule().getShortName());
                msgbuf.append(" " + updateTo.getName());
                msgbuf.append("\n\n");
                try {
                    subOr.rw.resetRetain(subOr.canMergeFlag);
                    subOr.rw.markStart(newCommit);
                    subOr.rw.markUninteresting(subOr.rw.parseCommit(oldId));
                    for (RevCommit c : subOr.rw) {
                        subOr.rw.parseBody(c);
                        msgbuf.append(c.getFullMessage() + "\n\n");
                    }
                } catch (IOException e) {
                    throw new SubmoduleException("Could not perform a revwalk to " + "create superproject commit message", e);
                }
            }
        }
        ed.finish();
        if (!sameAuthorForAll || author == null) {
            author = myIdent;
        }
        ObjectInserter oi = or.repo.newObjectInserter();
        ObjectId tree = dc.writeTree(oi);
        ObjectId currentCommitId = or.repo.exactRef(subscriber.get()).getObjectId();
        CommitBuilder commit = new CommitBuilder();
        commit.setTreeId(tree);
        commit.setParentIds(new ObjectId[] { currentCommitId });
        commit.setAuthor(author);
        commit.setCommitter(myIdent);
        commit.setMessage(msgbuf.toString());
        oi.insert(commit);
        oi.flush();
        ObjectId commitId = oi.idFor(Constants.OBJ_COMMIT, commit.build());
        final RefUpdate rfu = or.repo.updateRef(subscriber.get());
        rfu.setForceUpdate(false);
        rfu.setNewObjectId(commitId);
        rfu.setExpectedOldObjectId(currentCommitId);
        rfu.setRefLogMessage("Submit to " + subscriber.getParentKey().get(), true);
        switch(rfu.update()) {
            case NEW:
            case FAST_FORWARD:
                gitRefUpdated.fire(subscriber.getParentKey(), rfu, account);
                // sent to inform users about the updated branch
                break;
            case FORCED:
            case IO_FAILURE:
            case LOCK_FAILURE:
            case NOT_ATTEMPTED:
            case NO_CHANGE:
            case REJECTED:
            case REJECTED_CURRENT_BRANCH:
            case RENAMED:
            default:
                throw new IOException(rfu.getResult().name());
        }
    } catch (IOException e) {
        throw new SubmoduleException("Cannot update gitlinks for " + subscriber.get(), e);
    }
}
#end_block

#method_before
private static DirCache readTree(final Repository pdb, final Ref branch) throws MissingObjectException, IncorrectObjectTypeException, IOException {
    try (RevWalk rw = new RevWalk(pdb)) {
        final DirCache dc = DirCache.newInCore();
        final DirCacheBuilder b = dc.builder();
        // no prefix path
        b.addTree(// no prefix path
        new byte[0], // standard stage
        DirCacheEntry.STAGE_0, pdb.newObjectReader(), rw.parseTree(branch.getObjectId()));
        b.finish();
        return dc;
    }
}
#method_after
private static DirCache readTree(final Ref branch, RevWalk rw) throws MissingObjectException, IncorrectObjectTypeException, IOException {
    final DirCache dc = DirCache.newInCore();
    final DirCacheBuilder b = dc.builder();
    // no prefix path
    b.addTree(// no prefix path
    new byte[0], // standard stage
    DirCacheEntry.STAGE_0, rw.getObjectReader(), rw.parseTree(branch.getObjectId()));
    b.finish();
    return dc;
}
#end_block

#method_before
@Override
public Response<String> apply(ProjectResource resource, PutDescriptionInput input) throws AuthException, ResourceConflictException, ResourceNotFoundException, IOException {
    if (input == null) {
        // Delete would set description to null.
        input = new PutDescriptionInput();
    }
    ProjectControl ctl = resource.getControl();
    IdentifiedUser user = ctl.getUser().asIdentifiedUser();
    if (!ctl.isOwner()) {
        throw new AuthException("not project owner");
    }
    try {
        MetaDataUpdate md = updateFactory.create(resource.getNameKey());
        try {
            ProjectConfig config = ProjectConfig.read(md);
            Project project = config.getProject();
            project.setDescription(Strings.emptyToNull(input.description));
            String msg = MoreObjects.firstNonNull(Strings.emptyToNull(input.commitMessage), "Updated description.\n");
            if (!msg.endsWith("\n")) {
                msg += "\n";
            }
            md.setAuthor(user);
            md.setMessage(msg);
            ObjectId baseRev = config.getRevision();
            ObjectId commitRev = config.commit(md);
            // Only fire hook if project was actually changed.
            if (!Objects.equals(baseRev, commitRev)) {
                gitRefUpdated.fire(resource.getNameKey(), RefNames.REFS_CONFIG, baseRev, commitRev, user.getAccount());
            }
            cache.evict(ctl.getProject());
            gitMgr.setProjectDescription(resource.getNameKey(), project.getDescription());
            return Strings.isNullOrEmpty(project.getDescription()) ? Response.<String>none() : Response.ok(project.getDescription());
        } finally {
            md.close();
        }
    } catch (RepositoryNotFoundException notFound) {
        throw new ResourceNotFoundException(resource.getName());
    } catch (ConfigInvalidException e) {
        throw new ResourceConflictException(String.format("invalid project.config: %s", e.getMessage()));
    }
}
#method_after
@Override
public Response<String> apply(ProjectResource resource, DescriptionInput input) throws AuthException, ResourceConflictException, ResourceNotFoundException, IOException {
    if (input == null) {
        // Delete would set description to null.
        input = new DescriptionInput();
    }
    ProjectControl ctl = resource.getControl();
    IdentifiedUser user = ctl.getUser().asIdentifiedUser();
    if (!ctl.isOwner()) {
        throw new AuthException("not project owner");
    }
    try (MetaDataUpdate md = updateFactory.create(resource.getNameKey())) {
        ProjectConfig config = ProjectConfig.read(md);
        Project project = config.getProject();
        project.setDescription(Strings.emptyToNull(input.description));
        String msg = MoreObjects.firstNonNull(Strings.emptyToNull(input.commitMessage), "Updated description.\n");
        if (!msg.endsWith("\n")) {
            msg += "\n";
        }
        md.setAuthor(user);
        md.setMessage(msg);
        config.commit(md);
        cache.evict(ctl.getProject());
        gitMgr.setProjectDescription(resource.getNameKey(), project.getDescription());
        return Strings.isNullOrEmpty(project.getDescription()) ? Response.<String>none() : Response.ok(project.getDescription());
    } catch (RepositoryNotFoundException notFound) {
        throw new ResourceNotFoundException(resource.getName());
    } catch (ConfigInvalidException e) {
        throw new ResourceConflictException(String.format("invalid project.config: %s", e.getMessage()));
    }
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ChangeHookRunner.class);
    bind(ChangeHooks.class).to(ChangeHookRunner.class);
    bind(EventDispatcher.class).to(ChangeHookRunner.class);
    bind(EventSource.class).to(ChangeHookRunner.class);
    DynamicSet.bind(binder(), NewProjectCreatedListener.class).to(ChangeHookRunner.class);
    listener().to(ChangeHookRunner.class);
}
#method_after
@Override
protected void configure() {
    bind(ChangeHookRunner.class);
    bind(ChangeHooks.class).to(ChangeHookRunner.class);
    listener().to(ChangeHookRunner.class);
}
#end_block

#method_before
private static Path hook(Config config, Path path, String name) {
    String setting = name.replace("-", "") + "hook";
    String value = config.getString("hooks", null, setting);
    return path.resolve(value != null ? value : name);
}
#method_after
private static Optional<Path> hook(Config config, Path path, String name) {
    String setting = name.replace("-", "") + "hook";
    String value = config.getString("hooks", null, setting);
    Path p = path.resolve(value != null ? value : name);
    return Files.exists(p) ? Optional.of(p) : Optional.<Path>absent();
}
#end_block

#method_before
@Override
public HookResult doRefUpdateHook(Project project, String refname, Account uploader, ObjectId oldId, ObjectId newId) {
    List<String> args = new ArrayList<>();
    addArg(args, "--project", project.getName());
    addArg(args, "--refname", refname);
    addArg(args, "--uploader", getDisplayName(uploader));
    addArg(args, "--oldrev", oldId.getName());
    addArg(args, "--newrev", newId.getName());
    return runSyncHook(project.getNameKey(), refUpdateHook, args);
}
#method_after
@Override
public HookResult doRefUpdateHook(Project project, String refname, Account uploader, ObjectId oldId, ObjectId newId) {
    if (!refUpdateHook.isPresent()) {
        return null;
    }
    List<String> args = new ArrayList<>();
    addArg(args, "--project", project.getName());
    addArg(args, "--refname", refname);
    addArg(args, "--uploader", getDisplayName(uploader));
    addArg(args, "--oldrev", oldId.getName());
    addArg(args, "--newrev", newId.getName());
    return runSyncHook(project.getNameKey(), refUpdateHook, args);
}
#end_block

#method_before
@Override
public void doProjectCreatedHook(Project.NameKey project, String headName) {
    ProjectCreatedEvent event = new ProjectCreatedEvent();
    event.projectName = project.get();
    event.headName = headName;
    fireEvent(project, event);
    List<String> args = new ArrayList<>();
    addArg(args, "--project", project.get());
    addArg(args, "--head", headName);
    runHook(project, projectCreatedHook, args);
}
#method_after
@Override
public void doProjectCreatedHook(Project.NameKey project, String headName) {
    ProjectCreatedEvent event = new ProjectCreatedEvent();
    event.projectName = project.get();
    event.headName = headName;
    dispatcher.get().postEvent(project, event);
    if (!projectCreatedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    addArg(args, "--project", project.get());
    addArg(args, "--head", headName);
    runHook(project, projectCreatedHook, args);
}
#end_block

#method_before
@Override
public void doPatchsetCreatedHook(Change change, PatchSet patchSet, ReviewDb db) throws OrmException {
    PatchSetCreatedEvent event = new PatchSetCreatedEvent();
    AccountState uploader = accountCache.get(patchSet.getUploader());
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(db, change);
    event.patchSet = asPatchSetAttribute(change, patchSet, db);
    event.uploader = eventFactory.asAccountAttribute(uploader.getAccount());
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--is-draft", String.valueOf(patchSet.isDraft()));
    addArg(args, "--kind", String.valueOf(event.patchSet.kind));
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--uploader", getDisplayName(uploader.getAccount()));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--patchset", event.patchSet.number);
    runHook(change.getProject(), patchsetCreatedHook, args);
}
#method_after
@Override
public void doPatchsetCreatedHook(Change change, PatchSet patchSet, ReviewDb db) throws OrmException {
    PatchSetCreatedEvent event = new PatchSetCreatedEvent(change);
    Supplier<AccountState> uploader = getAccountSupplier(patchSet.getUploader());
    Supplier<AccountState> owner = getAccountSupplier(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.uploader = accountAttributeSupplier(uploader);
    dispatcher.get().postEvent(change, event, db);
    if (!patchsetCreatedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    PatchSetAttribute ps = event.patchSet.get();
    addArg(args, "--change", c.id);
    addArg(args, "--is-draft", String.valueOf(patchSet.isDraft()));
    addArg(args, "--kind", String.valueOf(ps.kind));
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.get().getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--topic", c.topic);
    addArg(args, "--uploader", getDisplayName(uploader.get().getAccount()));
    addArg(args, "--commit", ps.revision);
    addArg(args, "--patchset", ps.number);
    runHook(change.getProject(), patchsetCreatedHook, args);
}
#end_block

#method_before
@Override
public void doDraftPublishedHook(Change change, PatchSet patchSet, ReviewDb db) throws OrmException {
    DraftPublishedEvent event = new DraftPublishedEvent();
    AccountState uploader = accountCache.get(patchSet.getUploader());
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(db, change);
    event.patchSet = asPatchSetAttribute(change, patchSet, db);
    event.uploader = eventFactory.asAccountAttribute(uploader.getAccount());
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--uploader", getDisplayName(uploader.getAccount()));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--patchset", event.patchSet.number);
    runHook(change.getProject(), draftPublishedHook, args);
}
#method_after
@Override
public void doDraftPublishedHook(Change change, PatchSet patchSet, ReviewDb db) throws OrmException {
    DraftPublishedEvent event = new DraftPublishedEvent(change);
    Supplier<AccountState> uploader = getAccountSupplier(patchSet.getUploader());
    Supplier<AccountState> owner = getAccountSupplier(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.uploader = accountAttributeSupplier(uploader);
    dispatcher.get().postEvent(change, event, db);
    if (!draftPublishedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    PatchSetAttribute ps = event.patchSet.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.get().getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--topic", c.topic);
    addArg(args, "--uploader", getDisplayName(uploader.get().getAccount()));
    addArg(args, "--commit", ps.revision);
    addArg(args, "--patchset", ps.number);
    runHook(change.getProject(), draftPublishedHook, args);
}
#end_block

#method_before
@Override
public void doCommentAddedHook(Change change, Account account, PatchSet patchSet, String comment, Map<String, Short> approvals, ReviewDb db) throws OrmException {
    CommentAddedEvent event = new CommentAddedEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(db, change);
    event.author = eventFactory.asAccountAttribute(account);
    event.patchSet = asPatchSetAttribute(change, patchSet, db);
    event.comment = comment;
    LabelTypes labelTypes = projectCache.get(change.getProject()).getLabelTypes();
    if (approvals.size() > 0) {
        event.approvals = new ApprovalAttribute[approvals.size()];
        int i = 0;
        for (Map.Entry<String, Short> approval : approvals.entrySet()) {
            event.approvals[i++] = getApprovalAttribute(labelTypes, approval);
        }
    }
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--is-draft", patchSet.isDraft() ? "true" : "false");
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--author", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--comment", comment == null ? "" : comment);
    for (Map.Entry<String, Short> approval : approvals.entrySet()) {
        LabelType lt = labelTypes.byLabel(approval.getKey());
        if (lt != null) {
            addArg(args, "--" + lt.getName(), Short.toString(approval.getValue()));
        }
    }
    runHook(change.getProject(), commentAddedHook, args);
}
#method_after
@Override
public void doCommentAddedHook(final Change change, Account account, PatchSet patchSet, String comment, final Map<String, Short> approvals, final Map<String, Short> oldApprovals, ReviewDb db) throws OrmException {
    CommentAddedEvent event = new CommentAddedEvent(change);
    Supplier<AccountState> owner = getAccountSupplier(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.author = accountAttributeSupplier(account);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.comment = comment;
    event.approvals = Suppliers.memoize(new Supplier<ApprovalAttribute[]>() {

        @Override
        public ApprovalAttribute[] get() {
            LabelTypes labelTypes = projectCache.get(change.getProject()).getLabelTypes();
            if (approvals.size() > 0) {
                ApprovalAttribute[] r = new ApprovalAttribute[approvals.size()];
                int i = 0;
                for (Map.Entry<String, Short> approval : approvals.entrySet()) {
                    r[i++] = getApprovalAttribute(labelTypes, approval, oldApprovals);
                }
                return r;
            }
            return null;
        }
    });
    dispatcher.get().postEvent(change, event, db);
    if (!commentAddedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    PatchSetAttribute ps = event.patchSet.get();
    addArg(args, "--change", c.id);
    addArg(args, "--is-draft", patchSet.isDraft() ? "true" : "false");
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.get().getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--topic", c.topic);
    addArg(args, "--author", getDisplayName(account));
    addArg(args, "--commit", ps.revision);
    addArg(args, "--comment", comment == null ? "" : comment);
    LabelTypes labelTypes = projectCache.get(change.getProject()).getLabelTypes();
    for (Map.Entry<String, Short> approval : approvals.entrySet()) {
        LabelType lt = labelTypes.byLabel(approval.getKey());
        if (lt != null && approval.getValue() != null) {
            addArg(args, "--" + lt.getName(), Short.toString(approval.getValue()));
            if (oldApprovals != null && !oldApprovals.isEmpty()) {
                Short oldValue = oldApprovals.get(approval.getKey());
                if (oldValue != null) {
                    addArg(args, "--" + lt.getName() + "-oldValue", Short.toString(oldValue));
                }
            }
        }
    }
    runHook(change.getProject(), commentAddedHook, args);
}
#end_block

#method_before
@Override
public void doChangeMergedHook(Change change, Account account, PatchSet patchSet, ReviewDb db, String mergeResultRev) throws OrmException {
    ChangeMergedEvent event = new ChangeMergedEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(db, change);
    event.submitter = eventFactory.asAccountAttribute(account);
    event.patchSet = asPatchSetAttribute(change, patchSet, db);
    event.newRev = mergeResultRev;
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--submitter", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--newrev", mergeResultRev);
    runHook(change.getProject(), changeMergedHook, args);
}
#method_after
@Override
public void doChangeMergedHook(Change change, Account account, PatchSet patchSet, ReviewDb db, String mergeResultRev) throws OrmException {
    ChangeMergedEvent event = new ChangeMergedEvent(change);
    Supplier<AccountState> owner = getAccountSupplier(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.submitter = accountAttributeSupplier(account);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.newRev = mergeResultRev;
    dispatcher.get().postEvent(change, event, db);
    if (!changeMergedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    PatchSetAttribute ps = event.patchSet.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.get().getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--topic", c.topic);
    addArg(args, "--submitter", getDisplayName(account));
    addArg(args, "--commit", ps.revision);
    addArg(args, "--newrev", mergeResultRev);
    runHook(change.getProject(), changeMergedHook, args);
}
#end_block

#method_before
@Override
public void doChangeAbandonedHook(Change change, Account account, PatchSet patchSet, String reason, ReviewDb db) throws OrmException {
    ChangeAbandonedEvent event = new ChangeAbandonedEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(db, change);
    event.abandoner = eventFactory.asAccountAttribute(account);
    event.patchSet = asPatchSetAttribute(change, patchSet, db);
    event.reason = reason;
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--abandoner", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--reason", reason == null ? "" : reason);
    runHook(change.getProject(), changeAbandonedHook, args);
}
#method_after
@Override
public void doChangeAbandonedHook(Change change, Account account, PatchSet patchSet, String reason, ReviewDb db) throws OrmException {
    ChangeAbandonedEvent event = new ChangeAbandonedEvent(change);
    AccountState owner = accountCache.get(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.abandoner = accountAttributeSupplier(account);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.reason = reason;
    dispatcher.get().postEvent(change, event, db);
    if (!changeAbandonedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    PatchSetAttribute ps = event.patchSet.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--topic", c.topic);
    addArg(args, "--abandoner", getDisplayName(account));
    addArg(args, "--commit", ps.revision);
    addArg(args, "--reason", reason == null ? "" : reason);
    runHook(change.getProject(), changeAbandonedHook, args);
}
#end_block

#method_before
@Override
public void doChangeRestoredHook(Change change, Account account, PatchSet patchSet, String reason, ReviewDb db) throws OrmException {
    ChangeRestoredEvent event = new ChangeRestoredEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(db, change);
    event.restorer = eventFactory.asAccountAttribute(account);
    event.patchSet = asPatchSetAttribute(change, patchSet, db);
    event.reason = reason;
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--restorer", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--reason", reason == null ? "" : reason);
    runHook(change.getProject(), changeRestoredHook, args);
}
#method_after
@Override
public void doChangeRestoredHook(Change change, Account account, PatchSet patchSet, String reason, ReviewDb db) throws OrmException {
    ChangeRestoredEvent event = new ChangeRestoredEvent(change);
    AccountState owner = accountCache.get(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.restorer = accountAttributeSupplier(account);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.reason = reason;
    dispatcher.get().postEvent(change, event, db);
    if (!changeRestoredHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    PatchSetAttribute ps = event.patchSet.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--topic", c.topic);
    addArg(args, "--restorer", getDisplayName(account));
    addArg(args, "--commit", ps.revision);
    addArg(args, "--reason", reason == null ? "" : reason);
    runHook(change.getProject(), changeRestoredHook, args);
}
#end_block

#method_before
@Override
public void doRefUpdatedHook(Branch.NameKey refName, ObjectId oldId, ObjectId newId, Account account) {
    RefUpdatedEvent event = new RefUpdatedEvent();
    if (account != null) {
        event.submitter = eventFactory.asAccountAttribute(account);
    }
    event.refUpdate = eventFactory.asRefUpdateAttribute(oldId, newId, refName);
    fireEvent(refName, event);
    List<String> args = new ArrayList<>();
    addArg(args, "--oldrev", event.refUpdate.oldRev);
    addArg(args, "--newrev", event.refUpdate.newRev);
    addArg(args, "--refname", event.refUpdate.refName);
    addArg(args, "--project", event.refUpdate.project);
    if (account != null) {
        addArg(args, "--submitter", getDisplayName(account));
    }
    runHook(refName.getParentKey(), refUpdatedHook, args);
}
#method_after
@Override
public void doRefUpdatedHook(final Branch.NameKey refName, final ObjectId oldId, final ObjectId newId, Account account) {
    RefUpdatedEvent event = new RefUpdatedEvent();
    if (account != null) {
        event.submitter = accountAttributeSupplier(account);
    }
    event.refUpdate = Suppliers.memoize(new Supplier<RefUpdateAttribute>() {

        @Override
        public RefUpdateAttribute get() {
            return eventFactory.asRefUpdateAttribute(oldId, newId, refName);
        }
    });
    dispatcher.get().postEvent(refName, event);
    if (!refUpdatedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    RefUpdateAttribute r = event.refUpdate.get();
    addArg(args, "--oldrev", r.oldRev);
    addArg(args, "--newrev", r.newRev);
    addArg(args, "--refname", r.refName);
    addArg(args, "--project", r.project);
    if (account != null) {
        addArg(args, "--submitter", getDisplayName(account));
    }
    runHook(refName.getParentKey(), refUpdatedHook, args);
}
#end_block

#method_before
@Override
public void doReviewerAddedHook(Change change, Account account, PatchSet patchSet, ReviewDb db) throws OrmException {
    ReviewerAddedEvent event = new ReviewerAddedEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(db, change);
    event.patchSet = asPatchSetAttribute(change, patchSet, db);
    event.reviewer = eventFactory.asAccountAttribute(account);
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--reviewer", getDisplayName(account));
    runHook(change.getProject(), reviewerAddedHook, args);
}
#method_after
@Override
public void doReviewerAddedHook(Change change, Account account, PatchSet patchSet, ReviewDb db) throws OrmException {
    ReviewerAddedEvent event = new ReviewerAddedEvent(change);
    Supplier<AccountState> owner = getAccountSupplier(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.reviewer = accountAttributeSupplier(account);
    dispatcher.get().postEvent(change, event, db);
    if (!reviewerAddedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.get().getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--reviewer", getDisplayName(account));
    runHook(change.getProject(), reviewerAddedHook, args);
}
#end_block

#method_before
@Override
public void doTopicChangedHook(Change change, Account account, String oldTopic, ReviewDb db) throws OrmException {
    TopicChangedEvent event = new TopicChangedEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(db, change);
    event.changer = eventFactory.asAccountAttribute(account);
    event.oldTopic = oldTopic;
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--changer", getDisplayName(account));
    addArg(args, "--old-topic", oldTopic);
    addArg(args, "--new-topic", event.change.topic);
    runHook(change.getProject(), topicChangedHook, args);
}
#method_after
@Override
public void doTopicChangedHook(Change change, Account account, String oldTopic, ReviewDb db) throws OrmException {
    TopicChangedEvent event = new TopicChangedEvent(change);
    AccountState owner = accountCache.get(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.changer = accountAttributeSupplier(account);
    event.oldTopic = oldTopic;
    dispatcher.get().postEvent(change, event, db);
    if (!topicChangedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--changer", getDisplayName(account));
    addArg(args, "--old-topic", oldTopic);
    addArg(args, "--new-topic", c.topic);
    runHook(change.getProject(), topicChangedHook, args);
}
#end_block

#method_before
@Override
public void doHashtagsChangedHook(Change change, Account account, Set<String> added, Set<String> removed, Set<String> hashtags, ReviewDb db) throws OrmException {
    HashtagsChangedEvent event = new HashtagsChangedEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(db, change);
    event.editor = eventFactory.asAccountAttribute(account);
    event.hashtags = hashtagArray(hashtags);
    event.added = hashtagArray(added);
    event.removed = hashtagArray(removed);
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--editor", getDisplayName(account));
    if (hashtags != null) {
        for (String hashtag : hashtags) {
            addArg(args, "--hashtag", hashtag);
        }
    }
    if (added != null) {
        for (String hashtag : added) {
            addArg(args, "--added", hashtag);
        }
    }
    if (removed != null) {
        for (String hashtag : removed) {
            addArg(args, "--removed", hashtag);
        }
    }
    runHook(change.getProject(), hashtagsChangedHook, args);
}
#method_after
@Override
public void doHashtagsChangedHook(Change change, Account account, Set<String> added, Set<String> removed, Set<String> hashtags, ReviewDb db) throws OrmException {
    HashtagsChangedEvent event = new HashtagsChangedEvent(change);
    AccountState owner = accountCache.get(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.editor = accountAttributeSupplier(account);
    event.hashtags = hashtagArray(hashtags);
    event.added = hashtagArray(added);
    event.removed = hashtagArray(removed);
    dispatcher.get().postEvent(change, event, db);
    if (!hashtagsChangedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--editor", getDisplayName(account));
    if (hashtags != null) {
        for (String hashtag : hashtags) {
            addArg(args, "--hashtag", hashtag);
        }
    }
    if (added != null) {
        for (String hashtag : added) {
            addArg(args, "--added", hashtag);
        }
    }
    if (removed != null) {
        for (String hashtag : removed) {
            addArg(args, "--removed", hashtag);
        }
    }
    runHook(change.getProject(), hashtagsChangedHook, args);
}
#end_block

#method_before
@Override
public void doClaSignupHook(Account account, String claName) {
    if (account != null) {
        List<String> args = new ArrayList<>();
        addArg(args, "--submitter", getDisplayName(account));
        addArg(args, "--user-id", account.getId().toString());
        addArg(args, "--cla-name", claName);
        runHook(claSignedHook, args);
    }
}
#method_after
@Override
public void doClaSignupHook(Account account, String claName) {
    if (!claSignedHook.isPresent()) {
        return;
    }
    if (account != null) {
        List<String> args = new ArrayList<>();
        addArg(args, "--submitter", getDisplayName(account));
        addArg(args, "--user-id", account.getId().toString());
        addArg(args, "--cla-name", claName);
        runHook(claSignedHook, args);
    }
}
#end_block

#method_before
private ApprovalAttribute getApprovalAttribute(LabelTypes labelTypes, Entry<String, Short> approval) {
    ApprovalAttribute a = new ApprovalAttribute();
    a.type = approval.getKey();
    LabelType lt = labelTypes.byLabel(approval.getKey());
    if (lt != null) {
        a.description = lt.getName();
    }
    a.value = Short.toString(approval.getValue());
    return a;
}
#method_after
private ApprovalAttribute getApprovalAttribute(LabelTypes labelTypes, Entry<String, Short> approval, Map<String, Short> oldApprovals) {
    ApprovalAttribute a = new ApprovalAttribute();
    a.type = approval.getKey();
    if (oldApprovals != null && !oldApprovals.isEmpty()) {
        if (oldApprovals.get(approval.getKey()) != null) {
            a.oldValue = Short.toString(oldApprovals.get(approval.getKey()));
        }
    }
    LabelType lt = labelTypes.byLabel(approval.getKey());
    if (lt != null) {
        a.description = lt.getName();
    }
    if (approval.getValue() != null) {
        a.value = Short.toString(approval.getValue());
    }
    return a;
}
#end_block

#method_before
private synchronized void runHook(Path hook, List<String> args) {
    if (Files.exists(hook)) {
        hookQueue.execute(new AsyncHookTask(null, hook, args));
    }
}
#method_after
private synchronized void runHook(Project.NameKey project, Optional<Path> hook, List<String> args) {
    if (project != null && hook.isPresent()) {
        hookQueue.execute(new AsyncHookTask(project, hook.get(), args));
    }
}
#end_block

#method_before
private HookResult runSyncHook(Project.NameKey project, Path hook, List<String> args) {
    if (!Files.exists(hook)) {
        return null;
    }
    SyncHookTask syncHook = new SyncHookTask(project, hook, args);
    FutureTask<HookResult> task = new FutureTask<>(syncHook);
    syncHookThreadPool.execute(task);
    String message;
    try {
        return task.get(syncHookTimeout, TimeUnit.SECONDS);
    } catch (TimeoutException e) {
        message = "Synchronous hook timed out " + hook.toAbsolutePath();
        log.error(message);
    } catch (Exception e) {
        message = "Error running hook " + hook.toAbsolutePath();
        log.error(message, e);
    }
    task.cancel(true);
    syncHook.cancel();
    return new HookResult(syncHook.getOutput(), message);
}
#method_after
private HookResult runSyncHook(Project.NameKey project, Optional<Path> hook, List<String> args) {
    if (!hook.isPresent()) {
        return null;
    }
    SyncHookTask syncHook = new SyncHookTask(project, hook.get(), args);
    FutureTask<HookResult> task = new FutureTask<>(syncHook);
    syncHookThreadPool.execute(task);
    String message;
    try {
        return task.get(syncHookTimeout, TimeUnit.SECONDS);
    } catch (TimeoutException e) {
        message = "Synchronous hook timed out " + hook.get().toAbsolutePath();
        log.error(message);
    } catch (Exception e) {
        message = "Error running hook " + hook.get().toAbsolutePath();
        log.error(message, e);
    }
    task.cancel(true);
    syncHook.cancel();
    return new HookResult(syncHook.getOutput(), message);
}
#end_block

#method_before
public Output apply(RevisionResource revision, ReviewInput input, Timestamp ts) throws RestApiException, UpdateException, OrmException {
    if (revision.getEdit().isPresent()) {
        throw new ResourceConflictException("cannot post review on edit");
    }
    if (input.onBehalfOf != null) {
        revision = onBehalfOf(revision, input);
    }
    if (input.labels != null) {
        checkLabels(revision, input.strictLabels, input.labels);
    }
    if (input.comments != null) {
        checkComments(revision, input.comments);
    }
    if (input.notify == null) {
        log.warn("notify = null; assuming notify = NONE");
        input.notify = NotifyHandling.NONE;
    }
    try (BatchUpdate bu = batchUpdateFactory.create(db.get(), revision.getChange().getProject(), revision.getUser(), ts)) {
        bu.addOp(revision.getChange().getId(), new Op(revision.getPatchSet().getId(), input));
        bu.execute();
    }
    Output output = new Output();
    output.labels = input.labels;
    return output;
}
#method_after
public Output apply(RevisionResource revision, ReviewInput input, Timestamp ts) throws RestApiException, UpdateException, OrmException {
    // Respect timestamp, but truncate at change created-on time.
    ts = Ordering.natural().max(ts, revision.getChange().getCreatedOn());
    if (revision.getEdit().isPresent()) {
        throw new ResourceConflictException("cannot post review on edit");
    }
    if (input.onBehalfOf != null) {
        revision = onBehalfOf(revision, input);
    }
    if (input.labels != null) {
        checkLabels(revision, input.strictLabels, input.labels);
    }
    if (input.comments != null) {
        checkComments(revision, input.comments);
    }
    if (input.notify == null) {
        log.warn("notify = null; assuming notify = NONE");
        input.notify = NotifyHandling.NONE;
    }
    try (BatchUpdate bu = batchUpdateFactory.create(db.get(), revision.getChange().getProject(), revision.getUser(), ts)) {
        bu.addOp(revision.getChange().getId(), new Op(revision.getPatchSet().getId(), input));
        bu.execute();
    }
    Output output = new Output();
    output.labels = input.labels;
    return output;
}
#end_block

#method_before
private void checkLabels(RevisionResource revision, boolean strict, Map<String, Short> labels) throws BadRequestException, AuthException {
    ChangeControl ctl = revision.getControl();
    Iterator<Map.Entry<String, Short>> itr = labels.entrySet().iterator();
    while (itr.hasNext()) {
        Map.Entry<String, Short> ent = itr.next();
        LabelType lt = revision.getControl().getLabelTypes().byLabel(ent.getKey());
        if (lt == null) {
            if (strict) {
                throw new BadRequestException(String.format("label \"%s\" is not a configured label", ent.getKey()));
            } else {
                itr.remove();
                continue;
            }
        }
        if (ent.getValue() == null || ent.getValue() == 0) {
            // Later null/0 will be deleted and revoke the label.
            continue;
        }
        if (lt.getValue(ent.getValue()) == null) {
            if (strict) {
                throw new BadRequestException(String.format("label \"%s\": %d is not a valid value", ent.getKey(), ent.getValue()));
            } else {
                itr.remove();
                continue;
            }
        }
        String name = lt.getName();
        PermissionRange range = ctl.getRange(Permission.forLabel(name));
        if (range == null || !range.contains(ent.getValue())) {
            if (strict) {
                throw new AuthException(String.format("Applying label \"%s\": %d is restricted", ent.getKey(), ent.getValue()));
            } else if (range == null || range.isEmpty()) {
                ent.setValue((short) 0);
            } else {
                ent.setValue((short) range.squash(ent.getValue()));
            }
        }
    }
}
#method_after
private void checkLabels(RevisionResource revision, boolean strict, Map<String, Short> labels) throws BadRequestException, AuthException {
    ChangeControl ctl = revision.getControl();
    Iterator<Map.Entry<String, Short>> itr = labels.entrySet().iterator();
    while (itr.hasNext()) {
        Map.Entry<String, Short> ent = itr.next();
        LabelType lt = revision.getControl().getLabelTypes().byLabel(ent.getKey());
        if (lt == null) {
            if (strict) {
                throw new BadRequestException(String.format("label \"%s\" is not a configured label", ent.getKey()));
            }
            itr.remove();
            continue;
        }
        if (ent.getValue() == null || ent.getValue() == 0) {
            // Later null/0 will be deleted and revoke the label.
            continue;
        }
        if (lt.getValue(ent.getValue()) == null) {
            if (strict) {
                throw new BadRequestException(String.format("label \"%s\": %d is not a valid value", ent.getKey(), ent.getValue()));
            }
            itr.remove();
            continue;
        }
        String name = lt.getName();
        PermissionRange range = ctl.getRange(Permission.forLabel(name));
        if (range == null || !range.contains(ent.getValue())) {
            if (strict) {
                throw new AuthException(String.format("Applying label \"%s\": %d is restricted", ent.getKey(), ent.getValue()));
            } else if (range == null || range.isEmpty()) {
                ent.setValue((short) 0);
            } else {
                ent.setValue((short) range.squash(ent.getValue()));
            }
        }
    }
}
#end_block

#method_before
@Override
public void updateChange(ChangeContext ctx) throws OrmException, ResourceConflictException {
    user = ctx.getUser().asIdentifiedUser();
    change = ctx.getChange();
    if (change.getLastUpdatedOn().before(ctx.getWhen())) {
        change.setLastUpdatedOn(ctx.getWhen());
    }
    ps = ctx.getDb().patchSets().get(psId);
    ctx.getChangeUpdate().setPatchSetId(psId);
    boolean dirty = false;
    dirty |= insertComments(ctx);
    dirty |= updateLabels(ctx);
    dirty |= insertMessage(ctx);
    if (dirty) {
        ctx.getDb().changes().update(Collections.singleton(change));
    }
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, ResourceConflictException {
    user = ctx.getUser().asIdentifiedUser();
    notes = ctx.getNotes();
    ps = psUtil.get(ctx.getDb(), ctx.getNotes(), psId);
    boolean dirty = false;
    dirty |= insertComments(ctx);
    dirty |= updateLabels(ctx);
    dirty |= insertMessage(ctx);
    return dirty;
}
#end_block

#method_before
@Override
public void postUpdate(Context ctx) {
    if (message == null) {
        return;
    }
    if (in.notify.compareTo(NotifyHandling.NONE) > 0) {
        email.create(in.notify, change, ps, user.getAccountId(), message, comments).sendAsync();
    }
    commentAdded.fire(change, ps, user.getAccount(), message.getMessage(), categories, ctx.getWhen());
}
#method_after
@Override
public void postUpdate(Context ctx) {
    if (message == null) {
        return;
    }
    if (in.notify.compareTo(NotifyHandling.NONE) > 0) {
        email.create(in.notify, notes, ps, user, message, comments).sendAsync();
    }
    commentAdded.fire(notes.getChange(), ps, user.getAccount(), message.getMessage(), approvals, oldApprovals, ctx.getWhen());
}
#end_block

#method_before
private boolean insertComments(ChangeContext ctx) throws OrmException {
    Map<String, List<CommentInput>> map = in.comments;
    if (map == null) {
        map = Collections.emptyMap();
    }
    Map<String, PatchLineComment> drafts = Collections.emptyMap();
    if (!map.isEmpty() || in.drafts != DraftHandling.KEEP) {
        if (in.drafts == DraftHandling.PUBLISH_ALL_REVISIONS) {
            drafts = changeDrafts(ctx);
        } else {
            drafts = patchSetDrafts(ctx);
        }
    }
    List<PatchLineComment> del = Lists.newArrayList();
    List<PatchLineComment> ups = Lists.newArrayList();
    Set<CommentSetEntry> existingIds = in.omitDuplicateComments ? readExistingComments(ctx) : Collections.<CommentSetEntry>emptySet();
    for (Map.Entry<String, List<CommentInput>> ent : map.entrySet()) {
        String path = ent.getKey();
        for (CommentInput c : ent.getValue()) {
            String parent = Url.decode(c.inReplyTo);
            PatchLineComment e = drafts.remove(Url.decode(c.id));
            if (e == null) {
                e = new PatchLineComment(new PatchLineComment.Key(new Patch.Key(psId, path), null), c.line != null ? c.line : 0, user.getAccountId(), parent, ctx.getWhen());
            } else if (parent != null) {
                e.setParentUuid(parent);
            }
            e.setStatus(PatchLineComment.Status.PUBLISHED);
            e.setWrittenOn(ctx.getWhen());
            e.setSide(c.side == Side.PARENT ? (short) 0 : (short) 1);
            setCommentRevId(e, patchListCache, ctx.getChange(), ps);
            e.setMessage(c.message);
            if (c.range != null) {
                e.setRange(new CommentRange(c.range.startLine, c.range.startCharacter, c.range.endLine, c.range.endCharacter));
                e.setLine(c.range.endLine);
            }
            if (existingIds.contains(CommentSetEntry.create(e))) {
                continue;
            }
            if (e.getKey().get() == null) {
                e.getKey().set(ChangeUtil.messageUUID(ctx.getDb()));
            }
            ups.add(e);
        }
    }
    switch(firstNonNull(in.drafts, DraftHandling.DELETE)) {
        case KEEP:
        default:
            break;
        case DELETE:
            del.addAll(drafts.values());
            break;
        case PUBLISH:
        case PUBLISH_ALL_REVISIONS:
            for (PatchLineComment e : drafts.values()) {
                e.setStatus(PatchLineComment.Status.PUBLISHED);
                e.setWrittenOn(ctx.getWhen());
                setCommentRevId(e, patchListCache, ctx.getChange(), ps);
                ups.add(e);
            }
            break;
    }
    plcUtil.deleteComments(ctx.getDb(), ctx.getChangeUpdate(), del);
    plcUtil.upsertComments(ctx.getDb(), ctx.getChangeUpdate(), ups);
    comments.addAll(ups);
    return !del.isEmpty() || !ups.isEmpty();
}
#method_after
private boolean insertComments(ChangeContext ctx) throws OrmException {
    Map<String, List<CommentInput>> map = in.comments;
    if (map == null) {
        map = Collections.emptyMap();
    }
    Map<String, PatchLineComment> drafts = Collections.emptyMap();
    if (!map.isEmpty() || in.drafts != DraftHandling.KEEP) {
        if (in.drafts == DraftHandling.PUBLISH_ALL_REVISIONS) {
            drafts = changeDrafts(ctx);
        } else {
            drafts = patchSetDrafts(ctx);
        }
    }
    List<PatchLineComment> del = new ArrayList<>();
    List<PatchLineComment> ups = new ArrayList<>();
    Set<CommentSetEntry> existingIds = in.omitDuplicateComments ? readExistingComments(ctx) : Collections.<CommentSetEntry>emptySet();
    for (Map.Entry<String, List<CommentInput>> ent : map.entrySet()) {
        String path = ent.getKey();
        for (CommentInput c : ent.getValue()) {
            String parent = Url.decode(c.inReplyTo);
            PatchLineComment e = drafts.remove(Url.decode(c.id));
            if (e == null) {
                e = new PatchLineComment(new PatchLineComment.Key(new Patch.Key(psId, path), null), c.line != null ? c.line : 0, user.getAccountId(), parent, ctx.getWhen());
            } else if (parent != null) {
                e.setParentUuid(parent);
            }
            e.setStatus(PatchLineComment.Status.PUBLISHED);
            e.setWrittenOn(ctx.getWhen());
            e.setSide(c.side == Side.PARENT ? (short) 0 : (short) 1);
            setCommentRevId(e, patchListCache, ctx.getChange(), ps);
            e.setMessage(c.message);
            e.setTag(in.tag);
            if (c.range != null) {
                e.setRange(new CommentRange(c.range.startLine, c.range.startCharacter, c.range.endLine, c.range.endCharacter));
                e.setLine(c.range.endLine);
            }
            if (existingIds.contains(CommentSetEntry.create(e))) {
                continue;
            }
            if (e.getKey().get() == null) {
                e.getKey().set(ChangeUtil.messageUUID(ctx.getDb()));
            }
            ups.add(e);
        }
    }
    switch(firstNonNull(in.drafts, DraftHandling.DELETE)) {
        case KEEP:
        default:
            break;
        case DELETE:
            del.addAll(drafts.values());
            break;
        case PUBLISH:
            for (PatchLineComment e : drafts.values()) {
                ups.add(publishComment(ctx, e, ps));
            }
            break;
        case PUBLISH_ALL_REVISIONS:
            publishAllRevisions(ctx, drafts, ups);
            break;
    }
    ChangeUpdate u = ctx.getUpdate(psId);
    plcUtil.deleteComments(ctx.getDb(), u, del);
    plcUtil.putComments(ctx.getDb(), u, ups);
    comments.addAll(ups);
    return !del.isEmpty() || !ups.isEmpty();
}
#end_block

#method_before
private Set<CommentSetEntry> readExistingComments(ChangeContext ctx) throws OrmException {
    Set<CommentSetEntry> r = new HashSet<>();
    for (PatchLineComment c : plcUtil.publishedByChange(ctx.getDb(), ctx.getChangeNotes())) {
        r.add(CommentSetEntry.create(c));
    }
    return r;
}
#method_after
private Set<CommentSetEntry> readExistingComments(ChangeContext ctx) throws OrmException {
    Set<CommentSetEntry> r = new HashSet<>();
    for (PatchLineComment c : plcUtil.publishedByChange(ctx.getDb(), ctx.getNotes())) {
        r.add(CommentSetEntry.create(c));
    }
    return r;
}
#end_block

#method_before
private Map<String, PatchLineComment> changeDrafts(ChangeContext ctx) throws OrmException {
    Map<String, PatchLineComment> drafts = Maps.newHashMap();
    for (PatchLineComment c : plcUtil.draftByChangeAuthor(ctx.getDb(), ctx.getChangeNotes(), user.getAccountId())) {
        drafts.put(c.getKey().get(), c);
    }
    return drafts;
}
#method_after
private Map<String, PatchLineComment> changeDrafts(ChangeContext ctx) throws OrmException {
    Map<String, PatchLineComment> drafts = new HashMap<>();
    for (PatchLineComment c : plcUtil.draftByChangeAuthor(ctx.getDb(), ctx.getNotes(), user.getAccountId())) {
        c.setTag(in.tag);
        drafts.put(c.getKey().get(), c);
    }
    return drafts;
}
#end_block

#method_before
private Map<String, PatchLineComment> patchSetDrafts(ChangeContext ctx) throws OrmException {
    Map<String, PatchLineComment> drafts = Maps.newHashMap();
    for (PatchLineComment c : plcUtil.draftByPatchSetAuthor(ctx.getDb(), psId, user.getAccountId(), ctx.getChangeNotes())) {
        drafts.put(c.getKey().get(), c);
    }
    return drafts;
}
#method_after
private Map<String, PatchLineComment> patchSetDrafts(ChangeContext ctx) throws OrmException {
    Map<String, PatchLineComment> drafts = new HashMap<>();
    for (PatchLineComment c : plcUtil.draftByPatchSetAuthor(ctx.getDb(), psId, user.getAccountId(), ctx.getNotes())) {
        drafts.put(c.getKey().get(), c);
    }
    return drafts;
}
#end_block

#method_before
private boolean updateLabels(ChangeContext ctx) throws OrmException, ResourceConflictException {
    Map<String, Short> labels = in.labels;
    if (labels == null) {
        labels = Collections.emptyMap();
    }
    List<PatchSetApproval> del = Lists.newArrayList();
    List<PatchSetApproval> ups = Lists.newArrayList();
    Map<String, PatchSetApproval> current = scanLabels(ctx, del);
    ChangeUpdate update = ctx.getChangeUpdate();
    LabelTypes labelTypes = ctx.getChangeControl().getLabelTypes();
    for (Map.Entry<String, Short> ent : labels.entrySet()) {
        String name = ent.getKey();
        LabelType lt = checkNotNull(labelTypes.byLabel(name), name);
        PatchSetApproval c = current.remove(lt.getName());
        String normName = lt.getName();
        if (ent.getValue() == null || ent.getValue() == 0) {
            // User requested delete of this label.
            if (c != null) {
                if (c.getValue() != 0) {
                    addLabelDelta(normName, (short) 0);
                }
                del.add(c);
                update.putApproval(ent.getKey(), (short) 0);
            }
        } else if (c != null && c.getValue() != ent.getValue()) {
            c.setValue(ent.getValue());
            c.setGranted(ctx.getWhen());
            ups.add(c);
            addLabelDelta(normName, c.getValue());
            categories.put(normName, c.getValue());
            update.putApproval(ent.getKey(), ent.getValue());
        } else if (c != null && c.getValue() == ent.getValue()) {
            current.put(normName, c);
        } else if (c == null) {
            c = new PatchSetApproval(new PatchSetApproval.Key(psId, user.getAccountId(), lt.getLabelId()), ent.getValue(), TimeUtil.nowTs());
            c.setGranted(ctx.getWhen());
            ups.add(c);
            addLabelDelta(normName, c.getValue());
            categories.put(normName, c.getValue());
            update.putReviewer(user.getAccountId(), ReviewerState.REVIEWER);
            update.putApproval(ent.getKey(), ent.getValue());
        }
    }
    if (!del.isEmpty() || !ups.isEmpty()) {
        if (ctx.getChange().getStatus().isClosed()) {
            throw new ResourceConflictException("change is closed");
        }
    }
    forceCallerAsReviewer(ctx, current, ups, del);
    ctx.getDb().patchSetApprovals().delete(del);
    ctx.getDb().patchSetApprovals().upsert(ups);
    return !del.isEmpty() || !ups.isEmpty();
}
#method_after
private boolean updateLabels(ChangeContext ctx) throws OrmException, ResourceConflictException {
    Map<String, Short> inLabels = MoreObjects.firstNonNull(in.labels, Collections.<String, Short>emptyMap());
    // losing access to a label after the change was submitted.
    if (inLabels.isEmpty() && ctx.getChange().getStatus().isClosed()) {
        return false;
    }
    List<PatchSetApproval> del = new ArrayList<>();
    List<PatchSetApproval> ups = new ArrayList<>();
    Map<String, PatchSetApproval> current = scanLabels(ctx, del);
    LabelTypes labelTypes = ctx.getControl().getLabelTypes();
    Map<String, Short> allApprovals = getAllApprovals(labelTypes, approvalsByKey(current.values()), inLabels);
    Map<String, Short> previous = getPreviousApprovals(allApprovals, approvalsByKey(current.values()));
    ChangeUpdate update = ctx.getUpdate(psId);
    for (Map.Entry<String, Short> ent : allApprovals.entrySet()) {
        String name = ent.getKey();
        LabelType lt = checkNotNull(labelTypes.byLabel(name), name);
        PatchSetApproval c = current.remove(lt.getName());
        String normName = lt.getName();
        approvals.put(normName, (short) 0);
        if (ent.getValue() == null || ent.getValue() == 0) {
            // User requested delete of this label.
            oldApprovals.put(normName, null);
            if (c != null) {
                if (c.getValue() != 0) {
                    addLabelDelta(normName, (short) 0);
                    oldApprovals.put(normName, previous.get(normName));
                }
                del.add(c);
                update.putApproval(normName, (short) 0);
            }
        } else if (c != null && c.getValue() != ent.getValue()) {
            c.setValue(ent.getValue());
            c.setGranted(ctx.getWhen());
            c.setTag(in.tag);
            ups.add(c);
            addLabelDelta(normName, c.getValue());
            oldApprovals.put(normName, previous.get(normName));
            approvals.put(normName, c.getValue());
            update.putApproval(normName, ent.getValue());
        } else if (c != null && c.getValue() == ent.getValue()) {
            current.put(normName, c);
            oldApprovals.put(normName, null);
            approvals.put(normName, c.getValue());
        } else if (c == null) {
            c = new PatchSetApproval(new PatchSetApproval.Key(psId, user.getAccountId(), lt.getLabelId()), ent.getValue(), ctx.getWhen());
            c.setTag(in.tag);
            c.setGranted(ctx.getWhen());
            ups.add(c);
            addLabelDelta(normName, c.getValue());
            oldApprovals.put(normName, previous.get(normName));
            approvals.put(normName, c.getValue());
            update.putReviewer(user.getAccountId(), REVIEWER);
            update.putApproval(normName, ent.getValue());
        }
    }
    if ((!del.isEmpty() || !ups.isEmpty()) && ctx.getChange().getStatus().isClosed()) {
        throw new ResourceConflictException("change is closed");
    }
    forceCallerAsReviewer(ctx, current, ups, del);
    ctx.getDb().patchSetApprovals().delete(del);
    ctx.getDb().patchSetApprovals().upsert(ups);
    return !del.isEmpty() || !ups.isEmpty();
}
#end_block

#method_before
private void forceCallerAsReviewer(ChangeContext ctx, Map<String, PatchSetApproval> current, List<PatchSetApproval> ups, List<PatchSetApproval> del) {
    if (current.isEmpty() && ups.isEmpty()) {
        // TODO Find another way to link reviewers to changes.
        if (del.isEmpty()) {
            // If no existing label is being set to 0, hack in the caller
            // as a reviewer by picking the first server-wide LabelType.
            PatchSetApproval c = new PatchSetApproval(new PatchSetApproval.Key(psId, user.getAccountId(), ctx.getChangeControl().getLabelTypes().getLabelTypes().get(0).getLabelId()), (short) 0, TimeUtil.nowTs());
            c.setGranted(ctx.getWhen());
            ups.add(c);
        } else {
            // Pick a random label that is about to be deleted and keep it.
            Iterator<PatchSetApproval> i = del.iterator();
            PatchSetApproval c = i.next();
            c.setValue((short) 0);
            c.setGranted(ctx.getWhen());
            i.remove();
            ups.add(c);
        }
    }
}
#method_after
private void forceCallerAsReviewer(ChangeContext ctx, Map<String, PatchSetApproval> current, List<PatchSetApproval> ups, List<PatchSetApproval> del) {
    if (current.isEmpty() && ups.isEmpty()) {
        // TODO Find another way to link reviewers to changes.
        if (del.isEmpty()) {
            // If no existing label is being set to 0, hack in the caller
            // as a reviewer by picking the first server-wide LabelType.
            PatchSetApproval c = new PatchSetApproval(new PatchSetApproval.Key(psId, user.getAccountId(), ctx.getControl().getLabelTypes().getLabelTypes().get(0).getLabelId()), (short) 0, ctx.getWhen());
            c.setTag(in.tag);
            c.setGranted(ctx.getWhen());
            ups.add(c);
        } else {
            // Pick a random label that is about to be deleted and keep it.
            Iterator<PatchSetApproval> i = del.iterator();
            PatchSetApproval c = i.next();
            c.setValue((short) 0);
            c.setGranted(ctx.getWhen());
            i.remove();
            ups.add(c);
        }
    }
    ctx.getUpdate(ctx.getChange().currentPatchSetId()).putReviewer(user.getAccountId(), REVIEWER);
}
#end_block

#method_before
private Map<String, PatchSetApproval> scanLabels(ChangeContext ctx, List<PatchSetApproval> del) throws OrmException {
    LabelTypes labelTypes = ctx.getChangeControl().getLabelTypes();
    Map<String, PatchSetApproval> current = Maps.newHashMap();
    for (PatchSetApproval a : approvalsUtil.byPatchSetUser(ctx.getDb(), ctx.getChangeControl(), psId, user.getAccountId())) {
        if (a.isSubmit()) {
            continue;
        }
        LabelType lt = labelTypes.byLabel(a.getLabelId());
        if (lt != null) {
            current.put(lt.getName(), a);
        } else {
            del.add(a);
        }
    }
    return current;
}
#method_after
private Map<String, PatchSetApproval> scanLabels(ChangeContext ctx, List<PatchSetApproval> del) throws OrmException {
    LabelTypes labelTypes = ctx.getControl().getLabelTypes();
    Map<String, PatchSetApproval> current = new HashMap<>();
    for (PatchSetApproval a : approvalsUtil.byPatchSetUser(ctx.getDb(), ctx.getControl(), psId, user.getAccountId())) {
        if (a.isLegacySubmit()) {
            continue;
        }
        LabelType lt = labelTypes.byLabel(a.getLabelId());
        if (lt != null) {
            current.put(lt.getName(), a);
        } else {
            del.add(a);
        }
    }
    return current;
}
#end_block

#method_before
private boolean insertMessage(ChangeContext ctx) throws OrmException {
    String msg = Strings.nullToEmpty(in.message).trim();
    StringBuilder buf = new StringBuilder();
    for (String d : labelDelta) {
        buf.append(" ").append(d);
    }
    if (comments.size() == 1) {
        buf.append("\n\n(1 comment)");
    } else if (comments.size() > 1) {
        buf.append(String.format("\n\n(%d comments)", comments.size()));
    }
    if (!msg.isEmpty()) {
        buf.append("\n\n").append(msg);
    }
    if (buf.length() == 0) {
        return false;
    }
    message = new ChangeMessage(new ChangeMessage.Key(psId.getParentKey(), ChangeUtil.messageUUID(ctx.getDb())), user.getAccountId(), ctx.getWhen(), psId);
    message.setMessage(String.format("Patch Set %d:%s", psId.get(), buf.toString()));
    cmUtil.addChangeMessage(ctx.getDb(), ctx.getChangeUpdate(), message);
    return true;
}
#method_after
private boolean insertMessage(ChangeContext ctx) throws OrmException {
    String msg = Strings.nullToEmpty(in.message).trim();
    StringBuilder buf = new StringBuilder();
    for (String d : labelDelta) {
        buf.append(" ").append(d);
    }
    if (comments.size() == 1) {
        buf.append("\n\n(1 comment)");
    } else if (comments.size() > 1) {
        buf.append(String.format("\n\n(%d comments)", comments.size()));
    }
    if (!msg.isEmpty()) {
        buf.append("\n\n").append(msg);
    }
    if (buf.length() == 0) {
        return false;
    }
    message = new ChangeMessage(new ChangeMessage.Key(psId.getParentKey(), ChangeUtil.messageUUID(ctx.getDb())), user.getAccountId(), ctx.getWhen(), psId);
    message.setTag(in.tag);
    message.setMessage(String.format("Patch Set %d:%s", psId.get(), buf.toString()));
    cmUtil.addChangeMessage(ctx.getDb(), ctx.getUpdate(psId), message);
    return true;
}
#end_block

#method_before
public void setMessageSender(final MessageSender ms) {
    messageSender = ms != null ? ms : new ReceivePackMessageSender();
}
#method_after
public void setMessageSender(MessageSender ms) {
    messageSender = ms != null ? ms : new ReceivePackMessageSender();
}
#end_block

#method_before
void processCommands(final Collection<ReceiveCommand> commands, final MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    batch = repo.getRefDatabase().newBatchUpdate();
    batch.setPushCertificate(rp.getPushCertificate());
    batch.setRefLogIdent(rp.getRefLogIdent());
    batch.setRefLogMessage("push", true);
    parseCommands(commands);
    if (magicBranch != null && magicBranch.cmd.getResult() == NOT_ATTEMPTED) {
        selectNewAndReplacedChangesFromMagicBranch();
    }
    preparePatchSetsForReplace();
    if (!batch.getCommands().isEmpty()) {
        try {
            if (!batch.isAllowNonFastForwards() && magicBranch != null && magicBranch.edit) {
                batch.setAllowNonFastForwards(true);
            }
            batch.execute(rp.getRevWalk(), commandProgress);
        } catch (IOException err) {
            int cnt = 0;
            for (ReceiveCommand cmd : batch.getCommands()) {
                if (cmd.getResult() == NOT_ATTEMPTED) {
                    cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
                    cnt++;
                }
            }
            log.error(String.format("Failed to store %d refs in %s", cnt, project.getName()), err);
        }
    }
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(user)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    Set<Branch.NameKey> branches = Sets.newHashSet();
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == OK) {
            if (c.getType() == ReceiveCommand.Type.UPDATE) {
                // aka fast-forward
                tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
            }
            if (isHead(c) || isConfig(c)) {
                switch(c.getType()) {
                    case CREATE:
                    case UPDATE:
                    case UPDATE_NONFASTFORWARD:
                        autoCloseChanges(c);
                        branches.add(new Branch.NameKey(project.getNameKey(), c.getRefName()));
                        break;
                    case DELETE:
                        ResultSet<SubmoduleSubscription> submoduleSubscriptions = null;
                        Branch.NameKey projRef = new Branch.NameKey(project.getNameKey(), c.getRefName());
                        try {
                            submoduleSubscriptions = db.submoduleSubscriptions().bySuperProject(projRef);
                            db.submoduleSubscriptions().delete(submoduleSubscriptions);
                        } catch (OrmException e) {
                            log.error("Cannot delete submodule subscription(s) of branch " + projRef + ": " + submoduleSubscriptions, e);
                        }
                        break;
                }
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(c.getRefName())) {
                // We only fire gitRefUpdated for direct refs updates.
                // Events for change refs are fired when they are created.
                // 
                gitRefUpdated.fire(project.getNameKey(), c, user.getAccount());
            }
        }
    }
    // Update superproject gitlinks if required.
    SubmoduleOp op = subOpProvider.get();
    try {
        op.updateSubmoduleSubscriptions(db, branches);
        op.updateSuperProjects(db, branches);
    } catch (SubmoduleException e) {
        log.error("Can't update submodule subscriptions " + "or update the superprojects", e);
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    reportMessages();
}
#method_after
void processCommands(Collection<ReceiveCommand> commands, MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    batch = repo.getRefDatabase().newBatchUpdate();
    batch.setPushCertificate(rp.getPushCertificate());
    batch.setRefLogIdent(rp.getRefLogIdent());
    batch.setRefLogMessage("push", true);
    parseCommands(commands);
    if (magicBranch != null && magicBranch.cmd.getResult() == NOT_ATTEMPTED) {
        selectNewAndReplacedChangesFromMagicBranch();
    }
    preparePatchSetsForReplace();
    if (!batch.getCommands().isEmpty()) {
        try {
            if (!batch.isAllowNonFastForwards() && magicBranch != null && magicBranch.edit) {
                batch.setAllowNonFastForwards(true);
            }
            batch.execute(rp.getRevWalk(), commandProgress);
        } catch (IOException err) {
            int cnt = 0;
            for (ReceiveCommand cmd : batch.getCommands()) {
                if (cmd.getResult() == NOT_ATTEMPTED) {
                    cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
                    cnt++;
                }
            }
            log.error(String.format("Failed to store %d refs in %s", cnt, project.getName()), err);
        }
    }
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(user)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    Set<Branch.NameKey> branches = new HashSet<>();
    for (ReceiveCommand c : batch.getCommands()) {
        if (c.getResult() == OK) {
            String refName = c.getRefName();
            if (c.getType() == ReceiveCommand.Type.UPDATE) {
                // aka fast-forward
                tagCache.updateFastForward(project.getNameKey(), refName, c.getOldId(), c.getNewId());
            }
            if (isHead(c) || isConfig(c)) {
                switch(c.getType()) {
                    case CREATE:
                    case UPDATE:
                    case UPDATE_NONFASTFORWARD:
                        autoCloseChanges(c);
                        branches.add(new Branch.NameKey(project.getNameKey(), refName));
                        break;
                    case DELETE:
                        break;
                }
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(refName) && !refName.startsWith(REFS_CHANGES)) {
                // We only fire gitRefUpdated for direct refs updates.
                // Events for change refs are fired when they are created.
                // 
                gitRefUpdated.fire(project.getNameKey(), c, user.getAccount());
            }
        }
    }
    // Update superproject gitlinks if required.
    try (MergeOpRepoManager orm = ormProvider.get()) {
        orm.setContext(db, TimeUtil.nowTs(), user, "receiveID");
        SubmoduleOp op = subOpFactory.create(orm);
        op.updateSuperProjects(branches);
    } catch (SubmoduleException e) {
        log.error("Can't update the superprojects", e);
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    reportMessages();
}
#end_block

#method_before
private void reportMessages() {
    Iterable<CreateRequest> created = Iterables.filter(newChanges, new Predicate<CreateRequest>() {

        @Override
        public boolean apply(CreateRequest input) {
            return input.created;
        }
    });
    if (!Iterables.isEmpty(created)) {
        addMessage("");
        addMessage("New Changes:");
        for (CreateRequest c : created) {
            addMessage(formatChangeUrl(canonicalWebUrl, c.change, false));
        }
        addMessage("");
    }
    List<ReplaceRequest> updated = FluentIterable.from(replaceByChange.values()).filter(new Predicate<ReplaceRequest>() {

        @Override
        public boolean apply(ReplaceRequest input) {
            return !input.skip && input.inputCommand.getResult() == OK;
        }
    }).toSortedList(Ordering.natural().onResultOf(new Function<ReplaceRequest, Integer>() {

        @Override
        public Integer apply(ReplaceRequest in) {
            return in.change.getId().get();
        }
    }));
    if (!updated.isEmpty()) {
        addMessage("");
        addMessage("Updated Changes:");
        boolean edit = magicBranch != null && magicBranch.edit;
        for (ReplaceRequest u : updated) {
            addMessage(formatChangeUrl(canonicalWebUrl, u.change, edit));
        }
        addMessage("");
    }
}
#method_after
private void reportMessages() {
    Iterable<CreateRequest> created = Iterables.filter(newChanges, new Predicate<CreateRequest>() {

        @Override
        public boolean apply(CreateRequest input) {
            return input.change != null;
        }
    });
    if (!Iterables.isEmpty(created)) {
        addMessage("");
        addMessage("New Changes:");
        for (CreateRequest c : created) {
            addMessage(formatChangeUrl(canonicalWebUrl, c.change, c.change.getSubject(), false));
        }
        addMessage("");
    }
    List<ReplaceRequest> updated = FluentIterable.from(replaceByChange.values()).filter(new Predicate<ReplaceRequest>() {

        @Override
        public boolean apply(ReplaceRequest input) {
            return !input.skip && input.inputCommand.getResult() == OK;
        }
    }).toSortedList(Ordering.natural().onResultOf(new Function<ReplaceRequest, Integer>() {

        @Override
        public Integer apply(ReplaceRequest in) {
            return in.change.getId().get();
        }
    }));
    if (!updated.isEmpty()) {
        addMessage("");
        addMessage("Updated Changes:");
        boolean edit = magicBranch != null && magicBranch.edit;
        for (ReplaceRequest u : updated) {
            addMessage(formatChangeUrl(canonicalWebUrl, u.change, u.info.getSubject(), edit));
        }
        addMessage("");
    }
}
#end_block

#method_before
private static String formatChangeUrl(String url, Change change, boolean edit) {
    StringBuilder m = new StringBuilder().append("  ").append(url).append(change.getChangeId()).append(" ").append(ChangeUtil.cropSubject(change.getSubject()));
    if (change.getStatus() == Change.Status.DRAFT) {
        m.append(" [DRAFT]");
    }
    if (edit) {
        m.append(" [EDIT]");
    }
    return m.toString();
}
#method_after
private static String formatChangeUrl(String url, Change change, String subject, boolean edit) {
    StringBuilder m = new StringBuilder().append("  ").append(url).append(change.getChangeId()).append(" ").append(ChangeUtil.cropSubject(subject));
    if (change.getStatus() == Change.Status.DRAFT) {
        m.append(" [DRAFT]");
    }
    if (edit) {
        m.append(" [EDIT]");
    }
    return m.toString();
}
#end_block

#method_before
private void insertChangesAndPatchSets() {
    int replaceCount = 0;
    int okToInsert = 0;
    for (Map.Entry<Change.Id, ReplaceRequest> e : replaceByChange.entrySet()) {
        ReplaceRequest replace = e.getValue();
        if (magicBranch != null && replace.inputCommand == magicBranch.cmd) {
            replaceCount++;
            if (replace.cmd != null && replace.cmd.getResult() == OK) {
                okToInsert++;
            }
        } else if (replace.cmd != null && replace.cmd.getResult() == OK) {
            try {
                if (replace.insertPatchSet().checkedGet() != null) {
                    replace.inputCommand.setResult(OK);
                }
            } catch (IOException | RestApiException err) {
                reject(replace.inputCommand, "internal server error");
                log.error(String.format("Cannot add patch set to %d of %s", e.getKey().get(), project.getName()), err);
            }
        } else if (replace.inputCommand.getResult() == NOT_ATTEMPTED) {
            reject(replace.inputCommand, "internal server error");
            log.error(String.format("Replacement for project %s was not attempted", project.getName()));
        }
    }
    if (magicBranch == null || magicBranch.cmd.getResult() != NOT_ATTEMPTED) {
        // No need to continue.
        return;
    }
    List<String> lastCreateChangeErrors = Lists.newArrayList();
    for (CreateRequest create : newChanges) {
        if (create.cmd.getResult() == OK) {
            okToInsert++;
        } else {
            String createChangeResult = String.format("%s %s", create.cmd.getResult(), Strings.nullToEmpty(create.cmd.getMessage())).trim();
            lastCreateChangeErrors.add(createChangeResult);
            log.error(String.format("Command %s on %s:%s not completed: %s", create.cmd.getType(), project.getName(), create.cmd.getRefName(), createChangeResult));
        }
    }
    if (okToInsert != replaceCount + newChanges.size()) {
        // One or more new references failed to create. Assume the
        // system isn't working correctly anymore and abort.
        reject(magicBranch.cmd, "Unable to create changes: " + Joiner.on(' ').join(lastCreateChangeErrors));
        log.error(String.format("Only %d of %d new change refs created in %s; aborting", okToInsert, replaceCount + newChanges.size(), project.getName()));
        return;
    }
    try {
        List<CheckedFuture<?, RestApiException>> futures = Lists.newArrayList();
        for (ReplaceRequest replace : replaceByChange.values()) {
            if (replace.inputCommand == magicBranch.cmd) {
                futures.add(replace.insertPatchSet());
            }
        }
        for (CreateRequest create : newChanges) {
            futures.add(create.insertChange());
        }
        for (UpdateGroupsRequest update : updateGroups) {
            futures.add(update.updateGroups());
        }
        for (CheckedFuture<?, RestApiException> f : futures) {
            f.checkedGet();
        }
        magicBranch.cmd.setResult(OK);
    } catch (RestApiException err) {
        log.error("Can't insert change/patchset for " + project.getName() + ". " + err.getMessage(), err);
        String rejection = "internal server error";
        if (err.getCause() != null) {
            rejection += ": " + err.getCause().getMessage();
        }
        reject(magicBranch.cmd, rejection);
    } catch (IOException err) {
        log.error("Can't read commits for " + project.getName(), err);
        reject(magicBranch.cmd, "internal server error");
    }
}
#method_after
private void insertChangesAndPatchSets() {
    int replaceCount = 0;
    int okToInsert = 0;
    for (Map.Entry<Change.Id, ReplaceRequest> e : replaceByChange.entrySet()) {
        ReplaceRequest replace = e.getValue();
        if (magicBranch != null && replace.inputCommand == magicBranch.cmd) {
            replaceCount++;
            if (replace.cmd != null && replace.cmd.getResult() == OK) {
                okToInsert++;
            }
        } else if (replace.cmd != null && replace.cmd.getResult() == OK) {
            checkState(NEW_PATCHSET.matcher(replace.inputCommand.getRefName()).matches(), "expected a new patch set command as input when creating %s;" + " got %s", replace.cmd.getRefName(), replace.inputCommand.getRefName());
            try {
                replace.insertPatchSetWithoutBatchUpdate();
                replace.inputCommand.setResult(OK);
            } catch (IOException | UpdateException | RestApiException err) {
                reject(replace.inputCommand, "internal server error");
                log.error(String.format("Cannot add patch set to change %d in project %s", e.getKey().get(), project.getName()), err);
            }
        } else if (replace.inputCommand.getResult() == NOT_ATTEMPTED) {
            reject(replace.inputCommand, "internal server error");
            log.error(String.format("Replacement for project %s was not attempted", project.getName()));
        }
    }
    if (magicBranch == null || magicBranch.cmd.getResult() != NOT_ATTEMPTED) {
        // No need to continue.
        return;
    }
    List<String> lastCreateChangeErrors = new ArrayList<>();
    for (CreateRequest create : newChanges) {
        if (create.cmd.getResult() == OK) {
            okToInsert++;
        } else {
            String createChangeResult = String.format("%s %s", create.cmd.getResult(), Strings.nullToEmpty(create.cmd.getMessage())).trim();
            lastCreateChangeErrors.add(createChangeResult);
            log.error(String.format("Command %s on %s:%s not completed: %s", create.cmd.getType(), project.getName(), create.cmd.getRefName(), createChangeResult));
        }
    }
    if (okToInsert != replaceCount + newChanges.size()) {
        // One or more new references failed to create. Assume the
        // system isn't working correctly anymore and abort.
        reject(magicBranch.cmd, "Unable to create changes: " + Joiner.on(' ').join(lastCreateChangeErrors));
        log.error(String.format("Only %d of %d new change refs created in %s; aborting", okToInsert, replaceCount + newChanges.size(), project.getName()));
        return;
    }
    try (BatchUpdate bu = batchUpdateFactory.create(db, magicBranch.dest.getParentKey(), user, TimeUtil.nowTs());
        ObjectInserter ins = repo.newObjectInserter()) {
        bu.setRepository(repo, rp.getRevWalk(), ins).updateChangesInParallel();
        for (ReplaceRequest replace : replaceByChange.values()) {
            if (replace.inputCommand == magicBranch.cmd) {
                replace.addOps(bu, replaceProgress);
            }
        }
        for (CreateRequest create : newChanges) {
            create.addOps(bu);
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.addOps(bu);
        }
        try {
            bu.execute();
        } catch (UpdateException e) {
            throw INSERT_EXCEPTION.apply(e);
        }
        magicBranch.cmd.setResult(OK);
        for (ReplaceRequest replace : replaceByChange.values()) {
            String rejectMessage = replace.getRejectMessage();
            if (rejectMessage != null) {
                reject(replace.inputCommand, rejectMessage);
            }
        }
    } catch (ResourceConflictException e) {
        addMessage(e.getMessage());
        reject(magicBranch.cmd, "conflict");
    } catch (RestApiException | IOException err) {
        log.error("Can't insert change/patch set for " + project.getName(), err);
        reject(magicBranch.cmd, "internal server error: " + err.getMessage());
    }
    if (magicBranch != null && magicBranch.submit) {
        try {
            submit(newChanges, replaceByChange.values());
        } catch (ResourceConflictException e) {
            addMessage(e.getMessage());
            reject(magicBranch.cmd, "conflict");
        } catch (RestApiException | OrmException e) {
            log.error("Error submit changes to " + project.getName(), e);
            reject(magicBranch.cmd, "error during submit");
        }
    }
}
#end_block

#method_before
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseMagicBranch(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(repo, cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            addError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                addError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                        Project.NameKey newParent = cfg.getProject().getParent(allProjectsName);
                        Project.NameKey oldParent = project.getParent(allProjectsName);
                        if (oldParent == null) {
                            // update of the 'All-Projects' project
                            if (newParent != null) {
                                reject(cmd, "invalid project configuration: root project cannot have parent");
                                continue;
                            }
                        } else {
                            if (!oldParent.equals(newParent) && !user.getCapabilities().canAdministrateServer()) {
                                reject(cmd, "invalid project configuration: only Gerrit admin can set parent");
                                continue;
                            }
                            if (projectCache.get(newParent) == null) {
                                reject(cmd, "invalid project configuration: parent does not exist");
                                continue;
                            }
                        }
                        for (Entry<ProjectConfigEntry> e : pluginConfigEntries) {
                            PluginConfig pluginCfg = cfg.getPluginConfig(e.getPluginName());
                            ProjectConfigEntry configEntry = e.getProvider().get();
                            String value = pluginCfg.getString(e.getExportName());
                            String oldValue = projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getString(e.getExportName());
                            if (configEntry.getType() == ProjectConfigEntry.Type.ARRAY) {
                                List<String> l = Arrays.asList(projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getStringList(e.getExportName()));
                                oldValue = Joiner.on("\n").join(l);
                            }
                            if ((value == null ? oldValue != null : !value.equals(oldValue)) && !configEntry.isEditable(projectControl.getProjectState())) {
                                reject(cmd, String.format("invalid project configuration: Not allowed to set parameter" + " '%s' of plugin '%s' on project '%s'.", e.getExportName(), e.getPluginName(), project.getName()));
                                continue;
                            }
                            if (ProjectConfigEntry.Type.LIST.equals(configEntry.getType()) && value != null && !configEntry.getPermittedValues().contains(value)) {
                                reject(cmd, String.format("invalid project configuration: The value '%s' is " + "not permitted for parameter '%s' of plugin '%s'.", value, e.getExportName(), e.getPluginName()));
                            }
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#method_after
private void parseCommands(Collection<ReceiveCommand> commands) {
    for (ReceiveCommand cmd : commands) {
        if (cmd.getResult() != NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseMagicBranch(cmd);
            continue;
        }
        if (projectControl.getProjectState().isAllUsers() && RefNames.REFS_USERS_SELF.equals(cmd.getRefName())) {
            final ReceiveCommand orgCmd = cmd;
            cmd = new ReceiveCommand(cmd.getOldId(), cmd.getNewId(), RefNames.refsUsers(user.getAccountId()), cmd.getType()) {

                @Override
                public void setResult(Result s, String m) {
                    super.setResult(s, m);
                    orgCmd.setResult(s, m);
                }
            };
        }
        Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(rp.getRevWalk(), cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            addError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                addError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                        Project.NameKey newParent = cfg.getProject().getParent(allProjectsName);
                        Project.NameKey oldParent = project.getParent(allProjectsName);
                        if (oldParent == null) {
                            // update of the 'All-Projects' project
                            if (newParent != null) {
                                reject(cmd, "invalid project configuration: root project cannot have parent");
                                continue;
                            }
                        } else {
                            if (!oldParent.equals(newParent) && !user.getCapabilities().canAdministrateServer()) {
                                reject(cmd, "invalid project configuration: only Gerrit admin can set parent");
                                continue;
                            }
                            if (projectCache.get(newParent) == null) {
                                reject(cmd, "invalid project configuration: parent does not exist");
                                continue;
                            }
                        }
                        for (Entry<ProjectConfigEntry> e : pluginConfigEntries) {
                            PluginConfig pluginCfg = cfg.getPluginConfig(e.getPluginName());
                            ProjectConfigEntry configEntry = e.getProvider().get();
                            String value = pluginCfg.getString(e.getExportName());
                            String oldValue = projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getString(e.getExportName());
                            if (configEntry.getType() == ProjectConfigEntryType.ARRAY) {
                                List<String> l = Arrays.asList(projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getStringList(e.getExportName()));
                                oldValue = Joiner.on("\n").join(l);
                            }
                            if ((value == null ? oldValue != null : !value.equals(oldValue)) && !configEntry.isEditable(projectControl.getProjectState())) {
                                reject(cmd, String.format("invalid project configuration: Not allowed to set parameter" + " '%s' of plugin '%s' on project '%s'.", e.getExportName(), e.getPluginName(), project.getName()));
                                continue;
                            }
                            if (ProjectConfigEntryType.LIST.equals(configEntry.getType()) && value != null && !configEntry.getPermittedValues().contains(value)) {
                                reject(cmd, String.format("invalid project configuration: The value '%s' is " + "not permitted for parameter '%s' of plugin '%s'.", value, e.getExportName(), e.getPluginName()));
                            }
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#end_block

#method_before
private void parseCreate(final ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    rp.getRevWalk().reset();
    if (ctl.canCreate(db, rp.getRevWalk(), obj)) {
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        reject(cmd);
    }
}
#method_after
private void parseCreate(ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    rp.getRevWalk().reset();
    if (ctl.canCreate(db, rp.getRevWalk(), obj)) {
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        reject(cmd);
    }
}
#end_block

#method_before
private void parseUpdate(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canUpdate()) {
        if (isHead(cmd) && !isCommit(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        if (RefNames.REFS_CONFIG.equals(ctl.getRefName())) {
            errors.put(Error.CONFIG_UPDATE, RefNames.REFS_CONFIG);
        } else {
            errors.put(Error.UPDATE, ctl.getRefName());
        }
        reject(cmd);
    }
}
#method_after
private void parseUpdate(ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canUpdate()) {
        if (isHead(cmd) && !isCommit(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        if (RefNames.REFS_CONFIG.equals(ctl.getRefName())) {
            errors.put(Error.CONFIG_UPDATE, RefNames.REFS_CONFIG);
        } else {
            errors.put(Error.UPDATE, ctl.getRefName());
        }
        reject(cmd);
    }
}
#end_block

#method_before
private boolean isCommit(final ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName(), err);
        reject(cmd, "invalid object");
        return false;
    }
    if (obj instanceof RevCommit) {
        return true;
    } else {
        reject(cmd, "not a commit");
        return false;
    }
}
#method_after
private boolean isCommit(ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName(), err);
        reject(cmd, "invalid object");
        return false;
    }
    if (obj instanceof RevCommit) {
        return true;
    }
    reject(cmd, "not a commit");
    return false;
}
#end_block

#method_before
private void parseDelete(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.getRefName().startsWith(REFS_CHANGES)) {
        errors.put(Error.DELETE_CHANGES, ctl.getRefName());
        reject(cmd, "cannot delete changes");
    } else if (ctl.canDelete()) {
        batch.addCommand(cmd);
    } else {
        if (RefNames.REFS_CONFIG.equals(ctl.getRefName())) {
            reject(cmd, "cannot delete project configuration");
        } else {
            errors.put(Error.DELETE, ctl.getRefName());
            reject(cmd, "cannot delete references");
        }
    }
}
#method_after
private void parseDelete(ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.getRefName().startsWith(REFS_CHANGES)) {
        errors.put(Error.DELETE_CHANGES, ctl.getRefName());
        reject(cmd, "cannot delete changes");
    } else if (ctl.canDelete()) {
        batch.addCommand(cmd);
    } else {
        if (RefNames.REFS_CONFIG.equals(ctl.getRefName())) {
            reject(cmd, "cannot delete project configuration");
        } else {
            errors.put(Error.DELETE, ctl.getRefName());
            reject(cmd, "cannot delete references");
        }
    }
}
#end_block

#method_before
private void parseRewind(final ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
        batch.setAllowNonFastForwards(true).addCommand(cmd);
    } else {
        cmd.setResult(REJECTED_NONFASTFORWARD, " need '" + PermissionRule.FORCE_PUSH + "' privilege.");
    }
}
#method_after
private void parseRewind(ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
        batch.setAllowNonFastForwards(true).addCommand(cmd);
    } else {
        cmd.setResult(REJECTED_NONFASTFORWARD, " need '" + PermissionRule.FORCE_PUSH + "' privilege.");
    }
}
#end_block

#method_before
@Option(name = "--label", aliases = { "-l" }, metaVar = "LABEL+VALUE", usage = "label(s) to assign (defaults to +1 if no value provided")
void addLabel(final String token) throws CmdLineException {
    LabelVote v = LabelVote.parse(token);
    try {
        LabelType.checkName(v.label());
        ApprovalsUtil.checkLabel(labelTypes, v.label(), v.value());
    } catch (IllegalArgumentException e) {
        throw clp.reject(e.getMessage());
    }
    labels.put(v.label(), v.value());
}
#method_after
@Option(name = "--label", aliases = { "-l" }, metaVar = "LABEL+VALUE", usage = "label(s) to assign (defaults to +1 if no value provided")
void addLabel(String token) throws CmdLineException {
    LabelVote v = LabelVote.parse(token);
    try {
        LabelType.checkName(v.label());
        ApprovalsUtil.checkLabel(labelTypes, v.label(), v.value());
    } catch (IllegalArgumentException e) {
        throw clp.reject(e.getMessage());
    }
    labels.put(v.label(), v.value());
}
#end_block

#method_before
@Option(name = "--hashtag", aliases = { "-t" }, metaVar = "HASHTAG", usage = "add hashtag to changes")
void addHashtag(String token) throws CmdLineException {
    if (!notesMigration.enabled()) {
        throw clp.reject("cannot add hashtags; noteDb is disabled");
    }
    String hashtag = cleanupHashtag(token);
    if (!hashtag.isEmpty()) {
        hashtags.add(hashtag);
    }
// TODO(dpursehouse): validate hashtags
}
#method_after
@Option(name = "--hashtag", aliases = { "-t" }, metaVar = "HASHTAG", usage = "add hashtag to changes")
void addHashtag(String token) throws CmdLineException {
    if (!notesMigration.readChanges()) {
        throw clp.reject("cannot add hashtags; noteDb is disabled");
    }
    String hashtag = cleanupHashtag(token);
    if (!hashtag.isEmpty()) {
        hashtags.add(hashtag);
    }
// TODO(dpursehouse): validate hashtags
}
#end_block

#method_before
private void parseMagicBranch(final ReceiveCommand cmd) {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    magicBranch = new MagicBranchInput(cmd, labelTypes, notesMigration);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    magicBranch.clp = clp;
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet());
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    if (!magicBranch.ctl.canWrite()) {
        reject(cmd, "project is read only");
        return;
    }
    if (magicBranch.draft) {
        if (!receiveConfig.allowDrafts) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "draft workflow is disabled");
            return;
        } else if (projectControl.controlForRef("refs/drafts/" + ref).isBlocked(Permission.PUSH)) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "cannot upload drafts");
            return;
        }
    }
    if (!magicBranch.ctl.canUpload()) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload review");
        return;
    }
    if (magicBranch.draft && magicBranch.submit) {
        reject(cmd, "cannot submit draft");
        return;
    }
    if (magicBranch.submit && !projectControl.controlForRef(MagicBranch.NEW_CHANGE + ref).canSubmit()) {
        reject(cmd, "submit not allowed");
        return;
    }
    RevWalk walk = rp.getRevWalk();
    RevCommit tip;
    try {
        tip = walk.parseCommit(magicBranch.cmd.getNewId());
    } catch (IOException ex) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", ex);
        return;
    }
    // if %base was specified, ignore newChangeForAllNotInTarget
    if (tip.getParentCount() > 1 || magicBranch.base != null || tip.getParentCount() == 0) {
        newChangeForAllNotInTarget = false;
    }
    if (magicBranch.base != null) {
        magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
        for (ObjectId id : magicBranch.base) {
            try {
                magicBranch.baseCommit.add(walk.parseCommit(id));
            } catch (IncorrectObjectTypeException notCommit) {
                reject(cmd, "base must be a commit");
                return;
            } catch (MissingObjectException e) {
                reject(cmd, "base not found");
                return;
            } catch (IOException e) {
                log.warn(String.format("Project %s cannot read %s", project.getName(), id.name()), e);
                reject(cmd, "internal server error");
                return;
            }
        }
    } else if (newChangeForAllNotInTarget) {
        String destBranch = magicBranch.dest.get();
        try {
            Ref r = repo.getRefDatabase().exactRef(destBranch);
            if (r == null) {
                reject(cmd, destBranch + " not found");
                return;
            }
            ObjectId baseHead = r.getObjectId();
            magicBranch.baseCommit = Collections.singletonList(walk.parseCommit(baseHead));
        } catch (IOException ex) {
            log.warn(String.format("Project %s cannot read %s", project.getName(), destBranch), ex);
            reject(cmd, "internal server error");
            return;
        }
    }
    // 
    try {
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
    }
}
#method_after
private void parseMagicBranch(ReceiveCommand cmd) {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    magicBranch = new MagicBranchInput(cmd, labelTypes, notesMigration);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    magicBranch.clp = clp;
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet());
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (projectControl.getProjectState().isAllUsers() && RefNames.REFS_USERS_SELF.equals(ref)) {
        ref = RefNames.refsUsers(user.getAccountId());
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    if (!magicBranch.ctl.canWrite()) {
        reject(cmd, "project is read only");
        return;
    }
    if (magicBranch.draft) {
        if (!receiveConfig.allowDrafts) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "draft workflow is disabled");
            return;
        } else if (projectControl.controlForRef("refs/drafts/" + ref).isBlocked(Permission.PUSH)) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "cannot upload drafts");
            return;
        }
    }
    if (!magicBranch.ctl.canUpload()) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload review");
        return;
    }
    if (magicBranch.draft && magicBranch.submit) {
        reject(cmd, "cannot submit draft");
        return;
    }
    if (magicBranch.submit && !projectControl.controlForRef(MagicBranch.NEW_CHANGE + ref).canSubmit()) {
        reject(cmd, "submit not allowed");
        return;
    }
    RevWalk walk = rp.getRevWalk();
    RevCommit tip;
    try {
        tip = walk.parseCommit(magicBranch.cmd.getNewId());
    } catch (IOException ex) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", ex);
        return;
    }
    // if %base was specified, ignore newChangeForAllNotInTarget
    if (tip.getParentCount() > 1 || magicBranch.base != null || tip.getParentCount() == 0) {
        newChangeForAllNotInTarget = false;
    }
    if (magicBranch.base != null) {
        magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
        for (ObjectId id : magicBranch.base) {
            try {
                magicBranch.baseCommit.add(walk.parseCommit(id));
            } catch (IncorrectObjectTypeException notCommit) {
                reject(cmd, "base must be a commit");
                return;
            } catch (MissingObjectException e) {
                reject(cmd, "base not found");
                return;
            } catch (IOException e) {
                log.warn(String.format("Project %s cannot read %s", project.getName(), id.name()), e);
                reject(cmd, "internal server error");
                return;
            }
        }
    } else if (newChangeForAllNotInTarget) {
        String destBranch = magicBranch.dest.get();
        try {
            Ref r = repo.getRefDatabase().exactRef(destBranch);
            if (r == null) {
                reject(cmd, destBranch + " not found");
                return;
            }
            ObjectId baseHead = r.getObjectId();
            magicBranch.baseCommit = Collections.singletonList(walk.parseCommit(baseHead));
        } catch (IOException ex) {
            log.warn(String.format("Project %s cannot read %s", project.getName(), destBranch), ex);
            reject(cmd, "internal server error");
            return;
        }
    }
    // 
    try {
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        RevCommit h = walk.parseCommit(targetRef.getObjectId());
        RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
    }
}
#end_block

#method_before
private void parseReplaceCommand(final ReceiveCommand cmd, final Change.Id changeId) {
    if (cmd.getType() != ReceiveCommand.Type.CREATE) {
        reject(cmd, "invalid usage");
        return;
    }
    final RevCommit newCommit;
    try {
        newCommit = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IOException e) {
        log.error("Cannot parse " + cmd.getNewId().name() + " as commit", e);
        reject(cmd, "invalid commit");
        return;
    }
    final Change changeEnt;
    try {
        changeEnt = db.changes().get(changeId);
    } catch (OrmException e) {
        log.error("Cannot lookup existing change " + changeId, e);
        reject(cmd, "database error");
        return;
    }
    if (changeEnt == null) {
        reject(cmd, "change " + changeId + " not found");
        return;
    }
    if (!project.getNameKey().equals(changeEnt.getProject())) {
        reject(cmd, "change " + changeId + " does not belong to project " + project.getName());
        return;
    }
    requestReplace(cmd, true, changeEnt, newCommit);
}
#method_after
private void parseReplaceCommand(ReceiveCommand cmd, Change.Id changeId) {
    if (cmd.getType() != ReceiveCommand.Type.CREATE) {
        reject(cmd, "invalid usage");
        return;
    }
    RevCommit newCommit;
    try {
        newCommit = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IOException e) {
        log.error("Cannot parse " + cmd.getNewId().name() + " as commit", e);
        reject(cmd, "invalid commit");
        return;
    }
    Change changeEnt;
    try {
        changeEnt = notesFactory.createChecked(db, project.getNameKey(), changeId).getChange();
    } catch (OrmException e) {
        log.error("Cannot lookup existing change " + changeId, e);
        reject(cmd, "database error");
        return;
    } catch (NoSuchChangeException e) {
        log.error("Change not found " + changeId, e);
        reject(cmd, "change " + changeId + " not found");
        return;
    }
    if (!project.getNameKey().equals(changeEnt.getProject())) {
        reject(cmd, "change " + changeId + " does not belong to project " + project.getName());
        return;
    }
    requestReplace(cmd, true, changeEnt, newCommit);
}
#end_block

#method_before
private boolean requestReplace(final ReceiveCommand cmd, final boolean checkMergedInto, final Change change, final RevCommit newCommit) {
    if (change.getStatus().isClosed()) {
        reject(cmd, "change " + canonicalWebUrl + change.getId() + " closed");
        return false;
    }
    final ReplaceRequest req = new ReplaceRequest(change.getId(), newCommit, cmd, checkMergedInto);
    if (replaceByChange.containsKey(req.ontoChange)) {
        reject(cmd, "duplicate request");
        return false;
    }
    replaceByChange.put(req.ontoChange, req);
    return true;
}
#method_after
private boolean requestReplace(ReceiveCommand cmd, boolean checkMergedInto, Change change, RevCommit newCommit) {
    if (change.getStatus().isClosed()) {
        reject(cmd, "change " + canonicalWebUrl + change.getId() + " closed");
        return false;
    }
    ReplaceRequest req = new ReplaceRequest(change.getId(), newCommit, cmd, checkMergedInto);
    if (replaceByChange.containsKey(req.ontoChange)) {
        reject(cmd, "duplicate request");
        return false;
    }
    replaceByChange.put(req.ontoChange, req);
    return true;
}
#end_block

#method_before
private void selectNewAndReplacedChangesFromMagicBranch() {
    newChanges = Lists.newArrayList();
    SetMultimap<ObjectId, Ref> existing = changeRefsById();
    GroupCollector groupCollector = new GroupCollector(refsById, db);
    rp.getRevWalk().reset();
    rp.getRevWalk().sort(RevSort.TOPO);
    rp.getRevWalk().sort(RevSort.REVERSE, true);
    try {
        rp.getRevWalk().markStart(rp.getRevWalk().parseCommit(magicBranch.cmd.getNewId()));
        if (magicBranch.baseCommit != null) {
            for (RevCommit c : magicBranch.baseCommit) {
                rp.getRevWalk().markUninteresting(c);
            }
            Ref targetRef = allRefs.get(magicBranch.ctl.getRefName());
            if (targetRef != null) {
                rp.getRevWalk().markUninteresting(rp.getRevWalk().parseCommit(targetRef.getObjectId()));
            }
        } else {
            markHeadsAsUninteresting(rp.getRevWalk(), magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
        }
        List<ChangeLookup> pending = Lists.newArrayList();
        final Set<Change.Key> newChangeIds = new HashSet<>();
        final int maxBatchChanges = receiveConfig.getEffectiveMaxBatchChangesLimit(user);
        for (; ; ) {
            final RevCommit c = rp.getRevWalk().next();
            if (c == null) {
                break;
            }
            groupCollector.visit(c);
            Collection<Ref> existingRefs = existing.get(c);
            if (!existingRefs.isEmpty()) {
                // A's group.
                for (Ref ref : existingRefs) {
                    updateGroups.add(new UpdateGroupsRequest(ref, c));
                }
                continue;
            }
            if (!validCommit(magicBranch.ctl, magicBranch.cmd, c)) {
                // Not a change the user can propose? Abort as early as possible.
                newChanges = Collections.emptyList();
                return;
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
            }
            Change.Key changeKey = new Change.Key("I" + c.name());
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(magicBranch.ctl, c, changeKey));
                continue;
            }
            final String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                newChanges = Collections.emptyList();
                return;
            }
            changeKey = new Change.Key(idStr);
            pending.add(new ChangeLookup(c, changeKey));
            if (maxBatchChanges != 0 && pending.size() + newChanges.size() > maxBatchChanges) {
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                newChanges = Collections.emptyList();
                return;
            }
        }
        for (ChangeLookup p : pending) {
            if (newChangeIds.contains(p.changeKey)) {
                reject(magicBranch.cmd, "squash commits first");
                newChanges = Collections.emptyList();
                return;
            }
            List<ChangeData> changes = p.destChanges;
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 1) {
                // 
                if (requestReplace(magicBranch.cmd, false, changes.get(0).change(), p.commit)) {
                    continue;
                } else {
                    newChanges = Collections.emptyList();
                    return;
                }
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    newChanges = Collections.emptyList();
                    return;
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(magicBranch.ctl, p.commit, p.changeKey));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        newChanges = Collections.emptyList();
        return;
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        newChanges = Collections.emptyList();
        return;
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return;
    }
    if (!newChanges.isEmpty() && magicBranch.edit) {
        reject(magicBranch.cmd, "edit is not supported for new changes");
        return;
    }
    try {
        Multimap<ObjectId, String> groups = groupCollector.getGroups();
        for (CreateRequest create : newChanges) {
            batch.addCommand(create.cmd);
            create.groups = groups.get(create.commit);
        }
        for (ReplaceRequest replace : replaceByChange.values()) {
            replace.groups = groups.get(replace.newCommit);
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.groups = Sets.newHashSet(groups.get(update.commit));
        }
    } catch (OrmException e) {
        log.error("Error collecting groups for changes", e);
        reject(magicBranch.cmd, "internal server error");
        return;
    }
}
#method_after
private void selectNewAndReplacedChangesFromMagicBranch() {
    newChanges = new ArrayList<>();
    SetMultimap<ObjectId, Ref> existing = changeRefsById();
    GroupCollector groupCollector = GroupCollector.create(refsById, db, psUtil, notesFactory, project.getNameKey());
    rp.getRevWalk().reset();
    rp.getRevWalk().sort(RevSort.TOPO);
    rp.getRevWalk().sort(RevSort.REVERSE, true);
    try {
        rp.getRevWalk().markStart(rp.getRevWalk().parseCommit(magicBranch.cmd.getNewId()));
        if (magicBranch.baseCommit != null) {
            for (RevCommit c : magicBranch.baseCommit) {
                rp.getRevWalk().markUninteresting(c);
            }
            Ref targetRef = allRefs.get(magicBranch.ctl.getRefName());
            if (targetRef != null) {
                rp.getRevWalk().markUninteresting(rp.getRevWalk().parseCommit(targetRef.getObjectId()));
            }
        } else {
            markHeadsAsUninteresting(rp.getRevWalk(), magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
        }
        List<ChangeLookup> pending = new ArrayList<>();
        Set<Change.Key> newChangeIds = new HashSet<>();
        int maxBatchChanges = receiveConfig.getEffectiveMaxBatchChangesLimit(user);
        for (; ; ) {
            RevCommit c = rp.getRevWalk().next();
            if (c == null) {
                break;
            }
            groupCollector.visit(c);
            Collection<Ref> existingRefs = existing.get(c);
            if (!existingRefs.isEmpty()) {
                // A's group.
                for (Ref ref : existingRefs) {
                    updateGroups.add(new UpdateGroupsRequest(ref, c));
                }
                continue;
            }
            if (!validCommit(rp.getRevWalk(), magicBranch.ctl, magicBranch.cmd, c)) {
                // Not a change the user can propose? Abort as early as possible.
                newChanges = Collections.emptyList();
                return;
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
            }
            List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(c, magicBranch.dest.get()));
                continue;
            }
            String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                newChanges = Collections.emptyList();
                return;
            }
            pending.add(new ChangeLookup(c, new Change.Key(idStr)));
            if (maxBatchChanges != 0 && pending.size() + newChanges.size() > maxBatchChanges) {
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                newChanges = Collections.emptyList();
                return;
            }
        }
        for (ChangeLookup p : pending) {
            if (newChangeIds.contains(p.changeKey)) {
                reject(magicBranch.cmd, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
                newChanges = Collections.emptyList();
                return;
            }
            List<ChangeData> changes = p.destChanges;
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 1) {
                // 
                if (requestReplace(magicBranch.cmd, false, changes.get(0).change(), p.commit)) {
                    continue;
                }
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    newChanges = Collections.emptyList();
                    return;
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(p.commit, magicBranch.dest.get()));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        newChanges = Collections.emptyList();
        return;
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        newChanges = Collections.emptyList();
        return;
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return;
    }
    if (!newChanges.isEmpty() && magicBranch.edit) {
        reject(magicBranch.cmd, "edit is not supported for new changes");
        return;
    }
    try {
        SortedSetMultimap<ObjectId, String> groups = groupCollector.getGroups();
        for (CreateRequest create : newChanges) {
            batch.addCommand(create.cmd);
            create.groups = ImmutableList.copyOf(groups.get(create.commitId));
        }
        for (ReplaceRequest replace : replaceByChange.values()) {
            replace.groups = ImmutableList.copyOf(groups.get(replace.newCommitId));
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.groups = ImmutableList.copyOf((groups.get(update.commit)));
        }
    } catch (OrmException | NoSuchChangeException e) {
        log.error("Error collecting groups for changes", e);
        reject(magicBranch.cmd, "internal server error");
        return;
    }
}
#end_block

#method_before
private void submit(ChangeControl changeCtl, PatchSet ps) throws OrmException, ResourceConflictException {
    Submit submit = submitProvider.get();
    RevisionResource rsrc = new RevisionResource(changes.parse(changeCtl), ps);
    try {
        mergeOpProvider.get().merge(db, rsrc.getChange(), changeCtl.getUser().asIdentifiedUser(), false);
    } catch (NoSuchChangeException e) {
        throw new OrmException(e);
    }
    addMessage("");
    Change c = db.changes().get(rsrc.getChange().getId());
    switch(c.getStatus()) {
        case MERGED:
            addMessage("Change " + c.getChangeId() + " merged.");
            break;
        case NEW:
            ChangeMessage msg = submit.getConflictMessage(rsrc);
            if (msg != null) {
                addMessage("Change " + c.getChangeId() + ": " + msg.getMessage());
                break;
            }
        // $FALL-THROUGH$
        default:
            addMessage("change " + c.getChangeId() + " is " + c.getStatus().name().toLowerCase());
    }
}
#method_after
private void submit(Collection<CreateRequest> create, Collection<ReplaceRequest> replace) throws OrmException, RestApiException {
    Map<ObjectId, Change> bySha = Maps.newHashMapWithExpectedSize(create.size() + replace.size());
    for (CreateRequest r : create) {
        checkNotNull(r.change, "cannot submit new change %s; op may not have run", r.changeId);
        bySha.put(r.commitId, r.change);
    }
    for (ReplaceRequest r : replace) {
        bySha.put(r.newCommitId, r.change);
    }
    Change tipChange = bySha.get(magicBranch.cmd.getNewId());
    checkState(tipChange != null, "tip of push does not correspond to a change; found these changes: %s", bySha);
    try (MergeOp op = mergeOpProvider.get()) {
        op.merge(db, tipChange, user, false, new SubmitInput());
    }
}
#end_block

#method_before
private void readChangesForReplace() throws OrmException {
    List<CheckedFuture<Change, OrmException>> futures = Lists.newArrayListWithCapacity(replaceByChange.size());
    for (ReplaceRequest request : replaceByChange.values()) {
        futures.add(db.changes().getAsync(request.ontoChange));
    }
    for (CheckedFuture<Change, OrmException> f : futures) {
        Change c = f.checkedGet();
        if (c != null) {
            replaceByChange.get(c.getId()).change = c;
        }
    }
}
#method_after
private void readChangesForReplace() throws OrmException {
    List<CheckedFuture<ChangeNotes, OrmException>> futures = Lists.newArrayListWithCapacity(replaceByChange.size());
    for (ReplaceRequest request : replaceByChange.values()) {
        futures.add(notesFactory.createAsync(changeUpdateExector, db, project.getNameKey(), request.ontoChange));
    }
    for (CheckedFuture<ChangeNotes, OrmException> f : futures) {
        ChangeNotes notes = f.checkedGet();
        if (notes.getChange() != null) {
            replaceByChange.get(notes.getChangeId()).change = notes.getChange();
        }
    }
}
#end_block

#method_before
boolean validate(boolean autoClose) throws IOException, OrmException {
    if (!autoClose && inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    } else if (change == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    priorPatchSet = change.currentPatchSetId();
    if (!revisions.containsValue(priorPatchSet)) {
        reject(inputCommand, "change " + ontoChange + " missing revisions");
        return false;
    }
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    if (newCommit == priorCommit) {
        // Ignore requests to make the change its current state.
        skip = true;
        reject(inputCommand, "commit already exists (as current patchset)");
        return false;
    }
    changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet(db)) {
        String locked = ".";
        if (changeCtl.isPatchSetLocked(db)) {
            locked = ". Change is patch set locked.";
        }
        reject(inputCommand, "cannot replace " + ontoChange + locked);
        return false;
    } else if (change.getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    } else if (revisions.containsKey(newCommit)) {
        reject(inputCommand, "commit already exists (in the change)");
        return false;
    }
    for (final Ref r : rp.getRepository().getRefDatabase().getRefs("refs/changes").values()) {
        if (r.getObjectId().equals(newCommit)) {
            reject(inputCommand, "commit already exists (in the project)");
            return false;
        }
    }
    for (RevCommit prior : revisions.keySet()) {
        // amending when trying to address review comments.
        if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
            reject(inputCommand, "squash commits first");
            return false;
        }
    }
    rp.getRevWalk().parseBody(newCommit);
    if (!validCommit(changeCtl.getRefControl(), inputCommand, newCommit)) {
        return false;
    }
    rp.getRevWalk().parseBody(priorCommit);
    // of the commit was modified.
    if (newCommit.getTree() == priorCommit.getTree()) {
        final boolean messageEq = eq(newCommit.getFullMessage(), priorCommit.getFullMessage());
        final boolean parentsEq = parentsEqual(newCommit, priorCommit);
        final boolean authorEq = authorEqual(newCommit, priorCommit);
        final ObjectReader reader = rp.getRevWalk().getObjectReader();
        if (messageEq && parentsEq && authorEq && !autoClose) {
            addMessage(String.format("(W) No changes between prior commit %s and new commit %s", reader.abbreviate(priorCommit).name(), reader.abbreviate(newCommit).name()));
            reject(inputCommand, "no changes made");
            return false;
        } else {
            StringBuilder msg = new StringBuilder();
            msg.append("(W) ");
            msg.append(reader.abbreviate(newCommit).name());
            msg.append(":");
            msg.append(" no files changed");
            if (!authorEq) {
                msg.append(", author changed");
            }
            if (!messageEq) {
                msg.append(", message updated");
            }
            if (!parentsEq) {
                msg.append(", was rebased");
            }
            addMessage(msg.toString());
        }
    }
    if (magicBranch != null && magicBranch.edit) {
        return newEdit();
    }
    newPatchSet();
    return true;
}
#method_after
boolean validate(boolean autoClose) throws IOException, OrmException {
    if (!autoClose && inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    } else if (change == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    priorPatchSet = change.currentPatchSetId();
    if (!revisions.containsValue(priorPatchSet)) {
        reject(inputCommand, "change " + ontoChange + " missing revisions");
        return false;
    }
    RevCommit newCommit = rp.getRevWalk().parseCommit(newCommitId);
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    if (newCommit.equals(priorCommit)) {
        // Ignore requests to make the change its current state.
        skip = true;
        reject(inputCommand, "commit already exists (as current patchset)");
        return false;
    }
    changeCtl = projectControl.controlFor(db, change);
    if (!changeCtl.canAddPatchSet(db)) {
        String locked = ".";
        if (changeCtl.isPatchSetLocked(db)) {
            locked = ". Change is patch set locked.";
        }
        reject(inputCommand, "cannot replace " + ontoChange + locked);
        return false;
    } else if (change.getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    } else if (revisions.containsKey(newCommit)) {
        reject(inputCommand, "commit already exists (in the change)");
        return false;
    }
    for (Ref r : rp.getRepository().getRefDatabase().getRefs("refs/changes").values()) {
        if (r.getObjectId().equals(newCommit)) {
            reject(inputCommand, "commit already exists (in the project)");
            return false;
        }
    }
    for (RevCommit prior : revisions.keySet()) {
        // amending when trying to address review comments.
        if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
            reject(inputCommand, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
            return false;
        }
    }
    if (!validCommit(rp.getRevWalk(), changeCtl.getRefControl(), inputCommand, newCommit)) {
        return false;
    }
    rp.getRevWalk().parseBody(priorCommit);
    // of the commit was modified.
    if (newCommit.getTree().equals(priorCommit.getTree())) {
        boolean messageEq = eq(newCommit.getFullMessage(), priorCommit.getFullMessage());
        boolean parentsEq = parentsEqual(newCommit, priorCommit);
        boolean authorEq = authorEqual(newCommit, priorCommit);
        ObjectReader reader = rp.getRevWalk().getObjectReader();
        if (messageEq && parentsEq && authorEq && !autoClose) {
            addMessage(String.format("(W) No changes between prior commit %s and new commit %s", reader.abbreviate(priorCommit).name(), reader.abbreviate(newCommit).name()));
        } else {
            StringBuilder msg = new StringBuilder();
            msg.append("(I) ");
            msg.append(reader.abbreviate(newCommit).name());
            msg.append(":");
            msg.append(" no files changed");
            if (!authorEq) {
                msg.append(", author changed");
            }
            if (!messageEq) {
                msg.append(", message updated");
            }
            if (!parentsEq) {
                msg.append(", was rebased");
            }
            addMessage(msg.toString());
        }
    }
    if (magicBranch != null && magicBranch.edit) {
        return newEdit();
    }
    newPatchSet();
    return true;
}
#end_block

#method_before
private boolean newEdit() {
    newPatchSet = new PatchSet(change.currentPatchSetId());
    Optional<ChangeEdit> edit = null;
    try {
        edit = editUtil.byChange(change, user);
    } catch (IOException e) {
        log.error("Cannt retrieve edit", e);
        return false;
    }
    if (edit.isPresent()) {
        if (edit.get().getBasePatchSet().getId().equals(newPatchSet.getId())) {
            // replace edit
            cmd = new ReceiveCommand(edit.get().getRef().getObjectId(), newCommit, edit.get().getRefName());
        } else {
            // delete old edit ref on rebase
            prev = new ReceiveCommand(edit.get().getRef().getObjectId(), ObjectId.zeroId(), edit.get().getRefName());
            createEditCommand();
        }
    } else {
        createEditCommand();
    }
    return true;
}
#method_after
private boolean newEdit() {
    psId = change.currentPatchSetId();
    Optional<ChangeEdit> edit = null;
    try {
        edit = editUtil.byChange(changeCtl);
    } catch (AuthException | IOException e) {
        log.error("Cannot retrieve edit", e);
        return false;
    }
    if (edit.isPresent()) {
        if (edit.get().getBasePatchSet().getId().equals(psId)) {
            // replace edit
            cmd = new ReceiveCommand(edit.get().getRef().getObjectId(), newCommitId, edit.get().getRefName());
        } else {
            // delete old edit ref on rebase
            prev = new ReceiveCommand(edit.get().getRef().getObjectId(), ObjectId.zeroId(), edit.get().getRefName());
            createEditCommand();
        }
    } else {
        createEditCommand();
    }
    return true;
}
#end_block

#method_before
private void createEditCommand() {
    // create new edit
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommit, RefNames.refsEdit(user.getAccountId(), change.getId(), newPatchSet.getId()));
}
#method_after
private void createEditCommand() {
    // create new edit
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommitId, RefNames.refsEdit(user.getAccountId(), change.getId(), psId));
}
#end_block

#method_before
private void newPatchSet() throws IOException {
    PatchSet.Id id = ChangeUtil.nextPatchSetId(allRefs, change.currentPatchSetId());
    newPatchSet = new PatchSet(id);
    newPatchSet.setCreatedOn(TimeUtil.nowTs());
    newPatchSet.setUploader(user.getAccountId());
    newPatchSet.setRevision(toRevId(newCommit));
    newPatchSet.setGroups(groups);
    if (rp.getPushCertificate() != null) {
        newPatchSet.setPushCertificate(rp.getPushCertificate().toTextWithSignature());
    }
    if (magicBranch != null && magicBranch.draft) {
        newPatchSet.setDraft(true);
    }
    info = patchSetInfoFactory.get(rp.getRevWalk(), newCommit, newPatchSet.getId());
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommit, newPatchSet.getRefName());
}
#method_after
private void newPatchSet() throws IOException {
    RevCommit newCommit = rp.getRevWalk().parseCommit(newCommitId);
    psId = ChangeUtil.nextPatchSetId(allRefs, change.currentPatchSetId());
    info = patchSetInfoFactory.get(rp.getRevWalk(), newCommit, psId);
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommitId, psId.toRefName());
}
#end_block

#method_before
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    if (ctl.canForgeAuthor() && ctl.canForgeCommitter() && ctl.canForgeGerritServerIdentity() && ctl.canUploadMerges() && !projectControl.getProjectState().isUseSignedOffBy() && Iterables.isEmpty(rejectCommits) && !RefNames.REFS_CONFIG.equals(ctl.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        return;
    }
    boolean defaultName = Strings.isNullOrEmpty(user.getAccount().getFullName());
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        RevObject parsedObject = walk.parseAny(cmd.getNewId());
        if (!(parsedObject instanceof RevCommit)) {
            return;
        }
        walk.markStart((RevCommit) parsedObject);
        markHeadsAsUninteresting(walk, cmd.getRefName());
        Set<ObjectId> existing = changeRefsById().keySet();
        for (RevCommit c; (c = walk.next()) != null; ) {
            if (existing.contains(c)) {
                continue;
            } else if (!validCommit(ctl, cmd, c)) {
                break;
            }
            if (defaultName && user.hasEmailAddress(c.getCommitterIdent().getEmailAddress())) {
                try {
                    Account a = db.accounts().get(user.getAccountId());
                    if (a != null && Strings.isNullOrEmpty(a.getFullName())) {
                        a.setFullName(c.getCommitterIdent().getName());
                        db.accounts().update(Collections.singleton(a));
                        user.getAccount().setFullName(a.getFullName());
                        accountCache.evict(a.getId());
                    }
                } catch (OrmException e) {
                    log.warn("Cannot default full_name", e);
                } finally {
                    defaultName = false;
                }
            }
        }
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#method_after
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    if (ctl.canForgeAuthor() && ctl.canForgeCommitter() && ctl.canForgeGerritServerIdentity() && ctl.canUploadMerges() && !projectControl.getProjectState().isUseSignedOffBy() && Iterables.isEmpty(rejectCommits) && !RefNames.REFS_CONFIG.equals(ctl.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        return;
    }
    boolean defaultName = Strings.isNullOrEmpty(user.getAccount().getFullName());
    RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        RevObject parsedObject = walk.parseAny(cmd.getNewId());
        if (!(parsedObject instanceof RevCommit)) {
            return;
        }
        walk.markStart((RevCommit) parsedObject);
        markHeadsAsUninteresting(walk, cmd.getRefName());
        Set<ObjectId> existing = changeRefsById().keySet();
        for (RevCommit c; (c = walk.next()) != null; ) {
            if (existing.contains(c)) {
                continue;
            } else if (!validCommit(walk, ctl, cmd, c)) {
                break;
            }
            if (defaultName && user.hasEmailAddress(c.getCommitterIdent().getEmailAddress())) {
                try {
                    Account a = db.accounts().get(user.getAccountId());
                    if (a != null && Strings.isNullOrEmpty(a.getFullName())) {
                        a.setFullName(c.getCommitterIdent().getName());
                        db.accounts().update(Collections.singleton(a));
                        user.getAccount().setFullName(a.getFullName());
                        accountCache.evict(a.getId());
                    }
                } catch (OrmException e) {
                    log.warn("Cannot default full_name", e);
                } finally {
                    defaultName = false;
                }
            }
        }
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#end_block

#method_before
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) {
    if (validCommits.contains(c)) {
        return true;
    }
    CommitReceivedEvent receiveEvent = new CommitReceivedEvent(cmd, project, ctl.getRefName(), c, user);
    CommitValidators commitValidators = commitValidatorsFactory.create(ctl, sshInfo, repo);
    try {
        messages.addAll(commitValidators.validateForReceiveCommits(receiveEvent, rejectCommits));
    } catch (CommitValidationException e) {
        messages.addAll(e.getMessages());
        reject(cmd, e.getMessage());
        return false;
    }
    validCommits.add(c);
    return true;
}
#method_after
private boolean validCommit(RevWalk rw, RefControl ctl, ReceiveCommand cmd, ObjectId id) throws IOException {
    if (validCommits.contains(id)) {
        return true;
    }
    RevCommit c = rw.parseCommit(id);
    rw.parseBody(c);
    CommitReceivedEvent receiveEvent = new CommitReceivedEvent(cmd, project, ctl.getRefName(), c, user);
    CommitValidators commitValidators = commitValidatorsFactory.create(ctl, sshInfo, repo);
    try {
        messages.addAll(commitValidators.validateForReceiveCommits(receiveEvent, rejectCommits));
    } catch (CommitValidationException e) {
        messages.addAll(e.getMessages());
        reject(cmd, e.getMessage());
        return false;
    }
    validCommits.add(c.copy());
    return true;
}
#end_block

#method_before
private void autoCloseChanges(final ReceiveCommand cmd) {
    final RevWalk rw = rp.getRevWalk();
    try {
        RevCommit newTip = rw.parseCommit(cmd.getNewId());
        Branch.NameKey branch = new Branch.NameKey(project.getNameKey(), cmd.getRefName());
        rw.reset();
        rw.markStart(newTip);
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final SetMultimap<ObjectId, Ref> byCommit = changeRefsById();
        Map<Change.Key, Change> byKey = null;
        final List<ReplaceRequest> toClose = new ArrayList<>();
        for (RevCommit c; (c = rw.next()) != null; ) {
            rw.parseBody(c);
            for (Ref ref : byCommit.get(c.copy())) {
                Change.Key closedChange = closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                closeProgress.update(1);
                if (closedChange != null) {
                    if (byKey == null) {
                        byKey = openChangesByBranch(branch);
                    }
                    byKey.remove(closedChange);
                }
            }
            for (final String changeId : c.getFooterLines(CHANGE_ID)) {
                if (byKey == null) {
                    byKey = openChangesByBranch(branch);
                }
                final Change onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    final ReplaceRequest req = new ReplaceRequest(onto.getId(), c, cmd, false);
                    req.change = onto;
                    toClose.add(req);
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = req.validate(true) ? req.insertPatchSet().checkedGet() : null;
            if (psi != null) {
                closeChange(req.inputCommand, psi, req.newCommit);
                closeProgress.update(1);
            }
        }
    } catch (RestApiException e) {
        log.error("Can't insert patchset", e);
    } catch (IOException | OrmException e) {
        log.error("Can't scan for changes to close", e);
    }
}
#method_after
private void autoCloseChanges(final ReceiveCommand cmd) {
    String refName = cmd.getRefName();
    checkState(!MagicBranch.isMagicBranch(refName), "shouldn't be auto-closing changes on magic branch %s", refName);
    RevWalk rw = rp.getRevWalk();
    // insertChangesAndPatchSets.
    try (BatchUpdate bu = batchUpdateFactory.create(db, projectControl.getProject().getNameKey(), user, TimeUtil.nowTs());
        ObjectInserter ins = repo.newObjectInserter()) {
        bu.setRepository(repo, rp.getRevWalk(), ins).updateChangesInParallel();
        // TODO(dborowitz): Teach BatchUpdate to ignore missing changes.
        RevCommit newTip = rw.parseCommit(cmd.getNewId());
        Branch.NameKey branch = new Branch.NameKey(project.getNameKey(), refName);
        rw.reset();
        rw.markStart(newTip);
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        SetMultimap<ObjectId, Ref> byCommit = changeRefsById();
        Map<Change.Key, Change> byKey = null;
        COMMIT: for (RevCommit c; (c = rw.next()) != null; ) {
            rw.parseBody(c);
            for (Ref ref : byCommit.get(c.copy())) {
                PatchSet.Id psId = PatchSet.Id.fromRef(ref.getName());
                bu.addOp(psId.getParentKey(), mergedByPushOpFactory.create(requestScopePropagator, psId, refName));
                continue COMMIT;
            }
            for (String changeId : c.getFooterLines(CHANGE_ID)) {
                if (byKey == null) {
                    byKey = openChangesByBranch(branch);
                }
                Change onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    Change.Id id = onto.getId();
                    final ReplaceRequest req = new ReplaceRequest(id, c, cmd, false);
                    req.change = onto;
                    if (req.validate(true)) {
                        req.addOps(bu, null);
                        bu.addOp(id, mergedByPushOpFactory.create(requestScopePropagator, req.psId, refName).setPatchSetProvider(new Provider<PatchSet>() {

                            @Override
                            public PatchSet get() {
                                return req.replaceOp.getPatchSet();
                            }
                        }));
                        bu.addOp(id, new ChangeProgressOp(closeProgress));
                    }
                    break;
                }
            }
        }
        bu.execute();
    } catch (RestApiException e) {
        log.error("Can't insert patchset", e);
    } catch (IOException | OrmException | UpdateException e) {
        log.error("Can't scan for changes to close", e);
    }
}
#end_block

#method_before
private Map<Change.Key, Change> openChangesByBranch(Branch.NameKey branch) throws OrmException {
    final Map<Change.Key, Change> r = new HashMap<>();
    for (ChangeData cd : queryProvider.get().byBranchOpen(branch)) {
        r.put(cd.change().getKey(), cd.change());
    }
    return r;
}
#method_after
private Map<Change.Key, Change> openChangesByBranch(Branch.NameKey branch) throws OrmException {
    Map<Change.Key, Change> r = new HashMap<>();
    for (ChangeData cd : queryProvider.get().byBranchOpen(branch)) {
        r.put(cd.change().getKey(), cd.change());
    }
    return r;
}
#end_block

#method_before
private void reject(final ReceiveCommand cmd) {
    reject(cmd, "prohibited by Gerrit");
}
#method_after
private void reject(ReceiveCommand cmd) {
    reject(cmd, "prohibited by Gerrit");
}
#end_block

#method_before
private void reject(final ReceiveCommand cmd, final String why) {
    cmd.setResult(REJECTED_OTHER_REASON, why);
    commandProgress.update(1);
}
#method_after
private void reject(ReceiveCommand cmd, String why) {
    cmd.setResult(REJECTED_OTHER_REASON, why);
    commandProgress.update(1);
}
#end_block

#method_before
private static boolean isHead(final ReceiveCommand cmd) {
    return cmd.getRefName().startsWith(Constants.R_HEADS);
}
#method_after
private static boolean isHead(ReceiveCommand cmd) {
    return cmd.getRefName().startsWith(Constants.R_HEADS);
}
#end_block

#method_before
private static boolean isConfig(final ReceiveCommand cmd) {
    return cmd.getRefName().equals(RefNames.REFS_CONFIG);
}
#method_after
private static boolean isConfig(ReceiveCommand cmd) {
    return cmd.getRefName().equals(RefNames.REFS_CONFIG);
}
#end_block

#method_before
@Override
public Response<String> apply(ChangeResource req, Input input) throws UpdateException, RestApiException {
    ChangeControl ctl = req.getControl();
    if (!ctl.canEditTopicName()) {
        throw new AuthException("changing topic not permitted");
    }
    Op op = new Op(ctl, input != null ? input : new Input());
    try (BatchUpdate u = batchUpdateFactory.create(dbProvider.get(), req.getChange().getProject(), ctl.getUser(), TimeUtil.nowTs())) {
        u.addOp(req.getChange().getId(), op);
        u.execute();
    }
    return Strings.isNullOrEmpty(op.newTopicName) ? Response.<String>none() : Response.ok(op.newTopicName);
}
#method_after
@Override
public Response<String> apply(ChangeResource req, Input input) throws UpdateException, RestApiException {
    ChangeControl ctl = req.getControl();
    if (!ctl.canEditTopicName()) {
        throw new AuthException("changing topic not permitted");
    }
    Op op = new Op(input != null ? input : new Input());
    try (BatchUpdate u = batchUpdateFactory.create(dbProvider.get(), req.getChange().getProject(), ctl.getUser(), TimeUtil.nowTs())) {
        u.addOp(req.getId(), op);
        u.execute();
    }
    return Strings.isNullOrEmpty(op.newTopicName) ? Response.<String>none() : Response.ok(op.newTopicName);
}
#end_block

#method_before
@Override
public void updateChange(ChangeContext ctx) throws OrmException {
    change = ctx.getChange();
    newTopicName = Strings.nullToEmpty(input.topic);
    oldTopicName = Strings.nullToEmpty(change.getTopic());
    if (oldTopicName.equals(newTopicName)) {
        return;
    }
    String summary;
    if (oldTopicName.isEmpty()) {
        summary = "Topic set to " + newTopicName;
    } else if (newTopicName.isEmpty()) {
        summary = "Topic " + oldTopicName + " removed";
    } else {
        summary = String.format("Topic changed from %s to %s", oldTopicName, newTopicName);
    }
    change.setTopic(Strings.emptyToNull(newTopicName));
    ChangeUtil.updated(change);
    ctx.getDb().changes().update(Collections.singleton(change));
    ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(ctx.getDb())), caller.getAccountId(), ctx.getWhen(), change.currentPatchSetId());
    cmsg.setMessage(summary);
    cmUtil.addChangeMessage(ctx.getDb(), ctx.getChangeUpdate(), cmsg);
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException {
    change = ctx.getChange();
    ChangeUpdate update = ctx.getUpdate(change.currentPatchSetId());
    newTopicName = Strings.nullToEmpty(input.topic);
    oldTopicName = Strings.nullToEmpty(change.getTopic());
    if (oldTopicName.equals(newTopicName)) {
        return false;
    }
    String summary;
    if (oldTopicName.isEmpty()) {
        summary = "Topic set to " + newTopicName;
    } else if (newTopicName.isEmpty()) {
        summary = "Topic " + oldTopicName + " removed";
    } else {
        summary = String.format("Topic changed from %s to %s", oldTopicName, newTopicName);
    }
    change.setTopic(Strings.emptyToNull(newTopicName));
    update.setTopic(change.getTopic());
    ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(ctx.getDb())), ctx.getUser().getAccountId(), ctx.getWhen(), change.currentPatchSetId());
    cmsg.setMessage(summary);
    cmUtil.addChangeMessage(ctx.getDb(), update, cmsg);
    return true;
}
#end_block

#method_before
@Override
public void postUpdate(Context ctx) {
    if (change != null) {
        topicEdited.fire(change, caller.getAccount(), oldTopicName);
    }
}
#method_after
@Override
public void postUpdate(Context ctx) {
    if (change != null) {
        topicEdited.fire(change, ctx.getUser().asIdentifiedUser().getAccount(), oldTopicName);
    }
}
#end_block

#method_before
public ConfigInfo apply(ProjectControl ctrl, Input input) throws ResourceNotFoundException, BadRequestException, ResourceConflictException {
    Project.NameKey projectName = ctrl.getProject().getNameKey();
    if (input == null) {
        throw new BadRequestException("config is required");
    }
    final MetaDataUpdate md;
    try {
        md = metaDataUpdateFactory.get().create(projectName);
    } catch (RepositoryNotFoundException notFound) {
        throw new ResourceNotFoundException(projectName.get());
    } catch (IOException e) {
        throw new ResourceNotFoundException(projectName.get(), e);
    }
    try {
        ProjectConfig projectConfig = ProjectConfig.read(md);
        Project p = projectConfig.getProject();
        p.setDescription(Strings.emptyToNull(input.description));
        if (input.useContributorAgreements != null) {
            p.setUseContributorAgreements(input.useContributorAgreements);
        }
        if (input.useContentMerge != null) {
            p.setUseContentMerge(input.useContentMerge);
        }
        if (input.useSignedOffBy != null) {
            p.setUseSignedOffBy(input.useSignedOffBy);
        }
        if (input.createNewChangeForAllNotInTarget != null) {
            p.setCreateNewChangeForAllNotInTarget(input.createNewChangeForAllNotInTarget);
        }
        if (input.requireChangeId != null) {
            p.setRequireChangeID(input.requireChangeId);
        }
        if (serverEnableSignedPush) {
            if (input.enableSignedPush != null) {
                p.setEnableSignedPush(input.enableSignedPush);
            }
            if (input.requireSignedPush != null) {
                p.setRequireSignedPush(input.requireSignedPush);
            }
        }
        if (input.maxObjectSizeLimit != null) {
            p.setMaxObjectSizeLimit(input.maxObjectSizeLimit);
        }
        if (input.submitType != null) {
            p.setSubmitType(input.submitType);
        }
        if (input.state != null) {
            p.setState(input.state);
        }
        if (input.pluginConfigValues != null) {
            setPluginConfigValues(ctrl.getProjectState(), projectConfig, input.pluginConfigValues);
        }
        md.setMessage("Modified project settings\n");
        try {
            ObjectId baseRev = projectConfig.getRevision();
            ObjectId commitRev = projectConfig.commit(md);
            // Only fire hook if project was actually changed.
            if (!Objects.equals(baseRev, commitRev)) {
                gitRefUpdated.fire(projectName, RefNames.REFS_CONFIG, baseRev, commitRev, user.get().asIdentifiedUser().getAccount());
            }
            projectCache.evict(projectConfig.getProject());
            gitMgr.setProjectDescription(projectName, p.getDescription());
        } catch (IOException e) {
            if (e.getCause() instanceof ConfigInvalidException) {
                throw new ResourceConflictException("Cannot update " + projectName + ": " + e.getCause().getMessage());
            } else {
                log.warn(String.format("Failed to update config of project %s.", projectName), e);
                throw new ResourceConflictException("Cannot update " + projectName);
            }
        }
        ProjectState state = projectStateFactory.create(projectConfig);
        return new ConfigInfo(serverEnableSignedPush, state.controlFor(user.get()), config, pluginConfigEntries, cfgFactory, allProjects, views);
    } catch (ConfigInvalidException err) {
        throw new ResourceConflictException("Cannot read project " + projectName, err);
    } catch (IOException err) {
        throw new ResourceConflictException("Cannot update project " + projectName, err);
    } finally {
        md.close();
    }
}
#method_after
@Override
public ConfigInfo apply(ProjectResource rsrc, ConfigInput input) throws ResourceNotFoundException, BadRequestException, ResourceConflictException {
    if (!rsrc.getControl().isOwner()) {
        throw new ResourceNotFoundException(rsrc.getName());
    }
    return apply(rsrc.getControl(), input);
}
#end_block

#method_before
private void setPluginConfigValues(ProjectState projectState, ProjectConfig projectConfig, Map<String, Map<String, ConfigValue>> pluginConfigValues) throws BadRequestException {
    for (Entry<String, Map<String, ConfigValue>> e : pluginConfigValues.entrySet()) {
        String pluginName = e.getKey();
        PluginConfig cfg = projectConfig.getPluginConfig(pluginName);
        for (Entry<String, ConfigValue> v : e.getValue().entrySet()) {
            ProjectConfigEntry projectConfigEntry = pluginConfigEntries.get(pluginName, v.getKey());
            if (projectConfigEntry != null) {
                if (!isValidParameterName(v.getKey())) {
                    log.warn(String.format("Parameter name '%s' must match '^[a-zA-Z0-9]+[a-zA-Z0-9-]*$'", v.getKey()));
                    continue;
                }
                String oldValue = cfg.getString(v.getKey());
                String value = v.getValue().value;
                if (projectConfigEntry.getType() == ProjectConfigEntry.Type.ARRAY) {
                    List<String> l = Arrays.asList(cfg.getStringList(v.getKey()));
                    oldValue = Joiner.on("\n").join(l);
                    value = Joiner.on("\n").join(v.getValue().values);
                }
                if (Strings.emptyToNull(value) != null) {
                    if (!value.equals(oldValue)) {
                        validateProjectConfigEntryIsEditable(projectConfigEntry, projectState, v.getKey(), pluginName);
                        v.setValue(projectConfigEntry.preUpdate(v.getValue()));
                        value = v.getValue().value;
                        try {
                            switch(projectConfigEntry.getType()) {
                                case BOOLEAN:
                                    boolean newBooleanValue = Boolean.parseBoolean(value);
                                    cfg.setBoolean(v.getKey(), newBooleanValue);
                                    break;
                                case INT:
                                    int newIntValue = Integer.parseInt(value);
                                    cfg.setInt(v.getKey(), newIntValue);
                                    break;
                                case LONG:
                                    long newLongValue = Long.parseLong(value);
                                    cfg.setLong(v.getKey(), newLongValue);
                                    break;
                                case LIST:
                                    if (!projectConfigEntry.getPermittedValues().contains(value)) {
                                        throw new BadRequestException(String.format("The value '%s' is not permitted for parameter '%s' of plugin '" + pluginName + "'", value, v.getKey()));
                                    }
                                // $FALL-THROUGH$
                                case STRING:
                                    cfg.setString(v.getKey(), value);
                                    break;
                                case ARRAY:
                                    cfg.setStringList(v.getKey(), v.getValue().values);
                                    break;
                                default:
                                    log.warn(String.format("The type '%s' of parameter '%s' is not supported.", projectConfigEntry.getType().name(), v.getKey()));
                            }
                        } catch (NumberFormatException ex) {
                            throw new BadRequestException(String.format("The value '%s' of config parameter '%s' of plugin '%s' is invalid: %s", v.getValue(), v.getKey(), pluginName, ex.getMessage()));
                        }
                    }
                } else {
                    if (oldValue != null) {
                        validateProjectConfigEntryIsEditable(projectConfigEntry, projectState, v.getKey(), pluginName);
                        cfg.unset(v.getKey());
                    }
                }
            } else {
                throw new BadRequestException(String.format("The config parameter '%s' of plugin '%s' does not exist.", v.getKey(), pluginName));
            }
        }
    }
}
#method_after
private void setPluginConfigValues(ProjectState projectState, ProjectConfig projectConfig, Map<String, Map<String, ConfigValue>> pluginConfigValues) throws BadRequestException {
    for (Entry<String, Map<String, ConfigValue>> e : pluginConfigValues.entrySet()) {
        String pluginName = e.getKey();
        PluginConfig cfg = projectConfig.getPluginConfig(pluginName);
        for (Entry<String, ConfigValue> v : e.getValue().entrySet()) {
            ProjectConfigEntry projectConfigEntry = pluginConfigEntries.get(pluginName, v.getKey());
            if (projectConfigEntry != null) {
                if (!isValidParameterName(v.getKey())) {
                    log.warn(String.format("Parameter name '%s' must match '^[a-zA-Z0-9]+[a-zA-Z0-9-]*$'", v.getKey()));
                    continue;
                }
                String oldValue = cfg.getString(v.getKey());
                String value = v.getValue().value;
                if (projectConfigEntry.getType() == ProjectConfigEntryType.ARRAY) {
                    List<String> l = Arrays.asList(cfg.getStringList(v.getKey()));
                    oldValue = Joiner.on("\n").join(l);
                    value = Joiner.on("\n").join(v.getValue().values);
                }
                if (Strings.emptyToNull(value) != null) {
                    if (!value.equals(oldValue)) {
                        validateProjectConfigEntryIsEditable(projectConfigEntry, projectState, v.getKey(), pluginName);
                        v.setValue(projectConfigEntry.preUpdate(v.getValue()));
                        value = v.getValue().value;
                        try {
                            switch(projectConfigEntry.getType()) {
                                case BOOLEAN:
                                    boolean newBooleanValue = Boolean.parseBoolean(value);
                                    cfg.setBoolean(v.getKey(), newBooleanValue);
                                    break;
                                case INT:
                                    int newIntValue = Integer.parseInt(value);
                                    cfg.setInt(v.getKey(), newIntValue);
                                    break;
                                case LONG:
                                    long newLongValue = Long.parseLong(value);
                                    cfg.setLong(v.getKey(), newLongValue);
                                    break;
                                case LIST:
                                    if (!projectConfigEntry.getPermittedValues().contains(value)) {
                                        throw new BadRequestException(String.format("The value '%s' is not permitted for parameter '%s' of plugin '" + pluginName + "'", value, v.getKey()));
                                    }
                                // $FALL-THROUGH$
                                case STRING:
                                    cfg.setString(v.getKey(), value);
                                    break;
                                case ARRAY:
                                    cfg.setStringList(v.getKey(), v.getValue().values);
                                    break;
                                default:
                                    log.warn(String.format("The type '%s' of parameter '%s' is not supported.", projectConfigEntry.getType().name(), v.getKey()));
                            }
                        } catch (NumberFormatException ex) {
                            throw new BadRequestException(String.format("The value '%s' of config parameter '%s' of plugin '%s' is invalid: %s", v.getValue(), v.getKey(), pluginName, ex.getMessage()));
                        }
                    }
                } else {
                    if (oldValue != null) {
                        validateProjectConfigEntryIsEditable(projectConfigEntry, projectState, v.getKey(), pluginName);
                        cfg.unset(v.getKey());
                    }
                }
            } else {
                throw new BadRequestException(String.format("The config parameter '%s' of plugin '%s' does not exist.", v.getKey(), pluginName));
            }
        }
    }
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ChangeAbandonedListener.class).to(ChangeHookApiListener.class);
    bind(ChangeMergedListener.class).to(ChangeHookApiListener.class);
    bind(ChangeRestoredListener.class).to(ChangeHookApiListener.class);
    bind(CommentAddedListener.class).to(ChangeHookApiListener.class);
    bind(DraftPublishedListener.class).to(ChangeHookApiListener.class);
    bind(GitReferenceUpdatedListener.class).to(ChangeHookApiListener.class);
    bind(HashtagsEditedListener.class).to(ChangeHookApiListener.class);
    bind(MergeFailedListener.class).to(ChangeHookApiListener.class);
    bind(NewProjectCreatedListener.class).to(ChangeHookApiListener.class);
    bind(ReviewerAddedListener.class).to(ChangeHookApiListener.class);
    bind(RevisionCreatedListener.class).to(ChangeHookApiListener.class);
    bind(TopicEditedListener.class).to(ChangeHookApiListener.class);
    DynamicSet.bind(binder(), CommitValidationListener.class).to(ChangeHookValidator.class);
}
#method_after
@Override
protected void configure() {
    DynamicSet.bind(binder(), AgreementSignupListener.class).to(ChangeHookApiListener.class);
    DynamicSet.bind(binder(), ChangeAbandonedListener.class).to(ChangeHookApiListener.class);
    DynamicSet.bind(binder(), ChangeMergedListener.class).to(ChangeHookApiListener.class);
    DynamicSet.bind(binder(), ChangeRestoredListener.class).to(ChangeHookApiListener.class);
    DynamicSet.bind(binder(), CommentAddedListener.class).to(ChangeHookApiListener.class);
    DynamicSet.bind(binder(), DraftPublishedListener.class).to(ChangeHookApiListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ChangeHookApiListener.class);
    DynamicSet.bind(binder(), HashtagsEditedListener.class).to(ChangeHookApiListener.class);
    DynamicSet.bind(binder(), NewProjectCreatedListener.class).to(ChangeHookApiListener.class);
    DynamicSet.bind(binder(), ReviewerAddedListener.class).to(ChangeHookApiListener.class);
    DynamicSet.bind(binder(), RevisionCreatedListener.class).to(ChangeHookApiListener.class);
    DynamicSet.bind(binder(), TopicEditedListener.class).to(ChangeHookApiListener.class);
    DynamicSet.bind(binder(), CommitValidationListener.class).to(ChangeHookValidator.class);
}
#end_block

#method_before
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    IdentifiedUser user = receiveEvent.user;
    String refname = receiveEvent.refName;
    ObjectId old = receiveEvent.commit.getParent(0);
    if (receiveEvent.command.getRefName().startsWith(REFS_CHANGES)) {
        /*
          * If the ref-update hook tries to distinguish behavior between pushes to
          * refs/heads/... and refs/for/..., make sure we send it the correct refname.
          * Also, if this is targetting refs/for/, make sure we behave the same as
          * what a push to refs/for/ would behave; in particular, setting oldrev to
          * 0000000000000000000000000000000000000000.
          */
        refname = refname.replace(R_HEADS, "refs/for/refs/heads/");
        old = ObjectId.zeroId();
    }
    HookResult result = hooks.doRefUpdateHook(receiveEvent.project, refname, user.getAccount(), old, receiveEvent.commit);
    if (result != null && result.getExitValue() != 0) {
        throw new CommitValidationException(result.toString().trim());
    }
    return Collections.emptyList();
}
#method_after
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    IdentifiedUser user = receiveEvent.user;
    String refname = receiveEvent.refName;
    ObjectId old = ObjectId.zeroId();
    if (receiveEvent.commit.getParentCount() > 0) {
        old = receiveEvent.commit.getParent(0);
    }
    if (receiveEvent.command.getRefName().startsWith(REFS_CHANGES)) {
        /*
        * If the ref-update hook tries to distinguish behavior between pushes to
        * refs/heads/... and refs/for/..., make sure we send it the correct
        * refname.
        * Also, if this is targetting refs/for/, make sure we behave the same as
        * what a push to refs/for/ would behave; in particular, setting oldrev
        * to 0000000000000000000000000000000000000000.
        */
        refname = refname.replace(R_HEADS, "refs/for/refs/heads/");
        old = ObjectId.zeroId();
    }
    HookResult result = hooks.doRefUpdateHook(receiveEvent.project, refname, user.getAccount(), old, receiveEvent.commit);
    if (result != null && result.getExitValue() != 0) {
        throw new CommitValidationException(result.toString().trim());
    }
    return Collections.emptyList();
}
#end_block

#method_before
@Override
public void onRevisionCreated(RevisionCreatedListener.Event ev) {
    try {
        hooks.doPatchsetCreatedHook(getChange(ev.getChange()), getPatchSet(ev.getRevision()), db.get());
    } catch (OrmException e) {
    }
}
#method_after
@Override
public void onRevisionCreated(RevisionCreatedListener.Event ev) {
    try {
        ChangeNotes notes = getNotes(ev.getChange());
        hooks.doPatchsetCreatedHook(notes.getChange(), getPatchSet(notes, ev.getRevision()), db.get());
    } catch (OrmException e) {
        log.error("PatchsetCreated hook failed to run " + ev.getChange()._number, e);
    }
}
#end_block

#method_before
@Override
public void onDraftPublished(DraftPublishedListener.Event ev) {
    try {
        hooks.doDraftPublishedHook(getChange(ev.getChange()), getPatchSet(ev.getRevision()), db.get());
    } catch (OrmException e) {
    }
}
#method_after
@Override
public void onDraftPublished(DraftPublishedListener.Event ev) {
    try {
        ChangeNotes notes = getNotes(ev.getChange());
        hooks.doDraftPublishedHook(notes.getChange(), getPatchSet(notes, ev.getRevision()), db.get());
    } catch (OrmException e) {
        log.error("DraftPublished hook failed to run " + ev.getChange()._number, e);
    }
}
#end_block

#method_before
@Override
public void onCommentAdded(CommentAddedListener.Event ev) {
    Map<String, Short> approvals = new HashMap<String, Short>();
    for (Entry<String, ApprovalInfo> e : ev.getApprovals().entrySet()) {
        approvals.put(e.getKey(), e.getValue().value.shortValue());
    }
    try {
        hooks.doCommentAddedHook(getChange(ev.getChange()), getAccount(ev.getAuthor()), getPatchSet(ev.getRevision()), ev.getComment(), approvals, db.get());
    } catch (OrmException e) {
        log.warn("CommentAdded hook failed to fun" + ev.getChange()._number, e);
    }
}
#method_after
@Override
public void onCommentAdded(CommentAddedListener.Event ev) {
    Map<String, Short> approvals = convertApprovalsMap(ev.getApprovals());
    Map<String, Short> oldApprovals = convertApprovalsMap(ev.getOldApprovals());
    try {
        ChangeNotes notes = getNotes(ev.getChange());
        hooks.doCommentAddedHook(notes.getChange(), getAccount(ev.getAuthor()), getPatchSet(notes, ev.getRevision()), ev.getComment(), approvals, oldApprovals, db.get());
    } catch (OrmException e) {
        log.error("CommentAdded hook failed to fun" + ev.getChange()._number, e);
    }
}
#end_block

#method_before
@Override
public void onChangeMerged(ChangeMergedListener.Event ev) {
    try {
        hooks.doChangeMergedHook(getChange(ev.getChange()), getAccount(ev.getMerger()), getPatchSet(ev.getRevision()), db.get(), ev.getNewRevisionId());
    } catch (OrmException e) {
        log.error("ChangeMerged hook failed to run " + ev.getChange()._number, e);
    }
}
#method_after
@Override
public void onChangeMerged(ChangeMergedListener.Event ev) {
    try {
        ChangeNotes notes = getNotes(ev.getChange());
        hooks.doChangeMergedHook(notes.getChange(), getAccount(ev.getMerger()), getPatchSet(notes, ev.getRevision()), db.get(), ev.getNewRevisionId());
    } catch (OrmException e) {
        log.error("ChangeMerged hook failed to run " + ev.getChange()._number, e);
    }
}
#end_block

#method_before
@Override
public void onChangeAbandoned(ChangeAbandonedListener.Event ev) {
    try {
        hooks.doChangeAbandonedHook(getChange(ev.getChange()), getAccount(ev.getAbandoner()), getPatchSet(ev.getRevision()), ev.getReason(), db.get());
    } catch (OrmException e) {
    }
}
#method_after
@Override
public void onChangeAbandoned(ChangeAbandonedListener.Event ev) {
    try {
        ChangeNotes notes = getNotes(ev.getChange());
        hooks.doChangeAbandonedHook(notes.getChange(), getAccount(ev.getAbandoner()), getPatchSet(notes, ev.getRevision()), ev.getReason(), db.get());
    } catch (OrmException e) {
        log.error("ChangeAbandoned hook failed to run " + ev.getChange()._number, e);
    }
}
#end_block

#method_before
@Override
public void onChangeRestored(ChangeRestoredListener.Event ev) {
    try {
        hooks.doChangeRestoredHook(getChange(ev.getChange()), getAccount(ev.getRestorer()), getPatchSet(ev.getRevision()), ev.getReason(), db.get());
    } catch (OrmException e) {
    }
}
#method_after
@Override
public void onChangeRestored(ChangeRestoredListener.Event ev) {
    try {
        ChangeNotes notes = getNotes(ev.getChange());
        hooks.doChangeRestoredHook(notes.getChange(), getAccount(ev.getRestorer()), getPatchSet(notes, ev.getRevision()), ev.getReason(), db.get());
    } catch (OrmException e) {
        log.error("ChangeRestored hook failed to run " + ev.getChange()._number, e);
    }
}
#end_block

#method_before
@Override
public void onReviewerAdded(ReviewerAddedListener.Event ev) {
    try {
        Change change = getChange(ev.getChange());
        PatchSet patch = db.get().patchSets().get(change.currentPatchSetId());
        hooks.doReviewerAddedHook(change, getAccount(ev.getReviewer()), patch, db.get());
    } catch (OrmException e) {
    }
}
#method_after
@Override
public void onReviewerAdded(ReviewerAddedListener.Event ev) {
    try {
        ChangeNotes notes = getNotes(ev.getChange());
        hooks.doReviewerAddedHook(notes.getChange(), getAccount(ev.getReviewer()), psUtil.current(db.get(), notes), db.get());
    } catch (OrmException e) {
        log.error("ReviewerAdded hook failed to run " + ev.getChange()._number, e);
    }
}
#end_block

#method_before
@Override
public void onTopicEdited(TopicEditedListener.Event ev) {
    try {
        hooks.doTopicChangedHook(getChange(ev.getChange()), getAccount(ev.getEditor()), ev.getOldTopic(), db.get());
    } catch (OrmException e) {
    }
}
#method_after
@Override
public void onTopicEdited(TopicEditedListener.Event ev) {
    try {
        hooks.doTopicChangedHook(getNotes(ev.getChange()).getChange(), getAccount(ev.getEditor()), ev.getOldTopic(), db.get());
    } catch (OrmException e) {
        log.error("TopicChanged hook failed to run " + ev.getChange()._number, e);
    }
}
#end_block

#method_before
@Override
public void onHashtagsEdited(HashtagsEditedListener.Event ev) {
    try {
        hooks.doHashtagsChangedHook(getChange(ev.getChange()), getAccount(ev.getEditor()), new HashSet<String>(ev.getAddedHashtags()), new HashSet<String>(ev.getRemovedHashtags()), new HashSet<String>(ev.getHashtags()), db.get());
    } catch (OrmException e) {
    }
}
#method_after
@Override
public void onHashtagsEdited(HashtagsEditedListener.Event ev) {
    try {
        hooks.doHashtagsChangedHook(getNotes(ev.getChange()).getChange(), getAccount(ev.getEditor()), new HashSet<>(ev.getAddedHashtags()), new HashSet<>(ev.getRemovedHashtags()), new HashSet<>(ev.getHashtags()), db.get());
    } catch (OrmException e) {
        log.error("HashtagsChanged hook failed to run " + ev.getChange()._number, e);
    }
}
#end_block

#method_before
private PatchSet getPatchSet(RevisionInfo info) throws OrmException {
    return db.get().patchSets().get(PatchSet.Id.fromRef(info.ref));
}
#method_after
private PatchSet getPatchSet(ChangeNotes notes, RevisionInfo info) throws OrmException {
    return psUtil.get(db.get(), notes, PatchSet.Id.fromRef(info.ref));
}
#end_block

#method_before
public PatchSetInserter setGroups(Iterable<String> groups) {
    this.groups = groups;
    return this;
}
#method_after
public PatchSetInserter setGroups(List<String> groups) {
    checkNotNull(groups, "groups may not be null");
    this.groups = groups;
    return this;
}
#end_block

#method_before
@Override
public void updateRepo(RepoContext ctx) throws ResourceConflictException, IOException {
    init();
    validate(ctx);
    patchSetInfo = patchSetInfoFactory.get(ctx.getRevWalk(), commit, psId);
    ctx.addRefUpdate(new ReceiveCommand(ObjectId.zeroId(), commit, getPatchSetId().toRefName(), ReceiveCommand.Type.CREATE));
}
#method_after
@Override
public void updateRepo(RepoContext ctx) throws ResourceConflictException, IOException {
    init();
    validate(ctx);
    ctx.addRefUpdate(new ReceiveCommand(ObjectId.zeroId(), commit, getPatchSetId().toRefName(), ReceiveCommand.Type.CREATE));
}
#end_block

#method_before
@Override
public void updateChange(ChangeContext ctx) throws OrmException, InvalidChangeOperationException {
    ChangeControl ctl = ctx.getChangeControl();
    change = ctx.getChange();
    Change.Id id = change.getId();
    final PatchSet.Id currentPatchSetId = change.currentPatchSetId();
    if (!change.getStatus().isOpen() && !allowClosed) {
        throw new InvalidChangeOperationException(String.format("Change %s is closed", change.getId()));
    }
    patchSet = new PatchSet(psId);
    patchSet.setCreatedOn(ctx.getWhen());
    patchSet.setUploader(firstNonNull(uploader, ctl.getChange().getOwner()));
    patchSet.setRevision(new RevId(commit.name()));
    patchSet.setDraft(draft);
    if (groups != null) {
        patchSet.setGroups(groups);
    } else {
        patchSet.setGroups(GroupCollector.getCurrentGroups(db, change));
    }
    db.patchSets().insert(Collections.singleton(patchSet));
    if (sendMail) {
        oldReviewers = approvalsUtil.getReviewers(db, ctl.getNotes());
    }
    if (message != null) {
        changeMessage = new ChangeMessage(new ChangeMessage.Key(ctl.getChange().getId(), ChangeUtil.messageUUID(db)), ctx.getUser().getAccountId(), ctx.getWhen(), patchSet.getId());
        changeMessage.setMessage(message);
    }
    // TODO(dborowitz): Throw ResourceConflictException instead of using
    // AtomicUpdate.
    change = db.changes().atomicUpdate(id, new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isClosed() && !allowClosed) {
                return null;
            }
            if (!change.currentPatchSetId().equals(currentPatchSetId)) {
                return null;
            }
            if (change.getStatus() != Change.Status.DRAFT && !allowClosed) {
                change.setStatus(Change.Status.NEW);
            }
            change.setCurrentPatchSet(patchSetInfo);
            ChangeUtil.updated(change);
            return change;
        }
    });
    if (change == null) {
        throw new ChangeModifiedException(String.format("Change %s was modified", id));
    }
    approvalCopier.copy(db, ctl, patchSet);
    if (changeMessage != null) {
        cmUtil.addChangeMessage(db, ctx.getChangeUpdate(), changeMessage);
    }
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws ResourceConflictException, OrmException, IOException {
    ChangeControl ctl = ctx.getControl();
    change = ctx.getChange();
    ChangeUpdate update = ctx.getUpdate(psId);
    update.setSubjectForCommit("Create patch set " + psId.get());
    if (!change.getStatus().isOpen() && !allowClosed) {
        throw new ResourceConflictException(String.format("Cannot create new patch set of change %s because it is %s", change.getId(), change.getStatus().name().toLowerCase()));
    }
    List<String> newGroups = groups;
    if (newGroups.isEmpty()) {
        PatchSet prevPs = psUtil.current(ctx.getDb(), ctx.getNotes());
        if (prevPs != null) {
            newGroups = prevPs.getGroups();
        }
    }
    patchSet = psUtil.insert(ctx.getDb(), ctx.getRevWalk(), ctx.getUpdate(psId), psId, commit, draft, newGroups, null);
    if (sendMail) {
        oldReviewers = approvalsUtil.getReviewers(db, ctl.getNotes());
    }
    if (message != null) {
        changeMessage = new ChangeMessage(new ChangeMessage.Key(ctl.getId(), ChangeUtil.messageUUID(db)), ctx.getUser().getAccountId(), ctx.getWhen(), patchSet.getId());
        changeMessage.setMessage(message);
    }
    patchSetInfo = patchSetInfoFactory.get(ctx.getRevWalk(), commit, psId);
    if (change.getStatus() != Change.Status.DRAFT && !allowClosed) {
        change.setStatus(Change.Status.NEW);
    }
    change.setCurrentPatchSet(patchSetInfo);
    if (copyApprovals) {
        approvalCopier.copy(db, ctl, patchSet);
    }
    if (changeMessage != null) {
        cmUtil.addChangeMessage(db, update, changeMessage);
    }
    return true;
}
#end_block

#method_before
@Override
public void postUpdate(Context ctx) throws OrmException {
    if (sendMail) {
        try {
            ReplacePatchSetSender cm = replacePatchSetFactory.create(change.getId());
            cm.setFrom(ctx.getUser().getAccountId());
            cm.setPatchSet(patchSet, patchSetInfo);
            cm.setChangeMessage(changeMessage);
            cm.addReviewers(oldReviewers.get(ReviewerState.REVIEWER));
            cm.addExtraCC(oldReviewers.get(ReviewerState.CC));
            cm.send();
        } catch (Exception err) {
            log.error("Cannot send email for new patch set on change " + change.getId(), err);
        }
    }
    if (runHooks) {
        revisionCreated.fire(change, patchSet, ctx.getUser().getAccountId());
    }
}
#method_after
@Override
public void postUpdate(Context ctx) throws OrmException {
    if (sendMail) {
        try {
            ReplacePatchSetSender cm = replacePatchSetFactory.create(ctx.getProject(), change.getId());
            cm.setFrom(ctx.getUser().getAccountId());
            cm.setPatchSet(patchSet, patchSetInfo);
            cm.setChangeMessage(changeMessage);
            cm.addReviewers(oldReviewers.byState(REVIEWER));
            cm.addExtraCC(oldReviewers.byState(CC));
            cm.send();
        } catch (Exception err) {
            log.error("Cannot send email for new patch set on change " + change.getId(), err);
        }
    }
    if (runHooks) {
        revisionCreated.fire(change, patchSet, ctx.getUser().getAccountId());
    }
}
#end_block

#method_before
private void validate(RepoContext ctx) throws ResourceConflictException, IOException {
    CommitValidators cv = commitValidatorsFactory.create(refControl, sshInfo, ctx.getRepository());
    String refName = getPatchSetId().toRefName();
    CommitReceivedEvent event = new CommitReceivedEvent(new ReceiveCommand(ObjectId.zeroId(), commit.getId(), refName.substring(0, refName.lastIndexOf('/') + 1) + "new"), refControl.getProjectControl().getProject(), refControl.getRefName(), commit, ctx.getUser().asIdentifiedUser());
    try {
        switch(validatePolicy) {
            case RECEIVE_COMMITS:
                NoteMap rejectCommits = BanCommit.loadRejectCommitsMap(ctx.getRepository(), ctx.getRevWalk());
                cv.validateForReceiveCommits(event, rejectCommits);
                break;
            case GERRIT:
                cv.validateForGerritCommits(event);
                break;
            case NONE:
                break;
        }
    } catch (CommitValidationException e) {
        throw new ResourceConflictException(e.getMessage());
    }
}
#method_after
private void validate(RepoContext ctx) throws ResourceConflictException, IOException {
    CommitValidators cv = commitValidatorsFactory.create(origCtl.getRefControl(), sshInfo, ctx.getRepository());
    String refName = getPatchSetId().toRefName();
    CommitReceivedEvent event = new CommitReceivedEvent(new ReceiveCommand(ObjectId.zeroId(), commit.getId(), refName.substring(0, refName.lastIndexOf('/') + 1) + "new"), origCtl.getProjectControl().getProject(), origCtl.getRefControl().getRefName(), commit, ctx.getUser().asIdentifiedUser());
    try {
        switch(validatePolicy) {
            case RECEIVE_COMMITS:
                NoteMap rejectCommits = BanCommit.loadRejectCommitsMap(ctx.getRepository(), ctx.getRevWalk());
                cv.validateForReceiveCommits(event, rejectCommits);
                break;
            case GERRIT:
                cv.validateForGerritCommits(event);
                break;
            case NONE:
                break;
        }
    } catch (CommitValidationException e) {
        throw new ResourceConflictException(e.getFullMessage());
    }
}
#end_block

#method_before
@Override
public void enterAgreement(final String agreementName, final AsyncCallback<VoidResult> callback) {
    run(callback, new Action<VoidResult>() {

        @Override
        public VoidResult run(final ReviewDb db) throws OrmException, Failure {
            ContributorAgreement ca = projectCache.getAllProjects().getConfig().getContributorAgreement(agreementName);
            if (ca == null) {
                throw new Failure(new NoSuchEntityException());
            }
            if (ca.getAutoVerify() == null) {
                throw new Failure(new IllegalStateException("cannot enter a non-autoVerify agreement"));
            } else if (ca.getAutoVerify().getUUID() == null) {
                throw new Failure(new NoSuchEntityException());
            }
            AccountGroup group = groupCache.get(ca.getAutoVerify().getUUID());
            if (group == null) {
                throw new Failure(new NoSuchEntityException());
            }
            Account account = user.get().getAccount();
            // ToDo claSigned.fireClaSigned() instead of
            // hooks.doClaSignupHook(account, ca.getName());
            final AccountGroupMember.Key key = new AccountGroupMember.Key(account.getId(), group.getId());
            AccountGroupMember m = db.accountGroupMembers().get(key);
            if (m == null) {
                m = new AccountGroupMember(key);
                auditService.dispatchAddAccountsToGroup(account.getId(), Collections.singleton(m));
                db.accountGroupMembers().insert(Collections.singleton(m));
                accountCache.evict(m.getAccountId());
            }
            return VoidResult.INSTANCE;
        }
    });
}
#method_after
@Override
public void enterAgreement(final String agreementName, final AsyncCallback<VoidResult> callback) {
    run(callback, new Action<VoidResult>() {

        @Override
        public VoidResult run(final ReviewDb db) throws OrmException, Failure {
            ContributorAgreement ca = projectCache.getAllProjects().getConfig().getContributorAgreement(agreementName);
            if (ca == null) {
                throw new Failure(new NoSuchEntityException());
            }
            if (ca.getAutoVerify() == null) {
                throw new Failure(new IllegalStateException("cannot enter a non-autoVerify agreement"));
            } else if (ca.getAutoVerify().getUUID() == null) {
                throw new Failure(new NoSuchEntityException());
            }
            AccountGroup group = groupCache.get(ca.getAutoVerify().getUUID());
            if (group == null) {
                throw new Failure(new NoSuchEntityException());
            }
            Account account = user.get().getAccount();
            agreementSignup.fire(account, ca.getName());
            final AccountGroupMember.Key key = new AccountGroupMember.Key(account.getId(), group.getId());
            AccountGroupMember m = db.accountGroupMembers().get(key);
            if (m == null) {
                m = new AccountGroupMember(key);
                auditService.dispatchAddAccountsToGroup(account.getId(), Collections.singleton(m));
                db.accountGroupMembers().insert(Collections.singleton(m));
                accountCache.evict(m.getAccountId());
            }
            return VoidResult.INSTANCE;
        }
    });
}
#end_block

#method_before
@Override
public PostResult apply(ChangeResource rsrc, AddReviewerInput input) throws AuthException, BadRequestException, UnprocessableEntityException, OrmException, IOException {
    if (input.reviewer == null) {
        throw new BadRequestException("missing reviewer field");
    }
    try {
        Account.Id accountId = accounts.parse(input.reviewer).getAccountId();
        return putAccount(reviewerFactory.create(rsrc, accountId));
    } catch (UnprocessableEntityException e) {
        try {
            return putGroup(rsrc, input);
        } catch (UnprocessableEntityException e2) {
            throw new UnprocessableEntityException(MessageFormat.format(ChangeMessages.get().reviewerNotFound, input.reviewer));
        }
    }
}
#method_after
@Override
public PostResult apply(ChangeResource rsrc, AddReviewerInput input) throws UpdateException, OrmException, RestApiException, IOException {
    if (input.reviewer == null) {
        throw new BadRequestException("missing reviewer field");
    }
    try {
        Account.Id accountId = accounts.parse(input.reviewer).getAccountId();
        return putAccount(reviewerFactory.create(rsrc, accountId));
    } catch (UnprocessableEntityException e) {
        try {
            return putGroup(rsrc, input);
        } catch (UnprocessableEntityException e2) {
            throw new UnprocessableEntityException(MessageFormat.format(ChangeMessages.get().reviewerNotFound, input.reviewer));
        }
    }
}
#end_block

#method_before
private PostResult putAccount(ReviewerResource rsrc) throws OrmException, IOException {
    Account member = rsrc.getUser().getAccount();
    ChangeControl control = rsrc.getControl();
    PostResult result = new PostResult();
    if (isValidReviewer(member, control)) {
        addReviewers(rsrc, result, ImmutableMap.of(member.getId(), control));
    }
    return result;
}
#method_after
private PostResult putAccount(ReviewerResource rsrc) throws OrmException, UpdateException, RestApiException {
    Account member = rsrc.getReviewerUser().getAccount();
    ChangeControl control = rsrc.getReviewerControl();
    PostResult result = new PostResult();
    if (isValidReviewer(member, control)) {
        addReviewers(rsrc.getChangeResource(), result, ImmutableMap.of(member.getId(), control));
    }
    return result;
}
#end_block

#method_before
private PostResult putGroup(ChangeResource rsrc, AddReviewerInput input) throws BadRequestException, UnprocessableEntityException, OrmException, IOException {
    GroupDescription.Basic group = groupsCollection.parseInternal(input.reviewer);
    PostResult result = new PostResult();
    if (!isLegalReviewerGroup(group.getGroupUUID())) {
        result.error = MessageFormat.format(ChangeMessages.get().groupIsNotAllowed, group.getName());
        return result;
    }
    Map<Account.Id, ChangeControl> reviewers = Maps.newHashMap();
    ChangeControl control = rsrc.getControl();
    Set<Account> members;
    try {
        members = groupMembersFactory.create(control.getUser()).listAccounts(group.getGroupUUID(), control.getProject().getNameKey());
    } catch (NoSuchGroupException e) {
        throw new UnprocessableEntityException(e.getMessage());
    } catch (NoSuchProjectException e) {
        throw new BadRequestException(e.getMessage());
    }
    // if maxAllowed is set to 0, it is allowed to add any number of
    // reviewers
    int maxAllowed = cfg.getInt("addreviewer", "maxAllowed", DEFAULT_MAX_REVIEWERS);
    if (maxAllowed > 0 && members.size() > maxAllowed) {
        result.error = MessageFormat.format(ChangeMessages.get().groupHasTooManyMembers, group.getName());
        return result;
    }
    // if maxWithoutCheck is set to 0, we never ask for confirmation
    int maxWithoutConfirmation = cfg.getInt("addreviewer", "maxWithoutConfirmation", DEFAULT_MAX_REVIEWERS_WITHOUT_CHECK);
    if (!input.confirmed() && maxWithoutConfirmation > 0 && members.size() > maxWithoutConfirmation) {
        result.confirm = true;
        result.error = MessageFormat.format(ChangeMessages.get().groupManyMembersConfirmation, group.getName(), members.size());
        return result;
    }
    for (Account member : members) {
        if (isValidReviewer(member, control)) {
            reviewers.put(member.getId(), control);
        }
    }
    addReviewers(rsrc, result, reviewers);
    return result;
}
#method_after
private PostResult putGroup(ChangeResource rsrc, AddReviewerInput input) throws UpdateException, RestApiException, OrmException, IOException {
    GroupDescription.Basic group = groupsCollection.parseInternal(input.reviewer);
    PostResult result = new PostResult();
    if (!isLegalReviewerGroup(group.getGroupUUID())) {
        result.error = MessageFormat.format(ChangeMessages.get().groupIsNotAllowed, group.getName());
        return result;
    }
    Map<Account.Id, ChangeControl> reviewers = new HashMap<>();
    ChangeControl control = rsrc.getControl();
    Set<Account> members;
    try {
        members = groupMembersFactory.create(control.getUser()).listAccounts(group.getGroupUUID(), control.getProject().getNameKey());
    } catch (NoSuchGroupException e) {
        throw new UnprocessableEntityException(e.getMessage());
    } catch (NoSuchProjectException e) {
        throw new BadRequestException(e.getMessage());
    }
    // if maxAllowed is set to 0, it is allowed to add any number of
    // reviewers
    int maxAllowed = cfg.getInt("addreviewer", "maxAllowed", DEFAULT_MAX_REVIEWERS);
    if (maxAllowed > 0 && members.size() > maxAllowed) {
        result.error = MessageFormat.format(ChangeMessages.get().groupHasTooManyMembers, group.getName());
        return result;
    }
    // if maxWithoutCheck is set to 0, we never ask for confirmation
    int maxWithoutConfirmation = cfg.getInt("addreviewer", "maxWithoutConfirmation", DEFAULT_MAX_REVIEWERS_WITHOUT_CHECK);
    if (!input.confirmed() && maxWithoutConfirmation > 0 && members.size() > maxWithoutConfirmation) {
        result.confirm = true;
        result.error = MessageFormat.format(ChangeMessages.get().groupManyMembersConfirmation, group.getName(), members.size());
        return result;
    }
    for (Account member : members) {
        if (isValidReviewer(member, control)) {
            reviewers.put(member.getId(), control);
        }
    }
    addReviewers(rsrc, result, reviewers);
    return result;
}
#end_block

#method_before
private void addReviewers(ChangeResource rsrc, PostResult result, Map<Account.Id, ChangeControl> reviewers) throws OrmException, IOException {
    ReviewDb db = dbProvider.get();
    ChangeUpdate update = updateFactory.create(rsrc.getControl());
    List<PatchSetApproval> added;
    db.changes().beginTransaction(rsrc.getChange().getId());
    try {
        ChangeUtil.bumpRowVersionNotLastUpdatedOn(rsrc.getChange().getId(), db);
        added = approvalsUtil.addReviewers(db, rsrc.getNotes(), update, rsrc.getControl().getLabelTypes(), rsrc.getChange(), reviewers.keySet());
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    CheckedFuture<?, IOException> indexFuture = indexer.indexAsync(rsrc.getChange().getId());
    result.reviewers = Lists.newArrayListWithCapacity(added.size());
    for (PatchSetApproval psa : added) {
        // New reviewers have value 0, don't bother normalizing.
        result.reviewers.add(json.format(new ReviewerInfo(psa.getAccountId()), reviewers.get(psa.getAccountId()), ImmutableList.of(psa)));
    }
    accountLoaderFactory.create(true).fill(result.reviewers);
    indexFuture.checkedGet();
    emailReviewers(rsrc.getChange(), added);
    if (!added.isEmpty()) {
        PatchSet patchSet = dbProvider.get().patchSets().get(rsrc.getChange().currentPatchSetId());
        for (PatchSetApproval psa : added) {
            Account account = accountCache.get(psa.getAccountId()).getAccount();
            reviewerAdded.fire(rsrc.getChange(), patchSet, account);
        }
    }
}
#method_after
private void addReviewers(ChangeResource rsrc, PostResult result, Map<Account.Id, ChangeControl> reviewers) throws OrmException, RestApiException, UpdateException {
    try (BatchUpdate bu = batchUpdateFactory.create(dbProvider.get(), rsrc.getProject(), rsrc.getUser(), TimeUtil.nowTs())) {
        Op op = new Op(rsrc, reviewers);
        Change.Id id = rsrc.getChange().getId();
        bu.addOp(id, op);
        bu.execute();
        result.reviewers = Lists.newArrayListWithCapacity(op.added.size());
        for (PatchSetApproval psa : op.added) {
            // New reviewers have value 0, don't bother normalizing.
            result.reviewers.add(json.format(new ReviewerInfo(psa.getAccountId()), reviewers.get(psa.getAccountId()), ImmutableList.of(psa)));
        }
        // We don't do this inside Op, since the accounts are in a different
        // table.
        accountLoaderFactory.create(true).fill(result.reviewers);
    }
}
#end_block

#method_before
private void emailReviewers(Change change, List<PatchSetApproval> added) {
    if (added.isEmpty()) {
        return;
    }
    // Email the reviewers
    // 
    // The user knows they added themselves, don't bother emailing them.
    List<Account.Id> toMail = Lists.newArrayListWithCapacity(added.size());
    Account.Id userId = user.get().getAccountId();
    for (PatchSetApproval psa : added) {
        if (!psa.getAccountId().equals(userId)) {
            toMail.add(psa.getAccountId());
        }
    }
    if (!toMail.isEmpty()) {
        try {
            AddReviewerSender cm = addReviewerSenderFactory.create(change.getId());
            cm.setFrom(userId);
            cm.addReviewers(toMail);
            cm.send();
        } catch (Exception err) {
            log.error("Cannot send email to new reviewers of change " + change.getId(), err);
        }
    }
}
#method_after
private void emailReviewers(Change change, List<PatchSetApproval> added) {
    if (added.isEmpty()) {
        return;
    }
    // Email the reviewers
    // 
    // The user knows they added themselves, don't bother emailing them.
    List<Account.Id> toMail = Lists.newArrayListWithCapacity(added.size());
    Account.Id userId = user.get().getAccountId();
    for (PatchSetApproval psa : added) {
        if (!psa.getAccountId().equals(userId)) {
            toMail.add(psa.getAccountId());
        }
    }
    if (!toMail.isEmpty()) {
        try {
            AddReviewerSender cm = addReviewerSenderFactory.create(change.getProject(), change.getId());
            cm.setFrom(userId);
            cm.addReviewers(toMail);
            cm.send();
        } catch (Exception err) {
            log.error("Cannot send email to new reviewers of change " + change.getId(), err);
        }
    }
}
#end_block

#method_before
@Override
public UiAction.Description getDescription(RevisionResource rsrc) {
    try {
        return new UiAction.Description().setTitle(String.format("Publish revision %d", rsrc.getPatchSet().getPatchSetId())).setVisible(rsrc.getPatchSet().isDraft() && rsrc.getControl().canPublish(dbProvider.get()));
    } catch (OrmException e) {
        throw new IllegalStateException(e);
    }
}
#method_after
@Override
public UiAction.Description getDescription(RevisionResource rsrc) {
    try {
        return new UiAction.Description().setLabel("Publish").setTitle(String.format("Publish revision %d", rsrc.getPatchSet().getPatchSetId())).setVisible(rsrc.getPatchSet().isDraft() && rsrc.getControl().canPublish(dbProvider.get()));
    } catch (OrmException e) {
        throw new IllegalStateException(e);
    }
}
#end_block

#method_before
@Override
public void updateChange(ChangeContext ctx) throws RestApiException, OrmException {
    if (!ctx.getChangeControl().canPublish(ctx.getDb())) {
        throw new AuthException("Cannot publish this draft patch set");
    }
    saveChange(ctx);
    savePatchSet(ctx);
    addReviewers(ctx);
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws RestApiException, OrmException, IOException {
    if (!ctx.getControl().canPublish(ctx.getDb())) {
        throw new AuthException("Cannot publish this draft patch set");
    }
    if (patchSet == null) {
        patchSet = psUtil.get(ctx.getDb(), ctx.getNotes(), psId);
        if (patchSet == null) {
            throw new ResourceNotFoundException(psId.toString());
        }
    }
    saveChange(ctx);
    savePatchSet(ctx);
    addReviewers(ctx);
    return true;
}
#end_block

#method_before
private void saveChange(ChangeContext ctx) throws OrmException {
    change = ctx.getChange();
    wasDraftChange = change.getStatus() == Change.Status.DRAFT;
    if (wasDraftChange) {
        change.setStatus(Change.Status.NEW);
        ChangeUtil.updated(change);
        ctx.getDb().changes().update(Collections.singleton(change));
    }
}
#method_after
private void saveChange(ChangeContext ctx) {
    change = ctx.getChange();
    ChangeUpdate update = ctx.getUpdate(psId);
    wasDraftChange = change.getStatus() == Change.Status.DRAFT;
    if (wasDraftChange) {
        change.setStatus(Change.Status.NEW);
        update.setStatus(change.getStatus());
    }
}
#end_block

#method_before
private void savePatchSet(ChangeContext ctx) throws RestApiException, OrmException {
    patchSet = ctx.getDb().patchSets().get(psId);
    if (!patchSet.isDraft()) {
        throw new ResourceConflictException("Patch set is not a draft");
    }
    patchSet.setDraft(false);
    // Force ETag invalidation if not done already
    if (!wasDraftChange) {
        ChangeUtil.updated(change);
        ctx.getDb().changes().update(Collections.singleton(change));
    }
    ctx.getDb().patchSets().update(Collections.singleton(patchSet));
}
#method_after
private void savePatchSet(ChangeContext ctx) throws RestApiException, OrmException {
    if (!patchSet.isDraft()) {
        throw new ResourceConflictException("Patch set is not a draft");
    }
    psUtil.publish(ctx.getDb(), ctx.getUpdate(psId), patchSet);
}
#end_block

#method_before
private void addReviewers(ChangeContext ctx) throws OrmException {
    LabelTypes labelTypes = ctx.getChangeControl().getLabelTypes();
    Collection<Account.Id> oldReviewers = approvalsUtil.getReviewers(ctx.getDb(), ctx.getChangeNotes()).values();
    List<FooterLine> footerLines = commit.getFooterLines();
    recipients = getRecipientsFromFooters(accountResolver, patchSet, footerLines);
    recipients.remove(ctx.getUser().getAccountId());
    approvalsUtil.addReviewers(ctx.getDb(), ctx.getChangeUpdate(), labelTypes, change, patchSet, patchSetInfo, recipients.getReviewers(), oldReviewers);
}
#method_after
private void addReviewers(ChangeContext ctx) throws OrmException, IOException {
    LabelTypes labelTypes = ctx.getControl().getLabelTypes();
    Collection<Account.Id> oldReviewers = approvalsUtil.getReviewers(ctx.getDb(), ctx.getNotes()).all();
    RevCommit commit = ctx.getRevWalk().parseCommit(ObjectId.fromString(patchSet.getRevision().get()));
    patchSetInfo = patchSetInfoFactory.get(ctx.getRevWalk(), commit, psId);
    List<FooterLine> footerLines = commit.getFooterLines();
    recipients = getRecipientsFromFooters(accountResolver, patchSet.isDraft(), footerLines);
    recipients.remove(ctx.getUser().getAccountId());
    approvalsUtil.addReviewers(ctx.getDb(), ctx.getUpdate(psId), labelTypes, change, patchSet, patchSetInfo, recipients.getReviewers(), oldReviewers);
}
#end_block

#method_before
private void sendCreateChange(Context ctx) throws EmailException {
    CreateChangeSender cm = createChangeSenderFactory.create(change.getId());
    cm.setFrom(ctx.getUser().getAccountId());
    cm.setPatchSet(patchSet, patchSetInfo);
    cm.addReviewers(recipients.getReviewers());
    cm.addExtraCC(recipients.getCcOnly());
    cm.send();
}
#method_after
private void sendCreateChange(Context ctx) throws EmailException {
    CreateChangeSender cm = createChangeSenderFactory.create(ctx.getProject(), change.getId());
    cm.setFrom(ctx.getUser().getAccountId());
    cm.setPatchSet(patchSet, patchSetInfo);
    cm.addReviewers(recipients.getReviewers());
    cm.addExtraCC(recipients.getCcOnly());
    cm.send();
}
#end_block

#method_before
private void sendReplacePatchSet(Context ctx) throws EmailException, OrmException {
    Account.Id accountId = ctx.getUser().getAccountId();
    ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(ctx.getDb())), accountId, ctx.getWhen(), psId);
    msg.setMessage("Uploaded patch set " + psId.get() + ".");
    ReplacePatchSetSender cm = replacePatchSetFactory.create(change.getId());
    cm.setFrom(accountId);
    cm.setPatchSet(patchSet, patchSetInfo);
    cm.setChangeMessage(msg);
    cm.addReviewers(recipients.getReviewers());
    cm.addExtraCC(recipients.getCcOnly());
    cm.send();
}
#method_after
private void sendReplacePatchSet(Context ctx) throws EmailException, OrmException {
    Account.Id accountId = ctx.getUser().getAccountId();
    ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(ctx.getDb())), accountId, ctx.getWhen(), psId);
    msg.setMessage("Uploaded patch set " + psId.get() + ".");
    ReplacePatchSetSender cm = replacePatchSetFactory.create(ctx.getProject(), change.getId());
    cm.setFrom(accountId);
    cm.setPatchSet(patchSet, patchSetInfo);
    cm.setChangeMessage(msg);
    cm.addReviewers(recipients.getReviewers());
    cm.addExtraCC(recipients.getCcOnly());
    cm.send();
}
#end_block

#method_before
@Override
public Change getChange() {
    return change;
}
#method_after
public Change getChange() {
    checkState(change != null, "getChange() only valid after creating change");
    return change;
}
#end_block

#method_before
public ChangeInserter setDraft(boolean draft) {
    change.setStatus(draft ? Change.Status.DRAFT : Change.Status.NEW);
    patchSet.setDraft(draft);
    return this;
}
#method_after
public ChangeInserter setDraft(boolean draft) {
    checkState(change == null, "setDraft(boolean) only valid before creating change");
    return setStatus(draft ? Change.Status.DRAFT : Change.Status.NEW);
}
#end_block

#method_before
public ChangeInserter setGroups(Iterable<String> groups) {
    patchSet.setGroups(groups);
    return this;
}
#method_after
public ChangeInserter setGroups(List<String> groups) {
    checkNotNull(groups, "groups may not be empty");
    checkState(patchSet == null, "setGroups(Iterable<String>) only valid before creating change");
    this.groups = groups;
    return this;
}
#end_block

#method_before
public PatchSet getPatchSet() {
    return patchSet;
}
#method_after
public PatchSet getPatchSet() {
    checkState(patchSet != null, "getPatchSet() only valid after creating change");
    return patchSet;
}
#end_block

#method_before
@Override
public void updateRepo(RepoContext ctx) throws InvalidChangeOperationException, IOException {
    validate(ctx);
    patchSetInfo = patchSetInfoFactory.get(ctx.getRevWalk(), commit, patchSet.getId());
    change.setCurrentPatchSet(patchSetInfo);
    if (!updateRef) {
        return;
    }
    ctx.addRefUpdate(new ReceiveCommand(ObjectId.zeroId(), commit, patchSet.getRefName()));
}
#method_after
@Override
public void updateRepo(RepoContext ctx) throws ResourceConflictException, IOException {
    validate(ctx);
    if (!updateRef) {
        return;
    }
    if (updateRefCommand == null) {
        ctx.addRefUpdate(new ReceiveCommand(ObjectId.zeroId(), commit, psId.toRefName()));
    } else {
        ctx.addRefUpdate(updateRefCommand);
    }
}
#end_block

#method_before
@Override
public void updateChange(ChangeContext ctx) throws OrmException, IOException {
    ReviewDb db = ctx.getDb();
    ChangeControl ctl = ctx.getChangeControl();
    ChangeUpdate update = ctx.getChangeUpdate();
    if (patchSet.getGroups() == null) {
        patchSet.setGroups(GroupCollector.getDefaultGroups(patchSet));
    }
    db.patchSets().insert(Collections.singleton(patchSet));
    db.changes().insert(Collections.singleton(change));
    LabelTypes labelTypes = ctl.getProjectControl().getLabelTypes();
    approvalsUtil.addReviewers(db, update, labelTypes, change, patchSet, patchSetInfo, reviewers, Collections.<Account.Id>emptySet());
    approvalsUtil.addApprovals(db, update, labelTypes, patchSet, ctx.getChangeControl(), approvals);
    if (message != null) {
        changeMessage = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), user.getAccountId(), patchSet.getCreatedOn(), patchSet.getId());
        changeMessage.setMessage(message);
        cmUtil.addChangeMessage(db, update, changeMessage);
    }
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, IOException {
    // Use defensive copy created by ChangeControl.
    change = ctx.getChange();
    ReviewDb db = ctx.getDb();
    ChangeControl ctl = ctx.getControl();
    patchSetInfo = patchSetInfoFactory.get(ctx.getRevWalk(), commit, psId);
    ctx.getChange().setCurrentPatchSet(patchSetInfo);
    ChangeUpdate update = ctx.getUpdate(psId);
    update.setChangeId(change.getKey().get());
    update.setSubjectForCommit("Create change");
    update.setBranch(change.getDest().get());
    update.setTopic(change.getTopic());
    boolean draft = status == Change.Status.DRAFT;
    List<String> newGroups = groups;
    if (newGroups.isEmpty()) {
        newGroups = GroupCollector.getDefaultGroups(commit);
    }
    patchSet = psUtil.insert(ctx.getDb(), ctx.getRevWalk(), update, psId, commit, draft, newGroups, null);
    /* TODO: fixStatus is used here because the tests
     * (byStatusClosed() in AbstractQueryChangesTest)
     * insert changes that are already merged,
     * and setStatus may not be used to set the Status to merged
     *
     * is it possible to make the tests use the merge code path,
     * instead of setting the status directly?
     */
    update.fixStatus(change.getStatus());
    LabelTypes labelTypes = ctl.getProjectControl().getLabelTypes();
    approvalsUtil.addReviewers(db, update, labelTypes, change, patchSet, patchSetInfo, reviewers, Collections.<Account.Id>emptySet());
    approvalsUtil.addApprovals(db, update, labelTypes, patchSet, ctx.getControl(), approvals);
    if (message != null) {
        changeMessage = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), ctx.getUser().getAccountId(), patchSet.getCreatedOn(), patchSet.getId());
        changeMessage.setMessage(message);
        cmUtil.addChangeMessage(db, update, changeMessage);
    }
    return true;
}
#end_block

#method_before
@Override
public void postUpdate(Context ctx) throws OrmException {
    if (sendMail) {
        Runnable sender = new Runnable() {

            @Override
            public void run() {
                try {
                    CreateChangeSender cm = createChangeSenderFactory.create(change.getId());
                    cm.setFrom(change.getOwner());
                    cm.setPatchSet(patchSet, patchSetInfo);
                    cm.addReviewers(reviewers);
                    cm.addExtraCC(extraCC);
                    cm.send();
                } catch (Exception e) {
                    log.error("Cannot send email for new change " + change.getId(), e);
                }
            }

            @Override
            public String toString() {
                return "send-email newchange";
            }
        };
        if (requestScopePropagator != null) {
            workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(sender));
        } else {
            sender.run();
        }
    }
    if (runHooks) {
        revisionCreated.fire(change, patchSet, ctx.getUser().getAccountId());
        ReviewDb db = ctx.getDb();
        if (approvals != null && !approvals.isEmpty()) {
            commentAdded.fire(change, patchSet, user.getAccount(), null, approvals, ctx.getWhen());
        }
    }
}
#method_after
@Override
public void postUpdate(Context ctx) throws OrmException, NoSuchChangeException {
    if (sendMail) {
        Runnable sender = new Runnable() {

            @Override
            public void run() {
                try {
                    CreateChangeSender cm = createChangeSenderFactory.create(change.getProject(), change.getId());
                    cm.setFrom(change.getOwner());
                    cm.setPatchSet(patchSet, patchSetInfo);
                    cm.setNotify(notify);
                    cm.addReviewers(reviewers);
                    cm.addExtraCC(extraCC);
                    cm.send();
                } catch (Exception e) {
                    log.error("Cannot send email for new change " + change.getId(), e);
                }
            }

            @Override
            public String toString() {
                return "send-email newchange";
            }
        };
        if (requestScopePropagator != null) {
            sendEmailExecutor.submit(requestScopePropagator.wrap(sender));
        } else {
            sender.run();
        }
    }
    /* For labels that are not set in this operation, show the "current" value
     * of 0, and no oldValue as the value was not modified by this operation.
     * For labels that are set in this operation, the value was modified, so
     * show a transition from an oldValue of 0 to the new value.
     */
    if (runHooks) {
        revisionCreated.fire(change, patchSet, ctx.getUser().getAccountId());
        if (approvals != null && !approvals.isEmpty()) {
            ChangeControl changeControl = changeControlFactory.controlFor(ctx.getDb(), change, ctx.getUser());
            List<LabelType> labels = changeControl.getLabelTypes().getLabelTypes();
            Map<String, Short> allApprovals = new HashMap<>();
            Map<String, Short> oldApprovals = new HashMap<>();
            for (LabelType lt : labels) {
                allApprovals.put(lt.getName(), (short) 0);
                oldApprovals.put(lt.getName(), null);
            }
            for (Map.Entry<String, Short> entry : approvals.entrySet()) {
                if (entry.getValue() != 0) {
                    allApprovals.put(entry.getKey(), entry.getValue());
                    oldApprovals.put(entry.getKey(), (short) 0);
                }
            }
            commentAdded.fire(change, patchSet, ctx.getUser().asIdentifiedUser().getAccount(), null, allApprovals, oldApprovals, ctx.getWhen());
        }
    }
}
#end_block

#method_before
private void validate(RepoContext ctx) throws IOException, InvalidChangeOperationException {
    if (validatePolicy == CommitValidators.Policy.NONE) {
        return;
    }
    CommitValidators cv = commitValidatorsFactory.create(refControl, new NoSshInfo(), ctx.getRepository());
    String refName = patchSet.getId().toRefName();
    CommitReceivedEvent event = new CommitReceivedEvent(new ReceiveCommand(ObjectId.zeroId(), commit.getId(), refName), refControl.getProjectControl().getProject(), change.getDest().get(), commit, user);
    try {
        switch(validatePolicy) {
            case RECEIVE_COMMITS:
                NoteMap rejectCommits = BanCommit.loadRejectCommitsMap(ctx.getRepository(), ctx.getRevWalk());
                cv.validateForReceiveCommits(event, rejectCommits);
                break;
            case GERRIT:
                cv.validateForGerritCommits(event);
                break;
            case NONE:
                break;
        }
    } catch (CommitValidationException e) {
        throw new InvalidChangeOperationException(e.getMessage());
    }
}
#method_after
private void validate(RepoContext ctx) throws IOException, ResourceConflictException {
    if (validatePolicy == CommitValidators.Policy.NONE) {
        return;
    }
    try {
        RefControl refControl = projectControlFactory.controlFor(ctx.getProject(), ctx.getUser()).controlForRef(refName);
        CommitValidators cv = commitValidatorsFactory.create(refControl, new NoSshInfo(), ctx.getRepository());
        String refName = psId.toRefName();
        CommitReceivedEvent event = new CommitReceivedEvent(new ReceiveCommand(ObjectId.zeroId(), commit.getId(), refName), refControl.getProjectControl().getProject(), change.getDest().get(), commit, ctx.getUser().asIdentifiedUser());
        switch(validatePolicy) {
            case RECEIVE_COMMITS:
                NoteMap rejectCommits = BanCommit.loadRejectCommitsMap(ctx.getRepository(), ctx.getRevWalk());
                cv.validateForReceiveCommits(event, rejectCommits);
                break;
            case GERRIT:
                cv.validateForGerritCommits(event);
                break;
            case NONE:
                break;
        }
    } catch (CommitValidationException e) {
        throw new ResourceConflictException(e.getFullMessage());
    } catch (NoSuchProjectException e) {
        throw new ResourceConflictException(e.getMessage());
    }
}
#end_block

#method_before
@Override
public ChangeInfo apply(ChangeResource req, final AbandonInput input) throws RestApiException, UpdateException, OrmException {
    ChangeControl control = req.getControl();
    IdentifiedUser caller = control.getUser().asIdentifiedUser();
    if (!control.canAbandon(dbProvider.get())) {
        throw new AuthException("abandon not permitted");
    }
    Change change = abandon(control, input.message, caller.getAccount());
    return json.create(ChangeJson.NO_OPTIONS).format(change);
}
#method_after
@Override
public ChangeInfo apply(ChangeResource req, AbandonInput input) throws RestApiException, UpdateException, OrmException {
    ChangeControl control = req.getControl();
    if (!control.canAbandon(dbProvider.get())) {
        throw new AuthException("abandon not permitted");
    }
    Change change = abandon(control, input.message);
    return json.create(ChangeJson.NO_OPTIONS).format(change);
}
#end_block

#method_before
public Change abandon(ChangeControl control, final String msgTxt, final Account account) throws RestApiException, UpdateException {
    Op op = new Op(msgTxt, account);
    Change c = control.getChange();
    try (BatchUpdate u = batchUpdateFactory.create(dbProvider.get(), c.getProject(), control.getUser(), TimeUtil.nowTs())) {
        u.addOp(c.getId(), op).execute();
    }
    return op.change;
}
#method_after
public Change abandon(ChangeControl control, String msgTxt) throws RestApiException, UpdateException {
    CurrentUser user = control.getUser();
    Account account = user.isIdentifiedUser() ? user.asIdentifiedUser().getAccount() : null;
    Op op = new Op(msgTxt, account);
    try (BatchUpdate u = batchUpdateFactory.create(dbProvider.get(), control.getProject().getNameKey(), user, TimeUtil.nowTs())) {
        u.addOp(control.getId(), op).execute();
    }
    return op.change;
}
#end_block

#method_before
@Override
public void updateChange(ChangeContext ctx) throws OrmException, ResourceConflictException {
    change = ctx.getChange();
    if (change == null || !change.getStatus().isOpen()) {
        throw new ResourceConflictException("change is " + status(change));
    } else if (change.getStatus() == Change.Status.DRAFT) {
        throw new ResourceConflictException("draft changes cannot be abandoned");
    }
    patchSet = ctx.getDb().patchSets().get(change.currentPatchSetId());
    change.setStatus(Change.Status.ABANDONED);
    change.setLastUpdatedOn(ctx.getWhen());
    ctx.getDb().changes().update(Collections.singleton(change));
    message = newMessage(ctx.getDb());
    cmUtil.addChangeMessage(ctx.getDb(), ctx.getChangeUpdate(), message);
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, ResourceConflictException {
    change = ctx.getChange();
    PatchSet.Id psId = change.currentPatchSetId();
    ChangeUpdate update = ctx.getUpdate(psId);
    if (!change.getStatus().isOpen()) {
        throw new ResourceConflictException("change is " + status(change));
    } else if (change.getStatus() == Change.Status.DRAFT) {
        throw new ResourceConflictException("draft changes cannot be abandoned");
    }
    patchSet = psUtil.get(ctx.getDb(), ctx.getNotes(), psId);
    change.setStatus(Change.Status.ABANDONED);
    change.setLastUpdatedOn(ctx.getWhen());
    update.setStatus(change.getStatus());
    message = newMessage(ctx);
    cmUtil.addChangeMessage(ctx.getDb(), update, message);
    return true;
}
#end_block

#method_before
private ChangeMessage newMessage(ReviewDb db) throws OrmException {
    StringBuilder msg = new StringBuilder();
    msg.append("Abandoned");
    if (!Strings.nullToEmpty(msgTxt).trim().isEmpty()) {
        msg.append("\n\n");
        msg.append(msgTxt.trim());
    }
    ChangeMessage message = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), account != null ? account.getId() : null, change.getLastUpdatedOn(), change.currentPatchSetId());
    message.setMessage(msg.toString());
    return message;
}
#method_after
private ChangeMessage newMessage(ChangeContext ctx) throws OrmException {
    StringBuilder msg = new StringBuilder();
    msg.append("Abandoned");
    if (!Strings.nullToEmpty(msgTxt).trim().isEmpty()) {
        msg.append("\n\n");
        msg.append(msgTxt.trim());
    }
    ChangeMessage message = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(ctx.getDb())), account != null ? account.getId() : null, ctx.getWhen(), change.currentPatchSetId());
    message.setMessage(msg.toString());
    return message;
}
#end_block

#method_before
@Override
public void postUpdate(Context ctx) throws OrmException {
    try {
        ReplyToChangeSender cm = abandonedSenderFactory.create(change.getId());
        if (account != null) {
            cm.setFrom(account.getId());
        }
        cm.setChangeMessage(message);
        cm.send();
    } catch (Exception e) {
        log.error("Cannot email update for change " + change.getId(), e);
    }
    changeAbandoned.fire(change, patchSet, account, msgTxt);
}
#method_after
@Override
public void postUpdate(Context ctx) throws OrmException {
    try {
        ReplyToChangeSender cm = abandonedSenderFactory.create(ctx.getProject(), change.getId());
        if (account != null) {
            cm.setFrom(account.getId());
        }
        cm.setChangeMessage(message);
        cm.send();
    } catch (Exception e) {
        log.error("Cannot email update for change " + change.getId(), e);
    }
    changeAbandoned.fire(change, patchSet, account, msgTxt);
}
#end_block

#method_before
@Override
public ChangeInfo apply(ChangeResource req, RestoreInput input) throws RestApiException, UpdateException, OrmException {
    ChangeControl ctl = req.getControl();
    if (!ctl.canRestore(dbProvider.get())) {
        throw new AuthException("restore not permitted");
    }
    Op op = new Op(input);
    try (BatchUpdate u = batchUpdateFactory.create(dbProvider.get(), req.getChange().getProject(), ctl.getUser(), TimeUtil.nowTs())) {
        u.addOp(req.getChange().getId(), op).execute();
    }
    return json.create(ChangeJson.NO_OPTIONS).format(op.change);
}
#method_after
@Override
public ChangeInfo apply(ChangeResource req, RestoreInput input) throws RestApiException, UpdateException, OrmException {
    ChangeControl ctl = req.getControl();
    if (!ctl.canRestore(dbProvider.get())) {
        throw new AuthException("restore not permitted");
    }
    Op op = new Op(input);
    try (BatchUpdate u = batchUpdateFactory.create(dbProvider.get(), req.getChange().getProject(), ctl.getUser(), TimeUtil.nowTs())) {
        u.addOp(req.getId(), op).execute();
    }
    return json.create(ChangeJson.NO_OPTIONS).format(op.change);
}
#end_block

#method_before
@Override
public void updateChange(ChangeContext ctx) throws OrmException, ResourceConflictException {
    caller = ctx.getUser().asIdentifiedUser();
    change = ctx.getChange();
    if (change == null || change.getStatus() != Status.ABANDONED) {
        throw new ResourceConflictException("change is " + status(change));
    }
    patchSet = ctx.getDb().patchSets().get(change.currentPatchSetId());
    change.setStatus(Status.NEW);
    change.setLastUpdatedOn(ctx.getWhen());
    ctx.getDb().changes().update(Collections.singleton(change));
    message = newMessage(ctx.getDb());
    cmUtil.addChangeMessage(ctx.getDb(), ctx.getChangeUpdate(), message);
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, ResourceConflictException {
    change = ctx.getChange();
    if (change == null || change.getStatus() != Status.ABANDONED) {
        throw new ResourceConflictException("change is " + status(change));
    }
    PatchSet.Id psId = change.currentPatchSetId();
    ChangeUpdate update = ctx.getUpdate(psId);
    patchSet = psUtil.get(ctx.getDb(), ctx.getNotes(), psId);
    change.setStatus(Status.NEW);
    change.setLastUpdatedOn(ctx.getWhen());
    update.setStatus(change.getStatus());
    message = newMessage(ctx);
    cmUtil.addChangeMessage(ctx.getDb(), update, message);
    return true;
}
#end_block

#method_before
private ChangeMessage newMessage(ReviewDb db) throws OrmException {
    StringBuilder msg = new StringBuilder();
    msg.append("Restored");
    if (!Strings.nullToEmpty(input.message).trim().isEmpty()) {
        msg.append("\n\n");
        msg.append(input.message.trim());
    }
    ChangeMessage message = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), caller.getAccountId(), change.getLastUpdatedOn(), change.currentPatchSetId());
    message.setMessage(msg.toString());
    return message;
}
#method_after
private ChangeMessage newMessage(ChangeContext ctx) throws OrmException {
    StringBuilder msg = new StringBuilder();
    msg.append("Restored");
    if (!Strings.nullToEmpty(input.message).trim().isEmpty()) {
        msg.append("\n\n");
        msg.append(input.message.trim());
    }
    ChangeMessage message = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(ctx.getDb())), ctx.getUser().getAccountId(), ctx.getWhen(), change.currentPatchSetId());
    message.setMessage(msg.toString());
    return message;
}
#end_block

#method_before
@Override
public void postUpdate(Context ctx) throws OrmException {
    try {
        ReplyToChangeSender cm = restoredSenderFactory.create(change.getId());
        cm.setFrom(caller.getAccountId());
        cm.setChangeMessage(message);
        cm.send();
    } catch (Exception e) {
        log.error("Cannot email update for change " + change.getId(), e);
    }
    changeRestored.fire(change, patchSet, caller.getAccount(), Strings.emptyToNull(input.message));
}
#method_after
@Override
public void postUpdate(Context ctx) throws OrmException {
    try {
        ReplyToChangeSender cm = restoredSenderFactory.create(ctx.getProject(), change.getId());
        cm.setFrom(ctx.getUser().getAccountId());
        cm.setChangeMessage(message);
        cm.send();
    } catch (Exception e) {
        log.error("Cannot email update for change " + change.getId(), e);
    }
    changeRestored.fire(change, patchSet, ctx.getUser().asIdentifiedUser().getAccount(), Strings.emptyToNull(input.message));
}
#end_block

#method_before
@VisibleForTesting
public void start() throws IOException {
    if (dbInjector == null) {
        dbInjector = createDbInjector(MULTI_USER);
    }
    cfgInjector = createCfgInjector();
    config = cfgInjector.getInstance(Key.get(Config.class, GerritServerConfig.class));
    initIndexType();
    sysInjector = createSysInjector();
    sysInjector.getInstance(PluginGuiceEnvironment.class).setDbCfgInjector(dbInjector, cfgInjector);
    manager.add(dbInjector, cfgInjector, sysInjector);
    if (!consoleLog) {
        manager.add(ErrorLogFile.start(getSitePath(), config));
    }
    sshd &= !sshdOff();
    if (sshd) {
        initSshd();
    }
    if (MoreObjects.firstNonNull(httpd, true)) {
        initHttpd();
    }
    manager.start();
}
#method_after
@VisibleForTesting
public void start() throws IOException {
    if (dbInjector == null) {
        dbInjector = createDbInjector(true, /* enableMetrics */
        MULTI_USER);
    }
    cfgInjector = createCfgInjector();
    config = cfgInjector.getInstance(Key.get(Config.class, GerritServerConfig.class));
    if (!slave) {
        initIndexType();
    }
    sysInjector = createSysInjector();
    sysInjector.getInstance(PluginGuiceEnvironment.class).setDbCfgInjector(dbInjector, cfgInjector);
    manager.add(dbInjector, cfgInjector, sysInjector);
    if (!consoleLog) {
        manager.add(ErrorLogFile.start(getSitePath(), config));
    }
    sshd &= !sshdOff();
    if (sshd) {
        initSshd();
    }
    if (MoreObjects.firstNonNull(httpd, true)) {
        initHttpd();
    }
    manager.start();
}
#end_block

#method_before
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(SchemaVersionCheck.module());
    modules.add(new DropWizardMetricMaker.Module());
    modules.add(new LogFileCompressor.Module());
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookApiListener.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new DiffExecutorModule());
    modules.add(new MimeUtil2Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new ChangeCacheImplModule(slave));
    modules.add(new InternalAccountDirectory.Module());
    modules.add(new DefaultCacheFactory.Module());
    if (emailModule != null) {
        modules.add(emailModule);
    } else {
        modules.add(new SmtpEmailSender.Module());
    }
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginRestApiModule());
    modules.add(new RestCacheAdminModule());
    modules.add(new GpgModule(config));
    modules.add(createIndexModule());
    if (MoreObjects.firstNonNull(httpd, true)) {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return HttpCanonicalWebUrlProvider.class;
            }
        });
    } else {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return CanonicalWebUrlProvider.class;
            }
        });
    }
    if (sshd) {
        modules.add(SshKeyCacheImpl.module());
    } else {
        modules.add(NoSshKeyCache.module());
    }
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritOptions.class).toInstance(new GerritOptions(headless, slave));
            if (test) {
                bind(String.class).annotatedWith(SecureStoreClassName.class).toInstance(DefaultSecureStore.class.getName());
                bind(SecureStore.class).toProvider(SecureStoreProvider.class);
            }
        }
    });
    modules.add(new GarbageCollectionModule());
    modules.add(new ChangeCleanupRunner.Module());
    return cfgInjector.createChildInjector(modules);
}
#method_after
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(SchemaVersionCheck.module());
    modules.add(new DropWizardMetricMaker.RestModule());
    modules.add(new LogFileCompressor.Module());
    // Index module shutdown must happen before work queue shutdown, otherwise
    // work queue can get stuck waiting on index futures that will never return.
    modules.add(createIndexModule());
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookApiListener.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new EventBroker.Module());
    modules.add(new AccountPatchReviewStoreImpl.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new DiffExecutorModule());
    modules.add(new MimeUtil2Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new SearchingChangeCacheImpl.Module());
    modules.add(new InternalAccountDirectory.Module());
    modules.add(new DefaultCacheFactory.Module());
    if (emailModule != null) {
        modules.add(emailModule);
    } else {
        modules.add(new SmtpEmailSender.Module());
    }
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginRestApiModule());
    modules.add(new RestCacheAdminModule());
    modules.add(new GpgModule(config));
    if (MoreObjects.firstNonNull(httpd, true)) {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return HttpCanonicalWebUrlProvider.class;
            }
        });
    } else {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return CanonicalWebUrlProvider.class;
            }
        });
    }
    if (sshd) {
        modules.add(SshKeyCacheImpl.module());
    } else {
        modules.add(NoSshKeyCache.module());
    }
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritOptions.class).toInstance(new GerritOptions(config, headless, slave, polyGerritDev));
            if (test) {
                bind(String.class).annotatedWith(SecureStoreClassName.class).toInstance(DefaultSecureStore.class.getName());
                bind(SecureStore.class).toProvider(SecureStoreProvider.class);
            }
        }
    });
    modules.add(new GarbageCollectionModule());
    if (!slave) {
        modules.add(new ChangeCleanupRunner.Module());
    }
    return cfgInjector.createChildInjector(modules);
}
#end_block

#method_before
private AbstractModule createIndexModule() {
    if (slave) {
        return new DummyIndexModule();
    }
    switch(indexType) {
        case LUCENE:
            return luceneModule != null ? luceneModule : new LuceneIndexModule();
        default:
            throw new IllegalStateException("unsupported index.type = " + indexType);
    }
}
#method_after
private AbstractModule createIndexModule() {
    if (slave) {
        return new DummyIndexModule();
    }
    switch(indexType) {
        case LUCENE:
            return luceneModule != null ? luceneModule : LuceneIndexModule.latestVersionWithOnlineUpgrade();
        default:
            throw new IllegalStateException("unsupported index.type = " + indexType);
    }
}
#end_block

#method_before
private Injector createSshInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(sysInjector.getInstance(SshModule.class));
    if (!test) {
        modules.add(new SshHostKeyModule());
    }
    modules.add(new DefaultCommandModule(slave, sysInjector.getInstance(DownloadConfig.class)));
    if (indexType == IndexType.LUCENE) {
        modules.add(new IndexCommandsModule());
    }
    return sysInjector.createChildInjector(modules);
}
#method_after
private Injector createSshInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(sysInjector.getInstance(SshModule.class));
    if (!test) {
        modules.add(new SshHostKeyModule());
    }
    modules.add(new DefaultCommandModule(slave, sysInjector.getInstance(DownloadConfig.class)));
    if (!slave && indexType == IndexType.LUCENE) {
        modules.add(new IndexCommandsModule());
    }
    return sysInjector.createChildInjector(modules);
}
#end_block

#method_before
private Injector createWebInjector() {
    final List<Module> modules = new ArrayList<>();
    if (sshd) {
        modules.add(new ProjectQoSFilter.Module());
    }
    modules.add(RequestContextFilter.module());
    modules.add(AllRequestFilter.module());
    modules.add(H2CacheBasedWebSession.module());
    modules.add(sysInjector.getInstance(GitOverHttpModule.class));
    modules.add(sysInjector.getInstance(WebModule.class));
    modules.add(sysInjector.getInstance(RequireSslFilter.Module.class));
    modules.add(new HttpPluginModule());
    if (sshd) {
        modules.add(sshInjector.getInstance(WebSshGlueModule.class));
    } else {
        modules.add(new NoSshModule());
    }
    AuthConfig authConfig = cfgInjector.getInstance(AuthConfig.class);
    if (authConfig.getAuthType() == AuthType.OPENID || authConfig.getAuthType() == AuthType.OPENID_SSO) {
        modules.add(new OpenIdModule());
    } else if (authConfig.getAuthType() == AuthType.OAUTH) {
        modules.add(new OAuthModule());
    }
    modules.add(sysInjector.getInstance(GetUserFilter.Module.class));
    return sysInjector.createChildInjector(modules);
}
#method_after
private Injector createWebInjector() {
    final List<Module> modules = new ArrayList<>();
    if (sshd) {
        modules.add(new ProjectQoSFilter.Module());
    }
    modules.add(RequestContextFilter.module());
    modules.add(AllRequestFilter.module());
    modules.add(RequestMetricsFilter.module());
    modules.add(H2CacheBasedWebSession.module());
    modules.add(sysInjector.getInstance(GitOverHttpModule.class));
    modules.add(sysInjector.getInstance(WebModule.class));
    modules.add(sysInjector.getInstance(RequireSslFilter.Module.class));
    modules.add(new HttpPluginModule());
    if (sshd) {
        modules.add(sshInjector.getInstance(WebSshGlueModule.class));
    } else {
        modules.add(new NoSshModule());
    }
    AuthConfig authConfig = cfgInjector.getInstance(AuthConfig.class);
    if (authConfig.getAuthType() == AuthType.OPENID || authConfig.getAuthType() == AuthType.OPENID_SSO) {
        modules.add(new OpenIdModule());
    } else if (authConfig.getAuthType() == AuthType.OAUTH) {
        modules.add(new OAuthModule());
    }
    modules.add(sysInjector.getInstance(GetUserFilter.Module.class));
    // StaticModule contains a "/*" wildcard, place it last.
    modules.add(sysInjector.getInstance(StaticModule.class));
    return sysInjector.createChildInjector(modules);
}
#end_block

#method_before
@Override
public Response<?> apply(BranchResource rsrc, Input input) throws AuthException, ResourceConflictException, OrmException, IOException {
    if (!rsrc.getControl().controlForRef(rsrc.getBranchKey()).canDelete()) {
        throw new AuthException("Cannot delete branch");
    }
    if (!queryProvider.get().setLimit(1).byBranchOpen(rsrc.getBranchKey()).isEmpty()) {
        throw new ResourceConflictException("branch " + rsrc.getBranchKey() + " has open changes");
    }
    try (Repository r = repoManager.openRepository(rsrc.getNameKey())) {
        RefUpdate.Result result;
        RefUpdate u = r.updateRef(rsrc.getRef());
        u.setForceUpdate(true);
        int remainingLockFailureCalls = MAX_LOCK_FAILURE_CALLS;
        for (; ; ) {
            try {
                result = u.delete();
            } catch (LockFailedException e) {
                result = RefUpdate.Result.LOCK_FAILURE;
            } catch (IOException e) {
                log.error("Cannot delete " + rsrc.getBranchKey(), e);
                throw e;
            }
            if (result == RefUpdate.Result.LOCK_FAILURE && --remainingLockFailureCalls > 0) {
                try {
                    Thread.sleep(SLEEP_ON_LOCK_FAILURE_MS);
                } catch (InterruptedException ie) {
                // ignore
                }
            } else {
                break;
            }
        }
        switch(result) {
            case NEW:
            case NO_CHANGE:
            case FAST_FORWARD:
            case FORCED:
                referenceUpdated.fire(rsrc.getNameKey(), u, ReceiveCommand.Type.DELETE, identifiedUser.get().getAccount());
                ResultSet<SubmoduleSubscription> submoduleSubscriptions = dbProvider.get().submoduleSubscriptions().bySuperProject(rsrc.getBranchKey());
                dbProvider.get().submoduleSubscriptions().delete(submoduleSubscriptions);
                break;
            case REJECTED_CURRENT_BRANCH:
                log.error("Cannot delete " + rsrc.getBranchKey() + ": " + result.name());
                throw new ResourceConflictException("cannot delete current branch");
            default:
                log.error("Cannot delete " + rsrc.getBranchKey() + ": " + result.name());
                throw new ResourceConflictException("cannot delete branch: " + result.name());
        }
    }
    return Response.none();
}
#method_after
@Override
public Response<?> apply(BranchResource rsrc, Input input) throws AuthException, ResourceConflictException, OrmException, IOException {
    if (!rsrc.getControl().controlForRef(rsrc.getBranchKey()).canDelete()) {
        throw new AuthException("Cannot delete branch");
    }
    if (!queryProvider.get().setLimit(1).byBranchOpen(rsrc.getBranchKey()).isEmpty()) {
        throw new ResourceConflictException("branch " + rsrc.getBranchKey() + " has open changes");
    }
    try (Repository r = repoManager.openRepository(rsrc.getNameKey())) {
        RefUpdate.Result result;
        RefUpdate u = r.updateRef(rsrc.getRef());
        u.setForceUpdate(true);
        int remainingLockFailureCalls = MAX_LOCK_FAILURE_CALLS;
        for (; ; ) {
            try {
                result = u.delete();
            } catch (LockFailedException e) {
                result = RefUpdate.Result.LOCK_FAILURE;
            } catch (IOException e) {
                log.error("Cannot delete " + rsrc.getBranchKey(), e);
                throw e;
            }
            if (result == RefUpdate.Result.LOCK_FAILURE && --remainingLockFailureCalls > 0) {
                try {
                    Thread.sleep(SLEEP_ON_LOCK_FAILURE_MS);
                } catch (InterruptedException ie) {
                // ignore
                }
            } else {
                break;
            }
        }
        switch(result) {
            case NEW:
            case NO_CHANGE:
            case FAST_FORWARD:
            case FORCED:
                referenceUpdated.fire(rsrc.getNameKey(), u, ReceiveCommand.Type.DELETE, identifiedUser.get().getAccount());
                break;
            case REJECTED_CURRENT_BRANCH:
                log.error("Cannot delete " + rsrc.getBranchKey() + ": " + result.name());
                throw new ResourceConflictException("cannot delete current branch");
            case IO_FAILURE:
            case LOCK_FAILURE:
            case NOT_ATTEMPTED:
            case REJECTED:
            case RENAMED:
            default:
                log.error("Cannot delete " + rsrc.getBranchKey() + ": " + result.name());
                throw new ResourceConflictException("cannot delete branch: " + result.name());
        }
    }
    return Response.none();
}
#end_block

#method_before
private Injector createDbInjector() {
    final List<Module> modules = new ArrayList<>();
    AbstractModule secureStore = createSecureStoreModule();
    modules.add(secureStore);
    if (sitePath != null) {
        Module sitePathModule = new AbstractModule() {

            @Override
            protected void configure() {
                bind(Path.class).annotatedWith(SitePath.class).toInstance(sitePath);
            }
        };
        modules.add(sitePathModule);
        Module configModule = new GerritServerConfigModule();
        modules.add(configModule);
        Injector cfgInjector = Guice.createInjector(sitePathModule, configModule, secureStore);
        Config cfg = cfgInjector.getInstance(Key.get(Config.class, GerritServerConfig.class));
        String dbType = cfg.getString("database", null, "type");
        final DataSourceType dst = Guice.createInjector(new DataSourceModule(), configModule, sitePathModule, secureStore).getInstance(Key.get(DataSourceType.class, Names.named(dbType.toLowerCase())));
        modules.add(new LifecycleModule() {

            @Override
            protected void configure() {
                bind(DataSourceType.class).toInstance(dst);
                bind(DataSourceProvider.Context.class).toInstance(DataSourceProvider.Context.MULTI_USER);
                bind(Key.get(DataSource.class, Names.named("ReviewDb"))).toProvider(DataSourceProvider.class).in(SINGLETON);
                listener().to(DataSourceProvider.class);
            }
        });
    } else {
        modules.add(new LifecycleModule() {

            @Override
            protected void configure() {
                bind(Key.get(DataSource.class, Names.named("ReviewDb"))).toProvider(ReviewDbDataSourceProvider.class).in(SINGLETON);
                listener().to(ReviewDbDataSourceProvider.class);
            }
        });
    }
    modules.add(new DatabaseModule());
    return Guice.createInjector(PRODUCTION, modules);
}
#method_after
private Injector createDbInjector() {
    final List<Module> modules = new ArrayList<>();
    AbstractModule secureStore = createSecureStoreModule();
    modules.add(secureStore);
    if (sitePath != null) {
        Module sitePathModule = new AbstractModule() {

            @Override
            protected void configure() {
                bind(Path.class).annotatedWith(SitePath.class).toInstance(sitePath);
            }
        };
        modules.add(sitePathModule);
        Module configModule = new GerritServerConfigModule();
        modules.add(configModule);
        Injector cfgInjector = Guice.createInjector(sitePathModule, configModule, secureStore);
        Config cfg = cfgInjector.getInstance(Key.get(Config.class, GerritServerConfig.class));
        String dbType = cfg.getString("database", null, "type");
        final DataSourceType dst = Guice.createInjector(new DataSourceModule(), configModule, sitePathModule, secureStore).getInstance(Key.get(DataSourceType.class, Names.named(dbType.toLowerCase())));
        modules.add(new LifecycleModule() {

            @Override
            protected void configure() {
                bind(DataSourceType.class).toInstance(dst);
                bind(DataSourceProvider.Context.class).toInstance(DataSourceProvider.Context.MULTI_USER);
                bind(Key.get(DataSource.class, Names.named("ReviewDb"))).toProvider(DataSourceProvider.class).in(SINGLETON);
                listener().to(DataSourceProvider.class);
            }
        });
    } else {
        modules.add(new LifecycleModule() {

            @Override
            protected void configure() {
                bind(Key.get(DataSource.class, Names.named("ReviewDb"))).toProvider(ReviewDbDataSourceProvider.class).in(SINGLETON);
                listener().to(ReviewDbDataSourceProvider.class);
            }
        });
    }
    modules.add(new DatabaseModule());
    modules.add(new DropWizardMetricMaker.ApiModule());
    return Guice.createInjector(PRODUCTION, modules);
}
#end_block

#method_before
private Injector createCfgInjector() {
    final List<Module> modules = new ArrayList<>();
    if (sitePath == null) {
        // If we didn't get the site path from the system property
        // we need to get it from the database, as that's our old
        // method of locating the site path on disk.
        // 
        modules.add(new AbstractModule() {

            @Override
            protected void configure() {
                bind(Path.class).annotatedWith(SitePath.class).toProvider(SitePathFromSystemConfigProvider.class).in(SINGLETON);
            }
        });
        modules.add(new GerritServerConfigModule());
    }
    modules.add(new SchemaModule());
    modules.add(new LocalDiskRepositoryManager.Module());
    modules.add(SchemaVersionCheck.module());
    modules.add(new AuthConfigModule());
    return dbInjector.createChildInjector(modules);
}
#method_after
private Injector createCfgInjector() {
    final List<Module> modules = new ArrayList<>();
    if (sitePath == null) {
        // If we didn't get the site path from the system property
        // we need to get it from the database, as that's our old
        // method of locating the site path on disk.
        // 
        modules.add(new AbstractModule() {

            @Override
            protected void configure() {
                bind(Path.class).annotatedWith(SitePath.class).toProvider(SitePathFromSystemConfigProvider.class).in(SINGLETON);
            }
        });
        modules.add(new GerritServerConfigModule());
    }
    modules.add(new SchemaModule());
    modules.add(new ConfigNotesMigration.Module());
    modules.add(SchemaVersionCheck.module());
    modules.add(new AuthConfigModule());
    return dbInjector.createChildInjector(modules);
}
#end_block

#method_before
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(new DropWizardMetricMaker.Module());
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookApiListener.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new DiffExecutorModule());
    modules.add(new MimeUtil2Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new ChangeCacheImplModule(false));
    modules.add(new InternalAccountDirectory.Module());
    modules.add(new DefaultCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginRestApiModule());
    modules.add(new RestCacheAdminModule());
    modules.add(new GpgModule(config));
    switch(indexType) {
        case LUCENE:
            modules.add(new LuceneIndexModule());
            break;
        default:
            throw new IllegalStateException("unsupported index.type = " + indexType);
    }
    modules.add(new CanonicalWebUrlModule() {

        @Override
        protected Class<? extends Provider<String>> provider() {
            return HttpCanonicalWebUrlProvider.class;
        }
    });
    modules.add(SshKeyCacheImpl.module());
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritOptions.class).toInstance(new GerritOptions(false, false));
        }
    });
    modules.add(new GarbageCollectionModule());
    modules.add(new ChangeCleanupRunner.Module());
    return cfgInjector.createChildInjector(modules);
}
#method_after
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(new DropWizardMetricMaker.RestModule());
    modules.add(new EventBroker.Module());
    modules.add(new AccountPatchReviewStoreImpl.Module());
    modules.add(cfgInjector.getInstance(GitRepositoryManagerModule.class));
    modules.add(new ChangeHookApiListener.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new DiffExecutorModule());
    modules.add(new MimeUtil2Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new SearchingChangeCacheImpl.Module());
    modules.add(new InternalAccountDirectory.Module());
    modules.add(new DefaultCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginRestApiModule());
    modules.add(new RestCacheAdminModule());
    modules.add(new GpgModule(config));
    // Index module shutdown must happen before work queue shutdown, otherwise
    // work queue can get stuck waiting on index futures that will never return.
    modules.add(createIndexModule());
    modules.add(new WorkQueue.Module());
    modules.add(new CanonicalWebUrlModule() {

        @Override
        protected Class<? extends Provider<String>> provider() {
            return HttpCanonicalWebUrlProvider.class;
        }
    });
    modules.add(SshKeyCacheImpl.module());
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritOptions.class).toInstance(new GerritOptions(config, false, false, false));
        }
    });
    modules.add(new GarbageCollectionModule());
    modules.add(new ChangeCleanupRunner.Module());
    return cfgInjector.createChildInjector(modules);
}
#end_block

#method_before
private Injector createWebInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(RequestContextFilter.module());
    modules.add(AllRequestFilter.module());
    modules.add(sysInjector.getInstance(GitOverHttpModule.class));
    modules.add(sysInjector.getInstance(WebModule.class));
    modules.add(sysInjector.getInstance(RequireSslFilter.Module.class));
    if (sshInjector != null) {
        modules.add(sshInjector.getInstance(WebSshGlueModule.class));
    } else {
        modules.add(new NoSshModule());
    }
    modules.add(H2CacheBasedWebSession.module());
    modules.add(new HttpPluginModule());
    AuthConfig authConfig = cfgInjector.getInstance(AuthConfig.class);
    if (authConfig.getAuthType() == AuthType.OPENID) {
        modules.add(new OpenIdModule());
    } else if (authConfig.getAuthType() == AuthType.OAUTH) {
        modules.add(new OAuthModule());
    }
    modules.add(sysInjector.getInstance(GetUserFilter.Module.class));
    return sysInjector.createChildInjector(modules);
}
#method_after
private Injector createWebInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(RequestContextFilter.module());
    modules.add(AllRequestFilter.module());
    modules.add(RequestMetricsFilter.module());
    modules.add(sysInjector.getInstance(GitOverHttpModule.class));
    modules.add(sysInjector.getInstance(WebModule.class));
    modules.add(sysInjector.getInstance(RequireSslFilter.Module.class));
    if (sshInjector != null) {
        modules.add(sshInjector.getInstance(WebSshGlueModule.class));
    } else {
        modules.add(new NoSshModule());
    }
    modules.add(H2CacheBasedWebSession.module());
    modules.add(new HttpPluginModule());
    AuthConfig authConfig = cfgInjector.getInstance(AuthConfig.class);
    if (authConfig.getAuthType() == AuthType.OPENID) {
        modules.add(new OpenIdModule());
    } else if (authConfig.getAuthType() == AuthType.OAUTH) {
        modules.add(new OAuthModule());
    }
    modules.add(sysInjector.getInstance(GetUserFilter.Module.class));
    // StaticModule contains a "/*" wildcard, place it last.
    modules.add(sysInjector.getInstance(StaticModule.class));
    return sysInjector.createChildInjector(modules);
}
#end_block

#method_before
public ChangeInfo format(RevisionResource rsrc) throws OrmException {
    ChangeData cd = changeDataFactory.create(db.get(), rsrc.getControl());
    return format(cd, Optional.of(rsrc.getPatchSet().getId()), true);
}
#method_after
public ChangeInfo format(Project.NameKey project, Change.Id id) throws OrmException, NoSuchChangeException {
    ChangeNotes notes;
    try {
        notes = notesFactory.createChecked(db.get(), project, id);
    } catch (OrmException | NoSuchChangeException e) {
        if (!has(CHECK)) {
            throw e;
        }
        return checkOnly(changeDataFactory.create(db.get(), project, id));
    }
    return format(changeDataFactory.create(db.get(), notes));
}
#end_block

#method_before
private ChangeInfo format(ChangeData cd, Optional<PatchSet.Id> limitToPsId, boolean fillAccountLoader) throws OrmException {
    try {
        if (fillAccountLoader) {
            accountLoader = accountLoaderFactory.create(has(DETAILED_ACCOUNTS));
            ChangeInfo res = toChangeInfo(cd, limitToPsId);
            accountLoader.fill();
            return res;
        } else {
            return toChangeInfo(cd, limitToPsId);
        }
    } catch (PatchListNotAvailableException | GpgException | OrmException | IOException | RuntimeException e) {
        if (!has(CHECK)) {
            Throwables.propagateIfPossible(e, OrmException.class);
            throw new OrmException(e);
        }
        return checkOnly(cd);
    }
}
#method_after
private ChangeInfo format(ChangeData cd, Optional<PatchSet.Id> limitToPsId, boolean fillAccountLoader) throws OrmException {
    try {
        if (fillAccountLoader) {
            accountLoader = accountLoaderFactory.create(has(DETAILED_ACCOUNTS));
            ChangeInfo res = toChangeInfo(cd, limitToPsId);
            accountLoader.fill();
            return res;
        }
        return toChangeInfo(cd, limitToPsId);
    } catch (PatchListNotAvailableException | GpgException | OrmException | IOException | RuntimeException e) {
        if (!has(CHECK)) {
            Throwables.propagateIfPossible(e, OrmException.class);
            throw new OrmException(e);
        }
        return checkOnly(cd);
    }
}
#end_block

#method_before
public List<List<ChangeInfo>> formatQueryResults(List<QueryResult> in) throws OrmException {
    accountLoader = accountLoaderFactory.create(has(DETAILED_ACCOUNTS));
    ensureLoaded(FluentIterable.from(in).transformAndConcat(new Function<QueryResult, List<ChangeData>>() {

        @Override
        public List<ChangeData> apply(QueryResult in) {
            return in.changes();
        }
    }));
    List<List<ChangeInfo>> res = Lists.newArrayListWithCapacity(in.size());
    Map<Change.Id, ChangeInfo> out = Maps.newHashMap();
    for (QueryResult r : in) {
        List<ChangeInfo> infos = toChangeInfo(out, r.changes());
        if (!infos.isEmpty() && r.moreChanges()) {
            infos.get(infos.size() - 1)._moreChanges = true;
        }
        res.add(infos);
    }
    accountLoader.fill();
    return res;
}
#method_after
public List<List<ChangeInfo>> formatQueryResults(List<QueryResult> in) throws OrmException {
    accountLoader = accountLoaderFactory.create(has(DETAILED_ACCOUNTS));
    ensureLoaded(FluentIterable.from(in).transformAndConcat(new Function<QueryResult, List<ChangeData>>() {

        @Override
        public List<ChangeData> apply(QueryResult in) {
            return in.changes();
        }
    }));
    List<List<ChangeInfo>> res = Lists.newArrayListWithCapacity(in.size());
    Map<Change.Id, ChangeInfo> out = new HashMap<>();
    for (QueryResult r : in) {
        List<ChangeInfo> infos = toChangeInfo(out, r.changes());
        if (!infos.isEmpty() && r.moreChanges()) {
            infos.get(infos.size() - 1)._moreChanges = true;
        }
        res.add(infos);
    }
    accountLoader.fill();
    return res;
}
#end_block

#method_before
private ChangeInfo toChangeInfo(ChangeData cd, Optional<PatchSet.Id> limitToPsId) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    ChangeInfo out = new ChangeInfo();
    if (has(CHECK)) {
        out.problems = checkerProvider.get().check(cd.change(), fix).problems();
        // If any problems were fixed, the ChangeData needs to be reloaded.
        for (ProblemInfo p : out.problems) {
            if (p.status == ProblemInfo.Status.FIXED) {
                cd = changeDataFactory.create(cd.db(), cd.getId());
                break;
            }
        }
    }
    Change in = cd.change();
    CurrentUser user = userProvider.get();
    ChangeControl ctl = cd.changeControl().forUser(user);
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    out.hashtags = ctl.getNotes().load().getHashtags();
    out.changeId = in.getKey().get();
    // TODO(dborowitz): This gets the submit type, so we could include that in
    // the response and avoid making a request to /submit_type from the UI.
    out.mergeable = in.getStatus() == Change.Status.MERGED ? null : cd.isMergeable();
    out.submittable = submit.submittable(cd);
    ChangedLines changedLines = cd.changedLines();
    if (changedLines != null) {
        out.insertions = changedLines.insertions;
        out.deletions = changedLines.deletions;
    }
    out.subject = in.getSubject();
    out.status = in.getStatus().asChangeStatus();
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    out.starred = user.getStarredChanges().contains(in.getId()) ? true : null;
    if (in.getStatus().isOpen() && has(REVIEWED) && user.isIdentifiedUser()) {
        Account.Id accountId = user.getAccountId();
        out.reviewed = cd.reviewedBy().contains(accountId) ? true : null;
    }
    out.labels = labelsFor(ctl, cd, has(LABELS), has(DETAILED_LABELS));
    if (out.labels != null && has(DETAILED_LABELS)) {
        // list permitted labels, since users can't vote on those patch sets.
        if (!limitToPsId.isPresent() || limitToPsId.get().equals(in.currentPatchSetId())) {
            out.permittedLabels = permittedLabels(ctl, cd);
        }
        out.removableReviewers = removableReviewers(ctl, out.labels.values());
    }
    boolean needMessages = has(MESSAGES);
    boolean needRevisions = has(ALL_REVISIONS) || has(CURRENT_REVISION) || limitToPsId.isPresent();
    Map<PatchSet.Id, PatchSet> src;
    if (needMessages || needRevisions) {
        src = loadPatchSets(cd, limitToPsId);
    } else {
        src = null;
    }
    if (needMessages) {
        out.messages = messages(ctl, cd, src);
    }
    finish(out);
    if (needRevisions) {
        out.revisions = revisions(ctl, src);
        if (out.revisions != null) {
            for (Map.Entry<String, RevisionInfo> entry : out.revisions.entrySet()) {
                if (entry.getValue().isCurrent) {
                    out.currentRevision = entry.getKey();
                    break;
                }
            }
        }
    }
    if (has(CURRENT_ACTIONS) || has(CHANGE_ACTIONS)) {
        actionJson.addChangeActions(out, ctl);
    }
    return out;
}
#method_after
private ChangeInfo toChangeInfo(ChangeData cd, Optional<PatchSet.Id> limitToPsId) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    ChangeInfo out = new ChangeInfo();
    if (has(CHECK)) {
        out.problems = checkerProvider.get().check(cd.change(), fix).problems();
        // If any problems were fixed, the ChangeData needs to be reloaded.
        for (ProblemInfo p : out.problems) {
            if (p.status == ProblemInfo.Status.FIXED) {
                cd = changeDataFactory.create(cd.db(), cd.project(), cd.getId());
                break;
            }
        }
    }
    Change in = cd.change();
    CurrentUser user = userProvider.get();
    ChangeControl ctl = cd.changeControl().forUser(user);
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    out.hashtags = cd.hashtags();
    out.changeId = in.getKey().get();
    if (in.getStatus() != Change.Status.MERGED) {
        SubmitTypeRecord str = cd.submitTypeRecord();
        if (str.isOk()) {
            out.submitType = str.type;
        }
        out.mergeable = cd.isMergeable();
    }
    out.submittable = Submit.submittable(cd);
    ChangedLines changedLines = cd.changedLines();
    if (changedLines != null) {
        out.insertions = changedLines.insertions;
        out.deletions = changedLines.deletions;
    }
    out.subject = in.getSubject();
    out.status = in.getStatus().asChangeStatus();
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    if (user.isIdentifiedUser()) {
        Collection<String> stars = cd.stars().get(user.getAccountId());
        out.starred = stars.contains(StarredChangesUtil.DEFAULT_LABEL) ? true : null;
        if (!stars.isEmpty()) {
            out.stars = stars;
        }
    }
    if (in.getStatus().isOpen() && has(REVIEWED) && user.isIdentifiedUser()) {
        Account.Id accountId = user.getAccountId();
        out.reviewed = cd.reviewedBy().contains(accountId) ? true : null;
    }
    out.labels = labelsFor(ctl, cd, has(LABELS), has(DETAILED_LABELS));
    out.submitted = getSubmittedOn(cd);
    if (out.labels != null && has(DETAILED_LABELS)) {
        // list permitted labels, since users can't vote on those patch sets.
        if (!limitToPsId.isPresent() || limitToPsId.get().equals(in.currentPatchSetId())) {
            out.permittedLabels = permittedLabels(ctl, cd);
        }
        out.removableReviewers = removableReviewers(ctl, out.labels.values());
        out.reviewers = new HashMap<>();
        for (Map.Entry<ReviewerStateInternal, Map<Account.Id, Timestamp>> e : cd.reviewers().asTable().rowMap().entrySet()) {
            out.reviewers.put(e.getKey().asReviewerState(), toAccountInfo(e.getValue().keySet()));
        }
    }
    boolean needMessages = has(MESSAGES);
    boolean needRevisions = has(ALL_REVISIONS) || has(CURRENT_REVISION) || limitToPsId.isPresent();
    Map<PatchSet.Id, PatchSet> src;
    if (needMessages || needRevisions) {
        src = loadPatchSets(cd, limitToPsId);
    } else {
        src = null;
    }
    if (needMessages) {
        out.messages = messages(ctl, cd, src);
    }
    finish(out);
    if (needRevisions) {
        out.revisions = revisions(ctl, src);
        if (out.revisions != null) {
            for (Map.Entry<String, RevisionInfo> entry : out.revisions.entrySet()) {
                if (entry.getValue().isCurrent) {
                    out.currentRevision = entry.getKey();
                    break;
                }
            }
        }
    }
    if (has(CURRENT_ACTIONS) || has(CHANGE_ACTIONS)) {
        actionJson.addChangeActions(out, ctl);
    }
    return out;
}
#end_block

#method_before
private List<SubmitRecord> submitRecords(ChangeData cd) throws OrmException {
    if (cd.getSubmitRecords() != null) {
        return cd.getSubmitRecords();
    }
    cd.setSubmitRecords(new SubmitRuleEvaluator(cd).setFastEvalLabels(true).setAllowDraft(true).evaluate());
    return cd.getSubmitRecords();
}
#method_after
private List<SubmitRecord> submitRecords(ChangeData cd) throws OrmException {
    // TODO(dborowitz): Handle this better at the ChangeData level.
    if (submitRecords == null) {
        submitRecords = new HashMap<>();
    }
    List<SubmitRecord> records = submitRecords.get(cd.getId());
    if (records == null) {
        records = new SubmitRuleEvaluator(cd).setFastEvalLabels(true).setAllowDraft(true).evaluate();
        submitRecords.put(cd.getId(), records);
    }
    return records;
}
#end_block

#method_before
private Map<String, LabelWithStatus> initLabels(ChangeData cd, LabelTypes labelTypes, boolean standard) throws OrmException {
    // Don't use Maps.newTreeMap(Comparator) due to OpenJDK bug 100167.
    Map<String, LabelWithStatus> labels = new TreeMap<>(labelTypes.nameComparator());
    for (SubmitRecord rec : submitRecords(cd)) {
        if (rec.labels == null) {
            continue;
        }
        for (SubmitRecord.Label r : rec.labels) {
            LabelWithStatus p = labels.get(r.label);
            if (p == null || p.status().compareTo(r.status) < 0) {
                LabelInfo n = new LabelInfo();
                if (standard) {
                    switch(r.status) {
                        case OK:
                            n.approved = accountLoader.get(r.appliedBy);
                            break;
                        case REJECT:
                            n.rejected = accountLoader.get(r.appliedBy);
                            n.blocking = true;
                            break;
                        default:
                            break;
                    }
                }
                n.optional = r.status == SubmitRecord.Label.Status.MAY ? true : null;
                labels.put(r.label, LabelWithStatus.create(n, r.status));
            }
        }
    }
    return labels;
}
#method_after
private Map<String, LabelWithStatus> initLabels(ChangeData cd, LabelTypes labelTypes, boolean standard) throws OrmException {
    // Don't use Maps.newTreeMap(Comparator) due to OpenJDK bug 100167.
    Map<String, LabelWithStatus> labels = new TreeMap<>(labelTypes.nameComparator());
    for (SubmitRecord rec : submitRecords(cd)) {
        if (rec.labels == null) {
            continue;
        }
        for (SubmitRecord.Label r : rec.labels) {
            LabelWithStatus p = labels.get(r.label);
            if (p == null || p.status().compareTo(r.status) < 0) {
                LabelInfo n = new LabelInfo();
                if (standard) {
                    switch(r.status) {
                        case OK:
                            n.approved = accountLoader.get(r.appliedBy);
                            break;
                        case REJECT:
                            n.rejected = accountLoader.get(r.appliedBy);
                            n.blocking = true;
                            break;
                        case IMPOSSIBLE:
                        case MAY:
                        case NEED:
                        default:
                            break;
                    }
                }
                n.optional = r.status == SubmitRecord.Label.Status.MAY ? true : null;
                labels.put(r.label, LabelWithStatus.create(n, r.status));
            }
        }
    }
    return labels;
}
#end_block

#method_before
private void setAllApprovals(ChangeControl baseCtrl, ChangeData cd, Map<String, LabelWithStatus> labels) throws OrmException {
    // Include a user in the output for this label if either:
    // - They are an explicit reviewer.
    // - They ever voted on this change.
    Set<Account.Id> allUsers = Sets.newHashSet();
    allUsers.addAll(cd.reviewers().values());
    for (PatchSetApproval psa : cd.approvals().values()) {
        allUsers.add(psa.getAccountId());
    }
    Table<Account.Id, String, PatchSetApproval> current = HashBasedTable.create(allUsers.size(), baseCtrl.getLabelTypes().getLabelTypes().size());
    for (PatchSetApproval psa : cd.currentApprovals()) {
        current.put(psa.getAccountId(), psa.getLabel(), psa);
    }
    for (Account.Id accountId : allUsers) {
        IdentifiedUser user = userFactory.create(accountId);
        ChangeControl ctl = baseCtrl.forUser(user);
        for (Map.Entry<String, LabelWithStatus> e : labels.entrySet()) {
            LabelType lt = ctl.getLabelTypes().byLabel(e.getKey());
            if (lt == null) {
                // author didn't intend for the label to show up in the table.
                continue;
            }
            Integer value;
            Timestamp date = null;
            PatchSetApproval psa = current.get(accountId, lt.getName());
            if (psa != null) {
                value = Integer.valueOf(psa.getValue());
                if (value == 0) {
                    // This may be a dummy approval that was inserted when the reviewer
                    // was added. Explicitly check whether the user can vote on this
                    // label.
                    value = labelNormalizer.canVote(ctl, lt, accountId) ? 0 : null;
                }
                date = psa.getGranted();
            } else {
                // Either the user cannot vote on this label, or they were added as a
                // reviewer but have not responded yet. Explicitly check whether the
                // user can vote on this label.
                value = labelNormalizer.canVote(ctl, lt, accountId) ? 0 : null;
            }
            addApproval(e.getValue().label(), approvalInfo(accountId, value, date));
        }
    }
}
#method_after
private void setAllApprovals(ChangeControl baseCtrl, ChangeData cd, Map<String, LabelWithStatus> labels) throws OrmException {
    // Include a user in the output for this label if either:
    // - They are an explicit reviewer.
    // - They ever voted on this change.
    Set<Account.Id> allUsers = new HashSet<>();
    allUsers.addAll(cd.reviewers().all());
    for (PatchSetApproval psa : cd.approvals().values()) {
        allUsers.add(psa.getAccountId());
    }
    Table<Account.Id, String, PatchSetApproval> current = HashBasedTable.create(allUsers.size(), baseCtrl.getLabelTypes().getLabelTypes().size());
    for (PatchSetApproval psa : cd.currentApprovals()) {
        current.put(psa.getAccountId(), psa.getLabel(), psa);
    }
    for (Account.Id accountId : allUsers) {
        IdentifiedUser user = userFactory.create(accountId);
        ChangeControl ctl = baseCtrl.forUser(user);
        for (Map.Entry<String, LabelWithStatus> e : labels.entrySet()) {
            LabelType lt = ctl.getLabelTypes().byLabel(e.getKey());
            if (lt == null) {
                // author didn't intend for the label to show up in the table.
                continue;
            }
            Integer value;
            String tag = null;
            Timestamp date = null;
            PatchSetApproval psa = current.get(accountId, lt.getName());
            if (psa != null) {
                value = Integer.valueOf(psa.getValue());
                if (value == 0) {
                    // This may be a dummy approval that was inserted when the reviewer
                    // was added. Explicitly check whether the user can vote on this
                    // label.
                    value = labelNormalizer.canVote(ctl, lt, accountId) ? 0 : null;
                }
                tag = psa.getTag();
                date = psa.getGranted();
            } else {
                // Either the user cannot vote on this label, or they were added as a
                // reviewer but have not responded yet. Explicitly check whether the
                // user can vote on this label.
                value = labelNormalizer.canVote(ctl, lt, accountId) ? 0 : null;
            }
            addApproval(e.getValue().label(), approvalInfo(accountId, value, tag, date));
        }
    }
}
#end_block

#method_before
private Map<String, LabelWithStatus> labelsForClosedChange(ChangeData cd, LabelTypes labelTypes, boolean standard, boolean detailed) throws OrmException {
    Set<Account.Id> allUsers = Sets.newHashSet();
    if (detailed) {
        // the latest patch set (in the next loop).
        for (PatchSetApproval psa : cd.approvals().values()) {
            allUsers.add(psa.getAccountId());
        }
    }
    // We can only approximately reconstruct what the submit rule evaluator
    // would have done. These should really come from a stored submit record.
    Set<String> labelNames = Sets.newHashSet();
    Multimap<Account.Id, PatchSetApproval> current = HashMultimap.create();
    for (PatchSetApproval a : cd.currentApprovals()) {
        allUsers.add(a.getAccountId());
        LabelType type = labelTypes.byLabel(a.getLabelId());
        if (type != null) {
            labelNames.add(type.getName());
            // Not worth the effort to distinguish between votable/non-votable for 0
            // values on closed changes, since they can't vote anyway.
            current.put(a.getAccountId(), a);
        }
    }
    // Don't use Maps.newTreeMap(Comparator) due to OpenJDK bug 100167.
    Map<String, LabelWithStatus> labels = new TreeMap<>(labelTypes.nameComparator());
    for (String name : labelNames) {
        LabelType type = labelTypes.byLabel(name);
        LabelWithStatus l = LabelWithStatus.create(new LabelInfo(), null);
        if (detailed) {
            setLabelValues(type, l);
        }
        labels.put(type.getName(), l);
    }
    for (Account.Id accountId : allUsers) {
        Map<String, ApprovalInfo> byLabel = Maps.newHashMapWithExpectedSize(labels.size());
        if (detailed) {
            for (Map.Entry<String, LabelWithStatus> entry : labels.entrySet()) {
                ApprovalInfo ai = approvalInfo(accountId, 0, null);
                byLabel.put(entry.getKey(), ai);
                addApproval(entry.getValue().label(), ai);
            }
        }
        for (PatchSetApproval psa : current.get(accountId)) {
            LabelType type = labelTypes.byLabel(psa.getLabelId());
            if (type == null) {
                continue;
            }
            short val = psa.getValue();
            ApprovalInfo info = byLabel.get(type.getName());
            if (info != null) {
                info.value = Integer.valueOf(val);
                info.date = psa.getGranted();
            }
            if (!standard) {
                continue;
            }
            setLabelScores(type, labels.get(type.getName()), val, accountId);
        }
    }
    return labels;
}
#method_after
private Map<String, LabelWithStatus> labelsForClosedChange(ChangeData cd, LabelTypes labelTypes, boolean standard, boolean detailed) throws OrmException {
    Set<Account.Id> allUsers = new HashSet<>();
    if (detailed) {
        // the latest patch set (in the next loop).
        for (PatchSetApproval psa : cd.approvals().values()) {
            allUsers.add(psa.getAccountId());
        }
    }
    // We can only approximately reconstruct what the submit rule evaluator
    // would have done. These should really come from a stored submit record.
    Set<String> labelNames = new HashSet<>();
    Multimap<Account.Id, PatchSetApproval> current = HashMultimap.create();
    for (PatchSetApproval a : cd.currentApprovals()) {
        allUsers.add(a.getAccountId());
        LabelType type = labelTypes.byLabel(a.getLabelId());
        if (type != null) {
            labelNames.add(type.getName());
            // Not worth the effort to distinguish between votable/non-votable for 0
            // values on closed changes, since they can't vote anyway.
            current.put(a.getAccountId(), a);
        }
    }
    // Don't use Maps.newTreeMap(Comparator) due to OpenJDK bug 100167.
    Map<String, LabelWithStatus> labels = new TreeMap<>(labelTypes.nameComparator());
    for (String name : labelNames) {
        LabelType type = labelTypes.byLabel(name);
        LabelWithStatus l = LabelWithStatus.create(new LabelInfo(), null);
        if (detailed) {
            setLabelValues(type, l);
        }
        labels.put(type.getName(), l);
    }
    for (Account.Id accountId : allUsers) {
        Map<String, ApprovalInfo> byLabel = Maps.newHashMapWithExpectedSize(labels.size());
        if (detailed) {
            for (Map.Entry<String, LabelWithStatus> entry : labels.entrySet()) {
                ApprovalInfo ai = approvalInfo(accountId, 0, null, null);
                byLabel.put(entry.getKey(), ai);
                addApproval(entry.getValue().label(), ai);
            }
        }
        for (PatchSetApproval psa : current.get(accountId)) {
            LabelType type = labelTypes.byLabel(psa.getLabelId());
            if (type == null) {
                continue;
            }
            short val = psa.getValue();
            ApprovalInfo info = byLabel.get(type.getName());
            if (info != null) {
                info.value = Integer.valueOf(val);
                info.date = psa.getGranted();
                info.tag = psa.getTag();
            }
            if (!standard) {
                continue;
            }
            setLabelScores(type, labels.get(type.getName()), val, accountId);
        }
    }
    return labels;
}
#end_block

#method_before
private ApprovalInfo approvalInfo(Account.Id id, Integer value, Timestamp date) {
    ApprovalInfo ai = new ApprovalInfo(id.get());
    ai.value = value;
    ai.date = date;
    accountLoader.put(ai);
    return ai;
}
#method_after
private ApprovalInfo approvalInfo(Account.Id id, Integer value, String tag, Timestamp date) {
    ApprovalInfo ai = getApprovalInfo(id, value, tag, date);
    accountLoader.put(ai);
    return ai;
}
#end_block

#method_before
private void setLabelValues(LabelType type, LabelWithStatus l) {
    l.label().defaultValue = type.getDefaultValue();
    l.label().values = Maps.newLinkedHashMap();
    for (LabelValue v : type.getValues()) {
        l.label().values.put(v.formatValue(), v.getText());
    }
    if (isOnlyZero(l.label().values.keySet())) {
        l.label().values = null;
    }
}
#method_after
private void setLabelValues(LabelType type, LabelWithStatus l) {
    l.label().defaultValue = type.getDefaultValue();
    l.label().values = new LinkedHashMap<>();
    for (LabelValue v : type.getValues()) {
        l.label().values.put(v.formatValue(), v.getText());
    }
    if (isOnlyZero(l.label().values.keySet())) {
        l.label().values = null;
    }
}
#end_block

#method_before
private Collection<ChangeMessageInfo> messages(ChangeControl ctl, ChangeData cd, Map<PatchSet.Id, PatchSet> map) throws OrmException {
    List<ChangeMessage> messages = cmUtil.byChange(db.get(), cd.notes());
    if (messages.isEmpty()) {
        return Collections.emptyList();
    }
    List<ChangeMessageInfo> result = Lists.newArrayListWithCapacity(messages.size());
    for (ChangeMessage message : messages) {
        PatchSet.Id patchNum = message.getPatchSetId();
        PatchSet ps = patchNum != null ? map.get(patchNum) : null;
        if (patchNum == null || ctl.isPatchVisible(ps, db.get())) {
            ChangeMessageInfo cmi = new ChangeMessageInfo();
            cmi.id = message.getKey().get();
            cmi.author = accountLoader.get(message.getAuthor());
            cmi.date = message.getWrittenOn();
            cmi.message = message.getMessage();
            cmi._revisionNumber = patchNum != null ? patchNum.get() : null;
            result.add(cmi);
        }
    }
    return result;
}
#method_after
private Collection<ChangeMessageInfo> messages(ChangeControl ctl, ChangeData cd, Map<PatchSet.Id, PatchSet> map) throws OrmException {
    List<ChangeMessage> messages = cmUtil.byChange(db.get(), cd.notes());
    if (messages.isEmpty()) {
        return Collections.emptyList();
    }
    List<ChangeMessageInfo> result = Lists.newArrayListWithCapacity(messages.size());
    for (ChangeMessage message : messages) {
        PatchSet.Id patchNum = message.getPatchSetId();
        PatchSet ps = patchNum != null ? map.get(patchNum) : null;
        if (patchNum == null || ctl.isPatchVisible(ps, db.get())) {
            ChangeMessageInfo cmi = new ChangeMessageInfo();
            cmi.id = message.getKey().get();
            cmi.author = accountLoader.get(message.getAuthor());
            cmi.date = message.getWrittenOn();
            cmi.message = message.getMessage();
            cmi.tag = message.getTag();
            cmi._revisionNumber = patchNum != null ? patchNum.get() : null;
            result.add(cmi);
        }
    }
    return result;
}
#end_block

#method_before
private Map<String, RevisionInfo> revisions(ChangeControl ctl, Map<PatchSet.Id, PatchSet> map) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    Map<String, RevisionInfo> res = Maps.newLinkedHashMap();
    for (PatchSet in : map.values()) {
        if ((has(ALL_REVISIONS) || in.getId().equals(ctl.getChange().currentPatchSetId())) && ctl.isPatchVisible(in, db.get())) {
            res.put(in.getRevision().get(), toRevisionInfo(ctl, in));
        }
    }
    return res;
}
#method_after
private Map<String, RevisionInfo> revisions(ChangeControl ctl, Map<PatchSet.Id, PatchSet> map) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    Map<String, RevisionInfo> res = new LinkedHashMap<>();
    for (PatchSet in : map.values()) {
        if ((has(ALL_REVISIONS) || in.getId().equals(ctl.getChange().currentPatchSetId())) && ctl.isPatchVisible(in, db.get())) {
            res.put(in.getRevision().get(), toRevisionInfo(ctl, in));
        }
    }
    return res;
}
#end_block

#method_before
public RevisionInfo toRevisionInfo(ChangeControl ctl, PatchSet in) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    Change c = ctl.getChange();
    RevisionInfo out = new RevisionInfo();
    out.isCurrent = in.getId().equals(c.currentPatchSetId());
    out._number = in.getId().get();
    out.ref = in.getRefName();
    out.created = in.getCreatedOn();
    out.uploader = accountLoader.get(in.getUploader());
    out.draft = in.isDraft() ? true : null;
    out.fetch = makeFetchMap(ctl, in);
    boolean setCommit = has(ALL_COMMITS) || (out.isCurrent && has(CURRENT_COMMIT));
    boolean addFooters = out.isCurrent && has(COMMIT_FOOTERS);
    if (setCommit || addFooters) {
        Project.NameKey project = c.getProject();
        try (Repository repo = repoManager.openRepository(project);
            RevWalk rw = new RevWalk(repo)) {
            String rev = in.getRevision().get();
            RevCommit commit = rw.parseCommit(ObjectId.fromString(rev));
            rw.parseBody(commit);
            if (setCommit) {
                out.commit = toCommit(ctl, rw, commit, has(WEB_LINKS));
            }
            if (addFooters) {
                out.commitWithFooters = mergeUtilFactory.create(projectCache.get(project)).createCherryPickCommitMessage(commit, ctl, in.getId());
            }
        }
    }
    if (has(ALL_FILES) || (out.isCurrent && has(CURRENT_FILES))) {
        out.files = fileInfoJson.toFileInfoMap(c, in);
        out.files.remove(Patch.COMMIT_MSG);
    }
    if ((out.isCurrent || (out.draft != null && out.draft)) && has(CURRENT_ACTIONS) && userProvider.get().isIdentifiedUser()) {
        actionJson.addRevisionActions(out, new RevisionResource(new ChangeResource(ctl), in));
    }
    if (has(PUSH_CERTIFICATES)) {
        if (in.getPushCertificate() != null) {
            out.pushCertificate = gpgApi.checkPushCertificate(in.getPushCertificate(), userFactory.create(db, in.getUploader()));
        } else {
            out.pushCertificate = new PushCertificateInfo();
        }
    }
    return out;
}
#method_after
private RevisionInfo toRevisionInfo(ChangeControl ctl, PatchSet in) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    Change c = ctl.getChange();
    RevisionInfo out = new RevisionInfo();
    out.isCurrent = in.getId().equals(c.currentPatchSetId());
    out._number = in.getId().get();
    out.ref = in.getRefName();
    out.created = in.getCreatedOn();
    out.uploader = accountLoader.get(in.getUploader());
    out.draft = in.isDraft() ? true : null;
    out.fetch = makeFetchMap(ctl, in);
    boolean setCommit = has(ALL_COMMITS) || (out.isCurrent && has(CURRENT_COMMIT));
    boolean addFooters = out.isCurrent && has(COMMIT_FOOTERS);
    if (setCommit || addFooters) {
        Project.NameKey project = c.getProject();
        try (Repository repo = repoManager.openRepository(project);
            RevWalk rw = new RevWalk(repo)) {
            String rev = in.getRevision().get();
            RevCommit commit = rw.parseCommit(ObjectId.fromString(rev));
            rw.parseBody(commit);
            if (setCommit) {
                out.commit = toCommit(ctl, rw, commit, has(WEB_LINKS));
            }
            if (addFooters) {
                out.commitWithFooters = mergeUtilFactory.create(projectCache.get(project)).createCherryPickCommitMessage(commit, ctl, in.getId());
            }
        }
    }
    if (has(ALL_FILES) || (out.isCurrent && has(CURRENT_FILES))) {
        out.files = fileInfoJson.toFileInfoMap(c, in);
        out.files.remove(Patch.COMMIT_MSG);
    }
    if ((out.isCurrent || (out.draft != null && out.draft)) && has(CURRENT_ACTIONS) && userProvider.get().isIdentifiedUser()) {
        actionJson.addRevisionActions(out, new RevisionResource(changeResourceFactory.create(ctl), in));
    }
    if (has(PUSH_CERTIFICATES)) {
        if (in.getPushCertificate() != null) {
            out.pushCertificate = gpgApi.checkPushCertificate(in.getPushCertificate(), userFactory.create(in.getUploader()));
        } else {
            out.pushCertificate = new PushCertificateInfo();
        }
    }
    return out;
}
#end_block

#method_before
CommitInfo toCommit(ChangeControl ctl, RevWalk rw, RevCommit commit, boolean addLinks) throws IOException {
    Project.NameKey project = ctl.getChange().getProject();
    CommitInfo info = new CommitInfo();
    info.parents = new ArrayList<>(commit.getParentCount());
    info.author = toGitPerson(commit.getAuthorIdent());
    info.committer = toGitPerson(commit.getCommitterIdent());
    info.subject = commit.getShortMessage();
    info.message = commit.getFullMessage();
    if (addLinks) {
        FluentIterable<WebLinkInfo> links = webLinks.getPatchSetLinks(project, commit.name());
        info.webLinks = links.isEmpty() ? null : links.toList();
    }
    for (RevCommit parent : commit.getParents()) {
        rw.parseBody(parent);
        CommitInfo i = new CommitInfo();
        i.commit = parent.name();
        i.subject = parent.getShortMessage();
        if (addLinks) {
            FluentIterable<WebLinkInfo> parentLinks = webLinks.getPatchSetLinks(project, parent.name());
            i.webLinks = parentLinks.isEmpty() ? null : parentLinks.toList();
        }
        info.parents.add(i);
    }
    return info;
}
#method_after
CommitInfo toCommit(ChangeControl ctl, RevWalk rw, RevCommit commit, boolean addLinks) throws IOException {
    Project.NameKey project = ctl.getProject().getNameKey();
    CommitInfo info = new CommitInfo();
    info.parents = new ArrayList<>(commit.getParentCount());
    info.author = toGitPerson(commit.getAuthorIdent());
    info.committer = toGitPerson(commit.getCommitterIdent());
    info.subject = commit.getShortMessage();
    info.message = commit.getFullMessage();
    if (addLinks) {
        FluentIterable<WebLinkInfo> links = webLinks.getPatchSetLinks(project, commit.name());
        info.webLinks = links.isEmpty() ? null : links.toList();
    }
    for (RevCommit parent : commit.getParents()) {
        rw.parseBody(parent);
        CommitInfo i = new CommitInfo();
        i.commit = parent.name();
        i.subject = parent.getShortMessage();
        info.parents.add(i);
    }
    return info;
}
#end_block

#method_before
private Map<String, FetchInfo> makeFetchMap(ChangeControl ctl, PatchSet in) throws OrmException {
    Map<String, FetchInfo> r = Maps.newLinkedHashMap();
    for (DynamicMap.Entry<DownloadScheme> e : downloadSchemes) {
        String schemeName = e.getExportName();
        DownloadScheme scheme = e.getProvider().get();
        if (!scheme.isEnabled() || (scheme.isAuthRequired() && !userProvider.get().isIdentifiedUser())) {
            continue;
        }
        if (!scheme.isAuthSupported() && !ctl.forUser(anonymous).isPatchVisible(in, db.get())) {
            continue;
        }
        String projectName = ctl.getProject().getNameKey().get();
        String url = scheme.getUrl(projectName);
        String refName = in.getRefName();
        FetchInfo fetchInfo = new FetchInfo(url, refName);
        r.put(schemeName, fetchInfo);
        if (has(DOWNLOAD_COMMANDS)) {
            populateFetchMap(scheme, downloadCommands, projectName, refName, fetchInfo);
        }
    }
    return r;
}
#method_after
private Map<String, FetchInfo> makeFetchMap(ChangeControl ctl, PatchSet in) throws OrmException {
    Map<String, FetchInfo> r = new LinkedHashMap<>();
    for (DynamicMap.Entry<DownloadScheme> e : downloadSchemes) {
        String schemeName = e.getExportName();
        DownloadScheme scheme = e.getProvider().get();
        if (!scheme.isEnabled() || (scheme.isAuthRequired() && !userProvider.get().isIdentifiedUser())) {
            continue;
        }
        if (!scheme.isAuthSupported() && !ctl.forUser(anonymous).isPatchVisible(in, db.get())) {
            continue;
        }
        String projectName = ctl.getProject().getNameKey().get();
        String url = scheme.getUrl(projectName);
        String refName = in.getRefName();
        FetchInfo fetchInfo = new FetchInfo(url, refName);
        r.put(schemeName, fetchInfo);
        if (has(DOWNLOAD_COMMANDS)) {
            populateFetchMap(scheme, downloadCommands, projectName, refName, fetchInfo);
        }
    }
    return r;
}
#end_block

#method_before
private static void addCommand(FetchInfo fetchInfo, String commandName, String c) {
    if (fetchInfo.commands == null) {
        fetchInfo.commands = Maps.newTreeMap();
    }
    fetchInfo.commands.put(commandName, c);
}
#method_after
private static void addCommand(FetchInfo fetchInfo, String commandName, String c) {
    if (fetchInfo.commands == null) {
        fetchInfo.commands = new TreeMap<>();
    }
    fetchInfo.commands.put(commandName, c);
}
#end_block

#method_before
private static void addApproval(LabelInfo label, ApprovalInfo approval) {
    if (label.all == null) {
        label.all = Lists.newArrayList();
    }
    label.all.add(approval);
}
#method_after
private static void addApproval(LabelInfo label, ApprovalInfo approval) {
    if (label.all == null) {
        label.all = new ArrayList<>();
    }
    label.all.add(approval);
}
#end_block

#method_before
@Override
public ChangeInfo apply(ChangeResource req, final AbandonInput input) throws RestApiException, UpdateException, OrmException {
    ChangeControl control = req.getControl();
    IdentifiedUser caller = control.getUser().asIdentifiedUser();
    if (!control.canAbandon()) {
        throw new AuthException("abandon not permitted");
    }
    Change change = abandon(control, input.message, caller.getAccount());
    return json.create(ChangeJson.NO_OPTIONS).format(change);
}
#method_after
@Override
public ChangeInfo apply(ChangeResource req, AbandonInput input) throws RestApiException, UpdateException, OrmException {
    ChangeControl control = req.getControl();
    if (!control.canAbandon(dbProvider.get())) {
        throw new AuthException("abandon not permitted");
    }
    Change change = abandon(control, input.message);
    return json.create(ChangeJson.NO_OPTIONS).format(change);
}
#end_block

#method_before
public Change abandon(ChangeControl control, final String msgTxt, final Account account) throws RestApiException, UpdateException {
    Op op = new Op(msgTxt, account);
    Change c = control.getChange();
    try (BatchUpdate u = batchUpdateFactory.create(dbProvider.get(), c.getProject(), control.getUser(), TimeUtil.nowTs())) {
        u.addOp(c.getId(), op).execute();
    }
    return op.change;
}
#method_after
public Change abandon(ChangeControl control, String msgTxt) throws RestApiException, UpdateException {
    CurrentUser user = control.getUser();
    Account account = user.isIdentifiedUser() ? user.asIdentifiedUser().getAccount() : null;
    Op op = new Op(msgTxt, account);
    try (BatchUpdate u = batchUpdateFactory.create(dbProvider.get(), control.getProject().getNameKey(), user, TimeUtil.nowTs())) {
        u.addOp(control.getId(), op).execute();
    }
    return op.change;
}
#end_block

#method_before
@Override
public void updateChange(ChangeContext ctx) throws OrmException, ResourceConflictException {
    change = ctx.getChange();
    if (change == null || !change.getStatus().isOpen()) {
        throw new ResourceConflictException("change is " + status(change));
    } else if (change.getStatus() == Change.Status.DRAFT) {
        throw new ResourceConflictException("draft changes cannot be abandoned");
    }
    patchSet = ctx.getDb().patchSets().get(change.currentPatchSetId());
    change.setStatus(Change.Status.ABANDONED);
    change.setLastUpdatedOn(ctx.getWhen());
    ctx.getDb().changes().update(Collections.singleton(change));
    message = newMessage(ctx.getDb());
    cmUtil.addChangeMessage(ctx.getDb(), ctx.getChangeUpdate(), message);
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, ResourceConflictException {
    change = ctx.getChange();
    PatchSet.Id psId = change.currentPatchSetId();
    ChangeUpdate update = ctx.getUpdate(psId);
    if (!change.getStatus().isOpen()) {
        throw new ResourceConflictException("change is " + status(change));
    } else if (change.getStatus() == Change.Status.DRAFT) {
        throw new ResourceConflictException("draft changes cannot be abandoned");
    }
    patchSet = psUtil.get(ctx.getDb(), ctx.getNotes(), psId);
    change.setStatus(Change.Status.ABANDONED);
    change.setLastUpdatedOn(ctx.getWhen());
    update.setStatus(change.getStatus());
    message = newMessage(ctx);
    cmUtil.addChangeMessage(ctx.getDb(), update, message);
    return true;
}
#end_block

#method_before
private ChangeMessage newMessage(ReviewDb db) throws OrmException {
    StringBuilder msg = new StringBuilder();
    msg.append("Abandoned");
    if (!Strings.nullToEmpty(msgTxt).trim().isEmpty()) {
        msg.append("\n\n");
        msg.append(msgTxt.trim());
    }
    ChangeMessage message = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), account != null ? account.getId() : null, change.getLastUpdatedOn(), change.currentPatchSetId());
    message.setMessage(msg.toString());
    return message;
}
#method_after
private ChangeMessage newMessage(ChangeContext ctx) throws OrmException {
    StringBuilder msg = new StringBuilder();
    msg.append("Abandoned");
    if (!Strings.nullToEmpty(msgTxt).trim().isEmpty()) {
        msg.append("\n\n");
        msg.append(msgTxt.trim());
    }
    ChangeMessage message = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(ctx.getDb())), account != null ? account.getId() : null, ctx.getWhen(), change.currentPatchSetId());
    message.setMessage(msg.toString());
    return message;
}
#end_block

#method_before
@Override
public void postUpdate(Context ctx) throws OrmException {
    try {
        ReplyToChangeSender cm = abandonedSenderFactory.create(change.getId());
        if (account != null) {
            cm.setFrom(account.getId());
        }
        cm.setChangeMessage(message);
        cm.send();
    } catch (Exception e) {
        log.error("Cannot email update for change " + change.getId(), e);
    }
    try {
        changeAbandoned.fire(change, patchSet, account, msgTxt);
    } catch (PatchListNotAvailableException | GpgException | IOException e) {
        throw new OrmException(e);
    }
    hooks.doChangeAbandonedHook(change, account, patchSet, Strings.emptyToNull(msgTxt), ctx.getDb());
}
#method_after
@Override
public void postUpdate(Context ctx) throws OrmException {
    try {
        ReplyToChangeSender cm = abandonedSenderFactory.create(ctx.getProject(), change.getId());
        if (account != null) {
            cm.setFrom(account.getId());
        }
        cm.setChangeMessage(message);
        cm.send();
    } catch (Exception e) {
        log.error("Cannot email update for change " + change.getId(), e);
    }
    changeAbandoned.fire(change, patchSet, account, msgTxt);
    hooks.doChangeAbandonedHook(change, account, patchSet, Strings.emptyToNull(msgTxt), ctx.getDb());
}
#end_block

#method_before
@Override
public UiAction.Description getDescription(ChangeResource resource) {
    return new UiAction.Description().setLabel("Abandon").setTitle("Abandon the change").setVisible(resource.getChange().getStatus().isOpen() && resource.getChange().getStatus() != Change.Status.DRAFT && resource.getControl().canAbandon());
}
#method_after
@Override
public UiAction.Description getDescription(ChangeResource resource) {
    boolean canAbandon = false;
    try {
        canAbandon = resource.getControl().canAbandon(dbProvider.get());
    } catch (OrmException e) {
        log.error("Cannot check canAbandon status. Assuming false.", e);
    }
    return new UiAction.Description().setLabel("Abandon").setTitle("Abandon the change").setVisible(resource.getChange().getStatus().isOpen() && resource.getChange().getStatus() != Change.Status.DRAFT && canAbandon);
}
#end_block

#method_before
public void fire(ChangeInfo change, RevisionInfo revision, AccountInfo abandoner, String reason) {
    Event e = new Event(change, revision, abandoner, reason);
    for (ChangeAbandonedListener l : listeners) {
        l.onChangeAbandoned(e);
    }
}
#method_after
public void fire(ChangeInfo change, RevisionInfo revision, AccountInfo abandoner, String reason) {
    if (!listeners.iterator().hasNext()) {
        return;
    }
    Event e = new Event(change, revision, abandoner, reason);
    for (ChangeAbandonedListener l : listeners) {
        l.onChangeAbandoned(e);
    }
}
#end_block

#method_before
public void fire(Change change, PatchSet ps, Account abandoner, String reason) throws OrmException, PatchListNotAvailableException, GpgException, IOException {
    ChangeJson changeJson = changeJsonFactory.create(ChangeJson.NO_OPTIONS);
    ChangeInfo changeInfo = changeJson.format(change);
    ChangeData cd = changeDataFactory.create(db.get(), change);
    ChangeControl ctl = cd.changeControl();
    RevisionInfo revisionInfo = changeJson.toRevisionInfo(ctl, ps);
    AccountInfo ai = new AccountInfo(abandoner.getId().get());
    ai.email = abandoner.getPreferredEmail();
    ai.name = abandoner.getFullName();
    ai.username = abandoner.getUserName();
    fire(changeInfo, revisionInfo, ai, reason);
}
#method_after
public void fire(Change change, PatchSet ps, Account abandoner, String reason) {
    if (!listeners.iterator().hasNext()) {
        return;
    }
    try {
        fire(util.changeInfo(change), util.revisionInfo(change.getProject(), ps), util.accountInfo(abandoner), reason);
    } catch (PatchListNotAvailableException | GpgException | IOException | OrmException e) {
        log.error("Couldn't fire event", e);
    }
}
#end_block

#method_before
@Test
public void addReviewer() throws Exception {
    TestTimeUtil.resetWithClockStep(1, SECONDS);
    PushOneCommit.Result r = createChange();
    ChangeResource rsrc = parseResource(r);
    String oldETag = rsrc.getETag();
    Timestamp oldTs = rsrc.getChange().getLastUpdatedOn();
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    gApi.changes().id(r.getChangeId()).addReviewer(in);
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(user.emailAddress);
    assertThat(m.body()).contains("Hello " + user.fullName + ",\n");
    assertThat(m.body()).contains("I'd like you to do a code review.");
    assertThat(m.body()).contains("Change subject: " + PushOneCommit.SUBJECT + "\n");
    ChangeInfo c = gApi.changes().id(r.getChangeId()).get();
    // When NoteDb is enabled adding a reviewer records that user as reviewer
    // in NoteDb. When NoteDb is disabled adding a reviewer results in a dummy 0
    // approval on the change which is treated as CC when the ChangeInfo is
    // created.
    Collection<AccountInfo> reviewers = NoteDbMode.readWrite() ? c.reviewers.get(REVIEWER) : c.reviewers.get(CC);
    assertThat(reviewers).isNotNull();
    assertThat(reviewers).hasSize(1);
    assertThat(reviewers.iterator().next()._accountId).isEqualTo(user.getId().get());
    // Ensure ETag and lastUpdatedOn are updated.
    rsrc = parseResource(r);
    assertThat(rsrc.getETag()).isNotEqualTo(oldETag);
    assertThat(rsrc.getChange().getLastUpdatedOn()).isNotEqualTo(oldTs);
}
#method_after
@Test
public void addReviewer() throws Exception {
    TestTimeUtil.resetWithClockStep(1, SECONDS);
    sender.clear();
    PushOneCommit.Result r = createChange();
    ChangeResource rsrc = parseResource(r);
    String oldETag = rsrc.getETag();
    Timestamp oldTs = rsrc.getChange().getLastUpdatedOn();
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    gApi.changes().id(r.getChangeId()).addReviewer(in);
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(user.emailAddress);
    assertThat(m.body()).contains("Hello " + user.fullName + ",\n");
    assertThat(m.body()).contains("I'd like you to do a code review.");
    assertThat(m.body()).contains("Change subject: " + PushOneCommit.SUBJECT + "\n");
    ChangeInfo c = gApi.changes().id(r.getChangeId()).get();
    // When NoteDb is enabled adding a reviewer records that user as reviewer
    // in NoteDb. When NoteDb is disabled adding a reviewer results in a dummy 0
    // approval on the change which is treated as CC when the ChangeInfo is
    // created.
    Collection<AccountInfo> reviewers = NoteDbMode.readWrite() ? c.reviewers.get(REVIEWER) : c.reviewers.get(CC);
    assertThat(reviewers).isNotNull();
    assertThat(reviewers).hasSize(1);
    assertThat(reviewers.iterator().next()._accountId).isEqualTo(user.getId().get());
    // Ensure ETag and lastUpdatedOn are updated.
    rsrc = parseResource(r);
    assertThat(rsrc.getETag()).isNotEqualTo(oldETag);
    assertThat(rsrc.getChange().getLastUpdatedOn()).isNotEqualTo(oldTs);
}
#end_block

#method_before
@Override
public void postUpdate(Context ctx) {
    if (changeMessage == null) {
        return;
    }
    IdentifiedUser user = ctx.getUser().asIdentifiedUser();
    if (input.notify.compareTo(NotifyHandling.NONE) > 0) {
        try {
            ReplyToChangeSender cm = deleteVoteSenderFactory.create(ctx.getProject(), change.getId());
            cm.setFrom(user.getAccountId());
            cm.setChangeMessage(changeMessage);
            cm.setNotify(input.notify);
            cm.send();
        } catch (Exception e) {
            log.error("Cannot email update for change " + change.getId(), e);
        }
    }
    try {
        hooks.doCommentAddedHook(change, user.getAccount(), ps, changeMessage.getMessage(), newApprovals, oldApprovals, ctx.getDb());
    } catch (OrmException e) {
        log.warn("ChangeHook.doCommentAddedHook delivery failed", e);
    }
}
#method_after
@Override
public void postUpdate(Context ctx) {
    if (changeMessage == null) {
        return;
    }
    IdentifiedUser user = ctx.getUser().asIdentifiedUser();
    if (input.notify.compareTo(NotifyHandling.NONE) > 0) {
        try {
            ReplyToChangeSender cm = deleteVoteSenderFactory.create(ctx.getProject(), change.getId());
            cm.setFrom(user.getAccountId());
            cm.setChangeMessage(changeMessage);
            cm.setNotify(input.notify);
            cm.send();
        } catch (Exception e) {
            log.error("Cannot email update for change " + change.getId(), e);
        }
    }
    try {
        hooks.doCommentAddedHook(change, user.getAccount(), ps, changeMessage.getMessage(), newApprovals, oldApprovals, ctx.getDb());
    } catch (OrmException e) {
        log.warn("ChangeHook.doCommentAddedHook invocation failed", e);
    }
}
#end_block

#method_before
@Override
public void cancel() {
    repLog.info("Replication {} was cancelled", getURI());
    cancelledByReplication();
    pool.pushWasCancelled(this);
}
#method_after
@Override
public void cancel() {
    repLog.info("Replication {} was canceled", getURI());
    canceledByReplication();
    pool.pushWasCanceled(this);
}
#end_block

#method_before
private void runPushOperation() {
    // Lock the queue, and remove ourselves, so we can't be modified once
    // we start replication (instead a new instance, with the same URI, is
    // created and scheduled for a future point in time.)
    // 
    MDC.put(ID_MDC_KEY, IdGenerator.format(id));
    if (!pool.requestRunway(this)) {
        if (!cancelled) {
            repLog.info("Rescheduling replication to " + uri + " to avoid collision with an in-flight push.");
            pool.reschedule(this, Destination.RetryReason.COLLISION);
        }
        return;
    }
    repLog.info("Replication to " + uri + " started...");
    Timer1.Context context = metrics.start(config.getName());
    try {
        long startedAt = context.getStartTime();
        long delay = NANOSECONDS.toMillis(startedAt - createdAt);
        metrics.record(config.getName(), delay, retryCount);
        git = gitManager.openRepository(projectName);
        runImpl();
        long elapsed = NANOSECONDS.toMillis(context.stop());
        repLog.info("Replication to " + uri + " completed in " + (elapsed) + "ms, " + (delay) + "ms delay, " + retryCount + " retries");
    } catch (RepositoryNotFoundException e) {
        stateLog.error("Cannot replicate " + projectName + "; Local repository error: " + e.getMessage(), getStatesAsArray());
    } catch (RemoteRepositoryException e) {
        // Tried to replicate to a remote via anonymous git:// but the repository
        // does not exist.  In this case NoRemoteRepositoryException is not
        // raised.
        String msg = e.getMessage();
        if (msg.contains("access denied") || msg.contains("no such repository")) {
            createRepository();
        } else {
            repLog.error("Cannot replicate " + projectName + "; Remote repository error: " + msg);
        }
    } catch (NoRemoteRepositoryException e) {
        createRepository();
    } catch (NotSupportedException e) {
        stateLog.error("Cannot replicate to " + uri, e, getStatesAsArray());
    } catch (TransportException e) {
        Throwable cause = e.getCause();
        if (cause instanceof JSchException && cause.getMessage().startsWith("UnknownHostKey:")) {
            repLog.error("Cannot replicate to " + uri + ": " + cause.getMessage());
        } else if (e instanceof LockFailureException) {
            lockRetryCount++;
            // The LockFailureException message contains both URI and reason
            // for this failure.
            repLog.error("Cannot replicate to " + e.getMessage());
            // The remote push operation should be retried.
            if (lockRetryCount <= maxLockRetries) {
                if (canceledWhileRunning.get()) {
                    logCanceledWhileRunningException(e);
                } else {
                    pool.reschedule(this, Destination.RetryReason.TRANSPORT_ERROR);
                }
            } else {
                repLog.error("Giving up after " + lockRetryCount + " of this error during replication to " + e.getMessage());
            }
        } else {
            if (canceledWhileRunning.get()) {
                logCanceledWhileRunningException(e);
            } else {
                repLog.error("Cannot replicate to " + uri, e);
                // The remote push operation should be retried.
                pool.reschedule(this, Destination.RetryReason.TRANSPORT_ERROR);
            }
        }
    } catch (IOException e) {
        stateLog.error("Cannot replicate to " + uri, e, getStatesAsArray());
    } catch (RuntimeException | Error e) {
        stateLog.error("Unexpected error during replication to " + uri, e, getStatesAsArray());
    } finally {
        if (git != null) {
            git.close();
        }
        pool.notifyFinished(this);
    }
}
#method_after
private void runPushOperation() {
    // Lock the queue, and remove ourselves, so we can't be modified once
    // we start replication (instead a new instance, with the same URI, is
    // created and scheduled for a future point in time.)
    // 
    MDC.put(ID_MDC_KEY, IdGenerator.format(id));
    if (!pool.requestRunway(this)) {
        if (!canceled) {
            repLog.info("Rescheduling replication to " + uri + " to avoid collision with an in-flight push.");
            pool.reschedule(this, Destination.RetryReason.COLLISION);
        }
        return;
    }
    repLog.info("Replication to " + uri + " started...");
    Timer1.Context context = metrics.start(config.getName());
    try {
        long startedAt = context.getStartTime();
        long delay = NANOSECONDS.toMillis(startedAt - createdAt);
        metrics.record(config.getName(), delay, retryCount);
        git = gitManager.openRepository(projectName);
        runImpl();
        long elapsed = NANOSECONDS.toMillis(context.stop());
        repLog.info("Replication to " + uri + " completed in " + (elapsed) + "ms, " + (delay) + "ms delay, " + retryCount + " retries");
    } catch (RepositoryNotFoundException e) {
        stateLog.error("Cannot replicate " + projectName + "; Local repository error: " + e.getMessage(), getStatesAsArray());
    } catch (RemoteRepositoryException e) {
        // Tried to replicate to a remote via anonymous git:// but the repository
        // does not exist.  In this case NoRemoteRepositoryException is not
        // raised.
        String msg = e.getMessage();
        if (msg.contains("access denied") || msg.contains("no such repository")) {
            createRepository();
        } else {
            repLog.error("Cannot replicate " + projectName + "; Remote repository error: " + msg);
        }
    } catch (NoRemoteRepositoryException e) {
        createRepository();
    } catch (NotSupportedException e) {
        stateLog.error("Cannot replicate to " + uri, e, getStatesAsArray());
    } catch (TransportException e) {
        Throwable cause = e.getCause();
        if (cause instanceof JSchException && cause.getMessage().startsWith("UnknownHostKey:")) {
            repLog.error("Cannot replicate to " + uri + ": " + cause.getMessage());
        } else if (e instanceof LockFailureException) {
            lockRetryCount++;
            // The LockFailureException message contains both URI and reason
            // for this failure.
            repLog.error("Cannot replicate to " + e.getMessage());
            // The remote push operation should be retried.
            if (lockRetryCount <= maxLockRetries) {
                if (canceledWhileRunning.get()) {
                    logCanceledWhileRunningException(e);
                } else {
                    pool.reschedule(this, Destination.RetryReason.TRANSPORT_ERROR);
                }
            } else {
                repLog.error("Giving up after " + lockRetryCount + " of this error during replication to " + e.getMessage());
            }
        } else {
            if (canceledWhileRunning.get()) {
                logCanceledWhileRunningException(e);
            } else {
                repLog.error("Cannot replicate to " + uri, e);
                // The remote push operation should be retried.
                pool.reschedule(this, Destination.RetryReason.TRANSPORT_ERROR);
            }
        }
    } catch (IOException e) {
        stateLog.error("Cannot replicate to " + uri, e, getStatesAsArray());
    } catch (RuntimeException | Error e) {
        stateLog.error("Unexpected error during replication to " + uri, e, getStatesAsArray());
    } finally {
        if (git != null) {
            git.close();
        }
        pool.notifyFinished(this);
    }
}
#end_block

#method_before
private void logCanceledWhileRunningException(TransportException e) {
    repLog.info("Cannot replicate to " + uri + " it was canceled while running", e);
}
#method_after
private void logCanceledWhileRunningException(TransportException e) {
    repLog.info("Cannot replicate to " + uri + "." + " It was canceled while running", e);
}
#end_block

#method_before
private List<RemoteRefUpdate> generateUpdates(Transport tn) throws IOException {
    ProjectControl pc;
    try {
        pc = pool.controlFor(projectName);
    } catch (NoSuchProjectException e) {
        return Collections.emptyList();
    }
    Map<String, Ref> local = git.getAllRefs();
    if (!pc.allRefsAreVisible()) {
        if (!pushAllRefs) {
            // If we aren't mirroring, reduce the space we need to filter
            // to only the references we will update during this operation.
            // 
            Map<String, Ref> n = Maps.newHashMap();
            for (String src : delta) {
                Ref r = local.get(src);
                if (r != null) {
                    n.put(src, r);
                }
            }
            local = n;
        }
        try (ReviewDb db = schema.open()) {
            local = new VisibleRefFilter(tagCache, changeCache, git, pc, db, true).filter(local, true);
        } catch (OrmException e) {
            stateLog.error("Cannot read database to replicate to " + projectName, e, getStatesAsArray());
            return Collections.emptyList();
        }
    }
    return pushAllRefs ? doPushAll(tn, local) : doPushDelta(local);
}
#method_after
private List<RemoteRefUpdate> generateUpdates(Transport tn) throws IOException {
    ProjectControl pc;
    try {
        pc = pool.controlFor(projectName);
    } catch (NoSuchProjectException e) {
        return Collections.emptyList();
    }
    Map<String, Ref> local = git.getAllRefs();
    if (!pc.allRefsAreVisible()) {
        if (!pushAllRefs) {
            // If we aren't mirroring, reduce the space we need to filter
            // to only the references we will update during this operation.
            // 
            Map<String, Ref> n = new HashMap<>();
            for (String src : delta) {
                Ref r = local.get(src);
                if (r != null) {
                    n.put(src, r);
                }
            }
            local = n;
        }
        try (ReviewDb db = schema.open()) {
            local = new VisibleRefFilter(tagCache, changeNotesFactory, changeCache, git, pc, db, true).filter(local, true);
        } catch (OrmException e) {
            stateLog.error("Cannot read database to replicate to " + projectName, e, getStatesAsArray());
            return Collections.emptyList();
        }
    }
    return pushAllRefs ? doPushAll(tn, local) : doPushDelta(local);
}
#end_block

#method_before
private List<RemoteRefUpdate> doPushAll(Transport tn, Map<String, Ref> local) throws NotSupportedException, TransportException, IOException {
    List<RemoteRefUpdate> cmds = Lists.newArrayList();
    boolean noPerms = !pool.isReplicatePermissions();
    Map<String, Ref> remote = listRemote(tn);
    for (Ref src : local.values()) {
        if (!canPushRef(src.getName(), noPerms)) {
            continue;
        }
        RefSpec spec = matchSrc(src.getName());
        if (spec != null) {
            Ref dst = remote.get(spec.getDestination());
            if (dst == null || !src.getObjectId().equals(dst.getObjectId())) {
                // Doesn't exist yet, or isn't the same value, request to push.
                push(cmds, spec, src);
            }
        }
    }
    if (config.isMirror()) {
        for (Ref ref : remote.values()) {
            if (!Constants.HEAD.equals(ref.getName())) {
                RefSpec spec = matchDst(ref.getName());
                if (spec != null && !local.containsKey(spec.getSource())) {
                    // No longer on local side, request removal.
                    delete(cmds, spec);
                }
            }
        }
    }
    return cmds;
}
#method_after
private List<RemoteRefUpdate> doPushAll(Transport tn, Map<String, Ref> local) throws NotSupportedException, TransportException, IOException {
    List<RemoteRefUpdate> cmds = new ArrayList<>();
    boolean noPerms = !pool.isReplicatePermissions();
    Map<String, Ref> remote = listRemote(tn);
    for (Ref src : local.values()) {
        if (!canPushRef(src.getName(), noPerms)) {
            continue;
        }
        RefSpec spec = matchSrc(src.getName());
        if (spec != null) {
            Ref dst = remote.get(spec.getDestination());
            if (dst == null || !src.getObjectId().equals(dst.getObjectId())) {
                // Doesn't exist yet, or isn't the same value, request to push.
                push(cmds, spec, src);
            }
        }
    }
    if (config.isMirror()) {
        for (Ref ref : remote.values()) {
            if (!Constants.HEAD.equals(ref.getName())) {
                RefSpec spec = matchDst(ref.getName());
                if (spec != null && !local.containsKey(spec.getSource())) {
                    // No longer on local side, request removal.
                    delete(cmds, spec);
                }
            }
        }
    }
    return cmds;
}
#end_block

#method_before
private List<RemoteRefUpdate> doPushDelta(Map<String, Ref> local) throws IOException {
    List<RemoteRefUpdate> cmds = Lists.newArrayList();
    boolean noPerms = !pool.isReplicatePermissions();
    for (String src : delta) {
        RefSpec spec = matchSrc(src);
        if (spec != null) {
            // If the ref still exists locally, send it, otherwise delete it.
            Ref srcRef = local.get(src);
            if (srcRef != null && canPushRef(src, noPerms)) {
                push(cmds, spec, srcRef);
            } else if (config.isMirror()) {
                delete(cmds, spec);
            }
        }
    }
    return cmds;
}
#method_after
private List<RemoteRefUpdate> doPushDelta(Map<String, Ref> local) throws IOException {
    List<RemoteRefUpdate> cmds = new ArrayList<>();
    boolean noPerms = !pool.isReplicatePermissions();
    for (String src : delta) {
        RefSpec spec = matchSrc(src);
        if (spec != null) {
            // If the ref still exists locally, send it, otherwise delete it.
            Ref srcRef = local.get(src);
            // Second try to ensure that the ref is truly not found locally
            if (srcRef == null) {
                srcRef = git.exactRef(src);
            }
            if (srcRef != null && canPushRef(src, noPerms)) {
                push(cmds, spec, srcRef);
            } else if (config.isMirror()) {
                delete(cmds, spec);
            }
        }
    }
    return cmds;
}
#end_block

#method_before
void schedule(Project.NameKey project, String ref, URIish uri, ReplicationState state) {
    repLog.info("scheduling replication {}:{} => {}", project, ref, uri);
    if (!isVisible(project, state)) {
        return;
    }
    if (!config.replicatePermissions()) {
        PushOne e;
        synchronized (stateLock) {
            e = pending.get(uri);
        }
        if (e == null) {
            try (Repository git = gitManager.openRepository(project)) {
                try {
                    Ref head = git.exactRef(Constants.HEAD);
                    if (head != null && head.isSymbolic() && RefNames.REFS_CONFIG.equals(head.getLeaf().getName())) {
                        return;
                    }
                } catch (IOException err) {
                    stateLog.error(String.format("cannot check type of project %s", project), err, state);
                    return;
                }
            } catch (IOException err) {
                stateLog.error(String.format("source project %s not available", project), err, state);
                return;
            }
        }
    }
    synchronized (stateLock) {
        PushOne e = pending.get(uri);
        if (e == null) {
            e = opFactory.create(project, uri);
            pool.schedule(e, config.getDelay(), TimeUnit.SECONDS);
            pending.put(uri, e);
        }
        e.addRef(ref);
        state.increasePushTaskCount(project.get(), ref);
        e.addState(ref, state);
        repLog.info("scheduled {}:{} => {} to run after {}s", project, ref, e, config.getDelay());
    }
}
#method_after
void schedule(Project.NameKey project, String ref, URIish uri, ReplicationState state) {
    repLog.info("scheduling replication {}:{} => {}", project, ref, uri);
    if (!shouldReplicate(project, state)) {
        return;
    }
    if (!config.replicatePermissions()) {
        PushOne e;
        synchronized (stateLock) {
            e = pending.get(uri);
        }
        if (e == null) {
            try (Repository git = gitManager.openRepository(project)) {
                try {
                    Ref head = git.exactRef(Constants.HEAD);
                    if (head != null && head.isSymbolic() && RefNames.REFS_CONFIG.equals(head.getLeaf().getName())) {
                        return;
                    }
                } catch (IOException err) {
                    stateLog.error(String.format("cannot check type of project %s", project), err, state);
                    return;
                }
            } catch (IOException err) {
                stateLog.error(String.format("source project %s not available", project), err, state);
                return;
            }
        }
    }
    synchronized (stateLock) {
        PushOne e = pending.get(uri);
        if (e == null) {
            e = opFactory.create(project, uri);
            pool.schedule(e, config.getDelay(), TimeUnit.SECONDS);
            pending.put(uri, e);
        }
        e.addRef(ref);
        state.increasePushTaskCount(project.get(), ref);
        e.addState(ref, state);
        repLog.info("scheduled {}:{} => {} to run after {}s", project, ref, e, config.getDelay());
    }
}
#end_block

#method_before
void reschedule(PushOne pushOp, RetryReason reason) {
    synchronized (stateLock) {
        URIish uri = pushOp.getURI();
        PushOne pendingPushOp = pending.get(uri);
        if (pendingPushOp != null) {
            if (pendingPushOp.isRetrying()) {
                // The one pending is one already retrying, so it should
                // maintain it and add to it the refs of the one passed
                // as parameter to the method.
                // This scenario would happen if a PushOp has started running
                // and then before it failed due transport exception, another
                // one to same URI started. The first one would fail and would
                // be rescheduled, being present in pending list. When the
                // second one fails, it will also be rescheduled and then,
                // here, find out replication to its URI is already pending
                // for retry (blocking).
                pendingPushOp.addRefs(pushOp.getRefs());
                pendingPushOp.addStates(pushOp.getStates());
                pushOp.removeStates();
            } else {
                // The one pending is one that is NOT retrying, it was just
                // scheduled believing no problem would happen. The one pending
                // should be canceled, and this is done by setting its canceled
                // flag, removing it from pending list, and adding its refs to
                // the pushOp instance that should then, later, in this method,
                // be scheduled for retry.
                // Notice that the PushOp found pending will start running and,
                // when notifying it is starting (with pending lock protection),
                // it will see it was canceled and then it will do nothing with
                // pending list and it will not execute its run implementation.
                pendingPushOp.cancelledByReplication();
                pending.remove(uri);
                pushOp.addRefs(pendingPushOp.getRefs());
                pushOp.addStates(pendingPushOp.getStates());
                pendingPushOp.removeStates();
            }
        }
        if (pendingPushOp == null || !pendingPushOp.isRetrying()) {
            pending.put(uri, pushOp);
            switch(reason) {
                case COLLISION:
                    pool.schedule(pushOp, config.getDelay(), TimeUnit.SECONDS);
                    break;
                case TRANSPORT_ERROR:
                case REPOSITORY_MISSING:
                default:
                    pushOp.setToRetry();
                    pool.schedule(pushOp, config.getRetryDelay(), TimeUnit.MINUTES);
                    break;
            }
        }
    }
}
#method_after
void reschedule(PushOne pushOp, RetryReason reason) {
    synchronized (stateLock) {
        URIish uri = pushOp.getURI();
        PushOne pendingPushOp = pending.get(uri);
        if (pendingPushOp != null) {
            if (pendingPushOp.isRetrying()) {
                // The one pending is one already retrying, so it should
                // maintain it and add to it the refs of the one passed
                // as parameter to the method.
                // This scenario would happen if a PushOp has started running
                // and then before it failed due transport exception, another
                // one to same URI started. The first one would fail and would
                // be rescheduled, being present in pending list. When the
                // second one fails, it will also be rescheduled and then,
                // here, find out replication to its URI is already pending
                // for retry (blocking).
                pendingPushOp.addRefs(pushOp.getRefs());
                pendingPushOp.addStates(pushOp.getStates());
                pushOp.removeStates();
            } else {
                // The one pending is one that is NOT retrying, it was just
                // scheduled believing no problem would happen. The one pending
                // should be canceled, and this is done by setting its canceled
                // flag, removing it from pending list, and adding its refs to
                // the pushOp instance that should then, later, in this method,
                // be scheduled for retry.
                // Notice that the PushOp found pending will start running and,
                // when notifying it is starting (with pending lock protection),
                // it will see it was canceled and then it will do nothing with
                // pending list and it will not execute its run implementation.
                pendingPushOp.canceledByReplication();
                pending.remove(uri);
                pushOp.addRefs(pendingPushOp.getRefs());
                pushOp.addStates(pendingPushOp.getStates());
                pendingPushOp.removeStates();
            }
        }
        if (pendingPushOp == null || !pendingPushOp.isRetrying()) {
            pending.put(uri, pushOp);
            switch(reason) {
                case COLLISION:
                    pool.schedule(pushOp, config.getDelay(), TimeUnit.SECONDS);
                    break;
                case TRANSPORT_ERROR:
                case REPOSITORY_MISSING:
                default:
                    pushOp.setToRetry();
                    pool.schedule(pushOp, config.getRetryDelay(), TimeUnit.MINUTES);
                    break;
            }
        }
    }
}
#end_block

#method_before
boolean requestRunway(PushOne op) {
    synchronized (stateLock) {
        if (op.wasCancelled()) {
            return false;
        }
        pending.remove(op.getURI());
        if (inFlight.containsKey(op.getURI())) {
            return false;
        }
        inFlight.put(op.getURI(), op);
    }
    return true;
}
#method_after
boolean requestRunway(PushOne op) {
    synchronized (stateLock) {
        if (op.wasCanceled()) {
            return false;
        }
        pending.remove(op.getURI());
        if (inFlight.containsKey(op.getURI())) {
            return false;
        }
        inFlight.put(op.getURI(), op);
    }
    return true;
}
#end_block

#method_before
PushOne notifyFinished(PushOne op) {
    synchronized (stateLock) {
        return inFlight.remove(op.getURI());
    }
}
#method_after
void notifyFinished(PushOne op) {
    synchronized (stateLock) {
        inFlight.remove(op.getURI());
    }
}
#end_block

#method_before
boolean wouldPushProject(Project.NameKey project) {
    if (!isVisible(project)) {
        return false;
    }
    // by default push all projects
    String[] projects = config.getProjects();
    if (projects.length < 1) {
        return true;
    }
    return (new ReplicationFilter(Arrays.asList(projects))).matches(project);
}
#method_after
boolean wouldPushProject(Project.NameKey project) {
    if (!shouldReplicate(project)) {
        return false;
    }
    // by default push all projects
    List<String> projects = config.getProjects();
    if (projects.isEmpty()) {
        return true;
    }
    return (new ReplicationFilter(projects)).matches(project);
}
#end_block

#method_before
boolean isSingleProjectMatch() {
    String[] projects = config.getProjects();
    boolean ret = (projects.length == 1);
    if (ret) {
        String projectMatch = projects[0];
        if (ReplicationFilter.getPatternType(projectMatch) != ReplicationFilter.PatternType.EXACT_MATCH) {
            // projectMatch is either regular expression, or wild-card.
            // 
            // Even though they might refer to a single project now, they need not
            // after new projects have been created. Hence, we do not treat them as
            // matching a single project.
            ret = false;
        }
    }
    return ret;
}
#method_after
boolean isSingleProjectMatch() {
    List<String> projects = config.getProjects();
    boolean ret = (projects.size() == 1);
    if (ret) {
        String projectMatch = projects.get(0);
        if (ReplicationFilter.getPatternType(projectMatch) != ReplicationFilter.PatternType.EXACT_MATCH) {
            // projectMatch is either regular expression, or wild-card.
            // 
            // Even though they might refer to a single project now, they need not
            // after new projects have been created. Hence, we do not treat them as
            // matching a single project.
            ret = false;
        }
    }
    return ret;
}
#end_block

#method_before
String[] getAdminUrls() {
    return config.getAdminUrls();
}
#method_after
ImmutableList<String> getAdminUrls() {
    return config.getAdminUrls();
}
#end_block

#method_before
String[] getUrls() {
    return config.getUrls();
}
#method_after
ImmutableList<String> getUrls() {
    return config.getUrls();
}
#end_block

#method_before
String[] getAuthGroupNames() {
    return config.getAuthGroupNames();
}
#method_after
ImmutableList<String> getAuthGroupNames() {
    return config.getAuthGroupNames();
}
#end_block

#method_before
String[] getProjects() {
    return config.getProjects();
}
#method_after
ImmutableList<String> getProjects() {
    return config.getProjects();
}
#end_block

#method_before
private List<ChangeData> getForOpenChange(Change c, CurrentUser user) throws OrmException, IOException, AuthException {
    ChangeSet cs = mergeSuperSet.completeChangeSet(dbProvider.get(), c, user);
    if (cs.furtherHiddenChanges()) {
        throw new AuthException("topic includes hidden change");
    }
    return cs.changes().asList();
}
#method_after
private List<ChangeData> getForOpenChange(Change c, CurrentUser user) throws OrmException, IOException, AuthException {
    ChangeSet cs = mergeSuperSet.completeChangeSet(dbProvider.get(), c, user);
    if (cs.furtherHiddenChanges()) {
        throw new AuthException("change would be submitted with a change that you cannot see");
    }
    return cs.changes().asList();
}
#end_block

#method_before
public void merge(ReviewDb db, Change change, IdentifiedUser caller, boolean checkSubmitRules, SubmitInput submitInput) throws OrmException, RestApiException {
    this.submitInput = submitInput;
    this.caller = caller;
    updateSubmissionId(change);
    this.db = db;
    orm.setContext(db, ts, caller, submissionId);
    logDebug("Beginning integration of {}", change);
    try {
        ChangeSet cs = mergeSuperSet.completeChangeSet(db, change, caller);
        checkState(cs.ids().contains(change.getId()), "change %s missing from %s", change.getId(), cs);
        if (cs.furtherHiddenChanges()) {
            throw new AuthException("A change to be submitted with " + change.getId() + " is hidden");
        }
        this.commits = new CommitStatus(cs);
        MergeSuperSet.reloadChanges(cs);
        logDebug("Calculated to merge {}", cs);
        if (checkSubmitRules) {
            logDebug("Checking submit rules and state");
            checkSubmitRulesAndState(cs);
            // Done checks that don't involve opening repo.
            failFast(cs);
        } else {
            logDebug("Bypassing submit rules");
            bypassSubmitRules(cs);
        }
        try {
            integrateIntoHistory(cs);
        } catch (IntegrationException e) {
            logError("Error from integrateIntoHistory", e);
            throw new ResourceConflictException(e.getMessage(), e);
        }
    } catch (IOException e) {
        // Anything before the merge attempt is an error
        throw new OrmException(e);
    }
}
#method_after
public void merge(ReviewDb db, Change change, IdentifiedUser caller, boolean checkSubmitRules, SubmitInput submitInput) throws OrmException, RestApiException {
    this.submitInput = submitInput;
    this.caller = caller;
    updateSubmissionId(change);
    this.db = db;
    orm.setContext(db, ts, caller, submissionId);
    logDebug("Beginning integration of {}", change);
    try {
        ChangeSet cs = mergeSuperSet.completeChangeSet(db, change, caller);
        checkState(cs.ids().contains(change.getId()), "change %s missing from %s", change.getId(), cs);
        if (cs.furtherHiddenChanges()) {
            throw new AuthException("A change to be submitted with " + change.getId() + " is not visible");
        }
        this.commits = new CommitStatus(cs);
        MergeSuperSet.reloadChanges(cs);
        logDebug("Calculated to merge {}", cs);
        if (checkSubmitRules) {
            logDebug("Checking submit rules and state");
            checkSubmitRulesAndState(cs);
            // Done checks that don't involve opening repo.
            failFast(cs);
        } else {
            logDebug("Bypassing submit rules");
            bypassSubmitRules(cs);
        }
        try {
            integrateIntoHistory(cs);
        } catch (IntegrationException e) {
            logError("Error from integrateIntoHistory", e);
            throw new ResourceConflictException(e.getMessage(), e);
        }
    } catch (IOException e) {
        // Anything before the merge attempt is an error
        throw new OrmException(e);
    }
}
#end_block

#method_before
private void initTopicLink(ChangeInfo info) {
    if (info.topic() != null && !info.topic().isEmpty()) {
        text.setText(info.topic());
        text.setTargetHistoryToken(PageLinks.toChangeQuery(PageLinks.op("topic", info.topic()) + "+" + "is:open"));
    }
}
#method_after
private void initTopicLink(ChangeInfo info) {
    if (info.topic() != null && !info.topic().isEmpty()) {
        String topic = info.topic();
        text.setText(topic);
        text.setTargetHistoryToken(PageLinks.topicQuery(info.status(), topic));
    }
}
#end_block

#method_before
private NoteDbChangeState execute(ReviewDb db, Change.Id changeId, NoteDbUpdateManager manager) throws NoSuchChangeException, OrmException, IOException {
    Change change = db.changes().get(changeId);
    if (change == null) {
        throw new NoSuchChangeException(changeId);
    }
    final String oldNoteDbState = change.getNoteDbState();
    NoteDbChangeState newState = NoteDbChangeState.applyDelta(change, manager.stage().get(changeId));
    final String newNoteDbState = change.getNoteDbState();
    try {
        db.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (!oldNoteDbState.equals(change.getNoteDbState())) {
                    throw new AbortUpdateException();
                }
                change.setNoteDbState(newNoteDbState);
                return change;
            }
        });
        manager.execute();
    } catch (AbortUpdateException e) {
    // Drop this rebuild; another thread completed it.
    }
    return newState;
}
#method_after
private NoteDbChangeState execute(ReviewDb db, Change.Id changeId, NoteDbUpdateManager manager) throws NoSuchChangeException, OrmException, IOException {
    Change change = db.changes().get(changeId);
    if (change == null) {
        throw new NoSuchChangeException(changeId);
    }
    final String oldNoteDbState = change.getNoteDbState();
    NoteDbChangeState newState = NoteDbChangeState.applyDelta(change, manager.stage());
    final String newNoteDbState = change.getNoteDbState();
    try {
        db.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (!Objects.equals(oldNoteDbState, change.getNoteDbState())) {
                    throw new AbortUpdateException();
                }
                change.setNoteDbState(newNoteDbState);
                return change;
            }
        });
        manager.execute();
    } catch (AbortUpdateException e) {
    // Drop this rebuild; another thread completed it.
    }
    return newState;
}
#end_block

#method_before
@Override
public NoteDbChangeState rebuild(NoteDbUpdateManager manager, ChangeBundle bundle) throws NoSuchChangeException, IOException, OrmException, ConfigInvalidException {
    Change change = new Change(bundle.getChange());
    buildUpdates(manager, bundle);
    return NoteDbChangeState.applyDelta(change, manager.stage().get(change.getId()));
}
#method_after
@Override
public NoteDbChangeState rebuild(NoteDbUpdateManager manager, ChangeBundle bundle) throws NoSuchChangeException, IOException, OrmException, ConfigInvalidException {
    Change change = new Change(bundle.getChange());
    buildUpdates(manager, bundle);
    return NoteDbChangeState.applyDelta(change, manager.stage());
}
#end_block

#method_before
@Override
protected void doGetText(HttpServletRequest req, HttpServletResponse res) throws IOException {
    String prefix = ViewFilter.getView(req).getRepositoryPrefix();
    Set<String> branches = parseShowBranch(req);
    Map<String, RepositoryDescription> descs = list(req, res, prefix, branches);
    if (descs == null) {
        return;
    }
    try (Writer writer = startRenderText(req, res)) {
        for (RepositoryDescription repo : descs.values()) {
            for (String name : branches) {
                String ref = repo.branches.get(name);
                if (ref == null) {
                    // Print stub (forty '-' symbols)
                    ref = "----------------------------------------";
                }
                writer.write(ref);
                writer.write(' ');
            }
            writer.write(GitilesUrls.NAME_ESCAPER.apply(stripPrefix(prefix, repo.name)));
            writer.write('\n');
        }
    }
}
#method_after
@Override
protected void doGetText(HttpServletRequest req, HttpServletResponse res) throws IOException {
    String prefix = ViewFilter.getView(req).getRepositoryPrefix();
    Set<String> branches = parseShowBranch(req);
    Map<String, RepositoryDescription> descs = list(req, res, prefix, branches);
    if (descs == null) {
        return;
    }
    Writer writer = startRenderText(req, res);
    for (RepositoryDescription repo : descs.values()) {
        for (String name : branches) {
            String ref = repo.branches.get(name);
            if (ref == null) {
                // Print stub (forty '-' symbols)
                ref = "----------------------------------------";
            }
            writer.write(ref);
            writer.write(' ');
        }
        writer.write(GitilesUrls.NAME_ESCAPER.apply(stripPrefix(prefix, repo.name)));
        writer.write('\n');
    }
    writer.flush();
    writer.close();
}
#end_block

#method_before
public Builder setRepositoryPrefix(String prefix) {
    switch(type) {
        case HOST_INDEX:
            this.repositoryPrefix = prefix != null ? Strings.emptyToNull(maybeTrimLeadingAndTrailingSlash(prefix)) : null;
            return this;
        case ARCHIVE:
        case BLAME:
        case DESCRIBE:
        case DIFF:
        case DOC:
        case LOG:
        case PATH:
        case REFS:
        case REPOSITORY_INDEX:
        case REVISION:
        case ROOTED_DOC:
        case SHOW:
        default:
            throw new IllegalStateException(String.format("cannot set repository prefix on %s view", type));
    }
}
#method_after
public Builder setRepositoryPrefix(String prefix) {
    if (type == Type.HOST_INDEX) {
        this.repositoryPrefix = prefix != null ? Strings.emptyToNull(maybeTrimLeadingAndTrailingSlash(prefix)) : null;
        return this;
    }
    throw new IllegalStateException(String.format("cannot set repository prefix on %s view", type));
}
#end_block

#method_before
public Builder setOldRevision(Revision revision) {
    switch(type) {
        case DIFF:
        case LOG:
            break;
        case ARCHIVE:
        case BLAME:
        case DESCRIBE:
        case DOC:
        case HOST_INDEX:
        case PATH:
        case REFS:
        case REPOSITORY_INDEX:
        case REVISION:
        case ROOTED_DOC:
        case SHOW:
        default:
            revision = firstNonNull(revision, Revision.NULL);
            checkState(revision == Revision.NULL, "cannot set old revision on %s view", type);
            break;
    }
    this.oldRevision = revision;
    return this;
}
#method_after
public Builder setOldRevision(Revision revision) {
    if (type != Type.DIFF && type != Type.LOG) {
        revision = firstNonNull(revision, Revision.NULL);
        checkState(revision == Revision.NULL, "cannot set old revision on %s view", type);
    }
    this.oldRevision = revision;
    return this;
}
#end_block

#method_before
public String getRevisionRange() {
    if (oldRevision == Revision.NULL) {
        switch(type) {
            case LOG:
            case DIFF:
                // tree/commit.
                return revision.getName() + "^!";
            case ARCHIVE:
            case BLAME:
            case DESCRIBE:
            case DOC:
            case HOST_INDEX:
            case PATH:
            case REFS:
            case REPOSITORY_INDEX:
            case REVISION:
            case ROOTED_DOC:
            case SHOW:
            default:
                // revision.
                return null;
        }
    } else if (type == Type.DIFF && isFirstParent(revision, oldRevision)) {
        return revision.getName() + "^!";
    } else {
        return oldRevision.getName() + ".." + revision.getName();
    }
}
#method_after
public String getRevisionRange() {
    if (oldRevision == Revision.NULL) {
        if (type == Type.LOG || type == Type.DIFF) {
            // tree/commit.
            return revision.getName() + "^!";
        }
        // revision.
        return null;
    } else if (type == Type.DIFF && isFirstParent(revision, oldRevision)) {
        return revision.getName() + "^!";
    } else {
        return oldRevision.getName() + ".." + revision.getName();
    }
}
#end_block

#method_before
public Map<String, Object> toSoyData(ObjectId treeId, TreeWalk tw) throws MissingObjectException, IOException {
    ReadmeHelper readme = new ReadmeHelper(reader, view, MarkdownConfig.get(cfg), rootTree, requestUri);
    List<Object> entries = Lists.newArrayList();
    GitilesView.Builder urlBuilder = GitilesView.path().copyFrom(view);
    while (tw.next()) {
        FileType type = FileType.forEntry(tw);
        String name = tw.getNameString();
        switch(view.getType()) {
            case PATH:
                urlBuilder.setPathPart(view.getPathPart() + "/" + name);
                break;
            case REVISION:
                // Got here from a tag pointing at a tree.
                urlBuilder.setPathPart(name);
                break;
            case ARCHIVE:
            case BLAME:
            case DESCRIBE:
            case DIFF:
            case DOC:
            case HOST_INDEX:
            case LOG:
            case REFS:
            case REPOSITORY_INDEX:
            case ROOTED_DOC:
            case SHOW:
            default:
                throw new IllegalStateException(String.format("Cannot render TreeSoyData from %s view", view.getType()));
        }
        String url = urlBuilder.toUrl();
        if (type == FileType.TREE) {
            name += "/";
            url += "/";
        }
        Map<String, String> entry = Maps.newHashMapWithExpectedSize(4);
        entry.put("type", type.toString());
        entry.put("name", name);
        entry.put("url", url);
        if (type == FileType.SYMLINK) {
            String target = new String(reader.open(tw.getObjectId(0)).getCachedBytes(), UTF_8);
            entry.put("targetName", getTargetDisplayName(target));
            String targetUrl = resolveTargetUrl(view, target);
            if (targetUrl != null) {
                entry.put("targetUrl", targetUrl);
            }
        } else {
            readme.considerEntry(tw);
        }
        entries.add(entry);
    }
    Map<String, Object> data = Maps.newHashMapWithExpectedSize(3);
    data.put("sha", treeId.name());
    data.put("entries", entries);
    if (view.getType() == GitilesView.Type.PATH && view.getRevision().getPeeledType() == OBJ_COMMIT) {
        data.put("logUrl", GitilesView.log().copyFrom(view).toUrl());
        data.put("archiveUrl", GitilesView.archive().copyFrom(view).setPathPart(Strings.emptyToNull(view.getPathPart())).setExtension(archiveFormat.getDefaultSuffix()).toUrl());
        data.put("archiveType", archiveFormat.getShortName());
    }
    if (readme.isPresent()) {
        data.put("readmePath", readme.getPath());
        data.put("readmeHtml", readme.render());
    }
    return data;
}
#method_after
public Map<String, Object> toSoyData(ObjectId treeId, TreeWalk tw) throws MissingObjectException, IOException {
    ReadmeHelper readme = new ReadmeHelper(reader, view, MarkdownConfig.get(cfg), rootTree, requestUri);
    List<Object> entries = Lists.newArrayList();
    GitilesView.Builder urlBuilder = GitilesView.path().copyFrom(view);
    while (tw.next()) {
        FileType type = FileType.forEntry(tw);
        String name = tw.getNameString();
        GitilesView.Type viewType = view.getType();
        if (viewType == GitilesView.Type.PATH) {
            urlBuilder.setPathPart(view.getPathPart() + "/" + name);
        } else if (viewType == GitilesView.Type.REVISION) {
            // Got here from a tag pointing at a tree.
            urlBuilder.setPathPart(name);
        } else {
            throw new IllegalStateException(String.format("Cannot render TreeSoyData from %s view", viewType));
        }
        String url = urlBuilder.toUrl();
        if (type == FileType.TREE) {
            name += "/";
            url += "/";
        }
        Map<String, String> entry = Maps.newHashMapWithExpectedSize(4);
        entry.put("type", type.toString());
        entry.put("name", name);
        entry.put("url", url);
        if (type == FileType.SYMLINK) {
            String target = new String(reader.open(tw.getObjectId(0)).getCachedBytes(), UTF_8);
            entry.put("targetName", getTargetDisplayName(target));
            String targetUrl = resolveTargetUrl(view, target);
            if (targetUrl != null) {
                entry.put("targetUrl", targetUrl);
            }
        } else {
            readme.considerEntry(tw);
        }
        entries.add(entry);
    }
    Map<String, Object> data = Maps.newHashMapWithExpectedSize(3);
    data.put("sha", treeId.name());
    data.put("entries", entries);
    if (view.getType() == GitilesView.Type.PATH && view.getRevision().getPeeledType() == OBJ_COMMIT) {
        data.put("logUrl", GitilesView.log().copyFrom(view).toUrl());
        data.put("archiveUrl", GitilesView.archive().copyFrom(view).setPathPart(Strings.emptyToNull(view.getPathPart())).setExtension(archiveFormat.getDefaultSuffix()).toUrl());
        data.put("archiveType", archiveFormat.getShortName());
    }
    if (readme.isPresent()) {
        data.put("readmePath", readme.getPath());
        data.put("readmeHtml", readme.render());
    }
    return data;
}
#end_block

#method_before
@Override
protected void doGetJson(HttpServletRequest req, HttpServletResponse res) throws IOException {
    GitilesView view = ViewFilter.getView(req);
    Repository repo = ServletUtils.getRepository(req);
    String longStr = req.getParameter("long");
    boolean includeSizes = (longStr != null) && (longStr.isEmpty() || Boolean.TRUE.equals(StringUtils.toBooleanOrNull(longStr)));
    String recursiveStr = req.getParameter("recursive");
    boolean recursive = (recursiveStr != null) && (recursiveStr.isEmpty() || Boolean.TRUE.equals(StringUtils.toBooleanOrNull(recursiveStr)));
    try (RevWalk rw = new RevWalk(repo);
        WalkResult wr = WalkResult.forPath(rw, view, recursive)) {
        if (wr == null || wr.type != FileType.TREE) {
            res.setStatus(SC_NOT_FOUND);
        }
        renderJson(req, res, TreeJsonData.toJsonData(wr.id, wr.tw, includeSizes, recursive), TreeJsonData.Tree.class);
    } catch (LargeObjectException e) {
        res.setStatus(SC_INTERNAL_SERVER_ERROR);
    }
}
#method_after
@Override
protected void doGetJson(HttpServletRequest req, HttpServletResponse res) throws IOException {
    GitilesView view = ViewFilter.getView(req);
    Repository repo = ServletUtils.getRepository(req);
    String longStr = req.getParameter("long");
    boolean includeSizes = (longStr != null) && (longStr.isEmpty() || Boolean.TRUE.equals(StringUtils.toBooleanOrNull(longStr)));
    String recursiveStr = req.getParameter("recursive");
    boolean recursive = (recursiveStr != null) && (recursiveStr.isEmpty() || Boolean.TRUE.equals(StringUtils.toBooleanOrNull(recursiveStr)));
    try (RevWalk rw = new RevWalk(repo);
        WalkResult wr = WalkResult.forPath(rw, view, recursive)) {
        if (wr == null || wr.type != FileType.TREE) {
            res.setStatus(SC_NOT_FOUND);
        } else {
            renderJson(req, res, TreeJsonData.toJsonData(wr.id, wr.tw, includeSizes, recursive), TreeJsonData.Tree.class);
        }
    } catch (LargeObjectException e) {
        res.setStatus(SC_INTERNAL_SERVER_ERROR);
    }
}
#end_block

#method_before
private static WalkResult forPath(RevWalk rw, GitilesView view, boolean recursive) throws IOException {
    if (recursive) {
        return recursivePath(rw, view);
    }
    RevTree root = getRoot(view, rw);
    String path = view.getPathPart();
    try (TreeWalk tw = new TreeWalk(rw.getObjectReader())) {
        tw.addTree(root);
        tw.setRecursive(false);
        if (path.isEmpty()) {
            return new WalkResult(tw, path, root, root, FileType.TREE, ImmutableList.<Boolean>of());
        }
        AutoDiveFilter f = new AutoDiveFilter(path);
        tw.setFilter(f);
        while (tw.next()) {
            if (f.isDone(tw)) {
                FileType type = FileType.forEntry(tw);
                ObjectId id = tw.getObjectId(0);
                if (type == FileType.TREE) {
                    tw.enterSubtree();
                    tw.setRecursive(false);
                }
                return new WalkResult(tw, path, root, id, type, f.hasSingleTree);
            } else if (tw.isSubtree()) {
                tw.enterSubtree();
            }
        }
    } catch (IOException | RuntimeException e) {
    // Fallthrough.
    }
    return null;
}
#method_after
private static WalkResult forPath(RevWalk rw, GitilesView view, boolean recursive) throws IOException {
    if (recursive) {
        return recursivePath(rw, view);
    }
    RevTree root = getRoot(view, rw);
    String path = view.getPathPart();
    TreeWalk tw = new TreeWalk(rw.getObjectReader());
    try {
        tw.addTree(root);
        tw.setRecursive(false);
        if (path.isEmpty()) {
            return new WalkResult(tw, path, root, root, FileType.TREE, ImmutableList.<Boolean>of());
        }
        AutoDiveFilter f = new AutoDiveFilter(path);
        tw.setFilter(f);
        while (tw.next()) {
            if (f.isDone(tw)) {
                FileType type = FileType.forEntry(tw);
                ObjectId id = tw.getObjectId(0);
                if (type == FileType.TREE) {
                    tw.enterSubtree();
                    tw.setRecursive(false);
                }
                return new WalkResult(tw, path, root, id, type, f.hasSingleTree);
            } else if (tw.isSubtree()) {
                tw.enterSubtree();
            }
        }
    } catch (IOException | RuntimeException e) {
    // Fallthrough.
    }
    tw.close();
    return null;
}
#end_block

#method_before
@Override
public void close() {
    MoreExecutors.shutdownAndAwaitTermination(executor, Long.MAX_VALUE, TimeUnit.SECONDS);
    openIndex.close();
    closedIndex.close();
}
#method_after
@Override
public void close() {
    MoreExecutors.shutdownAndAwaitTermination(executor, Long.MAX_VALUE, TimeUnit.SECONDS);
    try {
        openIndex.close();
    } finally {
        closedIndex.close();
    }
}
#end_block

#method_before
@Override
protected void configure() {
    bind(AccountsCollection.class);
    bind(Capabilities.class);
    DynamicMap.mapOf(binder(), ACCOUNT_KIND);
    DynamicMap.mapOf(binder(), CAPABILITY_KIND);
    DynamicMap.mapOf(binder(), EMAIL_KIND);
    DynamicMap.mapOf(binder(), SSH_KEY_KIND);
    DynamicMap.mapOf(binder(), STARRED_CHANGE_KIND);
    put(ACCOUNT_KIND).to(PutAccount.class);
    get(ACCOUNT_KIND).to(GetAccount.class);
    get(ACCOUNT_KIND, "detail").to(GetDetail.class);
    get(ACCOUNT_KIND, "name").to(GetName.class);
    put(ACCOUNT_KIND, "name").to(PutName.class);
    delete(ACCOUNT_KIND, "name").to(PutName.class);
    get(ACCOUNT_KIND, "username").to(GetUsername.class);
    put(ACCOUNT_KIND, "username").to(PutUsername.class);
    get(ACCOUNT_KIND, "active").to(GetActive.class);
    put(ACCOUNT_KIND, "active").to(PutActive.class);
    delete(ACCOUNT_KIND, "active").to(DeleteActive.class);
    child(ACCOUNT_KIND, "emails").to(Emails.class);
    get(EMAIL_KIND).to(GetEmail.class);
    put(EMAIL_KIND).to(PutEmail.class);
    delete(EMAIL_KIND).to(DeleteEmail.class);
    put(EMAIL_KIND, "preferred").to(PutPreferred.class);
    get(ACCOUNT_KIND, "password.http").to(GetHttpPassword.class);
    put(ACCOUNT_KIND, "password.http").to(PutHttpPassword.class);
    delete(ACCOUNT_KIND, "password.http").to(PutHttpPassword.class);
    child(ACCOUNT_KIND, "sshkeys").to(SshKeys.class);
    post(ACCOUNT_KIND, "sshkeys").to(AddSshKey.class);
    get(SSH_KEY_KIND).to(GetSshKey.class);
    delete(SSH_KEY_KIND).to(DeleteSshKey.class);
    get(ACCOUNT_KIND, "oauthtoken").to(GetOAuthToken.class);
    get(ACCOUNT_KIND, "avatar").to(GetAvatar.class);
    get(ACCOUNT_KIND, "avatar.change.url").to(GetAvatarChangeUrl.class);
    child(ACCOUNT_KIND, "capabilities").to(Capabilities.class);
    get(ACCOUNT_KIND, "groups").to(GetGroups.class);
    get(ACCOUNT_KIND, "preferences").to(GetPreferences.class);
    put(ACCOUNT_KIND, "preferences").to(SetPreferences.class);
    get(ACCOUNT_KIND, "preferences.diff").to(GetDiffPreferences.class);
    put(ACCOUNT_KIND, "preferences.diff").to(SetDiffPreferences.class);
    get(ACCOUNT_KIND, "preferences.edit").to(GetEditPreferences.class);
    put(ACCOUNT_KIND, "preferences.edit").to(SetEditPreferences.class);
    get(CAPABILITY_KIND).to(GetCapabilities.CheckOne.class);
    child(ACCOUNT_KIND, "starred.changes").to(StarredChanges.class);
    put(STARRED_CHANGE_KIND).to(StarredChanges.Put.class);
    delete(STARRED_CHANGE_KIND).to(StarredChanges.Delete.class);
    bind(StarredChanges.Create.class);
    factory(CreateAccount.Factory.class);
    factory(CreateEmail.Factory.class);
}
#method_after
@Override
protected void configure() {
    bind(AccountsCollection.class);
    bind(Capabilities.class);
    DynamicMap.mapOf(binder(), ACCOUNT_KIND);
    DynamicMap.mapOf(binder(), CAPABILITY_KIND);
    DynamicMap.mapOf(binder(), EMAIL_KIND);
    DynamicMap.mapOf(binder(), SSH_KEY_KIND);
    DynamicMap.mapOf(binder(), STARRED_CHANGE_KIND);
    put(ACCOUNT_KIND).to(PutAccount.class);
    get(ACCOUNT_KIND).to(GetAccount.class);
    get(ACCOUNT_KIND, "detail").to(GetDetail.class);
    get(ACCOUNT_KIND, "name").to(GetName.class);
    put(ACCOUNT_KIND, "name").to(PutName.class);
    delete(ACCOUNT_KIND, "name").to(PutName.class);
    get(ACCOUNT_KIND, "username").to(GetUsername.class);
    put(ACCOUNT_KIND, "username").to(PutUsername.class);
    get(ACCOUNT_KIND, "active").to(GetActive.class);
    put(ACCOUNT_KIND, "active").to(PutActive.class);
    delete(ACCOUNT_KIND, "active").to(DeleteActive.class);
    child(ACCOUNT_KIND, "emails").to(Emails.class);
    get(EMAIL_KIND).to(GetEmail.class);
    put(EMAIL_KIND).to(PutEmail.class);
    delete(EMAIL_KIND).to(DeleteEmail.class);
    put(EMAIL_KIND, "preferred").to(PutPreferred.class);
    get(ACCOUNT_KIND, "password.http").to(GetHttpPassword.class);
    put(ACCOUNT_KIND, "password.http").to(PutHttpPassword.class);
    delete(ACCOUNT_KIND, "password.http").to(PutHttpPassword.class);
    child(ACCOUNT_KIND, "sshkeys").to(SshKeys.class);
    post(ACCOUNT_KIND, "sshkeys").to(AddSshKey.class);
    get(ACCOUNT_KIND, "watched.projects").to(GetWatchedProjects.class);
    post(ACCOUNT_KIND, "watched.projects").to(PostWatchedProjects.class);
    post(ACCOUNT_KIND, "watched.projects:delete").to(DeleteWatchedProjects.class);
    get(SSH_KEY_KIND).to(GetSshKey.class);
    delete(SSH_KEY_KIND).to(DeleteSshKey.class);
    get(ACCOUNT_KIND, "oauthtoken").to(GetOAuthToken.class);
    get(ACCOUNT_KIND, "avatar").to(GetAvatar.class);
    get(ACCOUNT_KIND, "avatar.change.url").to(GetAvatarChangeUrl.class);
    child(ACCOUNT_KIND, "capabilities").to(Capabilities.class);
    get(ACCOUNT_KIND, "groups").to(GetGroups.class);
    get(ACCOUNT_KIND, "preferences").to(GetPreferences.class);
    put(ACCOUNT_KIND, "preferences").to(SetPreferences.class);
    get(ACCOUNT_KIND, "preferences.diff").to(GetDiffPreferences.class);
    put(ACCOUNT_KIND, "preferences.diff").to(SetDiffPreferences.class);
    get(ACCOUNT_KIND, "preferences.edit").to(GetEditPreferences.class);
    put(ACCOUNT_KIND, "preferences.edit").to(SetEditPreferences.class);
    get(CAPABILITY_KIND).to(GetCapabilities.CheckOne.class);
    child(ACCOUNT_KIND, "starred.changes").to(StarredChanges.class);
    put(STARRED_CHANGE_KIND).to(StarredChanges.Put.class);
    delete(STARRED_CHANGE_KIND).to(StarredChanges.Delete.class);
    bind(StarredChanges.Create.class);
    factory(CreateAccount.Factory.class);
    factory(CreateEmail.Factory.class);
}
#end_block

#method_before
public void setMessageSender(final MessageSender ms) {
    messageSender = ms != null ? ms : new ReceivePackMessageSender();
}
#method_after
public void setMessageSender(MessageSender ms) {
    messageSender = ms != null ? ms : new ReceivePackMessageSender();
}
#end_block

#method_before
void processCommands(final Collection<ReceiveCommand> commands, final MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    batch = repo.getRefDatabase().newBatchUpdate();
    batch.setPushCertificate(rp.getPushCertificate());
    batch.setRefLogIdent(rp.getRefLogIdent());
    batch.setRefLogMessage("push", true);
    parseCommands(commands);
    if (magicBranch != null && magicBranch.cmd.getResult() == NOT_ATTEMPTED) {
        selectNewAndReplacedChangesFromMagicBranch();
    }
    preparePatchSetsForReplace();
    if (!batch.getCommands().isEmpty()) {
        try {
            if (!batch.isAllowNonFastForwards() && magicBranch != null && magicBranch.edit) {
                batch.setAllowNonFastForwards(true);
            }
            batch.execute(rp.getRevWalk(), commandProgress);
        } catch (IOException err) {
            int cnt = 0;
            for (ReceiveCommand cmd : batch.getCommands()) {
                if (cmd.getResult() == NOT_ATTEMPTED) {
                    cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
                    cnt++;
                }
            }
            log.error(String.format("Failed to store %d refs in %s", cnt, project.getName()), err);
        }
    }
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(user)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    Set<Branch.NameKey> branches = Sets.newHashSet();
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == OK) {
            if (c.getType() == ReceiveCommand.Type.UPDATE) {
                // aka fast-forward
                tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
            }
            if (isHead(c) || isConfig(c)) {
                switch(c.getType()) {
                    case CREATE:
                    case UPDATE:
                    case UPDATE_NONFASTFORWARD:
                        autoCloseChanges(c);
                        branches.add(new Branch.NameKey(project.getNameKey(), c.getRefName()));
                        break;
                    case DELETE:
                        break;
                }
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(c.getRefName()) || MagicBranch.isMagicBranchWithAutoClose(c.getRefName())) {
                // We only fire gitRefUpdated for direct refs updates.
                // Events for change refs are fired when they are created.
                // 
                gitRefUpdated.fire(project.getNameKey(), c);
                hooks.doRefUpdatedHook(new Branch.NameKey(project.getNameKey(), c.getRefName()), c.getOldId(), c.getNewId(), user.getAccount());
            }
        }
    }
    // Update superproject gitlinks if required.
    SubmoduleOp op = subOpProvider.get();
    try {
        op.updateSuperProjects(db, branches, "receiveID");
    } catch (SubmoduleException e) {
        log.error("Can't update the superprojects", e);
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    reportMessages();
}
#method_after
void processCommands(Collection<ReceiveCommand> commands, MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    batch = repo.getRefDatabase().newBatchUpdate();
    batch.setPushCertificate(rp.getPushCertificate());
    batch.setRefLogIdent(rp.getRefLogIdent());
    batch.setRefLogMessage("push", true);
    parseCommands(commands);
    if (magicBranch != null && magicBranch.cmd.getResult() == NOT_ATTEMPTED) {
        selectNewAndReplacedChangesFromMagicBranch();
    }
    preparePatchSetsForReplace();
    if (!batch.getCommands().isEmpty()) {
        try {
            if (!batch.isAllowNonFastForwards() && magicBranch != null && magicBranch.edit) {
                batch.setAllowNonFastForwards(true);
            }
            batch.execute(rp.getRevWalk(), commandProgress);
        } catch (IOException err) {
            int cnt = 0;
            for (ReceiveCommand cmd : batch.getCommands()) {
                if (cmd.getResult() == NOT_ATTEMPTED) {
                    cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
                    cnt++;
                }
            }
            log.error(String.format("Failed to store %d refs in %s", cnt, project.getName()), err);
        }
    }
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(user)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    Set<Branch.NameKey> branches = new HashSet<>();
    for (ReceiveCommand c : batch.getCommands()) {
        if (c.getResult() == OK) {
            String refName = c.getRefName();
            if (c.getType() == ReceiveCommand.Type.UPDATE) {
                // aka fast-forward
                tagCache.updateFastForward(project.getNameKey(), refName, c.getOldId(), c.getNewId());
            }
            if (isHead(c) || isConfig(c)) {
                switch(c.getType()) {
                    case CREATE:
                    case UPDATE:
                    case UPDATE_NONFASTFORWARD:
                        autoCloseChanges(c);
                        branches.add(new Branch.NameKey(project.getNameKey(), refName));
                        break;
                    case DELETE:
                        break;
                }
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(refName) && !refName.startsWith(REFS_CHANGES)) {
                // We only fire gitRefUpdated for direct refs updates.
                // Events for change refs are fired when they are created.
                // 
                gitRefUpdated.fire(project.getNameKey(), c, user.getAccount());
                hooks.doRefUpdatedHook(new Branch.NameKey(project.getNameKey(), refName), c.getOldId(), c.getNewId(), user.getAccount());
            }
        }
    }
    // Update superproject gitlinks if required.
    try (MergeOpRepoManager orm = ormProvider.get()) {
        orm.setContext(db, TimeUtil.nowTs(), user, "receiveID");
        SubmoduleOp op = subOpFactory.create(orm);
        op.updateSuperProjects(branches);
    } catch (SubmoduleException e) {
        log.error("Can't update the superprojects", e);
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    reportMessages();
}
#end_block

#method_before
private void insertChangesAndPatchSets() {
    int replaceCount = 0;
    int okToInsert = 0;
    for (Map.Entry<Change.Id, ReplaceRequest> e : replaceByChange.entrySet()) {
        ReplaceRequest replace = e.getValue();
        if (magicBranch != null && replace.inputCommand == magicBranch.cmd) {
            replaceCount++;
            if (replace.cmd != null && replace.cmd.getResult() == OK) {
                okToInsert++;
            }
        } else if (replace.cmd != null && replace.cmd.getResult() == OK) {
            try {
                if (replace.insertPatchSet().checkedGet() != null) {
                    replace.inputCommand.setResult(OK);
                }
            } catch (RestApiException err) {
                reject(replace.inputCommand, "internal server error");
                log.error(String.format("Cannot add patch set to change %d in project %s", e.getKey().get(), project.getName()), err);
            }
        } else if (replace.inputCommand.getResult() == NOT_ATTEMPTED) {
            reject(replace.inputCommand, "internal server error");
            log.error(String.format("Replacement for project %s was not attempted", project.getName()));
        }
    }
    if (magicBranch == null || magicBranch.cmd.getResult() != NOT_ATTEMPTED) {
        // No need to continue.
        return;
    }
    List<String> lastCreateChangeErrors = Lists.newArrayList();
    for (CreateRequest create : newChanges) {
        if (create.cmd.getResult() == OK) {
            okToInsert++;
        } else {
            String createChangeResult = String.format("%s %s", create.cmd.getResult(), Strings.nullToEmpty(create.cmd.getMessage())).trim();
            lastCreateChangeErrors.add(createChangeResult);
            log.error(String.format("Command %s on %s:%s not completed: %s", create.cmd.getType(), project.getName(), create.cmd.getRefName(), createChangeResult));
        }
    }
    if (okToInsert != replaceCount + newChanges.size()) {
        // One or more new references failed to create. Assume the
        // system isn't working correctly anymore and abort.
        reject(magicBranch.cmd, "Unable to create changes: " + Joiner.on(' ').join(lastCreateChangeErrors));
        log.error(String.format("Only %d of %d new change refs created in %s; aborting", okToInsert, replaceCount + newChanges.size(), project.getName()));
        return;
    }
    try {
        List<CheckedFuture<?, RestApiException>> futures = Lists.newArrayList();
        for (ReplaceRequest replace : replaceByChange.values()) {
            if (replace.inputCommand == magicBranch.cmd) {
                futures.add(replace.insertPatchSet());
            }
        }
        for (CreateRequest create : newChanges) {
            futures.add(create.insertChange());
        }
        for (UpdateGroupsRequest update : updateGroups) {
            futures.add(update.updateGroups());
        }
        for (CheckedFuture<?, RestApiException> f : futures) {
            f.checkedGet();
        }
        magicBranch.cmd.setResult(OK);
    } catch (ResourceConflictException e) {
        addMessage(e.getMessage());
        reject(magicBranch.cmd, "conflict");
    } catch (RestApiException err) {
        log.error("Can't insert change/patch set for " + project.getName(), err);
        reject(magicBranch.cmd, "internal server error: " + err.getMessage());
    }
}
#method_after
private void insertChangesAndPatchSets() {
    int replaceCount = 0;
    int okToInsert = 0;
    for (Map.Entry<Change.Id, ReplaceRequest> e : replaceByChange.entrySet()) {
        ReplaceRequest replace = e.getValue();
        if (magicBranch != null && replace.inputCommand == magicBranch.cmd) {
            replaceCount++;
            if (replace.cmd != null && replace.cmd.getResult() == OK) {
                okToInsert++;
            }
        } else if (replace.cmd != null && replace.cmd.getResult() == OK) {
            try {
                if (replace.insertPatchSet().checkedGet() != null) {
                    replace.inputCommand.setResult(OK);
                }
            } catch (RestApiException err) {
                reject(replace.inputCommand, "internal server error");
                log.error(String.format("Cannot add patch set to change %d in project %s", e.getKey().get(), project.getName()), err);
            }
        } else if (replace.inputCommand.getResult() == NOT_ATTEMPTED) {
            reject(replace.inputCommand, "internal server error");
            log.error(String.format("Replacement for project %s was not attempted", project.getName()));
        }
    }
    if (magicBranch == null || magicBranch.cmd.getResult() != NOT_ATTEMPTED) {
        // No need to continue.
        return;
    }
    List<String> lastCreateChangeErrors = new ArrayList<>();
    for (CreateRequest create : newChanges) {
        if (create.cmd.getResult() == OK) {
            okToInsert++;
        } else {
            String createChangeResult = String.format("%s %s", create.cmd.getResult(), Strings.nullToEmpty(create.cmd.getMessage())).trim();
            lastCreateChangeErrors.add(createChangeResult);
            log.error(String.format("Command %s on %s:%s not completed: %s", create.cmd.getType(), project.getName(), create.cmd.getRefName(), createChangeResult));
        }
    }
    if (okToInsert != replaceCount + newChanges.size()) {
        // One or more new references failed to create. Assume the
        // system isn't working correctly anymore and abort.
        reject(magicBranch.cmd, "Unable to create changes: " + Joiner.on(' ').join(lastCreateChangeErrors));
        log.error(String.format("Only %d of %d new change refs created in %s; aborting", okToInsert, replaceCount + newChanges.size(), project.getName()));
        return;
    }
    try {
        List<CheckedFuture<?, RestApiException>> futures = new ArrayList<>();
        for (ReplaceRequest replace : replaceByChange.values()) {
            if (replace.inputCommand == magicBranch.cmd) {
                futures.add(replace.insertPatchSet());
            }
        }
        for (CreateRequest create : newChanges) {
            futures.add(create.insertChange());
        }
        for (UpdateGroupsRequest update : updateGroups) {
            futures.add(update.updateGroups());
        }
        for (CheckedFuture<?, RestApiException> f : futures) {
            f.checkedGet();
        }
        magicBranch.cmd.setResult(OK);
    } catch (ResourceConflictException e) {
        addMessage(e.getMessage());
        reject(magicBranch.cmd, "conflict");
    } catch (RestApiException err) {
        log.error("Can't insert change/patch set for " + project.getName(), err);
        reject(magicBranch.cmd, "internal server error: " + err.getMessage());
    }
}
#end_block

#method_before
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseMagicBranch(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(repo, cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            addError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                addError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                        Project.NameKey newParent = cfg.getProject().getParent(allProjectsName);
                        Project.NameKey oldParent = project.getParent(allProjectsName);
                        if (oldParent == null) {
                            // update of the 'All-Projects' project
                            if (newParent != null) {
                                reject(cmd, "invalid project configuration: root project cannot have parent");
                                continue;
                            }
                        } else {
                            if (!oldParent.equals(newParent) && !user.getCapabilities().canAdministrateServer()) {
                                reject(cmd, "invalid project configuration: only Gerrit admin can set parent");
                                continue;
                            }
                            if (projectCache.get(newParent) == null) {
                                reject(cmd, "invalid project configuration: parent does not exist");
                                continue;
                            }
                        }
                        for (Entry<ProjectConfigEntry> e : pluginConfigEntries) {
                            PluginConfig pluginCfg = cfg.getPluginConfig(e.getPluginName());
                            ProjectConfigEntry configEntry = e.getProvider().get();
                            String value = pluginCfg.getString(e.getExportName());
                            String oldValue = projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getString(e.getExportName());
                            if (configEntry.getType() == ProjectConfigEntry.Type.ARRAY) {
                                List<String> l = Arrays.asList(projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getStringList(e.getExportName()));
                                oldValue = Joiner.on("\n").join(l);
                            }
                            if ((value == null ? oldValue != null : !value.equals(oldValue)) && !configEntry.isEditable(projectControl.getProjectState())) {
                                reject(cmd, String.format("invalid project configuration: Not allowed to set parameter" + " '%s' of plugin '%s' on project '%s'.", e.getExportName(), e.getPluginName(), project.getName()));
                                continue;
                            }
                            if (ProjectConfigEntry.Type.LIST.equals(configEntry.getType()) && value != null && !configEntry.getPermittedValues().contains(value)) {
                                reject(cmd, String.format("invalid project configuration: The value '%s' is " + "not permitted for parameter '%s' of plugin '%s'.", value, e.getExportName(), e.getPluginName()));
                            }
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#method_after
private void parseCommands(Collection<ReceiveCommand> commands) {
    for (ReceiveCommand cmd : commands) {
        if (cmd.getResult() != NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseMagicBranch(cmd);
            continue;
        }
        if (projectControl.getProjectState().isAllUsers() && RefNames.REFS_USERS_SELF.equals(cmd.getRefName())) {
            final ReceiveCommand orgCmd = cmd;
            cmd = new ReceiveCommand(cmd.getOldId(), cmd.getNewId(), RefNames.refsUsers(user.getAccountId()), cmd.getType()) {

                @Override
                public void setResult(Result s, String m) {
                    super.setResult(s, m);
                    orgCmd.setResult(s, m);
                }
            };
        }
        Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(rp.getRevWalk(), cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            addError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                addError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                        Project.NameKey newParent = cfg.getProject().getParent(allProjectsName);
                        Project.NameKey oldParent = project.getParent(allProjectsName);
                        if (oldParent == null) {
                            // update of the 'All-Projects' project
                            if (newParent != null) {
                                reject(cmd, "invalid project configuration: root project cannot have parent");
                                continue;
                            }
                        } else {
                            if (!oldParent.equals(newParent) && !user.getCapabilities().canAdministrateServer()) {
                                reject(cmd, "invalid project configuration: only Gerrit admin can set parent");
                                continue;
                            }
                            if (projectCache.get(newParent) == null) {
                                reject(cmd, "invalid project configuration: parent does not exist");
                                continue;
                            }
                        }
                        for (Entry<ProjectConfigEntry> e : pluginConfigEntries) {
                            PluginConfig pluginCfg = cfg.getPluginConfig(e.getPluginName());
                            ProjectConfigEntry configEntry = e.getProvider().get();
                            String value = pluginCfg.getString(e.getExportName());
                            String oldValue = projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getString(e.getExportName());
                            if (configEntry.getType() == ProjectConfigEntry.Type.ARRAY) {
                                List<String> l = Arrays.asList(projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getStringList(e.getExportName()));
                                oldValue = Joiner.on("\n").join(l);
                            }
                            if ((value == null ? oldValue != null : !value.equals(oldValue)) && !configEntry.isEditable(projectControl.getProjectState())) {
                                reject(cmd, String.format("invalid project configuration: Not allowed to set parameter" + " '%s' of plugin '%s' on project '%s'.", e.getExportName(), e.getPluginName(), project.getName()));
                                continue;
                            }
                            if (ProjectConfigEntry.Type.LIST.equals(configEntry.getType()) && value != null && !configEntry.getPermittedValues().contains(value)) {
                                reject(cmd, String.format("invalid project configuration: The value '%s' is " + "not permitted for parameter '%s' of plugin '%s'.", value, e.getExportName(), e.getPluginName()));
                            }
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#end_block

#method_before
private void parseCreate(final ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    rp.getRevWalk().reset();
    if (ctl.canCreate(db, rp.getRevWalk(), obj)) {
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        reject(cmd);
    }
}
#method_after
private void parseCreate(ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    rp.getRevWalk().reset();
    if (ctl.canCreate(db, rp.getRevWalk(), obj)) {
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        reject(cmd);
    }
}
#end_block

#method_before
private void parseUpdate(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canUpdate()) {
        if (isHead(cmd) && !isCommit(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        if (RefNames.REFS_CONFIG.equals(ctl.getRefName())) {
            errors.put(Error.CONFIG_UPDATE, RefNames.REFS_CONFIG);
        } else {
            errors.put(Error.UPDATE, ctl.getRefName());
        }
        reject(cmd);
    }
}
#method_after
private void parseUpdate(ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canUpdate()) {
        if (isHead(cmd) && !isCommit(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        if (RefNames.REFS_CONFIG.equals(ctl.getRefName())) {
            errors.put(Error.CONFIG_UPDATE, RefNames.REFS_CONFIG);
        } else {
            errors.put(Error.UPDATE, ctl.getRefName());
        }
        reject(cmd);
    }
}
#end_block

#method_before
private boolean isCommit(final ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName(), err);
        reject(cmd, "invalid object");
        return false;
    }
    if (obj instanceof RevCommit) {
        return true;
    } else {
        reject(cmd, "not a commit");
        return false;
    }
}
#method_after
private boolean isCommit(ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName(), err);
        reject(cmd, "invalid object");
        return false;
    }
    if (obj instanceof RevCommit) {
        return true;
    }
    reject(cmd, "not a commit");
    return false;
}
#end_block

#method_before
private void parseDelete(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.getRefName().startsWith(REFS_CHANGES)) {
        errors.put(Error.DELETE_CHANGES, ctl.getRefName());
        reject(cmd, "cannot delete changes");
    } else if (ctl.canDelete()) {
        batch.addCommand(cmd);
    } else {
        if (RefNames.REFS_CONFIG.equals(ctl.getRefName())) {
            reject(cmd, "cannot delete project configuration");
        } else {
            errors.put(Error.DELETE, ctl.getRefName());
            reject(cmd, "cannot delete references");
        }
    }
}
#method_after
private void parseDelete(ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.getRefName().startsWith(REFS_CHANGES)) {
        errors.put(Error.DELETE_CHANGES, ctl.getRefName());
        reject(cmd, "cannot delete changes");
    } else if (ctl.canDelete()) {
        batch.addCommand(cmd);
    } else {
        if (RefNames.REFS_CONFIG.equals(ctl.getRefName())) {
            reject(cmd, "cannot delete project configuration");
        } else {
            errors.put(Error.DELETE, ctl.getRefName());
            reject(cmd, "cannot delete references");
        }
    }
}
#end_block

#method_before
private void parseRewind(final ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
        batch.setAllowNonFastForwards(true).addCommand(cmd);
    } else {
        cmd.setResult(REJECTED_NONFASTFORWARD, " need '" + PermissionRule.FORCE_PUSH + "' privilege.");
    }
}
#method_after
private void parseRewind(ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
        batch.setAllowNonFastForwards(true).addCommand(cmd);
    } else {
        cmd.setResult(REJECTED_NONFASTFORWARD, " need '" + PermissionRule.FORCE_PUSH + "' privilege.");
    }
}
#end_block

#method_before
@Option(name = "--label", aliases = { "-l" }, metaVar = "LABEL+VALUE", usage = "label(s) to assign (defaults to +1 if no value provided")
void addLabel(final String token) throws CmdLineException {
    LabelVote v = LabelVote.parse(token);
    try {
        LabelType.checkName(v.label());
        ApprovalsUtil.checkLabel(labelTypes, v.label(), v.value());
    } catch (IllegalArgumentException e) {
        throw clp.reject(e.getMessage());
    }
    labels.put(v.label(), v.value());
}
#method_after
@Option(name = "--label", aliases = { "-l" }, metaVar = "LABEL+VALUE", usage = "label(s) to assign (defaults to +1 if no value provided")
void addLabel(String token) throws CmdLineException {
    LabelVote v = LabelVote.parse(token);
    try {
        LabelType.checkName(v.label());
        ApprovalsUtil.checkLabel(labelTypes, v.label(), v.value());
    } catch (IllegalArgumentException e) {
        throw clp.reject(e.getMessage());
    }
    labels.put(v.label(), v.value());
}
#end_block

#method_before
@Option(name = "--hashtag", aliases = { "-t" }, metaVar = "HASHTAG", usage = "add hashtag to changes")
void addHashtag(String token) throws CmdLineException {
    if (!notesMigration.enabled()) {
        throw clp.reject("cannot add hashtags; noteDb is disabled");
    }
    String hashtag = cleanupHashtag(token);
    if (!hashtag.isEmpty()) {
        hashtags.add(hashtag);
    }
// TODO(dpursehouse): validate hashtags
}
#method_after
@Option(name = "--hashtag", aliases = { "-t" }, metaVar = "HASHTAG", usage = "add hashtag to changes")
void addHashtag(String token) throws CmdLineException {
    if (!notesMigration.readChanges()) {
        throw clp.reject("cannot add hashtags; noteDb is disabled");
    }
    String hashtag = cleanupHashtag(token);
    if (!hashtag.isEmpty()) {
        hashtags.add(hashtag);
    }
// TODO(dpursehouse): validate hashtags
}
#end_block

#method_before
private void parseMagicBranch(final ReceiveCommand cmd) {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    magicBranch = new MagicBranchInput(cmd, labelTypes, notesMigration);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    magicBranch.clp = clp;
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet());
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    if (!magicBranch.ctl.canWrite()) {
        reject(cmd, "project is read only");
        return;
    }
    if (magicBranch.draft) {
        if (!receiveConfig.allowDrafts) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "draft workflow is disabled");
            return;
        } else if (projectControl.controlForRef("refs/drafts/" + ref).isBlocked(Permission.PUSH)) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "cannot upload drafts");
            return;
        }
    }
    if (!magicBranch.ctl.canUpload()) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload review");
        return;
    }
    if (magicBranch.draft && magicBranch.submit) {
        reject(cmd, "cannot submit draft");
        return;
    }
    if (magicBranch.submit && !projectControl.controlForRef(MagicBranch.NEW_CHANGE + ref).canSubmit()) {
        reject(cmd, "submit not allowed");
        return;
    }
    RevWalk walk = rp.getRevWalk();
    RevCommit tip;
    try {
        tip = walk.parseCommit(magicBranch.cmd.getNewId());
    } catch (IOException ex) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", ex);
        return;
    }
    // if %base was specified, ignore newChangeForAllNotInTarget
    if (tip.getParentCount() > 1 || magicBranch.base != null || tip.getParentCount() == 0) {
        newChangeForAllNotInTarget = false;
    }
    if (magicBranch.base != null) {
        magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
        for (ObjectId id : magicBranch.base) {
            try {
                magicBranch.baseCommit.add(walk.parseCommit(id));
            } catch (IncorrectObjectTypeException notCommit) {
                reject(cmd, "base must be a commit");
                return;
            } catch (MissingObjectException e) {
                reject(cmd, "base not found");
                return;
            } catch (IOException e) {
                log.warn(String.format("Project %s cannot read %s", project.getName(), id.name()), e);
                reject(cmd, "internal server error");
                return;
            }
        }
    } else if (newChangeForAllNotInTarget) {
        String destBranch = magicBranch.dest.get();
        try {
            Ref r = repo.getRefDatabase().exactRef(destBranch);
            if (r == null) {
                reject(cmd, destBranch + " not found");
                return;
            }
            ObjectId baseHead = r.getObjectId();
            magicBranch.baseCommit = Collections.singletonList(walk.parseCommit(baseHead));
        } catch (IOException ex) {
            log.warn(String.format("Project %s cannot read %s", project.getName(), destBranch), ex);
            reject(cmd, "internal server error");
            return;
        }
    }
    // 
    try {
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
    }
}
#method_after
private void parseMagicBranch(ReceiveCommand cmd) {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    magicBranch = new MagicBranchInput(cmd, labelTypes, notesMigration);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    magicBranch.clp = clp;
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet());
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (projectControl.getProjectState().isAllUsers() && RefNames.REFS_USERS_SELF.equals(ref)) {
        ref = RefNames.refsUsers(user.getAccountId());
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    if (!magicBranch.ctl.canWrite()) {
        reject(cmd, "project is read only");
        return;
    }
    if (magicBranch.draft) {
        if (!receiveConfig.allowDrafts) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "draft workflow is disabled");
            return;
        } else if (projectControl.controlForRef("refs/drafts/" + ref).isBlocked(Permission.PUSH)) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "cannot upload drafts");
            return;
        }
    }
    if (!magicBranch.ctl.canUpload()) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload review");
        return;
    }
    if (magicBranch.draft && magicBranch.submit) {
        reject(cmd, "cannot submit draft");
        return;
    }
    if (magicBranch.submit && !projectControl.controlForRef(MagicBranch.NEW_CHANGE + ref).canSubmit()) {
        reject(cmd, "submit not allowed");
        return;
    }
    RevWalk walk = rp.getRevWalk();
    RevCommit tip;
    try {
        tip = walk.parseCommit(magicBranch.cmd.getNewId());
    } catch (IOException ex) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", ex);
        return;
    }
    // if %base was specified, ignore newChangeForAllNotInTarget
    if (tip.getParentCount() > 1 || magicBranch.base != null || tip.getParentCount() == 0) {
        newChangeForAllNotInTarget = false;
    }
    if (magicBranch.base != null) {
        magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
        for (ObjectId id : magicBranch.base) {
            try {
                magicBranch.baseCommit.add(walk.parseCommit(id));
            } catch (IncorrectObjectTypeException notCommit) {
                reject(cmd, "base must be a commit");
                return;
            } catch (MissingObjectException e) {
                reject(cmd, "base not found");
                return;
            } catch (IOException e) {
                log.warn(String.format("Project %s cannot read %s", project.getName(), id.name()), e);
                reject(cmd, "internal server error");
                return;
            }
        }
    } else if (newChangeForAllNotInTarget) {
        String destBranch = magicBranch.dest.get();
        try {
            Ref r = repo.getRefDatabase().exactRef(destBranch);
            if (r == null) {
                reject(cmd, destBranch + " not found");
                return;
            }
            ObjectId baseHead = r.getObjectId();
            magicBranch.baseCommit = Collections.singletonList(walk.parseCommit(baseHead));
        } catch (IOException ex) {
            log.warn(String.format("Project %s cannot read %s", project.getName(), destBranch), ex);
            reject(cmd, "internal server error");
            return;
        }
    }
    // 
    try {
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        RevCommit h = walk.parseCommit(targetRef.getObjectId());
        RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
    }
}
#end_block

#method_before
private void parseReplaceCommand(final ReceiveCommand cmd, final Change.Id changeId) {
    if (cmd.getType() != ReceiveCommand.Type.CREATE) {
        reject(cmd, "invalid usage");
        return;
    }
    final RevCommit newCommit;
    try {
        newCommit = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IOException e) {
        log.error("Cannot parse " + cmd.getNewId().name() + " as commit", e);
        reject(cmd, "invalid commit");
        return;
    }
    final Change changeEnt;
    try {
        changeEnt = notesFactory.createChecked(db, project.getNameKey(), changeId).getChange();
    } catch (OrmException e) {
        log.error("Cannot lookup existing change " + changeId, e);
        reject(cmd, "database error");
        return;
    } catch (NoSuchChangeException e) {
        log.error("Change not found " + changeId, e);
        reject(cmd, "change " + changeId + " not found");
        return;
    }
    if (!project.getNameKey().equals(changeEnt.getProject())) {
        reject(cmd, "change " + changeId + " does not belong to project " + project.getName());
        return;
    }
    requestReplace(cmd, true, changeEnt, newCommit);
}
#method_after
private void parseReplaceCommand(ReceiveCommand cmd, Change.Id changeId) {
    if (cmd.getType() != ReceiveCommand.Type.CREATE) {
        reject(cmd, "invalid usage");
        return;
    }
    RevCommit newCommit;
    try {
        newCommit = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IOException e) {
        log.error("Cannot parse " + cmd.getNewId().name() + " as commit", e);
        reject(cmd, "invalid commit");
        return;
    }
    Change changeEnt;
    try {
        changeEnt = notesFactory.createChecked(db, project.getNameKey(), changeId).getChange();
    } catch (OrmException e) {
        log.error("Cannot lookup existing change " + changeId, e);
        reject(cmd, "database error");
        return;
    } catch (NoSuchChangeException e) {
        log.error("Change not found " + changeId, e);
        reject(cmd, "change " + changeId + " not found");
        return;
    }
    if (!project.getNameKey().equals(changeEnt.getProject())) {
        reject(cmd, "change " + changeId + " does not belong to project " + project.getName());
        return;
    }
    requestReplace(cmd, true, changeEnt, newCommit);
}
#end_block

#method_before
private boolean requestReplace(final ReceiveCommand cmd, final boolean checkMergedInto, final Change change, final RevCommit newCommit) {
    if (change.getStatus().isClosed()) {
        reject(cmd, "change " + canonicalWebUrl + change.getId() + " closed");
        return false;
    }
    final ReplaceRequest req = new ReplaceRequest(change.getId(), newCommit, cmd, checkMergedInto);
    if (replaceByChange.containsKey(req.ontoChange)) {
        reject(cmd, "duplicate request");
        return false;
    }
    replaceByChange.put(req.ontoChange, req);
    return true;
}
#method_after
private boolean requestReplace(ReceiveCommand cmd, boolean checkMergedInto, Change change, RevCommit newCommit) {
    if (change.getStatus().isClosed()) {
        reject(cmd, "change " + canonicalWebUrl + change.getId() + " closed");
        return false;
    }
    ReplaceRequest req = new ReplaceRequest(change.getId(), newCommit, cmd, checkMergedInto);
    if (replaceByChange.containsKey(req.ontoChange)) {
        reject(cmd, "duplicate request");
        return false;
    }
    replaceByChange.put(req.ontoChange, req);
    return true;
}
#end_block

#method_before
private void selectNewAndReplacedChangesFromMagicBranch() {
    newChanges = Lists.newArrayList();
    SetMultimap<ObjectId, Ref> existing = changeRefsById();
    GroupCollector groupCollector = GroupCollector.create(refsById, db, psUtil, notesFactory, project.getNameKey());
    rp.getRevWalk().reset();
    rp.getRevWalk().sort(RevSort.TOPO);
    rp.getRevWalk().sort(RevSort.REVERSE, true);
    try {
        rp.getRevWalk().markStart(rp.getRevWalk().parseCommit(magicBranch.cmd.getNewId()));
        if (magicBranch.baseCommit != null) {
            for (RevCommit c : magicBranch.baseCommit) {
                rp.getRevWalk().markUninteresting(c);
            }
            Ref targetRef = allRefs.get(magicBranch.ctl.getRefName());
            if (targetRef != null) {
                rp.getRevWalk().markUninteresting(rp.getRevWalk().parseCommit(targetRef.getObjectId()));
            }
        } else {
            markHeadsAsUninteresting(rp.getRevWalk(), magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
        }
        List<ChangeLookup> pending = Lists.newArrayList();
        final Set<Change.Key> newChangeIds = new HashSet<>();
        final int maxBatchChanges = receiveConfig.getEffectiveMaxBatchChangesLimit(user);
        for (; ; ) {
            final RevCommit c = rp.getRevWalk().next();
            if (c == null) {
                break;
            }
            groupCollector.visit(c);
            Collection<Ref> existingRefs = existing.get(c);
            if (!existingRefs.isEmpty()) {
                // A's group.
                for (Ref ref : existingRefs) {
                    updateGroups.add(new UpdateGroupsRequest(ref, c));
                }
                continue;
            }
            if (!validCommit(rp.getRevWalk(), magicBranch.ctl, magicBranch.cmd, c)) {
                // Not a change the user can propose? Abort as early as possible.
                newChanges = Collections.emptyList();
                return;
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
            }
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(c, magicBranch.dest.get()));
                continue;
            }
            final String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                newChanges = Collections.emptyList();
                return;
            }
            pending.add(new ChangeLookup(c, new Change.Key(idStr)));
            if (maxBatchChanges != 0 && pending.size() + newChanges.size() > maxBatchChanges) {
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                newChanges = Collections.emptyList();
                return;
            }
        }
        for (ChangeLookup p : pending) {
            if (newChangeIds.contains(p.changeKey)) {
                reject(magicBranch.cmd, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
                newChanges = Collections.emptyList();
                return;
            }
            List<ChangeData> changes = p.destChanges;
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 1) {
                // 
                if (requestReplace(magicBranch.cmd, false, changes.get(0).change(), p.commit)) {
                    continue;
                } else {
                    newChanges = Collections.emptyList();
                    return;
                }
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    newChanges = Collections.emptyList();
                    return;
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(p.commit, magicBranch.dest.get()));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        newChanges = Collections.emptyList();
        return;
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        newChanges = Collections.emptyList();
        return;
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return;
    }
    if (!newChanges.isEmpty() && magicBranch.edit) {
        reject(magicBranch.cmd, "edit is not supported for new changes");
        return;
    }
    try {
        SortedSetMultimap<ObjectId, String> groups = groupCollector.getGroups();
        for (CreateRequest create : newChanges) {
            batch.addCommand(create.cmd);
            create.groups = ImmutableList.copyOf(groups.get(create.commitId));
        }
        for (ReplaceRequest replace : replaceByChange.values()) {
            replace.groups = ImmutableList.copyOf(groups.get(replace.newCommitId));
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.groups = ImmutableList.copyOf((groups.get(update.commit)));
        }
    } catch (OrmException | NoSuchChangeException e) {
        log.error("Error collecting groups for changes", e);
        reject(magicBranch.cmd, "internal server error");
        return;
    }
}
#method_after
private void selectNewAndReplacedChangesFromMagicBranch() {
    newChanges = new ArrayList<>();
    SetMultimap<ObjectId, Ref> existing = changeRefsById();
    GroupCollector groupCollector = GroupCollector.create(refsById, db, psUtil, notesFactory, project.getNameKey());
    rp.getRevWalk().reset();
    rp.getRevWalk().sort(RevSort.TOPO);
    rp.getRevWalk().sort(RevSort.REVERSE, true);
    try {
        rp.getRevWalk().markStart(rp.getRevWalk().parseCommit(magicBranch.cmd.getNewId()));
        if (magicBranch.baseCommit != null) {
            for (RevCommit c : magicBranch.baseCommit) {
                rp.getRevWalk().markUninteresting(c);
            }
            Ref targetRef = allRefs.get(magicBranch.ctl.getRefName());
            if (targetRef != null) {
                rp.getRevWalk().markUninteresting(rp.getRevWalk().parseCommit(targetRef.getObjectId()));
            }
        } else {
            markHeadsAsUninteresting(rp.getRevWalk(), magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
        }
        List<ChangeLookup> pending = new ArrayList<>();
        Set<Change.Key> newChangeIds = new HashSet<>();
        int maxBatchChanges = receiveConfig.getEffectiveMaxBatchChangesLimit(user);
        for (; ; ) {
            RevCommit c = rp.getRevWalk().next();
            if (c == null) {
                break;
            }
            groupCollector.visit(c);
            Collection<Ref> existingRefs = existing.get(c);
            if (!existingRefs.isEmpty()) {
                // A's group.
                for (Ref ref : existingRefs) {
                    updateGroups.add(new UpdateGroupsRequest(ref, c));
                }
                continue;
            }
            if (!validCommit(rp.getRevWalk(), magicBranch.ctl, magicBranch.cmd, c)) {
                // Not a change the user can propose? Abort as early as possible.
                newChanges = Collections.emptyList();
                return;
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
            }
            List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(c, magicBranch.dest.get()));
                continue;
            }
            String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                newChanges = Collections.emptyList();
                return;
            }
            pending.add(new ChangeLookup(c, new Change.Key(idStr)));
            if (maxBatchChanges != 0 && pending.size() + newChanges.size() > maxBatchChanges) {
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                newChanges = Collections.emptyList();
                return;
            }
        }
        for (ChangeLookup p : pending) {
            if (newChangeIds.contains(p.changeKey)) {
                reject(magicBranch.cmd, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
                newChanges = Collections.emptyList();
                return;
            }
            List<ChangeData> changes = p.destChanges;
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 1) {
                // 
                if (requestReplace(magicBranch.cmd, false, changes.get(0).change(), p.commit)) {
                    continue;
                }
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    newChanges = Collections.emptyList();
                    return;
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(p.commit, magicBranch.dest.get()));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        newChanges = Collections.emptyList();
        return;
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        newChanges = Collections.emptyList();
        return;
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return;
    }
    if (!newChanges.isEmpty() && magicBranch.edit) {
        reject(magicBranch.cmd, "edit is not supported for new changes");
        return;
    }
    try {
        SortedSetMultimap<ObjectId, String> groups = groupCollector.getGroups();
        for (CreateRequest create : newChanges) {
            batch.addCommand(create.cmd);
            create.groups = ImmutableList.copyOf(groups.get(create.commitId));
        }
        for (ReplaceRequest replace : replaceByChange.values()) {
            replace.groups = ImmutableList.copyOf(groups.get(replace.newCommitId));
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.groups = ImmutableList.copyOf((groups.get(update.commit)));
        }
    } catch (OrmException | NoSuchChangeException e) {
        log.error("Error collecting groups for changes", e);
        reject(magicBranch.cmd, "internal server error");
        return;
    }
}
#end_block

#method_before
private void insertChange(RequestState state) throws OrmException, IOException, RestApiException, UpdateException, NoSuchChangeException {
    RevCommit commit = state.rw.parseCommit(commitId);
    state.rw.parseBody(commit);
    final PatchSet.Id psId = ins.setGroups(groups).getPatchSetId();
    final Account.Id me = user.getAccountId();
    final List<FooterLine> footerLines = commit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    Map<String, Short> approvals = new HashMap<>();
    checkNotNull(magicBranch);
    recipients.add(magicBranch.getMailRecipients());
    approvals = magicBranch.labels;
    recipients.add(getRecipientsFromFooters(accountResolver, magicBranch.draft, footerLines));
    recipients.remove(me);
    StringBuilder msg = new StringBuilder(ApprovalsUtil.renderMessageWithApprovals(psId.get(), approvals, Collections.<String, PatchSetApproval>emptyMap()));
    if (!Strings.isNullOrEmpty(magicBranch.message)) {
        msg.append("\n").append(magicBranch.message);
    }
    try (BatchUpdate bu = batchUpdateFactory.create(state.db, magicBranch.dest.getParentKey(), user, TimeUtil.nowTs())) {
        bu.setRepository(state.repo, state.rw, state.ins);
        bu.insertChange(ins.setReviewers(recipients.getReviewers()).setExtraCC(recipients.getCcOnly()).setApprovals(approvals).setMessage(msg.toString()).setNotify(magicBranch.notify).setRequestScopePropagator(requestScopePropagator).setSendMail(true).setUpdateRef(true));
        bu.addOp(changeId, hashtagsFactory.create(new HashtagsInput(magicBranch.hashtags)).setRunHooks(false));
        if (!Strings.isNullOrEmpty(magicBranch.topic)) {
            bu.addOp(changeId, new BatchUpdate.Op() {

                @Override
                public boolean updateChange(ChangeContext ctx) {
                    ctx.getUpdate(psId).setTopic(magicBranch.topic);
                    return true;
                }
            });
        }
        bu.execute();
    }
    change = ins.getChange();
    if (magicBranch.submit) {
        submit(projectControl.controlFor(state.db, change), ins.getPatchSet());
    }
}
#method_after
private void insertChange(RequestState state) throws OrmException, IOException, RestApiException, UpdateException, NoSuchChangeException {
    RevCommit commit = state.rw.parseCommit(commitId);
    state.rw.parseBody(commit);
    final PatchSet.Id psId = ins.setGroups(groups).getPatchSetId();
    Account.Id me = user.getAccountId();
    List<FooterLine> footerLines = commit.getFooterLines();
    MailRecipients recipients = new MailRecipients();
    Map<String, Short> approvals = new HashMap<>();
    checkNotNull(magicBranch);
    recipients.add(magicBranch.getMailRecipients());
    approvals = magicBranch.labels;
    recipients.add(getRecipientsFromFooters(accountResolver, magicBranch.draft, footerLines));
    recipients.remove(me);
    StringBuilder msg = new StringBuilder(ApprovalsUtil.renderMessageWithApprovals(psId.get(), approvals, Collections.<String, PatchSetApproval>emptyMap()));
    if (!Strings.isNullOrEmpty(magicBranch.message)) {
        msg.append("\n").append(magicBranch.message);
    }
    try (BatchUpdate bu = batchUpdateFactory.create(state.db, magicBranch.dest.getParentKey(), user, TimeUtil.nowTs())) {
        bu.setRepository(state.repo, state.rw, state.ins);
        bu.insertChange(ins.setReviewers(recipients.getReviewers()).setExtraCC(recipients.getCcOnly()).setApprovals(approvals).setMessage(msg.toString()).setNotify(magicBranch.notify).setRequestScopePropagator(requestScopePropagator).setSendMail(true).setUpdateRef(true));
        if (!magicBranch.hashtags.isEmpty()) {
            bu.addOp(changeId, hashtagsFactory.create(new HashtagsInput(magicBranch.hashtags)).setRunHooks(false));
        }
        if (!Strings.isNullOrEmpty(magicBranch.topic)) {
            bu.addOp(changeId, new BatchUpdate.Op() {

                @Override
                public boolean updateChange(ChangeContext ctx) {
                    ctx.getUpdate(psId).setTopic(magicBranch.topic);
                    return true;
                }
            });
        }
        bu.execute();
    }
    change = ins.getChange();
    if (magicBranch.submit) {
        submit(projectControl.controlFor(state.db, change), ins.getPatchSet());
    }
}
#end_block

#method_before
boolean validate(boolean autoClose) throws IOException, OrmException {
    if (!autoClose && inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    } else if (change == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    priorPatchSet = change.currentPatchSetId();
    if (!revisions.containsValue(priorPatchSet)) {
        reject(inputCommand, "change " + ontoChange + " missing revisions");
        return false;
    }
    RevCommit newCommit = rp.getRevWalk().parseCommit(newCommitId);
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    if (newCommit.equals(priorCommit)) {
        // Ignore requests to make the change its current state.
        skip = true;
        reject(inputCommand, "commit already exists (as current patchset)");
        return false;
    }
    changeCtl = projectControl.controlFor(db, change);
    if (!changeCtl.canAddPatchSet(db)) {
        String locked = ".";
        if (changeCtl.isPatchSetLocked(db)) {
            locked = ". Change is patch set locked.";
        }
        reject(inputCommand, "cannot replace " + ontoChange + locked);
        return false;
    } else if (change.getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    } else if (revisions.containsKey(newCommit)) {
        reject(inputCommand, "commit already exists (in the change)");
        return false;
    }
    for (final Ref r : rp.getRepository().getRefDatabase().getRefs("refs/changes").values()) {
        if (r.getObjectId().equals(newCommit)) {
            reject(inputCommand, "commit already exists (in the project)");
            return false;
        }
    }
    for (RevCommit prior : revisions.keySet()) {
        // amending when trying to address review comments.
        if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
            reject(inputCommand, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
            return false;
        }
    }
    if (!validCommit(rp.getRevWalk(), changeCtl.getRefControl(), inputCommand, newCommit)) {
        return false;
    }
    rp.getRevWalk().parseBody(priorCommit);
    // of the commit was modified.
    if (newCommit.getTree().equals(priorCommit.getTree())) {
        final boolean messageEq = eq(newCommit.getFullMessage(), priorCommit.getFullMessage());
        final boolean parentsEq = parentsEqual(newCommit, priorCommit);
        final boolean authorEq = authorEqual(newCommit, priorCommit);
        final ObjectReader reader = rp.getRevWalk().getObjectReader();
        if (messageEq && parentsEq && authorEq && !autoClose) {
            addMessage(String.format("(W) No changes between prior commit %s and new commit %s", reader.abbreviate(priorCommit).name(), reader.abbreviate(newCommit).name()));
        } else {
            StringBuilder msg = new StringBuilder();
            msg.append("(W) ");
            msg.append(reader.abbreviate(newCommit).name());
            msg.append(":");
            msg.append(" no files changed");
            if (!authorEq) {
                msg.append(", author changed");
            }
            if (!messageEq) {
                msg.append(", message updated");
            }
            if (!parentsEq) {
                msg.append(", was rebased");
            }
            addMessage(msg.toString());
        }
    }
    if (magicBranch != null && magicBranch.edit) {
        return newEdit();
    }
    newPatchSet();
    return true;
}
#method_after
boolean validate(boolean autoClose) throws IOException, OrmException {
    if (!autoClose && inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    } else if (change == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    priorPatchSet = change.currentPatchSetId();
    if (!revisions.containsValue(priorPatchSet)) {
        reject(inputCommand, "change " + ontoChange + " missing revisions");
        return false;
    }
    RevCommit newCommit = rp.getRevWalk().parseCommit(newCommitId);
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    if (newCommit.equals(priorCommit)) {
        // Ignore requests to make the change its current state.
        skip = true;
        reject(inputCommand, "commit already exists (as current patchset)");
        return false;
    }
    changeCtl = projectControl.controlFor(db, change);
    if (!changeCtl.canAddPatchSet(db)) {
        String locked = ".";
        if (changeCtl.isPatchSetLocked(db)) {
            locked = ". Change is patch set locked.";
        }
        reject(inputCommand, "cannot replace " + ontoChange + locked);
        return false;
    } else if (change.getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    } else if (revisions.containsKey(newCommit)) {
        reject(inputCommand, "commit already exists (in the change)");
        return false;
    }
    for (Ref r : rp.getRepository().getRefDatabase().getRefs("refs/changes").values()) {
        if (r.getObjectId().equals(newCommit)) {
            reject(inputCommand, "commit already exists (in the project)");
            return false;
        }
    }
    for (RevCommit prior : revisions.keySet()) {
        // amending when trying to address review comments.
        if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
            reject(inputCommand, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
            return false;
        }
    }
    if (!validCommit(rp.getRevWalk(), changeCtl.getRefControl(), inputCommand, newCommit)) {
        return false;
    }
    rp.getRevWalk().parseBody(priorCommit);
    // of the commit was modified.
    if (newCommit.getTree().equals(priorCommit.getTree())) {
        boolean messageEq = eq(newCommit.getFullMessage(), priorCommit.getFullMessage());
        boolean parentsEq = parentsEqual(newCommit, priorCommit);
        boolean authorEq = authorEqual(newCommit, priorCommit);
        ObjectReader reader = rp.getRevWalk().getObjectReader();
        if (messageEq && parentsEq && authorEq && !autoClose) {
            addMessage(String.format("(W) No changes between prior commit %s and new commit %s", reader.abbreviate(priorCommit).name(), reader.abbreviate(newCommit).name()));
        } else {
            StringBuilder msg = new StringBuilder();
            msg.append("(I) ");
            msg.append(reader.abbreviate(newCommit).name());
            msg.append(":");
            msg.append(" no files changed");
            if (!authorEq) {
                msg.append(", author changed");
            }
            if (!messageEq) {
                msg.append(", message updated");
            }
            if (!parentsEq) {
                msg.append(", was rebased");
            }
            addMessage(msg.toString());
        }
    }
    if (magicBranch != null && magicBranch.edit) {
        return newEdit();
    }
    newPatchSet();
    return true;
}
#end_block

#method_before
PatchSet.Id insertPatchSet(RequestState state) throws OrmException, IOException, RestApiException, UpdateException, NoSuchChangeException {
    RevCommit newCommit = state.rw.parseCommit(newCommitId);
    state.rw.parseBody(newCommit);
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    ReplaceOp replaceOp = replaceOpFactory.create(requestScopePropagator, projectControl, checkMergedInto, priorPatchSet, priorCommit, psId, newCommit, info, groups, magicBranch, rp.getPushCertificate());
    try (BatchUpdate bu = batchUpdateFactory.create(state.db, project.getNameKey(), user, TimeUtil.nowTs())) {
        bu.setRepository(state.repo, state.rw, state.ins);
        bu.addOp(change.getId(), replaceOp);
        bu.execute();
    }
    if (replaceOp.getRejectMessage() != null) {
        reject(inputCommand, replaceOp.getRejectMessage());
        return null;
    }
    groups = replaceOp.getGroups();
    // TODO(ekempin): mark changes as merged inside of ReplaceOp
    if (replaceOp.getMergedIntoRef() != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, info, replaceOp.getMergedIntoRef());
    }
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    PatchSet newPatchSet = replaceOp.getPatchSet();
    gitRefUpdated.fire(project.getNameKey(), newPatchSet.getRefName(), ObjectId.zeroId(), newCommit);
    if (magicBranch != null && magicBranch.submit) {
        submit(changeCtl, newPatchSet);
    }
    return newPatchSet.getId();
}
#method_after
PatchSet.Id insertPatchSet(RequestState state) throws OrmException, IOException, RestApiException, UpdateException, NoSuchChangeException {
    RevCommit newCommit = state.rw.parseCommit(newCommitId);
    state.rw.parseBody(newCommit);
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    ReplaceOp replaceOp = replaceOpFactory.create(requestScopePropagator, projectControl, checkMergedInto, priorPatchSet, priorCommit, psId, newCommit, info, groups, magicBranch, rp.getPushCertificate());
    try (BatchUpdate bu = batchUpdateFactory.create(state.db, project.getNameKey(), user, TimeUtil.nowTs())) {
        bu.setRepository(state.repo, state.rw, state.ins);
        bu.addOp(change.getId(), replaceOp);
        bu.execute();
    }
    if (replaceOp.getRejectMessage() != null) {
        reject(inputCommand, replaceOp.getRejectMessage());
        return null;
    }
    groups = replaceOp.getGroups();
    // TODO(ekempin): mark changes as merged inside of ReplaceOp
    if (replaceOp.getMergedIntoRef() != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, info, replaceOp.getMergedIntoRef());
    }
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    PatchSet newPatchSet = replaceOp.getPatchSet();
    gitRefUpdated.fire(project.getNameKey(), newPatchSet.getRefName(), ObjectId.zeroId(), newCommit, user.getAccount());
    if (magicBranch != null && magicBranch.submit) {
        submit(changeCtl, newPatchSet);
    }
    return newPatchSet.getId();
}
#end_block

#method_before
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    if (ctl.canForgeAuthor() && ctl.canForgeCommitter() && ctl.canForgeGerritServerIdentity() && ctl.canUploadMerges() && !projectControl.getProjectState().isUseSignedOffBy() && Iterables.isEmpty(rejectCommits) && !RefNames.REFS_CONFIG.equals(ctl.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        return;
    }
    boolean defaultName = Strings.isNullOrEmpty(user.getAccount().getFullName());
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        RevObject parsedObject = walk.parseAny(cmd.getNewId());
        if (!(parsedObject instanceof RevCommit)) {
            return;
        }
        walk.markStart((RevCommit) parsedObject);
        markHeadsAsUninteresting(walk, cmd.getRefName());
        Set<ObjectId> existing = changeRefsById().keySet();
        for (RevCommit c; (c = walk.next()) != null; ) {
            if (existing.contains(c)) {
                continue;
            } else if (!validCommit(walk, ctl, cmd, c)) {
                break;
            }
            if (defaultName && user.hasEmailAddress(c.getCommitterIdent().getEmailAddress())) {
                try {
                    Account a = db.accounts().get(user.getAccountId());
                    if (a != null && Strings.isNullOrEmpty(a.getFullName())) {
                        a.setFullName(c.getCommitterIdent().getName());
                        db.accounts().update(Collections.singleton(a));
                        user.getAccount().setFullName(a.getFullName());
                        accountCache.evict(a.getId());
                    }
                } catch (OrmException e) {
                    log.warn("Cannot default full_name", e);
                } finally {
                    defaultName = false;
                }
            }
        }
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#method_after
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    if (ctl.canForgeAuthor() && ctl.canForgeCommitter() && ctl.canForgeGerritServerIdentity() && ctl.canUploadMerges() && !projectControl.getProjectState().isUseSignedOffBy() && Iterables.isEmpty(rejectCommits) && !RefNames.REFS_CONFIG.equals(ctl.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        return;
    }
    boolean defaultName = Strings.isNullOrEmpty(user.getAccount().getFullName());
    RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        RevObject parsedObject = walk.parseAny(cmd.getNewId());
        if (!(parsedObject instanceof RevCommit)) {
            return;
        }
        walk.markStart((RevCommit) parsedObject);
        markHeadsAsUninteresting(walk, cmd.getRefName());
        Set<ObjectId> existing = changeRefsById().keySet();
        for (RevCommit c; (c = walk.next()) != null; ) {
            if (existing.contains(c)) {
                continue;
            } else if (!validCommit(walk, ctl, cmd, c)) {
                break;
            }
            if (defaultName && user.hasEmailAddress(c.getCommitterIdent().getEmailAddress())) {
                try {
                    Account a = db.accounts().get(user.getAccountId());
                    if (a != null && Strings.isNullOrEmpty(a.getFullName())) {
                        a.setFullName(c.getCommitterIdent().getName());
                        db.accounts().update(Collections.singleton(a));
                        user.getAccount().setFullName(a.getFullName());
                        accountCache.evict(a.getId());
                    }
                } catch (OrmException e) {
                    log.warn("Cannot default full_name", e);
                } finally {
                    defaultName = false;
                }
            }
        }
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#end_block

#method_before
private void autoCloseChanges(final ReceiveCommand cmd) {
    final RevWalk rw = rp.getRevWalk();
    try {
        RevCommit newTip = rw.parseCommit(cmd.getNewId());
        Branch.NameKey branch = new Branch.NameKey(project.getNameKey(), cmd.getRefName());
        rw.reset();
        rw.markStart(newTip);
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final SetMultimap<ObjectId, Ref> byCommit = changeRefsById();
        Map<Change.Key, Change> byKey = null;
        final List<ReplaceRequest> toClose = new ArrayList<>();
        for (RevCommit c; (c = rw.next()) != null; ) {
            rw.parseBody(c);
            for (Ref ref : byCommit.get(c.copy())) {
                Change.Key closedChange = closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                closeProgress.update(1);
                if (closedChange != null) {
                    if (byKey == null) {
                        byKey = openChangesByBranch(branch);
                    }
                    byKey.remove(closedChange);
                }
            }
            for (final String changeId : c.getFooterLines(CHANGE_ID)) {
                if (byKey == null) {
                    byKey = openChangesByBranch(branch);
                }
                final Change onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    final ReplaceRequest req = new ReplaceRequest(onto.getId(), c, cmd, false);
                    req.change = onto;
                    toClose.add(req);
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = req.validate(true) ? req.insertPatchSet().checkedGet() : null;
            if (psi != null) {
                closeChange(req.inputCommand, psi, req.newCommitId);
                closeProgress.update(1);
            }
        }
    } catch (RestApiException e) {
        log.error("Can't insert patchset", e);
    } catch (IOException | OrmException | UpdateException e) {
        log.error("Can't scan for changes to close", e);
    }
}
#method_after
private void autoCloseChanges(final ReceiveCommand cmd) {
    RevWalk rw = rp.getRevWalk();
    try {
        RevCommit newTip = rw.parseCommit(cmd.getNewId());
        Branch.NameKey branch = new Branch.NameKey(project.getNameKey(), cmd.getRefName());
        rw.reset();
        rw.markStart(newTip);
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        SetMultimap<ObjectId, Ref> byCommit = changeRefsById();
        Map<Change.Key, Change> byKey = null;
        List<ReplaceRequest> toClose = new ArrayList<>();
        for (RevCommit c; (c = rw.next()) != null; ) {
            rw.parseBody(c);
            for (Ref ref : byCommit.get(c.copy())) {
                Change.Key closedChange = closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                closeProgress.update(1);
                if (closedChange != null) {
                    if (byKey == null) {
                        byKey = openChangesByBranch(branch);
                    }
                    byKey.remove(closedChange);
                }
            }
            for (String changeId : c.getFooterLines(CHANGE_ID)) {
                if (byKey == null) {
                    byKey = openChangesByBranch(branch);
                }
                Change onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    ReplaceRequest req = new ReplaceRequest(onto.getId(), c, cmd, false);
                    req.change = onto;
                    toClose.add(req);
                    break;
                }
            }
        }
        for (ReplaceRequest req : toClose) {
            PatchSet.Id psi = req.validate(true) ? req.insertPatchSet().checkedGet() : null;
            if (psi != null) {
                closeChange(req.inputCommand, psi, req.newCommitId);
                closeProgress.update(1);
            }
        }
    } catch (RestApiException e) {
        log.error("Can't insert patchset", e);
    } catch (IOException | OrmException | UpdateException e) {
        log.error("Can't scan for changes to close", e);
    }
}
#end_block

#method_before
private Map<Change.Key, Change> openChangesByBranch(Branch.NameKey branch) throws OrmException {
    final Map<Change.Key, Change> r = new HashMap<>();
    for (ChangeData cd : queryProvider.get().byBranchOpen(branch)) {
        r.put(cd.change().getKey(), cd.change());
    }
    return r;
}
#method_after
private Map<Change.Key, Change> openChangesByBranch(Branch.NameKey branch) throws OrmException {
    Map<Change.Key, Change> r = new HashMap<>();
    for (ChangeData cd : queryProvider.get().byBranchOpen(branch)) {
        r.put(cd.change().getKey(), cd.change());
    }
    return r;
}
#end_block

#method_before
private void markChangeMergedByPush(ReviewDb db, final PatchSetInfo info, final String mergedIntoRef) throws UpdateException, RestApiException {
    try (BatchUpdate bu = batchUpdateFactory.create(db, project.getNameKey(), user, TimeUtil.nowTs())) {
        bu.addOp(info.getKey().getParentKey(), new BatchUpdate.Op() {

            @Override
            public boolean updateChange(ChangeContext ctx) throws OrmException {
                Change change = ctx.getChange();
                ChangeUpdate update = ctx.getUpdate(info.getKey());
                if (change.getStatus().isOpen()) {
                    change.setCurrentPatchSet(info);
                    change.setStatus(Change.Status.MERGED);
                    ctx.saveChange();
                    // we cannot reconstruct the submit records for when this change was
                    // submitted, this is why we must fix the status
                    update.fixStatus(Change.Status.MERGED);
                }
                StringBuilder msgBuf = new StringBuilder();
                msgBuf.append("Change has been successfully pushed");
                if (!mergedIntoRef.equals(change.getDest().get())) {
                    msgBuf.append(" into ");
                    if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
                        msgBuf.append("branch ");
                        msgBuf.append(Repository.shortenRefName(mergedIntoRef));
                    } else {
                        msgBuf.append(mergedIntoRef);
                    }
                }
                msgBuf.append(".");
                ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(ctx.getDb())), user.getAccountId(), ctx.getWhen(), info.getKey());
                msg.setMessage(msgBuf.toString());
                cmUtil.addChangeMessage(ctx.getDb(), update, msg);
                PatchSetApproval submitter = new PatchSetApproval(new PatchSetApproval.Key(change.currentPatchSetId(), ctx.getUser().getAccountId(), LabelId.legacySubmit()), (short) 1, ctx.getWhen());
                update.putApproval(submitter.getLabel(), submitter.getValue());
                ctx.getDb().patchSetApprovals().upsert(Collections.singleton(submitter));
                return true;
            }
        });
        bu.execute();
    }
}
#method_after
private void markChangeMergedByPush(ReviewDb db, final PatchSetInfo info, final String mergedIntoRef) throws UpdateException, RestApiException {
    try (BatchUpdate bu = batchUpdateFactory.create(db, project.getNameKey(), user, TimeUtil.nowTs())) {
        bu.addOp(info.getKey().getParentKey(), new BatchUpdate.Op() {

            @Override
            public boolean updateChange(ChangeContext ctx) throws OrmException {
                Change change = ctx.getChange();
                ChangeUpdate update = ctx.getUpdate(info.getKey());
                if (change.getStatus().isOpen()) {
                    change.setCurrentPatchSet(info);
                    change.setStatus(Change.Status.MERGED);
                    // we cannot reconstruct the submit records for when this change was
                    // submitted, this is why we must fix the status
                    update.fixStatus(Change.Status.MERGED);
                }
                StringBuilder msgBuf = new StringBuilder();
                msgBuf.append("Change has been successfully pushed");
                if (!mergedIntoRef.equals(change.getDest().get())) {
                    msgBuf.append(" into ");
                    if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
                        msgBuf.append("branch ");
                        msgBuf.append(Repository.shortenRefName(mergedIntoRef));
                    } else {
                        msgBuf.append(mergedIntoRef);
                    }
                }
                msgBuf.append(".");
                ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(ctx.getDb())), user.getAccountId(), ctx.getWhen(), info.getKey());
                msg.setMessage(msgBuf.toString());
                cmUtil.addChangeMessage(ctx.getDb(), update, msg);
                PatchSetApproval submitter = new PatchSetApproval(new PatchSetApproval.Key(change.currentPatchSetId(), ctx.getUser().getAccountId(), LabelId.legacySubmit()), (short) 1, ctx.getWhen());
                update.putApproval(submitter.getLabel(), submitter.getValue());
                ctx.getDb().patchSetApprovals().upsert(Collections.singleton(submitter));
                return true;
            }
        });
        bu.execute();
    }
}
#end_block

#method_before
private void reject(final ReceiveCommand cmd) {
    reject(cmd, "prohibited by Gerrit");
}
#method_after
private void reject(ReceiveCommand cmd) {
    reject(cmd, "prohibited by Gerrit");
}
#end_block

#method_before
private void reject(final ReceiveCommand cmd, final String why) {
    cmd.setResult(REJECTED_OTHER_REASON, why);
    commandProgress.update(1);
}
#method_after
private void reject(ReceiveCommand cmd, String why) {
    cmd.setResult(REJECTED_OTHER_REASON, why);
    commandProgress.update(1);
}
#end_block

#method_before
private static boolean isHead(final ReceiveCommand cmd) {
    return cmd.getRefName().startsWith(Constants.R_HEADS);
}
#method_after
private static boolean isHead(ReceiveCommand cmd) {
    return cmd.getRefName().startsWith(Constants.R_HEADS);
}
#end_block

#method_before
private static boolean isConfig(final ReceiveCommand cmd) {
    return cmd.getRefName().equals(RefNames.REFS_CONFIG);
}
#method_after
private static boolean isConfig(ReceiveCommand cmd) {
    return cmd.getRefName().equals(RefNames.REFS_CONFIG);
}
#end_block

#method_before
private RequestState requestState(Thread caller) throws OrmException, IOException {
    if (caller == Thread.currentThread()) {
        return new RequestState(db, repo, rp.getRevWalk());
    } else {
        return new RequestState(project.getNameKey());
    }
}
#method_after
private RequestState requestState(Thread caller) throws OrmException, IOException {
    if (caller == Thread.currentThread()) {
        return new RequestState(db, repo, rp.getRevWalk());
    }
    return new RequestState(project.getNameKey());
}
#end_block

#method_before
protected void assertSubmittedTogether(String chId, String... expected) throws Exception {
    List<ChangeInfo> actual = gApi.changes().id(chId).submittedTogether();
    assertThat(actual).hasSize(expected.length);
    assertThat(Iterables.transform(actual, new Function<ChangeInfo, String>() {

        @Override
        public String apply(ChangeInfo input) {
            return input.changeId != null ? input.changeId : "null";
        }
    })).containsExactly((Object[]) expected).inOrder();
}
#method_after
protected void assertSubmittedTogether(String chId, String... expected) throws Exception {
    EnumSet<SubmittedTogetherOption> o = EnumSet.noneOf(SubmittedTogetherOption.class);
    assertSubmittedTogether(chId, o, expected);
}
#end_block

#method_before
protected void assertSubmittedTogether(String chId, String... expected) throws Exception {
    List<ChangeInfo> actual = gApi.changes().id(chId).submittedTogether();
    assertThat(actual).hasSize(expected.length);
    assertThat(Iterables.transform(actual, new Function<ChangeInfo, String>() {

        @Override
        public String apply(ChangeInfo input) {
            return input.changeId != null ? input.changeId : "null";
        }
    })).containsExactly((Object[]) expected).inOrder();
}
#method_after
protected void assertSubmittedTogether(String chId, EnumSet<SubmittedTogetherOption> o, String... expected) throws Exception {
    List<ChangeInfo> actual = gApi.changes().id(chId).submittedTogether(o);
    assertThat(actual).hasSize(expected.length);
    assertThat(Iterables.transform(actual, new Function<ChangeInfo, String>() {

        @Override
        public String apply(ChangeInfo input) {
            return input.changeId != null ? input.changeId : input.subject;
        }
    })).containsExactly((Object[]) expected).inOrder();
}
#end_block

#method_before
public ChangeSet completeChangeSet(ReviewDb db, Change change, CurrentUser user) throws MissingObjectException, IncorrectObjectTypeException, IOException, OrmException {
    ChangeData cd = changeDataFactory.create(db, change.getProject(), change.getId());
    cd.changeControl(user);
    if (Submit.wholeTopicEnabled(cfg)) {
        return completeChangeSetIncludingTopics(db, new ChangeSet(cd), user);
    }
    return completeChangeSetWithoutTopic(db, new ChangeSet(cd), user);
}
#method_after
public ChangeSet completeChangeSet(ReviewDb db, Change change, CurrentUser user) throws MissingObjectException, IncorrectObjectTypeException, IOException, OrmException {
    ChangeData cd = changeDataFactory.create(db, change.getProject(), change.getId());
    cd.changeControl(user);
    if (Submit.wholeTopicEnabled(cfg)) {
        return completeChangeSetIncludingTopics(db, new ChangeSet(cd, db, null), user);
    }
    return completeChangeSetWithoutTopic(db, new ChangeSet(cd, db, null), user);
}
#end_block

#method_before
private ChangeSet completeChangeSetWithoutTopic(ReviewDb db, ChangeSet changes, CurrentUser user) throws MissingObjectException, IncorrectObjectTypeException, IOException, OrmException {
    List<ChangeData> ret = new ArrayList<>();
    boolean furtherHiddenChanges = false;
    Multimap<Project.NameKey, Change.Id> pc = changes.changesByProject();
    for (Project.NameKey project : pc.keySet()) {
        try (Repository repo = repoManager.openRepository(project);
            RevWalk rw = CodeReviewCommit.newRevWalk(repo)) {
            for (Change.Id cId : pc.get(project)) {
                ChangeData cd = changeDataFactory.create(db, project, cId);
                cd.changeControl(user);
                SubmitTypeRecord str = cd.submitTypeRecord();
                if (cd.currentPatchSet().isDraft()) {
                    furtherHiddenChanges = true;
                    continue;
                }
                if (!str.isOk()) {
                    logErrorAndThrow("Failed to get submit type for " + cd.getId() + ": " + str.errorMessage);
                }
                if (str.type == SubmitType.CHERRY_PICK) {
                    ret.add(cd);
                    continue;
                }
                // Get the underlying git commit object
                PatchSet ps = cd.currentPatchSet();
                String objIdStr = ps.getRevision().get();
                RevCommit commit = rw.parseCommit(ObjectId.fromString(objIdStr));
                // Collect unmerged ancestors
                Branch.NameKey destBranch = cd.change().getDest();
                repo.getRefDatabase().refresh();
                Ref ref = repo.getRefDatabase().getRef(destBranch.get());
                rw.reset();
                rw.sort(RevSort.TOPO);
                rw.markStart(commit);
                if (ref != null) {
                    RevCommit head = rw.parseCommit(ref.getObjectId());
                    rw.markUninteresting(head);
                }
                List<String> hashes = new ArrayList<>();
                // Always include the input, even if merged. This allows
                // SubmitStrategyOp to correct the situation later, assuming it gets
                // returned by byCommitsOnBranchNotMerged below.
                hashes.add(objIdStr);
                for (RevCommit c : rw) {
                    if (!c.equals(commit)) {
                        hashes.add(c.name());
                    }
                }
                if (!hashes.isEmpty()) {
                    Iterable<ChangeData> destChanges = query().byCommitsOnBranchNotMerged(repo, db, cd.change().getDest(), hashes);
                    for (ChangeData chd : destChanges) {
                        ret.add(chd);
                    }
                }
            }
        }
    }
    return new ChangeSet(ret, furtherHiddenChanges);
}
#method_after
private ChangeSet completeChangeSetWithoutTopic(ReviewDb db, ChangeSet changes, CurrentUser user) throws MissingObjectException, IncorrectObjectTypeException, IOException, OrmException {
    List<ChangeData> ret = new ArrayList<>();
    Multimap<Project.NameKey, Change.Id> pc = changes.changesByProject();
    for (Project.NameKey project : pc.keySet()) {
        try (Repository repo = repoManager.openRepository(project);
            RevWalk rw = CodeReviewCommit.newRevWalk(repo)) {
            for (Change.Id cId : pc.get(project)) {
                ChangeData cd = changeDataFactory.create(db, project, cId);
                SubmitTypeRecord str = cd.submitTypeRecord();
                if (!str.isOk()) {
                    logErrorAndThrow("Failed to get submit type for " + cd.getId() + ": " + str.errorMessage);
                }
                if (str.type == SubmitType.CHERRY_PICK) {
                    ret.add(cd);
                    continue;
                }
                // Get the underlying git commit object
                PatchSet ps = cd.currentPatchSet();
                String objIdStr = ps.getRevision().get();
                RevCommit commit = rw.parseCommit(ObjectId.fromString(objIdStr));
                // Collect unmerged ancestors
                Branch.NameKey destBranch = cd.change().getDest();
                repo.getRefDatabase().refresh();
                Ref ref = repo.getRefDatabase().getRef(destBranch.get());
                rw.reset();
                rw.sort(RevSort.TOPO);
                rw.markStart(commit);
                if (ref != null) {
                    RevCommit head = rw.parseCommit(ref.getObjectId());
                    rw.markUninteresting(head);
                }
                List<String> hashes = new ArrayList<>();
                // Always include the input, even if merged. This allows
                // SubmitStrategyOp to correct the situation later, assuming it gets
                // returned by byCommitsOnBranchNotMerged below.
                hashes.add(objIdStr);
                for (RevCommit c : rw) {
                    if (!c.equals(commit)) {
                        hashes.add(c.name());
                    }
                }
                if (!hashes.isEmpty()) {
                    Iterable<ChangeData> destChanges = query().byCommitsOnBranchNotMerged(repo, db, cd.change().getDest(), hashes);
                    for (ChangeData chd : destChanges) {
                        ret.add(chd);
                    }
                }
            }
        }
    }
    return new ChangeSet(ret, db, user);
}
#end_block

#method_before
private ChangeSet completeChangeSetIncludingTopics(ReviewDb db, ChangeSet changes, CurrentUser user) throws MissingObjectException, IncorrectObjectTypeException, IOException, OrmException {
    Set<String> topicsTraversed = new HashSet<>();
    boolean done = false;
    ChangeSet newCs = completeChangeSetWithoutTopic(db, changes, user);
    while (!done) {
        List<ChangeData> chgs = new ArrayList<>();
        done = true;
        for (ChangeData cd : newCs.changes()) {
            chgs.add(cd);
            String topic = cd.change().getTopic();
            if (!Strings.isNullOrEmpty(topic) && !topicsTraversed.contains(topic)) {
                chgs.addAll(query().byTopicOpen(topic));
                done = false;
                topicsTraversed.add(topic);
            }
        }
        changes = new ChangeSet(chgs, newCs.isComplete());
        newCs = completeChangeSetWithoutTopic(db, changes, user);
    }
    return newCs;
}
#method_after
private ChangeSet completeChangeSetIncludingTopics(ReviewDb db, ChangeSet changes, CurrentUser user) throws MissingObjectException, IncorrectObjectTypeException, IOException, OrmException {
    Set<String> topicsTraversed = new HashSet<>();
    boolean done = false;
    while (!done) {
        done = true;
        List<ChangeData> newChgs = new ArrayList<>();
        for (ChangeData cd : changes.changes()) {
            newChgs.add(cd);
            String topic = cd.change().getTopic();
            if (!Strings.isNullOrEmpty(topic) && !topicsTraversed.contains(topic)) {
                newChgs.addAll(query().byTopicOpen(topic));
                done = false;
                topicsTraversed.add(topic);
            }
        }
        changes = completeChangeSetWithoutTopic(db, new ChangeSet(newChgs, db, null), null);
    }
    return completeChangeSetWithoutTopic(db, changes, user);
}
#end_block

#method_before
private InternalChangeQuery query() {
    // Request fields required for completing the ChangeSet without having to
    // touch the database. This provides reasonable performance when loading the
    // change screen; callers that care about reading the latest value of these
    // fields should clear them explicitly using reloadChanges().
    Set<String> fields = ImmutableSet.of(ChangeField.CHANGE.getName(), ChangeField.PATCH_SET.getName());
    return queryProvider.get().setRequestedFields(fields);
}
#method_after
private InternalChangeQuery query() {
    // Request fields required for completing the ChangeSet without having to
    // touch the database. This provides reasonable performance when loading the
    // change screen; callers that care about reading the latest value of these
    // fields should clear them explicitly using reloadChanges().
    Set<String> fields = ImmutableSet.of(ChangeField.CHANGE.getName(), ChangeField.PATCH_SET.getName(), ChangeField.REVIEWER.getName());
    return queryProvider.get().setRequestedFields(fields);
}
#end_block

#method_before
@Override
public List<ChangeInfo> apply(ChangeResource resource) throws AuthException, BadRequestException, ResourceConflictException, Exception {
    try {
        boolean addHiddenDummy = false;
        Change c = resource.getChange();
        List<ChangeData> cds;
        if (c.getStatus().isOpen()) {
            ChangeSet cs = getForOpenChange(c, resource.getControl().getUser());
            cds = cs.changes().asList();
            addHiddenDummy = !cs.isComplete();
        } else if (c.getStatus().asChangeStatus() == ChangeStatus.MERGED) {
            cds = getForMergedChange(c);
        } else {
            cds = getForAbandonedChange();
        }
        if (cds.size() <= 1 && !addHiddenDummy) {
            cds = Collections.emptyList();
        } else {
            // Skip sorting for singleton lists, to avoid WalkSorter opening the
            // repo just to fill out the commit field in PatchSetData.
            cds = sort(cds);
        }
        List<ChangeInfo> ret = json.create(EnumSet.of(ListChangesOption.CURRENT_REVISION, ListChangesOption.CURRENT_COMMIT)).formatChangeDatas(cds);
        if (addHiddenDummy) {
            ChangeInfo i = new ChangeInfo();
            i.subject = "Some Changes are hidden";
            ret.add(i);
        }
        return ret;
    } catch (OrmException | IOException e) {
        log.error("Error on getting a ChangeSet", e);
        throw e;
    }
}
#method_after
@Override
public List<ChangeInfo> apply(ChangeResource resource) throws AuthException, BadRequestException, ResourceConflictException, Exception {
    try {
        boolean addHiddenDummy = false;
        Change c = resource.getChange();
        List<ChangeData> cds;
        if (c.getStatus().isOpen()) {
            ChangeSet cs = getForOpenChange(c, resource.getControl().getUser());
            cds = cs.changes().asList();
            addHiddenDummy = !cs.isComplete();
        } else if (c.getStatus().asChangeStatus() == ChangeStatus.MERGED) {
            cds = getForMergedChange(c);
        } else {
            cds = getForAbandonedChange();
        }
        addHiddenDummy &= options.contains(SubmittedTogetherOption.DUMMY);
        if (cds.size() <= 1 && !addHiddenDummy) {
            cds = Collections.emptyList();
        } else {
            // Skip sorting for singleton lists, to avoid WalkSorter opening the
            // repo just to fill out the commit field in PatchSetData.
            cds = sort(cds);
        }
        List<ChangeInfo> ret = json.create(EnumSet.of(ListChangesOption.CURRENT_REVISION, ListChangesOption.CURRENT_COMMIT)).formatChangeDatas(cds);
        if (addHiddenDummy) {
            ChangeInfo i = new ChangeInfo();
            i.subject = "Some changes are not visible";
            i.project = null;
            i.branch = null;
            i.submittable = false;
            i.mergeable = false;
            i.changeId = null;
            i._number = 0;
            i.currentRevision = "0";
            i.status = ChangeStatus.NEW;
            RevisionInfo ri = new RevisionInfo();
            ri.commit = new CommitInfo();
            ri.commit.subject = "Some changes are not visible";
            Map<String, RevisionInfo> revs = new LinkedHashMap<>();
            i.revisions = revs;
            i.revisions.put("0", ri);
            ret.add(i);
        }
        return ret;
    } catch (OrmException | IOException e) {
        log.error("Error on getting a ChangeSet", e);
        throw e;
    }
}
#end_block

#method_before
@Test
public void testHiddenDraftChange() throws Exception {
    setApiUser(admin);
    RevCommit initialHead = getRemoteHead();
    // Create two independent commits and push.
    RevCommit c1_1 = commitBuilder().add("a.txt", "1").message("subject: 1").create();
    String id1 = getChangeId(c1_1);
    pushHead(testRepo, "refs/drafts/master/" + name("connectingTopic"), false);
    testRepo.reset(initialHead);
    setApiUser(user);
    RevCommit c2_1 = commitBuilder().add("b.txt", "2").message("subject: 2").create();
    String id2 = getChangeId(c2_1);
    pushHead(testRepo, "refs/for/master/" + name("connectingTopic"), false);
    String draftId = "null";
    if (isSubmitWholeTopicEnabled()) {
        setApiUser(admin);
        assertSubmittedTogether(id1, draftId);
        assertSubmittedTogether(id2, draftId);
        setApiUser(user);
        assertSubmittedTogether(id2, draftId);
    } else {
        setApiUser(admin);
        assertSubmittedTogether(id1, draftId);
        assertSubmittedTogether(id2);
        setApiUser(user);
        assertSubmittedTogether(id2);
    }
}
#method_after
@Test
public void testHiddenDraftChange() throws Exception {
    setApiUser(admin);
    RevCommit initialHead = getRemoteHead();
    // Create two independent commits and push.
    RevCommit c1_1 = commitBuilder().add("a.txt", "1").message("subject: 1").create();
    String id1 = getChangeId(c1_1);
    pushHead(testRepo, "refs/drafts/master/" + name("connectingTopic"), false);
    testRepo.reset(initialHead);
    setApiUser(user);
    RevCommit c2_1 = commitBuilder().add("b.txt", "2").message("subject: 2").create();
    String id2 = getChangeId(c2_1);
    pushHead(testRepo, "refs/for/master/" + name("connectingTopic"), false);
    String draftId = "Some changes are not visible";
    EnumSet<SubmittedTogetherOption> o1 = EnumSet.noneOf(SubmittedTogetherOption.class);
    EnumSet<SubmittedTogetherOption> o2 = EnumSet.of(SubmittedTogetherOption.DUMMY);
    if (isSubmitWholeTopicEnabled()) {
        setApiUser(admin);
        assertSubmittedTogether(id1, o1, id2, id1);
        assertSubmittedTogether(id2, o1, id2, id1);
        assertSubmittedTogether(id1, o2, id2, id1);
        assertSubmittedTogether(id2, o2, id2, id1);
        setApiUser(user);
        assertSubmittedTogether(id2, o1);
        assertSubmittedTogether(id2, o2, id2, draftId);
    } else {
        setApiUser(admin);
        assertSubmittedTogether(id1, o1);
        assertSubmittedTogether(id2, o1);
        assertSubmittedTogether(id1, o2);
        assertSubmittedTogether(id2, o2);
        setApiUser(user);
        assertSubmittedTogether(id2, o1);
        assertSubmittedTogether(id2, o2);
    }
}
#end_block

#method_before
@Test
public void submitTwoChangesWithFastForward() throws Exception {
    RevCommit originalHead = getRemoteHead();
    PushOneCommit.Result change = createChange();
    PushOneCommit.Result change2 = createChange();
    String id1 = change.getChangeId();
    String id2 = change2.getChangeId();
    approve(id1);
    submit(id2);
    RevCommit updatedHead = getRemoteHead();
    assertThat(updatedHead.getId()).isEqualTo(change2.getCommit());
    assertThat(updatedHead.getParent(0).getId()).isEqualTo(change.getCommit());
    assertSubmitter(change.getChangeId(), 1);
    assertSubmitter(change2.getChangeId(), 1);
    assertPersonEquals(admin.getIdent(), updatedHead.getAuthorIdent());
    assertPersonEquals(admin.getIdent(), updatedHead.getCommitterIdent());
    assertSubmittedTogether(id1, id2, id1);
    assertSubmittedTogether(id2, id2, id1);
    RefUpdateAttribute refUpdate = getOneRefUpdate(project.get() + "-refs/heads/master");
    assertThat(refUpdate).isNotNull();
    assertThat(refUpdate.oldRev).isEqualTo(originalHead.name());
    assertThat(refUpdate.newRev).isEqualTo(updatedHead.name());
}
#method_after
@Test
public void submitTwoChangesWithFastForward() throws Exception {
    RevCommit originalHead = getRemoteHead();
    PushOneCommit.Result change = createChange();
    PushOneCommit.Result change2 = createChange();
    String id1 = change.getChangeId();
    String id2 = change2.getChangeId();
    approve(id1);
    submit(id2);
    RevCommit updatedHead = getRemoteHead();
    assertThat(updatedHead.getId()).isEqualTo(change2.getCommit());
    assertThat(updatedHead.getParent(0).getId()).isEqualTo(change.getCommit());
    assertSubmitter(change.getChangeId(), 1);
    assertSubmitter(change2.getChangeId(), 1);
    assertPersonEquals(admin.getIdent(), updatedHead.getAuthorIdent());
    assertPersonEquals(admin.getIdent(), updatedHead.getCommitterIdent());
    assertSubmittedTogether(id1, id2, id1);
    assertSubmittedTogether(id2, id2, id1);
    RefUpdatedEvent refUpdate = eventRecorder.getOneRefUpdate(project.get(), "refs/heads/master");
    assertThat(refUpdate.refUpdate.get().oldRev).isEqualTo(originalHead.name());
    assertThat(refUpdate.refUpdate.get().newRev).isEqualTo(updatedHead.name());
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    changeMergedEvents = new HashMap<>();
    refUpdatedEvents = HashMultimap.create();
    eventListenerRegistration = eventListeners.add(new UserScopedEventListener() {

        @Override
        public void onEvent(Event event) {
            if (event instanceof ChangeMergedEvent) {
                ChangeMergedEvent e = (ChangeMergedEvent) event;
                ChangeAttribute c = e.change.get();
                PatchSetAttribute ps = e.patchSet.get();
                log.debug("Merged {},{} as {}", ps.number, c.number, e.newRev);
                changeMergedEvents.put(e.change.get().number, e.newRev);
            } else if (event instanceof RefUpdatedEvent) {
                RefUpdatedEvent e = (RefUpdatedEvent) event;
                RefUpdateAttribute r = e.refUpdate.get();
                log.debug("Branch {} ref updated from {} to {}", r.refName, r.oldRev, r.newRev);
                refUpdatedEvents.put(r.project + "-" + r.refName, r);
            }
        }

        @Override
        public CurrentUser getUser() {
            return factory.create(user.id);
        }
    });
}
#method_after
@Before
public void setUp() throws Exception {
    eventRecorder = eventRecorderFactory.create(user);
}
#end_block

#method_before
@After
public void cleanup() {
    eventListenerRegistration.remove();
    db.close();
}
#method_after
@After
public void cleanup() {
    eventRecorder.close();
    db.close();
}
#end_block

#method_before
protected void submit(String changeId, SubmitInput input, Class<? extends RestApiException> expectedExceptionType, String expectedExceptionMsg, boolean checkMergeResult) throws Exception {
    approve(changeId);
    if (expectedExceptionType == null) {
        assertSubmittable(changeId);
    }
    try {
        gApi.changes().id(changeId).current().submit(input);
        if (expectedExceptionType != null) {
            fail("Expected exception of type " + expectedExceptionType.getSimpleName());
        }
    } catch (RestApiException e) {
        if (expectedExceptionType == null) {
            throw e;
        }
        // us the stack trace.
        if (!expectedExceptionType.isAssignableFrom(e.getClass()) || !e.getMessage().equals(expectedExceptionMsg)) {
            throw new AssertionError("Expected exception of type " + expectedExceptionType.getSimpleName() + " with message: \"" + expectedExceptionMsg + "\" but got exception of type " + e.getClass().getSimpleName() + " with message \"" + e.getMessage() + "\"", e);
        }
        return;
    }
    ChangeInfo change = gApi.changes().id(changeId).info();
    assertThat(change.status).isEqualTo(ChangeStatus.MERGED);
    if (checkMergeResult) {
        checkMergeResult(change);
    }
}
#method_after
protected void submit(String changeId, SubmitInput input, Class<? extends RestApiException> expectedExceptionType, String expectedExceptionMsg, boolean checkMergeResult) throws Exception {
    approve(changeId);
    if (expectedExceptionType == null) {
        assertSubmittable(changeId);
    }
    try {
        gApi.changes().id(changeId).current().submit(input);
        if (expectedExceptionType != null) {
            fail("Expected exception of type " + expectedExceptionType.getSimpleName());
        }
    } catch (RestApiException e) {
        if (expectedExceptionType == null) {
            throw e;
        }
        // us the stack trace.
        if (!expectedExceptionType.isAssignableFrom(e.getClass()) || !e.getMessage().equals(expectedExceptionMsg)) {
            throw new AssertionError("Expected exception of type " + expectedExceptionType.getSimpleName() + " with message: \"" + expectedExceptionMsg + "\" but got exception of type " + e.getClass().getSimpleName() + " with message \"" + e.getMessage() + "\"", e);
        }
        return;
    }
    ChangeInfo change = gApi.changes().id(changeId).info();
    assertMerged(change.changeId);
    if (checkMergeResult) {
        checkMergeResult(change);
    }
}
#end_block

#method_before
private void checkMergeResult(ChangeInfo change) throws Exception {
    // Get the revision of the branch after the submit to compare with the
    // newRev of the ChangeMergedEvent.
    BranchInfo branch = gApi.projects().name(change.project).branch(change.branch).get();
    assertThat(changeMergedEvents).isNotEmpty();
    String newRev = changeMergedEvents.get(Integer.toString(change._number));
    assertThat(newRev).isNotNull();
    assertThat(branch.revision).isEqualTo(newRev);
}
#method_after
private void checkMergeResult(ChangeInfo change) throws Exception {
    // Get the revision of the branch after the submit to compare with the
    // newRev of the ChangeMergedEvent.
    BranchInfo branch = gApi.projects().name(change.project).branch(change.branch).get();
    ChangeMergedEvent event = eventRecorder.getOneChangeMerged(change.project, change.branch, Integer.toString(change._number));
    assertThat(event.newRev).isNotNull();
    assertThat(branch.revision).isEqualTo(event.newRev);
}
#end_block

#method_before
@Override
public int compareTo(ProjectHolder other) {
    return other.size < this.size ? -1 : 1;
}
#method_after
@Override
public int compareTo(ProjectHolder other) {
    return ComparisonChain.start().compare(other.size, size).compare(other.name.get(), name.get()).result();
}
#end_block

#method_before
@Override
public Result indexAll(ChangeIndex index) {
    ProgressMonitor pm = new TextProgressMonitor();
    pm.beginTask("Collecting projects", ProgressMonitor.UNKNOWN);
    SortedSet<ProjectHolder> projects = new TreeSet<>();
    int changeCount = 0;
    Stopwatch sw = Stopwatch.createStarted();
    for (Project.NameKey project : projectCache.all()) {
        try (Repository repo = repoManager.openRepository(project)) {
            int size = ChangeNotes.Factory.scan(repo).size();
            changeCount += size;
            projects.add(new ProjectHolder(project, size));
        } catch (IOException e) {
            log.error("Error collecting projects", e);
            return new Result(sw, false, 0, 0);
        }
        pm.update(1);
    }
    pm.endTask();
    setTotalWork(changeCount);
    return indexAll(index, projects);
}
#method_after
@Override
public Result indexAll(ChangeIndex index) {
    ProgressMonitor pm = new TextProgressMonitor();
    pm.beginTask("Collecting projects", ProgressMonitor.UNKNOWN);
    SortedSet<ProjectHolder> projects = new TreeSet<>();
    int changeCount = 0;
    Stopwatch sw = Stopwatch.createStarted();
    for (Project.NameKey name : projectCache.all()) {
        try (Repository repo = repoManager.openRepository(name)) {
            int size = ChangeNotes.Factory.scan(repo).size();
            changeCount += size;
            projects.add(new ProjectHolder(name, size));
        } catch (IOException e) {
            log.error("Error collecting projects", e);
            return new Result(sw, false, 0, 0);
        }
        pm.update(1);
    }
    pm.endTask();
    setTotalWork(changeCount);
    return indexAll(index, projects);
}
#end_block

#method_before
public SiteIndexer.Result indexAll(ChangeIndex index, Iterable<ProjectHolder> projects) {
    Stopwatch sw = Stopwatch.createStarted();
    final MultiProgressMonitor mpm = new MultiProgressMonitor(progressOut, "Reindexing changes");
    final Task projTask = mpm.beginSubTask("projects", (projects instanceof Collection) ? ((Collection<?>) projects).size() : MultiProgressMonitor.UNKNOWN);
    final Task doneTask = mpm.beginSubTask(null, totalWork >= 0 ? totalWork : MultiProgressMonitor.UNKNOWN);
    final Task failedTask = mpm.beginSubTask("failed", MultiProgressMonitor.UNKNOWN);
    final List<ListenableFuture<?>> futures = new ArrayList<>();
    final AtomicBoolean ok = new AtomicBoolean(true);
    for (final ProjectHolder project : projects) {
        ListenableFuture<?> future = executor.submit(reindexProject(indexerFactory.create(executor, index), project.name, doneTask, failedTask, verboseWriter));
        addErrorListener(future, "project " + project, projTask, ok);
        futures.add(future);
    }
    try {
        mpm.waitFor(Futures.transformAsync(Futures.successfulAsList(futures), new AsyncFunction<List<?>, Void>() {

            @Override
            public ListenableFuture<Void> apply(List<?> input) {
                mpm.end();
                return Futures.immediateFuture(null);
            }
        }));
    } catch (ExecutionException e) {
        log.error("Error in batch indexer", e);
        ok.set(false);
    }
    // If too many changes failed, maybe there was a bug in the indexer. Don't
    // trust the results. This is not an exact percentage since we bump the same
    // failure counter if a project can't be read, but close enough.
    int nFailed = failedTask.getCount();
    int nTotal = nFailed + doneTask.getCount();
    double pctFailed = ((double) nFailed) / nTotal * 100;
    if (pctFailed > 10) {
        log.error("Failed {}/{} changes ({}%); not marking new index as ready", nFailed, nTotal, Math.round(pctFailed));
        ok.set(false);
    }
    return new Result(sw, ok.get(), doneTask.getCount(), failedTask.getCount());
}
#method_after
public SiteIndexer.Result indexAll(ChangeIndex index, Iterable<ProjectHolder> projects) {
    Stopwatch sw = Stopwatch.createStarted();
    final MultiProgressMonitor mpm = new MultiProgressMonitor(progressOut, "Reindexing changes");
    final Task projTask = mpm.beginSubTask("projects", (projects instanceof Collection) ? ((Collection<?>) projects).size() : MultiProgressMonitor.UNKNOWN);
    final Task doneTask = mpm.beginSubTask(null, totalWork >= 0 ? totalWork : MultiProgressMonitor.UNKNOWN);
    final Task failedTask = mpm.beginSubTask("failed", MultiProgressMonitor.UNKNOWN);
    final List<ListenableFuture<?>> futures = new ArrayList<>();
    final AtomicBoolean ok = new AtomicBoolean(true);
    for (final ProjectHolder project : projects) {
        ListenableFuture<?> future = executor.submit(reindexProject(indexerFactory.create(executor, index), project.name, doneTask, failedTask, verboseWriter));
        addErrorListener(future, "project " + project.name, projTask, ok);
        futures.add(future);
    }
    try {
        mpm.waitFor(Futures.transformAsync(Futures.successfulAsList(futures), new AsyncFunction<List<?>, Void>() {

            @Override
            public ListenableFuture<Void> apply(List<?> input) {
                mpm.end();
                return Futures.immediateFuture(null);
            }
        }));
    } catch (ExecutionException e) {
        log.error("Error in batch indexer", e);
        ok.set(false);
    }
    // If too many changes failed, maybe there was a bug in the indexer. Don't
    // trust the results. This is not an exact percentage since we bump the same
    // failure counter if a project can't be read, but close enough.
    int nFailed = failedTask.getCount();
    int nTotal = nFailed + doneTask.getCount();
    double pctFailed = ((double) nFailed) / nTotal * 100;
    if (pctFailed > 10) {
        log.error("Failed {}/{} changes ({}%); not marking new index as ready", nFailed, nTotal, Math.round(pctFailed));
        ok.set(false);
    }
    return new Result(sw, ok.get(), doneTask.getCount(), failedTask.getCount());
}
#end_block

#method_before
@Override
int getCmLine(int line, DisplaySide side) {
    int res = Collections.binarySearch(chunks, new UnifiedDiffChunkInfo(side, line, 0, 0, // Dummy DiffChunkInfo
    false), getDiffChunkComparator());
    if (res >= 0) {
        return chunks.get(res).getCmLine();
    }
    res = -res - 1;
    if (res > 0) {
        UnifiedDiffChunkInfo info = chunks.get(res - 1);
        if (side == DisplaySide.A && info.isEdit() && info.getSide() == DisplaySide.B) {
            // Need to use the start and cmLine of the deletion chunk
            UnifiedDiffChunkInfo delete = chunks.get(res - 2);
            if (line <= delete.getEnd()) {
                return delete.getCmLine() + line - delete.getStart();
            }
            // Need to add the length of the insertion chunk
            return delete.getCmLine() + line - delete.getStart() + info.getEnd() - info.getStart() + 1;
        } else if (side == info.getSide()) {
            return info.getCmLine() + line - info.getStart();
        } else {
            return info.getCmLine() + lineMapper.lineOnOther(side, line).getLine() - info.getStart();
        }
    }
    return line;
}
#method_after
@Override
int getCmLine(int line, DisplaySide side) {
    int res = Collections.binarySearch(chunks, new UnifiedDiffChunkInfo(side, line, 0, 0, // Dummy DiffChunkInfo
    false), getDiffChunkComparator());
    if (res >= 0) {
        return chunks.get(res).getCmLine();
    }
    // The line might be within a DiffChunk
    res = -res - 1;
    if (res > 0) {
        UnifiedDiffChunkInfo info = chunks.get(res - 1);
        if (side == DisplaySide.A && info.isEdit() && info.getSide() == DisplaySide.B) {
            // Need to use the start and cmLine of the deletion chunk
            UnifiedDiffChunkInfo delete = chunks.get(res - 2);
            if (line <= delete.getEnd()) {
                return delete.getCmLine() + line - delete.getStart();
            }
            // Need to add the length of the insertion chunk
            return delete.getCmLine() + line - delete.getStart() + info.getEnd() - info.getStart() + 1;
        } else if (side == info.getSide()) {
            return info.getCmLine() + line - info.getStart();
        } else {
            return info.getCmLine() + lineMapper.lineOnOther(side, line).getLine() - info.getStart();
        }
    }
    return line;
}
#end_block

#method_before
LineRegionInfo getLineRegionInfoFromCmLine(int cmLine) {
    int res = Collections.binarySearch(chunks, new UnifiedDiffChunkInfo(DisplaySide.A, 0, 0, cmLine, // Dummy DiffChunkInfo
    false), getDiffChunkComparatorCmLine());
    if (res >= 0) {
        // The line is right at the start of a diff chunk.
        UnifiedDiffChunkInfo info = chunks.get(res);
        return new LineRegionInfo(info.getStart(), displaySideToRegionType(info.getSide()));
    }
    res = -res - 1;
    if (res > 0) {
        UnifiedDiffChunkInfo info = chunks.get(res - 1);
        int lineOnInfoSide = info.getStart() + cmLine - info.getCmLine();
        if (lineOnInfoSide > info.getEnd()) {
            // After a diff chunk
            if (info.getSide() == DisplaySide.A) {
                // on side B with a common region.
                return new LineRegionInfo(lineMapper.lineOnOther(DisplaySide.A, lineOnInfoSide).getLine(), RegionType.COMMON);
            }
            return new LineRegionInfo(lineOnInfoSide, RegionType.COMMON);
        }
        // Within a diff chunk
        return new LineRegionInfo(lineOnInfoSide, displaySideToRegionType(info.getSide()));
    }
    // belongs to a common region.
    return new LineRegionInfo(cmLine, RegionType.COMMON);
}
#method_after
LineRegionInfo getLineRegionInfoFromCmLine(int cmLine) {
    int res = Collections.binarySearch(chunks, new UnifiedDiffChunkInfo(DisplaySide.A, 0, 0, cmLine, // Dummy DiffChunkInfo
    false), getDiffChunkComparatorCmLine());
    if (res >= 0) {
        // The line is right at the start of a diff chunk.
        UnifiedDiffChunkInfo info = chunks.get(res);
        return new LineRegionInfo(info.getStart(), displaySideToRegionType(info.getSide()));
    }
    // The line might be within or after a diff chunk.
    res = -res - 1;
    if (res > 0) {
        UnifiedDiffChunkInfo info = chunks.get(res - 1);
        int lineOnInfoSide = info.getStart() + cmLine - info.getCmLine();
        if (lineOnInfoSide > info.getEnd()) {
            // After a diff chunk
            if (info.getSide() == DisplaySide.A) {
                // on side B with a common region.
                return new LineRegionInfo(lineMapper.lineOnOther(DisplaySide.A, lineOnInfoSide).getLine(), RegionType.COMMON);
            }
            return new LineRegionInfo(lineOnInfoSide, RegionType.COMMON);
        }
        // Within a diff chunk
        return new LineRegionInfo(lineOnInfoSide, displaySideToRegionType(info.getSide()));
    }
    // belongs to a common region.
    return new LineRegionInfo(cmLine, RegionType.COMMON);
}
#end_block

#method_before
public static boolean isRefsEditOf(String ref, Account.Id accountId) {
    String prefix = new StringBuilder(refsUsers(accountId)).append('/').append(EDIT_PREFIX).toString();
    return ref.startsWith(prefix);
}
#method_after
public static boolean isRefsEditOf(String ref, Account.Id accountId) {
    if (accountId == null) {
        return false;
    }
    String prefix = new StringBuilder(refsUsers(accountId)).append('/').append(EDIT_PREFIX).toString();
    return ref.startsWith(prefix);
}
#end_block

#method_before
private void sendAutoIndex(PluginContentScanner scanner, String prefix, String pluginName, PluginResourceKey cacheKey, HttpServletResponse res, long lastModifiedTime) throws IOException {
    List<PluginEntry> cmds = new ArrayList<>();
    List<PluginEntry> servlets = new ArrayList<>();
    List<PluginEntry> restApis = new ArrayList<>();
    List<PluginEntry> docs = new ArrayList<>();
    PluginEntry about = null;
    Enumeration<PluginEntry> entries = scanner.entries();
    while (entries.hasMoreElements()) {
        PluginEntry entry = entries.nextElement();
        String name = entry.getName();
        Optional<Long> size = entry.getSize();
        if (name.startsWith(prefix) && (name.endsWith(".md") || name.endsWith(".html")) && size.isPresent() && 0 < size.get() && size.get() <= SMALL_RESOURCE) {
            name = name.substring(prefix.length());
            if (name.startsWith("cmd-")) {
                cmds.add(entry);
            } else if (name.startsWith("servlet-")) {
                servlets.add(entry);
            } else if (name.startsWith("rest-api-")) {
                restApis.add(entry);
            } else if (name.startsWith("about.")) {
                if (about == null) {
                    about = entry;
                }
            } else {
                docs.add(entry);
            }
        }
    }
    Collections.sort(cmds, PluginEntry.COMPARATOR_BY_NAME);
    Collections.sort(docs, PluginEntry.COMPARATOR_BY_NAME);
    StringBuilder md = new StringBuilder();
    md.append(String.format("# Plugin %s #\n", pluginName));
    md.append("\n");
    appendPluginInfoTable(md, scanner.getManifest().getMainAttributes());
    if (about != null) {
        InputStreamReader isr = new InputStreamReader(scanner.getInputStream(about));
        StringBuilder aboutContent = new StringBuilder();
        try (BufferedReader reader = new BufferedReader(isr)) {
            String line;
            while ((line = reader.readLine()) != null) {
                line = line.trim();
                if (line.isEmpty()) {
                    aboutContent.append("\n");
                } else {
                    aboutContent.append(line).append("\n");
                }
            }
        }
        // Only append the About section if there was anything in it
        if (aboutContent.toString().trim().length() > 0) {
            md.append("## About ##\n");
            md.append("\n").append(aboutContent);
        }
    }
    appendEntriesSection(scanner, docs, "Documentation", md, prefix, 0);
    appendEntriesSection(scanner, servlets, "Servlets", md, prefix, "servlet-".length());
    appendEntriesSection(scanner, restApis, "REST APIs", md, prefix, "rest-api-".length());
    appendEntriesSection(scanner, cmds, "Commands", md, prefix, "cmd-".length());
    sendMarkdownAsHtml(md.toString(), pluginName, cacheKey, res, lastModifiedTime);
}
#method_after
private void sendAutoIndex(PluginContentScanner scanner, final String prefix, final String pluginName, PluginResourceKey cacheKey, HttpServletResponse res, long lastModifiedTime) throws IOException {
    List<PluginEntry> cmds = new ArrayList<>();
    List<PluginEntry> servlets = new ArrayList<>();
    List<PluginEntry> restApis = new ArrayList<>();
    List<PluginEntry> docs = new ArrayList<>();
    PluginEntry about = null;
    Predicate<PluginEntry> filter = new Predicate<PluginEntry>() {

        @Override
        public boolean apply(PluginEntry entry) {
            String name = entry.getName();
            Optional<Long> size = entry.getSize();
            if (name.startsWith(prefix) && (name.endsWith(".md") || name.endsWith(".html")) && size.isPresent()) {
                if (size.get() <= 0 || size.get() > SMALL_RESOURCE) {
                    log.warn(String.format("Plugin %s: %s omitted from document index. " + "Size %d out of range (0,%d).", pluginName, name.substring(prefix.length()), size.get(), SMALL_RESOURCE));
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    List<PluginEntry> entries = FluentIterable.from(Collections.list(scanner.entries())).filter(filter).toList();
    for (PluginEntry entry : entries) {
        String name = entry.getName().substring(prefix.length());
        if (name.startsWith("cmd-")) {
            cmds.add(entry);
        } else if (name.startsWith("servlet-")) {
            servlets.add(entry);
        } else if (name.startsWith("rest-api-")) {
            restApis.add(entry);
        } else if (name.startsWith("about.")) {
            if (about == null) {
                about = entry;
            } else {
                log.warn(String.format("Plugin %s: Multiple 'about' documents found; using %s", pluginName, about.getName().substring(prefix.length())));
            }
        } else {
            docs.add(entry);
        }
    }
    Collections.sort(cmds, PluginEntry.COMPARATOR_BY_NAME);
    Collections.sort(docs, PluginEntry.COMPARATOR_BY_NAME);
    StringBuilder md = new StringBuilder();
    md.append(String.format("# Plugin %s #\n", pluginName));
    md.append("\n");
    appendPluginInfoTable(md, scanner.getManifest().getMainAttributes());
    if (about != null) {
        InputStreamReader isr = new InputStreamReader(scanner.getInputStream(about));
        StringBuilder aboutContent = new StringBuilder();
        try (BufferedReader reader = new BufferedReader(isr)) {
            String line;
            while ((line = reader.readLine()) != null) {
                line = line.trim();
                if (line.isEmpty()) {
                    aboutContent.append("\n");
                } else {
                    aboutContent.append(line).append("\n");
                }
            }
        }
        // Only append the About section if there was anything in it
        if (aboutContent.toString().trim().length() > 0) {
            md.append("## About ##\n");
            md.append("\n").append(aboutContent);
        }
    }
    appendEntriesSection(scanner, docs, "Documentation", md, prefix, 0);
    appendEntriesSection(scanner, servlets, "Servlets", md, prefix, "servlet-".length());
    appendEntriesSection(scanner, restApis, "REST APIs", md, prefix, "rest-api-".length());
    appendEntriesSection(scanner, cmds, "Commands", md, prefix, "cmd-".length());
    sendMarkdownAsHtml(md.toString(), pluginName, cacheKey, res, lastModifiedTime);
}
#end_block

#method_before
private Iterable<String> getUsernames(CurrentUser user) {
    if (user.isIdentifiedUser()) {
        Set<String> emails = user.asIdentifiedUser().getEmailAddresses();
        if (user.getUserName() == null) {
            return emails;
        } else if (emails.isEmpty()) {
            return ImmutableSet.of(user.getUserName());
        }
    }
    if (user.getUserName() != null) {
        return ImmutableSet.of(user.getUserName());
    }
    return ImmutableSet.of();
}
#method_after
private Iterable<String> getUsernames(CurrentUser user) {
    if (user.isIdentifiedUser()) {
        Set<String> emails = user.asIdentifiedUser().getEmailAddresses();
        if (user.getUserName() == null) {
            return emails;
        } else if (emails.isEmpty()) {
            return ImmutableSet.of(user.getUserName());
        }
        return Iterables.concat(emails, ImmutableSet.of(user.getUserName()));
    }
    if (user.getUserName() != null) {
        return ImmutableSet.of(user.getUserName());
    }
    return ImmutableSet.of();
}
#end_block

#method_before
private List<String> getUsernames(CurrentUser user) {
    List<String> r;
    if (user.isIdentifiedUser()) {
        Set<String> emails = user.asIdentifiedUser().getEmailAddresses();
        r = new ArrayList<>(emails.size() + 1);
        r.addAll(emails);
    } else {
        r = new ArrayList<>(1);
    }
    if (user.getUserName() != null) {
        r.add(user.getUserName());
    }
    return r;
}
#method_after
private Iterable<String> getUsernames(CurrentUser user) {
    if (user.isIdentifiedUser()) {
        Set<String> emails = user.asIdentifiedUser().getEmailAddresses();
        if (user.getUserName() == null) {
            return emails;
        } else if (emails.isEmpty()) {
            return ImmutableSet.of(user.getUserName());
        }
        Iterables.concat(emails, ImmutableSet.of(user.getUserName()));
    }
    if (user.getUserName() != null) {
        return ImmutableSet.of(user.getUserName());
    }
    return ImmutableSet.of();
}
#end_block

#method_before
PermissionCollection filter(Iterable<SectionMatcher> matcherList, String ref, CurrentUser user) {
    if (isRE(ref)) {
        ref = RefControl.shortestExample(ref);
    } else if (ref.endsWith("/*")) {
        ref = ref.substring(0, ref.length() - 1);
    }
    boolean perUser = false;
    Map<AccessSection, Project.NameKey> sectionToProject = Maps.newLinkedHashMap();
    for (SectionMatcher sm : matcherList) {
        // 
        if (sm.matcher instanceof RefPatternMatcher.ExpandParameters) {
            if (!((RefPatternMatcher.ExpandParameters) sm.matcher).matchPrefix(ref)) {
                continue;
            }
            perUser = true;
            if (sm.match(ref, user)) {
                sectionToProject.put(sm.section, sm.project);
                break;
            }
        } else if (sm.match(ref, null)) {
            sectionToProject.put(sm.section, sm.project);
        }
    }
    List<AccessSection> sections = Lists.newArrayList(sectionToProject.keySet());
    sorter.sort(ref, sections);
    Set<SeenRule> seen = new HashSet<>();
    Set<String> exclusiveGroupPermissions = new HashSet<>();
    HashMap<String, List<PermissionRule>> permissions = new HashMap<>();
    HashMap<String, List<PermissionRule>> overridden = new HashMap<>();
    Map<PermissionRule, ProjectRef> ruleProps = Maps.newIdentityHashMap();
    for (AccessSection section : sections) {
        Project.NameKey project = sectionToProject.get(section);
        for (Permission permission : section.getPermissions()) {
            boolean exclusivePermissionExists = exclusiveGroupPermissions.contains(permission.getName());
            for (PermissionRule rule : permission.getRules()) {
                SeenRule s = SeenRule.create(section, permission, rule);
                boolean addRule;
                if (rule.isBlock()) {
                    addRule = true;
                } else {
                    addRule = seen.add(s) && !rule.isDeny() && !exclusivePermissionExists;
                }
                HashMap<String, List<PermissionRule>> p = null;
                if (addRule) {
                    p = permissions;
                } else if (!rule.isDeny() && !exclusivePermissionExists) {
                    p = overridden;
                }
                if (p != null) {
                    List<PermissionRule> r = p.get(permission.getName());
                    if (r == null) {
                        r = new ArrayList<>(2);
                        p.put(permission.getName(), r);
                    }
                    r.add(rule);
                    ruleProps.put(rule, ProjectRef.create(project, section.getName()));
                }
            }
            if (permission.getExclusiveGroup()) {
                exclusiveGroupPermissions.add(permission.getName());
            }
        }
    }
    return new PermissionCollection(permissions, overridden, ruleProps, perUser);
}
#method_after
PermissionCollection filter(Iterable<SectionMatcher> matcherList, String ref, CurrentUser user) {
    if (isRE(ref)) {
        ref = RefControl.shortestExample(ref);
    } else if (ref.endsWith("/*")) {
        ref = ref.substring(0, ref.length() - 1);
    }
    boolean perUser = false;
    Map<AccessSection, Project.NameKey> sectionToProject = new LinkedHashMap<>();
    for (SectionMatcher sm : matcherList) {
        // 
        if (sm.matcher instanceof RefPatternMatcher.ExpandParameters) {
            if (!((RefPatternMatcher.ExpandParameters) sm.matcher).matchPrefix(ref)) {
                continue;
            }
            perUser = true;
            if (sm.match(ref, user)) {
                sectionToProject.put(sm.section, sm.project);
                break;
            }
        } else if (sm.match(ref, null)) {
            sectionToProject.put(sm.section, sm.project);
        }
    }
    List<AccessSection> sections = Lists.newArrayList(sectionToProject.keySet());
    sorter.sort(ref, sections);
    Set<SeenRule> seen = new HashSet<>();
    Set<String> exclusiveGroupPermissions = new HashSet<>();
    HashMap<String, List<PermissionRule>> permissions = new HashMap<>();
    HashMap<String, List<PermissionRule>> overridden = new HashMap<>();
    Map<PermissionRule, ProjectRef> ruleProps = Maps.newIdentityHashMap();
    for (AccessSection section : sections) {
        Project.NameKey project = sectionToProject.get(section);
        for (Permission permission : section.getPermissions()) {
            boolean exclusivePermissionExists = exclusiveGroupPermissions.contains(permission.getName());
            for (PermissionRule rule : permission.getRules()) {
                SeenRule s = SeenRule.create(section, permission, rule);
                boolean addRule;
                if (rule.isBlock()) {
                    addRule = true;
                } else {
                    addRule = seen.add(s) && !rule.isDeny() && !exclusivePermissionExists;
                }
                HashMap<String, List<PermissionRule>> p = null;
                if (addRule) {
                    p = permissions;
                } else if (!rule.isDeny() && !exclusivePermissionExists) {
                    p = overridden;
                }
                if (p != null) {
                    List<PermissionRule> r = p.get(permission.getName());
                    if (r == null) {
                        r = new ArrayList<>(2);
                        p.put(permission.getName(), r);
                    }
                    r.add(rule);
                    ruleProps.put(rule, ProjectRef.create(project, section.getName()));
                }
            }
            if (permission.getExclusiveGroup()) {
                exclusiveGroupPermissions.add(permission.getName());
            }
        }
    }
    return new PermissionCollection(permissions, overridden, ruleProps, perUser);
}
#end_block

#method_before
private Capable verifyActiveContributorAgreement() {
    if (!(user.isIdentifiedUser())) {
        return new Capable("Must be logged in to verify Contributor Agreement");
    }
    final IdentifiedUser iUser = user.asIdentifiedUser();
    List<AccountGroup.UUID> okGroupIds = Lists.newArrayList();
    for (ContributorAgreement ca : contributorAgreements) {
        List<AccountGroup.UUID> groupIds;
        groupIds = okGroupIds;
        for (PermissionRule rule : ca.getAccepted()) {
            if ((rule.getAction() == Action.ALLOW) && (rule.getGroup() != null) && (rule.getGroup().getUUID() != null)) {
                groupIds.add(new AccountGroup.UUID(rule.getGroup().getUUID().get()));
            }
        }
    }
    if (iUser.getEffectiveGroups().containsAnyOf(okGroupIds)) {
        return Capable.OK;
    }
    final StringBuilder msg = new StringBuilder();
    msg.append(" A Contributor Agreement must be completed before uploading");
    if (canonicalWebUrl != null) {
        msg.append(":\n\n  ");
        msg.append(canonicalWebUrl);
        msg.append("#");
        msg.append(PageLinks.SETTINGS_AGREEMENTS);
        msg.append("\n");
    } else {
        msg.append(".");
    }
    msg.append("\n");
    return new Capable(msg.toString());
}
#method_after
private Capable verifyActiveContributorAgreement() {
    if (!(user.isIdentifiedUser())) {
        return new Capable("Must be logged in to verify Contributor Agreement");
    }
    final IdentifiedUser iUser = user.asIdentifiedUser();
    List<AccountGroup.UUID> okGroupIds = new ArrayList<>();
    for (ContributorAgreement ca : contributorAgreements) {
        List<AccountGroup.UUID> groupIds;
        groupIds = okGroupIds;
        for (PermissionRule rule : ca.getAccepted()) {
            if ((rule.getAction() == Action.ALLOW) && (rule.getGroup() != null) && (rule.getGroup().getUUID() != null)) {
                groupIds.add(new AccountGroup.UUID(rule.getGroup().getUUID().get()));
            }
        }
    }
    if (iUser.getEffectiveGroups().containsAnyOf(okGroupIds)) {
        return Capable.OK;
    }
    final StringBuilder msg = new StringBuilder();
    msg.append(" A Contributor Agreement must be completed before uploading");
    if (canonicalWebUrl != null) {
        msg.append(":\n\n  ");
        msg.append(canonicalWebUrl);
        msg.append("#");
        msg.append(PageLinks.SETTINGS_AGREEMENTS);
        msg.append("\n");
    } else {
        msg.append(".");
    }
    msg.append("\n");
    return new Capable(msg.toString());
}
#end_block

#method_before
public boolean isReviewer(ReviewDb db, @Nullable ChangeData cd) throws OrmException {
    if (getUser().isIdentifiedUser()) {
        Collection<Account.Id> results = changeData(db, cd).reviewers().values();
        return results.contains(getUser().getAccountId());
    }
    return false;
}
#method_after
public boolean isReviewer(ReviewDb db, @Nullable ChangeData cd) throws OrmException {
    if (getUser().isIdentifiedUser()) {
        Collection<Account.Id> results = changeData(db, cd).reviewers().all();
        return results.contains(getUser().getAccountId());
    }
    return false;
}
#end_block

#method_before
void processCommands(Collection<ReceiveCommand> commands, MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    batch = repo.getRefDatabase().newBatchUpdate();
    batch.setPushCertificate(rp.getPushCertificate());
    batch.setRefLogIdent(rp.getRefLogIdent());
    batch.setRefLogMessage("push", true);
    parseCommands(commands);
    if (magicBranch != null && magicBranch.cmd.getResult() == NOT_ATTEMPTED) {
        selectNewAndReplacedChangesFromMagicBranch();
    }
    preparePatchSetsForReplace();
    if (!batch.getCommands().isEmpty()) {
        try {
            if (!batch.isAllowNonFastForwards() && magicBranch != null && magicBranch.edit) {
                batch.setAllowNonFastForwards(true);
            }
            batch.execute(rp.getRevWalk(), commandProgress);
        } catch (IOException err) {
            int cnt = 0;
            for (ReceiveCommand cmd : batch.getCommands()) {
                if (cmd.getResult() == NOT_ATTEMPTED) {
                    cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
                    cnt++;
                }
            }
            log.error(String.format("Failed to store %d refs in %s", cnt, project.getName()), err);
        }
    }
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(user)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    Set<Branch.NameKey> branches = Sets.newHashSet();
    for (ReceiveCommand c : batch.getCommands()) {
        if (c.getResult() == OK) {
            if (c.getType() == ReceiveCommand.Type.UPDATE) {
                // aka fast-forward
                tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
            }
            if (isHead(c) || isConfig(c)) {
                switch(c.getType()) {
                    case CREATE:
                    case UPDATE:
                    case UPDATE_NONFASTFORWARD:
                        autoCloseChanges(c);
                        branches.add(new Branch.NameKey(project.getNameKey(), c.getRefName()));
                        break;
                    case DELETE:
                        break;
                }
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(c.getRefName())) {
                // We only fire gitRefUpdated for direct refs updates.
                // Events for change refs are fired when they are created.
                // 
                gitRefUpdated.fire(project.getNameKey(), c);
                hooks.doRefUpdatedHook(new Branch.NameKey(project.getNameKey(), c.getRefName()), c.getOldId(), c.getNewId(), user.getAccount());
            }
        }
    }
    // Update superproject gitlinks if required.
    SubmoduleOp op = subOpProvider.get();
    try {
        op.updateSuperProjects(db, branches, "receiveID");
    } catch (SubmoduleException e) {
        log.error("Can't update the superprojects", e);
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    reportMessages();
}
#method_after
void processCommands(Collection<ReceiveCommand> commands, MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    batch = repo.getRefDatabase().newBatchUpdate();
    batch.setPushCertificate(rp.getPushCertificate());
    batch.setRefLogIdent(rp.getRefLogIdent());
    batch.setRefLogMessage("push", true);
    parseCommands(commands);
    if (magicBranch != null && magicBranch.cmd.getResult() == NOT_ATTEMPTED) {
        selectNewAndReplacedChangesFromMagicBranch();
    }
    preparePatchSetsForReplace();
    if (!batch.getCommands().isEmpty()) {
        try {
            if (!batch.isAllowNonFastForwards() && magicBranch != null && magicBranch.edit) {
                batch.setAllowNonFastForwards(true);
            }
            batch.execute(rp.getRevWalk(), commandProgress);
        } catch (IOException err) {
            int cnt = 0;
            for (ReceiveCommand cmd : batch.getCommands()) {
                if (cmd.getResult() == NOT_ATTEMPTED) {
                    cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
                    cnt++;
                }
            }
            log.error(String.format("Failed to store %d refs in %s", cnt, project.getName()), err);
        }
    }
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(user)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    Set<Branch.NameKey> branches = new HashSet<>();
    for (ReceiveCommand c : batch.getCommands()) {
        if (c.getResult() == OK) {
            if (c.getType() == ReceiveCommand.Type.UPDATE) {
                // aka fast-forward
                tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
            }
            if (isHead(c) || isConfig(c)) {
                switch(c.getType()) {
                    case CREATE:
                    case UPDATE:
                    case UPDATE_NONFASTFORWARD:
                        autoCloseChanges(c);
                        branches.add(new Branch.NameKey(project.getNameKey(), c.getRefName()));
                        break;
                    case DELETE:
                        break;
                }
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(c.getRefName())) {
                // We only fire gitRefUpdated for direct refs updates.
                // Events for change refs are fired when they are created.
                // 
                gitRefUpdated.fire(project.getNameKey(), c, user.getAccount());
                hooks.doRefUpdatedHook(new Branch.NameKey(project.getNameKey(), c.getRefName()), c.getOldId(), c.getNewId(), user.getAccount());
            }
        }
    }
    // Update superproject gitlinks if required.
    SubmoduleOp op = subOpProvider.get();
    try (MergeOpRepoManager orm = ormProvider.get()) {
        orm.setContext(db, TimeUtil.nowTs(), user);
        op.updateSuperProjects(branches, "receiveID", orm);
    } catch (SubmoduleException e) {
        log.error("Can't update the superprojects", e);
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    reportMessages();
}
#end_block

#method_before
private void insertChangesAndPatchSets() {
    int replaceCount = 0;
    int okToInsert = 0;
    for (Map.Entry<Change.Id, ReplaceRequest> e : replaceByChange.entrySet()) {
        ReplaceRequest replace = e.getValue();
        if (magicBranch != null && replace.inputCommand == magicBranch.cmd) {
            replaceCount++;
            if (replace.cmd != null && replace.cmd.getResult() == OK) {
                okToInsert++;
            }
        } else if (replace.cmd != null && replace.cmd.getResult() == OK) {
            try {
                if (replace.insertPatchSet().checkedGet() != null) {
                    replace.inputCommand.setResult(OK);
                }
            } catch (RestApiException err) {
                reject(replace.inputCommand, "internal server error");
                log.error(String.format("Cannot add patch set to change %d in project %s", e.getKey().get(), project.getName()), err);
            }
        } else if (replace.inputCommand.getResult() == NOT_ATTEMPTED) {
            reject(replace.inputCommand, "internal server error");
            log.error(String.format("Replacement for project %s was not attempted", project.getName()));
        }
    }
    if (magicBranch == null || magicBranch.cmd.getResult() != NOT_ATTEMPTED) {
        // No need to continue.
        return;
    }
    List<String> lastCreateChangeErrors = Lists.newArrayList();
    for (CreateRequest create : newChanges) {
        if (create.cmd.getResult() == OK) {
            okToInsert++;
        } else {
            String createChangeResult = String.format("%s %s", create.cmd.getResult(), Strings.nullToEmpty(create.cmd.getMessage())).trim();
            lastCreateChangeErrors.add(createChangeResult);
            log.error(String.format("Command %s on %s:%s not completed: %s", create.cmd.getType(), project.getName(), create.cmd.getRefName(), createChangeResult));
        }
    }
    if (okToInsert != replaceCount + newChanges.size()) {
        // One or more new references failed to create. Assume the
        // system isn't working correctly anymore and abort.
        reject(magicBranch.cmd, "Unable to create changes: " + Joiner.on(' ').join(lastCreateChangeErrors));
        log.error(String.format("Only %d of %d new change refs created in %s; aborting", okToInsert, replaceCount + newChanges.size(), project.getName()));
        return;
    }
    try {
        List<CheckedFuture<?, RestApiException>> futures = Lists.newArrayList();
        for (ReplaceRequest replace : replaceByChange.values()) {
            if (replace.inputCommand == magicBranch.cmd) {
                futures.add(replace.insertPatchSet());
            }
        }
        for (CreateRequest create : newChanges) {
            futures.add(create.insertChange());
        }
        for (UpdateGroupsRequest update : updateGroups) {
            futures.add(update.updateGroups());
        }
        for (CheckedFuture<?, RestApiException> f : futures) {
            f.checkedGet();
        }
        magicBranch.cmd.setResult(OK);
    } catch (ResourceConflictException e) {
        addMessage(e.getMessage());
        reject(magicBranch.cmd, "conflict");
    } catch (RestApiException err) {
        log.error("Can't insert change/patch set for " + project.getName(), err);
        reject(magicBranch.cmd, "internal server error: " + err.getMessage());
    }
}
#method_after
private void insertChangesAndPatchSets() {
    int replaceCount = 0;
    int okToInsert = 0;
    for (Map.Entry<Change.Id, ReplaceRequest> e : replaceByChange.entrySet()) {
        ReplaceRequest replace = e.getValue();
        if (magicBranch != null && replace.inputCommand == magicBranch.cmd) {
            replaceCount++;
            if (replace.cmd != null && replace.cmd.getResult() == OK) {
                okToInsert++;
            }
        } else if (replace.cmd != null && replace.cmd.getResult() == OK) {
            try {
                if (replace.insertPatchSet().checkedGet() != null) {
                    replace.inputCommand.setResult(OK);
                }
            } catch (RestApiException err) {
                reject(replace.inputCommand, "internal server error");
                log.error(String.format("Cannot add patch set to change %d in project %s", e.getKey().get(), project.getName()), err);
            }
        } else if (replace.inputCommand.getResult() == NOT_ATTEMPTED) {
            reject(replace.inputCommand, "internal server error");
            log.error(String.format("Replacement for project %s was not attempted", project.getName()));
        }
    }
    if (magicBranch == null || magicBranch.cmd.getResult() != NOT_ATTEMPTED) {
        // No need to continue.
        return;
    }
    List<String> lastCreateChangeErrors = new ArrayList<>();
    for (CreateRequest create : newChanges) {
        if (create.cmd.getResult() == OK) {
            okToInsert++;
        } else {
            String createChangeResult = String.format("%s %s", create.cmd.getResult(), Strings.nullToEmpty(create.cmd.getMessage())).trim();
            lastCreateChangeErrors.add(createChangeResult);
            log.error(String.format("Command %s on %s:%s not completed: %s", create.cmd.getType(), project.getName(), create.cmd.getRefName(), createChangeResult));
        }
    }
    if (okToInsert != replaceCount + newChanges.size()) {
        // One or more new references failed to create. Assume the
        // system isn't working correctly anymore and abort.
        reject(magicBranch.cmd, "Unable to create changes: " + Joiner.on(' ').join(lastCreateChangeErrors));
        log.error(String.format("Only %d of %d new change refs created in %s; aborting", okToInsert, replaceCount + newChanges.size(), project.getName()));
        return;
    }
    try {
        List<CheckedFuture<?, RestApiException>> futures = new ArrayList<>();
        for (ReplaceRequest replace : replaceByChange.values()) {
            if (replace.inputCommand == magicBranch.cmd) {
                futures.add(replace.insertPatchSet());
            }
        }
        for (CreateRequest create : newChanges) {
            futures.add(create.insertChange());
        }
        for (UpdateGroupsRequest update : updateGroups) {
            futures.add(update.updateGroups());
        }
        for (CheckedFuture<?, RestApiException> f : futures) {
            f.checkedGet();
        }
        magicBranch.cmd.setResult(OK);
    } catch (ResourceConflictException e) {
        addMessage(e.getMessage());
        reject(magicBranch.cmd, "conflict");
    } catch (RestApiException err) {
        log.error("Can't insert change/patch set for " + project.getName(), err);
        reject(magicBranch.cmd, "internal server error: " + err.getMessage());
    }
}
#end_block

#method_before
private void parseCommands(Collection<ReceiveCommand> commands) {
    for (ReceiveCommand cmd : commands) {
        if (cmd.getResult() != NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseMagicBranch(cmd);
            continue;
        }
        if (allUsersName.equals(projectControl.getProject().getNameKey()) && RefNames.REFS_USERS_SELF.equals(cmd.getRefName())) {
            cmd.setResult(OK);
            String userRefName = RefNames.refsUsers(user.getAccountId());
            try {
                Ref userRef = rp.getRepository().getRefDatabase().exactRef(userRefName);
                ObjectId oldId = userRef != null ? userRef.getObjectId() : ObjectId.zeroId();
                ReceiveCommand.Type type;
                switch(cmd.getType()) {
                    case CREATE:
                    case UPDATE:
                        type = userRef != null ? ReceiveCommand.Type.UPDATE : ReceiveCommand.Type.CREATE;
                        break;
                    case DELETE:
                    case UPDATE_NONFASTFORWARD:
                        type = cmd.getType();
                        break;
                    default:
                        reject(cmd);
                        continue;
                }
                cmd = new ReceiveCommand(oldId, cmd.getNewId(), userRefName, type);
            } catch (IOException e) {
                log.error(String.format("Failed to lookup %s refs in %s", userRefName, project.getName()));
                reject(cmd);
            }
        }
        Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(repo, cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            addError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                addError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                        Project.NameKey newParent = cfg.getProject().getParent(allProjectsName);
                        Project.NameKey oldParent = project.getParent(allProjectsName);
                        if (oldParent == null) {
                            // update of the 'All-Projects' project
                            if (newParent != null) {
                                reject(cmd, "invalid project configuration: root project cannot have parent");
                                continue;
                            }
                        } else {
                            if (!oldParent.equals(newParent) && !user.getCapabilities().canAdministrateServer()) {
                                reject(cmd, "invalid project configuration: only Gerrit admin can set parent");
                                continue;
                            }
                            if (projectCache.get(newParent) == null) {
                                reject(cmd, "invalid project configuration: parent does not exist");
                                continue;
                            }
                        }
                        for (Entry<ProjectConfigEntry> e : pluginConfigEntries) {
                            PluginConfig pluginCfg = cfg.getPluginConfig(e.getPluginName());
                            ProjectConfigEntry configEntry = e.getProvider().get();
                            String value = pluginCfg.getString(e.getExportName());
                            String oldValue = projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getString(e.getExportName());
                            if (configEntry.getType() == ProjectConfigEntry.Type.ARRAY) {
                                List<String> l = Arrays.asList(projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getStringList(e.getExportName()));
                                oldValue = Joiner.on("\n").join(l);
                            }
                            if ((value == null ? oldValue != null : !value.equals(oldValue)) && !configEntry.isEditable(projectControl.getProjectState())) {
                                reject(cmd, String.format("invalid project configuration: Not allowed to set parameter" + " '%s' of plugin '%s' on project '%s'.", e.getExportName(), e.getPluginName(), project.getName()));
                                continue;
                            }
                            if (ProjectConfigEntry.Type.LIST.equals(configEntry.getType()) && value != null && !configEntry.getPermittedValues().contains(value)) {
                                reject(cmd, String.format("invalid project configuration: The value '%s' is " + "not permitted for parameter '%s' of plugin '%s'.", value, e.getExportName(), e.getPluginName()));
                            }
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#method_after
private void parseCommands(Collection<ReceiveCommand> commands) {
    for (ReceiveCommand cmd : commands) {
        if (cmd.getResult() != NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseMagicBranch(cmd);
            continue;
        }
        if (projectControl.getProjectState().isAllUsers() && RefNames.REFS_USERS_SELF.equals(cmd.getRefName())) {
            final ReceiveCommand orgCmd = cmd;
            cmd = new ReceiveCommand(cmd.getOldId(), cmd.getNewId(), RefNames.refsUsers(user.getAccountId()), cmd.getType()) {

                @Override
                public void setResult(Result s, String m) {
                    super.setResult(s, m);
                    orgCmd.setResult(s, m);
                }
            };
        }
        Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(rp.getRevWalk(), cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            addError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                addError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                        Project.NameKey newParent = cfg.getProject().getParent(allProjectsName);
                        Project.NameKey oldParent = project.getParent(allProjectsName);
                        if (oldParent == null) {
                            // update of the 'All-Projects' project
                            if (newParent != null) {
                                reject(cmd, "invalid project configuration: root project cannot have parent");
                                continue;
                            }
                        } else {
                            if (!oldParent.equals(newParent) && !user.getCapabilities().canAdministrateServer()) {
                                reject(cmd, "invalid project configuration: only Gerrit admin can set parent");
                                continue;
                            }
                            if (projectCache.get(newParent) == null) {
                                reject(cmd, "invalid project configuration: parent does not exist");
                                continue;
                            }
                        }
                        for (Entry<ProjectConfigEntry> e : pluginConfigEntries) {
                            PluginConfig pluginCfg = cfg.getPluginConfig(e.getPluginName());
                            ProjectConfigEntry configEntry = e.getProvider().get();
                            String value = pluginCfg.getString(e.getExportName());
                            String oldValue = projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getString(e.getExportName());
                            if (configEntry.getType() == ProjectConfigEntry.Type.ARRAY) {
                                List<String> l = Arrays.asList(projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getStringList(e.getExportName()));
                                oldValue = Joiner.on("\n").join(l);
                            }
                            if ((value == null ? oldValue != null : !value.equals(oldValue)) && !configEntry.isEditable(projectControl.getProjectState())) {
                                reject(cmd, String.format("invalid project configuration: Not allowed to set parameter" + " '%s' of plugin '%s' on project '%s'.", e.getExportName(), e.getPluginName(), project.getName()));
                                continue;
                            }
                            if (ProjectConfigEntry.Type.LIST.equals(configEntry.getType()) && value != null && !configEntry.getPermittedValues().contains(value)) {
                                reject(cmd, String.format("invalid project configuration: The value '%s' is " + "not permitted for parameter '%s' of plugin '%s'.", value, e.getExportName(), e.getPluginName()));
                            }
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#end_block

#method_before
@Option(name = "--hashtag", aliases = { "-t" }, metaVar = "HASHTAG", usage = "add hashtag to changes")
void addHashtag(String token) throws CmdLineException {
    if (!notesMigration.enabled()) {
        throw clp.reject("cannot add hashtags; noteDb is disabled");
    }
    String hashtag = cleanupHashtag(token);
    if (!hashtag.isEmpty()) {
        hashtags.add(hashtag);
    }
// TODO(dpursehouse): validate hashtags
}
#method_after
@Option(name = "--hashtag", aliases = { "-t" }, metaVar = "HASHTAG", usage = "add hashtag to changes")
void addHashtag(String token) throws CmdLineException {
    if (!notesMigration.readChanges()) {
        throw clp.reject("cannot add hashtags; noteDb is disabled");
    }
    String hashtag = cleanupHashtag(token);
    if (!hashtag.isEmpty()) {
        hashtags.add(hashtag);
    }
// TODO(dpursehouse): validate hashtags
}
#end_block

#method_before
private void parseMagicBranch(ReceiveCommand cmd) {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    magicBranch = new MagicBranchInput(cmd, labelTypes, notesMigration);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    magicBranch.clp = clp;
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet());
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    if (!magicBranch.ctl.canWrite()) {
        reject(cmd, "project is read only");
        return;
    }
    if (magicBranch.draft) {
        if (!receiveConfig.allowDrafts) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "draft workflow is disabled");
            return;
        } else if (projectControl.controlForRef("refs/drafts/" + ref).isBlocked(Permission.PUSH)) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "cannot upload drafts");
            return;
        }
    }
    if (!magicBranch.ctl.canUpload()) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload review");
        return;
    }
    if (magicBranch.draft && magicBranch.submit) {
        reject(cmd, "cannot submit draft");
        return;
    }
    if (magicBranch.submit && !projectControl.controlForRef(MagicBranch.NEW_CHANGE + ref).canSubmit()) {
        reject(cmd, "submit not allowed");
        return;
    }
    RevWalk walk = rp.getRevWalk();
    RevCommit tip;
    try {
        tip = walk.parseCommit(magicBranch.cmd.getNewId());
    } catch (IOException ex) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", ex);
        return;
    }
    // if %base was specified, ignore newChangeForAllNotInTarget
    if (tip.getParentCount() > 1 || magicBranch.base != null || tip.getParentCount() == 0) {
        newChangeForAllNotInTarget = false;
    }
    if (magicBranch.base != null) {
        magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
        for (ObjectId id : magicBranch.base) {
            try {
                magicBranch.baseCommit.add(walk.parseCommit(id));
            } catch (IncorrectObjectTypeException notCommit) {
                reject(cmd, "base must be a commit");
                return;
            } catch (MissingObjectException e) {
                reject(cmd, "base not found");
                return;
            } catch (IOException e) {
                log.warn(String.format("Project %s cannot read %s", project.getName(), id.name()), e);
                reject(cmd, "internal server error");
                return;
            }
        }
    } else if (newChangeForAllNotInTarget) {
        String destBranch = magicBranch.dest.get();
        try {
            Ref r = repo.getRefDatabase().exactRef(destBranch);
            if (r == null) {
                reject(cmd, destBranch + " not found");
                return;
            }
            ObjectId baseHead = r.getObjectId();
            magicBranch.baseCommit = Collections.singletonList(walk.parseCommit(baseHead));
        } catch (IOException ex) {
            log.warn(String.format("Project %s cannot read %s", project.getName(), destBranch), ex);
            reject(cmd, "internal server error");
            return;
        }
    }
    // 
    try {
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        RevCommit h = walk.parseCommit(targetRef.getObjectId());
        RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
    }
}
#method_after
private void parseMagicBranch(ReceiveCommand cmd) {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    magicBranch = new MagicBranchInput(cmd, labelTypes, notesMigration);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    magicBranch.clp = clp;
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet());
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (projectControl.getProjectState().isAllUsers() && RefNames.REFS_USERS_SELF.equals(ref)) {
        ref = RefNames.refsUsers(user.getAccountId());
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    if (!magicBranch.ctl.canWrite()) {
        reject(cmd, "project is read only");
        return;
    }
    if (magicBranch.draft) {
        if (!receiveConfig.allowDrafts) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "draft workflow is disabled");
            return;
        } else if (projectControl.controlForRef("refs/drafts/" + ref).isBlocked(Permission.PUSH)) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "cannot upload drafts");
            return;
        }
    }
    if (!magicBranch.ctl.canUpload()) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload review");
        return;
    }
    if (magicBranch.draft && magicBranch.submit) {
        reject(cmd, "cannot submit draft");
        return;
    }
    if (magicBranch.submit && !projectControl.controlForRef(MagicBranch.NEW_CHANGE + ref).canSubmit()) {
        reject(cmd, "submit not allowed");
        return;
    }
    RevWalk walk = rp.getRevWalk();
    RevCommit tip;
    try {
        tip = walk.parseCommit(magicBranch.cmd.getNewId());
    } catch (IOException ex) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", ex);
        return;
    }
    // if %base was specified, ignore newChangeForAllNotInTarget
    if (tip.getParentCount() > 1 || magicBranch.base != null || tip.getParentCount() == 0) {
        newChangeForAllNotInTarget = false;
    }
    if (magicBranch.base != null) {
        magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
        for (ObjectId id : magicBranch.base) {
            try {
                magicBranch.baseCommit.add(walk.parseCommit(id));
            } catch (IncorrectObjectTypeException notCommit) {
                reject(cmd, "base must be a commit");
                return;
            } catch (MissingObjectException e) {
                reject(cmd, "base not found");
                return;
            } catch (IOException e) {
                log.warn(String.format("Project %s cannot read %s", project.getName(), id.name()), e);
                reject(cmd, "internal server error");
                return;
            }
        }
    } else if (newChangeForAllNotInTarget) {
        String destBranch = magicBranch.dest.get();
        try {
            Ref r = repo.getRefDatabase().exactRef(destBranch);
            if (r == null) {
                reject(cmd, destBranch + " not found");
                return;
            }
            ObjectId baseHead = r.getObjectId();
            magicBranch.baseCommit = Collections.singletonList(walk.parseCommit(baseHead));
        } catch (IOException ex) {
            log.warn(String.format("Project %s cannot read %s", project.getName(), destBranch), ex);
            reject(cmd, "internal server error");
            return;
        }
    }
    // 
    try {
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        RevCommit h = walk.parseCommit(targetRef.getObjectId());
        RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
    }
}
#end_block

#method_before
private void selectNewAndReplacedChangesFromMagicBranch() {
    newChanges = Lists.newArrayList();
    SetMultimap<ObjectId, Ref> existing = HashMultimap.create();
    GroupCollector groupCollector = GroupCollector.create(changeRefsById(), db, psUtil, notesFactory, project.getNameKey());
    rp.getRevWalk().reset();
    rp.getRevWalk().sort(RevSort.TOPO);
    rp.getRevWalk().sort(RevSort.REVERSE, true);
    try {
        rp.getRevWalk().markStart(rp.getRevWalk().parseCommit(magicBranch.cmd.getNewId()));
        if (magicBranch.baseCommit != null) {
            for (RevCommit c : magicBranch.baseCommit) {
                rp.getRevWalk().markUninteresting(c);
            }
            Ref targetRef = allRefs.get(magicBranch.ctl.getRefName());
            if (targetRef != null) {
                rp.getRevWalk().markUninteresting(rp.getRevWalk().parseCommit(targetRef.getObjectId()));
            }
        } else {
            markHeadsAsUninteresting(rp.getRevWalk(), existing, magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
        }
        List<ChangeLookup> pending = Lists.newArrayList();
        Set<Change.Key> newChangeIds = new HashSet<>();
        int maxBatchChanges = receiveConfig.getEffectiveMaxBatchChangesLimit(user);
        for (; ; ) {
            RevCommit c = rp.getRevWalk().next();
            if (c == null) {
                break;
            }
            groupCollector.visit(c);
            Collection<Ref> existingRefs = existing.get(c);
            if (!existingRefs.isEmpty()) {
                // A's group.
                for (Ref ref : existingRefs) {
                    updateGroups.add(new UpdateGroupsRequest(ref, c));
                }
                continue;
            }
            if (!validCommit(rp.getRevWalk(), magicBranch.ctl, magicBranch.cmd, c)) {
                // Not a change the user can propose? Abort as early as possible.
                newChanges = Collections.emptyList();
                return;
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
            }
            List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(c, magicBranch.dest.get()));
                continue;
            }
            String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                newChanges = Collections.emptyList();
                return;
            }
            pending.add(new ChangeLookup(c, new Change.Key(idStr)));
            if (maxBatchChanges != 0 && pending.size() + newChanges.size() > maxBatchChanges) {
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                newChanges = Collections.emptyList();
                return;
            }
        }
        for (ChangeLookup p : pending) {
            if (newChangeIds.contains(p.changeKey)) {
                reject(magicBranch.cmd, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
                newChanges = Collections.emptyList();
                return;
            }
            List<ChangeData> changes = p.destChanges;
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 1) {
                // 
                if (requestReplace(magicBranch.cmd, false, changes.get(0).change(), p.commit)) {
                    continue;
                } else {
                    newChanges = Collections.emptyList();
                    return;
                }
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    newChanges = Collections.emptyList();
                    return;
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(p.commit, magicBranch.dest.get()));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        newChanges = Collections.emptyList();
        return;
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        newChanges = Collections.emptyList();
        return;
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return;
    }
    if (!newChanges.isEmpty() && magicBranch.edit) {
        reject(magicBranch.cmd, "edit is not supported for new changes");
        return;
    }
    try {
        SortedSetMultimap<ObjectId, String> groups = groupCollector.getGroups();
        for (CreateRequest create : newChanges) {
            batch.addCommand(create.cmd);
            create.groups = ImmutableList.copyOf(groups.get(create.commitId));
        }
        for (ReplaceRequest replace : replaceByChange.values()) {
            replace.groups = ImmutableList.copyOf(groups.get(replace.newCommitId));
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.groups = ImmutableList.copyOf((groups.get(update.commit)));
        }
    } catch (OrmException | NoSuchChangeException e) {
        log.error("Error collecting groups for changes", e);
        reject(magicBranch.cmd, "internal server error");
        return;
    }
}
#method_after
private void selectNewAndReplacedChangesFromMagicBranch() {
    newChanges = new ArrayList<>();
    SetMultimap<ObjectId, Ref> existing = changeRefsById();
    GroupCollector groupCollector = GroupCollector.create(refsById, db, psUtil, notesFactory, project.getNameKey());
    rp.getRevWalk().reset();
    rp.getRevWalk().sort(RevSort.TOPO);
    rp.getRevWalk().sort(RevSort.REVERSE, true);
    try {
        rp.getRevWalk().markStart(rp.getRevWalk().parseCommit(magicBranch.cmd.getNewId()));
        if (magicBranch.baseCommit != null) {
            for (RevCommit c : magicBranch.baseCommit) {
                rp.getRevWalk().markUninteresting(c);
            }
            Ref targetRef = allRefs.get(magicBranch.ctl.getRefName());
            if (targetRef != null) {
                rp.getRevWalk().markUninteresting(rp.getRevWalk().parseCommit(targetRef.getObjectId()));
            }
        } else {
            markHeadsAsUninteresting(rp.getRevWalk(), magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
        }
        List<ChangeLookup> pending = new ArrayList<>();
        Set<Change.Key> newChangeIds = new HashSet<>();
        int maxBatchChanges = receiveConfig.getEffectiveMaxBatchChangesLimit(user);
        for (; ; ) {
            RevCommit c = rp.getRevWalk().next();
            if (c == null) {
                break;
            }
            groupCollector.visit(c);
            Collection<Ref> existingRefs = existing.get(c);
            if (!existingRefs.isEmpty()) {
                // A's group.
                for (Ref ref : existingRefs) {
                    updateGroups.add(new UpdateGroupsRequest(ref, c));
                }
                continue;
            }
            if (!validCommit(rp.getRevWalk(), magicBranch.ctl, magicBranch.cmd, c)) {
                // Not a change the user can propose? Abort as early as possible.
                newChanges = Collections.emptyList();
                return;
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
            }
            List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(c, magicBranch.dest.get()));
                continue;
            }
            String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                newChanges = Collections.emptyList();
                return;
            }
            pending.add(new ChangeLookup(c, new Change.Key(idStr)));
            if (maxBatchChanges != 0 && pending.size() + newChanges.size() > maxBatchChanges) {
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                newChanges = Collections.emptyList();
                return;
            }
        }
        for (ChangeLookup p : pending) {
            if (newChangeIds.contains(p.changeKey)) {
                reject(magicBranch.cmd, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
                newChanges = Collections.emptyList();
                return;
            }
            List<ChangeData> changes = p.destChanges;
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 1) {
                // 
                if (requestReplace(magicBranch.cmd, false, changes.get(0).change(), p.commit)) {
                    continue;
                } else {
                    newChanges = Collections.emptyList();
                    return;
                }
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    newChanges = Collections.emptyList();
                    return;
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(p.commit, magicBranch.dest.get()));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        newChanges = Collections.emptyList();
        return;
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        newChanges = Collections.emptyList();
        return;
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return;
    }
    if (!newChanges.isEmpty() && magicBranch.edit) {
        reject(magicBranch.cmd, "edit is not supported for new changes");
        return;
    }
    try {
        SortedSetMultimap<ObjectId, String> groups = groupCollector.getGroups();
        for (CreateRequest create : newChanges) {
            batch.addCommand(create.cmd);
            create.groups = ImmutableList.copyOf(groups.get(create.commitId));
        }
        for (ReplaceRequest replace : replaceByChange.values()) {
            replace.groups = ImmutableList.copyOf(groups.get(replace.newCommitId));
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.groups = ImmutableList.copyOf((groups.get(update.commit)));
        }
    } catch (OrmException | NoSuchChangeException e) {
        log.error("Error collecting groups for changes", e);
        reject(magicBranch.cmd, "internal server error");
        return;
    }
}
#end_block

#method_before
private void markHeadsAsUninteresting(final RevWalk walk, SetMultimap<ObjectId, Ref> existing, @Nullable String forRef) {
    for (Ref ref : allRefs.values()) {
        if (ref.getObjectId() == null) {
            continue;
        } else if (ref.getName().startsWith(REFS_CHANGES)) {
            existing.put(ref.getObjectId(), ref);
        } else if (ref.getName().startsWith(R_HEADS) || (forRef != null && forRef.equals(ref.getName()))) {
            try {
                walk.markUninteresting(walk.parseCommit(ref.getObjectId()));
            } catch (IOException e) {
                log.warn(String.format("Invalid ref %s in %s", ref.getName(), project.getName()), e);
                continue;
            }
        }
    }
}
#method_after
private void markHeadsAsUninteresting(RevWalk rw, @Nullable String forRef) {
    for (Ref ref : allRefs.values()) {
        if ((ref.getName().startsWith(R_HEADS) || ref.getName().equals(forRef)) && ref.getObjectId() != null) {
            try {
                rw.markUninteresting(rw.parseCommit(ref.getObjectId()));
            } catch (IOException e) {
                log.warn(String.format("Invalid ref %s in %s", ref.getName(), project.getName()), e);
            }
        }
    }
}
#end_block

#method_before
private void insertChange(RequestState state) throws OrmException, IOException, RestApiException, UpdateException, NoSuchChangeException {
    RevCommit commit = state.rw.parseCommit(commitId);
    state.rw.parseBody(commit);
    final PatchSet.Id psId = ins.setGroups(groups).getPatchSetId();
    Account.Id me = user.getAccountId();
    List<FooterLine> footerLines = commit.getFooterLines();
    MailRecipients recipients = new MailRecipients();
    Map<String, Short> approvals = new HashMap<>();
    checkNotNull(magicBranch);
    recipients.add(magicBranch.getMailRecipients());
    approvals = magicBranch.labels;
    recipients.add(getRecipientsFromFooters(accountResolver, magicBranch.draft, footerLines));
    recipients.remove(me);
    StringBuilder msg = new StringBuilder(ApprovalsUtil.renderMessageWithApprovals(psId.get(), approvals, Collections.<String, PatchSetApproval>emptyMap()));
    if (!Strings.isNullOrEmpty(magicBranch.message)) {
        msg.append("\n").append(magicBranch.message);
    }
    try (BatchUpdate bu = batchUpdateFactory.create(state.db, magicBranch.dest.getParentKey(), user, TimeUtil.nowTs())) {
        bu.setRepository(state.repo, state.rw, state.ins);
        bu.insertChange(ins.setReviewers(recipients.getReviewers()).setExtraCC(recipients.getCcOnly()).setApprovals(approvals).setMessage(msg.toString()).setNotify(magicBranch.notify).setRequestScopePropagator(requestScopePropagator).setSendMail(true).setUpdateRef(true));
        bu.addOp(changeId, hashtagsFactory.create(new HashtagsInput(magicBranch.hashtags)).setRunHooks(false));
        if (!Strings.isNullOrEmpty(magicBranch.topic)) {
            bu.addOp(changeId, new BatchUpdate.Op() {

                @Override
                public boolean updateChange(ChangeContext ctx) {
                    ctx.getUpdate(psId).setTopic(magicBranch.topic);
                    return true;
                }
            });
        }
        bu.execute();
    }
    change = ins.getChange();
    if (magicBranch.submit) {
        submit(projectControl.controlFor(state.db, change), ins.getPatchSet());
    }
}
#method_after
private void insertChange(RequestState state) throws OrmException, IOException, RestApiException, UpdateException, NoSuchChangeException {
    RevCommit commit = state.rw.parseCommit(commitId);
    state.rw.parseBody(commit);
    final PatchSet.Id psId = ins.setGroups(groups).getPatchSetId();
    Account.Id me = user.getAccountId();
    List<FooterLine> footerLines = commit.getFooterLines();
    MailRecipients recipients = new MailRecipients();
    Map<String, Short> approvals = new HashMap<>();
    checkNotNull(magicBranch);
    recipients.add(magicBranch.getMailRecipients());
    approvals = magicBranch.labels;
    recipients.add(getRecipientsFromFooters(accountResolver, magicBranch.draft, footerLines));
    recipients.remove(me);
    StringBuilder msg = new StringBuilder(ApprovalsUtil.renderMessageWithApprovals(psId.get(), approvals, Collections.<String, PatchSetApproval>emptyMap()));
    if (!Strings.isNullOrEmpty(magicBranch.message)) {
        msg.append("\n").append(magicBranch.message);
    }
    try (BatchUpdate bu = batchUpdateFactory.create(state.db, magicBranch.dest.getParentKey(), user, TimeUtil.nowTs())) {
        bu.setRepository(state.repo, state.rw, state.ins);
        bu.insertChange(ins.setReviewers(recipients.getReviewers()).setExtraCC(recipients.getCcOnly()).setApprovals(approvals).setMessage(msg.toString()).setNotify(magicBranch.notify).setRequestScopePropagator(requestScopePropagator).setSendMail(true).setUpdateRef(true));
        if (!magicBranch.hashtags.isEmpty()) {
            bu.addOp(changeId, hashtagsFactory.create(new HashtagsInput(magicBranch.hashtags)).setRunHooks(false));
        }
        if (!Strings.isNullOrEmpty(magicBranch.topic)) {
            bu.addOp(changeId, new BatchUpdate.Op() {

                @Override
                public boolean updateChange(ChangeContext ctx) {
                    ctx.getUpdate(psId).setTopic(magicBranch.topic);
                    return true;
                }
            });
        }
        bu.execute();
    }
    change = ins.getChange();
    if (magicBranch.submit) {
        submit(projectControl.controlFor(state.db, change), ins.getPatchSet());
    }
}
#end_block

#method_before
boolean validate(boolean autoClose) throws IOException, OrmException {
    if (!autoClose && inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    } else if (change == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    priorPatchSet = change.currentPatchSetId();
    if (!revisions.containsValue(priorPatchSet)) {
        reject(inputCommand, "change " + ontoChange + " missing revisions");
        return false;
    }
    RevCommit newCommit = rp.getRevWalk().parseCommit(newCommitId);
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    if (newCommit.equals(priorCommit)) {
        // Ignore requests to make the change its current state.
        skip = true;
        reject(inputCommand, "commit already exists (as current patchset)");
        return false;
    }
    changeCtl = projectControl.controlFor(db, change);
    if (!changeCtl.canAddPatchSet(db)) {
        String locked = ".";
        if (changeCtl.isPatchSetLocked(db)) {
            locked = ". Change is patch set locked.";
        }
        reject(inputCommand, "cannot replace " + ontoChange + locked);
        return false;
    } else if (change.getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    } else if (revisions.containsKey(newCommit)) {
        reject(inputCommand, "commit already exists (in the change)");
        return false;
    }
    for (Ref r : rp.getRepository().getRefDatabase().getRefs("refs/changes").values()) {
        if (r.getObjectId().equals(newCommit)) {
            reject(inputCommand, "commit already exists (in the project)");
            return false;
        }
    }
    for (RevCommit prior : revisions.keySet()) {
        // amending when trying to address review comments.
        if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
            reject(inputCommand, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
            return false;
        }
    }
    if (!validCommit(rp.getRevWalk(), changeCtl.getRefControl(), inputCommand, newCommit)) {
        return false;
    }
    rp.getRevWalk().parseBody(priorCommit);
    // of the commit was modified.
    if (newCommit.getTree().equals(priorCommit.getTree())) {
        boolean messageEq = eq(newCommit.getFullMessage(), priorCommit.getFullMessage());
        boolean parentsEq = parentsEqual(newCommit, priorCommit);
        boolean authorEq = authorEqual(newCommit, priorCommit);
        ObjectReader reader = rp.getRevWalk().getObjectReader();
        if (messageEq && parentsEq && authorEq && !autoClose) {
            addMessage(String.format("(W) No changes between prior commit %s and new commit %s", reader.abbreviate(priorCommit).name(), reader.abbreviate(newCommit).name()));
        } else {
            StringBuilder msg = new StringBuilder();
            msg.append("(W) ");
            msg.append(reader.abbreviate(newCommit).name());
            msg.append(":");
            msg.append(" no files changed");
            if (!authorEq) {
                msg.append(", author changed");
            }
            if (!messageEq) {
                msg.append(", message updated");
            }
            if (!parentsEq) {
                msg.append(", was rebased");
            }
            addMessage(msg.toString());
        }
    }
    if (magicBranch != null && magicBranch.edit) {
        return newEdit();
    }
    newPatchSet();
    return true;
}
#method_after
boolean validate(boolean autoClose) throws IOException, OrmException {
    if (!autoClose && inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    } else if (change == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    priorPatchSet = change.currentPatchSetId();
    if (!revisions.containsValue(priorPatchSet)) {
        reject(inputCommand, "change " + ontoChange + " missing revisions");
        return false;
    }
    RevCommit newCommit = rp.getRevWalk().parseCommit(newCommitId);
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    if (newCommit.equals(priorCommit)) {
        // Ignore requests to make the change its current state.
        skip = true;
        reject(inputCommand, "commit already exists (as current patchset)");
        return false;
    }
    changeCtl = projectControl.controlFor(db, change);
    if (!changeCtl.canAddPatchSet(db)) {
        String locked = ".";
        if (changeCtl.isPatchSetLocked(db)) {
            locked = ". Change is patch set locked.";
        }
        reject(inputCommand, "cannot replace " + ontoChange + locked);
        return false;
    } else if (change.getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    } else if (revisions.containsKey(newCommit)) {
        reject(inputCommand, "commit already exists (in the change)");
        return false;
    }
    for (Ref r : rp.getRepository().getRefDatabase().getRefs("refs/changes").values()) {
        if (r.getObjectId().equals(newCommit)) {
            reject(inputCommand, "commit already exists (in the project)");
            return false;
        }
    }
    for (RevCommit prior : revisions.keySet()) {
        // amending when trying to address review comments.
        if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
            reject(inputCommand, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
            return false;
        }
    }
    if (!validCommit(rp.getRevWalk(), changeCtl.getRefControl(), inputCommand, newCommit)) {
        return false;
    }
    rp.getRevWalk().parseBody(priorCommit);
    // of the commit was modified.
    if (newCommit.getTree().equals(priorCommit.getTree())) {
        boolean messageEq = eq(newCommit.getFullMessage(), priorCommit.getFullMessage());
        boolean parentsEq = parentsEqual(newCommit, priorCommit);
        boolean authorEq = authorEqual(newCommit, priorCommit);
        ObjectReader reader = rp.getRevWalk().getObjectReader();
        if (messageEq && parentsEq && authorEq && !autoClose) {
            addMessage(String.format("(W) No changes between prior commit %s and new commit %s", reader.abbreviate(priorCommit).name(), reader.abbreviate(newCommit).name()));
        } else {
            StringBuilder msg = new StringBuilder();
            msg.append("(I) ");
            msg.append(reader.abbreviate(newCommit).name());
            msg.append(":");
            msg.append(" no files changed");
            if (!authorEq) {
                msg.append(", author changed");
            }
            if (!messageEq) {
                msg.append(", message updated");
            }
            if (!parentsEq) {
                msg.append(", was rebased");
            }
            addMessage(msg.toString());
        }
    }
    if (magicBranch != null && magicBranch.edit) {
        return newEdit();
    }
    newPatchSet();
    return true;
}
#end_block

#method_before
PatchSet.Id insertPatchSet(RequestState state) throws OrmException, IOException, RestApiException, UpdateException, NoSuchChangeException {
    RevCommit newCommit = state.rw.parseCommit(newCommitId);
    state.rw.parseBody(newCommit);
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    ReplaceOp replaceOp = replaceOpFactory.create(requestScopePropagator, projectControl, checkMergedInto, priorPatchSet, priorCommit, psId, newCommit, info, groups, magicBranch, rp.getPushCertificate());
    try (BatchUpdate bu = batchUpdateFactory.create(state.db, project.getNameKey(), user, TimeUtil.nowTs())) {
        bu.setRepository(state.repo, state.rw, state.ins);
        bu.addOp(change.getId(), replaceOp);
        bu.execute();
    }
    if (replaceOp.getRejectMessage() != null) {
        reject(inputCommand, replaceOp.getRejectMessage());
        return null;
    }
    groups = replaceOp.getGroups();
    // TODO(ekempin): mark changes as merged inside of ReplaceOp
    if (replaceOp.getMergedIntoRef() != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, info, replaceOp.getMergedIntoRef());
    }
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    PatchSet newPatchSet = replaceOp.getPatchSet();
    gitRefUpdated.fire(project.getNameKey(), newPatchSet.getRefName(), ObjectId.zeroId(), newCommit);
    if (magicBranch != null && magicBranch.submit) {
        submit(changeCtl, newPatchSet);
    }
    return newPatchSet.getId();
}
#method_after
PatchSet.Id insertPatchSet(RequestState state) throws OrmException, IOException, RestApiException, UpdateException, NoSuchChangeException {
    RevCommit newCommit = state.rw.parseCommit(newCommitId);
    state.rw.parseBody(newCommit);
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    ReplaceOp replaceOp = replaceOpFactory.create(requestScopePropagator, projectControl, checkMergedInto, priorPatchSet, priorCommit, psId, newCommit, info, groups, magicBranch, rp.getPushCertificate());
    try (BatchUpdate bu = batchUpdateFactory.create(state.db, project.getNameKey(), user, TimeUtil.nowTs())) {
        bu.setRepository(state.repo, state.rw, state.ins);
        bu.addOp(change.getId(), replaceOp);
        bu.execute();
    }
    if (replaceOp.getRejectMessage() != null) {
        reject(inputCommand, replaceOp.getRejectMessage());
        return null;
    }
    groups = replaceOp.getGroups();
    // TODO(ekempin): mark changes as merged inside of ReplaceOp
    if (replaceOp.getMergedIntoRef() != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, info, replaceOp.getMergedIntoRef());
    }
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    PatchSet newPatchSet = replaceOp.getPatchSet();
    gitRefUpdated.fire(project.getNameKey(), newPatchSet.getRefName(), ObjectId.zeroId(), newCommit, user.getAccount());
    if (magicBranch != null && magicBranch.submit) {
        submit(changeCtl, newPatchSet);
    }
    return newPatchSet.getId();
}
#end_block

#method_before
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    if (ctl.canForgeAuthor() && ctl.canForgeCommitter() && ctl.canForgeGerritServerIdentity() && ctl.canUploadMerges() && !projectControl.getProjectState().isUseSignedOffBy() && Iterables.isEmpty(rejectCommits) && !RefNames.REFS_CONFIG.equals(ctl.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        return;
    }
    boolean defaultName = Strings.isNullOrEmpty(user.getAccount().getFullName());
    RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        RevObject parsedObject = walk.parseAny(cmd.getNewId());
        if (!(parsedObject instanceof RevCommit)) {
            return;
        }
        SetMultimap<ObjectId, Ref> existing = HashMultimap.create();
        walk.markStart((RevCommit) parsedObject);
        markHeadsAsUninteresting(walk, existing, cmd.getRefName());
        for (RevCommit c; (c = walk.next()) != null; ) {
            if (existing.keySet().contains(c)) {
                continue;
            } else if (!validCommit(walk, ctl, cmd, c)) {
                break;
            }
            if (defaultName && user.hasEmailAddress(c.getCommitterIdent().getEmailAddress())) {
                try {
                    Account a = db.accounts().get(user.getAccountId());
                    if (a != null && Strings.isNullOrEmpty(a.getFullName())) {
                        a.setFullName(c.getCommitterIdent().getName());
                        db.accounts().update(Collections.singleton(a));
                        user.getAccount().setFullName(a.getFullName());
                        accountCache.evict(a.getId());
                    }
                } catch (OrmException e) {
                    log.warn("Cannot default full_name", e);
                } finally {
                    defaultName = false;
                }
            }
        }
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#method_after
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    if (ctl.canForgeAuthor() && ctl.canForgeCommitter() && ctl.canForgeGerritServerIdentity() && ctl.canUploadMerges() && !projectControl.getProjectState().isUseSignedOffBy() && Iterables.isEmpty(rejectCommits) && !RefNames.REFS_CONFIG.equals(ctl.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        return;
    }
    boolean defaultName = Strings.isNullOrEmpty(user.getAccount().getFullName());
    RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        RevObject parsedObject = walk.parseAny(cmd.getNewId());
        if (!(parsedObject instanceof RevCommit)) {
            return;
        }
        walk.markStart((RevCommit) parsedObject);
        markHeadsAsUninteresting(walk, cmd.getRefName());
        Set<ObjectId> existing = changeRefsById().keySet();
        for (RevCommit c; (c = walk.next()) != null; ) {
            if (existing.contains(c)) {
                continue;
            } else if (!validCommit(walk, ctl, cmd, c)) {
                break;
            }
            if (defaultName && user.hasEmailAddress(c.getCommitterIdent().getEmailAddress())) {
                try {
                    Account a = db.accounts().get(user.getAccountId());
                    if (a != null && Strings.isNullOrEmpty(a.getFullName())) {
                        a.setFullName(c.getCommitterIdent().getName());
                        db.accounts().update(Collections.singleton(a));
                        user.getAccount().setFullName(a.getFullName());
                        accountCache.evict(a.getId());
                    }
                } catch (OrmException e) {
                    log.warn("Cannot default full_name", e);
                } finally {
                    defaultName = false;
                }
            }
        }
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#end_block

#method_before
private void markChangeMergedByPush(ReviewDb db, final PatchSetInfo info, final String mergedIntoRef) throws UpdateException, RestApiException {
    try (BatchUpdate bu = batchUpdateFactory.create(db, project.getNameKey(), user, TimeUtil.nowTs())) {
        bu.addOp(info.getKey().getParentKey(), new BatchUpdate.Op() {

            @Override
            public boolean updateChange(ChangeContext ctx) throws OrmException {
                Change change = ctx.getChange();
                ChangeUpdate update = ctx.getUpdate(info.getKey());
                if (change.getStatus().isOpen()) {
                    change.setCurrentPatchSet(info);
                    change.setStatus(Change.Status.MERGED);
                    ctx.saveChange();
                    // we cannot reconstruct the submit records for when this change was
                    // submitted, this is why we must fix the status
                    update.fixStatus(Change.Status.MERGED);
                }
                StringBuilder msgBuf = new StringBuilder();
                msgBuf.append("Change has been successfully pushed");
                if (!mergedIntoRef.equals(change.getDest().get())) {
                    msgBuf.append(" into ");
                    if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
                        msgBuf.append("branch ");
                        msgBuf.append(Repository.shortenRefName(mergedIntoRef));
                    } else {
                        msgBuf.append(mergedIntoRef);
                    }
                }
                msgBuf.append(".");
                ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(ctx.getDb())), user.getAccountId(), ctx.getWhen(), info.getKey());
                msg.setMessage(msgBuf.toString());
                cmUtil.addChangeMessage(ctx.getDb(), update, msg);
                PatchSetApproval submitter = new PatchSetApproval(new PatchSetApproval.Key(change.currentPatchSetId(), ctx.getUser().getAccountId(), LabelId.legacySubmit()), (short) 1, ctx.getWhen());
                update.putApproval(submitter.getLabel(), submitter.getValue());
                ctx.getDb().patchSetApprovals().upsert(Collections.singleton(submitter));
                return true;
            }
        });
        bu.execute();
    }
}
#method_after
private void markChangeMergedByPush(ReviewDb db, final PatchSetInfo info, final String mergedIntoRef) throws UpdateException, RestApiException {
    try (BatchUpdate bu = batchUpdateFactory.create(db, project.getNameKey(), user, TimeUtil.nowTs())) {
        bu.addOp(info.getKey().getParentKey(), new BatchUpdate.Op() {

            @Override
            public boolean updateChange(ChangeContext ctx) throws OrmException {
                Change change = ctx.getChange();
                ChangeUpdate update = ctx.getUpdate(info.getKey());
                if (change.getStatus().isOpen()) {
                    change.setCurrentPatchSet(info);
                    change.setStatus(Change.Status.MERGED);
                    // we cannot reconstruct the submit records for when this change was
                    // submitted, this is why we must fix the status
                    update.fixStatus(Change.Status.MERGED);
                }
                StringBuilder msgBuf = new StringBuilder();
                msgBuf.append("Change has been successfully pushed");
                if (!mergedIntoRef.equals(change.getDest().get())) {
                    msgBuf.append(" into ");
                    if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
                        msgBuf.append("branch ");
                        msgBuf.append(Repository.shortenRefName(mergedIntoRef));
                    } else {
                        msgBuf.append(mergedIntoRef);
                    }
                }
                msgBuf.append(".");
                ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(ctx.getDb())), user.getAccountId(), ctx.getWhen(), info.getKey());
                msg.setMessage(msgBuf.toString());
                cmUtil.addChangeMessage(ctx.getDb(), update, msg);
                PatchSetApproval submitter = new PatchSetApproval(new PatchSetApproval.Key(change.currentPatchSetId(), ctx.getUser().getAccountId(), LabelId.legacySubmit()), (short) 1, ctx.getWhen());
                update.putApproval(submitter.getLabel(), submitter.getValue());
                ctx.getDb().patchSetApprovals().upsert(Collections.singleton(submitter));
                return true;
            }
        });
        bu.execute();
    }
}
#end_block

#method_before
@Override
public Response<?> apply(ChangeEditResource rsrc) throws IOException {
    try {
        ChangeEdit edit = rsrc.getChangeEdit();
        return Response.ok(fileContentUtil.getContent(rsrc.getControl().getProjectControl().getProjectState(), base ? ObjectId.fromString(edit.getRevision().get()) : ObjectId.fromString(edit.getBasePatchSet().getRevision().get()), rsrc.getPath()));
    } catch (ResourceNotFoundException rnfe) {
        return Response.none();
    }
}
#method_after
@Override
public Response<?> apply(ChangeEditResource rsrc) throws IOException {
    try {
        ChangeEdit edit = rsrc.getChangeEdit();
        return Response.ok(fileContentUtil.getContent(rsrc.getControl().getProjectControl().getProjectState(), base ? ObjectId.fromString(edit.getBasePatchSet().getRevision().get()) : ObjectId.fromString(edit.getRevision().get()), rsrc.getPath()));
    } catch (ResourceNotFoundException rnfe) {
        return Response.none();
    }
}
#end_block

#method_before
public static void get(PatchSet.Id id, String path, boolean base, HttpCallback<NativeString> cb) {
    RestApi api;
    if (id.get() != 0) {
        // Read from a published revision, when change edit doesn't
        // exist for the caller, or is not currently active.
        api = ChangeApi.revision(id).view("files").id(path).view("content");
    } else if (Patch.COMMIT_MSG.equals(path)) {
        api = editMessage(id.getParentKey().get());
    } else {
        api = editFile(id.getParentKey().get(), path);
    }
    api.addParameter("base", base).get(cb);
}
#method_after
public static void get(PatchSet.Id id, String path, boolean base, HttpCallback<NativeString> cb) {
    RestApi api;
    if (id.get() != 0) {
        // Read from a published revision, when change edit doesn't
        // exist for the caller, or is not currently active.
        api = ChangeApi.revision(id).view("files").id(path).view("content");
    } else if (Patch.COMMIT_MSG.equals(path)) {
        api = editMessage(id.getParentKey().get()).addParameter("base", base);
    } else {
        api = editFile(id.getParentKey().get(), path).addParameter("base", base);
    }
    api.get(cb);
}
#end_block

#method_before
@Test
public void starUnstarChange() throws Exception {
    PushOneCommit.Result r = createChange();
    String triplet = project.get() + "~master~" + r.getChangeId();
    gApi.accounts().self().starChange(triplet);
    ChangeInfo change = info(triplet);
    assertThat(change.starred).isTrue();
    assertThat(change.stars).contains(StarredChangesUtil.DEFAULT_LABEL);
    gApi.accounts().self().unstarChange(triplet);
    change = info(triplet);
    assertThat(change.starred).isNull();
    assertThat(change.stars).isNull();
}
#method_after
@Test
public void starUnstarChange() throws Exception {
    PushOneCommit.Result r = createChange();
    String triplet = project.get() + "~master~" + r.getChangeId();
    gApi.accounts().self().starChange(triplet);
    ChangeInfo change = info(triplet);
    assertThat(change.starred).isTrue();
    assertThat(change.stars).contains(DEFAULT_LABEL);
    gApi.accounts().self().unstarChange(triplet);
    change = info(triplet);
    assertThat(change.starred).isNull();
    assertThat(change.stars).isNull();
}
#end_block

#method_before
@Test
public void starUnstarChangeWithLabels() throws Exception {
    PushOneCommit.Result r = createChange();
    String triplet = project.get() + "~master~" + r.getChangeId();
    assertThat(gApi.accounts().self().getStars(triplet)).isEmpty();
    assertThat(gApi.accounts().self().getStarredChanges()).isEmpty();
    gApi.accounts().self().setStars(triplet, new StarsInput(new HashSet<>(Arrays.asList(StarredChangesUtil.DEFAULT_LABEL, "red", "blue"))));
    ChangeInfo change = info(triplet);
    assertThat(change.starred).isTrue();
    assertThat(change.stars).containsExactly("blue", "red", StarredChangesUtil.DEFAULT_LABEL).inOrder();
    assertThat(gApi.accounts().self().getStars(triplet)).containsExactly("blue", "red", StarredChangesUtil.DEFAULT_LABEL).inOrder();
    List<ChangeInfo> starredChanges = gApi.accounts().self().getStarredChanges();
    assertThat(starredChanges).hasSize(1);
    ChangeInfo starredChange = starredChanges.get(0);
    assertThat(starredChange._number).isEqualTo(r.getChange().getId().get());
    assertThat(starredChange.starred).isTrue();
    assertThat(starredChange.stars).containsExactly("blue", "red", StarredChangesUtil.DEFAULT_LABEL).inOrder();
    gApi.accounts().self().setStars(triplet, new StarsInput(new HashSet<>(Arrays.asList("yellow")), new HashSet<>(Arrays.asList(StarredChangesUtil.DEFAULT_LABEL, "blue"))));
    change = info(triplet);
    assertThat(change.starred).isNull();
    assertThat(change.stars).containsExactly("red", "yellow").inOrder();
    assertThat(gApi.accounts().self().getStars(triplet)).containsExactly("red", "yellow").inOrder();
    starredChanges = gApi.accounts().self().getStarredChanges();
    assertThat(starredChanges).hasSize(1);
    starredChange = starredChanges.get(0);
    assertThat(starredChange._number).isEqualTo(r.getChange().getId().get());
    assertThat(starredChange.starred).isNull();
    assertThat(starredChange.stars).containsExactly("red", "yellow").inOrder();
    setApiUser(user);
    exception.expect(AuthException.class);
    exception.expectMessage("not allowed to get stars of another account");
    gApi.accounts().id(Integer.toString((admin.id.get()))).getStars(triplet);
}
#method_after
@Test
public void starUnstarChangeWithLabels() throws Exception {
    PushOneCommit.Result r = createChange();
    String triplet = project.get() + "~master~" + r.getChangeId();
    assertThat(gApi.accounts().self().getStars(triplet)).isEmpty();
    assertThat(gApi.accounts().self().getStarredChanges()).isEmpty();
    gApi.accounts().self().setStars(triplet, new StarsInput(ImmutableSet.of(DEFAULT_LABEL, "red", "blue")));
    ChangeInfo change = info(triplet);
    assertThat(change.starred).isTrue();
    assertThat(change.stars).containsExactly("blue", "red", DEFAULT_LABEL).inOrder();
    assertThat(gApi.accounts().self().getStars(triplet)).containsExactly("blue", "red", DEFAULT_LABEL).inOrder();
    List<ChangeInfo> starredChanges = gApi.accounts().self().getStarredChanges();
    assertThat(starredChanges).hasSize(1);
    ChangeInfo starredChange = starredChanges.get(0);
    assertThat(starredChange._number).isEqualTo(r.getChange().getId().get());
    assertThat(starredChange.starred).isTrue();
    assertThat(starredChange.stars).containsExactly("blue", "red", DEFAULT_LABEL).inOrder();
    gApi.accounts().self().setStars(triplet, new StarsInput(ImmutableSet.of("yellow"), ImmutableSet.of(DEFAULT_LABEL, "blue")));
    change = info(triplet);
    assertThat(change.starred).isNull();
    assertThat(change.stars).containsExactly("red", "yellow").inOrder();
    assertThat(gApi.accounts().self().getStars(triplet)).containsExactly("red", "yellow").inOrder();
    starredChanges = gApi.accounts().self().getStarredChanges();
    assertThat(starredChanges).hasSize(1);
    starredChange = starredChanges.get(0);
    assertThat(starredChange._number).isEqualTo(r.getChange().getId().get());
    assertThat(starredChange.starred).isNull();
    assertThat(starredChange.stars).containsExactly("red", "yellow").inOrder();
    setApiUser(user);
    exception.expect(AuthException.class);
    exception.expectMessage("not allowed to get stars of another account");
    gApi.accounts().id(Integer.toString((admin.id.get()))).getStars(triplet);
}
#end_block

#method_before
@Test
public void starWithInvalidLabels() throws Exception {
    PushOneCommit.Result r = createChange();
    String triplet = project.get() + "~master~" + r.getChangeId();
    exception.expect(BadRequestException.class);
    exception.expectMessage("invalid labels: another invalid label, invalid label");
    gApi.accounts().self().setStars(triplet, new StarsInput(new HashSet<>(Arrays.asList(StarredChangesUtil.DEFAULT_LABEL, "invalid label", "blue", "another invalid label"))));
}
#method_after
@Test
public void starWithInvalidLabels() throws Exception {
    PushOneCommit.Result r = createChange();
    String triplet = project.get() + "~master~" + r.getChangeId();
    exception.expect(BadRequestException.class);
    exception.expectMessage("invalid labels: another invalid label, invalid label");
    gApi.accounts().self().setStars(triplet, new StarsInput(ImmutableSet.of(DEFAULT_LABEL, "invalid label", "blue", "another invalid label")));
}
#end_block

#method_before
@Test
public void starWithDefaultAndIgnoreLabel() throws Exception {
    PushOneCommit.Result r = createChange();
    String triplet = project.get() + "~master~" + r.getChangeId();
    exception.expect(BadRequestException.class);
    exception.expectMessage("The labels " + StarredChangesUtil.DEFAULT_LABEL + " and " + StarredChangesUtil.IGNORE_LABEL + " are mutually exclusive." + " Only one of them can be set.");
    gApi.accounts().self().setStars(triplet, new StarsInput(new HashSet<>(Arrays.asList(StarredChangesUtil.DEFAULT_LABEL, "blue", StarredChangesUtil.IGNORE_LABEL))));
}
#method_after
@Test
public void starWithDefaultAndIgnoreLabel() throws Exception {
    PushOneCommit.Result r = createChange();
    String triplet = project.get() + "~master~" + r.getChangeId();
    exception.expect(BadRequestException.class);
    exception.expectMessage("The labels " + DEFAULT_LABEL + " and " + IGNORE_LABEL + " are mutually exclusive." + " Only one of them can be set.");
    gApi.accounts().self().setStars(triplet, new StarsInput(ImmutableSet.of(DEFAULT_LABEL, "blue", IGNORE_LABEL)));
}
#end_block

#method_before
@Test
public void ignoreChange() throws Exception {
    PushOneCommit.Result r = createChange();
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    gApi.changes().id(r.getChangeId()).addReviewer(in);
    setApiUser(user);
    gApi.accounts().self().setStars(r.getChangeId(), new StarsInput(ImmutableSet.of(StarredChangesUtil.IGNORE_LABEL)));
    sender.clear();
    setApiUser(admin);
    gApi.changes().id(r.getChangeId()).abandon();
    assertThat(sender.getMessages()).hasSize(0);
}
#method_after
@Test
public void ignoreChange() throws Exception {
    PushOneCommit.Result r = createChange();
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    gApi.changes().id(r.getChangeId()).addReviewer(in);
    TestAccount user2 = accounts.user2();
    in = new AddReviewerInput();
    in.reviewer = user2.email;
    gApi.changes().id(r.getChangeId()).addReviewer(in);
    setApiUser(user);
    gApi.accounts().self().setStars(r.getChangeId(), new StarsInput(ImmutableSet.of(IGNORE_LABEL)));
    sender.clear();
    setApiUser(admin);
    gApi.changes().id(r.getChangeId()).abandon();
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    assertThat(messages.get(0).rcpt()).containsExactly(user2.emailAddress);
}
#end_block

#method_before
@Test
public void sshKeys() throws Exception {
    // The test account should initially have exactly one ssh key
    List<SshKeyInfo> info = gApi.accounts().self().listSshKeys();
    assertThat(info).hasSize(1);
    SshKeyInfo key = info.get(0);
    String inital = AccountCreator.publicKey(admin.sshKey, admin.email);
    assertThat(key.sshPublicKey).isEqualTo(inital);
    // Add a new key
    String newKey = AccountCreator.publicKey(AccountCreator.genSshKey(), admin.email);
    gApi.accounts().self().addSshKey(newKey);
    info = gApi.accounts().self().listSshKeys();
    assertThat(info).hasSize(2);
    // Add an existing key again
    gApi.accounts().self().addSshKey(inital);
    info = gApi.accounts().self().listSshKeys();
    assertThat(info).hasSize(3);
}
#method_after
@Test
public void sshKeys() throws Exception {
    // The test account should initially have exactly one ssh key
    List<SshKeyInfo> info = gApi.accounts().self().listSshKeys();
    assertThat(info).hasSize(1);
    assertSequenceNumbers(info);
    SshKeyInfo key = info.get(0);
    String inital = AccountCreator.publicKey(admin.sshKey, admin.email);
    assertThat(key.sshPublicKey).isEqualTo(inital);
    // Add a new key
    String newKey = AccountCreator.publicKey(AccountCreator.genSshKey(), admin.email);
    gApi.accounts().self().addSshKey(newKey);
    info = gApi.accounts().self().listSshKeys();
    assertThat(info).hasSize(2);
    assertSequenceNumbers(info);
    // Add an existing key (the request succeeds, but the key isn't added again)
    gApi.accounts().self().addSshKey(inital);
    info = gApi.accounts().self().listSshKeys();
    assertThat(info).hasSize(2);
    assertSequenceNumbers(info);
    // Add another new key
    String newKey2 = AccountCreator.publicKey(AccountCreator.genSshKey(), admin.email);
    gApi.accounts().self().addSshKey(newKey2);
    info = gApi.accounts().self().listSshKeys();
    assertThat(info).hasSize(3);
    assertSequenceNumbers(info);
    // Delete second key
    gApi.accounts().self().deleteSshKey(2);
    info = gApi.accounts().self().listSshKeys();
    assertThat(info).hasSize(2);
    assertThat(info.get(0).seq).isEqualTo(1);
    assertThat(info.get(1).seq).isEqualTo(3);
}
#end_block

#method_before
protected void bccStarredBy() {
    if (!NotifyHandling.ALL.equals(notify)) {
        return;
    }
    try {
        // BCC anyone who has starred this change
        // and remove anyone who has ignored this change.
        // 
        Multimap<Account.Id, String> stars = args.starredChangesUtil.byChangeFromIndex(change.getId());
        for (Map.Entry<Account.Id, Collection<String>> e : stars.asMap().entrySet()) {
            if (e.getValue().contains(StarredChangesUtil.DEFAULT_LABEL)) {
                super.add(RecipientType.BCC, e.getKey());
            }
            if (e.getValue().contains(StarredChangesUtil.IGNORE_LABEL)) {
                AccountState accountState = args.accountCache.get(e.getKey());
                if (accountState != null) {
                    super.removeUser(accountState.getAccount());
                }
            }
        }
    } catch (OrmException | NoSuchChangeException err) {
        // Just don't BCC everyone. Better to send a partial message to those
        // we already have queued up then to fail deliver entirely to people
        // who have a lower interest in the change.
        log.warn("Cannot BCC users that starred updated change", err);
    }
}
#method_after
protected void bccStarredBy() {
    if (!NotifyHandling.ALL.equals(notify)) {
        return;
    }
    try {
        // BCC anyone who has starred this change
        // and remove anyone who has ignored this change.
        // 
        Multimap<Account.Id, String> stars = args.starredChangesUtil.byChangeFromIndex(change.getId());
        for (Map.Entry<Account.Id, Collection<String>> e : stars.asMap().entrySet()) {
            if (e.getValue().contains(StarredChangesUtil.DEFAULT_LABEL)) {
                super.add(RecipientType.BCC, e.getKey());
            }
            if (e.getValue().contains(StarredChangesUtil.IGNORE_LABEL)) {
                AccountState accountState = args.accountCache.get(e.getKey());
                if (accountState != null) {
                    removeUser(accountState.getAccount());
                }
            }
        }
    } catch (OrmException | NoSuchChangeException err) {
        // Just don't BCC everyone. Better to send a partial message to those
        // we already have queued up then to fail deliver entirely to people
        // who have a lower interest in the change.
        log.warn("Cannot BCC users that starred updated change", err);
    }
}
#end_block

#method_before
public static StarField parse(String s) {
    int p = s.indexOf(SEPARATOR);
    if (p >= 0) {
        try {
            Account.Id accountId = Account.Id.parse(s.substring(0, p));
            String label = s.substring(p + 1);
            return create(accountId, label);
        } catch (NumberFormatException e) {
            return null;
        }
    }
    return null;
}
#method_after
public static StarField parse(String s) {
    int p = s.indexOf(SEPARATOR);
    if (p >= 0) {
        Integer id = Ints.tryParse(s.substring(0, p));
        if (id == null) {
            return null;
        }
        Account.Id accountId = new Account.Id(id);
        String label = s.substring(p + 1);
        return create(accountId, label);
    }
    return null;
}
#end_block

#method_before
public ImmutableSortedSet<String> star(Account.Id accountId, Project.NameKey project, Change.Id changeId, Set<String> labelsToAdd, Set<String> labelsToRemove) throws OrmException {
    try (Repository repo = repoManager.openRepository(allUsers)) {
        String refName = RefNames.refsStarredChanges(changeId, accountId);
        ObjectId oldObjectId = getObjectId(repo, refName);
        SortedSet<String> labels = readLabels(repo, oldObjectId);
        if (labelsToAdd != null) {
            labels.addAll(labelsToAdd);
        }
        if (labelsToRemove != null) {
            labels.removeAll(labelsToRemove);
        }
        if (labels.isEmpty()) {
            deleteRef(repo, refName, oldObjectId);
        } else {
            if (labels.contains(DEFAULT_LABEL) && labels.contains(IGNORE_LABEL)) {
                throw IllegalLabelException.mutuallyExclusiveLabels(DEFAULT_LABEL, IGNORE_LABEL);
            }
            updateLabels(repo, refName, oldObjectId, labels);
        }
        indexer.index(dbProvider.get(), project, changeId);
        return ImmutableSortedSet.copyOf(labels);
    } catch (IOException e) {
        throw new OrmException(String.format("Star change %d for account %d failed", changeId.get(), accountId.get()), e);
    }
}
#method_after
public ImmutableSortedSet<String> star(Account.Id accountId, Project.NameKey project, Change.Id changeId, Set<String> labelsToAdd, Set<String> labelsToRemove) throws OrmException {
    try (Repository repo = repoManager.openRepository(allUsers)) {
        String refName = RefNames.refsStarredChanges(changeId, accountId);
        ObjectId oldObjectId = getObjectId(repo, refName);
        SortedSet<String> labels = readLabels(repo, oldObjectId);
        if (labelsToAdd != null) {
            labels.addAll(labelsToAdd);
        }
        if (labelsToRemove != null) {
            labels.removeAll(labelsToRemove);
        }
        if (labels.isEmpty()) {
            deleteRef(repo, refName, oldObjectId);
        } else {
            checkMutuallyExclusiveLabels(labels);
            updateLabels(repo, refName, oldObjectId, labels);
        }
        indexer.index(dbProvider.get(), project, changeId);
        return ImmutableSortedSet.copyOf(labels);
    } catch (IOException e) {
        throw new OrmException(String.format("Star change %d for account %d failed", changeId.get(), accountId.get()), e);
    }
}
#end_block

#method_before
public ImmutableMultimap<Account.Id, String> byChange(Change.Id changeId) throws OrmException {
    try (Repository repo = repoManager.openRepository(allUsers)) {
        ImmutableMultimap.Builder<Account.Id, String> builder = new ImmutableMultimap.Builder<>();
        for (String refPart : getRefNames(repo, RefNames.refsStarredChangesPrefix(changeId))) {
            Account.Id accountId = Account.Id.parse(refPart);
            builder.putAll(accountId, readLabels(repo, RefNames.refsStarredChanges(changeId, accountId)));
        }
        return builder.build();
    } catch (IOException e) {
        throw new OrmException(String.format("Get accounts that starred change %d failed", changeId.get()), e);
    }
}
#method_after
public ImmutableMultimap<Account.Id, String> byChange(Change.Id changeId) throws OrmException {
    try (Repository repo = repoManager.openRepository(allUsers)) {
        ImmutableMultimap.Builder<Account.Id, String> builder = new ImmutableMultimap.Builder<>();
        for (String refPart : getRefNames(repo, RefNames.refsStarredChangesPrefix(changeId))) {
            Integer id = Ints.tryParse(refPart);
            if (id == null) {
                continue;
            }
            Account.Id accountId = new Account.Id(id);
            builder.putAll(accountId, readLabels(repo, RefNames.refsStarredChanges(changeId, accountId)));
        }
        return builder.build();
    } catch (IOException e) {
        throw new OrmException(String.format("Get accounts that starred change %d failed", changeId.get()), e);
    }
}
#end_block

#method_before
private static void validateLabels(Set<String> labels) {
    if (labels == null) {
        return;
    }
    SortedSet<String> invalidLabels = new TreeSet<>();
    for (String label : labels) {
        if (CharMatcher.WHITESPACE.matchesAnyOf(label)) {
            invalidLabels.add(label);
        }
    }
    if (!invalidLabels.isEmpty()) {
        throw IllegalLabelException.invalidLabels(invalidLabels);
    }
}
#method_after
private static void validateLabels(Set<String> labels) {
    if (labels == null) {
        return;
    }
    SortedSet<String> invalidLabels = new TreeSet<>();
    for (String label : labels) {
        if (CharMatcher.whitespace().matchesAnyOf(label)) {
            invalidLabels.add(label);
        }
    }
    if (!invalidLabels.isEmpty()) {
        throw IllegalLabelException.invalidLabels(invalidLabels);
    }
}
#end_block

#method_before
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    RevCommit commit = receiveEvent.commit;
    final List<String> idList = commit.getFooterLines(FooterConstants.CHANGE_ID);
    List<CommitValidationMessage> messages = new LinkedList<>();
    if (idList.isEmpty()) {
        if (projectControl.getProjectState().isRequireChangeID()) {
            String shortMsg = commit.getShortMessage();
            String sha1 = commit.getId().name().substring(0, SHA1_LENGTH);
            if (shortMsg.startsWith(CHANGE_ID_PREFIX) && shortMsg.substring(CHANGE_ID_PREFIX.length()).trim().matches(SHA1_PATTERN)) {
                String errMsg = String.format(MISSING_SUBJECT_MSG, sha1);
                throw new CommitValidationException(errMsg);
            }
            String errMsg = String.format(MISSING_CHANGE_ID_MSG, sha1);
            messages.add(getMissingChangeIdErrorMsg(errMsg, commit));
            throw new CommitValidationException(errMsg, messages);
        }
    } else if (idList.size() > 1) {
        String sha1 = commit.getId().name().substring(0, SHA1_LENGTH);
        String errMsg = String.format(MULTIPLE_CHANGE_ID_MSG, sha1);
        throw new CommitValidationException(errMsg, messages);
    }
    String v = idList.get(idList.size() - 1).trim();
    if (!v.matches(SHA1_PATTERN)) {
        String sha1 = commit.getId().name().substring(0, SHA1_LENGTH);
        String errMsg = String.format(INVALID_CHANGE_ID_MSG, sha1);
        messages.add(getMissingChangeIdErrorMsg(errMsg, receiveEvent.commit));
        throw new CommitValidationException(errMsg, messages);
    }
    return Collections.emptyList();
}
#method_after
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    RevCommit commit = receiveEvent.commit;
    List<CommitValidationMessage> messages = new LinkedList<>();
    List<String> idList = commit.getFooterLines(FooterConstants.CHANGE_ID);
    String sha1 = commit.abbreviate(SHA1_LENGTH).name();
    if (idList.isEmpty()) {
        if (projectControl.getProjectState().isRequireChangeID()) {
            String shortMsg = commit.getShortMessage();
            if (shortMsg.startsWith(CHANGE_ID_PREFIX) && CHANGE_ID.matcher(shortMsg.substring(CHANGE_ID_PREFIX.length()).trim()).matches()) {
                String errMsg = String.format(MISSING_SUBJECT_MSG, sha1);
                throw new CommitValidationException(errMsg);
            }
            String errMsg = String.format(MISSING_CHANGE_ID_MSG, sha1);
            messages.add(getMissingChangeIdErrorMsg(errMsg, commit));
            throw new CommitValidationException(errMsg, messages);
        }
    } else if (idList.size() > 1) {
        String errMsg = String.format(MULTIPLE_CHANGE_ID_MSG, sha1);
        throw new CommitValidationException(errMsg, messages);
    }
    String v = idList.get(idList.size() - 1).trim();
    if (!CHANGE_ID.matcher(v).matches()) {
        String errMsg = String.format(INVALID_CHANGE_ID_MSG, sha1);
        messages.add(getMissingChangeIdErrorMsg(errMsg, receiveEvent.commit));
        throw new CommitValidationException(errMsg, messages);
    }
    return Collections.emptyList();
}
#end_block

#method_before
@Override
public BranchInfo apply(ProjectResource rsrc, Input input) throws BadRequestException, AuthException, ResourceConflictException, IOException {
    if (input == null) {
        input = new Input();
    }
    if (input.ref != null && !ref.equals(input.ref)) {
        throw new BadRequestException("ref must match URL");
    }
    if (input.revision == null) {
        input.revision = Constants.HEAD;
    }
    while (ref.startsWith("/")) {
        ref = ref.substring(1);
    }
    ref = RefNames.fullName(ref);
    if (!Repository.isValidRefName(ref)) {
        throw new BadRequestException("invalid branch name \"" + ref + "\"");
    }
    if (MagicBranch.isMagicBranch(ref)) {
        throw new BadRequestException("not allowed to create branches under \"" + MagicBranch.getMagicRefNamePrefix(ref) + "\"");
    }
    final Branch.NameKey name = new Branch.NameKey(rsrc.getNameKey(), ref);
    final RefControl refControl = rsrc.getControl().controlForRef(name);
    try (Repository repo = repoManager.openRepository(rsrc.getNameKey())) {
        final ObjectId revid = parseBaseRevision(repo, rsrc.getNameKey(), input.revision);
        final RevWalk rw = verifyConnected(repo, revid);
        RevObject object = rw.parseAny(revid);
        if (ref.startsWith(Constants.R_HEADS)) {
            // 
            try {
                object = rw.parseCommit(object);
            } catch (IncorrectObjectTypeException notCommit) {
                throw new BadRequestException("\"" + input.revision + "\" not a commit");
            }
        }
        rw.reset();
        if (!refControl.canCreate(db.get(), rw, object)) {
            throw new AuthException("Cannot create \"" + ref + "\"");
        }
        try {
            final RefUpdate u = repo.updateRef(ref);
            u.setExpectedOldObjectId(ObjectId.zeroId());
            u.setNewObjectId(object.copy());
            u.setRefLogIdent(identifiedUser.get().newRefLogIdent());
            u.setRefLogMessage("created via REST from " + input.revision, false);
            final RefUpdate.Result result = u.update(rw);
            switch(result) {
                case FAST_FORWARD:
                case NEW:
                case NO_CHANGE:
                    referenceUpdated.fire(name.getParentKey(), u, ReceiveCommand.Type.CREATE, identifiedUser.get().getAccount());
                    hooks.doRefUpdatedHook(name, u, identifiedUser.get().getAccount());
                    break;
                case LOCK_FAILURE:
                    if (repo.getRefDatabase().exactRef(ref) != null) {
                        throw new ResourceConflictException("branch \"" + ref + "\" already exists");
                    }
                    String refPrefix = getRefPrefix(ref);
                    while (!Constants.R_HEADS.equals(refPrefix)) {
                        if (repo.getRefDatabase().exactRef(refPrefix) != null) {
                            throw new ResourceConflictException("Cannot create branch \"" + ref + "\" since it conflicts with branch \"" + refPrefix + "\".");
                        }
                        refPrefix = getRefPrefix(refPrefix);
                    }
                // $FALL-THROUGH$
                default:
                    {
                        throw new IOException(result.name());
                    }
            }
            BranchInfo info = new BranchInfo();
            info.ref = ref;
            info.revision = revid.getName();
            info.canDelete = refControl.canDelete() ? true : null;
            return info;
        } catch (IOException err) {
            log.error("Cannot create branch \"" + name + "\"", err);
            throw err;
        }
    } catch (InvalidRevisionException e) {
        throw new BadRequestException("invalid revision \"" + input.revision + "\"");
    }
}
#method_after
@Override
public BranchInfo apply(ProjectResource rsrc, Input input) throws BadRequestException, AuthException, ResourceConflictException, IOException {
    if (input == null) {
        input = new Input();
    }
    if (input.ref != null && !ref.equals(input.ref)) {
        throw new BadRequestException("ref must match URL");
    }
    if (input.revision == null) {
        input.revision = Constants.HEAD;
    }
    while (ref.startsWith("/")) {
        ref = ref.substring(1);
    }
    ref = RefNames.fullName(ref);
    if (!Repository.isValidRefName(ref)) {
        throw new BadRequestException("invalid branch name \"" + ref + "\"");
    }
    if (MagicBranch.isMagicBranch(ref)) {
        throw new BadRequestException("not allowed to create branches under \"" + MagicBranch.getMagicRefNamePrefix(ref) + "\"");
    }
    final Branch.NameKey name = new Branch.NameKey(rsrc.getNameKey(), ref);
    final RefControl refControl = rsrc.getControl().controlForRef(name);
    try (Repository repo = repoManager.openRepository(rsrc.getNameKey())) {
        final ObjectId revid = parseBaseRevision(repo, rsrc.getNameKey(), input.revision);
        final RevWalk rw = verifyConnected(repo, revid);
        RevObject object = rw.parseAny(revid);
        if (ref.startsWith(Constants.R_HEADS)) {
            // 
            try {
                object = rw.parseCommit(object);
            } catch (IncorrectObjectTypeException notCommit) {
                throw new BadRequestException("\"" + input.revision + "\" not a commit");
            }
        }
        rw.reset();
        if (!refControl.canCreate(db.get(), rw, object)) {
            throw new AuthException("Cannot create \"" + ref + "\"");
        }
        try {
            final RefUpdate u = repo.updateRef(ref);
            u.setExpectedOldObjectId(ObjectId.zeroId());
            u.setNewObjectId(object.copy());
            u.setRefLogIdent(identifiedUser.get().newRefLogIdent());
            u.setRefLogMessage("created via REST from " + input.revision, false);
            final RefUpdate.Result result = u.update(rw);
            switch(result) {
                case FAST_FORWARD:
                case NEW:
                case NO_CHANGE:
                    referenceUpdated.fire(name.getParentKey(), u, ReceiveCommand.Type.CREATE, identifiedUser.get().getAccount());
                    hooks.doRefUpdatedHook(name, u, identifiedUser.get().getAccount());
                    break;
                case LOCK_FAILURE:
                    if (repo.getRefDatabase().exactRef(ref) != null) {
                        throw new ResourceConflictException("branch \"" + ref + "\" already exists");
                    }
                    String refPrefix = getRefPrefix(ref);
                    while (!Constants.R_HEADS.equals(refPrefix)) {
                        if (repo.getRefDatabase().exactRef(refPrefix) != null) {
                            throw new ResourceConflictException("Cannot create branch \"" + ref + "\" since it conflicts with branch \"" + refPrefix + "\".");
                        }
                        refPrefix = getRefPrefix(refPrefix);
                    }
                // $FALL-THROUGH$
                case FORCED:
                case IO_FAILURE:
                case NOT_ATTEMPTED:
                case REJECTED:
                case REJECTED_CURRENT_BRANCH:
                case RENAMED:
                default:
                    {
                        throw new IOException(result.name());
                    }
            }
            BranchInfo info = new BranchInfo();
            info.ref = ref;
            info.revision = revid.getName();
            info.canDelete = refControl.canDelete() ? true : null;
            return info;
        } catch (IOException err) {
            log.error("Cannot create branch \"" + name + "\"", err);
            throw err;
        }
    } catch (InvalidRevisionException e) {
        throw new BadRequestException("invalid revision \"" + input.revision + "\"");
    }
}
#end_block

#method_before
public void setMessageSender(final MessageSender ms) {
    messageSender = ms != null ? ms : new ReceivePackMessageSender();
}
#method_after
public void setMessageSender(MessageSender ms) {
    messageSender = ms != null ? ms : new ReceivePackMessageSender();
}
#end_block

#method_before
void processCommands(final Collection<ReceiveCommand> commands, final MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    batch = repo.getRefDatabase().newBatchUpdate();
    batch.setPushCertificate(rp.getPushCertificate());
    batch.setRefLogIdent(rp.getRefLogIdent());
    batch.setRefLogMessage("push", true);
    parseCommands(commands);
    if (magicBranch != null && magicBranch.cmd.getResult() == NOT_ATTEMPTED) {
        selectNewAndReplacedChangesFromMagicBranch();
    }
    preparePatchSetsForReplace();
    if (!batch.getCommands().isEmpty()) {
        try {
            if (!batch.isAllowNonFastForwards() && magicBranch != null && magicBranch.edit) {
                batch.setAllowNonFastForwards(true);
            }
            batch.execute(rp.getRevWalk(), commandProgress);
        } catch (IOException err) {
            int cnt = 0;
            for (ReceiveCommand cmd : batch.getCommands()) {
                if (cmd.getResult() == NOT_ATTEMPTED) {
                    cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
                    cnt++;
                }
            }
            log.error(String.format("Failed to store %d refs in %s", cnt, project.getName()), err);
        }
    }
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(user)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    Set<Branch.NameKey> branches = Sets.newHashSet();
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == OK) {
            if (c.getType() == ReceiveCommand.Type.UPDATE) {
                // aka fast-forward
                tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
            }
            if (isHead(c) || isConfig(c)) {
                switch(c.getType()) {
                    case CREATE:
                    case UPDATE:
                    case UPDATE_NONFASTFORWARD:
                        autoCloseChanges(c);
                        branches.add(new Branch.NameKey(project.getNameKey(), c.getRefName()));
                        break;
                    case DELETE:
                        ResultSet<SubmoduleSubscription> submoduleSubscriptions = null;
                        Branch.NameKey projRef = new Branch.NameKey(project.getNameKey(), c.getRefName());
                        try {
                            submoduleSubscriptions = db.submoduleSubscriptions().bySuperProject(projRef);
                            db.submoduleSubscriptions().delete(submoduleSubscriptions);
                        } catch (OrmException e) {
                            log.error("Cannot delete submodule subscription(s) of branch " + projRef + ": " + submoduleSubscriptions, e);
                        }
                        break;
                }
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(c.getRefName())) {
                // We only fire gitRefUpdated for direct refs updates.
                // Events for change refs are fired when they are created.
                // 
                gitRefUpdated.fire(project.getNameKey(), c, user.getAccount());
                hooks.doRefUpdatedHook(new Branch.NameKey(project.getNameKey(), c.getRefName()), c.getOldId(), c.getNewId(), user.getAccount());
            }
        }
    }
    // Update superproject gitlinks if required.
    SubmoduleOp op = subOpProvider.get();
    try {
        op.updateSubmoduleSubscriptions(db, branches);
        op.updateSuperProjects(db, branches);
    } catch (SubmoduleException e) {
        log.error("Can't update submodule subscriptions " + "or update the superprojects", e);
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    reportMessages();
}
#method_after
void processCommands(Collection<ReceiveCommand> commands, MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    batch = repo.getRefDatabase().newBatchUpdate();
    batch.setPushCertificate(rp.getPushCertificate());
    batch.setRefLogIdent(rp.getRefLogIdent());
    batch.setRefLogMessage("push", true);
    parseCommands(commands);
    if (magicBranch != null && magicBranch.cmd.getResult() == NOT_ATTEMPTED) {
        selectNewAndReplacedChangesFromMagicBranch();
    }
    preparePatchSetsForReplace();
    if (!batch.getCommands().isEmpty()) {
        try {
            if (!batch.isAllowNonFastForwards() && magicBranch != null && magicBranch.edit) {
                batch.setAllowNonFastForwards(true);
            }
            batch.execute(rp.getRevWalk(), commandProgress);
        } catch (IOException err) {
            int cnt = 0;
            for (ReceiveCommand cmd : batch.getCommands()) {
                if (cmd.getResult() == NOT_ATTEMPTED) {
                    cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
                    cnt++;
                }
            }
            log.error(String.format("Failed to store %d refs in %s", cnt, project.getName()), err);
        }
    }
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(user)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    Set<Branch.NameKey> branches = new HashSet<>();
    for (ReceiveCommand c : commands) {
        if (c.getResult() == OK) {
            if (c.getType() == ReceiveCommand.Type.UPDATE) {
                // aka fast-forward
                tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
            }
            if (isHead(c) || isConfig(c)) {
                switch(c.getType()) {
                    case CREATE:
                    case UPDATE:
                    case UPDATE_NONFASTFORWARD:
                        autoCloseChanges(c);
                        branches.add(new Branch.NameKey(project.getNameKey(), c.getRefName()));
                        break;
                    case DELETE:
                        break;
                }
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(c.getRefName())) {
                // We only fire gitRefUpdated for direct refs updates.
                // Events for change refs are fired when they are created.
                // 
                gitRefUpdated.fire(project.getNameKey(), c, user.getAccount());
                hooks.doRefUpdatedHook(new Branch.NameKey(project.getNameKey(), c.getRefName()), c.getOldId(), c.getNewId(), user.getAccount());
            }
        }
    }
    // Update superproject gitlinks if required.
    SubmoduleOp op = subOpProvider.get();
    try (MergeOpRepoManager orm = ormProvider.get()) {
        orm.setContext(db, TimeUtil.nowTs(), user);
        op.updateSuperProjects(db, branches, "receiveID", orm);
    } catch (SubmoduleException e) {
        log.error("Can't update the superprojects", e);
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    reportMessages();
}
#end_block

#method_before
private void reportMessages() {
    Iterable<CreateRequest> created = Iterables.filter(newChanges, new Predicate<CreateRequest>() {

        @Override
        public boolean apply(CreateRequest input) {
            return input.created;
        }
    });
    if (!Iterables.isEmpty(created)) {
        addMessage("");
        addMessage("New Changes:");
        for (CreateRequest c : created) {
            addMessage(formatChangeUrl(canonicalWebUrl, c.change, false));
        }
        addMessage("");
    }
    List<ReplaceRequest> updated = FluentIterable.from(replaceByChange.values()).filter(new Predicate<ReplaceRequest>() {

        @Override
        public boolean apply(ReplaceRequest input) {
            return !input.skip && input.inputCommand.getResult() == OK;
        }
    }).toSortedList(Ordering.natural().onResultOf(new Function<ReplaceRequest, Integer>() {

        @Override
        public Integer apply(ReplaceRequest in) {
            return in.change.getId().get();
        }
    }));
    if (!updated.isEmpty()) {
        addMessage("");
        addMessage("Updated Changes:");
        boolean edit = magicBranch != null && magicBranch.edit;
        for (ReplaceRequest u : updated) {
            addMessage(formatChangeUrl(canonicalWebUrl, u.change, edit));
        }
        addMessage("");
    }
}
#method_after
private void reportMessages() {
    Iterable<CreateRequest> created = Iterables.filter(newChanges, new Predicate<CreateRequest>() {

        @Override
        public boolean apply(CreateRequest input) {
            return input.change != null;
        }
    });
    if (!Iterables.isEmpty(created)) {
        addMessage("");
        addMessage("New Changes:");
        for (CreateRequest c : created) {
            addMessage(formatChangeUrl(canonicalWebUrl, c.change, c.change.getSubject(), false));
        }
        addMessage("");
    }
    List<ReplaceRequest> updated = FluentIterable.from(replaceByChange.values()).filter(new Predicate<ReplaceRequest>() {

        @Override
        public boolean apply(ReplaceRequest input) {
            return !input.skip && input.inputCommand.getResult() == OK;
        }
    }).toSortedList(Ordering.natural().onResultOf(new Function<ReplaceRequest, Integer>() {

        @Override
        public Integer apply(ReplaceRequest in) {
            return in.change.getId().get();
        }
    }));
    if (!updated.isEmpty()) {
        addMessage("");
        addMessage("Updated Changes:");
        boolean edit = magicBranch != null && magicBranch.edit;
        for (ReplaceRequest u : updated) {
            addMessage(formatChangeUrl(canonicalWebUrl, u.change, u.info.getSubject(), edit));
        }
        addMessage("");
    }
}
#end_block

#method_before
private static String formatChangeUrl(String url, Change change, boolean edit) {
    StringBuilder m = new StringBuilder().append("  ").append(url).append(change.getChangeId()).append(" ").append(ChangeUtil.cropSubject(change.getSubject()));
    if (change.getStatus() == Change.Status.DRAFT) {
        m.append(" [DRAFT]");
    }
    if (edit) {
        m.append(" [EDIT]");
    }
    return m.toString();
}
#method_after
private static String formatChangeUrl(String url, Change change, String subject, boolean edit) {
    StringBuilder m = new StringBuilder().append("  ").append(url).append(change.getChangeId()).append(" ").append(ChangeUtil.cropSubject(subject));
    if (change.getStatus() == Change.Status.DRAFT) {
        m.append(" [DRAFT]");
    }
    if (edit) {
        m.append(" [EDIT]");
    }
    return m.toString();
}
#end_block

#method_before
private void insertChangesAndPatchSets() {
    int replaceCount = 0;
    int okToInsert = 0;
    for (Map.Entry<Change.Id, ReplaceRequest> e : replaceByChange.entrySet()) {
        ReplaceRequest replace = e.getValue();
        if (magicBranch != null && replace.inputCommand == magicBranch.cmd) {
            replaceCount++;
            if (replace.cmd != null && replace.cmd.getResult() == OK) {
                okToInsert++;
            }
        } else if (replace.cmd != null && replace.cmd.getResult() == OK) {
            try {
                if (replace.insertPatchSet().checkedGet() != null) {
                    replace.inputCommand.setResult(OK);
                }
            } catch (IOException | RestApiException err) {
                reject(replace.inputCommand, "internal server error");
                log.error(String.format("Cannot add patch set to %d of %s", e.getKey().get(), project.getName()), err);
            }
        } else if (replace.inputCommand.getResult() == NOT_ATTEMPTED) {
            reject(replace.inputCommand, "internal server error");
            log.error(String.format("Replacement for project %s was not attempted", project.getName()));
        }
    }
    if (magicBranch == null || magicBranch.cmd.getResult() != NOT_ATTEMPTED) {
        // No need to continue.
        return;
    }
    List<String> lastCreateChangeErrors = Lists.newArrayList();
    for (CreateRequest create : newChanges) {
        if (create.cmd.getResult() == OK) {
            okToInsert++;
        } else {
            String createChangeResult = String.format("%s %s", create.cmd.getResult(), Strings.nullToEmpty(create.cmd.getMessage())).trim();
            lastCreateChangeErrors.add(createChangeResult);
            log.error(String.format("Command %s on %s:%s not completed: %s", create.cmd.getType(), project.getName(), create.cmd.getRefName(), createChangeResult));
        }
    }
    if (okToInsert != replaceCount + newChanges.size()) {
        // One or more new references failed to create. Assume the
        // system isn't working correctly anymore and abort.
        reject(magicBranch.cmd, "Unable to create changes: " + Joiner.on(' ').join(lastCreateChangeErrors));
        log.error(String.format("Only %d of %d new change refs created in %s; aborting", okToInsert, replaceCount + newChanges.size(), project.getName()));
        return;
    }
    try {
        List<CheckedFuture<?, RestApiException>> futures = Lists.newArrayList();
        for (ReplaceRequest replace : replaceByChange.values()) {
            if (replace.inputCommand == magicBranch.cmd) {
                futures.add(replace.insertPatchSet());
            }
        }
        for (CreateRequest create : newChanges) {
            futures.add(create.insertChange());
        }
        for (UpdateGroupsRequest update : updateGroups) {
            futures.add(update.updateGroups());
        }
        for (CheckedFuture<?, RestApiException> f : futures) {
            f.checkedGet();
        }
        magicBranch.cmd.setResult(OK);
    } catch (RestApiException err) {
        log.error("Can't insert change/patchset for " + project.getName() + ". " + err.getMessage(), err);
        String rejection = "internal server error";
        if (err.getCause() != null) {
            rejection += ": " + err.getCause().getMessage();
        }
        reject(magicBranch.cmd, rejection);
    } catch (IOException err) {
        log.error("Can't read commits for " + project.getName(), err);
        reject(magicBranch.cmd, "internal server error");
    }
}
#method_after
private void insertChangesAndPatchSets() {
    int replaceCount = 0;
    int okToInsert = 0;
    for (Map.Entry<Change.Id, ReplaceRequest> e : replaceByChange.entrySet()) {
        ReplaceRequest replace = e.getValue();
        if (magicBranch != null && replace.inputCommand == magicBranch.cmd) {
            replaceCount++;
            if (replace.cmd != null && replace.cmd.getResult() == OK) {
                okToInsert++;
            }
        } else if (replace.cmd != null && replace.cmd.getResult() == OK) {
            try {
                if (replace.insertPatchSet().checkedGet() != null) {
                    replace.inputCommand.setResult(OK);
                }
            } catch (RestApiException err) {
                reject(replace.inputCommand, "internal server error");
                log.error(String.format("Cannot add patch set to change %d in project %s", e.getKey().get(), project.getName()), err);
            }
        } else if (replace.inputCommand.getResult() == NOT_ATTEMPTED) {
            reject(replace.inputCommand, "internal server error");
            log.error(String.format("Replacement for project %s was not attempted", project.getName()));
        }
    }
    if (magicBranch == null || magicBranch.cmd.getResult() != NOT_ATTEMPTED) {
        // No need to continue.
        return;
    }
    List<String> lastCreateChangeErrors = new ArrayList<>();
    for (CreateRequest create : newChanges) {
        if (create.cmd.getResult() == OK) {
            okToInsert++;
        } else {
            String createChangeResult = String.format("%s %s", create.cmd.getResult(), Strings.nullToEmpty(create.cmd.getMessage())).trim();
            lastCreateChangeErrors.add(createChangeResult);
            log.error(String.format("Command %s on %s:%s not completed: %s", create.cmd.getType(), project.getName(), create.cmd.getRefName(), createChangeResult));
        }
    }
    if (okToInsert != replaceCount + newChanges.size()) {
        // One or more new references failed to create. Assume the
        // system isn't working correctly anymore and abort.
        reject(magicBranch.cmd, "Unable to create changes: " + Joiner.on(' ').join(lastCreateChangeErrors));
        log.error(String.format("Only %d of %d new change refs created in %s; aborting", okToInsert, replaceCount + newChanges.size(), project.getName()));
        return;
    }
    try {
        List<CheckedFuture<?, RestApiException>> futures = new ArrayList<>();
        for (ReplaceRequest replace : replaceByChange.values()) {
            if (replace.inputCommand == magicBranch.cmd) {
                futures.add(replace.insertPatchSet());
            }
        }
        for (CreateRequest create : newChanges) {
            futures.add(create.insertChange());
        }
        for (UpdateGroupsRequest update : updateGroups) {
            futures.add(update.updateGroups());
        }
        for (CheckedFuture<?, RestApiException> f : futures) {
            f.checkedGet();
        }
        magicBranch.cmd.setResult(OK);
    } catch (ResourceConflictException e) {
        addMessage(e.getMessage());
        reject(magicBranch.cmd, "conflict");
    } catch (RestApiException err) {
        log.error("Can't insert change/patch set for " + project.getName(), err);
        reject(magicBranch.cmd, "internal server error: " + err.getMessage());
    }
}
#end_block

#method_before
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        HookResult result = hooks.doRefUpdateHook(project, cmd.getRefName(), user.getAccount(), cmd.getOldId(), cmd.getNewId());
        if (result != null) {
            final String message = result.toString().trim();
            if (result.getExitValue() != 0) {
                reject(cmd, message);
                continue;
            }
            rp.sendMessage(message);
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseMagicBranch(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(repo, cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            addError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                addError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                        Project.NameKey newParent = cfg.getProject().getParent(allProjectsName);
                        Project.NameKey oldParent = project.getParent(allProjectsName);
                        if (oldParent == null) {
                            // update of the 'All-Projects' project
                            if (newParent != null) {
                                reject(cmd, "invalid project configuration: root project cannot have parent");
                                continue;
                            }
                        } else {
                            if (!oldParent.equals(newParent) && !user.getCapabilities().canAdministrateServer()) {
                                reject(cmd, "invalid project configuration: only Gerrit admin can set parent");
                                continue;
                            }
                            if (projectCache.get(newParent) == null) {
                                reject(cmd, "invalid project configuration: parent does not exist");
                                continue;
                            }
                        }
                        for (Entry<ProjectConfigEntry> e : pluginConfigEntries) {
                            PluginConfig pluginCfg = cfg.getPluginConfig(e.getPluginName());
                            ProjectConfigEntry configEntry = e.getProvider().get();
                            String value = pluginCfg.getString(e.getExportName());
                            String oldValue = projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getString(e.getExportName());
                            if (configEntry.getType() == ProjectConfigEntry.Type.ARRAY) {
                                List<String> l = Arrays.asList(projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getStringList(e.getExportName()));
                                oldValue = Joiner.on("\n").join(l);
                            }
                            if ((value == null ? oldValue != null : !value.equals(oldValue)) && !configEntry.isEditable(projectControl.getProjectState())) {
                                reject(cmd, String.format("invalid project configuration: Not allowed to set parameter" + " '%s' of plugin '%s' on project '%s'.", e.getExportName(), e.getPluginName(), project.getName()));
                                continue;
                            }
                            if (ProjectConfigEntry.Type.LIST.equals(configEntry.getType()) && value != null && !configEntry.getPermittedValues().contains(value)) {
                                reject(cmd, String.format("invalid project configuration: The value '%s' is " + "not permitted for parameter '%s' of plugin '%s'.", value, e.getExportName(), e.getPluginName()));
                            }
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#method_after
private void parseCommands(Collection<ReceiveCommand> commands) {
    for (ReceiveCommand cmd : commands) {
        if (cmd.getResult() != NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseMagicBranch(cmd);
            continue;
        }
        Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(repo, cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            addError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                addError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                        Project.NameKey newParent = cfg.getProject().getParent(allProjectsName);
                        Project.NameKey oldParent = project.getParent(allProjectsName);
                        if (oldParent == null) {
                            // update of the 'All-Projects' project
                            if (newParent != null) {
                                reject(cmd, "invalid project configuration: root project cannot have parent");
                                continue;
                            }
                        } else {
                            if (!oldParent.equals(newParent) && !user.getCapabilities().canAdministrateServer()) {
                                reject(cmd, "invalid project configuration: only Gerrit admin can set parent");
                                continue;
                            }
                            if (projectCache.get(newParent) == null) {
                                reject(cmd, "invalid project configuration: parent does not exist");
                                continue;
                            }
                        }
                        for (Entry<ProjectConfigEntry> e : pluginConfigEntries) {
                            PluginConfig pluginCfg = cfg.getPluginConfig(e.getPluginName());
                            ProjectConfigEntry configEntry = e.getProvider().get();
                            String value = pluginCfg.getString(e.getExportName());
                            String oldValue = projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getString(e.getExportName());
                            if (configEntry.getType() == ProjectConfigEntry.Type.ARRAY) {
                                List<String> l = Arrays.asList(projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getStringList(e.getExportName()));
                                oldValue = Joiner.on("\n").join(l);
                            }
                            if ((value == null ? oldValue != null : !value.equals(oldValue)) && !configEntry.isEditable(projectControl.getProjectState())) {
                                reject(cmd, String.format("invalid project configuration: Not allowed to set parameter" + " '%s' of plugin '%s' on project '%s'.", e.getExportName(), e.getPluginName(), project.getName()));
                                continue;
                            }
                            if (ProjectConfigEntry.Type.LIST.equals(configEntry.getType()) && value != null && !configEntry.getPermittedValues().contains(value)) {
                                reject(cmd, String.format("invalid project configuration: The value '%s' is " + "not permitted for parameter '%s' of plugin '%s'.", value, e.getExportName(), e.getPluginName()));
                            }
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#end_block

#method_before
private void parseCreate(final ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    rp.getRevWalk().reset();
    if (ctl.canCreate(db, rp.getRevWalk(), obj)) {
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        reject(cmd);
    }
}
#method_after
private void parseCreate(ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    rp.getRevWalk().reset();
    if (ctl.canCreate(db, rp.getRevWalk(), obj)) {
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        reject(cmd);
    }
}
#end_block

#method_before
private void parseUpdate(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canUpdate()) {
        if (isHead(cmd) && !isCommit(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        if (RefNames.REFS_CONFIG.equals(ctl.getRefName())) {
            errors.put(Error.CONFIG_UPDATE, RefNames.REFS_CONFIG);
        } else {
            errors.put(Error.UPDATE, ctl.getRefName());
        }
        reject(cmd);
    }
}
#method_after
private void parseUpdate(ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canUpdate()) {
        if (isHead(cmd) && !isCommit(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        if (RefNames.REFS_CONFIG.equals(ctl.getRefName())) {
            errors.put(Error.CONFIG_UPDATE, RefNames.REFS_CONFIG);
        } else {
            errors.put(Error.UPDATE, ctl.getRefName());
        }
        reject(cmd);
    }
}
#end_block

#method_before
private boolean isCommit(final ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName(), err);
        reject(cmd, "invalid object");
        return false;
    }
    if (obj instanceof RevCommit) {
        return true;
    } else {
        reject(cmd, "not a commit");
        return false;
    }
}
#method_after
private boolean isCommit(ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName(), err);
        reject(cmd, "invalid object");
        return false;
    }
    if (obj instanceof RevCommit) {
        return true;
    } else {
        reject(cmd, "not a commit");
        return false;
    }
}
#end_block

#method_before
private void parseDelete(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.getRefName().startsWith(REFS_CHANGES)) {
        errors.put(Error.DELETE_CHANGES, ctl.getRefName());
        reject(cmd, "cannot delete changes");
    } else if (ctl.canDelete()) {
        batch.addCommand(cmd);
    } else {
        if (RefNames.REFS_CONFIG.equals(ctl.getRefName())) {
            reject(cmd, "cannot delete project configuration");
        } else {
            errors.put(Error.DELETE, ctl.getRefName());
            reject(cmd, "cannot delete references");
        }
    }
}
#method_after
private void parseDelete(ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.getRefName().startsWith(REFS_CHANGES)) {
        errors.put(Error.DELETE_CHANGES, ctl.getRefName());
        reject(cmd, "cannot delete changes");
    } else if (ctl.canDelete()) {
        batch.addCommand(cmd);
    } else {
        if (RefNames.REFS_CONFIG.equals(ctl.getRefName())) {
            reject(cmd, "cannot delete project configuration");
        } else {
            errors.put(Error.DELETE, ctl.getRefName());
            reject(cmd, "cannot delete references");
        }
    }
}
#end_block

#method_before
private void parseRewind(final ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
        batch.setAllowNonFastForwards(true).addCommand(cmd);
    } else {
        cmd.setResult(REJECTED_NONFASTFORWARD, " need '" + PermissionRule.FORCE_PUSH + "' privilege.");
    }
}
#method_after
private void parseRewind(ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
        batch.setAllowNonFastForwards(true).addCommand(cmd);
    } else {
        cmd.setResult(REJECTED_NONFASTFORWARD, " need '" + PermissionRule.FORCE_PUSH + "' privilege.");
    }
}
#end_block

#method_before
@Option(name = "--label", aliases = { "-l" }, metaVar = "LABEL+VALUE", usage = "label(s) to assign (defaults to +1 if no value provided")
void addLabel(final String token) throws CmdLineException {
    LabelVote v = LabelVote.parse(token);
    try {
        LabelType.checkName(v.label());
        ApprovalsUtil.checkLabel(labelTypes, v.label(), v.value());
    } catch (IllegalArgumentException e) {
        throw clp.reject(e.getMessage());
    }
    labels.put(v.label(), v.value());
}
#method_after
@Option(name = "--label", aliases = { "-l" }, metaVar = "LABEL+VALUE", usage = "label(s) to assign (defaults to +1 if no value provided")
void addLabel(String token) throws CmdLineException {
    LabelVote v = LabelVote.parse(token);
    try {
        LabelType.checkName(v.label());
        ApprovalsUtil.checkLabel(labelTypes, v.label(), v.value());
    } catch (IllegalArgumentException e) {
        throw clp.reject(e.getMessage());
    }
    labels.put(v.label(), v.value());
}
#end_block

#method_before
@Option(name = "--hashtag", aliases = { "-t" }, metaVar = "HASHTAG", usage = "add hashtag to changes")
void addHashtag(String token) throws CmdLineException {
    if (!notesMigration.enabled()) {
        throw clp.reject("cannot add hashtags; noteDb is disabled");
    }
    String hashtag = cleanupHashtag(token);
    if (!hashtag.isEmpty()) {
        hashtags.add(hashtag);
    }
// TODO(dpursehouse): validate hashtags
}
#method_after
@Option(name = "--hashtag", aliases = { "-t" }, metaVar = "HASHTAG", usage = "add hashtag to changes")
void addHashtag(String token) throws CmdLineException {
    if (!notesMigration.readChanges()) {
        throw clp.reject("cannot add hashtags; noteDb is disabled");
    }
    String hashtag = cleanupHashtag(token);
    if (!hashtag.isEmpty()) {
        hashtags.add(hashtag);
    }
// TODO(dpursehouse): validate hashtags
}
#end_block

#method_before
private void parseMagicBranch(final ReceiveCommand cmd) {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    magicBranch = new MagicBranchInput(cmd, labelTypes, notesMigration);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    magicBranch.clp = clp;
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet());
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    if (!magicBranch.ctl.canWrite()) {
        reject(cmd, "project is read only");
        return;
    }
    if (magicBranch.draft) {
        if (!receiveConfig.allowDrafts) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "draft workflow is disabled");
            return;
        } else if (projectControl.controlForRef("refs/drafts/" + ref).isBlocked(Permission.PUSH)) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "cannot upload drafts");
            return;
        }
    }
    if (!magicBranch.ctl.canUpload()) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload review");
        return;
    }
    if (magicBranch.draft && magicBranch.submit) {
        reject(cmd, "cannot submit draft");
        return;
    }
    if (magicBranch.submit && !projectControl.controlForRef(MagicBranch.NEW_CHANGE + ref).canSubmit()) {
        reject(cmd, "submit not allowed");
        return;
    }
    RevWalk walk = rp.getRevWalk();
    RevCommit tip;
    try {
        tip = walk.parseCommit(magicBranch.cmd.getNewId());
    } catch (IOException ex) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", ex);
        return;
    }
    // if %base was specified, ignore newChangeForAllNotInTarget
    if (tip.getParentCount() > 1 || magicBranch.base != null || tip.getParentCount() == 0) {
        newChangeForAllNotInTarget = false;
    }
    if (magicBranch.base != null) {
        magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
        for (ObjectId id : magicBranch.base) {
            try {
                magicBranch.baseCommit.add(walk.parseCommit(id));
            } catch (IncorrectObjectTypeException notCommit) {
                reject(cmd, "base must be a commit");
                return;
            } catch (MissingObjectException e) {
                reject(cmd, "base not found");
                return;
            } catch (IOException e) {
                log.warn(String.format("Project %s cannot read %s", project.getName(), id.name()), e);
                reject(cmd, "internal server error");
                return;
            }
        }
    } else if (newChangeForAllNotInTarget) {
        String destBranch = magicBranch.dest.get();
        try {
            Ref r = repo.getRefDatabase().exactRef(destBranch);
            if (r == null) {
                reject(cmd, destBranch + " not found");
                return;
            }
            ObjectId baseHead = r.getObjectId();
            magicBranch.baseCommit = Collections.singletonList(walk.parseCommit(baseHead));
        } catch (IOException ex) {
            log.warn(String.format("Project %s cannot read %s", project.getName(), destBranch), ex);
            reject(cmd, "internal server error");
            return;
        }
    }
    // 
    try {
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
    }
}
#method_after
private void parseMagicBranch(ReceiveCommand cmd) {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    magicBranch = new MagicBranchInput(cmd, labelTypes, notesMigration);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    magicBranch.clp = clp;
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet());
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    if (!magicBranch.ctl.canWrite()) {
        reject(cmd, "project is read only");
        return;
    }
    if (magicBranch.draft) {
        if (!receiveConfig.allowDrafts) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "draft workflow is disabled");
            return;
        } else if (projectControl.controlForRef("refs/drafts/" + ref).isBlocked(Permission.PUSH)) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "cannot upload drafts");
            return;
        }
    }
    if (!magicBranch.ctl.canUpload()) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload review");
        return;
    }
    if (magicBranch.draft && magicBranch.submit) {
        reject(cmd, "cannot submit draft");
        return;
    }
    if (magicBranch.submit && !projectControl.controlForRef(MagicBranch.NEW_CHANGE + ref).canSubmit()) {
        reject(cmd, "submit not allowed");
        return;
    }
    RevWalk walk = rp.getRevWalk();
    RevCommit tip;
    try {
        tip = walk.parseCommit(magicBranch.cmd.getNewId());
    } catch (IOException ex) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", ex);
        return;
    }
    // if %base was specified, ignore newChangeForAllNotInTarget
    if (tip.getParentCount() > 1 || magicBranch.base != null || tip.getParentCount() == 0) {
        newChangeForAllNotInTarget = false;
    }
    if (magicBranch.base != null) {
        magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
        for (ObjectId id : magicBranch.base) {
            try {
                magicBranch.baseCommit.add(walk.parseCommit(id));
            } catch (IncorrectObjectTypeException notCommit) {
                reject(cmd, "base must be a commit");
                return;
            } catch (MissingObjectException e) {
                reject(cmd, "base not found");
                return;
            } catch (IOException e) {
                log.warn(String.format("Project %s cannot read %s", project.getName(), id.name()), e);
                reject(cmd, "internal server error");
                return;
            }
        }
    } else if (newChangeForAllNotInTarget) {
        String destBranch = magicBranch.dest.get();
        try {
            Ref r = repo.getRefDatabase().exactRef(destBranch);
            if (r == null) {
                reject(cmd, destBranch + " not found");
                return;
            }
            ObjectId baseHead = r.getObjectId();
            magicBranch.baseCommit = Collections.singletonList(walk.parseCommit(baseHead));
        } catch (IOException ex) {
            log.warn(String.format("Project %s cannot read %s", project.getName(), destBranch), ex);
            reject(cmd, "internal server error");
            return;
        }
    }
    // 
    try {
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        RevCommit h = walk.parseCommit(targetRef.getObjectId());
        RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
    }
}
#end_block

#method_before
private void parseReplaceCommand(final ReceiveCommand cmd, final Change.Id changeId) {
    if (cmd.getType() != ReceiveCommand.Type.CREATE) {
        reject(cmd, "invalid usage");
        return;
    }
    final RevCommit newCommit;
    try {
        newCommit = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IOException e) {
        log.error("Cannot parse " + cmd.getNewId().name() + " as commit", e);
        reject(cmd, "invalid commit");
        return;
    }
    final Change changeEnt;
    try {
        changeEnt = db.changes().get(changeId);
    } catch (OrmException e) {
        log.error("Cannot lookup existing change " + changeId, e);
        reject(cmd, "database error");
        return;
    }
    if (changeEnt == null) {
        reject(cmd, "change " + changeId + " not found");
        return;
    }
    if (!project.getNameKey().equals(changeEnt.getProject())) {
        reject(cmd, "change " + changeId + " does not belong to project " + project.getName());
        return;
    }
    requestReplace(cmd, true, changeEnt, newCommit);
}
#method_after
private void parseReplaceCommand(ReceiveCommand cmd, Change.Id changeId) {
    if (cmd.getType() != ReceiveCommand.Type.CREATE) {
        reject(cmd, "invalid usage");
        return;
    }
    RevCommit newCommit;
    try {
        newCommit = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IOException e) {
        log.error("Cannot parse " + cmd.getNewId().name() + " as commit", e);
        reject(cmd, "invalid commit");
        return;
    }
    Change changeEnt;
    try {
        changeEnt = notesFactory.createChecked(db, project.getNameKey(), changeId).getChange();
    } catch (OrmException e) {
        log.error("Cannot lookup existing change " + changeId, e);
        reject(cmd, "database error");
        return;
    } catch (NoSuchChangeException e) {
        log.error("Change not found " + changeId, e);
        reject(cmd, "change " + changeId + " not found");
        return;
    }
    if (!project.getNameKey().equals(changeEnt.getProject())) {
        reject(cmd, "change " + changeId + " does not belong to project " + project.getName());
        return;
    }
    requestReplace(cmd, true, changeEnt, newCommit);
}
#end_block

#method_before
private boolean requestReplace(final ReceiveCommand cmd, final boolean checkMergedInto, final Change change, final RevCommit newCommit) {
    if (change.getStatus().isClosed()) {
        reject(cmd, "change " + canonicalWebUrl + change.getId() + " closed");
        return false;
    }
    final ReplaceRequest req = new ReplaceRequest(change.getId(), newCommit, cmd, checkMergedInto);
    if (replaceByChange.containsKey(req.ontoChange)) {
        reject(cmd, "duplicate request");
        return false;
    }
    replaceByChange.put(req.ontoChange, req);
    return true;
}
#method_after
private boolean requestReplace(ReceiveCommand cmd, boolean checkMergedInto, Change change, RevCommit newCommit) {
    if (change.getStatus().isClosed()) {
        reject(cmd, "change " + canonicalWebUrl + change.getId() + " closed");
        return false;
    }
    ReplaceRequest req = new ReplaceRequest(change.getId(), newCommit, cmd, checkMergedInto);
    if (replaceByChange.containsKey(req.ontoChange)) {
        reject(cmd, "duplicate request");
        return false;
    }
    replaceByChange.put(req.ontoChange, req);
    return true;
}
#end_block

#method_before
private void selectNewAndReplacedChangesFromMagicBranch() {
    newChanges = Lists.newArrayList();
    SetMultimap<ObjectId, Ref> existing = changeRefsById();
    GroupCollector groupCollector = new GroupCollector(refsById, db);
    rp.getRevWalk().reset();
    rp.getRevWalk().sort(RevSort.TOPO);
    rp.getRevWalk().sort(RevSort.REVERSE, true);
    try {
        rp.getRevWalk().markStart(rp.getRevWalk().parseCommit(magicBranch.cmd.getNewId()));
        if (magicBranch.baseCommit != null) {
            for (RevCommit c : magicBranch.baseCommit) {
                rp.getRevWalk().markUninteresting(c);
            }
            Ref targetRef = allRefs.get(magicBranch.ctl.getRefName());
            if (targetRef != null) {
                rp.getRevWalk().markUninteresting(rp.getRevWalk().parseCommit(targetRef.getObjectId()));
            }
        } else {
            markHeadsAsUninteresting(rp.getRevWalk(), magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
        }
        List<ChangeLookup> pending = Lists.newArrayList();
        final Set<Change.Key> newChangeIds = new HashSet<>();
        final int maxBatchChanges = receiveConfig.getEffectiveMaxBatchChangesLimit(user);
        for (; ; ) {
            final RevCommit c = rp.getRevWalk().next();
            if (c == null) {
                break;
            }
            groupCollector.visit(c);
            Collection<Ref> existingRefs = existing.get(c);
            if (!existingRefs.isEmpty()) {
                // A's group.
                for (Ref ref : existingRefs) {
                    updateGroups.add(new UpdateGroupsRequest(ref, c));
                }
                continue;
            }
            if (!validCommit(magicBranch.ctl, magicBranch.cmd, c)) {
                // Not a change the user can propose? Abort as early as possible.
                newChanges = Collections.emptyList();
                return;
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
            }
            Change.Key changeKey = new Change.Key("I" + c.name());
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(magicBranch.ctl, c, changeKey));
                continue;
            }
            final String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                newChanges = Collections.emptyList();
                return;
            }
            changeKey = new Change.Key(idStr);
            pending.add(new ChangeLookup(c, changeKey));
            if (maxBatchChanges != 0 && pending.size() + newChanges.size() > maxBatchChanges) {
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                newChanges = Collections.emptyList();
                return;
            }
        }
        for (ChangeLookup p : pending) {
            if (newChangeIds.contains(p.changeKey)) {
                reject(magicBranch.cmd, "squash commits first");
                newChanges = Collections.emptyList();
                return;
            }
            List<ChangeData> changes = p.destChanges;
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 1) {
                // 
                if (requestReplace(magicBranch.cmd, false, changes.get(0).change(), p.commit)) {
                    continue;
                } else {
                    newChanges = Collections.emptyList();
                    return;
                }
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    newChanges = Collections.emptyList();
                    return;
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(magicBranch.ctl, p.commit, p.changeKey));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        newChanges = Collections.emptyList();
        return;
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        newChanges = Collections.emptyList();
        return;
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return;
    }
    if (!newChanges.isEmpty() && magicBranch.edit) {
        reject(magicBranch.cmd, "edit is not supported for new changes");
        return;
    }
    try {
        Multimap<ObjectId, String> groups = groupCollector.getGroups();
        for (CreateRequest create : newChanges) {
            batch.addCommand(create.cmd);
            create.groups = groups.get(create.commit);
        }
        for (ReplaceRequest replace : replaceByChange.values()) {
            replace.groups = groups.get(replace.newCommit);
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.groups = Sets.newHashSet(groups.get(update.commit));
        }
    } catch (OrmException e) {
        log.error("Error collecting groups for changes", e);
        reject(magicBranch.cmd, "internal server error");
        return;
    }
}
#method_after
private void selectNewAndReplacedChangesFromMagicBranch() {
    newChanges = new ArrayList<>();
    SetMultimap<ObjectId, Ref> existing = changeRefsById();
    GroupCollector groupCollector = GroupCollector.create(refsById, db, psUtil, notesFactory, project.getNameKey());
    rp.getRevWalk().reset();
    rp.getRevWalk().sort(RevSort.TOPO);
    rp.getRevWalk().sort(RevSort.REVERSE, true);
    try {
        rp.getRevWalk().markStart(rp.getRevWalk().parseCommit(magicBranch.cmd.getNewId()));
        if (magicBranch.baseCommit != null) {
            for (RevCommit c : magicBranch.baseCommit) {
                rp.getRevWalk().markUninteresting(c);
            }
            Ref targetRef = allRefs.get(magicBranch.ctl.getRefName());
            if (targetRef != null) {
                rp.getRevWalk().markUninteresting(rp.getRevWalk().parseCommit(targetRef.getObjectId()));
            }
        } else {
            markHeadsAsUninteresting(rp.getRevWalk(), magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
        }
        List<ChangeLookup> pending = new ArrayList<>();
        Set<Change.Key> newChangeIds = new HashSet<>();
        int maxBatchChanges = receiveConfig.getEffectiveMaxBatchChangesLimit(user);
        for (; ; ) {
            RevCommit c = rp.getRevWalk().next();
            if (c == null) {
                break;
            }
            groupCollector.visit(c);
            Collection<Ref> existingRefs = existing.get(c);
            if (!existingRefs.isEmpty()) {
                // A's group.
                for (Ref ref : existingRefs) {
                    updateGroups.add(new UpdateGroupsRequest(ref, c));
                }
                continue;
            }
            if (!validCommit(rp.getRevWalk(), magicBranch.ctl, magicBranch.cmd, c)) {
                // Not a change the user can propose? Abort as early as possible.
                newChanges = Collections.emptyList();
                return;
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
            }
            List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(c, magicBranch.dest.get()));
                continue;
            }
            String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                newChanges = Collections.emptyList();
                return;
            }
            pending.add(new ChangeLookup(c, new Change.Key(idStr)));
            if (maxBatchChanges != 0 && pending.size() + newChanges.size() > maxBatchChanges) {
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                newChanges = Collections.emptyList();
                return;
            }
        }
        for (ChangeLookup p : pending) {
            if (newChangeIds.contains(p.changeKey)) {
                reject(magicBranch.cmd, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
                newChanges = Collections.emptyList();
                return;
            }
            List<ChangeData> changes = p.destChanges;
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 1) {
                // 
                if (requestReplace(magicBranch.cmd, false, changes.get(0).change(), p.commit)) {
                    continue;
                } else {
                    newChanges = Collections.emptyList();
                    return;
                }
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    newChanges = Collections.emptyList();
                    return;
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(p.commit, magicBranch.dest.get()));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        newChanges = Collections.emptyList();
        return;
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        newChanges = Collections.emptyList();
        return;
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return;
    }
    if (!newChanges.isEmpty() && magicBranch.edit) {
        reject(magicBranch.cmd, "edit is not supported for new changes");
        return;
    }
    try {
        SortedSetMultimap<ObjectId, String> groups = groupCollector.getGroups();
        for (CreateRequest create : newChanges) {
            batch.addCommand(create.cmd);
            create.groups = ImmutableList.copyOf(groups.get(create.commitId));
        }
        for (ReplaceRequest replace : replaceByChange.values()) {
            replace.groups = ImmutableList.copyOf(groups.get(replace.newCommitId));
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.groups = ImmutableList.copyOf((groups.get(update.commit)));
        }
    } catch (OrmException | NoSuchChangeException e) {
        log.error("Error collecting groups for changes", e);
        reject(magicBranch.cmd, "internal server error");
        return;
    }
}
#end_block

#method_before
CheckedFuture<Void, RestApiException> insertChange() throws IOException {
    rp.getRevWalk().parseBody(commit);
    final Thread caller = Thread.currentThread();
    ListenableFuture<Void> future = changeUpdateExector.submit(requestScopePropagator.wrap(new Callable<Void>() {

        @Override
        public Void call() throws OrmException, RestApiException, UpdateException {
            if (caller == Thread.currentThread()) {
                insertChange(ReceiveCommits.this.db);
            } else {
                try (ReviewDb threadLocalDb = schemaFactory.open()) {
                    insertChange(threadLocalDb);
                }
            }
            synchronized (newProgress) {
                newProgress.update(1);
            }
            return null;
        }
    }));
    return Futures.makeChecked(future, INSERT_EXCEPTION);
}
#method_after
CheckedFuture<Void, RestApiException> insertChange() {
    final Thread caller = Thread.currentThread();
    ListenableFuture<Void> future = changeUpdateExector.submit(requestScopePropagator.wrap(new Callable<Void>() {

        @Override
        public Void call() throws OrmException, RestApiException, UpdateException, RepositoryNotFoundException, IOException, NoSuchChangeException {
            try (RequestState state = requestState(caller)) {
                insertChange(state);
            }
            synchronizedIncrement(newProgress);
            return null;
        }
    }));
    return Futures.makeChecked(future, INSERT_EXCEPTION);
}
#end_block

#method_before
private void insertChange(ReviewDb threadLocalDb) throws OrmException, RestApiException, UpdateException {
    final PatchSet ps = ins.setGroups(groups).getPatchSet();
    final Account.Id me = user.getAccountId();
    final List<FooterLine> footerLines = commit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    Map<String, Short> approvals = new HashMap<>();
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.labels;
    }
    recipients.add(getRecipientsFromFooters(accountResolver, ps, footerLines));
    recipients.remove(me);
    String msg = renderMessageWithApprovals(ps.getPatchSetId(), null, approvals, Collections.<String, PatchSetApproval>emptyMap());
    try (ObjectInserter oi = repo.newObjectInserter();
        BatchUpdate bu = batchUpdateFactory.create(threadLocalDb, change.getProject(), user, change.getCreatedOn())) {
        bu.setRepository(repo, rp.getRevWalk(), oi);
        bu.insertChange(ins.setReviewers(recipients.getReviewers()).setExtraCC(recipients.getCcOnly()).setApprovals(approvals).setMessage(msg).setRequestScopePropagator(requestScopePropagator).setSendMail(true).setUpdateRef(false));
        if (magicBranch != null) {
            bu.addOp(ins.getChange().getId(), hashtagsFactory.create(new HashtagsInput(magicBranch.hashtags)).setRunHooks(false));
        }
        bu.execute();
    }
    created = true;
    if (magicBranch != null && magicBranch.submit) {
        submit(projectControl.controlFor(change), ps);
    }
}
#method_after
private void insertChange(RequestState state) throws OrmException, IOException, RestApiException, UpdateException, NoSuchChangeException {
    RevCommit commit = state.rw.parseCommit(commitId);
    state.rw.parseBody(commit);
    final PatchSet.Id psId = ins.setGroups(groups).getPatchSetId();
    Account.Id me = user.getAccountId();
    List<FooterLine> footerLines = commit.getFooterLines();
    MailRecipients recipients = new MailRecipients();
    Map<String, Short> approvals = new HashMap<>();
    checkNotNull(magicBranch);
    recipients.add(magicBranch.getMailRecipients());
    approvals = magicBranch.labels;
    recipients.add(getRecipientsFromFooters(accountResolver, magicBranch.draft, footerLines));
    recipients.remove(me);
    StringBuilder msg = new StringBuilder(ApprovalsUtil.renderMessageWithApprovals(psId.get(), approvals, Collections.<String, PatchSetApproval>emptyMap()));
    if (!Strings.isNullOrEmpty(magicBranch.message)) {
        msg.append("\n").append(magicBranch.message);
    }
    try (BatchUpdate bu = batchUpdateFactory.create(state.db, magicBranch.dest.getParentKey(), user, TimeUtil.nowTs())) {
        bu.setRepository(state.repo, state.rw, state.ins);
        bu.insertChange(ins.setReviewers(recipients.getReviewers()).setExtraCC(recipients.getCcOnly()).setApprovals(approvals).setMessage(msg.toString()).setNotify(magicBranch.notify).setRequestScopePropagator(requestScopePropagator).setSendMail(true).setUpdateRef(true));
        if (!magicBranch.hashtags.isEmpty()) {
            bu.addOp(changeId, hashtagsFactory.create(new HashtagsInput(magicBranch.hashtags)).setRunHooks(false));
        }
        if (!Strings.isNullOrEmpty(magicBranch.topic)) {
            bu.addOp(changeId, new BatchUpdate.Op() {

                @Override
                public boolean updateChange(ChangeContext ctx) {
                    ctx.getUpdate(psId).setTopic(magicBranch.topic);
                    return true;
                }
            });
        }
        bu.execute();
    }
    change = ins.getChange();
    if (magicBranch.submit) {
        submit(projectControl.controlFor(state.db, change), ins.getPatchSet());
    }
}
#end_block

#method_before
private void submit(ChangeControl changeCtl, PatchSet ps) throws OrmException, ResourceConflictException {
    Submit submit = submitProvider.get();
    RevisionResource rsrc = new RevisionResource(changes.parse(changeCtl), ps);
    try {
        mergeOpProvider.get().merge(db, rsrc.getChange(), changeCtl.getUser().asIdentifiedUser(), false);
    } catch (NoSuchChangeException e) {
        throw new OrmException(e);
    }
    addMessage("");
    Change c = db.changes().get(rsrc.getChange().getId());
    switch(c.getStatus()) {
        case MERGED:
            addMessage("Change " + c.getChangeId() + " merged.");
            break;
        case NEW:
            ChangeMessage msg = submit.getConflictMessage(rsrc);
            if (msg != null) {
                addMessage("Change " + c.getChangeId() + ": " + msg.getMessage());
                break;
            }
        // $FALL-THROUGH$
        default:
            addMessage("change " + c.getChangeId() + " is " + c.getStatus().name().toLowerCase());
    }
}
#method_after
private void submit(ChangeControl changeCtl, PatchSet ps) throws OrmException, RestApiException, NoSuchChangeException {
    Submit submit = submitProvider.get();
    RevisionResource rsrc = new RevisionResource(changes.parse(changeCtl), ps);
    try (MergeOp op = mergeOpProvider.get()) {
        op.merge(db, rsrc.getChange(), changeCtl.getUser().asIdentifiedUser(), false, new SubmitInput());
    }
    addMessage("");
    Change c = notesFactory.createChecked(db, project.getNameKey(), rsrc.getChange().getId()).getChange();
    switch(c.getStatus()) {
        case MERGED:
            addMessage("Change " + c.getChangeId() + " merged.");
            break;
        case NEW:
            ChangeMessage msg = submit.getConflictMessage(rsrc);
            if (msg != null) {
                addMessage("Change " + c.getChangeId() + ": " + msg.getMessage());
                break;
            }
        // $FALL-THROUGH$
        case ABANDONED:
        case DRAFT:
        default:
            addMessage("change " + c.getChangeId() + " is " + c.getStatus().name().toLowerCase());
    }
}
#end_block

#method_before
private void readChangesForReplace() throws OrmException {
    List<CheckedFuture<Change, OrmException>> futures = Lists.newArrayListWithCapacity(replaceByChange.size());
    for (ReplaceRequest request : replaceByChange.values()) {
        futures.add(db.changes().getAsync(request.ontoChange));
    }
    for (CheckedFuture<Change, OrmException> f : futures) {
        Change c = f.checkedGet();
        if (c != null) {
            replaceByChange.get(c.getId()).change = c;
        }
    }
}
#method_after
private void readChangesForReplace() throws OrmException {
    List<CheckedFuture<ChangeNotes, OrmException>> futures = Lists.newArrayListWithCapacity(replaceByChange.size());
    for (ReplaceRequest request : replaceByChange.values()) {
        futures.add(notesFactory.createAsync(changeUpdateExector, db, project.getNameKey(), request.ontoChange));
    }
    for (CheckedFuture<ChangeNotes, OrmException> f : futures) {
        ChangeNotes notes = f.checkedGet();
        if (notes.getChange() != null) {
            replaceByChange.get(notes.getChangeId()).change = notes.getChange();
        }
    }
}
#end_block

#method_before
boolean validate(boolean autoClose) throws IOException {
    if (!autoClose && inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    } else if (change == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    priorPatchSet = change.currentPatchSetId();
    if (!revisions.containsValue(priorPatchSet)) {
        reject(inputCommand, "change " + ontoChange + " missing revisions");
        return false;
    }
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    if (newCommit == priorCommit) {
        // Ignore requests to make the change its current state.
        skip = true;
        reject(inputCommand, "commit already exists (as current patchset)");
        return false;
    }
    changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(inputCommand, "cannot replace " + ontoChange);
        return false;
    } else if (change.getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    } else if (revisions.containsKey(newCommit)) {
        reject(inputCommand, "commit already exists (in the change)");
        return false;
    }
    for (final Ref r : rp.getRepository().getRefDatabase().getRefs("refs/changes").values()) {
        if (r.getObjectId().equals(newCommit)) {
            reject(inputCommand, "commit already exists (in the project)");
            return false;
        }
    }
    for (RevCommit prior : revisions.keySet()) {
        // amending when trying to address review comments.
        if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
            reject(inputCommand, "squash commits first");
            return false;
        }
    }
    rp.getRevWalk().parseBody(newCommit);
    if (!validCommit(changeCtl.getRefControl(), inputCommand, newCommit)) {
        return false;
    }
    rp.getRevWalk().parseBody(priorCommit);
    // of the commit was modified.
    if (newCommit.getTree() == priorCommit.getTree()) {
        final boolean messageEq = eq(newCommit.getFullMessage(), priorCommit.getFullMessage());
        final boolean parentsEq = parentsEqual(newCommit, priorCommit);
        final boolean authorEq = authorEqual(newCommit, priorCommit);
        final ObjectReader reader = rp.getRevWalk().getObjectReader();
        if (messageEq && parentsEq && authorEq && !autoClose) {
            addMessage(String.format("(W) No changes between prior commit %s and new commit %s", reader.abbreviate(priorCommit).name(), reader.abbreviate(newCommit).name()));
            reject(inputCommand, "no changes made");
            return false;
        } else {
            StringBuilder msg = new StringBuilder();
            msg.append("(W) ");
            msg.append(reader.abbreviate(newCommit).name());
            msg.append(":");
            msg.append(" no files changed");
            if (!authorEq) {
                msg.append(", author changed");
            }
            if (!messageEq) {
                msg.append(", message updated");
            }
            if (!parentsEq) {
                msg.append(", was rebased");
            }
            addMessage(msg.toString());
        }
    }
    if (magicBranch != null && magicBranch.edit) {
        return newEdit();
    }
    newPatchSet();
    return true;
}
#method_after
boolean validate(boolean autoClose) throws IOException, OrmException {
    if (!autoClose && inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    } else if (change == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    priorPatchSet = change.currentPatchSetId();
    if (!revisions.containsValue(priorPatchSet)) {
        reject(inputCommand, "change " + ontoChange + " missing revisions");
        return false;
    }
    RevCommit newCommit = rp.getRevWalk().parseCommit(newCommitId);
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    if (newCommit.equals(priorCommit)) {
        // Ignore requests to make the change its current state.
        skip = true;
        reject(inputCommand, "commit already exists (as current patchset)");
        return false;
    }
    changeCtl = projectControl.controlFor(db, change);
    if (!changeCtl.canAddPatchSet(db)) {
        String locked = ".";
        if (changeCtl.isPatchSetLocked(db)) {
            locked = ". Change is patch set locked.";
        }
        reject(inputCommand, "cannot replace " + ontoChange + locked);
        return false;
    } else if (change.getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    } else if (revisions.containsKey(newCommit)) {
        reject(inputCommand, "commit already exists (in the change)");
        return false;
    }
    for (Ref r : rp.getRepository().getRefDatabase().getRefs("refs/changes").values()) {
        if (r.getObjectId().equals(newCommit)) {
            reject(inputCommand, "commit already exists (in the project)");
            return false;
        }
    }
    for (RevCommit prior : revisions.keySet()) {
        // amending when trying to address review comments.
        if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
            reject(inputCommand, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
            return false;
        }
    }
    if (!validCommit(rp.getRevWalk(), changeCtl.getRefControl(), inputCommand, newCommit)) {
        return false;
    }
    rp.getRevWalk().parseBody(priorCommit);
    // of the commit was modified.
    if (newCommit.getTree().equals(priorCommit.getTree())) {
        boolean messageEq = eq(newCommit.getFullMessage(), priorCommit.getFullMessage());
        boolean parentsEq = parentsEqual(newCommit, priorCommit);
        boolean authorEq = authorEqual(newCommit, priorCommit);
        ObjectReader reader = rp.getRevWalk().getObjectReader();
        if (messageEq && parentsEq && authorEq && !autoClose) {
            addMessage(String.format("(W) No changes between prior commit %s and new commit %s", reader.abbreviate(priorCommit).name(), reader.abbreviate(newCommit).name()));
        } else {
            StringBuilder msg = new StringBuilder();
            msg.append("(I) ");
            msg.append(reader.abbreviate(newCommit).name());
            msg.append(":");
            msg.append(" no files changed");
            if (!authorEq) {
                msg.append(", author changed");
            }
            if (!messageEq) {
                msg.append(", message updated");
            }
            if (!parentsEq) {
                msg.append(", was rebased");
            }
            addMessage(msg.toString());
        }
    }
    if (magicBranch != null && magicBranch.edit) {
        return newEdit();
    }
    newPatchSet();
    return true;
}
#end_block

#method_before
private boolean newEdit() {
    newPatchSet = new PatchSet(change.currentPatchSetId());
    Optional<ChangeEdit> edit = null;
    try {
        edit = editUtil.byChange(change, user);
    } catch (IOException e) {
        log.error("Cannt retrieve edit", e);
        return false;
    }
    if (edit.isPresent()) {
        if (edit.get().getBasePatchSet().getId().equals(newPatchSet.getId())) {
            // replace edit
            cmd = new ReceiveCommand(edit.get().getRef().getObjectId(), newCommit, edit.get().getRefName());
        } else {
            // delete old edit ref on rebase
            prev = new ReceiveCommand(edit.get().getRef().getObjectId(), ObjectId.zeroId(), edit.get().getRefName());
            createEditCommand();
        }
    } else {
        createEditCommand();
    }
    return true;
}
#method_after
private boolean newEdit() {
    psId = change.currentPatchSetId();
    Optional<ChangeEdit> edit = null;
    try {
        edit = editUtil.byChange(changeCtl);
    } catch (AuthException | IOException e) {
        log.error("Cannot retrieve edit", e);
        return false;
    }
    if (edit.isPresent()) {
        if (edit.get().getBasePatchSet().getId().equals(psId)) {
            // replace edit
            cmd = new ReceiveCommand(edit.get().getRef().getObjectId(), newCommitId, edit.get().getRefName());
        } else {
            // delete old edit ref on rebase
            prev = new ReceiveCommand(edit.get().getRef().getObjectId(), ObjectId.zeroId(), edit.get().getRefName());
            createEditCommand();
        }
    } else {
        createEditCommand();
    }
    return true;
}
#end_block

#method_before
private void createEditCommand() {
    // create new edit
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommit, RefNames.refsEdit(user.getAccountId(), change.getId(), newPatchSet.getId()));
}
#method_after
private void createEditCommand() {
    // create new edit
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommitId, RefNames.refsEdit(user.getAccountId(), change.getId(), psId));
}
#end_block

#method_before
private void newPatchSet() throws IOException {
    PatchSet.Id id = ChangeUtil.nextPatchSetId(allRefs, change.currentPatchSetId());
    newPatchSet = new PatchSet(id);
    newPatchSet.setCreatedOn(TimeUtil.nowTs());
    newPatchSet.setUploader(user.getAccountId());
    newPatchSet.setRevision(toRevId(newCommit));
    newPatchSet.setGroups(groups);
    if (rp.getPushCertificate() != null) {
        newPatchSet.setPushCertificate(rp.getPushCertificate().toTextWithSignature());
    }
    if (magicBranch != null && magicBranch.draft) {
        newPatchSet.setDraft(true);
    }
    info = patchSetInfoFactory.get(rp.getRevWalk(), newCommit, newPatchSet.getId());
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommit, newPatchSet.getRefName());
}
#method_after
private void newPatchSet() throws IOException {
    RevCommit newCommit = rp.getRevWalk().parseCommit(newCommitId);
    psId = ChangeUtil.nextPatchSetId(allRefs, change.currentPatchSetId());
    info = patchSetInfoFactory.get(rp.getRevWalk(), newCommit, psId);
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommitId, psId.toRefName());
}
#end_block

#method_before
CheckedFuture<PatchSet.Id, RestApiException> insertPatchSet() throws IOException {
    rp.getRevWalk().parseBody(newCommit);
    final Thread caller = Thread.currentThread();
    ListenableFuture<PatchSet.Id> future = changeUpdateExector.submit(requestScopePropagator.wrap(new Callable<PatchSet.Id>() {

        @Override
        public PatchSet.Id call() throws OrmException, IOException, NoSuchChangeException, ResourceConflictException {
            try {
                if (magicBranch != null && magicBranch.edit) {
                    return upsertEdit();
                } else if (caller == Thread.currentThread()) {
                    return insertPatchSet(db);
                } else {
                    try (ReviewDb db = schemaFactory.open()) {
                        return insertPatchSet(db);
                    }
                }
            } finally {
                synchronized (replaceProgress) {
                    replaceProgress.update(1);
                }
            }
        }
    }));
    return Futures.makeChecked(future, INSERT_EXCEPTION);
}
#method_after
CheckedFuture<PatchSet.Id, RestApiException> insertPatchSet() {
    final Thread caller = Thread.currentThread();
    ListenableFuture<PatchSet.Id> future = changeUpdateExector.submit(requestScopePropagator.wrap(new Callable<PatchSet.Id>() {

        @Override
        public PatchSet.Id call() throws OrmException, IOException, RestApiException, UpdateException, NoSuchChangeException {
            try {
                if (magicBranch != null && magicBranch.edit) {
                    return upsertEdit();
                }
                try (RequestState state = requestState(caller)) {
                    return insertPatchSet(state);
                }
            } catch (OrmException | IOException e) {
                log.error("Failed to insert patch set", e);
                throw e;
            } finally {
                synchronizedIncrement(replaceProgress);
            }
        }
    }));
    return Futures.makeChecked(future, INSERT_EXCEPTION);
}
#end_block

#method_before
PatchSet.Id upsertEdit() {
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    return newPatchSet.getId();
}
#method_after
PatchSet.Id upsertEdit() {
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    return psId;
}
#end_block

#method_before
PatchSet.Id insertPatchSet(ReviewDb db) throws OrmException, IOException, ResourceConflictException {
    final Account.Id me = user.getAccountId();
    final List<FooterLine> footerLines = newCommit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    Map<String, Short> approvals = new HashMap<>();
    ChangeUpdate update = updateFactory.create(changeCtl, newPatchSet.getCreatedOn());
    update.setPatchSetId(newPatchSet.getId());
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.labels;
        Set<String> hashtags = magicBranch.hashtags;
        if (!hashtags.isEmpty()) {
            ChangeNotes notes = changeCtl.getNotes().load();
            hashtags.addAll(notes.getHashtags());
            update.setHashtags(hashtags);
        }
    }
    recipients.add(getRecipientsFromFooters(accountResolver, newPatchSet, footerLines));
    recipients.remove(me);
    db.changes().beginTransaction(change.getId());
    ChangeKind changeKind = ChangeKind.REWORK;
    Timestamp ts = TimeUtil.nowTs();
    try {
        change = db.changes().get(change.getId());
        if (change == null || change.getStatus().isClosed()) {
            reject(inputCommand, "change is closed");
            return null;
        }
        if (newPatchSet.getGroups() == null) {
            newPatchSet.setGroups(GroupCollector.getCurrentGroups(db, change));
        }
        db.patchSets().insert(Collections.singleton(newPatchSet));
        if (checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), newCommit);
            mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        ChangeData cd = changeDataFactory.create(db, changeCtl);
        MailRecipients oldRecipients = getRecipientsFromReviewers(cd.reviewers());
        approvalCopier.copy(db, changeCtl, newPatchSet);
        approvalsUtil.addReviewers(db, update, labelTypes, change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
        approvalsUtil.addApprovals(db, update, labelTypes, newPatchSet, changeCtl, approvals, ts);
        recipients.add(oldRecipients);
        RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
        changeKind = changeKindCache.getChangeKind(projectControl.getProjectState(), repo, priorCommit, newCommit);
        cmUtil.addChangeMessage(db, update, newChangeMessage(db, changeKind, approvals));
        if (mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isClosed()) {
                        return null;
                    }
                    if (!change.currentPatchSetId().equals(priorPatchSet)) {
                        return change;
                    }
                    if (magicBranch != null && magicBranch.topic != null) {
                        change.setTopic(magicBranch.topic);
                    }
                    if (change.getStatus() == Change.Status.DRAFT && newPatchSet.isDraft()) {
                    // Leave in draft status.
                    } else {
                        change.setStatus(Change.Status.NEW);
                    }
                    change.setCurrentPatchSet(info);
                    final List<String> idList = newCommit.getFooterLines(CHANGE_ID);
                    if (idList.isEmpty()) {
                        change.setKey(new Change.Key("I" + newCommit.name()));
                    } else {
                        change.setKey(new Change.Key(idList.get(idList.size() - 1).trim()));
                    }
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(newPatchSet));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(inputCommand, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    if (mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, this, changeCtl);
    }
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    indexer.index(db, change);
    if (changeKind != ChangeKind.TRIVIAL_REBASE) {
        workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

            @Override
            public void run() {
                try {
                    ReplacePatchSetSender cm = replacePatchSetFactory.create(change.getId());
                    cm.setFrom(me);
                    cm.setPatchSet(newPatchSet, info);
                    cm.setChangeMessage(msg);
                    cm.addReviewers(recipients.getReviewers());
                    cm.addExtraCC(recipients.getCcOnly());
                    cm.send();
                } catch (Exception e) {
                    log.error("Cannot send email for new patch set " + newPatchSet.getId(), e);
                }
                if (mergedIntoRef != null) {
                    sendMergedEmail(ReplaceRequest.this);
                }
            }

            @Override
            public String toString() {
                return "send-email newpatchset";
            }
        }));
    }
    gitRefUpdated.fire(project.getNameKey(), newPatchSet.getRefName(), ObjectId.zeroId(), newCommit, user.getAccount());
    revisionCreated.fire(change, newPatchSet, user.getAccountId());
    hooks.doPatchsetCreatedHook(change, newPatchSet, db);
    if (mergedIntoRef != null) {
        changeMerged.fire(change, newPatchSet, user.getAccount(), newCommit.getName());
        hooks.doChangeMergedHook(change, user.getAccount(), newPatchSet, db, newCommit.getName());
    }
    if (!approvals.isEmpty()) {
        commentAdded.fire(change, newPatchSet, user.getAccount(), null, approvals, ts);
        hooks.doCommentAddedHook(change, user.getAccount(), newPatchSet, null, approvals, db);
    }
    if (magicBranch != null && magicBranch.submit) {
        submit(changeCtl, newPatchSet);
    }
    return newPatchSet.getId();
}
#method_after
PatchSet.Id insertPatchSet(RequestState state) throws OrmException, IOException, RestApiException, UpdateException, NoSuchChangeException {
    RevCommit newCommit = state.rw.parseCommit(newCommitId);
    state.rw.parseBody(newCommit);
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    ReplaceOp replaceOp = replaceOpFactory.create(requestScopePropagator, projectControl, checkMergedInto, priorPatchSet, priorCommit, psId, newCommit, info, groups, magicBranch, rp.getPushCertificate());
    try (BatchUpdate bu = batchUpdateFactory.create(state.db, project.getNameKey(), user, TimeUtil.nowTs())) {
        bu.setRepository(state.repo, state.rw, state.ins);
        bu.addOp(change.getId(), replaceOp);
        bu.execute();
    }
    if (replaceOp.getRejectMessage() != null) {
        reject(inputCommand, replaceOp.getRejectMessage());
        return null;
    }
    groups = replaceOp.getGroups();
    // TODO(ekempin): mark changes as merged inside of ReplaceOp
    if (replaceOp.getMergedIntoRef() != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, info, replaceOp.getMergedIntoRef());
    }
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    PatchSet newPatchSet = replaceOp.getPatchSet();
    gitRefUpdated.fire(project.getNameKey(), newPatchSet.getRefName(), ObjectId.zeroId(), newCommit, user.getAccount());
    if (magicBranch != null && magicBranch.submit) {
        submit(changeCtl, newPatchSet);
    }
    return newPatchSet.getId();
}
#end_block

#method_before
CheckedFuture<Void, RestApiException> updateGroups() {
    final Thread caller = Thread.currentThread();
    ListenableFuture<Void> future = changeUpdateExector.submit(requestScopePropagator.wrap(new Callable<Void>() {

        @Override
        public Void call() throws OrmException, IOException {
            if (caller == Thread.currentThread()) {
                updateGroups(db);
            } else {
                try (ReviewDb db = schemaFactory.open()) {
                    updateGroups(db);
                }
            }
            return null;
        }
    }));
    return Futures.makeChecked(future, INSERT_EXCEPTION);
}
#method_after
private void updateGroups(RequestState state) throws RestApiException, UpdateException {
    try (ObjectInserter oi = repo.newObjectInserter();
        BatchUpdate bu = batchUpdateFactory.create(state.db, magicBranch.dest.getParentKey(), user, TimeUtil.nowTs())) {
        bu.addOp(psId.getParentKey(), new BatchUpdate.Op() {

            @Override
            public boolean updateChange(ChangeContext ctx) throws OrmException {
                PatchSet ps = psUtil.get(ctx.getDb(), ctx.getNotes(), psId);
                List<String> oldGroups = ps.getGroups();
                if (oldGroups == null) {
                    if (groups == null) {
                        return false;
                    }
                } else if (sameGroups(oldGroups, groups)) {
                    return false;
                }
                psUtil.setGroups(ctx.getDb(), ctx.getUpdate(psId), ps, groups);
                return true;
            }
        });
        bu.execute();
    }
}
#end_block

#method_before
CheckedFuture<Void, RestApiException> updateGroups() {
    final Thread caller = Thread.currentThread();
    ListenableFuture<Void> future = changeUpdateExector.submit(requestScopePropagator.wrap(new Callable<Void>() {

        @Override
        public Void call() throws OrmException, IOException {
            if (caller == Thread.currentThread()) {
                updateGroups(db);
            } else {
                try (ReviewDb db = schemaFactory.open()) {
                    updateGroups(db);
                }
            }
            return null;
        }
    }));
    return Futures.makeChecked(future, INSERT_EXCEPTION);
}
#method_after
CheckedFuture<Void, RestApiException> updateGroups() {
    final Thread caller = Thread.currentThread();
    ListenableFuture<Void> future = changeUpdateExector.submit(requestScopePropagator.wrap(new Callable<Void>() {

        @Override
        public Void call() throws Exception {
            try (RequestState state = requestState(caller)) {
                updateGroups(state);
            }
            return null;
        }
    }));
    return Futures.makeChecked(future, INSERT_EXCEPTION);
}
#end_block

#method_before
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    if (ctl.canForgeAuthor() && ctl.canForgeCommitter() && ctl.canForgeGerritServerIdentity() && ctl.canUploadMerges() && !projectControl.getProjectState().isUseSignedOffBy() && Iterables.isEmpty(rejectCommits) && !RefNames.REFS_CONFIG.equals(ctl.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        return;
    }
    boolean defaultName = Strings.isNullOrEmpty(user.getAccount().getFullName());
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        RevObject parsedObject = walk.parseAny(cmd.getNewId());
        if (!(parsedObject instanceof RevCommit)) {
            return;
        }
        walk.markStart((RevCommit) parsedObject);
        markHeadsAsUninteresting(walk, cmd.getRefName());
        Set<ObjectId> existing = changeRefsById().keySet();
        for (RevCommit c; (c = walk.next()) != null; ) {
            if (existing.contains(c)) {
                continue;
            } else if (!validCommit(ctl, cmd, c)) {
                break;
            }
            if (defaultName && user.hasEmailAddress(c.getCommitterIdent().getEmailAddress())) {
                try {
                    Account a = db.accounts().get(user.getAccountId());
                    if (a != null && Strings.isNullOrEmpty(a.getFullName())) {
                        a.setFullName(c.getCommitterIdent().getName());
                        db.accounts().update(Collections.singleton(a));
                        user.getAccount().setFullName(a.getFullName());
                        accountCache.evict(a.getId());
                    }
                } catch (OrmException e) {
                    log.warn("Cannot default full_name", e);
                } finally {
                    defaultName = false;
                }
            }
        }
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#method_after
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    if (ctl.canForgeAuthor() && ctl.canForgeCommitter() && ctl.canForgeGerritServerIdentity() && ctl.canUploadMerges() && !projectControl.getProjectState().isUseSignedOffBy() && Iterables.isEmpty(rejectCommits) && !RefNames.REFS_CONFIG.equals(ctl.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        return;
    }
    boolean defaultName = Strings.isNullOrEmpty(user.getAccount().getFullName());
    RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        RevObject parsedObject = walk.parseAny(cmd.getNewId());
        if (!(parsedObject instanceof RevCommit)) {
            return;
        }
        walk.markStart((RevCommit) parsedObject);
        markHeadsAsUninteresting(walk, cmd.getRefName());
        Set<ObjectId> existing = changeRefsById().keySet();
        for (RevCommit c; (c = walk.next()) != null; ) {
            if (existing.contains(c)) {
                continue;
            } else if (!validCommit(walk, ctl, cmd, c)) {
                break;
            }
            if (defaultName && user.hasEmailAddress(c.getCommitterIdent().getEmailAddress())) {
                try {
                    Account a = db.accounts().get(user.getAccountId());
                    if (a != null && Strings.isNullOrEmpty(a.getFullName())) {
                        a.setFullName(c.getCommitterIdent().getName());
                        db.accounts().update(Collections.singleton(a));
                        user.getAccount().setFullName(a.getFullName());
                        accountCache.evict(a.getId());
                    }
                } catch (OrmException e) {
                    log.warn("Cannot default full_name", e);
                } finally {
                    defaultName = false;
                }
            }
        }
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#end_block

#method_before
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) {
    if (validCommits.contains(c)) {
        return true;
    }
    CommitReceivedEvent receiveEvent = new CommitReceivedEvent(cmd, project, ctl.getRefName(), c, user);
    CommitValidators commitValidators = commitValidatorsFactory.create(ctl, sshInfo, repo);
    try {
        messages.addAll(commitValidators.validateForReceiveCommits(receiveEvent, rejectCommits));
    } catch (CommitValidationException e) {
        messages.addAll(e.getMessages());
        reject(cmd, e.getMessage());
        return false;
    }
    validCommits.add(c);
    return true;
}
#method_after
private boolean validCommit(RevWalk rw, RefControl ctl, ReceiveCommand cmd, ObjectId id) throws IOException {
    if (validCommits.contains(id)) {
        return true;
    }
    RevCommit c = rw.parseCommit(id);
    rw.parseBody(c);
    CommitReceivedEvent receiveEvent = new CommitReceivedEvent(cmd, project, ctl.getRefName(), c, user);
    CommitValidators commitValidators = commitValidatorsFactory.create(ctl, sshInfo, repo);
    try {
        messages.addAll(commitValidators.validateForReceiveCommits(receiveEvent, rejectCommits));
    } catch (CommitValidationException e) {
        messages.addAll(e.getMessages());
        reject(cmd, e.getMessage());
        return false;
    }
    validCommits.add(c.copy());
    return true;
}
#end_block

#method_before
private void autoCloseChanges(final ReceiveCommand cmd) {
    final RevWalk rw = rp.getRevWalk();
    try {
        RevCommit newTip = rw.parseCommit(cmd.getNewId());
        Branch.NameKey branch = new Branch.NameKey(project.getNameKey(), cmd.getRefName());
        rw.reset();
        rw.markStart(newTip);
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final SetMultimap<ObjectId, Ref> byCommit = changeRefsById();
        Map<Change.Key, Change> byKey = null;
        final List<ReplaceRequest> toClose = new ArrayList<>();
        for (RevCommit c; (c = rw.next()) != null; ) {
            rw.parseBody(c);
            for (Ref ref : byCommit.get(c.copy())) {
                Change.Key closedChange = closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                closeProgress.update(1);
                if (closedChange != null) {
                    if (byKey == null) {
                        byKey = openChangesByBranch(branch);
                    }
                    byKey.remove(closedChange);
                }
            }
            for (final String changeId : c.getFooterLines(CHANGE_ID)) {
                if (byKey == null) {
                    byKey = openChangesByBranch(branch);
                }
                final Change onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    final ReplaceRequest req = new ReplaceRequest(onto.getId(), c, cmd, false);
                    req.change = onto;
                    toClose.add(req);
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = req.validate(true) ? req.insertPatchSet().checkedGet() : null;
            if (psi != null) {
                closeChange(req.inputCommand, psi, req.newCommit);
                closeProgress.update(1);
            }
        }
    } catch (RestApiException e) {
        log.error("Can't insert patchset", e);
    } catch (IOException | OrmException e) {
        log.error("Can't scan for changes to close", e);
    }
}
#method_after
private void autoCloseChanges(final ReceiveCommand cmd) {
    RevWalk rw = rp.getRevWalk();
    try {
        RevCommit newTip = rw.parseCommit(cmd.getNewId());
        Branch.NameKey branch = new Branch.NameKey(project.getNameKey(), cmd.getRefName());
        rw.reset();
        rw.markStart(newTip);
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        SetMultimap<ObjectId, Ref> byCommit = changeRefsById();
        Map<Change.Key, Change> byKey = null;
        List<ReplaceRequest> toClose = new ArrayList<>();
        for (RevCommit c; (c = rw.next()) != null; ) {
            rw.parseBody(c);
            for (Ref ref : byCommit.get(c.copy())) {
                Change.Key closedChange = closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                closeProgress.update(1);
                if (closedChange != null) {
                    if (byKey == null) {
                        byKey = openChangesByBranch(branch);
                    }
                    byKey.remove(closedChange);
                }
            }
            for (String changeId : c.getFooterLines(CHANGE_ID)) {
                if (byKey == null) {
                    byKey = openChangesByBranch(branch);
                }
                Change onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    ReplaceRequest req = new ReplaceRequest(onto.getId(), c, cmd, false);
                    req.change = onto;
                    toClose.add(req);
                    break;
                }
            }
        }
        for (ReplaceRequest req : toClose) {
            PatchSet.Id psi = req.validate(true) ? req.insertPatchSet().checkedGet() : null;
            if (psi != null) {
                closeChange(req.inputCommand, psi, req.newCommitId);
                closeProgress.update(1);
            }
        }
    } catch (RestApiException e) {
        log.error("Can't insert patchset", e);
    } catch (IOException | OrmException | UpdateException e) {
        log.error("Can't scan for changes to close", e);
    }
}
#end_block

#method_before
private Change.Key closeChange(final ReceiveCommand cmd, final PatchSet.Id psi, final RevCommit commit) throws OrmException, IOException {
    final String refName = cmd.getRefName();
    final Change.Id cid = psi.getParentKey();
    final Change change = db.changes().get(cid);
    final PatchSet ps = db.patchSets().get(psi);
    if (change == null || ps == null) {
        log.warn(project.getName() + " " + psi + " is missing");
        return null;
    }
    if (change.getStatus() == Change.Status.MERGED || change.getStatus() == Change.Status.ABANDONED || !change.getDest().get().equals(refName)) {
        // 
        return null;
    }
    ReplaceRequest result = new ReplaceRequest(cid, commit, cmd, false);
    result.change = change;
    result.changeCtl = projectControl.controlFor(change);
    result.newPatchSet = ps;
    result.info = patchSetInfoFactory.get(rp.getRevWalk(), commit, psi);
    result.mergedIntoRef = refName;
    markChangeMergedByPush(db, result, result.changeCtl);
    changeMerged.fire(change, result.newPatchSet, user.getAccount(), commit.getName());
    hooks.doChangeMergedHook(change, user.getAccount(), result.newPatchSet, db, commit.getName());
    sendMergedEmail(result);
    return change.getKey();
}
#method_after
private Change.Key closeChange(ReceiveCommand cmd, PatchSet.Id psi, ObjectId commitId) throws OrmException, IOException, UpdateException, RestApiException {
    String refName = cmd.getRefName();
    Change.Id cid = psi.getParentKey();
    Change change;
    try {
        change = notesFactory.createChecked(db, project.getNameKey(), cid).getChange();
    } catch (NoSuchChangeException e) {
        log.warn(project.getName() + " change " + cid + " is missing");
        return null;
    }
    ChangeControl ctl = projectControl.controlFor(db, change);
    PatchSet ps = psUtil.get(db, ctl.getNotes(), psi);
    if (ps == null) {
        log.warn(project.getName() + " patch set " + psi + " is missing");
        return null;
    }
    if (change.getStatus() == Change.Status.MERGED || change.getStatus() == Change.Status.ABANDONED || !change.getDest().get().equals(refName)) {
        // 
        return null;
    }
    RevCommit commit = rp.getRevWalk().parseCommit(commitId);
    rp.getRevWalk().parseBody(commit);
    PatchSetInfo info = patchSetInfoFactory.get(rp.getRevWalk(), commit, psi);
    markChangeMergedByPush(db, info, refName);
    hooks.doChangeMergedHook(change, user.getAccount(), ps, db, commit.getName());
    sendMergedEmail(ps, info);
    return change.getKey();
}
#end_block

#method_before
private Map<Change.Key, Change> openChangesByBranch(Branch.NameKey branch) throws OrmException {
    final Map<Change.Key, Change> r = new HashMap<>();
    for (ChangeData cd : queryProvider.get().byBranchOpen(branch)) {
        r.put(cd.change().getKey(), cd.change());
    }
    return r;
}
#method_after
private Map<Change.Key, Change> openChangesByBranch(Branch.NameKey branch) throws OrmException {
    Map<Change.Key, Change> r = new HashMap<>();
    for (ChangeData cd : queryProvider.get().byBranchOpen(branch)) {
        r.put(cd.change().getKey(), cd.change());
    }
    return r;
}
#end_block

#method_before
private void markChangeMergedByPush(ReviewDb db, final ReplaceRequest result, ChangeControl control) throws OrmException, IOException {
    Change.Id id = result.change.getId();
    db.changes().beginTransaction(id);
    Change change;
    ChangeUpdate update;
    try {
        change = db.changes().atomicUpdate(id, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.setCurrentPatchSet(result.info);
                    change.setStatus(Change.Status.MERGED);
                    ChangeUtil.updated(change);
                }
                return change;
            }
        });
        String mergedIntoRef = result.mergedIntoRef;
        StringBuilder msgBuf = new StringBuilder();
        msgBuf.append("Change has been successfully pushed");
        if (!mergedIntoRef.equals(change.getDest().get())) {
            msgBuf.append(" into ");
            if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
                msgBuf.append("branch ");
                msgBuf.append(Repository.shortenRefName(mergedIntoRef));
            } else {
                msgBuf.append(mergedIntoRef);
            }
        }
        msgBuf.append(".");
        ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(id, ChangeUtil.messageUUID(db)), user.getAccountId(), change.getLastUpdatedOn(), result.info.getKey());
        msg.setMessage(msgBuf.toString());
        update = updateFactory.create(control, change.getLastUpdatedOn());
        cmUtil.addChangeMessage(db, update, msg);
        db.commit();
    } finally {
        db.rollback();
    }
    indexer.index(db, change);
    update.commit();
}
#method_after
private void markChangeMergedByPush(ReviewDb db, final PatchSetInfo info, final String mergedIntoRef) throws UpdateException, RestApiException {
    try (BatchUpdate bu = batchUpdateFactory.create(db, project.getNameKey(), user, TimeUtil.nowTs())) {
        bu.addOp(info.getKey().getParentKey(), new BatchUpdate.Op() {

            @Override
            public boolean updateChange(ChangeContext ctx) throws OrmException {
                Change change = ctx.getChange();
                ChangeUpdate update = ctx.getUpdate(info.getKey());
                if (change.getStatus().isOpen()) {
                    change.setCurrentPatchSet(info);
                    change.setStatus(Change.Status.MERGED);
                    // we cannot reconstruct the submit records for when this change was
                    // submitted, this is why we must fix the status
                    update.fixStatus(Change.Status.MERGED);
                }
                StringBuilder msgBuf = new StringBuilder();
                msgBuf.append("Change has been successfully pushed");
                if (!mergedIntoRef.equals(change.getDest().get())) {
                    msgBuf.append(" into ");
                    if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
                        msgBuf.append("branch ");
                        msgBuf.append(Repository.shortenRefName(mergedIntoRef));
                    } else {
                        msgBuf.append(mergedIntoRef);
                    }
                }
                msgBuf.append(".");
                ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(ctx.getDb())), user.getAccountId(), ctx.getWhen(), info.getKey());
                msg.setMessage(msgBuf.toString());
                cmUtil.addChangeMessage(ctx.getDb(), update, msg);
                PatchSetApproval submitter = new PatchSetApproval(new PatchSetApproval.Key(change.currentPatchSetId(), ctx.getUser().getAccountId(), LabelId.legacySubmit()), (short) 1, ctx.getWhen());
                update.putApproval(submitter.getLabel(), submitter.getValue());
                ctx.getDb().patchSetApprovals().upsert(Collections.singleton(submitter));
                return true;
            }
        });
        bu.execute();
    }
}
#end_block

#method_before
private void sendMergedEmail(final ReplaceRequest result) {
    final Change.Id id = result.change.getId();
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                final MergedSender cm = mergedSenderFactory.create(id);
                cm.setFrom(user.getAccountId());
                cm.setPatchSet(result.newPatchSet, result.info);
                cm.send();
            } catch (Exception e) {
                final PatchSet.Id psi = result.newPatchSet.getId();
                log.error("Cannot send email for submitted patch set " + psi, e);
            }
        }

        @Override
        public String toString() {
            return "send-email merged";
        }
    }));
}
#method_after
private void sendMergedEmail(final PatchSet ps, final PatchSetInfo info) {
    sendEmailExecutor.submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                MergedSender cm = mergedSenderFactory.create(project.getNameKey(), ps.getId().getParentKey());
                cm.setFrom(user.getAccountId());
                cm.setPatchSet(ps, info);
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for submitted patch set " + ps.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send-email merged";
        }
    }));
}
#end_block

#method_before
private void reject(final ReceiveCommand cmd) {
    reject(cmd, "prohibited by Gerrit");
}
#method_after
private void reject(ReceiveCommand cmd) {
    reject(cmd, "prohibited by Gerrit");
}
#end_block

#method_before
private void reject(final ReceiveCommand cmd, final String why) {
    cmd.setResult(REJECTED_OTHER_REASON, why);
    commandProgress.update(1);
}
#method_after
private void reject(ReceiveCommand cmd, String why) {
    cmd.setResult(REJECTED_OTHER_REASON, why);
    commandProgress.update(1);
}
#end_block

#method_before
private static boolean isHead(final ReceiveCommand cmd) {
    return cmd.getRefName().startsWith(Constants.R_HEADS);
}
#method_after
private static boolean isHead(ReceiveCommand cmd) {
    return cmd.getRefName().startsWith(Constants.R_HEADS);
}
#end_block

#method_before
private static boolean isConfig(final ReceiveCommand cmd) {
    return cmd.getRefName().equals(RefNames.REFS_CONFIG);
}
#method_after
private static boolean isConfig(ReceiveCommand cmd) {
    return cmd.getRefName().equals(RefNames.REFS_CONFIG);
}
#end_block

#method_before
protected void updateSuperProjects(ReviewDb db, Collection<Branch.NameKey> updatedBranches) throws SubmoduleException {
    try {
        // These (repo/branch) will be updated later with all the given
        // individual submodule subscriptions
        Multimap<Branch.NameKey, SubmoduleSubscription> targets = HashMultimap.create();
        for (Branch.NameKey updatedBranch : updatedBranches) {
            for (SubmoduleSubscription sub : db.submoduleSubscriptions().bySubmodule(updatedBranch)) {
                targets.put(sub.getSuperProject(), sub);
            }
        }
        updatedSubscribers.addAll(updatedBranches);
        // Update subscribers.
        for (Branch.NameKey dest : targets.keySet()) {
            try {
                if (!updatedSubscribers.add(dest)) {
                    log.error("Possible circular subscription involving " + dest);
                } else {
                    updateGitlinks(db, dest, targets.get(dest));
                }
            } catch (SubmoduleException e) {
                log.warn("Cannot update gitlinks for " + dest, e);
            }
        }
    } catch (OrmException e) {
        logAndThrowSubmoduleException("Cannot read subscription records", e);
    }
}
#method_after
protected void updateSuperProjects(ReviewDb db, Collection<Branch.NameKey> updatedBranches, String updateId, MergeOpRepoManager orm) throws SubmoduleException {
    if (!enableSuperProjectSubscriptions) {
        logDebug("Updating superprojects disabled");
        return;
    }
    this.updateId = updateId;
    logDebug("Updating superprojects");
    // These (repo/branch) will be updated later with all the given
    // individual submodule subscriptions
    Multimap<Branch.NameKey, SubmoduleSubscription> targets = HashMultimap.create();
    try {
        for (Branch.NameKey updatedBranch : updatedBranches) {
            for (SubmoduleSubscription sub : superProjectSubscriptionsForSubmoduleBranch(updatedBranch, orm)) {
                targets.put(sub.getSuperProject(), sub);
            }
        }
    } catch (IOException e) {
        throw new SubmoduleException("Could not calculate all superprojects");
    }
    updatedSubscribers.addAll(updatedBranches);
    // Update subscribers.
    for (Branch.NameKey dest : targets.keySet()) {
        try {
            if (!updatedSubscribers.add(dest)) {
                log.error("Possible circular subscription involving " + dest);
            } else {
                updateGitlinks(db, dest, targets.get(dest), orm);
            }
        } catch (SubmoduleException e) {
            log.warn("Cannot update gitlinks for " + dest, e);
        }
    }
}
#end_block

#method_before
private void updateGitlinks(ReviewDb db, Branch.NameKey subscriber, Collection<SubmoduleSubscription> updates) throws SubmoduleException {
    PersonIdent author = null;
    StringBuilder msgbuf = new StringBuilder("Updated git submodules\n\n");
    boolean sameAuthorForAll = true;
    try (Repository pdb = repoManager.openRepository(subscriber.getParentKey())) {
        if (pdb.getRef(subscriber.get()) == null) {
            throw new SubmoduleException("The branch was probably deleted from the subscriber repository");
        }
        DirCache dc = readTree(pdb, pdb.getRef(subscriber.get()));
        DirCacheEditor ed = dc.editor();
        for (SubmoduleSubscription s : updates) {
            try (Repository subrepo = repoManager.openRepository(s.getSubmodule().getParentKey());
                RevWalk rw = CodeReviewCommit.newRevWalk(subrepo)) {
                Ref ref = subrepo.getRefDatabase().exactRef(s.getSubmodule().get());
                if (ref == null) {
                    ed.add(new DeletePath(s.getPath()));
                    continue;
                }
                final ObjectId updateTo = ref.getObjectId();
                RevCommit newCommit = rw.parseCommit(updateTo);
                if (author == null) {
                    author = newCommit.getAuthorIdent();
                } else if (!author.equals(newCommit.getAuthorIdent())) {
                    sameAuthorForAll = false;
                }
                DirCacheEntry dce = dc.getEntry(s.getPath());
                ObjectId oldId;
                if (dce != null) {
                    if (!dce.getFileMode().equals(FileMode.GITLINK)) {
                        log.error("Requested to update gitlink " + s.getPath() + " in " + s.getSubmodule().getParentKey().get() + " but entry " + "doesn't have gitlink file mode.");
                        continue;
                    }
                    oldId = dce.getObjectId();
                } else {
                    // This submodule did not exist before. We do not want to add
                    // the full submodule history to the commit message, so omit it.
                    oldId = updateTo;
                }
                ed.add(new PathEdit(s.getPath()) {

                    @Override
                    public void apply(DirCacheEntry ent) {
                        ent.setFileMode(FileMode.GITLINK);
                        ent.setObjectId(updateTo);
                    }
                });
                if (verboseSuperProject) {
                    msgbuf.append("Project: " + s.getSubmodule().getParentKey().get());
                    msgbuf.append(" " + s.getSubmodule().getShortName());
                    msgbuf.append(" " + updateTo.getName());
                    msgbuf.append("\n\n");
                    try {
                        rw.markStart(newCommit);
                        rw.markUninteresting(rw.parseCommit(oldId));
                        for (RevCommit c : rw) {
                            msgbuf.append(c.getFullMessage() + "\n\n");
                        }
                    } catch (IOException e) {
                        logAndThrowSubmoduleException("Could not perform a revwalk to " + "create superproject commit message", e);
                    }
                }
            }
        }
        ed.finish();
        if (!sameAuthorForAll || author == null) {
            author = myIdent;
        }
        ObjectInserter oi = pdb.newObjectInserter();
        ObjectId tree = dc.writeTree(oi);
        ObjectId currentCommitId = pdb.getRef(subscriber.get()).getObjectId();
        CommitBuilder commit = new CommitBuilder();
        commit.setTreeId(tree);
        commit.setParentIds(new ObjectId[] { currentCommitId });
        commit.setAuthor(author);
        commit.setCommitter(myIdent);
        commit.setMessage(msgbuf.toString());
        oi.insert(commit);
        oi.flush();
        ObjectId commitId = oi.idFor(Constants.OBJ_COMMIT, commit.build());
        final RefUpdate rfu = pdb.updateRef(subscriber.get());
        rfu.setForceUpdate(false);
        rfu.setNewObjectId(commitId);
        rfu.setExpectedOldObjectId(currentCommitId);
        rfu.setRefLogMessage("Submit to " + subscriber.getParentKey().get(), true);
        switch(rfu.update()) {
            case NEW:
            case FAST_FORWARD:
                gitRefUpdated.fire(subscriber.getParentKey(), rfu, account);
                changeHooks.doRefUpdatedHook(subscriber, rfu, account);
                // sent to inform users about the updated branch
                break;
            default:
                throw new IOException(rfu.getResult().name());
        }
        // Recursive call: update subscribers of the subscriber
        updateSuperProjects(db, Sets.newHashSet(subscriber));
    } catch (IOException e) {
        throw new SubmoduleException("Cannot update gitlinks for " + subscriber.get(), e);
    }
}
#method_after
private void updateGitlinks(ReviewDb db, Branch.NameKey subscriber, Collection<SubmoduleSubscription> updates, MergeOpRepoManager orm) throws SubmoduleException {
    PersonIdent author = null;
    StringBuilder msgbuf = new StringBuilder("Update git submodules\n\n");
    boolean sameAuthorForAll = true;
    try {
        orm.openRepo(subscriber.getParentKey(), false);
    } catch (NoSuchProjectException | IOException e) {
        throw new SubmoduleException("Cannot access superproject", e);
    }
    OpenRepo or = orm.getRepo(subscriber.getParentKey());
    try {
        Ref r = or.repo.exactRef(subscriber.get());
        if (r == null) {
            throw new SubmoduleException("The branch was probably deleted from the subscriber repository");
        }
        DirCache dc = readTree(r, or.rw);
        DirCacheEditor ed = dc.editor();
        for (SubmoduleSubscription s : updates) {
            try {
                orm.openRepo(s.getSubmodule().getParentKey(), false);
            } catch (NoSuchProjectException | IOException e) {
                throw new SubmoduleException("Cannot access submodule", e);
            }
            OpenRepo subOr = orm.getRepo(s.getSubmodule().getParentKey());
            Repository subrepo = subOr.repo;
            Ref ref = subrepo.getRefDatabase().exactRef(s.getSubmodule().get());
            if (ref == null) {
                ed.add(new DeletePath(s.getPath()));
                continue;
            }
            final ObjectId updateTo = ref.getObjectId();
            RevCommit newCommit = subOr.rw.parseCommit(updateTo);
            subOr.rw.parseBody(newCommit);
            if (author == null) {
                author = newCommit.getAuthorIdent();
            } else if (!author.equals(newCommit.getAuthorIdent())) {
                sameAuthorForAll = false;
            }
            DirCacheEntry dce = dc.getEntry(s.getPath());
            ObjectId oldId;
            if (dce != null) {
                if (!dce.getFileMode().equals(FileMode.GITLINK)) {
                    log.error("Requested to update gitlink " + s.getPath() + " in " + s.getSubmodule().getParentKey().get() + " but entry " + "doesn't have gitlink file mode.");
                    continue;
                }
                oldId = dce.getObjectId();
            } else {
                // This submodule did not exist before. We do not want to add
                // the full submodule history to the commit message, so omit it.
                oldId = updateTo;
            }
            ed.add(new PathEdit(s.getPath()) {

                @Override
                public void apply(DirCacheEntry ent) {
                    ent.setFileMode(FileMode.GITLINK);
                    ent.setObjectId(updateTo);
                }
            });
            if (verboseSuperProject) {
                msgbuf.append("Project: " + s.getSubmodule().getParentKey().get());
                msgbuf.append(" " + s.getSubmodule().getShortName());
                msgbuf.append(" " + updateTo.getName());
                msgbuf.append("\n\n");
                try {
                    subOr.rw.markStart(newCommit);
                    subOr.rw.markUninteresting(subOr.rw.parseCommit(oldId));
                    for (RevCommit c : subOr.rw) {
                        subOr.rw.parseBody(c);
                        msgbuf.append(c.getFullMessage() + "\n\n");
                    }
                } catch (IOException e) {
                    throw new SubmoduleException("Could not perform a revwalk to " + "create superproject commit message", e);
                }
            }
        }
        ed.finish();
        if (!sameAuthorForAll || author == null) {
            author = myIdent;
        }
        ObjectInserter oi = or.repo.newObjectInserter();
        ObjectId tree = dc.writeTree(oi);
        ObjectId currentCommitId = or.repo.exactRef(subscriber.get()).getObjectId();
        CommitBuilder commit = new CommitBuilder();
        commit.setTreeId(tree);
        commit.setParentIds(new ObjectId[] { currentCommitId });
        commit.setAuthor(author);
        commit.setCommitter(myIdent);
        commit.setMessage(msgbuf.toString());
        oi.insert(commit);
        oi.flush();
        ObjectId commitId = oi.idFor(Constants.OBJ_COMMIT, commit.build());
        final RefUpdate rfu = or.repo.updateRef(subscriber.get());
        rfu.setForceUpdate(false);
        rfu.setNewObjectId(commitId);
        rfu.setExpectedOldObjectId(currentCommitId);
        rfu.setRefLogMessage("Submit to " + subscriber.getParentKey().get(), true);
        switch(rfu.update()) {
            case NEW:
            case FAST_FORWARD:
                gitRefUpdated.fire(subscriber.getParentKey(), rfu, account);
                changeHooks.doRefUpdatedHook(subscriber, rfu, account);
                // sent to inform users about the updated branch
                break;
            case FORCED:
            case IO_FAILURE:
            case LOCK_FAILURE:
            case NOT_ATTEMPTED:
            case NO_CHANGE:
            case REJECTED:
            case REJECTED_CURRENT_BRANCH:
            case RENAMED:
            default:
                throw new IOException(rfu.getResult().name());
        }
        // Recursive call: update subscribers of the subscriber
        updateSuperProjects(db, Sets.newHashSet(subscriber), updateId, orm);
    } catch (IOException e) {
        throw new SubmoduleException("Cannot update gitlinks for " + subscriber.get(), e);
    }
}
#end_block

#method_before
private static DirCache readTree(final Repository pdb, final Ref branch) throws MissingObjectException, IncorrectObjectTypeException, IOException {
    try (RevWalk rw = new RevWalk(pdb)) {
        final DirCache dc = DirCache.newInCore();
        final DirCacheBuilder b = dc.builder();
        // no prefix path
        b.addTree(// no prefix path
        new byte[0], // standard stage
        DirCacheEntry.STAGE_0, pdb.newObjectReader(), rw.parseTree(branch.getObjectId()));
        b.finish();
        return dc;
    }
}
#method_after
private static DirCache readTree(final Ref branch, RevWalk rw) throws MissingObjectException, IncorrectObjectTypeException, IOException {
    final DirCache dc = DirCache.newInCore();
    final DirCacheBuilder b = dc.builder();
    // no prefix path
    b.addTree(// no prefix path
    new byte[0], // standard stage
    DirCacheEntry.STAGE_0, rw.getObjectReader(), rw.parseTree(branch.getObjectId()));
    b.finish();
    return dc;
}
#end_block

#method_before
public Repository getRepository() throws IOException {
    initRepository();
    return repo;
}
#method_after
@Override
public Repository getRepository() throws IOException {
    return BatchUpdate.this.getRepository();
}
#end_block

#method_before
public ObjectInserter getInserter() throws IOException {
    initRepository();
    return inserter;
}
#method_after
public ObjectInserter getInserter() throws IOException {
    return BatchUpdate.this.getObjectInserter();
}
#end_block

#method_before
public void addRefUpdate(ReceiveCommand cmd) throws IOException {
    getBatchRefUpdate().addCommand(cmd);
}
#method_after
public void addRefUpdate(ReceiveCommand cmd) throws IOException {
    initRepository();
    commands.add(cmd);
}
#end_block

#method_before
public Change getChange() {
    return update.getChange();
}
#method_after
public Change getChange() {
    Change c = ctl.getChange();
    checkNotNull(c);
    return c;
}
#end_block

#method_before
@SuppressWarnings("unused")
public void updateChange(ChangeContext ctx) throws Exception {
}
#method_after
@SuppressWarnings("unused")
public boolean updateChange(ChangeContext ctx) throws Exception {
    return false;
}
#end_block

#method_before
public void execute() throws UpdateException, RestApiException {
    try {
        executeRefUpdates();
        executeChangeOps();
        reindexChanges();
        if (batchRefUpdate != null) {
            // Fire ref update events only after all mutations are finished, since
            // callers may assume a patch set ref being created means the change was
            // created, or a branch advancing meaning some changes were closed.
            gitRefUpdated.fire(project, batchRefUpdate, user.getAccountId());
        }
        executePostOps();
    } catch (UpdateException | RestApiException e) {
        // failure.
        throw e;
    } catch (Exception e) {
        Throwables.propagateIfPossible(e);
        throw new UpdateException(e);
    }
}
#method_after
static void execute(Collection<BatchUpdate> updates, Listener listener) throws UpdateException, RestApiException {
    if (updates.isEmpty()) {
        return;
    }
    try {
        Order order = getOrder(updates);
        switch(order) {
            case REPO_BEFORE_DB:
                for (BatchUpdate u : updates) {
                    u.executeUpdateRepo();
                }
                listener.afterUpdateRepos();
                for (BatchUpdate u : updates) {
                    u.executeRefUpdates();
                }
                listener.afterRefUpdates();
                for (BatchUpdate u : updates) {
                    u.executeChangeOps();
                }
                listener.afterUpdateChanges();
                break;
            case DB_BEFORE_REPO:
                for (BatchUpdate u : updates) {
                    u.executeChangeOps();
                }
                listener.afterUpdateChanges();
                for (BatchUpdate u : updates) {
                    u.executeUpdateRepo();
                }
                listener.afterUpdateRepos();
                for (BatchUpdate u : updates) {
                    u.executeRefUpdates();
                }
                listener.afterRefUpdates();
                break;
            default:
                throw new IllegalStateException("invalid execution order: " + order);
        }
        List<CheckedFuture<?, IOException>> indexFutures = new ArrayList<>();
        for (BatchUpdate u : updates) {
            indexFutures.addAll(u.indexFutures);
        }
        ChangeIndexer.allAsList(indexFutures).get();
        for (BatchUpdate u : updates) {
            if (u.batchRefUpdate != null) {
                // Fire ref update events only after all mutations are finished, since
                // callers may assume a patch set ref being created means the change
                // was created, or a branch advancing meaning some changes were
                // closed.
                u.gitRefUpdated.fire(u.project, u.batchRefUpdate, u.getUser().isIdentifiedUser() ? u.getUser().getAccountId() : null);
            }
        }
        for (BatchUpdate u : updates) {
            u.executePostOps();
        }
    } catch (UpdateException | RestApiException e) {
        // failure.
        throw e;
    // Convert other common non-REST exception types with user-visible
    // messages to corresponding REST exception types
    } catch (InvalidChangeOperationException e) {
        throw new ResourceConflictException(e.getMessage(), e);
    } catch (NoSuchChangeException | NoSuchRefException | NoSuchProjectException e) {
        throw new ResourceNotFoundException(e.getMessage(), e);
    } catch (Exception e) {
        Throwables.propagateIfPossible(e);
        throw new UpdateException(e);
    }
}
#end_block

#method_before
public BatchUpdate setRepository(Repository repo, RevWalk revWalk, ObjectInserter inserter) {
    checkState(this.repo == null, "repo already set");
    closeRepo = false;
    this.repo = checkNotNull(repo, "repo");
    this.revWalk = checkNotNull(revWalk, "revWalk");
    this.inserter = checkNotNull(inserter, "inserter");
    return this;
}
#method_after
public BatchUpdate setRepository(Repository repo, RevWalk revWalk, ObjectInserter inserter) {
    checkState(this.repo == null, "repo already set");
    closeRepo = false;
    this.repo = checkNotNull(repo, "repo");
    this.revWalk = checkNotNull(revWalk, "revWalk");
    this.inserter = checkNotNull(inserter, "inserter");
    commands = new ChainedReceiveCommands(repo);
    return this;
}
#end_block

#method_before
private void initRepository() throws IOException {
    if (repo == null) {
        this.repo = repoManager.openRepository(project);
        closeRepo = true;
        inserter = repo.newObjectInserter();
        revWalk = new RevWalk(inserter.newReader());
    }
}
#method_after
private void initRepository() throws IOException {
    if (repo == null) {
        this.repo = repoManager.openRepository(project);
        closeRepo = true;
        inserter = repo.newObjectInserter();
        revWalk = new RevWalk(inserter.newReader());
        commands = new ChainedReceiveCommands(repo);
    }
}
#end_block

#method_before
public BatchUpdate insertChange(InsertChangeOp op) {
    Change c = op.getChange();
    checkArgument(!newChanges.containsKey(c.getId()), "only one op allowed to create change %s", c.getId());
    newChanges.put(c.getId(), c);
    ops.get(c.getId()).add(0, op);
    return this;
}
#method_after
public BatchUpdate insertChange(InsertChangeOp op) {
    Context ctx = new Context();
    Change c = op.createChange(ctx);
    checkArgument(!newChanges.containsKey(c.getId()), "only one op allowed to create change %s", c.getId());
    newChanges.put(c.getId(), c);
    ops.get(c.getId()).add(0, op);
    return this;
}
#end_block

#method_before
public void execute() throws UpdateException, RestApiException {
    try {
        executeRefUpdates();
        executeChangeOps();
        reindexChanges();
        if (batchRefUpdate != null) {
            // Fire ref update events only after all mutations are finished, since
            // callers may assume a patch set ref being created means the change was
            // created, or a branch advancing meaning some changes were closed.
            gitRefUpdated.fire(project, batchRefUpdate, user.getAccountId());
        }
        executePostOps();
    } catch (UpdateException | RestApiException e) {
        // failure.
        throw e;
    } catch (Exception e) {
        Throwables.propagateIfPossible(e);
        throw new UpdateException(e);
    }
}
#method_after
public void execute() throws UpdateException, RestApiException {
    execute(Listener.NONE);
}
#end_block

#method_before
private void executeRefUpdates() throws IOException, UpdateException, RestApiException {
    try {
        RepoContext ctx = new RepoContext();
        for (Op op : ops.values()) {
            op.updateRepo(ctx);
        }
    } catch (Exception e) {
        Throwables.propagateIfPossible(e, RestApiException.class);
        throw new UpdateException(e);
    }
    if (repo == null || batchRefUpdate == null || batchRefUpdate.getCommands().isEmpty()) {
        return;
    }
    inserter.flush();
    batchRefUpdate.execute(revWalk, NullProgressMonitor.INSTANCE);
    boolean ok = true;
    for (ReceiveCommand cmd : batchRefUpdate.getCommands()) {
        if (cmd.getResult() != ReceiveCommand.Result.OK) {
            ok = false;
            break;
        }
    }
    if (!ok) {
        throw new UpdateException("BatchRefUpdate failed: " + batchRefUpdate);
    }
}
#method_after
private void executeRefUpdates() throws IOException, UpdateException {
    if (commands == null || commands.isEmpty()) {
        return;
    }
    // May not be opened if the caller added ref updates but no new objects.
    initRepository();
    batchRefUpdate = repo.getRefDatabase().newBatchUpdate();
    commands.addTo(batchRefUpdate);
    batchRefUpdate.execute(revWalk, NullProgressMonitor.INSTANCE);
    boolean ok = true;
    for (ReceiveCommand cmd : batchRefUpdate.getCommands()) {
        if (cmd.getResult() != ReceiveCommand.Result.OK) {
            ok = false;
            break;
        }
    }
    if (!ok) {
        throw new UpdateException("BatchRefUpdate failed: " + batchRefUpdate);
    }
}
#end_block

#method_before
private void executeChangeOps() throws UpdateException, RestApiException {
    try {
        for (Map.Entry<Change.Id, Collection<Op>> e : ops.asMap().entrySet()) {
            Change.Id id = e.getKey();
            db.changes().beginTransaction(id);
            ChangeContext ctx;
            try {
                ctx = newChangeContext(id);
                for (Op op : e.getValue()) {
                    op.updateChange(ctx);
                }
                db.commit();
            } finally {
                db.rollback();
            }
            ctx.getChangeUpdate().commit();
            indexFutures.add(indexer.indexAsync(id));
        }
    } catch (Exception e) {
        Throwables.propagateIfPossible(e, RestApiException.class);
        throw new UpdateException(e);
    }
}
#method_after
private void executeChangeOps() throws UpdateException, RestApiException {
    try {
        for (Map.Entry<Change.Id, Collection<Op>> e : ops.asMap().entrySet()) {
            Change.Id id = e.getKey();
            db.changes().beginTransaction(id);
            ChangeContext ctx;
            NoteDbUpdateManager updateManager = null;
            boolean dirty = false;
            try {
                ctx = newChangeContext(id);
                // Call updateChange on each op.
                for (Op op : e.getValue()) {
                    dirty |= op.updateChange(ctx);
                }
                if (!dirty) {
                    return;
                }
                // Stage the NoteDb update and store its state in the Change.
                if (!ctx.deleted && notesMigration.writeChanges()) {
                    updateManager = stageNoteDbUpdate(ctx);
                }
                // Bump lastUpdatedOn or rowVersion and commit.
                Iterable<Change> cs = changesToUpdate(ctx);
                if (newChanges.containsKey(id)) {
                    // Insert rather than upsert in case of a race on change IDs.
                    db.changes().insert(cs);
                } else if (ctx.deleted) {
                    db.changes().delete(cs);
                } else {
                    db.changes().update(cs);
                }
                db.commit();
            } finally {
                db.rollback();
            }
            // Execute NoteDb updates after committing ReviewDb updates.
            if (notesMigration.writeChanges()) {
                if (updateManager != null) {
                    updateManager.execute();
                }
                if (ctx.deleted) {
                    new ChangeDelete(plcUtil, getRepository(), ctx.getNotes()).delete();
                }
            }
            // Reindex changes.
            if (ctx.deleted) {
                indexFutures.add(indexer.deleteAsync(id));
            } else {
                indexFutures.add(indexer.indexAsync(ctx.getProject(), id));
            }
        }
    } catch (Exception e) {
        Throwables.propagateIfPossible(e, RestApiException.class);
        throw new UpdateException(e);
    }
}
#end_block

#method_before
private ChangeContext newChangeContext(Change.Id id) throws Exception {
    Change c = newChanges.get(id);
    if (c == null) {
        c = db.changes().get(id);
    }
    // - attempting to read a change that doesn't exist yet
    return new ChangeContext(changeControlFactory.controlFor(c, user));
}
#method_after
private ChangeContext newChangeContext(Change.Id id) throws Exception {
    Change c = newChanges.get(id);
    if (c == null) {
        c = unwrap(db).changes().get(id);
    }
    // Pass in preloaded change to controlFor, to avoid:
    // - reading from a db that does not belong to this update
    // - attempting to read a change that doesn't exist yet
    ChangeNotes notes = changeNotesFactory.createForNew(c);
    ChangeContext ctx = new ChangeContext(changeControlFactory.controlFor(notes, user), new BatchUpdateReviewDb(db));
    return ctx;
}
#end_block

#method_before
private void updateRef(String notesBranch) throws IOException, MissingObjectException, IncorrectObjectTypeException, CorruptObjectException, ConcurrentRefUpdateException {
    if (baseCommit != null && oursCommit.getTree().equals(baseCommit.getTree())) {
        // Avoid saving this commit as it has no new information.
        return;
    }
    int remainingLockFailureCalls = MAX_LOCK_FAILURE_CALLS;
    RefUpdate refUpdate = createRefUpdate(notesBranch, oursCommit, baseCommit);
    for (; ; ) {
        Result result = refUpdate.update();
        if (result == Result.LOCK_FAILURE) {
            if (--remainingLockFailureCalls > 0) {
                try {
                    Thread.sleep(SLEEP_ON_LOCK_FAILURE_MS);
                } catch (InterruptedException e) {
                // ignore
                }
            } else {
                throw new ConcurrentRefUpdateException("Failed to lock the ref: " + notesBranch, refUpdate.getRef(), result);
            }
        } else if (result == Result.REJECTED) {
            RevCommit theirsCommit = revWalk.parseCommit(refUpdate.getOldObjectId());
            NoteMap theirs = NoteMap.read(revWalk.getObjectReader(), theirsCommit);
            NoteMapMerger merger = new NoteMapMerger(db, getNoteMerger(), MergeStrategy.RESOLVE);
            NoteMap merged = merger.merge(base, ours, theirs);
            RevCommit mergeCommit = createCommit(merged, gerritIdent, "Merged note commits\n", theirsCommit, oursCommit);
            refUpdate = createRefUpdate(notesBranch, mergeCommit, theirsCommit);
            remainingLockFailureCalls = MAX_LOCK_FAILURE_CALLS;
        } else if (result == Result.IO_FAILURE) {
            throw new IOException("Couldn't update " + notesBranch + ". " + result.name());
        } else {
            AccountInfo gerrit = new AccountInfo(null);
            gerrit.name = gerritIdent.getName();
            gerrit.email = gerritIdent.getEmailAddress();
            gitRefUpdated.fire(project, refUpdate, gerrit);
            break;
        }
    }
}
#method_after
private void updateRef(String notesBranch) throws IOException, MissingObjectException, IncorrectObjectTypeException, CorruptObjectException, ConcurrentRefUpdateException {
    if (baseCommit != null && oursCommit.getTree().equals(baseCommit.getTree())) {
        // Avoid saving this commit as it has no new information.
        return;
    }
    int remainingLockFailureCalls = MAX_LOCK_FAILURE_CALLS;
    RefUpdate refUpdate = createRefUpdate(notesBranch, oursCommit, baseCommit);
    for (; ; ) {
        Result result = refUpdate.update();
        if (result == Result.LOCK_FAILURE) {
            if (--remainingLockFailureCalls > 0) {
                try {
                    Thread.sleep(SLEEP_ON_LOCK_FAILURE_MS);
                } catch (InterruptedException e) {
                // ignore
                }
            } else {
                throw new ConcurrentRefUpdateException("Failed to lock the ref: " + notesBranch, refUpdate.getRef(), result);
            }
        } else if (result == Result.REJECTED) {
            RevCommit theirsCommit = revWalk.parseCommit(refUpdate.getOldObjectId());
            NoteMap theirs = NoteMap.read(revWalk.getObjectReader(), theirsCommit);
            NoteMapMerger merger = new NoteMapMerger(db, getNoteMerger(), MergeStrategy.RESOLVE);
            NoteMap merged = merger.merge(base, ours, theirs);
            RevCommit mergeCommit = createCommit(merged, gerritIdent, "Merged note commits\n", theirsCommit, oursCommit);
            refUpdate = createRefUpdate(notesBranch, mergeCommit, theirsCommit);
            remainingLockFailureCalls = MAX_LOCK_FAILURE_CALLS;
        } else if (result == Result.IO_FAILURE) {
            throw new IOException("Couldn't update " + notesBranch + ". " + result.name());
        } else {
            gitRefUpdated.fire(project, refUpdate, (AccountInfo) null);
            break;
        }
    }
}
#end_block

#method_before
public MetaDataUpdate create(Project.NameKey name, Repository repository, IdentifiedUser user, BatchRefUpdate batch) {
    MetaDataUpdate md = factory.create(name, repository, batch);
    md.getCommitBuilder().setAuthor(createPersonIdent(user));
    md.getCommitBuilder().setCommitter(serverIdent);
    return md;
}
#method_after
public MetaDataUpdate create(Project.NameKey name, Repository repository, IdentifiedUser user, BatchRefUpdate batch) {
    MetaDataUpdate md = factory.create(name, repository, batch);
    md.getCommitBuilder().setCommitter(serverIdent);
    md.setAuthor(user);
    return md;
}
#end_block

#method_before
public void setAuthor(IdentifiedUser user) {
    this.user = user;
    getCommitBuilder().setAuthor(user.newCommitterIdent(getCommitBuilder().getCommitter().getWhen(), getCommitBuilder().getCommitter().getTimeZone()));
}
#method_after
public void setAuthor(IdentifiedUser author) {
    this.author = author;
    getCommitBuilder().setAuthor(author.newCommitterIdent(getCommitBuilder().getCommitter().getWhen(), getCommitBuilder().getCommitter().getTimeZone()));
}
#end_block

#method_before
public void close() {
    getRepository().close();
}
#method_after
@Override
public void close() {
    getRepository().close();
}
#end_block

#method_before
void fireGitRefUpdatedEvent(RefUpdate ru) {
    gitRefUpdated.fire(projectName, ru, user.getAccount());
}
#method_after
void fireGitRefUpdatedEvent(RefUpdate ru) {
    gitRefUpdated.fire(projectName, ru, author == null ? null : author.getAccount());
}
#end_block

#method_before
@Override
public Response<ProjectInfo> apply(TopLevelResource resource, ProjectInput input) throws BadRequestException, UnprocessableEntityException, ResourceConflictException, ResourceNotFoundException, IOException, ConfigInvalidException {
    if (input == null) {
        input = new ProjectInput();
    }
    if (input.name != null && !name.equals(input.name)) {
        throw new BadRequestException("name must match URL");
    }
    CreateProjectArgs args = new CreateProjectArgs();
    args.setProjectName(ProjectUtil.stripGitSuffix(name));
    if (!Strings.isNullOrEmpty(input.parent)) {
        args.newParent = projectsCollection.get().parse(input.parent).getControl();
    }
    args.createEmptyCommit = input.createEmptyCommit;
    args.permissionsOnly = input.permissionsOnly;
    args.projectDescription = Strings.emptyToNull(input.description);
    args.submitType = input.submitType;
    args.branch = normalizeBranchNames(input.branches);
    if (input.owners == null || input.owners.isEmpty()) {
        args.ownerIds = new ArrayList<>(projectOwnerGroups.create(args.getProject()).get());
    } else {
        args.ownerIds = Lists.newArrayListWithCapacity(input.owners.size());
        for (String owner : input.owners) {
            args.ownerIds.add(groupsCollection.get().parse(owner).getGroupUUID());
        }
    }
    args.contributorAgreements = MoreObjects.firstNonNull(input.useContributorAgreements, InheritableBoolean.INHERIT);
    args.signedOffBy = MoreObjects.firstNonNull(input.useSignedOffBy, InheritableBoolean.INHERIT);
    args.contentMerge = input.submitType == SubmitType.FAST_FORWARD_ONLY ? InheritableBoolean.FALSE : MoreObjects.firstNonNull(input.useContentMerge, InheritableBoolean.INHERIT);
    args.newChangeForAllNotInTarget = MoreObjects.firstNonNull(input.createNewChangeForAllNotInTarget, InheritableBoolean.INHERIT);
    args.changeIdRequired = MoreObjects.firstNonNull(input.requireChangeId, InheritableBoolean.INHERIT);
    try {
        args.maxObjectSizeLimit = ProjectConfig.validMaxObjectSizeLimit(input.maxObjectSizeLimit);
    } catch (ConfigInvalidException e) {
        throw new BadRequestException(e.getMessage());
    }
    for (ProjectCreationValidationListener l : projectCreationValidationListeners) {
        try {
            l.validateNewProject(args);
        } catch (ValidationException e) {
            throw new ResourceConflictException(e.getMessage(), e);
        }
    }
    Project p = createProject(args);
    if (input.pluginConfigValues != null) {
        try {
            ProjectControl projectControl = projectControlFactory.controlFor(p.getNameKey(), currentUser.get());
            PutConfig.Input in = new PutConfig.Input();
            in.pluginConfigValues = input.pluginConfigValues;
            putConfig.get().apply(projectControl, in);
        } catch (NoSuchProjectException e) {
            throw new ResourceNotFoundException(p.getName());
        }
    }
    return Response.created(json.format(p));
}
#method_after
@Override
public Response<ProjectInfo> apply(TopLevelResource resource, ProjectInput input) throws BadRequestException, UnprocessableEntityException, ResourceConflictException, ResourceNotFoundException, IOException, ConfigInvalidException {
    if (input == null) {
        input = new ProjectInput();
    }
    if (input.name != null && !name.equals(input.name)) {
        throw new BadRequestException("name must match URL");
    }
    CreateProjectArgs args = new CreateProjectArgs();
    args.setProjectName(ProjectUtil.stripGitSuffix(name));
    String parentName = MoreObjects.firstNonNull(Strings.emptyToNull(input.parent), allProjects.get());
    args.newParent = projectsCollection.get().parse(parentName).getControl();
    args.createEmptyCommit = input.createEmptyCommit;
    args.permissionsOnly = input.permissionsOnly;
    args.projectDescription = Strings.emptyToNull(input.description);
    args.submitType = input.submitType;
    args.branch = normalizeBranchNames(input.branches);
    if (input.owners == null || input.owners.isEmpty()) {
        args.ownerIds = new ArrayList<>(projectOwnerGroups.create(args.getProject()).get());
    } else {
        args.ownerIds = Lists.newArrayListWithCapacity(input.owners.size());
        for (String owner : input.owners) {
            args.ownerIds.add(groupsCollection.get().parse(owner).getGroupUUID());
        }
    }
    args.contributorAgreements = MoreObjects.firstNonNull(input.useContributorAgreements, InheritableBoolean.INHERIT);
    args.signedOffBy = MoreObjects.firstNonNull(input.useSignedOffBy, InheritableBoolean.INHERIT);
    args.contentMerge = input.submitType == SubmitType.FAST_FORWARD_ONLY ? InheritableBoolean.FALSE : MoreObjects.firstNonNull(input.useContentMerge, InheritableBoolean.INHERIT);
    args.newChangeForAllNotInTarget = MoreObjects.firstNonNull(input.createNewChangeForAllNotInTarget, InheritableBoolean.INHERIT);
    args.changeIdRequired = MoreObjects.firstNonNull(input.requireChangeId, InheritableBoolean.INHERIT);
    try {
        args.maxObjectSizeLimit = ProjectConfig.validMaxObjectSizeLimit(input.maxObjectSizeLimit);
    } catch (ConfigInvalidException e) {
        throw new BadRequestException(e.getMessage());
    }
    for (ProjectCreationValidationListener l : projectCreationValidationListeners) {
        try {
            l.validateNewProject(args);
        } catch (ValidationException e) {
            throw new ResourceConflictException(e.getMessage(), e);
        }
    }
    Project p = createProject(args);
    if (input.pluginConfigValues != null) {
        try {
            ProjectControl projectControl = projectControlFactory.controlFor(p.getNameKey(), currentUser.get());
            PutConfig.Input in = new PutConfig.Input();
            in.pluginConfigValues = input.pluginConfigValues;
            putConfig.get().apply(projectControl, in);
        } catch (NoSuchProjectException e) {
            throw new ResourceNotFoundException(p.getName());
        }
    }
    return Response.created(json.format(p));
}
#end_block

#method_before
private void createProjectConfig(CreateProjectArgs args) throws IOException, ConfigInvalidException {
    MetaDataUpdate md = metaDataUpdateFactory.create(args.getProject());
    try {
        ProjectConfig config = ProjectConfig.read(md);
        config.load(md);
        Project newProject = config.getProject();
        newProject.setDescription(args.projectDescription);
        newProject.setSubmitType(MoreObjects.firstNonNull(args.submitType, repositoryCfg.getDefaultSubmitType(args.getProject())));
        newProject.setUseContributorAgreements(args.contributorAgreements);
        newProject.setUseSignedOffBy(args.signedOffBy);
        newProject.setUseContentMerge(args.contentMerge);
        newProject.setCreateNewChangeForAllNotInTarget(args.newChangeForAllNotInTarget);
        newProject.setRequireChangeID(args.changeIdRequired);
        newProject.setMaxObjectSizeLimit(args.maxObjectSizeLimit);
        if (args.newParent != null) {
            newProject.setParentName(args.newParent.getProject().getNameKey());
        }
        if (!args.ownerIds.isEmpty()) {
            AccessSection all = config.getAccessSection(AccessSection.ALL, true);
            for (AccountGroup.UUID ownerId : args.ownerIds) {
                GroupDescription.Basic g = groupBackend.get(ownerId);
                if (g != null) {
                    GroupReference group = config.resolve(GroupReference.forGroup(g));
                    all.getPermission(Permission.OWNER, true).add(new PermissionRule(group));
                }
            }
        }
        md.setMessage("Created project\n");
        config.commit(md);
    } finally {
        md.close();
    }
    projectCache.onCreateProject(args.getProject());
    repoManager.setProjectDescription(args.getProject(), args.projectDescription);
}
#method_after
private void createProjectConfig(CreateProjectArgs args) throws IOException, ConfigInvalidException {
    try (MetaDataUpdate md = metaDataUpdateFactory.create(args.getProject())) {
        ProjectConfig config = ProjectConfig.read(md);
        config.load(md);
        Project newProject = config.getProject();
        newProject.setDescription(args.projectDescription);
        newProject.setSubmitType(MoreObjects.firstNonNull(args.submitType, repositoryCfg.getDefaultSubmitType(args.getProject())));
        newProject.setUseContributorAgreements(args.contributorAgreements);
        newProject.setUseSignedOffBy(args.signedOffBy);
        newProject.setUseContentMerge(args.contentMerge);
        newProject.setCreateNewChangeForAllNotInTarget(args.newChangeForAllNotInTarget);
        newProject.setRequireChangeID(args.changeIdRequired);
        newProject.setMaxObjectSizeLimit(args.maxObjectSizeLimit);
        if (args.newParent != null) {
            newProject.setParentName(args.newParent.getProject().getNameKey());
        }
        if (!args.ownerIds.isEmpty()) {
            AccessSection all = config.getAccessSection(AccessSection.ALL, true);
            for (AccountGroup.UUID ownerId : args.ownerIds) {
                GroupDescription.Basic g = groupBackend.get(ownerId);
                if (g != null) {
                    GroupReference group = config.resolve(GroupReference.forGroup(g));
                    all.getPermission(Permission.OWNER, true).add(new PermissionRule(group));
                }
            }
        }
        md.setMessage("Created project\n");
        config.commit(md);
    }
    projectCache.onCreateProject(args.getProject());
    repoManager.setProjectDescription(args.getProject(), args.projectDescription);
}
#end_block

#method_before
private void createEmptyCommits(Repository repo, Project.NameKey project, List<String> refs) throws IOException {
    try (ObjectInserter oi = repo.newObjectInserter()) {
        CommitBuilder cb = new CommitBuilder();
        cb.setTreeId(oi.insert(Constants.OBJ_TREE, new byte[] {}));
        cb.setAuthor(metaDataUpdateFactory.getUserPersonIdent());
        cb.setCommitter(serverIdent);
        cb.setMessage("Initial empty repository\n");
        ObjectId id = oi.insert(cb);
        oi.flush();
        for (String ref : refs) {
            RefUpdate ru = repo.updateRef(ref);
            ru.setNewObjectId(id);
            Result result = ru.update();
            switch(result) {
                case NEW:
                    referenceUpdated.fire(project, ru, ReceiveCommand.Type.CREATE, currentUser.get().getAccountId());
                    break;
                default:
                    {
                        throw new IOException(String.format("Failed to create ref \"%s\": %s", ref, result.name()));
                    }
            }
        }
    } catch (IOException e) {
        log.error("Cannot create empty commit for " + project.get(), e);
        throw e;
    }
}
#method_after
private void createEmptyCommits(Repository repo, Project.NameKey project, List<String> refs) throws IOException {
    try (ObjectInserter oi = repo.newObjectInserter()) {
        CommitBuilder cb = new CommitBuilder();
        cb.setTreeId(oi.insert(Constants.OBJ_TREE, new byte[] {}));
        cb.setAuthor(metaDataUpdateFactory.getUserPersonIdent());
        cb.setCommitter(serverIdent);
        cb.setMessage("Initial empty repository\n");
        ObjectId id = oi.insert(cb);
        oi.flush();
        for (String ref : refs) {
            RefUpdate ru = repo.updateRef(ref);
            ru.setNewObjectId(id);
            Result result = ru.update();
            switch(result) {
                case NEW:
                    referenceUpdated.fire(project, ru, ReceiveCommand.Type.CREATE, currentUser.get().getAccountId());
                    break;
                case FAST_FORWARD:
                case FORCED:
                case IO_FAILURE:
                case LOCK_FAILURE:
                case NOT_ATTEMPTED:
                case NO_CHANGE:
                case REJECTED:
                case REJECTED_CURRENT_BRANCH:
                case RENAMED:
                default:
                    {
                        throw new IOException(String.format("Failed to create ref \"%s\": %s", ref, result.name()));
                    }
            }
        }
    } catch (IOException e) {
        log.error("Cannot create empty commit for " + project.get(), e);
        throw e;
    }
}
#end_block

#method_before
private void appendAndLogErrorMessage(StringBuilder errorMessages, ReceiveCommand cmd) {
    String msg = null;
    switch(cmd.getResult()) {
        case REJECTED_CURRENT_BRANCH:
            msg = format("Cannot delete %s: it is the current branch", cmd.getRefName());
            break;
        case REJECTED_OTHER_REASON:
            msg = format("Cannot delete %s: %s", cmd.getRefName(), cmd.getMessage());
            break;
        default:
            msg = format("Cannot delete %s: %s", cmd.getRefName(), cmd.getResult());
            break;
    }
    log.error(msg);
    errorMessages.append(msg);
    errorMessages.append("\n");
}
#method_after
private void appendAndLogErrorMessage(StringBuilder errorMessages, ReceiveCommand cmd) {
    String msg = null;
    switch(cmd.getResult()) {
        case REJECTED_CURRENT_BRANCH:
            msg = format("Cannot delete %s: it is the current branch", cmd.getRefName());
            break;
        case REJECTED_OTHER_REASON:
            msg = format("Cannot delete %s: %s", cmd.getRefName(), cmd.getMessage());
            break;
        case LOCK_FAILURE:
        case NOT_ATTEMPTED:
        case OK:
        case REJECTED_MISSING_OBJECT:
        case REJECTED_NOCREATE:
        case REJECTED_NODELETE:
        case REJECTED_NONFASTFORWARD:
        default:
            msg = format("Cannot delete %s: %s", cmd.getRefName(), cmd.getResult());
            break;
    }
    log.error(msg);
    errorMessages.append(msg);
    errorMessages.append("\n");
}
#end_block

#method_before
private void postDeletion(ProjectResource project, ReceiveCommand cmd) throws OrmException {
    referenceUpdated.fire(project.getNameKey(), cmd, identifiedUser.get().getAccount());
    Branch.NameKey branchKey = new Branch.NameKey(project.getNameKey(), cmd.getRefName());
    hooks.doRefUpdatedHook(branchKey, cmd.getOldId(), cmd.getNewId(), identifiedUser.get().getAccount());
    ResultSet<SubmoduleSubscription> submoduleSubscriptions = dbProvider.get().submoduleSubscriptions().bySuperProject(branchKey);
    dbProvider.get().submoduleSubscriptions().delete(submoduleSubscriptions);
}
#method_after
private void postDeletion(ProjectResource project, ReceiveCommand cmd) {
    referenceUpdated.fire(project.getNameKey(), cmd, identifiedUser.get().getAccount());
    Branch.NameKey branchKey = new Branch.NameKey(project.getNameKey(), cmd.getRefName());
    hooks.doRefUpdatedHook(branchKey, cmd.getOldId(), cmd.getNewId(), identifiedUser.get().getAccount());
}
#end_block

#method_before
@Override
public Response<?> apply(BranchResource rsrc, Input input) throws AuthException, ResourceConflictException, OrmException, IOException {
    if (!rsrc.getControl().controlForRef(rsrc.getBranchKey()).canDelete()) {
        throw new AuthException("Cannot delete branch");
    }
    if (!queryProvider.get().setLimit(1).byBranchOpen(rsrc.getBranchKey()).isEmpty()) {
        throw new ResourceConflictException("branch " + rsrc.getBranchKey() + " has open changes");
    }
    try (Repository r = repoManager.openRepository(rsrc.getNameKey())) {
        RefUpdate.Result result;
        RefUpdate u = r.updateRef(rsrc.getRef());
        u.setForceUpdate(true);
        int remainingLockFailureCalls = MAX_LOCK_FAILURE_CALLS;
        for (; ; ) {
            try {
                result = u.delete();
            } catch (LockFailedException e) {
                result = RefUpdate.Result.LOCK_FAILURE;
            } catch (IOException e) {
                log.error("Cannot delete " + rsrc.getBranchKey(), e);
                throw e;
            }
            if (result == RefUpdate.Result.LOCK_FAILURE && --remainingLockFailureCalls > 0) {
                try {
                    Thread.sleep(SLEEP_ON_LOCK_FAILURE_MS);
                } catch (InterruptedException ie) {
                // ignore
                }
            } else {
                break;
            }
        }
        switch(result) {
            case NEW:
            case NO_CHANGE:
            case FAST_FORWARD:
            case FORCED:
                referenceUpdated.fire(rsrc.getNameKey(), u, ReceiveCommand.Type.DELETE, identifiedUser.get().getAccount());
                hooks.doRefUpdatedHook(rsrc.getBranchKey(), u, identifiedUser.get().getAccount());
                ResultSet<SubmoduleSubscription> submoduleSubscriptions = dbProvider.get().submoduleSubscriptions().bySuperProject(rsrc.getBranchKey());
                dbProvider.get().submoduleSubscriptions().delete(submoduleSubscriptions);
                break;
            case REJECTED_CURRENT_BRANCH:
                log.error("Cannot delete " + rsrc.getBranchKey() + ": " + result.name());
                throw new ResourceConflictException("cannot delete current branch");
            default:
                log.error("Cannot delete " + rsrc.getBranchKey() + ": " + result.name());
                throw new ResourceConflictException("cannot delete branch: " + result.name());
        }
    }
    return Response.none();
}
#method_after
@Override
public Response<?> apply(BranchResource rsrc, Input input) throws AuthException, ResourceConflictException, OrmException, IOException {
    if (!rsrc.getControl().controlForRef(rsrc.getBranchKey()).canDelete()) {
        throw new AuthException("Cannot delete branch");
    }
    if (!queryProvider.get().setLimit(1).byBranchOpen(rsrc.getBranchKey()).isEmpty()) {
        throw new ResourceConflictException("branch " + rsrc.getBranchKey() + " has open changes");
    }
    try (Repository r = repoManager.openRepository(rsrc.getNameKey())) {
        RefUpdate.Result result;
        RefUpdate u = r.updateRef(rsrc.getRef());
        u.setForceUpdate(true);
        int remainingLockFailureCalls = MAX_LOCK_FAILURE_CALLS;
        for (; ; ) {
            try {
                result = u.delete();
            } catch (LockFailedException e) {
                result = RefUpdate.Result.LOCK_FAILURE;
            } catch (IOException e) {
                log.error("Cannot delete " + rsrc.getBranchKey(), e);
                throw e;
            }
            if (result == RefUpdate.Result.LOCK_FAILURE && --remainingLockFailureCalls > 0) {
                try {
                    Thread.sleep(SLEEP_ON_LOCK_FAILURE_MS);
                } catch (InterruptedException ie) {
                // ignore
                }
            } else {
                break;
            }
        }
        switch(result) {
            case NEW:
            case NO_CHANGE:
            case FAST_FORWARD:
            case FORCED:
                referenceUpdated.fire(rsrc.getNameKey(), u, ReceiveCommand.Type.DELETE, identifiedUser.get().getAccount());
                hooks.doRefUpdatedHook(rsrc.getBranchKey(), u, identifiedUser.get().getAccount());
                break;
            case REJECTED_CURRENT_BRANCH:
                log.error("Cannot delete " + rsrc.getBranchKey() + ": " + result.name());
                throw new ResourceConflictException("cannot delete current branch");
            case IO_FAILURE:
            case LOCK_FAILURE:
            case NOT_ATTEMPTED:
            case REJECTED:
            case RENAMED:
            default:
                log.error("Cannot delete " + rsrc.getBranchKey() + ": " + result.name());
                throw new ResourceConflictException("cannot delete branch: " + result.name());
        }
    }
    return Response.none();
}
#end_block

#method_before
@Test
public void testPushForMasterWithMessage() throws Exception {
    PushOneCommit.Result r = pushTo("refs/for/master/%m=my_test_message");
    r.assertOkStatus();
    r.assertChange(Change.Status.NEW, null);
    ChangeInfo ci = get(r.getChangeId());
    Collection<ChangeMessageInfo> changeMessages = ci.messages;
    assertThat(changeMessages).hasSize(1);
    for (ChangeMessageInfo cm : changeMessages) {
        assertThat(cm.message).isEqualTo("Uploaded patch set 1.: my test message");
    }
}
#method_after
@Test
public void testPushForMasterWithMessage() throws Exception {
    PushOneCommit.Result r = pushTo("refs/for/master/%m=my_test_message");
    r.assertOkStatus();
    r.assertChange(Change.Status.NEW, null);
    ChangeInfo ci = get(r.getChangeId());
    Collection<ChangeMessageInfo> changeMessages = ci.messages;
    assertThat(changeMessages).hasSize(1);
    for (ChangeMessageInfo cm : changeMessages) {
        assertThat(cm.message).isEqualTo("Uploaded patch set 1.\nmy test message");
    }
}
#end_block

#method_before
private void insertChange(RequestState state) throws OrmException, IOException, RestApiException, UpdateException, NoSuchChangeException {
    RevCommit commit = state.rw.parseCommit(commitId);
    state.rw.parseBody(commit);
    final PatchSet.Id psId = ins.setGroups(groups).getPatchSetId();
    final Account.Id me = user.getAccountId();
    final List<FooterLine> footerLines = commit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    Map<String, Short> approvals = new HashMap<>();
    checkNotNull(magicBranch);
    recipients.add(magicBranch.getMailRecipients());
    approvals = magicBranch.labels;
    recipients.add(getRecipientsFromFooters(accountResolver, magicBranch.draft, footerLines));
    recipients.remove(me);
    String msg = renderMessageWithApprovals(psId.get(), approvals, Collections.<String, PatchSetApproval>emptyMap());
    if (!Strings.isNullOrEmpty(magicBranch.message)) {
        msg = msg + ": " + magicBranch.message;
    }
    try (BatchUpdate bu = batchUpdateFactory.create(state.db, magicBranch.dest.getParentKey(), user, TimeUtil.nowTs())) {
        bu.setRepository(state.repo, state.rw, state.ins);
        bu.insertChange(ins.setReviewers(recipients.getReviewers()).setExtraCC(recipients.getCcOnly()).setApprovals(approvals).setMessage(msg).setNotify(magicBranch.notify).setRequestScopePropagator(requestScopePropagator).setSendMail(true).setUpdateRef(true));
        bu.addOp(changeId, hashtagsFactory.create(new HashtagsInput(magicBranch.hashtags)).setRunHooks(false));
        if (!Strings.isNullOrEmpty(magicBranch.topic)) {
            bu.addOp(changeId, new BatchUpdate.Op() {

                @Override
                public boolean updateChange(ChangeContext ctx) {
                    ctx.getUpdate(psId).setTopic(magicBranch.topic);
                    return true;
                }
            });
        }
        bu.execute();
    }
    change = ins.getChange();
    if (magicBranch.submit) {
        submit(projectControl.controlFor(state.db, change), ins.getPatchSet());
    }
}
#method_after
private void insertChange(RequestState state) throws OrmException, IOException, RestApiException, UpdateException, NoSuchChangeException {
    RevCommit commit = state.rw.parseCommit(commitId);
    state.rw.parseBody(commit);
    final PatchSet.Id psId = ins.setGroups(groups).getPatchSetId();
    final Account.Id me = user.getAccountId();
    final List<FooterLine> footerLines = commit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    Map<String, Short> approvals = new HashMap<>();
    checkNotNull(magicBranch);
    recipients.add(magicBranch.getMailRecipients());
    approvals = magicBranch.labels;
    recipients.add(getRecipientsFromFooters(accountResolver, magicBranch.draft, footerLines));
    recipients.remove(me);
    StringBuilder msg = new StringBuilder(ApprovalsUtil.renderMessageWithApprovals(psId.get(), approvals, Collections.<String, PatchSetApproval>emptyMap()));
    if (!Strings.isNullOrEmpty(magicBranch.message)) {
        msg.append("\n").append(magicBranch.message);
    }
    try (BatchUpdate bu = batchUpdateFactory.create(state.db, magicBranch.dest.getParentKey(), user, TimeUtil.nowTs())) {
        bu.setRepository(state.repo, state.rw, state.ins);
        bu.insertChange(ins.setReviewers(recipients.getReviewers()).setExtraCC(recipients.getCcOnly()).setApprovals(approvals).setMessage(msg.toString()).setNotify(magicBranch.notify).setRequestScopePropagator(requestScopePropagator).setSendMail(true).setUpdateRef(true));
        bu.addOp(changeId, hashtagsFactory.create(new HashtagsInput(magicBranch.hashtags)).setRunHooks(false));
        if (!Strings.isNullOrEmpty(magicBranch.topic)) {
            bu.addOp(changeId, new BatchUpdate.Op() {

                @Override
                public boolean updateChange(ChangeContext ctx) {
                    ctx.getUpdate(psId).setTopic(magicBranch.topic);
                    return true;
                }
            });
        }
        bu.execute();
    }
    change = ins.getChange();
    if (magicBranch.submit) {
        submit(projectControl.controlFor(state.db, change), ins.getPatchSet());
    }
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, IOException {
    change = ctx.getChange();
    if (change == null || change.getStatus().isClosed()) {
        rejectMessage = CHANGE_IS_CLOSED;
        return false;
    }
    if (groups.isEmpty()) {
        PatchSet prevPs = psUtil.current(ctx.getDb(), ctx.getNotes());
        groups = prevPs != null ? prevPs.getGroups() : ImmutableList.<String>of();
    }
    ChangeUpdate update = ctx.getUpdate(patchSetId);
    update.setSubjectForCommit("Create patch set " + patchSetId.get());
    String branchMessage = null;
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        branchMessage = magicBranch.message;
        approvals.putAll(magicBranch.labels);
        Set<String> hashtags = magicBranch.hashtags;
        if (hashtags != null && !hashtags.isEmpty()) {
            hashtags.addAll(ctx.getNotes().getHashtags());
            update.setHashtags(hashtags);
        }
        if (magicBranch.topic != null && !magicBranch.topic.equals(ctx.getChange().getTopic())) {
            update.setTopic(magicBranch.topic);
        }
    }
    boolean draft = magicBranch != null && magicBranch.draft;
    newPatchSet = psUtil.insert(ctx.getDb(), ctx.getRevWalk(), update, patchSetId, commit, draft, groups, pushCertificate != null ? pushCertificate.toTextWithSignature() : null);
    if (checkMergedInto) {
        Ref mergedInto = findMergedInto(ctx, change.getDest().get(), commit);
        mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
    }
    recipients.add(getRecipientsFromFooters(accountResolver, draft, commit.getFooterLines()));
    recipients.remove(ctx.getUser().getAccountId());
    ChangeData cd = changeDataFactory.create(ctx.getDb(), ctx.getControl());
    MailRecipients oldRecipients = getRecipientsFromReviewers(cd.reviewers());
    approvalCopier.copy(ctx.getDb(), ctx.getControl(), newPatchSet);
    approvalsUtil.addReviewers(ctx.getDb(), update, projectControl.getLabelTypes(), change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
    approvalsUtil.addApprovals(ctx.getDb(), update, projectControl.getLabelTypes(), newPatchSet, ctx.getControl(), approvals);
    recipients.add(oldRecipients);
    String approvalMessage = renderMessageWithApprovals(patchSetId.get(), approvals, scanLabels(ctx, approvals));
    String message = approvalMessage;
    String kindMessage = changeKindMessage(changeKind);
    if (!Strings.isNullOrEmpty(kindMessage)) {
        message = message + kindMessage;
    }
    if (!Strings.isNullOrEmpty(branchMessage)) {
        message = message + ": " + branchMessage;
    }
    msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(ctx.getDb())), ctx.getUser().getAccountId(), ctx.getWhen(), patchSetId);
    msg.setMessage(message);
    cmUtil.addChangeMessage(ctx.getDb(), update, msg);
    if (mergedIntoRef == null) {
        resetChange(ctx, msg);
    }
    ctx.saveChange();
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, IOException {
    change = ctx.getChange();
    if (change == null || change.getStatus().isClosed()) {
        rejectMessage = CHANGE_IS_CLOSED;
        return false;
    }
    if (groups.isEmpty()) {
        PatchSet prevPs = psUtil.current(ctx.getDb(), ctx.getNotes());
        groups = prevPs != null ? prevPs.getGroups() : ImmutableList.<String>of();
    }
    ChangeUpdate update = ctx.getUpdate(patchSetId);
    update.setSubjectForCommit("Create patch set " + patchSetId.get());
    String reviewMessage = null;
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        reviewMessage = magicBranch.message;
        approvals.putAll(magicBranch.labels);
        Set<String> hashtags = magicBranch.hashtags;
        if (hashtags != null && !hashtags.isEmpty()) {
            hashtags.addAll(ctx.getNotes().getHashtags());
            update.setHashtags(hashtags);
        }
        if (magicBranch.topic != null && !magicBranch.topic.equals(ctx.getChange().getTopic())) {
            update.setTopic(magicBranch.topic);
        }
    }
    boolean draft = magicBranch != null && magicBranch.draft;
    newPatchSet = psUtil.insert(ctx.getDb(), ctx.getRevWalk(), update, patchSetId, commit, draft, groups, pushCertificate != null ? pushCertificate.toTextWithSignature() : null);
    if (checkMergedInto) {
        Ref mergedInto = findMergedInto(ctx, change.getDest().get(), commit);
        mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
    }
    recipients.add(getRecipientsFromFooters(accountResolver, draft, commit.getFooterLines()));
    recipients.remove(ctx.getUser().getAccountId());
    ChangeData cd = changeDataFactory.create(ctx.getDb(), ctx.getControl());
    MailRecipients oldRecipients = getRecipientsFromReviewers(cd.reviewers());
    approvalCopier.copy(ctx.getDb(), ctx.getControl(), newPatchSet);
    approvalsUtil.addReviewers(ctx.getDb(), update, projectControl.getLabelTypes(), change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
    approvalsUtil.addApprovals(ctx.getDb(), update, projectControl.getLabelTypes(), newPatchSet, ctx.getControl(), approvals);
    recipients.add(oldRecipients);
    String approvalMessage = ApprovalsUtil.renderMessageWithApprovals(patchSetId.get(), approvals, scanLabels(ctx, approvals));
    StringBuilder message = new StringBuilder(approvalMessage);
    String kindMessage = changeKindMessage(changeKind);
    if (!Strings.isNullOrEmpty(kindMessage)) {
        message.append(kindMessage);
    }
    if (!Strings.isNullOrEmpty(reviewMessage)) {
        message.append("\n").append(reviewMessage);
    }
    msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(ctx.getDb())), ctx.getUser().getAccountId(), ctx.getWhen(), patchSetId);
    msg.setMessage(message.toString());
    cmUtil.addChangeMessage(ctx.getDb(), update, msg);
    if (mergedIntoRef == null) {
        resetChange(ctx, msg);
    }
    ctx.saveChange();
    return true;
}
#end_block

#method_before
@Override
void clearLine(DisplaySide side, int line, CommentGroup group) {
    SortedMap<Integer, SideBySideCommentGroup> map = map(side);
    if (map.get(line) == group) {
        map.remove(line);
    }
}
#method_after
@Override
void clearLine(DisplaySide side, int line, CommentGroup group) {
    super.clearLine(side, line, group);
}
#end_block

#method_before
@Override
void newDraftOnGutterClick(CodeMirror cm, String gutterClass, int line) {
    insertNewDraft(cm.side(), line);
}
#method_after
@Override
void newDraftOnGutterClick(CodeMirror cm, String gutterClass, int line) {
    if (!Gerrit.isSignedIn()) {
        signInCallback(cm).run();
    } else {
        insertNewDraft(cm.side(), line);
    }
}
#end_block

#method_before
private void newDraft(CodeMirror cm) {
    int line = cm.getLineNumber(cm.extras().activeLine()) + 1;
    if (cm.somethingSelected()) {
        FromTo fromTo = adjustSelection(cm);
        addDraftBox(cm.side(), CommentInfo.create(getPath(), getStoredSideFromDisplaySide(cm.side()), line, CommentRange.create(fromTo))).setEdit(true);
        cm.setCursor(fromTo.to());
        cm.setSelection(cm.getCursor());
    } else {
        insertNewDraft(cm.side(), line);
    }
}
#method_after
@Override
void newDraft(CodeMirror cm) {
    int line = cm.getLineNumber(cm.extras().activeLine()) + 1;
    if (cm.somethingSelected()) {
        FromTo fromTo = adjustSelection(cm);
        addDraftBox(cm.side(), CommentInfo.create(getPath(), getStoredSideFromDisplaySide(cm.side()), line, CommentRange.create(fromTo))).setEdit(true);
        cm.setCursor(fromTo.to());
        cm.setSelection(cm.getCursor());
    } else {
        insertNewDraft(cm.side(), line);
    }
}
#end_block

#method_before
private SideBySideCommentGroup group(DisplaySide side, int line) {
    SideBySideCommentGroup existing = map(side).get(line);
    if (existing != null) {
        return existing;
    }
    SideBySideCommentGroup newGroup = newGroup(side, line);
    Map<Integer, SideBySideCommentGroup> map = side == DisplaySide.A ? sideA : sideB;
    Map<Integer, SideBySideCommentGroup> otherMap = side == DisplaySide.A ? sideB : sideA;
    map.put(line, newGroup);
    int otherLine = host.lineOnOther(side, line - 1).getLine() + 1;
    existing = map(side.otherSide()).get(otherLine);
    SideBySideCommentGroup otherGroup;
    if (existing != null) {
        otherGroup = existing;
    } else {
        otherGroup = newGroup(side.otherSide(), otherLine);
        otherMap.put(otherLine, otherGroup);
    }
    SideBySideCommentGroup.pair(newGroup, otherGroup);
    if (isAttached()) {
        newGroup.init(host.getDiffTable());
        otherGroup.handleRedraw();
    }
    return newGroup;
}
#method_after
@Override
CommentGroup group(DisplaySide side, int line) {
    CommentGroup existing = map(side).get(line);
    if (existing != null) {
        return existing;
    }
    SideBySideCommentGroup newGroup = newGroup(side, line);
    Map<Integer, CommentGroup> map = side == DisplaySide.A ? sideA : sideB;
    Map<Integer, CommentGroup> otherMap = side == DisplaySide.A ? sideB : sideA;
    map.put(line, newGroup);
    int otherLine = host.lineOnOther(side, line - 1).getLine() + 1;
    existing = map(side.otherSide()).get(otherLine);
    CommentGroup otherGroup;
    if (existing != null) {
        otherGroup = existing;
    } else {
        otherGroup = newGroup(side.otherSide(), otherLine);
        otherMap.put(otherLine, otherGroup);
    }
    SideBySideCommentGroup.pair(newGroup, (SideBySideCommentGroup) otherGroup);
    if (isAttached()) {
        newGroup.init(host.getDiffTable());
        otherGroup.handleRedraw();
    }
    return newGroup;
}
#end_block

#method_before
protected TestRepository<?> createProjectWithPush(String name, Project.NameKey parent) throws Exception {
    Project.NameKey project = createProject(name, parent);
    grant(Permission.PUSH, project, "refs/heads/*");
    grant(Permission.SUBMIT, project, "refs/for/refs/heads/*");
    return cloneProject(project);
}
#method_after
protected TestRepository<?> createProjectWithPush(String name, @Nullable Project.NameKey parent) throws Exception {
    Project.NameKey project = createProject(name, parent);
    grant(Permission.PUSH, project, "refs/heads/*");
    grant(Permission.SUBMIT, project, "refs/for/refs/heads/*");
    return cloneProject(project);
}
#end_block

#method_before
@Test
public void testCircularSubscriptionIsDetected() throws Exception {
    TestRepository<?> superRepo = createProjectWithPush("super-project");
    TestRepository<?> subRepo = createProjectWithPush("subscribed-to-project");
    allowSubmoduleSubscription("subscribed-to-project", "refs/heads/master", "super-project", "refs/heads/master");
    allowSubmoduleSubscription("super-project", "refs/heads/master", "subscribed-to-project", "refs/heads/master");
    pushChangeTo(subRepo, "master");
    createSubmoduleSubscription(superRepo, "master", "subscribed-to-project", "master");
    createSubmoduleSubscription(subRepo, "master", "super-project", "master");
    ObjectId subHEAD = pushChangeTo(subRepo, "master");
    pushChangeTo(superRepo, "master");
    expectToHaveSubmoduleState(superRepo, "master", "subscribed-to-project", subHEAD);
    assertThat(hasSubmodule(subRepo, "master", "super-project")).isFalse();
}
#method_after
@Test
public void testCircularSubscriptionIsDetected() throws Exception {
    TestRepository<?> superRepo = createProjectWithPush("super-project");
    TestRepository<?> subRepo = createProjectWithPush("subscribed-to-project");
    allowSubmoduleSubscription("subscribed-to-project", "refs/heads/master", "super-project", "refs/heads/master");
    allowSubmoduleSubscription("super-project", "refs/heads/master", "subscribed-to-project", "refs/heads/master");
    pushChangeTo(subRepo, "master");
    pushChangeTo(superRepo, "master");
    createSubmoduleSubscription(superRepo, "master", "subscribed-to-project", "master");
    createSubmoduleSubscription(subRepo, "master", "super-project", "master");
    pushChangeTo(subRepo, "master");
    pushChangeTo(superRepo, "master");
    assertThat(hasSubmodule(subRepo, "master", "super-project")).isFalse();
    assertThat(hasSubmodule(superRepo, "master", "subscribed-to-project")).isFalse();
}
#end_block

#method_before
public Collection<SubmoduleSubscription> superProjectSubscriptionsForSubmoduleBranch(Branch.NameKey branch, MergeOpRepoManager orm) throws IOException {
    logDebug("Calculating possible superprojects for " + branch);
    Collection<SubmoduleSubscription> ret = new ArrayList<>();
    Project.NameKey project = branch.getParentKey();
    ProjectConfig cfg = projectCache.get(project).getConfig();
    ProjectState state = projectStateFactory.create(cfg);
    for (SubscribeSection s : state.getInheritedSubscribeSections(branch)) {
        Collection<Branch.NameKey> branches = getDestinationBranches(branch, s, orm);
        for (Branch.NameKey targetBranch : branches) {
            GitModules m = gitmodulesFactory.create(targetBranch, updateId, orm);
            m.load();
            ret.addAll(m.subscribedTo(branch));
        }
    }
    logDebug("Calculated superprojects for " + branch + " are " + ret);
    return ret;
}
#method_after
public Collection<SubmoduleSubscription> superProjectSubscriptionsForSubmoduleBranch(Branch.NameKey branch, MergeOpRepoManager orm) throws IOException {
    logDebug("Calculating possible superprojects for " + branch);
    Collection<SubmoduleSubscription> ret = new ArrayList<>();
    Project.NameKey project = branch.getParentKey();
    ProjectConfig cfg = projectCache.get(project).getConfig();
    for (SubscribeSection s : projectStateFactory.create(cfg).getSubscribeSections(branch)) {
        Collection<Branch.NameKey> branches = getDestinationBranches(branch, s, orm);
        for (Branch.NameKey targetBranch : branches) {
            GitModules m = gitmodulesFactory.create(targetBranch, updateId, orm);
            m.load();
            ret.addAll(m.subscribedTo(branch));
        }
    }
    logDebug("Calculated superprojects for " + branch + " are " + ret);
    return ret;
}
#end_block

#method_before
protected void updateSuperProjects(ReviewDb db, Collection<Branch.NameKey> updatedBranches, String updateId, MergeOpRepoManager orm) throws SubmoduleException {
    if (!enableSuperProjectSubscriptions) {
        logDebug("Updating superprojects disabled");
        return;
    }
    this.updateId = updateId;
    logDebug("Updating superprojects");
    // These (repo/branch) will be updated later with all the given
    // individual submodule subscriptions
    Multimap<Branch.NameKey, SubmoduleSubscription> targets = HashMultimap.create();
    try {
        for (Branch.NameKey updatedBranch : updatedBranches) {
            for (SubmoduleSubscription sub : superProjectSubscriptionsForSubmoduleBranch(updatedBranch, orm)) {
                targets.put(sub.getSuperProject(), sub);
            }
        }
    } catch (IOException e) {
        throw new SubmoduleException("Could not calculate all superprojects");
    }
    updatedSubscribers.addAll(updatedBranches);
    // Update subscribers.
    for (Branch.NameKey dest : targets.keySet()) {
        try {
            if (!updatedSubscribers.add(dest)) {
                log.error("Possible circular subscription involving " + dest);
            } else {
                updateGitlinks(db, dest, targets.get(dest), orm);
            }
        } catch (SubmoduleException e) {
            log.warn("Cannot update gitlinks for " + dest, e);
        }
    }
}
#method_after
protected void updateSuperProjects(ReviewDb db, Collection<Branch.NameKey> updatedBranches, String updateId, MergeOpRepoManager orm) throws SubmoduleException {
    if (!enableSuperProjectSubscriptions) {
        logDebug("Updating superprojects disabled");
        return;
    }
    this.updateId = updateId;
    logDebug("Updating superprojects");
    Multimap<Branch.NameKey, SubmoduleSubscription> targets = HashMultimap.create();
    for (Branch.NameKey updatedBranch : updatedBranches) {
        logDebug("Now processing " + updatedBranch);
        Set<Branch.NameKey> checkedTargets = new HashSet<>();
        Set<Branch.NameKey> targetsToProcess = new HashSet<>();
        targetsToProcess.add(updatedBranch);
        while (!targetsToProcess.isEmpty()) {
            Set<Branch.NameKey> newTargets = new HashSet<>();
            for (Branch.NameKey b : targetsToProcess) {
                try {
                    Collection<SubmoduleSubscription> subs = superProjectSubscriptionsForSubmoduleBranch(b, orm);
                    for (SubmoduleSubscription sub : subs) {
                        Branch.NameKey dst = sub.getSuperProject();
                        targets.put(dst, sub);
                        newTargets.add(dst);
                    }
                } catch (IOException e) {
                    throw new SubmoduleException("Cannot find superprojects for " + b, e);
                }
            }
            logDebug("adding to done " + targetsToProcess);
            checkedTargets.addAll(targetsToProcess);
            logDebug("completely done with " + checkedTargets);
            Set<Branch.NameKey> intersection = new HashSet<>(checkedTargets);
            intersection.retainAll(newTargets);
            if (!intersection.isEmpty()) {
                throw new SubmoduleException("Possible circular subscription involving " + updatedBranch);
            }
            targetsToProcess = newTargets;
        }
    }
    for (Branch.NameKey dst : targets.keySet()) {
        try {
            updateGitlinks(dst, targets.get(dst), orm);
        } catch (SubmoduleException e) {
            throw new SubmoduleException("Cannot update gitlinks for " + dst, e);
        }
    }
}
#end_block

#method_before
private void updateGitlinks(ReviewDb db, Branch.NameKey subscriber, Collection<SubmoduleSubscription> updates, MergeOpRepoManager orm) throws SubmoduleException {
    PersonIdent author = null;
    StringBuilder msgbuf = new StringBuilder("Update git submodules\n\n");
    boolean sameAuthorForAll = true;
    try {
        orm.openRepo(subscriber.getParentKey(), false);
    } catch (NoSuchProjectException | IOException e) {
        throw new SubmoduleException("Cannot access superproject", e);
    }
    OpenRepo or = orm.getRepo(subscriber.getParentKey());
    try {
        Ref r = or.repo.exactRef(subscriber.get());
        if (r == null) {
            throw new SubmoduleException("The branch was probably deleted from the subscriber repository");
        }
        DirCache dc = readTree(r, or.rw);
        DirCacheEditor ed = dc.editor();
        for (SubmoduleSubscription s : updates) {
            try {
                orm.openRepo(s.getSubmodule().getParentKey(), false);
            } catch (NoSuchProjectException | IOException e) {
                throw new SubmoduleException("Cannot access submodule", e);
            }
            OpenRepo subOr = orm.getRepo(s.getSubmodule().getParentKey());
            Repository subrepo = subOr.repo;
            Ref ref = subrepo.getRefDatabase().exactRef(s.getSubmodule().get());
            if (ref == null) {
                ed.add(new DeletePath(s.getPath()));
                continue;
            }
            final ObjectId updateTo = ref.getObjectId();
            RevCommit newCommit = subOr.rw.parseCommit(updateTo);
            subOr.rw.parseBody(newCommit);
            if (author == null) {
                author = newCommit.getAuthorIdent();
            } else if (!author.equals(newCommit.getAuthorIdent())) {
                sameAuthorForAll = false;
            }
            DirCacheEntry dce = dc.getEntry(s.getPath());
            ObjectId oldId;
            if (dce != null) {
                if (!dce.getFileMode().equals(FileMode.GITLINK)) {
                    log.error("Requested to update gitlink " + s.getPath() + " in " + s.getSubmodule().getParentKey().get() + " but entry " + "doesn't have gitlink file mode.");
                    continue;
                }
                oldId = dce.getObjectId();
            } else {
                // This submodule did not exist before. We do not want to add
                // the full submodule history to the commit message, so omit it.
                oldId = updateTo;
            }
            ed.add(new PathEdit(s.getPath()) {

                @Override
                public void apply(DirCacheEntry ent) {
                    ent.setFileMode(FileMode.GITLINK);
                    ent.setObjectId(updateTo);
                }
            });
            if (verboseSuperProject) {
                msgbuf.append("Project: " + s.getSubmodule().getParentKey().get());
                msgbuf.append(" " + s.getSubmodule().getShortName());
                msgbuf.append(" " + updateTo.getName());
                msgbuf.append("\n\n");
                try {
                    subOr.rw.markStart(newCommit);
                    subOr.rw.markUninteresting(subOr.rw.parseCommit(oldId));
                    for (RevCommit c : subOr.rw) {
                        subOr.rw.parseBody(c);
                        msgbuf.append(c.getFullMessage() + "\n\n");
                    }
                } catch (IOException e) {
                    throw new SubmoduleException("Could not perform a revwalk to " + "create superproject commit message", e);
                }
            }
        }
        ed.finish();
        if (!sameAuthorForAll || author == null) {
            author = myIdent;
        }
        ObjectInserter oi = or.repo.newObjectInserter();
        ObjectId tree = dc.writeTree(oi);
        ObjectId currentCommitId = or.repo.exactRef(subscriber.get()).getObjectId();
        CommitBuilder commit = new CommitBuilder();
        commit.setTreeId(tree);
        commit.setParentIds(new ObjectId[] { currentCommitId });
        commit.setAuthor(author);
        commit.setCommitter(myIdent);
        commit.setMessage(msgbuf.toString());
        oi.insert(commit);
        oi.flush();
        ObjectId commitId = oi.idFor(Constants.OBJ_COMMIT, commit.build());
        final RefUpdate rfu = or.repo.updateRef(subscriber.get());
        rfu.setForceUpdate(false);
        rfu.setNewObjectId(commitId);
        rfu.setExpectedOldObjectId(currentCommitId);
        rfu.setRefLogMessage("Submit to " + subscriber.getParentKey().get(), true);
        switch(rfu.update()) {
            case NEW:
            case FAST_FORWARD:
                gitRefUpdated.fire(subscriber.getParentKey(), rfu);
                changeHooks.doRefUpdatedHook(subscriber, rfu, account);
                // sent to inform users about the updated branch
                break;
            case FORCED:
            case IO_FAILURE:
            case LOCK_FAILURE:
            case NOT_ATTEMPTED:
            case NO_CHANGE:
            case REJECTED:
            case REJECTED_CURRENT_BRANCH:
            case RENAMED:
            default:
                throw new IOException(rfu.getResult().name());
        }
        // Recursive call: update subscribers of the subscriber
        updateSuperProjects(db, Sets.newHashSet(subscriber), updateId, orm);
    } catch (IOException e) {
        throw new SubmoduleException("Cannot update gitlinks for " + subscriber.get(), e);
    }
}
#method_after
private void updateGitlinks(Branch.NameKey subscriber, Collection<SubmoduleSubscription> updates, MergeOpRepoManager orm) throws SubmoduleException {
    PersonIdent author = null;
    StringBuilder msgbuf = new StringBuilder("Update git submodules\n\n");
    boolean sameAuthorForAll = true;
    try {
        orm.openRepo(subscriber.getParentKey(), false);
    } catch (NoSuchProjectException | IOException e) {
        throw new SubmoduleException("Cannot access superproject", e);
    }
    OpenRepo or = orm.getRepo(subscriber.getParentKey());
    try {
        Ref r = or.repo.exactRef(subscriber.get());
        if (r == null) {
            throw new SubmoduleException("The branch was probably deleted from the subscriber repository");
        }
        DirCache dc = readTree(r, or.rw);
        DirCacheEditor ed = dc.editor();
        for (SubmoduleSubscription s : updates) {
            try {
                orm.openRepo(s.getSubmodule().getParentKey(), false);
            } catch (NoSuchProjectException | IOException e) {
                throw new SubmoduleException("Cannot access submodule", e);
            }
            OpenRepo subOr = orm.getRepo(s.getSubmodule().getParentKey());
            Repository subrepo = subOr.repo;
            Ref ref = subrepo.getRefDatabase().exactRef(s.getSubmodule().get());
            if (ref == null) {
                ed.add(new DeletePath(s.getPath()));
                continue;
            }
            final ObjectId updateTo = ref.getObjectId();
            RevCommit newCommit = subOr.rw.parseCommit(updateTo);
            subOr.rw.parseBody(newCommit);
            if (author == null) {
                author = newCommit.getAuthorIdent();
            } else if (!author.equals(newCommit.getAuthorIdent())) {
                sameAuthorForAll = false;
            }
            DirCacheEntry dce = dc.getEntry(s.getPath());
            ObjectId oldId;
            if (dce != null) {
                if (!dce.getFileMode().equals(FileMode.GITLINK)) {
                    log.error("Requested to update gitlink " + s.getPath() + " in " + s.getSubmodule().getParentKey().get() + " but entry " + "doesn't have gitlink file mode.");
                    continue;
                }
                oldId = dce.getObjectId();
            } else {
                // This submodule did not exist before. We do not want to add
                // the full submodule history to the commit message, so omit it.
                oldId = updateTo;
            }
            ed.add(new PathEdit(s.getPath()) {

                @Override
                public void apply(DirCacheEntry ent) {
                    ent.setFileMode(FileMode.GITLINK);
                    ent.setObjectId(updateTo);
                }
            });
            if (verboseSuperProject) {
                msgbuf.append("Project: " + s.getSubmodule().getParentKey().get());
                msgbuf.append(" " + s.getSubmodule().getShortName());
                msgbuf.append(" " + updateTo.getName());
                msgbuf.append("\n\n");
                try {
                    subOr.rw.markStart(newCommit);
                    subOr.rw.markUninteresting(subOr.rw.parseCommit(oldId));
                    for (RevCommit c : subOr.rw) {
                        subOr.rw.parseBody(c);
                        msgbuf.append(c.getFullMessage() + "\n\n");
                    }
                } catch (IOException e) {
                    throw new SubmoduleException("Could not perform a revwalk to " + "create superproject commit message", e);
                }
            }
        }
        ed.finish();
        if (!sameAuthorForAll || author == null) {
            author = myIdent;
        }
        ObjectInserter oi = or.repo.newObjectInserter();
        ObjectId tree = dc.writeTree(oi);
        ObjectId currentCommitId = or.repo.exactRef(subscriber.get()).getObjectId();
        CommitBuilder commit = new CommitBuilder();
        commit.setTreeId(tree);
        commit.setParentIds(new ObjectId[] { currentCommitId });
        commit.setAuthor(author);
        commit.setCommitter(myIdent);
        commit.setMessage(msgbuf.toString());
        oi.insert(commit);
        oi.flush();
        ObjectId commitId = oi.idFor(Constants.OBJ_COMMIT, commit.build());
        final RefUpdate rfu = or.repo.updateRef(subscriber.get());
        rfu.setForceUpdate(false);
        rfu.setNewObjectId(commitId);
        rfu.setExpectedOldObjectId(currentCommitId);
        rfu.setRefLogMessage("Submit to " + subscriber.getParentKey().get(), true);
        switch(rfu.update()) {
            case NEW:
            case FAST_FORWARD:
                gitRefUpdated.fire(subscriber.getParentKey(), rfu, account);
                changeHooks.doRefUpdatedHook(subscriber, rfu, account);
                // sent to inform users about the updated branch
                break;
            case FORCED:
            case IO_FAILURE:
            case LOCK_FAILURE:
            case NOT_ATTEMPTED:
            case NO_CHANGE:
            case REJECTED:
            case REJECTED_CURRENT_BRANCH:
            case RENAMED:
            default:
                throw new IOException(rfu.getResult().name());
        }
    } catch (IOException e) {
        throw new SubmoduleException("Cannot update gitlinks for " + subscriber.get(), e);
    }
}
#end_block

#method_before
@Override
public void run() throws UnloggedFailure, OrmException {
    Account account;
    if (name.isEmpty()) {
        throw new UnloggedFailure(1, "You need to tell me who to find:  LastName,\\\\ Firstname, email@address.com, account id or an user name.  " + "Be sure to double-escape spaces, for example: \"show-account Last,\\\\ First\"");
    }
    Set<Id> idList = accountResolver.findAll(name);
    if (idList.isEmpty()) {
        throw new UnloggedFailure(1, "No accounts found for your query: \"" + name + "\"" + " Tip: Try double-escaping spaces, for example: \"show-account Last,\\\\ First\"");
    } else {
        stdout.println("Found " + idList.size() + " result" + (idList.size() > 1 ? "s" : "") + ": for query: \"" + name + "\"");
        stdout.println();
    }
    for (Id id : idList) {
        account = accountResolver.find(id.toString());
        if (account == null) {
            throw new UnloggedFailure("Account " + id.toString() + " does not exist.");
        }
        stdout.println("Full name:         " + account.getFullName());
        stdout.println("Account Id:        " + id.toString());
        stdout.println("Preferred Email:   " + account.getPreferredEmail());
        stdout.println("User Name:         " + account.getUserName());
        stdout.println("Active:            " + account.isActive());
        stdout.println("Registered on:     " + account.getRegisteredOn());
        try (final ReviewDb db = schema.open()) {
            stdout.println("");
            stdout.println("External Ids:");
            stdout.println(String.format("%-50s %s", "Email Address:", "External Id:"));
            for (AccountExternalId accountExternalId : db.accountExternalIds().byAccount(account.getId())) {
                stdout.println(String.format("%-50s %s", (accountExternalId.getEmailAddress() == null ? "" : accountExternalId.getEmailAddress()), accountExternalId.getExternalId()));
            }
            if (showKeys) {
                stdout.println("");
                stdout.println("Public Keys:");
                List<SshKeyInfo> sshKeys;
                try {
                    sshKeys = getSshKeys.get().apply(new AccountResource(userFactory.create(id)));
                } catch (AuthException | IOException | ConfigInvalidException e) {
                    stdout.println("Error getting ssh key info!");
                    e.printStackTrace();
                    sshKeys = null;
                }
                if (sshKeys == null || sshKeys.isEmpty()) {
                    stdout.println("None");
                } else {
                    stdout.println(String.format("%-9s %s", "Status:", "Key:"));
                    for (SshKeyInfo sshKey : sshKeys) {
                        stdout.println(String.format("%-9s %s", (sshKey.valid ? "Active" : "Inactive"), sshKey.sshPublicKey));
                    }
                }
            }
        }
        if (showGroups) {
            stdout.println();
            stdout.println("Member of groups" + (filterGroups == null ? "" : " (Filtering on \"" + filterGroups + "\")") + ":");
            List<GroupInfo> groupInfos = accountGetGroups.get().apply(new AccountResource(userFactory.create(id)));
            Collections.sort(groupInfos, new CustomComparator());
            for (GroupInfo groupInfo : groupInfos) {
                if (null == filterGroups || groupInfo.name.toLowerCase().contains(filterGroups.toLowerCase())) {
                    stdout.println(groupInfo.name);
                }
            }
        }
        stdout.println("");
    }
}
#method_after
@Override
public void run() throws UnloggedFailure, OrmException {
    Account account;
    if (name.isEmpty()) {
        throw new UnloggedFailure(1, "You need to tell me who to find:  LastName,\\\\ Firstname, email@address.com, account id or an user name.  " + "Be sure to double-escape spaces, for example: \"show-account Last,\\\\ First\"");
    }
    Set<Id> idList = accountResolver.findAll(name);
    if (idList.isEmpty()) {
        throw new UnloggedFailure(1, "No accounts found for your query: \"" + name + "\"" + " Tip: Try double-escaping spaces, for example: \"show-account Last,\\\\ First\"");
    } else {
        stdout.println("Found " + idList.size() + " result" + (idList.size() > 1 ? "s" : "") + ": for query: \"" + name + "\"");
        stdout.println();
    }
    for (Id id : idList) {
        account = accountResolver.find(id.toString());
        if (account == null) {
            throw new UnloggedFailure("Account " + id.toString() + " does not exist.");
        }
        stdout.println("Full name:         " + account.getFullName());
        stdout.println("Account Id:        " + id.toString());
        stdout.println("Preferred Email:   " + account.getPreferredEmail());
        stdout.println("User Name:         " + account.getUserName());
        stdout.println("Active:            " + account.isActive());
        stdout.println("Registered on:     " + account.getRegisteredOn());
        try (final ReviewDb db = schema.open()) {
            stdout.println("");
            stdout.println("External Ids:");
            stdout.println(String.format("%-50s %s", "Email Address:", "External Id:"));
            for (AccountExternalId accountExternalId : db.accountExternalIds().byAccount(account.getId())) {
                stdout.println(String.format("%-50s %s", (accountExternalId.getEmailAddress() == null ? "" : accountExternalId.getEmailAddress()), accountExternalId.getExternalId()));
            }
            if (showKeys) {
                stdout.println("");
                stdout.println("Public Keys:");
                List<SshKeyInfo> sshKeys;
                try {
                    sshKeys = getSshKeys.get().apply(new AccountResource(userFactory.create(id)));
                } catch (AuthException | IOException | ConfigInvalidException e) {
                    throw new UnloggedFailure(1, "Error getting sshkeys: " + e.getMessage(), e);
                }
                if (sshKeys == null || sshKeys.isEmpty()) {
                    stdout.println("None");
                } else {
                    stdout.println(String.format("%-9s %s", "Status:", "Key:"));
                    for (SshKeyInfo sshKey : sshKeys) {
                        stdout.println(String.format("%-9s %s", (sshKey.valid ? "Active" : "Inactive"), sshKey.sshPublicKey));
                    }
                }
            }
        }
        if (showGroups) {
            stdout.println();
            stdout.println("Member of groups" + (filterGroups == null ? "" : " (Filtering on \"" + filterGroups + "\")") + ":");
            List<GroupInfo> groupInfos = accountGetGroups.get().apply(new AccountResource(userFactory.create(id)));
            Collections.sort(groupInfos, new CustomComparator());
            for (GroupInfo groupInfo : groupInfos) {
                if (null == filterGroups || groupInfo.name.toLowerCase().contains(filterGroups.toLowerCase())) {
                    stdout.println(groupInfo.name);
                }
            }
        }
        stdout.println("");
    }
}
#end_block

#method_before
private List<HashtagsEvent> getHashtagsEvents(Change change, NoteDbUpdateManager manager) throws IOException {
    String refName = ChangeNoteUtil.changeRefName(change.getId());
    ObjectId old = manager.getChangeRepo().getObjectId(refName);
    if (old == null) {
        return Collections.emptyList();
    }
    RevWalk rw = manager.getChangeRepo().rw;
    List<HashtagsEvent> events = new ArrayList<>();
    rw.reset();
    rw.markStart(rw.parseCommit(old));
    for (RevCommit commit : rw) {
        Account.Id authorId;
        try {
            authorId = changeNoteUtil.parseIdent(commit.getAuthorIdent(), change.getId());
        } catch (ConfigInvalidException e) {
            // Corrupt data, no valid hashtags in this commit.
            continue;
        }
        PatchSet.Id psId = parsePatchSetId(change, commit);
        Set<String> hashtags = parseHashtags(commit);
        if (authorId == null || psId == null || hashtags == null) {
            continue;
        }
        Timestamp commitTime = new Timestamp(commit.getCommitterIdent().getWhen().getTime());
        events.add(new HashtagsEvent(psId, authorId, commitTime, hashtags, change.getCreatedOn()));
    }
    return events;
}
#method_after
private List<HashtagsEvent> getHashtagsEvents(Change change, NoteDbUpdateManager manager) throws IOException {
    String refName = changeMetaRef(change.getId());
    ObjectId old = manager.getChangeRepo().getObjectId(refName);
    if (old == null) {
        return Collections.emptyList();
    }
    RevWalk rw = manager.getChangeRepo().rw;
    List<HashtagsEvent> events = new ArrayList<>();
    rw.reset();
    rw.markStart(rw.parseCommit(old));
    for (RevCommit commit : rw) {
        Account.Id authorId;
        try {
            authorId = changeNoteUtil.parseIdent(commit.getAuthorIdent(), change.getId());
        } catch (ConfigInvalidException e) {
            // Corrupt data, no valid hashtags in this commit.
            continue;
        }
        PatchSet.Id psId = parsePatchSetId(change, commit);
        Set<String> hashtags = parseHashtags(commit);
        if (authorId == null || psId == null || hashtags == null) {
            continue;
        }
        Timestamp commitTime = new Timestamp(commit.getCommitterIdent().getWhen().getTime());
        events.add(new HashtagsEvent(psId, authorId, commitTime, hashtags, change.getCreatedOn()));
    }
    return events;
}
#end_block

#method_before
private void deleteRef(Change change, Repository repo, ChainedReceiveCommands cmds) throws IOException {
    String refName = ChangeNoteUtil.changeRefName(change.getId());
    ObjectId old = cmds.getObjectId(repo, refName);
    if (old != null) {
        cmds.add(new ReceiveCommand(old, ObjectId.zeroId(), refName));
    }
}
#method_after
private void deleteRef(Change change, Repository repo, ChainedReceiveCommands cmds) throws IOException {
    String refName = changeMetaRef(change.getId());
    ObjectId old = cmds.getObjectId(repo, refName);
    if (old != null) {
        cmds.add(new ReceiveCommand(old, ObjectId.zeroId(), refName));
    }
}
#end_block

#method_before
@Override
public List<GroupInfo> apply(GroupResource resource, Input input) throws MethodNotAllowedException, AuthException, UnprocessableEntityException, OrmException {
    AccountGroup group = resource.toAccountGroup();
    if (group == null) {
        throw new MethodNotAllowedException();
    }
    input = Input.init(input);
    GroupControl control = resource.getControl();
    Map<AccountGroup.UUID, AccountGroupById> newIncludedGroups = new HashMap<>();
    List<GroupInfo> result = Lists.newLinkedList();
    Account.Id me = control.getUser().getAccountId();
    for (String includedGroup : input.groups) {
        GroupDescription.Basic d = groupsCollection.parse(includedGroup);
        if (!control.canAddGroup()) {
            throw new AuthException(String.format("Cannot add group: %s", d.getName()));
        }
        if (!newIncludedGroups.containsKey(d.getGroupUUID())) {
            AccountGroupById.Key agiKey = new AccountGroupById.Key(group.getId(), d.getGroupUUID());
            AccountGroupById agi = db.get().accountGroupById().get(agiKey);
            if (agi == null) {
                agi = new AccountGroupById(agiKey);
                newIncludedGroups.put(d.getGroupUUID(), agi);
            }
        }
        result.add(json.format(d));
    }
    if (!newIncludedGroups.isEmpty()) {
        auditService.dispatchAddGroupsToGroup(me, newIncludedGroups.values());
        db.get().accountGroupById().insert(newIncludedGroups.values());
        for (AccountGroupById agi : newIncludedGroups.values()) {
            groupIncludeCache.evictParentGroupsOf(agi.getIncludeUUID());
        }
        groupIncludeCache.evictSubgroupsOf(group.getGroupUUID());
    }
    return result;
}
#method_after
@Override
public List<GroupInfo> apply(GroupResource resource, Input input) throws MethodNotAllowedException, AuthException, UnprocessableEntityException, OrmException {
    AccountGroup group = resource.toAccountGroup();
    if (group == null) {
        throw new MethodNotAllowedException();
    }
    input = Input.init(input);
    GroupControl control = resource.getControl();
    Map<AccountGroup.UUID, AccountGroupById> newIncludedGroups = new HashMap<>();
    List<GroupInfo> result = new LinkedList<>();
    Account.Id me = control.getUser().getAccountId();
    for (String includedGroup : input.groups) {
        GroupDescription.Basic d = groupsCollection.parse(includedGroup);
        if (!control.canAddGroup()) {
            throw new AuthException(String.format("Cannot add group: %s", d.getName()));
        }
        if (!newIncludedGroups.containsKey(d.getGroupUUID())) {
            AccountGroupById.Key agiKey = new AccountGroupById.Key(group.getId(), d.getGroupUUID());
            AccountGroupById agi = db.get().accountGroupById().get(agiKey);
            if (agi == null) {
                agi = new AccountGroupById(agiKey);
                newIncludedGroups.put(d.getGroupUUID(), agi);
            }
        }
        result.add(json.format(d));
    }
    if (!newIncludedGroups.isEmpty()) {
        auditService.dispatchAddGroupsToGroup(me, newIncludedGroups.values());
        db.get().accountGroupById().insert(newIncludedGroups.values());
        for (AccountGroupById agi : newIncludedGroups.values()) {
            groupIncludeCache.evictParentGroupsOf(agi.getIncludeUUID());
        }
        groupIncludeCache.evictSubgroupsOf(group.getGroupUUID());
    }
    return result;
}
#end_block

#method_before
private List<AccountInfo> toAccountInfoList(Set<Account.Id> accountIds) throws OrmException {
    List<AccountInfo> result = Lists.newLinkedList();
    AccountLoader loader = infoFactory.create(true);
    for (Account.Id accId : accountIds) {
        result.add(loader.get(accId));
    }
    loader.fill();
    return result;
}
#method_after
private List<AccountInfo> toAccountInfoList(Set<Account.Id> accountIds) throws OrmException {
    List<AccountInfo> result = new LinkedList<>();
    AccountLoader loader = infoFactory.create(true);
    for (Account.Id accId : accountIds) {
        result.add(loader.get(accId));
    }
    loader.fill();
    return result;
}
#end_block

#method_before
boolean validate(boolean autoClose) throws IOException, OrmException {
    if (!autoClose && inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    } else if (change == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    priorPatchSet = change.currentPatchSetId();
    if (!revisions.containsValue(priorPatchSet)) {
        reject(inputCommand, "change " + ontoChange + " missing revisions");
        return false;
    }
    RevCommit newCommit = rp.getRevWalk().parseCommit(newCommitId);
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    if (newCommit.equals(priorCommit)) {
        // Ignore requests to make the change its current state.
        skip = true;
        reject(inputCommand, "commit already exists (as current patchset)");
        return false;
    }
    changeCtl = projectControl.controlFor(db, change);
    if (!changeCtl.canAddPatchSet(db)) {
        String locked = ".";
        if (changeCtl.isPatchSetLocked(db)) {
            locked = ". Change is patch set locked.";
        }
        reject(inputCommand, "cannot replace " + ontoChange + locked);
        return false;
    } else if (change.getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    } else if (revisions.containsKey(newCommit)) {
        reject(inputCommand, "commit already exists (in the change)");
        return false;
    }
    for (Ref r : rp.getRepository().getRefDatabase().getRefs("refs/changes").values()) {
        if (r.getObjectId().equals(newCommit)) {
            reject(inputCommand, "commit already exists (in the project)");
            return false;
        }
    }
    for (RevCommit prior : revisions.keySet()) {
        // amending when trying to address review comments.
        if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
            reject(inputCommand, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
            return false;
        }
    }
    if (!validCommit(rp.getRevWalk(), changeCtl.getRefControl(), inputCommand, newCommit)) {
        return false;
    }
    rp.getRevWalk().parseBody(priorCommit);
    // of the commit was modified.
    if (newCommit.getTree().equals(priorCommit.getTree())) {
        boolean messageEq = eq(newCommit.getFullMessage(), priorCommit.getFullMessage());
        boolean parentsEq = parentsEqual(newCommit, priorCommit);
        boolean authorEq = authorEqual(newCommit, priorCommit);
        ObjectReader reader = rp.getRevWalk().getObjectReader();
        if (messageEq && parentsEq && authorEq && !autoClose) {
            addMessage(String.format("(W) No changes between prior commit %s and new commit %s", reader.abbreviate(priorCommit).name(), reader.abbreviate(newCommit).name()));
        } else {
            StringBuilder msg = new StringBuilder();
            msg.append("(W) ");
            msg.append(reader.abbreviate(newCommit).name());
            msg.append(":");
            msg.append(" no files changed");
            if (!authorEq) {
                msg.append(", author changed");
            }
            if (!messageEq) {
                msg.append(", message updated");
            }
            if (!parentsEq) {
                msg.append(", was rebased");
            }
            addMessage(msg.toString());
        }
    }
    if (magicBranch != null && magicBranch.edit) {
        return newEdit();
    }
    newPatchSet();
    return true;
}
#method_after
boolean validate(boolean autoClose) throws IOException, OrmException {
    if (!autoClose && inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    } else if (change == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    priorPatchSet = change.currentPatchSetId();
    if (!revisions.containsValue(priorPatchSet)) {
        reject(inputCommand, "change " + ontoChange + " missing revisions");
        return false;
    }
    RevCommit newCommit = rp.getRevWalk().parseCommit(newCommitId);
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    if (newCommit.equals(priorCommit)) {
        // Ignore requests to make the change its current state.
        skip = true;
        reject(inputCommand, "commit already exists (as current patchset)");
        return false;
    }
    changeCtl = projectControl.controlFor(db, change);
    if (!changeCtl.canAddPatchSet(db)) {
        String locked = ".";
        if (changeCtl.isPatchSetLocked(db)) {
            locked = ". Change is patch set locked.";
        }
        reject(inputCommand, "cannot replace " + ontoChange + locked);
        return false;
    } else if (change.getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    } else if (revisions.containsKey(newCommit)) {
        reject(inputCommand, "commit already exists (in the change)");
        return false;
    }
    for (Ref r : rp.getRepository().getRefDatabase().getRefs("refs/changes").values()) {
        if (r.getObjectId().equals(newCommit)) {
            reject(inputCommand, "commit already exists (in the project)");
            return false;
        }
    }
    for (RevCommit prior : revisions.keySet()) {
        // amending when trying to address review comments.
        if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
            reject(inputCommand, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
            return false;
        }
    }
    if (!validCommit(rp.getRevWalk(), changeCtl.getRefControl(), inputCommand, newCommit)) {
        return false;
    }
    rp.getRevWalk().parseBody(priorCommit);
    // of the commit was modified.
    if (newCommit.getTree().equals(priorCommit.getTree())) {
        boolean messageEq = eq(newCommit.getFullMessage(), priorCommit.getFullMessage());
        boolean parentsEq = parentsEqual(newCommit, priorCommit);
        boolean authorEq = authorEqual(newCommit, priorCommit);
        ObjectReader reader = rp.getRevWalk().getObjectReader();
        if (messageEq && parentsEq && authorEq && !autoClose) {
            addMessage(String.format("(W) No changes between prior commit %s and new commit %s", reader.abbreviate(priorCommit).name(), reader.abbreviate(newCommit).name()));
        } else {
            StringBuilder msg = new StringBuilder();
            msg.append("(I) ");
            msg.append(reader.abbreviate(newCommit).name());
            msg.append(":");
            msg.append(" no files changed");
            if (!authorEq) {
                msg.append(", author changed");
            }
            if (!messageEq) {
                msg.append(", message updated");
            }
            if (!parentsEq) {
                msg.append(", was rebased");
            }
            addMessage(msg.toString());
        }
    }
    if (magicBranch != null && magicBranch.edit) {
        return newEdit();
    }
    newPatchSet();
    return true;
}
#end_block

#method_before
@Override
public Response<?> apply(GroupResource resource, Input input) throws AuthException, MethodNotAllowedException, UnprocessableEntityException, OrmException {
    AccountGroup internalGroup = resource.toAccountGroup();
    if (internalGroup == null) {
        throw new MethodNotAllowedException();
    }
    input = Input.init(input);
    final GroupControl control = resource.getControl();
    final Map<AccountGroup.UUID, AccountGroupById> includedGroups = getIncludedGroups(internalGroup.getId());
    final List<AccountGroupById> toRemove = Lists.newLinkedList();
    for (final String includedGroup : input.groups) {
        GroupDescription.Basic d = groupsCollection.parse(includedGroup);
        if (!control.canRemoveGroup()) {
            throw new AuthException(String.format("Cannot delete group: %s", d.getName()));
        }
        AccountGroupById g = includedGroups.remove(d.getGroupUUID());
        if (g != null) {
            toRemove.add(g);
        }
    }
    if (!toRemove.isEmpty()) {
        writeAudits(toRemove);
        db.get().accountGroupById().delete(toRemove);
        for (final AccountGroupById g : toRemove) {
            groupIncludeCache.evictParentGroupsOf(g.getIncludeUUID());
        }
        groupIncludeCache.evictSubgroupsOf(internalGroup.getGroupUUID());
    }
    return Response.none();
}
#method_after
@Override
public Response<?> apply(GroupResource resource, Input input) throws AuthException, MethodNotAllowedException, UnprocessableEntityException, OrmException {
    AccountGroup internalGroup = resource.toAccountGroup();
    if (internalGroup == null) {
        throw new MethodNotAllowedException();
    }
    input = Input.init(input);
    final GroupControl control = resource.getControl();
    final Map<AccountGroup.UUID, AccountGroupById> includedGroups = getIncludedGroups(internalGroup.getId());
    final List<AccountGroupById> toRemove = new LinkedList<>();
    for (final String includedGroup : input.groups) {
        GroupDescription.Basic d = groupsCollection.parse(includedGroup);
        if (!control.canRemoveGroup()) {
            throw new AuthException(String.format("Cannot delete group: %s", d.getName()));
        }
        AccountGroupById g = includedGroups.remove(d.getGroupUUID());
        if (g != null) {
            toRemove.add(g);
        }
    }
    if (!toRemove.isEmpty()) {
        writeAudits(toRemove);
        db.get().accountGroupById().delete(toRemove);
        for (final AccountGroupById g : toRemove) {
            groupIncludeCache.evictParentGroupsOf(g.getIncludeUUID());
        }
        groupIncludeCache.evictSubgroupsOf(internalGroup.getGroupUUID());
    }
    return Response.none();
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws RestApiException, OrmException, IOException {
    added = approvalsUtil.addReviewers(ctx.getDb(), ctx.getNotes(), ctx.getUpdate(ctx.getChange().currentPatchSetId()), rsrc.getControl().getLabelTypes(), rsrc.getChange(), reviewers.keySet());
    if (added.isEmpty()) {
        return false;
    }
    patchSet = psUtil.current(dbProvider.get(), rsrc.getNotes());
    ctx.bumpLastUpdatedOn(false);
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws RestApiException, OrmException, IOException {
    added = approvalsUtil.addReviewers(ctx.getDb(), ctx.getNotes(), ctx.getUpdate(ctx.getChange().currentPatchSetId()), rsrc.getControl().getLabelTypes(), rsrc.getChange(), reviewers.keySet());
    if (added.isEmpty()) {
        return false;
    }
    patchSet = psUtil.current(dbProvider.get(), rsrc.getNotes());
    return true;
}
#end_block

#method_before
@Override
public Response<?> apply(GroupResource resource, Input input) throws AuthException, MethodNotAllowedException, UnprocessableEntityException, OrmException {
    AccountGroup internalGroup = resource.toAccountGroup();
    if (internalGroup == null) {
        throw new MethodNotAllowedException();
    }
    input = Input.init(input);
    final GroupControl control = resource.getControl();
    final Map<Account.Id, AccountGroupMember> members = getMembers(internalGroup.getId());
    final List<AccountGroupMember> toRemove = Lists.newLinkedList();
    for (final String nameOrEmail : input.members) {
        Account a = accounts.parse(nameOrEmail).getAccount();
        if (!control.canRemoveMember()) {
            throw new AuthException("Cannot delete member: " + a.getFullName());
        }
        final AccountGroupMember m = members.remove(a.getId());
        if (m != null) {
            toRemove.add(m);
        }
    }
    writeAudits(toRemove);
    db.get().accountGroupMembers().delete(toRemove);
    for (final AccountGroupMember m : toRemove) {
        accountCache.evict(m.getAccountId());
    }
    return Response.none();
}
#method_after
@Override
public Response<?> apply(GroupResource resource, Input input) throws AuthException, MethodNotAllowedException, UnprocessableEntityException, OrmException {
    AccountGroup internalGroup = resource.toAccountGroup();
    if (internalGroup == null) {
        throw new MethodNotAllowedException();
    }
    input = Input.init(input);
    final GroupControl control = resource.getControl();
    final Map<Account.Id, AccountGroupMember> members = getMembers(internalGroup.getId());
    final List<AccountGroupMember> toRemove = new LinkedList<>();
    for (final String nameOrEmail : input.members) {
        Account a = accounts.parse(nameOrEmail).getAccount();
        if (!control.canRemoveMember()) {
            throw new AuthException("Cannot delete member: " + a.getFullName());
        }
        final AccountGroupMember m = members.remove(a.getId());
        if (m != null) {
            toRemove.add(m);
        }
    }
    writeAudits(toRemove);
    db.get().accountGroupMembers().delete(toRemove);
    for (final AccountGroupMember m : toRemove) {
        accountCache.evict(m.getAccountId());
    }
    return Response.none();
}
#end_block

#method_before
private void appendOneComment(PrintWriter writer, PatchLineComment c) {
    // The CommentRange field for a comment is allowed to be null. If it is
    // null, then in the first line, we simply use the line number field for a
    // comment instead. If it isn't null, we write the comment range itself.
    CommentRange range = c.getRange();
    if (range != null) {
        writer.print(range.getStartLine());
        writer.print(':');
        writer.print(range.getStartCharacter());
        writer.print('-');
        writer.print(range.getEndLine());
        writer.print(':');
        writer.print(range.getEndCharacter());
    } else {
        writer.print(c.getLine());
    }
    writer.print("\n");
    writer.print(formatTime(serverIdent, c.getWrittenOn()));
    writer.print("\n");
    PersonIdent ident = newIdent(accountCache.get(c.getAuthor()).getAccount(), c.getWrittenOn(), serverIdent, anonymousCowardName);
    String nameString = ident.getName() + " <" + ident.getEmailAddress() + ">";
    appendHeaderField(writer, AUTHOR, nameString);
    String parent = c.getParentUuid();
    if (parent != null) {
        appendHeaderField(writer, PARENT, parent);
    }
    appendHeaderField(writer, UUID, c.getKey().get());
    if (c.getTag() != null) {
        appendHeaderField(writer, TAG, c.getTag());
    }
    byte[] messageBytes = c.getMessage().getBytes(UTF_8);
    appendHeaderField(writer, LENGTH, Integer.toString(messageBytes.length));
    writer.print(c.getMessage());
    writer.print("\n\n");
}
#method_after
private void appendOneComment(PrintWriter writer, PatchLineComment c) {
    // The CommentRange field for a comment is allowed to be null. If it is
    // null, then in the first line, we simply use the line number field for a
    // comment instead. If it isn't null, we write the comment range itself.
    CommentRange range = c.getRange();
    if (range != null) {
        writer.print(range.getStartLine());
        writer.print(':');
        writer.print(range.getStartCharacter());
        writer.print('-');
        writer.print(range.getEndLine());
        writer.print(':');
        writer.print(range.getEndCharacter());
    } else {
        writer.print(c.getLine());
    }
    writer.print("\n");
    writer.print(formatTime(serverIdent, c.getWrittenOn()));
    writer.print("\n");
    PersonIdent ident = newIdent(accountCache.get(c.getAuthor()).getAccount(), c.getWrittenOn(), serverIdent, anonymousCowardName);
    StringBuilder name = new StringBuilder();
    PersonIdent.appendSanitized(name, ident.getName());
    name.append(" <");
    PersonIdent.appendSanitized(name, ident.getEmailAddress());
    name.append('>');
    appendHeaderField(writer, AUTHOR, name.toString());
    String parent = c.getParentUuid();
    if (parent != null) {
        appendHeaderField(writer, PARENT, parent);
    }
    appendHeaderField(writer, UUID, c.getKey().get());
    if (c.getTag() != null) {
        appendHeaderField(writer, TAG, c.getTag());
    }
    byte[] messageBytes = c.getMessage().getBytes(UTF_8);
    appendHeaderField(writer, LENGTH, Integer.toString(messageBytes.length));
    writer.print(c.getMessage());
    writer.print("\n\n");
}
#end_block

#method_before
private void startPlugin(PluginGuiceEnvironment env) throws Exception {
    Injector root = newRootInjector(env);
    serverManager = new LifecycleManager();
    serverManager.add(root);
    AutoRegisterModules auto = null;
    if (sysModule == null && sshModule == null && httpModule == null) {
        auto = new AutoRegisterModules(getName(), env, scanner, classLoader);
        auto.discover();
    }
    if (sysModule != null) {
        sysInjector = root.createChildInjector(root.getInstance(sysModule));
        serverManager.add(sysInjector);
    } else if (auto != null && auto.sysModule != null) {
        sysInjector = root.createChildInjector(auto.sysModule);
        serverManager.add(sysInjector);
    } else {
        sysInjector = root;
    }
    if (env.hasSshModule()) {
        List<Module> modules = Lists.newLinkedList();
        if (getApiType() == ApiType.PLUGIN) {
            modules.add(env.getSshModule());
        }
        if (sshModule != null) {
            modules.add(sysInjector.getInstance(sshModule));
            sshInjector = sysInjector.createChildInjector(modules);
            serverManager.add(sshInjector);
        } else if (auto != null && auto.sshModule != null) {
            modules.add(auto.sshModule);
            sshInjector = sysInjector.createChildInjector(modules);
            serverManager.add(sshInjector);
        }
    }
    if (env.hasHttpModule()) {
        List<Module> modules = Lists.newLinkedList();
        if (getApiType() == ApiType.PLUGIN) {
            modules.add(env.getHttpModule());
        }
        if (httpModule != null) {
            modules.add(sysInjector.getInstance(httpModule));
            httpInjector = sysInjector.createChildInjector(modules);
            serverManager.add(httpInjector);
        } else if (auto != null && auto.httpModule != null) {
            modules.add(auto.httpModule);
            httpInjector = sysInjector.createChildInjector(modules);
            serverManager.add(httpInjector);
        }
    }
    serverManager.start();
}
#method_after
private void startPlugin(PluginGuiceEnvironment env) throws Exception {
    Injector root = newRootInjector(env);
    serverManager = new LifecycleManager();
    serverManager.add(root);
    AutoRegisterModules auto = null;
    if (sysModule == null && sshModule == null && httpModule == null) {
        auto = new AutoRegisterModules(getName(), env, scanner, classLoader);
        auto.discover();
    }
    if (sysModule != null) {
        sysInjector = root.createChildInjector(root.getInstance(sysModule));
        serverManager.add(sysInjector);
    } else if (auto != null && auto.sysModule != null) {
        sysInjector = root.createChildInjector(auto.sysModule);
        serverManager.add(sysInjector);
    } else {
        sysInjector = root;
    }
    if (env.hasSshModule()) {
        List<Module> modules = new LinkedList<>();
        if (getApiType() == ApiType.PLUGIN) {
            modules.add(env.getSshModule());
        }
        if (sshModule != null) {
            modules.add(sysInjector.getInstance(sshModule));
            sshInjector = sysInjector.createChildInjector(modules);
            serverManager.add(sshInjector);
        } else if (auto != null && auto.sshModule != null) {
            modules.add(auto.sshModule);
            sshInjector = sysInjector.createChildInjector(modules);
            serverManager.add(sshInjector);
        }
    }
    if (env.hasHttpModule()) {
        List<Module> modules = new LinkedList<>();
        if (getApiType() == ApiType.PLUGIN) {
            modules.add(env.getHttpModule());
        }
        if (httpModule != null) {
            modules.add(sysInjector.getInstance(httpModule));
            httpInjector = sysInjector.createChildInjector(modules);
            serverManager.add(httpInjector);
        } else if (auto != null && auto.httpModule != null) {
            modules.add(auto.httpModule);
            httpInjector = sysInjector.createChildInjector(modules);
            serverManager.add(httpInjector);
        }
    }
    serverManager.start();
}
#end_block

#method_before
public List<PatchLineComment> draftByChange(ReviewDb db, ChangeNotes notes) throws OrmException {
    if (!migration.readChanges()) {
        return sort(byCommentStatus(db.patchComments().byChange(notes.getChangeId()), Status.DRAFT));
    }
    List<PatchLineComment> comments = new ArrayList<>();
    for (String refSuffix : getDraftRefs(notes.getChangeId()).keySet()) {
        Account.Id account = Account.Id.fromRefPart(refSuffix);
        if (account != null) {
            comments.addAll(draftByChangeAuthor(db, notes, account));
        }
    }
    return sort(comments);
}
#method_after
public List<PatchLineComment> draftByChange(ReviewDb db, ChangeNotes notes) throws OrmException {
    if (!migration.readChanges()) {
        return sort(byCommentStatus(db.patchComments().byChange(notes.getChangeId()), Status.DRAFT));
    }
    List<PatchLineComment> comments = new ArrayList<>();
    for (Ref ref : getDraftRefs(notes.getChangeId())) {
        Account.Id account = Account.Id.fromRefSuffix(ref.getName());
        if (account != null) {
            comments.addAll(draftByChangeAuthor(db, notes, account));
        }
    }
    return sort(comments);
}
#end_block

#method_before
public List<PatchLineComment> byPatchSet(ReviewDb db, ChangeNotes notes, PatchSet.Id psId) throws OrmException {
    if (!migration.readChanges()) {
        return sort(db.patchComments().byPatchSet(psId).toList());
    }
    List<PatchLineComment> comments = new ArrayList<>();
    comments.addAll(publishedByPatchSet(db, notes, psId));
    for (String refSuffix : getDraftRefs(notes.getChangeId()).keySet()) {
        Account.Id account = Account.Id.fromRefPart(refSuffix);
        if (account != null) {
            comments.addAll(draftByPatchSetAuthor(db, psId, account, notes));
        }
    }
    return sort(comments);
}
#method_after
public List<PatchLineComment> byPatchSet(ReviewDb db, ChangeNotes notes, PatchSet.Id psId) throws OrmException {
    if (!migration.readChanges()) {
        return sort(db.patchComments().byPatchSet(psId).toList());
    }
    List<PatchLineComment> comments = new ArrayList<>();
    comments.addAll(publishedByPatchSet(db, notes, psId));
    for (Ref ref : getDraftRefs(notes.getChangeId())) {
        Account.Id account = Account.Id.fromRefSuffix(ref.getName());
        if (account != null) {
            comments.addAll(draftByPatchSetAuthor(db, psId, account, notes));
        }
    }
    return sort(comments);
}
#end_block

#method_before
// To be used only by HasDraftByLegacyPredicate.
@Deprecated
public List<PatchLineComment> draftByAuthor(ReviewDb db, Account.Id author) throws OrmException {
    if (!migration.readChanges()) {
        return sort(db.patchComments().draftByAuthor(author).toList());
    }
    Set<String> refNames = getRefNamesAllUsers(RefNames.refsDraftCommentsPrefix(author));
    List<PatchLineComment> comments = new ArrayList<>();
    for (String refName : refNames) {
        Change.Id changeId = Change.Id.parse(refName);
        // Avoid loading notes for all affected changes just to be able to auto-
        // rebuild. This is only used in a corner case in the search codepath, so
        // returning slightly stale values is ok.
        DraftCommentNotes notes = draftFactory.createWithAutoRebuildingDisabled(changeId, author);
        comments.addAll(notes.load().getComments().values());
    }
    return sort(comments);
}
#method_after
// To be used only by HasDraftByLegacyPredicate.
@Deprecated
public List<PatchLineComment> draftByAuthor(ReviewDb db, Account.Id author) throws OrmException {
    if (!migration.readChanges()) {
        return sort(db.patchComments().draftByAuthor(author).toList());
    }
    List<PatchLineComment> comments = new ArrayList<>();
    try (Repository repo = repoManager.openRepository(allUsers)) {
        for (String refName : repo.getRefDatabase().getRefs(RefNames.REFS_DRAFT_COMMENTS).keySet()) {
            Account.Id accountId = Account.Id.fromRefSuffix(refName);
            Change.Id changeId = Change.Id.fromRefPart(refName);
            if (accountId == null || changeId == null) {
                continue;
            }
            // Avoid loading notes for all affected changes just to be able to auto-
            // rebuild. This is only used in a corner case in the search codepath,
            // so returning slightly stale values is ok.
            DraftCommentNotes notes = draftFactory.createWithAutoRebuildingDisabled(changeId, author);
            comments.addAll(notes.load().getComments().values());
        }
    } catch (IOException e) {
        throw new OrmException(e);
    }
    return sort(comments);
}
#end_block

#method_before
public void deleteAllDraftsFromAllUsers(Change.Id changeId) throws IOException {
    try (Repository repo = repoManager.openRepository(allUsers);
        RevWalk rw = new RevWalk(repo)) {
        BatchRefUpdate bru = repo.getRefDatabase().newBatchUpdate();
        for (Ref ref : getDraftRefs(repo, changeId).values()) {
            bru.addCommand(new ReceiveCommand(ref.getObjectId(), ObjectId.zeroId(), ref.getName()));
        }
        bru.setRefLogMessage("Delete drafts from NoteDb", false);
        bru.execute(rw, NullProgressMonitor.INSTANCE);
        for (ReceiveCommand cmd : bru.getCommands()) {
            if (cmd.getResult() != ReceiveCommand.Result.OK) {
                throw new IOException(String.format("Failed to delete draft comment ref %s at %s: %s (%s)", cmd.getRefName(), cmd.getOldId(), cmd.getResult(), cmd.getMessage()));
            }
        }
    }
}
#method_after
public void deleteAllDraftsFromAllUsers(Change.Id changeId) throws IOException {
    try (Repository repo = repoManager.openRepository(allUsers);
        RevWalk rw = new RevWalk(repo)) {
        BatchRefUpdate bru = repo.getRefDatabase().newBatchUpdate();
        for (Ref ref : getDraftRefs(repo, changeId)) {
            bru.addCommand(new ReceiveCommand(ref.getObjectId(), ObjectId.zeroId(), ref.getName()));
        }
        bru.setRefLogMessage("Delete drafts from NoteDb", false);
        bru.execute(rw, NullProgressMonitor.INSTANCE);
        for (ReceiveCommand cmd : bru.getCommands()) {
            if (cmd.getResult() != ReceiveCommand.Result.OK) {
                throw new IOException(String.format("Failed to delete draft comment ref %s at %s: %s (%s)", cmd.getRefName(), cmd.getOldId(), cmd.getResult(), cmd.getMessage()));
            }
        }
    }
}
#end_block

#method_before
public Map<String, Ref> getDraftRefs(Change.Id changeId) throws OrmException {
    try (Repository repo = repoManager.openRepository(allUsers)) {
        return getDraftRefs(repo, changeId);
    } catch (IOException e) {
        throw new OrmException(e);
    }
}
#method_after
public Collection<Ref> getDraftRefs(Change.Id changeId) throws OrmException {
    try (Repository repo = repoManager.openRepository(allUsers)) {
        return getDraftRefs(repo, changeId);
    } catch (IOException e) {
        throw new OrmException(e);
    }
}
#end_block

#method_before
private Map<String, Ref> getDraftRefs(Repository repo, final Change.Id changeId) throws IOException {
    final String suffix = "/" + changeId.get();
    return Maps.filterKeys(repo.getRefDatabase().getRefs(RefNames.REFS_DRAFT_COMMENTS), new Predicate<String>() {

        @Override
        public boolean apply(String input) {
            return input.endsWith(suffix);
        }
    });
}
#method_after
private Collection<Ref> getDraftRefs(Repository repo, Change.Id changeId) throws IOException {
    return repo.getRefDatabase().getRefs(RefNames.refsDraftCommentsPrefix(changeId)).values();
}
#end_block

#method_before
private void parse(ChangeNotesCommit commit) throws ConfigInvalidException {
    Timestamp ts = new Timestamp(commit.getCommitterIdent().getWhen().getTime());
    boolean updateTs = commit.getParentCount() == 0;
    createdOn = ts;
    parseTag(commit);
    updateTs |= tag != null;
    if (branch == null) {
        branch = parseBranch(commit);
        updateTs |= branch != null;
    }
    if (status == null) {
        status = parseStatus(commit);
        updateTs |= status != null;
    }
    PatchSet.Id psId = parsePatchSetId(commit);
    if (currentPatchSetId == null || psId.get() > currentPatchSetId.get()) {
        currentPatchSetId = psId;
    }
    PatchSetState psState = parsePatchSetState(commit);
    if (psState != null && !patchSetStates.containsKey(psId)) {
        patchSetStates.put(psId, psState);
    }
    Account.Id accountId = parseIdent(commit);
    if (accountId != null) {
        ownerId = accountId;
    }
    if (changeId == null) {
        changeId = parseChangeId(commit);
        updateTs |= changeId != null;
    }
    String currSubject = parseSubject(commit);
    if (currSubject != null) {
        if (subject == null) {
            subject = currSubject;
        }
        originalSubject = currSubject;
        updateTs = true;
    }
    updateTs |= parseChangeMessage(psId, accountId, commit, ts) != null;
    if (topic == null) {
        topic = parseTopic(commit);
        updateTs |= topic != null;
    }
    Set<String> oldHashtags = hashtags;
    parseHashtags(commit);
    updateTs |= hashtags != oldHashtags;
    if (submissionId == null) {
        submissionId = parseSubmissionId(commit);
        updateTs |= submissionId != null;
    }
    ObjectId currRev = parseRevision(commit);
    if (currRev != null) {
        parsePatchSet(psId, currRev, accountId, ts);
        updateTs = true;
    }
    parseGroups(psId, commit);
    if (submitRecords.isEmpty()) {
        // Only parse the most recent set of submit records; any older ones are
        // still there, but not currently used.
        parseSubmitRecords(commit.getFooterLineValues(FOOTER_SUBMITTED_WITH));
        updateTs |= !submitRecords.isEmpty();
    }
    for (String line : commit.getFooterLineValues(FOOTER_LABEL)) {
        parseApproval(psId, accountId, ts, line);
        updateTs = true;
    }
    for (ReviewerStateInternal state : ReviewerStateInternal.values()) {
        for (String line : commit.getFooterLineValues(state.getFooterKey())) {
            parseReviewer(state, line);
        }
    // Don't update timestamp when a reviewer was added, matching RevewDb
    // behavior.
    }
    if (updateTs) {
        if (lastUpdatedOn == null || ts.after(lastUpdatedOn)) {
            lastUpdatedOn = ts;
        }
    }
}
#method_after
private void parse(ChangeNotesCommit commit) throws ConfigInvalidException {
    Timestamp ts = new Timestamp(commit.getCommitterIdent().getWhen().getTime());
    createdOn = ts;
    parseTag(commit);
    if (branch == null) {
        branch = parseBranch(commit);
    }
    if (status == null) {
        status = parseStatus(commit);
    }
    PatchSet.Id psId = parsePatchSetId(commit);
    if (currentPatchSetId == null || psId.get() > currentPatchSetId.get()) {
        currentPatchSetId = psId;
    }
    PatchSetState psState = parsePatchSetState(commit);
    if (psState != null && !patchSetStates.containsKey(psId)) {
        patchSetStates.put(psId, psState);
    }
    Account.Id accountId = parseIdent(commit);
    if (accountId != null) {
        ownerId = accountId;
    }
    if (changeId == null) {
        changeId = parseChangeId(commit);
    }
    String currSubject = parseSubject(commit);
    if (currSubject != null) {
        if (subject == null) {
            subject = currSubject;
        }
        originalSubject = currSubject;
    }
    parseChangeMessage(psId, accountId, commit, ts);
    if (topic == null) {
        topic = parseTopic(commit);
    }
    parseHashtags(commit);
    if (submissionId == null) {
        submissionId = parseSubmissionId(commit);
    }
    ObjectId currRev = parseRevision(commit);
    if (currRev != null) {
        parsePatchSet(psId, currRev, accountId, ts);
    }
    parseGroups(psId, commit);
    if (submitRecords.isEmpty()) {
        // Only parse the most recent set of submit records; any older ones are
        // still there, but not currently used.
        parseSubmitRecords(commit.getFooterLineValues(FOOTER_SUBMITTED_WITH));
    }
    for (String line : commit.getFooterLineValues(FOOTER_LABEL)) {
        parseApproval(psId, accountId, ts, line);
    }
    for (ReviewerStateInternal state : ReviewerStateInternal.values()) {
        for (String line : commit.getFooterLineValues(state.getFooterKey())) {
            parseReviewer(state, line);
        }
    // Don't update timestamp when a reviewer was added, matching RevewDb
    // behavior.
    }
    if (lastUpdatedOn == null || ts.after(lastUpdatedOn)) {
        lastUpdatedOn = ts;
    }
}
#end_block

#method_before
private ChangeMessage parseChangeMessage(PatchSet.Id psId, Account.Id accountId, ChangeNotesCommit commit, Timestamp ts) {
    byte[] raw = commit.getRawBuffer();
    int size = raw.length;
    Charset enc = RawParseUtils.parseEncoding(raw);
    int subjectStart = RawParseUtils.commitMessage(raw, 0);
    if (subjectStart < 0 || subjectStart >= size) {
        return null;
    }
    int subjectEnd = RawParseUtils.endOfParagraph(raw, subjectStart);
    if (subjectEnd == size) {
        return null;
    }
    int changeMessageStart;
    if (raw[subjectEnd] == '\n') {
        // \n\n ends paragraph
        changeMessageStart = subjectEnd + 2;
    } else if (raw[subjectEnd] == '\r') {
        // \r\n\r\n ends paragraph
        changeMessageStart = subjectEnd + 4;
    } else {
        return null;
    }
    int ptr = size - 1;
    int changeMessageEnd = -1;
    while (ptr > changeMessageStart) {
        ptr = RawParseUtils.prevLF(raw, ptr, '\r');
        if (ptr == -1) {
            break;
        }
        if (raw[ptr] == '\n') {
            changeMessageEnd = ptr - 1;
            break;
        } else if (raw[ptr] == '\r') {
            changeMessageEnd = ptr - 3;
            break;
        }
    }
    if (ptr <= changeMessageStart) {
        return null;
    }
    String changeMsgString = RawParseUtils.decode(enc, raw, changeMessageStart, changeMessageEnd + 1);
    ChangeMessage changeMessage = new ChangeMessage(new ChangeMessage.Key(psId.getParentKey(), commit.name()), accountId, ts, psId);
    changeMessage.setMessage(changeMsgString);
    changeMessage.setTag(tag);
    changeMessagesByPatchSet.put(psId, changeMessage);
    allChangeMessages.add(changeMessage);
    return changeMessage;
}
#method_after
private void parseChangeMessage(PatchSet.Id psId, Account.Id accountId, ChangeNotesCommit commit, Timestamp ts) {
    byte[] raw = commit.getRawBuffer();
    int size = raw.length;
    Charset enc = RawParseUtils.parseEncoding(raw);
    int subjectStart = RawParseUtils.commitMessage(raw, 0);
    if (subjectStart < 0 || subjectStart >= size) {
        return;
    }
    int subjectEnd = RawParseUtils.endOfParagraph(raw, subjectStart);
    if (subjectEnd == size) {
        return;
    }
    int changeMessageStart;
    if (raw[subjectEnd] == '\n') {
        // \n\n ends paragraph
        changeMessageStart = subjectEnd + 2;
    } else if (raw[subjectEnd] == '\r') {
        // \r\n\r\n ends paragraph
        changeMessageStart = subjectEnd + 4;
    } else {
        return;
    }
    int ptr = size - 1;
    int changeMessageEnd = -1;
    while (ptr > changeMessageStart) {
        ptr = RawParseUtils.prevLF(raw, ptr, '\r');
        if (ptr == -1) {
            break;
        }
        if (raw[ptr] == '\n') {
            changeMessageEnd = ptr - 1;
            break;
        } else if (raw[ptr] == '\r') {
            changeMessageEnd = ptr - 3;
            break;
        }
    }
    if (ptr <= changeMessageStart) {
        return;
    }
    String changeMsgString = RawParseUtils.decode(enc, raw, changeMessageStart, changeMessageEnd + 1);
    ChangeMessage changeMessage = new ChangeMessage(new ChangeMessage.Key(psId.getParentKey(), commit.name()), accountId, ts, psId);
    changeMessage.setMessage(changeMsgString);
    changeMessage.setTag(tag);
    changeMessagesByPatchSet.put(psId, changeMessage);
    allChangeMessages.add(changeMessage);
}
#end_block

#method_before
private boolean includedInOne(final Collection<Ref> refs) throws IOException {
    parseCommits(refs);
    List<RevCommit> before = Lists.newLinkedList();
    List<RevCommit> after = Lists.newLinkedList();
    partition(before, after);
    // Within the "before" set we are trying to handle cases arising from clock skew
    return !includedIn(after, 1).isEmpty() || !includedIn(before, 1).isEmpty();
}
#method_after
private boolean includedInOne(final Collection<Ref> refs) throws IOException {
    parseCommits(refs);
    List<RevCommit> before = new LinkedList<>();
    List<RevCommit> after = new LinkedList<>();
    partition(before, after);
    // Within the "before" set we are trying to handle cases arising from clock skew
    return !includedIn(after, 1).isEmpty() || !includedIn(before, 1).isEmpty();
}
#end_block

#method_before
void setContext(final int context) {
    operation(new Runnable() {

        @Override
        public void run() {
            getSkipManager().removeAll();
            getSkipManager().render(context, diff);
            updateRenderEntireFile();
        }
    });
}
#method_after
void setContext(final int context) {
    operation(new Runnable() {

        @Override
        public void run() {
            skipManager.removeAll();
            skipManager.render(context, diff);
            updateRenderEntireFile();
        }
    });
}
#end_block

#method_before
Runnable maybePrevVimSearch(final CodeMirror cm) {
    return new Runnable() {

        @Override
        public void run() {
            if (cm.vim().hasSearchHighlight()) {
                cm.vim().handleKey("n");
            } else {
                getCommentManager().commentNav(cm, Direction.NEXT).run();
            }
        }
    };
}
#method_after
Runnable maybePrevVimSearch(final CodeMirror cm) {
    return new Runnable() {

        @Override
        public void run() {
            if (cm.vim().hasSearchHighlight()) {
                cm.vim().handleKey("N");
            } else {
                getCommentManager().commentNav(cm, Direction.NEXT).run();
            }
        }
    };
}
#end_block

#method_before
void reloadDiffInfo() {
    final int id = ++reloadVersionId;
    DiffApi.diff(revision, path).base(base).wholeFile().intraline(prefs.intralineDifference()).ignoreWhitespace(prefs.ignoreWhitespace()).get(new GerritCallback<DiffInfo>() {

        @Override
        public void onSuccess(DiffInfo diffInfo) {
            if (id == reloadVersionId && isAttached()) {
                diff = diffInfo;
                operation(new Runnable() {

                    @Override
                    public void run() {
                        getSkipManager().removeAll();
                        getChunkManager().reset();
                        getDiffTable().scrollbar.removeDiffAnnotations();
                        setShowIntraline(prefs.intralineDifference());
                        render(diff);
                        getSkipManager().render(prefs.context(), diff);
                    }
                });
            }
        }
    });
}
#method_after
void reloadDiffInfo() {
    final int id = ++reloadVersionId;
    DiffApi.diff(revision, path).base(base).wholeFile().intraline(prefs.intralineDifference()).ignoreWhitespace(prefs.ignoreWhitespace()).get(new GerritCallback<DiffInfo>() {

        @Override
        public void onSuccess(DiffInfo diffInfo) {
            if (id == reloadVersionId && isAttached()) {
                diff = diffInfo;
                operation(new Runnable() {

                    @Override
                    public void run() {
                        skipManager.removeAll();
                        getChunkManager().reset();
                        getDiffTable().scrollbar.removeDiffAnnotations();
                        setShowIntraline(prefs.intralineDifference());
                        render(diff);
                        skipManager.render(prefs.context(), diff);
                    }
                });
            }
        }
    });
}
#end_block

#method_before
private GutterClickHandler onGutterClick(final CodeMirror cm) {
    return new GutterClickHandler() {

        @Override
        public void handle(CodeMirror instance, final int line, final String gutterClass, NativeEvent clickEvent) {
            if (clickEvent.getButton() == NativeEvent.BUTTON_LEFT && !clickEvent.getMetaKey() && !clickEvent.getAltKey() && !clickEvent.getCtrlKey() && !clickEvent.getShiftKey()) {
                cm.setCursor(Pos.create(line));
                Scheduler.get().scheduleDeferred(new ScheduledCommand() {

                    @Override
                    public void execute() {
                        getCommentManager().newDraftOnGutterClick(cm, gutterClass, line + 1);
                    }
                });
            }
        }
    };
}
#method_after
private GutterClickHandler onGutterClick(final CodeMirror cm) {
    return new GutterClickHandler() {

        @Override
        public void handle(CodeMirror instance, final int line, final String gutterClass, NativeEvent clickEvent) {
            if (Element.as(clickEvent.getEventTarget()).hasClassName(getLineNumberClassName()) && clickEvent.getButton() == NativeEvent.BUTTON_LEFT && !clickEvent.getMetaKey() && !clickEvent.getAltKey() && !clickEvent.getCtrlKey() && !clickEvent.getShiftKey()) {
                cm.setCursor(Pos.create(line));
                Scheduler.get().scheduleDeferred(new ScheduledCommand() {

                    @Override
                    public void execute() {
                        getCommentManager().newDraftOnGutterClick(cm, gutterClass, line + 1);
                    }
                });
            }
        }
    };
}
#end_block

#method_before
LineOnOtherInfo lineOnOther(DisplaySide side, int line) {
    return getChunkManager().getLineMapper().lineOnOther(side, line);
}
#method_after
LineOnOtherInfo lineOnOther(DisplaySide side, int line) {
    return getChunkManager().lineMapper.lineOnOther(side, line);
}
#end_block

#method_before
@Override
public void postRun() throws Exception {
    AuthType authType = flags.cfg.getEnum(AuthType.values(), "auth", null, "type", null);
    if (authType != AuthType.DEVELOPMENT_BECOME_ANY_ACCOUNT) {
        return;
    }
    try (ReviewDb db = dbFactory.open()) {
        if (db.accounts().anyAccounts().toList().isEmpty()) {
            ui.header("Gerrit Administrator");
            if (ui.yesno(true, "Create administrator user")) {
                Account.Id id = new Account.Id(db.nextAccountId());
                String username = ui.readString("admin", "username");
                String name = ui.readString("Administrator", "name");
                String httpPassword = ui.readString("secret", "HTTP password");
                AccountSshKey sshKey = readSshKey(id);
                String email = readEmail(sshKey);
                AccountExternalId extUser = new AccountExternalId(id, new AccountExternalId.Key(AccountExternalId.SCHEME_USERNAME, username));
                if (!Strings.isNullOrEmpty(httpPassword)) {
                    extUser.setPassword(httpPassword);
                }
                db.accountExternalIds().insert(Collections.singleton(extUser));
                if (email != null) {
                    AccountExternalId extMailto = new AccountExternalId(id, new AccountExternalId.Key(AccountExternalId.SCHEME_MAILTO, email));
                    extMailto.setEmailAddress(email);
                    db.accountExternalIds().insert(Collections.singleton(extMailto));
                }
                Account a = new Account(id, TimeUtil.nowTs());
                a.setFullName(name);
                a.setPreferredEmail(email);
                db.accounts().insert(Collections.singleton(a));
                AccountGroupName adminGroup = db.accountGroupNames().get(new AccountGroup.NameKey("Administrators"));
                AccountGroupMember m = new AccountGroupMember(new AccountGroupMember.Key(id, adminGroup.getId()));
                db.accountGroupMembers().insert(Collections.singleton(m));
                if (sshKey != null) {
                    VersionedAuthorizedKeysOnInit authorizedKeys = authorizedKeysFactory.create(id).load();
                    authorizedKeys.addKey(sshKey.getSshPublicKey());
                    authorizedKeys.save("Added SSH key for initial admin user");
                    db.accountSshKeys().insert(Collections.singleton(sshKey));
                }
            }
        }
    }
}
#method_after
@Override
public void postRun() throws Exception {
    AuthType authType = flags.cfg.getEnum(AuthType.values(), "auth", null, "type", null);
    if (authType != AuthType.DEVELOPMENT_BECOME_ANY_ACCOUNT) {
        return;
    }
    try (ReviewDb db = dbFactory.open()) {
        if (db.accounts().anyAccounts().toList().isEmpty()) {
            ui.header("Gerrit Administrator");
            if (ui.yesno(true, "Create administrator user")) {
                Account.Id id = new Account.Id(db.nextAccountId());
                String username = ui.readString("admin", "username");
                String name = ui.readString("Administrator", "name");
                String httpPassword = ui.readString("secret", "HTTP password");
                AccountSshKey sshKey = readSshKey(id);
                String email = readEmail(sshKey);
                AccountExternalId extUser = new AccountExternalId(id, new AccountExternalId.Key(AccountExternalId.SCHEME_USERNAME, username));
                if (!Strings.isNullOrEmpty(httpPassword)) {
                    extUser.setPassword(httpPassword);
                }
                db.accountExternalIds().insert(Collections.singleton(extUser));
                if (email != null) {
                    AccountExternalId extMailto = new AccountExternalId(id, new AccountExternalId.Key(AccountExternalId.SCHEME_MAILTO, email));
                    extMailto.setEmailAddress(email);
                    db.accountExternalIds().insert(Collections.singleton(extMailto));
                }
                Account a = new Account(id, TimeUtil.nowTs());
                a.setFullName(name);
                a.setPreferredEmail(email);
                db.accounts().insert(Collections.singleton(a));
                AccountGroupName adminGroup = db.accountGroupNames().get(new AccountGroup.NameKey("Administrators"));
                AccountGroupMember m = new AccountGroupMember(new AccountGroupMember.Key(id, adminGroup.getId()));
                db.accountGroupMembers().insert(Collections.singleton(m));
                if (sshKey != null) {
                    VersionedAuthorizedKeysOnInit authorizedKeys = authorizedKeysFactory.create(id).load();
                    authorizedKeys.addKey(sshKey.getSshPublicKey());
                    authorizedKeys.save("Added SSH key for initial admin user\n");
                }
            }
        }
    }
}
#end_block

#method_before
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    revision = getRevision();
    super.onLoad();
}
#method_after
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    revision = getRevision();
    keys = AuthorizedKeys.parse(accountId, readUTF8(AuthorizedKeys.FILE_NAME));
}
#end_block

#method_before
public void save(String message) throws IOException, ConfigInvalidException {
    save(new PersonIdent("Gerrit Initialization", "init@gerrit"), message);
}
#method_after
public void save(String message) throws IOException {
    save(new PersonIdent("Gerrit Initialization", "init@gerrit"), message);
}
#end_block

#method_before
private void save(PersonIdent ident, String msg) throws IOException, ConfigInvalidException {
    File path = getPath();
    if (path == null) {
        throw new IOException(project + " does not exist.");
    }
    try (Repository repo = new FileRepository(path)) {
        inserter = repo.newObjectInserter();
        reader = repo.newObjectReader();
        try (RevWalk rw = new RevWalk(reader)) {
            RevTree srcTree = revision != null ? rw.parseTree(revision) : null;
            newTree = readTree(srcTree);
            CommitBuilder commit = new CommitBuilder();
            commit.setAuthor(ident);
            commit.setCommitter(ident);
            commit.setMessage(msg);
            super.onSave(commit);
            ObjectId res = newTree.writeTree(inserter);
            if (res.equals(srcTree)) {
                return;
            }
            commit.setTreeId(res);
            if (revision != null) {
                commit.addParentId(revision);
            }
            ObjectId newRevision = inserter.insert(commit);
            updateRef(repo, ident, newRevision, "commit: " + msg);
            revision = newRevision;
        } finally {
            if (inserter != null) {
                inserter.close();
                inserter = null;
            }
            if (reader != null) {
                reader.close();
                reader = null;
            }
        }
    }
}
#method_after
private void save(PersonIdent ident, String msg) throws IOException {
    File path = getPath();
    if (path == null) {
        throw new IOException(project + " does not exist.");
    }
    try (Repository repo = new FileRepository(path);
        ObjectInserter i = repo.newObjectInserter();
        ObjectReader r = repo.newObjectReader();
        RevWalk rw = new RevWalk(reader)) {
        inserter = i;
        reader = r;
        RevTree srcTree = revision != null ? rw.parseTree(revision) : null;
        newTree = readTree(srcTree);
        CommitBuilder commit = new CommitBuilder();
        commit.setAuthor(ident);
        commit.setCommitter(ident);
        commit.setMessage(msg);
        onSave(commit);
        ObjectId res = newTree.writeTree(inserter);
        if (res.equals(srcTree)) {
            return;
        }
        commit.setTreeId(res);
        if (revision != null) {
            commit.addParentId(revision);
        }
        ObjectId newRevision = inserter.insert(commit);
        updateRef(repo, ident, newRevision, "commit: " + msg);
        revision = newRevision;
    } finally {
        inserter = null;
        reader = null;
    }
}
#end_block

#method_before
@Override
public Response<?> apply(AccountResource.SshKey rsrc, Input input) throws AuthException, OrmException, RepositoryNotFoundException, IOException, ConfigInvalidException {
    if (self.get() != rsrc.getUser() && !self.get().getCapabilities().canAdministrateServer()) {
        throw new AuthException("not allowed to delete SSH keys");
    }
    if (readFromGit) {
        try (MetaDataUpdate md = metaDataUpdateFactory.get().create(allUsersName.get());
            Repository git = repoManager.openRepository(allUsersName.get())) {
            VersionedAuthorizedKeys authorizedKeys = new VersionedAuthorizedKeys(rsrc.getUser().getAccountId());
            authorizedKeys.load(md);
            if (authorizedKeys.deleteKey(rsrc.getSshKey().getKey().get())) {
                authorizedKeys.commit(md);
            }
        }
    } else {
        List<AccountSshKey> keys = readFromDb(dbProvider.get(), rsrc.getUser().getAccountId());
        if (keys.remove(rsrc.getSshKey())) {
            try (MetaDataUpdate md = metaDataUpdateFactory.get().create(allUsersName.get());
                Repository git = repoManager.openRepository(allUsersName.get())) {
                VersionedAuthorizedKeys authorizedKeys = new VersionedAuthorizedKeys(rsrc.getUser().getAccountId());
                authorizedKeys.load(md);
                authorizedKeys.setKeys(keys);
                authorizedKeys.commit(md);
            }
        }
    }
    dbProvider.get().accountSshKeys().deleteKeys(Collections.singleton(rsrc.getSshKey().getKey()));
    sshKeyCache.evict(rsrc.getUser().getUserName());
    return Response.none();
}
#method_after
@Override
public Response<?> apply(AccountResource.SshKey rsrc, Input input) throws AuthException, OrmException, RepositoryNotFoundException, IOException, ConfigInvalidException {
    if (self.get() != rsrc.getUser() && !self.get().getCapabilities().canAdministrateServer()) {
        throw new AuthException("not allowed to delete SSH keys");
    }
    authorizedKeys.deleteKey(rsrc.getUser().getAccountId(), rsrc.getSshKey().getKey().get());
    sshKeyCache.evict(rsrc.getUser().getUserName());
    return Response.none();
}
#end_block

#method_before
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    keys = new TreeMap<>();
    int seq = 1;
    for (String line : readUTF8(FILE_NAME).split("\\r?\\n")) {
        line = line.trim();
        if (line.isEmpty()) {
            continue;
        } else if (line.startsWith(INVALID_KEY_COMMENT)) {
            String pub = line.substring(INVALID_KEY_COMMENT.length());
            AccountSshKey key = new AccountSshKey(new AccountSshKey.Id(accountId, seq++), pub);
            key.setInvalid();
            keys.put(key.getKey().get(), Optional.of(key));
        } else if (line.startsWith(DELETED_KEY_COMMENT)) {
            keys.put(seq++, Optional.<AccountSshKey>absent());
        } else if (line.startsWith("#")) {
            continue;
        } else {
            AccountSshKey key = new AccountSshKey(new AccountSshKey.Id(accountId, seq++), line);
            keys.put(key.getKey().get(), Optional.of(key));
        }
    }
}
#method_after
@Override
protected void onLoad() throws IOException {
    keys = AuthorizedKeys.parse(accountId, readUTF8(AuthorizedKeys.FILE_NAME));
}
#end_block

#method_before
@Override
protected boolean onSave(CommitBuilder commit) throws IOException, ConfigInvalidException {
    if (commit.getMessage() == null || "".equals(commit.getMessage())) {
        commit.setMessage("Updated SSH keys\n");
    }
    StringBuilder b = new StringBuilder();
    for (Optional<AccountSshKey> key : keys.values()) {
        if (key.isPresent()) {
            if (!key.get().isValid()) {
                b.append(INVALID_KEY_COMMENT);
            }
            b.append(key.get().getSshPublicKey().trim());
        } else {
            b.append(DELETED_KEY_COMMENT);
        }
        b.append("\n");
    }
    saveUTF8(FILE_NAME, b.toString());
    return true;
}
#method_after
@Override
protected boolean onSave(CommitBuilder commit) throws IOException {
    if (Strings.isNullOrEmpty(commit.getMessage())) {
        commit.setMessage("Updated SSH keys\n");
    }
    saveUTF8(AuthorizedKeys.FILE_NAME, AuthorizedKeys.serialize(keys));
    return true;
}
#end_block

#method_before
public List<AccountSshKey> getKeys() {
    checkState(keys != null, "SSH keys not loaded yet");
    List<AccountSshKey> result = new ArrayList<>();
    for (Optional<AccountSshKey> key : keys.values()) {
        if (key.isPresent()) {
            result.add(key.get());
        }
    }
    return result;
}
#method_after
private List<AccountSshKey> getKeys() {
    checkLoaded();
    return Lists.newArrayList(Optional.presentInstances(keys));
}
#end_block

#method_before
public AccountSshKey getKey(int seq) {
    checkState(keys != null, "SSH keys not loaded yet");
    Optional<AccountSshKey> key = keys.get(seq);
    return key.isPresent() ? key.get() : null;
}
#method_after
private AccountSshKey getKey(int seq) {
    checkLoaded();
    Optional<AccountSshKey> key = keys.get(seq - 1);
    return key.orNull();
}
#end_block

#method_before
public AccountSshKey addKey(String pub) {
    checkState(keys != null, "SSH keys not loaded yet");
    int seq = keys.isEmpty() ? 1 : keys.lastKey() + 1;
    AccountSshKey key = new AccountSshKey(new AccountSshKey.Id(accountId, seq), pub);
    keys.put(seq, Optional.of(key));
    return key;
}
#method_after
private AccountSshKey addKey(String pub) throws InvalidSshKeyException {
    checkLoaded();
    int seq = keys.size() + 1;
    AccountSshKey.Id keyId = new AccountSshKey.Id(accountId, seq);
    AccountSshKey key = sshKeyCreator.create(keyId, pub);
    keys.add(Optional.of(key));
    return key;
}
#end_block

#method_before
public boolean deleteKey(int seq) {
    checkState(keys != null, "SSH keys not loaded yet");
    if (keys.containsKey(seq) && keys.get(seq).isPresent()) {
        keys.put(seq, Optional.<AccountSshKey>absent());
        return true;
    }
    return false;
}
#method_after
private boolean deleteKey(int seq) {
    checkLoaded();
    if (seq <= keys.size() && keys.get(seq - 1).isPresent()) {
        keys.set(seq - 1, Optional.<AccountSshKey>absent());
        return true;
    }
    return false;
}
#end_block

#method_before
public void markKeyInvalid(int seq) {
    checkState(keys != null, "SSH keys not loaded yet");
    AccountSshKey key = getKey(seq);
    if (key != null) {
        key.setInvalid();
    }
}
#method_after
private boolean markKeyInvalid(int seq) {
    checkLoaded();
    AccountSshKey key = getKey(seq);
    if (key != null && key.isValid()) {
        key.setInvalid();
        return true;
    }
    return false;
}
#end_block

#method_before
public void setKeys(List<AccountSshKey> newKeys) {
    keys = new TreeMap<>();
    for (AccountSshKey key : newKeys) {
        keys.put(key.getKey().get(), Optional.of(key));
    }
    for (int seq = 1; seq < keys.lastKey(); seq++) {
        if (!keys.containsKey(seq)) {
            keys.put(seq, Optional.<AccountSshKey>absent());
        }
    }
}
#method_after
public void setKeys(Collection<AccountSshKey> newKeys) {
    Ordering<AccountSshKey> o = Ordering.natural().onResultOf(new Function<AccountSshKey, Integer>() {

        @Override
        public Integer apply(AccountSshKey sshKey) {
            return sshKey.getKey().get();
        }
    });
    keys = Collections.nCopies(o.max(newKeys).getKey().get(), Optional.<AccountSshKey>absent());
    for (AccountSshKey key : newKeys) {
        keys.set(key.getKey().get() - 1, Optional.of(key));
    }
}
#end_block

#method_before
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            cache(CACHE_NAME, String.class, new TypeLiteral<Iterable<SshKeyCacheEntry>>() {
            }).loader(Loader.class);
            bind(SshKeyCacheImpl.class);
            bind(SshKeyCache.class).to(SshKeyCacheImpl.class);
        }
    };
}
#method_after
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            cache(CACHE_NAME, String.class, new TypeLiteral<Iterable<SshKeyCacheEntry>>() {
            }).loader(Loader.class);
            bind(SshKeyCacheImpl.class);
            bind(SshKeyCache.class).to(SshKeyCacheImpl.class);
            bind(SshKeyCreator.class).to(SshKeyCreatorImpl.class);
        }
    };
}
#end_block

#method_before
@Override
public Iterable<SshKeyCacheEntry> load(String username) throws Exception {
    try (ReviewDb db = schema.open()) {
        final AccountExternalId.Key key = new AccountExternalId.Key(SCHEME_USERNAME, username);
        final AccountExternalId user = db.accountExternalIds().get(key);
        if (user == null) {
            return NO_SUCH_USER;
        }
        final List<SshKeyCacheEntry> kl = new ArrayList<>(4);
        for (AccountSshKey k : readSshKeys(db, user.getAccountId())) {
            if (k.isValid()) {
                add(db, kl, k);
            }
        }
        if (kl.isEmpty()) {
            return NO_KEYS;
        }
        return Collections.unmodifiableList(kl);
    }
}
#method_after
@Override
public Iterable<SshKeyCacheEntry> load(String username) throws Exception {
    try (ReviewDb db = schema.open()) {
        AccountExternalId.Key key = new AccountExternalId.Key(SCHEME_USERNAME, username);
        AccountExternalId user = db.accountExternalIds().get(key);
        if (user == null) {
            return NO_SUCH_USER;
        }
        List<SshKeyCacheEntry> kl = new ArrayList<>(4);
        for (AccountSshKey k : authorizedKeys.getKeys(user.getAccountId())) {
            if (k.isValid()) {
                add(kl, k);
            }
        }
        if (kl.isEmpty()) {
            return NO_KEYS;
        }
        return Collections.unmodifiableList(kl);
    }
}
#end_block

#method_before
private void add(ReviewDb db, List<SshKeyCacheEntry> kl, AccountSshKey k) {
    try {
        kl.add(new SshKeyCacheEntry(k.getKey(), SshUtil.parse(k)));
    } catch (OutOfMemoryError e) {
        // 
        throw e;
    } catch (Throwable e) {
        markInvalid(db, k);
    }
}
#method_after
private void add(List<SshKeyCacheEntry> kl, AccountSshKey k) {
    try {
        kl.add(new SshKeyCacheEntry(k.getKey(), SshUtil.parse(k)));
    } catch (OutOfMemoryError e) {
        // 
        throw e;
    } catch (Throwable e) {
        markInvalid(k);
    }
}
#end_block

#method_before
private void markInvalid(ReviewDb db, AccountSshKey k) {
    try {
        log.info("Flagging SSH key " + k.getKey() + " invalid");
        k.setInvalid();
        db.accountSshKeys().update(Collections.singleton(k));
        List<AccountSshKey> keys = readFromDb(db, k.getAccount());
        try (MetaDataUpdate md = metaDataUpdateFactory.get().create(allUsersName.get(), userFactory.create(k.getAccount()));
            Repository git = repoManager.openRepository(allUsersName.get())) {
            VersionedAuthorizedKeys authorizedKeys = new VersionedAuthorizedKeys(k.getAccount());
            authorizedKeys.load(md);
            authorizedKeys.setKeys(keys);
            authorizedKeys.commit(md);
        }
    } catch (OrmException | IOException | ConfigInvalidException e) {
        log.error("Failed to mark SSH key" + k.getKey() + " invalid", e);
    }
}
#method_after
private void markInvalid(AccountSshKey k) {
    try {
        log.info("Flagging SSH key " + k.getKey() + " invalid");
        authorizedKeys.markKeyInvalid(k.getAccount(), k.getKey().get());
        k.setInvalid();
    } catch (IOException | ConfigInvalidException e) {
        log.error("Failed to mark SSH key" + k.getKey() + " invalid", e);
    }
}
#end_block

#method_before
public AccountResource.SshKey parse(IdentifiedUser user, IdString id) throws ResourceNotFoundException, OrmException, IOException, ConfigInvalidException {
    try {
        int seq = Integer.parseInt(id.get(), 10);
        AccountSshKey sshKey;
        if (readFromGit) {
            try (Repository git = repoManager.openRepository(allUsersName.get())) {
                VersionedAuthorizedKeys authorizedKeys = new VersionedAuthorizedKeys(user.getAccountId());
                authorizedKeys.load(git);
                sshKey = authorizedKeys.getKey(seq);
            }
        } else {
            sshKey = dbProvider.get().accountSshKeys().get(new AccountSshKey.Id(user.getAccountId(), seq));
        }
        if (sshKey == null) {
            throw new ResourceNotFoundException(id);
        }
        return new AccountResource.SshKey(user, sshKey);
    } catch (NumberFormatException e) {
        throw new ResourceNotFoundException(id);
    }
}
#method_after
public AccountResource.SshKey parse(IdentifiedUser user, IdString id) throws ResourceNotFoundException, IOException, ConfigInvalidException {
    try {
        int seq = Integer.parseInt(id.get(), 10);
        AccountSshKey sshKey = authorizedKeys.getKey(user.getAccountId(), seq);
        if (sshKey == null) {
            throw new ResourceNotFoundException(id);
        }
        return new AccountResource.SshKey(user, sshKey);
    } catch (NumberFormatException e) {
        throw new ResourceNotFoundException(id);
    }
}
#end_block

#method_before
public Response<SshKeyInfo> apply(IdentifiedUser user, Input input) throws BadRequestException, OrmException, IOException, ConfigInvalidException {
    if (input == null) {
        input = new Input();
    }
    if (input.raw == null) {
        throw new BadRequestException("SSH public key missing");
    }
    final RawInput rawKey = input.raw;
    String sshPublicKey = new ByteSource() {

        @Override
        public InputStream openStream() throws IOException {
            return rawKey.getInputStream();
        }
    }.asCharSource(UTF_8).read();
    AccountSshKey sshKey;
    if (readFromGit) {
        try (MetaDataUpdate md = metaDataUpdateFactory.get().create(allUsersName.get());
            Repository git = repoManager.openRepository(allUsersName.get())) {
            VersionedAuthorizedKeys authorizedKeys = new VersionedAuthorizedKeys(user.getAccountId());
            authorizedKeys.load(md);
            sshKey = authorizedKeys.addKey(sshPublicKey);
            authorizedKeys.commit(md);
        }
    } else {
        List<AccountSshKey> keys = readFromDb(dbProvider.get(), user.getAccountId());
        int max = keys.isEmpty() ? 0 : keys.get(keys.size() - 1).getKey().get();
        try {
            sshKey = sshKeyCache.create(new AccountSshKey.Id(user.getAccountId(), max + 1), sshPublicKey);
            keys.add(sshKey);
            try (MetaDataUpdate md = metaDataUpdateFactory.get().create(allUsersName.get());
                Repository git = repoManager.openRepository(allUsersName.get())) {
                VersionedAuthorizedKeys authorizedKeys = new VersionedAuthorizedKeys(user.getAccountId());
                authorizedKeys.load(md);
                authorizedKeys.setKeys(keys);
                authorizedKeys.commit(md);
            }
        } catch (InvalidSshKeyException e) {
            throw new BadRequestException(e.getMessage());
        }
    }
    dbProvider.get().accountSshKeys().insert(Collections.singleton(sshKey));
    try {
        addKeyFactory.create(user, sshKey).send();
    } catch (EmailException e) {
        log.error("Cannot send SSH key added message to " + user.getAccount().getPreferredEmail(), e);
    }
    sshKeyCache.evict(user.getUserName());
    return Response.<SshKeyInfo>created(GetSshKeys.newSshKeyInfo(sshKey));
}
#method_after
public Response<SshKeyInfo> apply(IdentifiedUser user, Input input) throws BadRequestException, IOException, ConfigInvalidException {
    if (input == null) {
        input = new Input();
    }
    if (input.raw == null) {
        throw new BadRequestException("SSH public key missing");
    }
    final RawInput rawKey = input.raw;
    String sshPublicKey = new ByteSource() {

        @Override
        public InputStream openStream() throws IOException {
            return rawKey.getInputStream();
        }
    }.asCharSource(UTF_8).read();
    try {
        AccountSshKey sshKey = authorizedKeys.addKey(user.getAccountId(), sshPublicKey);
        try {
            addKeyFactory.create(user, sshKey).send();
        } catch (EmailException e) {
            log.error("Cannot send SSH key added message to " + user.getAccount().getPreferredEmail(), e);
        }
        sshKeyCache.evict(user.getUserName());
        return Response.<SshKeyInfo>created(GetSshKeys.newSshKeyInfo(sshKey));
    } catch (InvalidSshKeyException e) {
        throw new BadRequestException(e.getMessage());
    }
}
#end_block

#method_before
@Override
public Response<AccountInfo> apply(TopLevelResource rsrc, Input input) throws BadRequestException, ResourceConflictException, UnprocessableEntityException, OrmException, IOException, ConfigInvalidException {
    if (input == null) {
        input = new Input();
    }
    if (input.username != null && !username.equals(input.username)) {
        throw new BadRequestException("username must match URL");
    }
    if (!username.matches(Account.USER_NAME_PATTERN)) {
        throw new BadRequestException("Username '" + username + "'" + " must contain only letters, numbers, _, - or .");
    }
    Set<AccountGroup.Id> groups = parseGroups(input.groups);
    Account.Id id = new Account.Id(db.nextAccountId());
    AccountSshKey key = createSshKey(id, input.sshKey);
    AccountExternalId extUser = new AccountExternalId(id, new AccountExternalId.Key(AccountExternalId.SCHEME_USERNAME, username));
    if (input.httpPassword != null) {
        extUser.setPassword(input.httpPassword);
    }
    if (db.accountExternalIds().get(extUser.getKey()) != null) {
        throw new ResourceConflictException("username '" + username + "' already exists");
    }
    if (input.email != null) {
        if (db.accountExternalIds().get(getEmailKey(input.email)) != null) {
            throw new UnprocessableEntityException("email '" + input.email + "' already exists");
        }
        if (!EmailValidator.getInstance().isValid(input.email)) {
            throw new BadRequestException("invalid email address");
        }
    }
    LinkedList<AccountExternalId> externalIds = new LinkedList<>();
    externalIds.add(extUser);
    for (AccountExternalIdCreator c : externalIdCreators) {
        externalIds.addAll(c.create(id, username, input.email));
    }
    try {
        db.accountExternalIds().insert(externalIds);
    } catch (OrmDuplicateKeyException duplicateKey) {
        throw new ResourceConflictException("username '" + username + "' already exists");
    }
    if (input.email != null) {
        AccountExternalId extMailto = new AccountExternalId(id, getEmailKey(input.email));
        extMailto.setEmailAddress(input.email);
        try {
            db.accountExternalIds().insert(Collections.singleton(extMailto));
        } catch (OrmDuplicateKeyException duplicateKey) {
            try {
                db.accountExternalIds().delete(Collections.singleton(extUser));
            } catch (OrmException cleanupError) {
            // Ignored
            }
            throw new UnprocessableEntityException("email '" + input.email + "' already exists");
        }
    }
    Account a = new Account(id, TimeUtil.nowTs());
    a.setFullName(input.name);
    a.setPreferredEmail(input.email);
    db.accounts().insert(Collections.singleton(a));
    for (AccountGroup.Id groupId : groups) {
        AccountGroupMember m = new AccountGroupMember(new AccountGroupMember.Key(id, groupId));
        auditService.dispatchAddAccountsToGroup(currentUser.get().getAccountId(), Collections.singleton(m));
        db.accountGroupMembers().insert(Collections.singleton(m));
    }
    if (key != null) {
        addSshKey(db, key, username);
    }
    accountCache.evictByUsername(username);
    byEmailCache.evict(input.email);
    AccountLoader loader = infoLoader.create(true);
    AccountInfo info = loader.get(id);
    loader.fill();
    return Response.created(info);
}
#method_after
@Override
public Response<AccountInfo> apply(TopLevelResource rsrc, Input input) throws BadRequestException, ResourceConflictException, UnprocessableEntityException, OrmException, IOException, ConfigInvalidException {
    if (input == null) {
        input = new Input();
    }
    if (input.username != null && !username.equals(input.username)) {
        throw new BadRequestException("username must match URL");
    }
    if (!username.matches(Account.USER_NAME_PATTERN)) {
        throw new BadRequestException("Username '" + username + "'" + " must contain only letters, numbers, _, - or .");
    }
    Set<AccountGroup.Id> groups = parseGroups(input.groups);
    Account.Id id = new Account.Id(db.nextAccountId());
    AccountExternalId extUser = new AccountExternalId(id, new AccountExternalId.Key(AccountExternalId.SCHEME_USERNAME, username));
    if (input.httpPassword != null) {
        extUser.setPassword(input.httpPassword);
    }
    if (db.accountExternalIds().get(extUser.getKey()) != null) {
        throw new ResourceConflictException("username '" + username + "' already exists");
    }
    if (input.email != null) {
        if (db.accountExternalIds().get(getEmailKey(input.email)) != null) {
            throw new UnprocessableEntityException("email '" + input.email + "' already exists");
        }
        if (!EmailValidator.getInstance().isValid(input.email)) {
            throw new BadRequestException("invalid email address");
        }
    }
    LinkedList<AccountExternalId> externalIds = new LinkedList<>();
    externalIds.add(extUser);
    for (AccountExternalIdCreator c : externalIdCreators) {
        externalIds.addAll(c.create(id, username, input.email));
    }
    try {
        db.accountExternalIds().insert(externalIds);
    } catch (OrmDuplicateKeyException duplicateKey) {
        throw new ResourceConflictException("username '" + username + "' already exists");
    }
    if (input.email != null) {
        AccountExternalId extMailto = new AccountExternalId(id, getEmailKey(input.email));
        extMailto.setEmailAddress(input.email);
        try {
            db.accountExternalIds().insert(Collections.singleton(extMailto));
        } catch (OrmDuplicateKeyException duplicateKey) {
            try {
                db.accountExternalIds().delete(Collections.singleton(extUser));
            } catch (OrmException cleanupError) {
            // Ignored
            }
            throw new UnprocessableEntityException("email '" + input.email + "' already exists");
        }
    }
    Account a = new Account(id, TimeUtil.nowTs());
    a.setFullName(input.name);
    a.setPreferredEmail(input.email);
    db.accounts().insert(Collections.singleton(a));
    for (AccountGroup.Id groupId : groups) {
        AccountGroupMember m = new AccountGroupMember(new AccountGroupMember.Key(id, groupId));
        auditService.dispatchAddAccountsToGroup(currentUser.get().getAccountId(), Collections.singleton(m));
        db.accountGroupMembers().insert(Collections.singleton(m));
    }
    if (input.sshKey != null) {
        try {
            authorizedKeys.addKey(id, input.sshKey);
            sshKeyCache.evict(username);
        } catch (InvalidSshKeyException e) {
            throw new BadRequestException(e.getMessage());
        }
    }
    accountCache.evictByUsername(username);
    byEmailCache.evict(input.email);
    AccountLoader loader = infoLoader.create(true);
    AccountInfo info = loader.get(id);
    loader.fill();
    return Response.created(info);
}
#end_block

#method_before
public synchronized TestAccount create(String username, String email, String fullName, String... groups) throws OrmException, JSchException, RepositoryNotFoundException, IOException, ConfigInvalidException {
    TestAccount account = accounts.get(username);
    if (account != null) {
        return account;
    }
    try (ReviewDb db = reviewDbProvider.open()) {
        Account.Id id = new Account.Id(db.nextAccountId());
        AccountExternalId extUser = new AccountExternalId(id, new AccountExternalId.Key(AccountExternalId.SCHEME_USERNAME, username));
        String httpPass = "http-pass";
        extUser.setPassword(httpPass);
        db.accountExternalIds().insert(Collections.singleton(extUser));
        if (email != null) {
            AccountExternalId extMailto = new AccountExternalId(id, getEmailKey(email));
            extMailto.setEmailAddress(email);
            db.accountExternalIds().insert(Collections.singleton(extMailto));
        }
        Account a = new Account(id, TimeUtil.nowTs());
        a.setFullName(fullName);
        a.setPreferredEmail(email);
        db.accounts().insert(Collections.singleton(a));
        if (groups != null) {
            for (String n : groups) {
                AccountGroup.NameKey k = new AccountGroup.NameKey(n);
                AccountGroup g = groupCache.get(k);
                AccountGroupMember m = new AccountGroupMember(new AccountGroupMember.Key(id, g.getId()));
                db.accountGroupMembers().insert(Collections.singleton(m));
            }
        }
        KeyPair sshKey = genSshKey();
        addSshKey(db, id, username, email, sshKey);
        accountCache.evictByUsername(username);
        byEmailCache.evict(email);
        account = new TestAccount(id, username, email, fullName, sshKey, httpPass);
        accounts.put(username, account);
        return account;
    }
}
#method_after
public synchronized TestAccount create(String username, String email, String fullName, String... groups) throws Exception {
    TestAccount account = accounts.get(username);
    if (account != null) {
        return account;
    }
    try (ReviewDb db = reviewDbProvider.open()) {
        Account.Id id = new Account.Id(db.nextAccountId());
        AccountExternalId extUser = new AccountExternalId(id, new AccountExternalId.Key(AccountExternalId.SCHEME_USERNAME, username));
        String httpPass = "http-pass";
        extUser.setPassword(httpPass);
        db.accountExternalIds().insert(Collections.singleton(extUser));
        if (email != null) {
            AccountExternalId extMailto = new AccountExternalId(id, getEmailKey(email));
            extMailto.setEmailAddress(email);
            db.accountExternalIds().insert(Collections.singleton(extMailto));
        }
        Account a = new Account(id, TimeUtil.nowTs());
        a.setFullName(fullName);
        a.setPreferredEmail(email);
        db.accounts().insert(Collections.singleton(a));
        if (groups != null) {
            for (String n : groups) {
                AccountGroup.NameKey k = new AccountGroup.NameKey(n);
                AccountGroup g = groupCache.get(k);
                AccountGroupMember m = new AccountGroupMember(new AccountGroupMember.Key(id, g.getId()));
                db.accountGroupMembers().insert(Collections.singleton(m));
            }
        }
        KeyPair sshKey = genSshKey();
        authorizedKeys.addKey(id, publicKey(sshKey, email));
        sshKeyCache.evict(username);
        accountCache.evictByUsername(username);
        byEmailCache.evict(email);
        account = new TestAccount(id, username, email, fullName, sshKey, httpPass);
        accounts.put(username, account);
        return account;
    }
}
#end_block

#method_before
public TestAccount create(String username, String group) throws OrmException, JSchException, RepositoryNotFoundException, IOException, ConfigInvalidException {
    return create(username, null, username, group);
}
#method_after
public TestAccount create(String username, String group) throws Exception {
    return create(username, null, username, group);
}
#end_block

#method_before
public TestAccount create(String username) throws OrmException, JSchException, RepositoryNotFoundException, IOException, ConfigInvalidException {
    return create(username, null, username, (String[]) null);
}
#method_after
public TestAccount create(String username) throws Exception {
    return create(username, null, username, (String[]) null);
}
#end_block

#method_before
public TestAccount admin() throws OrmException, JSchException, RepositoryNotFoundException, IOException, ConfigInvalidException {
    return create("admin", "admin@example.com", "Administrator", "Administrators");
}
#method_after
public TestAccount admin() throws Exception {
    return create("admin", "admin@example.com", "Administrator", "Administrators");
}
#end_block

#method_before
public TestAccount admin2() throws OrmException, JSchException, RepositoryNotFoundException, IOException, ConfigInvalidException {
    return create("admin2", "admin2@example.com", "Administrator2", "Administrators");
}
#method_after
public TestAccount admin2() throws Exception {
    return create("admin2", "admin2@example.com", "Administrator2", "Administrators");
}
#end_block

#method_before
public TestAccount user() throws OrmException, JSchException, RepositoryNotFoundException, IOException, ConfigInvalidException {
    return create("user", "user@example.com", "User");
}
#method_after
public TestAccount user() throws Exception {
    return create("user", "user@example.com", "User");
}
#end_block

#method_before
public TestAccount user2() throws OrmException, JSchException, RepositoryNotFoundException, IOException, ConfigInvalidException {
    return create("user2", "user2@example.com", "User2");
}
#method_after
public TestAccount user2() throws Exception {
    return create("user2", "user2@example.com", "User2");
}
#end_block

#method_before
public List<SshKeyInfo> apply(IdentifiedUser user) throws OrmException, RepositoryNotFoundException, IOException, ConfigInvalidException {
    List<AccountSshKey> keys = readFromGit ? readFromGit(user.getAccountId()) : readFromDb(dbProvider.get(), user.getAccountId());
    return Lists.transform(keys, new Function<AccountSshKey, SshKeyInfo>() {

        @Override
        public SshKeyInfo apply(AccountSshKey key) {
            return newSshKeyInfo(key);
        }
    });
}
#method_after
public List<SshKeyInfo> apply(IdentifiedUser user) throws RepositoryNotFoundException, IOException, ConfigInvalidException {
    return Lists.transform(authorizedKeys.getKeys(user.getAccountId()), new Function<AccountSshKey, SshKeyInfo>() {

        @Override
        public SshKeyInfo apply(AccountSshKey key) {
            return newSshKeyInfo(key);
        }
    });
}
#end_block

#method_before
@Override
public String getAvatarUrl(int size) throws RestApiException {
    GetAvatar myGetAvatar = getAvatar.get();
    myGetAvatar.setSize(size);
    return myGetAvatar.apply(account).location();
}
#method_after
@Override
public String getAvatarUrl(int size) throws RestApiException {
    getAvatar.setSize(size);
    return getAvatar.apply(account).location();
}
#end_block

#method_before
@Override
public void starChange(String id) throws RestApiException {
    try {
        ChangeResource rsrc = changes.parse(TopLevelResource.INSTANCE, IdString.fromUrl(id));
        starredChangesCreate.setChange(rsrc);
        starredChangesCreate.apply(account, new StarredChanges.EmptyInput());
    } catch (OrmException e) {
        throw new RestApiException("Cannot star change", e);
    }
}
#method_after
@Override
public void starChange(String id) throws RestApiException {
    try {
        ChangeResource rsrc = changes.parse(TopLevelResource.INSTANCE, IdString.fromUrl(id));
        starredChangesCreate.setChange(rsrc);
        starredChangesCreate.apply(account, new StarredChanges.EmptyInput());
    } catch (OrmException | IOException e) {
        throw new RestApiException("Cannot star change", e);
    }
}
#end_block

#method_before
@Override
public void unstarChange(String id) throws RestApiException {
    try {
        ChangeResource rsrc = changes.parse(TopLevelResource.INSTANCE, IdString.fromUrl(id));
        AccountResource.StarredChange starredChange = new AccountResource.StarredChange(account.getUser(), rsrc);
        starredChangesDelete.apply(starredChange, new StarredChanges.EmptyInput());
    } catch (OrmException e) {
        throw new RestApiException("Cannot unstar change", e);
    }
}
#method_after
@Override
public void unstarChange(String id) throws RestApiException {
    try {
        ChangeResource rsrc = changes.parse(TopLevelResource.INSTANCE, IdString.fromUrl(id));
        AccountResource.StarredChange starredChange = new AccountResource.StarredChange(account.getUser(), rsrc);
        starredChangesDelete.apply(starredChange, new StarredChanges.EmptyInput());
    } catch (OrmException | IOException e) {
        throw new RestApiException("Cannot unstar change", e);
    }
}
#end_block

#method_before
@Override
protected void configure() {
    bind(AccountsCollection.class);
    bind(Capabilities.class);
    DynamicMap.mapOf(binder(), ACCOUNT_KIND);
    DynamicMap.mapOf(binder(), CAPABILITY_KIND);
    DynamicMap.mapOf(binder(), EMAIL_KIND);
    DynamicMap.mapOf(binder(), SSH_KEY_KIND);
    DynamicMap.mapOf(binder(), STARRED_CHANGE_KIND);
    put(ACCOUNT_KIND).to(PutAccount.class);
    get(ACCOUNT_KIND).to(GetAccount.class);
    get(ACCOUNT_KIND, "detail").to(GetDetail.class);
    get(ACCOUNT_KIND, "name").to(GetName.class);
    put(ACCOUNT_KIND, "name").to(PutName.class);
    delete(ACCOUNT_KIND, "name").to(PutName.class);
    get(ACCOUNT_KIND, "username").to(GetUsername.class);
    put(ACCOUNT_KIND, "username").to(PutUsername.class);
    get(ACCOUNT_KIND, "active").to(GetActive.class);
    put(ACCOUNT_KIND, "active").to(PutActive.class);
    delete(ACCOUNT_KIND, "active").to(DeleteActive.class);
    child(ACCOUNT_KIND, "emails").to(Emails.class);
    get(EMAIL_KIND).to(GetEmail.class);
    put(EMAIL_KIND).to(PutEmail.class);
    delete(EMAIL_KIND).to(DeleteEmail.class);
    put(EMAIL_KIND, "preferred").to(PutPreferred.class);
    get(ACCOUNT_KIND, "password.http").to(GetHttpPassword.class);
    put(ACCOUNT_KIND, "password.http").to(PutHttpPassword.class);
    delete(ACCOUNT_KIND, "password.http").to(PutHttpPassword.class);
    child(ACCOUNT_KIND, "sshkeys").to(SshKeys.class);
    post(ACCOUNT_KIND, "sshkeys").to(AddSshKey.class);
    get(ACCOUNT_KIND, "watchedprojects").to(GetWatchedProjects.class);
    get(SSH_KEY_KIND).to(GetSshKey.class);
    delete(SSH_KEY_KIND).to(DeleteSshKey.class);
    get(ACCOUNT_KIND, "avatar").to(GetAvatar.class);
    get(ACCOUNT_KIND, "avatar.change.url").to(GetAvatarChangeUrl.class);
    child(ACCOUNT_KIND, "capabilities").to(Capabilities.class);
    get(ACCOUNT_KIND, "groups").to(GetGroups.class);
    get(ACCOUNT_KIND, "preferences").to(GetPreferences.class);
    put(ACCOUNT_KIND, "preferences").to(SetPreferences.class);
    get(ACCOUNT_KIND, "preferences.diff").to(GetDiffPreferences.class);
    put(ACCOUNT_KIND, "preferences.diff").to(SetDiffPreferences.class);
    get(ACCOUNT_KIND, "preferences.edit").to(GetEditPreferences.class);
    put(ACCOUNT_KIND, "preferences.edit").to(SetEditPreferences.class);
    get(CAPABILITY_KIND).to(GetCapabilities.CheckOne.class);
    child(ACCOUNT_KIND, "starred.changes").to(StarredChanges.class);
    put(STARRED_CHANGE_KIND).to(StarredChanges.Put.class);
    delete(STARRED_CHANGE_KIND).to(StarredChanges.Delete.class);
    bind(StarredChanges.Create.class);
    factory(CreateAccount.Factory.class);
    factory(CreateEmail.Factory.class);
}
#method_after
@Override
protected void configure() {
    bind(AccountsCollection.class);
    bind(Capabilities.class);
    DynamicMap.mapOf(binder(), ACCOUNT_KIND);
    DynamicMap.mapOf(binder(), CAPABILITY_KIND);
    DynamicMap.mapOf(binder(), EMAIL_KIND);
    DynamicMap.mapOf(binder(), SSH_KEY_KIND);
    DynamicMap.mapOf(binder(), STARRED_CHANGE_KIND);
    put(ACCOUNT_KIND).to(PutAccount.class);
    get(ACCOUNT_KIND).to(GetAccount.class);
    get(ACCOUNT_KIND, "detail").to(GetDetail.class);
    get(ACCOUNT_KIND, "name").to(GetName.class);
    put(ACCOUNT_KIND, "name").to(PutName.class);
    delete(ACCOUNT_KIND, "name").to(PutName.class);
    get(ACCOUNT_KIND, "username").to(GetUsername.class);
    put(ACCOUNT_KIND, "username").to(PutUsername.class);
    get(ACCOUNT_KIND, "active").to(GetActive.class);
    put(ACCOUNT_KIND, "active").to(PutActive.class);
    delete(ACCOUNT_KIND, "active").to(DeleteActive.class);
    child(ACCOUNT_KIND, "emails").to(Emails.class);
    get(EMAIL_KIND).to(GetEmail.class);
    put(EMAIL_KIND).to(PutEmail.class);
    delete(EMAIL_KIND).to(DeleteEmail.class);
    put(EMAIL_KIND, "preferred").to(PutPreferred.class);
    get(ACCOUNT_KIND, "password.http").to(GetHttpPassword.class);
    put(ACCOUNT_KIND, "password.http").to(PutHttpPassword.class);
    delete(ACCOUNT_KIND, "password.http").to(PutHttpPassword.class);
    child(ACCOUNT_KIND, "sshkeys").to(SshKeys.class);
    post(ACCOUNT_KIND, "sshkeys").to(AddSshKey.class);
    get(ACCOUNT_KIND, "watched.projects").to(GetWatchedProjects.class);
    get(SSH_KEY_KIND).to(GetSshKey.class);
    delete(SSH_KEY_KIND).to(DeleteSshKey.class);
    get(ACCOUNT_KIND, "avatar").to(GetAvatar.class);
    get(ACCOUNT_KIND, "avatar.change.url").to(GetAvatarChangeUrl.class);
    child(ACCOUNT_KIND, "capabilities").to(Capabilities.class);
    get(ACCOUNT_KIND, "groups").to(GetGroups.class);
    get(ACCOUNT_KIND, "preferences").to(GetPreferences.class);
    put(ACCOUNT_KIND, "preferences").to(SetPreferences.class);
    get(ACCOUNT_KIND, "preferences.diff").to(GetDiffPreferences.class);
    put(ACCOUNT_KIND, "preferences.diff").to(SetDiffPreferences.class);
    get(ACCOUNT_KIND, "preferences.edit").to(GetEditPreferences.class);
    put(ACCOUNT_KIND, "preferences.edit").to(SetEditPreferences.class);
    get(CAPABILITY_KIND).to(GetCapabilities.CheckOne.class);
    child(ACCOUNT_KIND, "starred.changes").to(StarredChanges.class);
    put(STARRED_CHANGE_KIND).to(StarredChanges.Put.class);
    delete(STARRED_CHANGE_KIND).to(StarredChanges.Delete.class);
    bind(StarredChanges.Create.class);
    factory(CreateAccount.Factory.class);
    factory(CreateEmail.Factory.class);
}
#end_block

#method_before
@Override
public List<WatchedProjectInfo> getWatchedProjects() throws RestApiException {
    return getWatchedProjects.apply(account);
}
#method_after
@Override
public List<ProjectWatchInfo> getWatchedProjects() throws RestApiException {
    try {
        return getWatchedProjects.apply(account);
    } catch (OrmException e) {
        throw new RestApiException("Cannot get watched projects", e);
    }
}
#end_block

#method_before
@Override
public List<SshKeyInfo> listSshKeys() throws RestApiException {
    try {
        return getSshKeys.apply(account);
    } catch (OrmException e) {
        throw new RestApiException("Cannot list SSH keys", e);
    }
}
#method_after
@Override
public List<SshKeyInfo> listSshKeys() throws RestApiException {
    try {
        return getSshKeys.apply(account);
    } catch (OrmException | IOException | ConfigInvalidException e) {
        throw new RestApiException("Cannot list SSH keys", e);
    }
}
#end_block

#method_before
@Override
public SshKeyInfo addSshKey(String key) throws RestApiException {
    AddSshKey.Input in = new AddSshKey.Input();
    in.raw = RawInputUtil.create(key);
    try {
        return addSshKey.apply(account, in).value();
    } catch (OrmException | IOException e) {
        throw new RestApiException("Cannot add SSH key", e);
    }
}
#method_after
@Override
public SshKeyInfo addSshKey(String key) throws RestApiException {
    AddSshKey.Input in = new AddSshKey.Input();
    in.raw = RawInputUtil.create(key);
    try {
        return addSshKey.apply(account, in).value();
    } catch (OrmException | IOException | ConfigInvalidException e) {
        throw new RestApiException("Cannot add SSH key", e);
    }
}
#end_block

#method_before
@Override
public List<WatchedProjectInfo> apply(AccountResource rsrc) {
    List<WatchedProjectInfo> watchedProjectInfos = new LinkedList<>();
    for (AccountProjectWatch a : rsrc.getUser().getNotificationFilters()) {
        WatchedProjectInfo wpi = new WatchedProjectInfo();
        wpi.filter = a.getFilter();
        wpi.projectName = a.getProjectNameKey().get();
        wpi.notifyAbandonedChanges = toBoolean(a.isNotify(AccountProjectWatch.NotifyType.SUBMITTED_CHANGES));
        wpi.notifyNewChanges = toBoolean(a.isNotify(AccountProjectWatch.NotifyType.NEW_CHANGES));
        wpi.notifyNewPatchSets = toBoolean(a.isNotify(AccountProjectWatch.NotifyType.NEW_PATCHSETS));
        wpi.notifySubmittedChanges = toBoolean(a.isNotify(AccountProjectWatch.NotifyType.SUBMITTED_CHANGES));
        wpi.notifyAllComments = toBoolean(a.isNotify(AccountProjectWatch.NotifyType.ALL_COMMENTS));
        watchedProjectInfos.add(wpi);
    }
    return watchedProjectInfos;
}
#method_after
@Override
public List<ProjectWatchInfo> apply(AccountResource rsrc) throws OrmException, AuthException {
    if (self.get() != rsrc.getUser()) {
        throw new AuthException("It is not allowed to list project watches " + "of other users");
    }
    List<ProjectWatchInfo> projectWatchInfos = new LinkedList<>();
    Iterable<AccountProjectWatch> projectWatches = dbProvider.get().accountProjectWatches().byAccount(rsrc.getUser().getAccountId());
    for (AccountProjectWatch a : projectWatches) {
        ProjectWatchInfo pwi = new ProjectWatchInfo();
        pwi.filter = a.getFilter();
        pwi.project = a.getProjectNameKey().get();
        pwi.notifyAbandonedChanges = toBoolean(a.isNotify(AccountProjectWatch.NotifyType.ABANDONED_CHANGES));
        pwi.notifyNewChanges = toBoolean(a.isNotify(AccountProjectWatch.NotifyType.NEW_CHANGES));
        pwi.notifyNewPatchSets = toBoolean(a.isNotify(AccountProjectWatch.NotifyType.NEW_PATCHSETS));
        pwi.notifySubmittedChanges = toBoolean(a.isNotify(AccountProjectWatch.NotifyType.SUBMITTED_CHANGES));
        pwi.notifyAllComments = toBoolean(a.isNotify(AccountProjectWatch.NotifyType.ALL_COMMENTS));
        projectWatchInfos.add(pwi);
    }
    return projectWatchInfos;
}
#end_block

#method_before
@Override
public List<WatchedProjectInfo> getWatchedProjects() throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public List<ProjectWatchInfo> getWatchedProjects() throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
private RefUpdate.Result modify(TreeOperation op, ChangeEdit edit, String file, @Nullable String newFile, @Nullable RawInput content) throws AuthException, IOException, InvalidChangeOperationException {
    if (!currentUser.get().isIdentifiedUser()) {
        throw new AuthException("Authentication required");
    }
    IdentifiedUser me = currentUser.get().asIdentifiedUser();
    Project.NameKey project = edit.getChange().getProject();
    try (Repository repo = gitManager.openRepository(project);
        RevWalk rw = new RevWalk(repo);
        ObjectInserter inserter = repo.newObjectInserter();
        ObjectReader reader = repo.newObjectReader()) {
        String refName = edit.getRefName();
        RevCommit prevEdit = edit.getEditCommit();
        ObjectId newTree = writeNewTree(op, rw, inserter, prevEdit, reader, file, newFile, toBlob(inserter, content));
        if (ObjectId.equals(newTree, prevEdit.getTree())) {
            throw new InvalidChangeOperationException("no changes were made");
        }
        Timestamp now = TimeUtil.nowTs();
        ObjectId commit = createCommit(me, inserter, prevEdit, newTree, now);
        inserter.flush();
        return update(repo, me, refName, rw, prevEdit, commit, now);
    }
}
#method_after
private RefUpdate.Result modify(TreeOperation op, ChangeEdit edit, String file, @Nullable String newFile, @Nullable RawInput content) throws AuthException, IOException, InvalidChangeOperationException {
    if (!currentUser.get().isIdentifiedUser()) {
        throw new AuthException("Authentication required");
    }
    IdentifiedUser me = currentUser.get().asIdentifiedUser();
    Project.NameKey project = edit.getChange().getProject();
    try (Repository repo = gitManager.openRepository(project);
        RevWalk rw = new RevWalk(repo);
        ObjectInserter inserter = repo.newObjectInserter();
        ObjectReader reader = repo.newObjectReader()) {
        String refName = edit.getRefName();
        RevCommit prevEdit = edit.getEditCommit();
        ObjectId newTree = writeNewTree(op, rw, inserter, prevEdit, reader, file, newFile, content);
        if (ObjectId.equals(newTree, prevEdit.getTree())) {
            throw new InvalidChangeOperationException("no changes were made");
        }
        Timestamp now = TimeUtil.nowTs();
        ObjectId commit = createCommit(me, inserter, prevEdit, newTree, now);
        inserter.flush();
        return update(repo, me, refName, rw, prevEdit, commit, now);
    }
}
#end_block

#method_before
private static ObjectId writeNewTree(TreeOperation op, RevWalk rw, ObjectInserter ins, RevCommit prevEdit, final ObjectReader reader, String fileName, @Nullable String newFile, @Nullable final ObjectId content) throws IOException {
    DirCache newTree = readTree(reader, prevEdit);
    DirCacheEditor dce = newTree.editor();
    switch(op) {
        case DELETE_ENTRY:
            dce.add(new DeletePath(fileName));
            break;
        case RENAME_ENTRY:
            rw.parseHeaders(prevEdit);
            TreeWalk tw = TreeWalk.forPath(rw.getObjectReader(), fileName, prevEdit.getTree());
            if (tw != null) {
                dce.add(new DeletePath(fileName));
                addFileToCommit(newFile, dce, tw);
            }
            break;
        case CHANGE_ENTRY:
            checkNotNull(content, "new content required");
            dce.add(new PathEdit(fileName) {

                @Override
                public void apply(DirCacheEntry ent) {
                    if (ent.getRawMode() == 0) {
                        ent.setFileMode(FileMode.REGULAR_FILE);
                    }
                    FileMode mode = ent.getFileMode();
                    if (FileMode.GITLINK != mode) {
                        ent.setObjectId(content);
                    } else {
                        ent.setLength(0);
                        ent.setLastModified(0);
                        try {
                            ObjectId id = ObjectId.fromString(reader.open(content).getBytes(), 0);
                            ent.setObjectId(id);
                        } catch (LargeObjectException e) {
                            // TODO Auto-generated catch block
                            e.printStackTrace();
                        } catch (MissingObjectException e) {
                            // TODO Auto-generated catch block
                            e.printStackTrace();
                        } catch (IOException e) {
                            // TODO Auto-generated catch block
                            e.printStackTrace();
                        }
                    }
                }
            });
            break;
        case RESTORE_ENTRY:
            if (prevEdit.getParentCount() == 0) {
                dce.add(new DeletePath(fileName));
                break;
            }
            RevCommit base = prevEdit.getParent(0);
            rw.parseHeaders(base);
            tw = TreeWalk.forPath(rw.getObjectReader(), fileName, base.getTree());
            if (tw == null) {
                dce.add(new DeletePath(fileName));
                break;
            }
            addFileToCommit(fileName, dce, tw);
            break;
    }
    dce.finish();
    return newTree.writeTree(ins);
}
#method_after
private static ObjectId writeNewTree(TreeOperation op, RevWalk rw, final ObjectInserter ins, RevCommit prevEdit, ObjectReader reader, String fileName, @Nullable String newFile, @Nullable final RawInput content) throws InvalidChangeOperationException, IOException {
    DirCache newTree = readTree(reader, prevEdit);
    DirCacheEditor dce = newTree.editor();
    switch(op) {
        case DELETE_ENTRY:
            dce.add(new DeletePath(fileName));
            break;
        case RENAME_ENTRY:
            rw.parseHeaders(prevEdit);
            TreeWalk tw = TreeWalk.forPath(rw.getObjectReader(), fileName, prevEdit.getTree());
            if (tw != null) {
                dce.add(new DeletePath(fileName));
                addFileToCommit(newFile, dce, tw);
            }
            break;
        case CHANGE_ENTRY:
            checkNotNull(content, "new content required");
            final AtomicReference<IOException> ioe = new AtomicReference<>(null);
            final AtomicReference<InvalidChangeOperationException> icoe = new AtomicReference<>(null);
            dce.add(new PathEdit(fileName) {

                @Override
                public void apply(DirCacheEntry ent) {
                    try {
                        if (ent.getFileMode() == FileMode.GITLINK) {
                            ent.setLength(0);
                            ent.setLastModified(0);
                            ent.setObjectId(ObjectId.fromString(ByteStreams.toByteArray(content.getInputStream()), 0));
                        } else {
                            if (ent.getRawMode() == 0) {
                                ent.setFileMode(FileMode.REGULAR_FILE);
                            }
                            ent.setObjectId(toBlob(ins, content));
                        }
                    } catch (IOException e) {
                        ioe.set(e);
                    } catch (InvalidObjectIdException e) {
                        icoe.set(new InvalidChangeOperationException("Invalid object id in submodule link: " + e.getMessage()));
                        icoe.get().initCause(e);
                    }
                }
            });
            if (ioe.get() != null) {
                throw ioe.get();
            }
            if (icoe.get() != null) {
                throw icoe.get();
            }
            break;
        case RESTORE_ENTRY:
            if (prevEdit.getParentCount() == 0) {
                dce.add(new DeletePath(fileName));
                break;
            }
            RevCommit base = prevEdit.getParent(0);
            rw.parseHeaders(base);
            tw = TreeWalk.forPath(rw.getObjectReader(), fileName, base.getTree());
            if (tw == null) {
                dce.add(new DeletePath(fileName));
                break;
            }
            addFileToCommit(fileName, dce, tw);
            break;
    }
    dce.finish();
    return newTree.writeTree(ins);
}
#end_block

#method_before
public Collection<Branch.NameKey> getDestinationBranches(Branch.NameKey src, SubscribeSection s) throws IOException {
    Collection<Branch.NameKey> ret = new ArrayList<>();
    logDebug("Inspecting SubscribeSection " + s);
    for (RefSpec r : s.getRefSpecs()) {
        logDebug("Inspecting ref " + r);
        if (r.matchSource(src.get())) {
            if (r.getDestination() == null) {
                // no need to care for wildcard, as we matched already
                try {
                    mergeOp.openRepo(s.getProject(), false);
                } catch (NoSuchProjectException e) {
                    // to subscribe to it. Allow this for now.
                    continue;
                }
                OpenRepo or = mergeOp.getRepo(s.getProject());
                for (Ref ref : or.repo.getRefDatabase().getRefs(RefNames.REFS_HEADS).values()) {
                    ret.add(new Branch.NameKey(s.getProject(), ref.getName()));
                }
            } else if (r.isWildcard()) {
                // refs/heads/*:refs/heads/*
                ret.add(new Branch.NameKey(s.getProject(), r.expandFromSource(src.get()).getDestination()));
            } else {
                // e.g. refs/heads/master:refs/heads/stable
                ret.add(new Branch.NameKey(s.getProject(), r.getDestination()));
            }
        }
    }
    logDebug("Returning possible branches: " + ret + "for project " + s.getProject());
    return ret;
}
#method_after
public Collection<Branch.NameKey> getDestinationBranches(Branch.NameKey src, SubscribeSection s, MergeOpRepoManager orm) throws IOException {
    Collection<Branch.NameKey> ret = new ArrayList<>();
    logDebug("Inspecting SubscribeSection " + s);
    for (RefSpec r : s.getRefSpecs()) {
        logDebug("Inspecting ref " + r);
        if (r.matchSource(src.get())) {
            if (r.getDestination() == null) {
                // no need to care for wildcard, as we matched already
                try {
                    orm.openRepo(s.getProject(), false);
                } catch (NoSuchProjectException e) {
                    // to subscribe to it. Allow this for now.
                    continue;
                }
                OpenRepo or = orm.getRepo(s.getProject());
                for (Ref ref : or.repo.getRefDatabase().getRefs(RefNames.REFS_HEADS).values()) {
                    ret.add(new Branch.NameKey(s.getProject(), ref.getName()));
                }
            } else if (r.isWildcard()) {
                // refs/heads/*:refs/heads/*
                ret.add(new Branch.NameKey(s.getProject(), r.expandFromSource(src.get()).getDestination()));
            } else {
                // e.g. refs/heads/master:refs/heads/stable
                ret.add(new Branch.NameKey(s.getProject(), r.getDestination()));
            }
        }
    }
    logDebug("Returning possible branches: " + ret + "for project " + s.getProject());
    return ret;
}
#end_block

#method_before
public Collection<SubmoduleSubscription> superProjectSubscriptionsForSubmoduleBranch(Branch.NameKey branch) throws IOException {
    logDebug("Calculating possible superprojects for " + branch);
    Collection<SubmoduleSubscription> ret = new ArrayList<>();
    Project.NameKey project = branch.getParentKey();
    ProjectConfig cfg = projectCache.get(project).getConfig();
    for (SubscribeSection s : cfg.getSubscribeSections(branch)) {
        Collection<Branch.NameKey> branches = getDestinationBranches(branch, s);
        for (Branch.NameKey targetBranch : branches) {
            GitModules m = gitmodulesFactory.create(targetBranch, updateId);
            m.load();
            ret.addAll(m.subscribedTo(branch));
        }
    }
    logDebug("Calculated superprojects for " + branch + " are " + ret);
    return ret;
}
#method_after
public Collection<SubmoduleSubscription> superProjectSubscriptionsForSubmoduleBranch(Branch.NameKey branch, MergeOpRepoManager orm) throws IOException {
    logDebug("Calculating possible superprojects for " + branch);
    Collection<SubmoduleSubscription> ret = new ArrayList<>();
    Project.NameKey project = branch.getParentKey();
    ProjectConfig cfg = projectCache.get(project).getConfig();
    for (SubscribeSection s : cfg.getSubscribeSections(branch)) {
        Collection<Branch.NameKey> branches = getDestinationBranches(branch, s, orm);
        for (Branch.NameKey targetBranch : branches) {
            GitModules m = gitmodulesFactory.create(targetBranch, updateId, orm);
            m.load();
            ret.addAll(m.subscribedTo(branch));
        }
    }
    logDebug("Calculated superprojects for " + branch + " are " + ret);
    return ret;
}
#end_block

#method_before
protected void updateSuperProjects(ReviewDb db, Collection<Branch.NameKey> updatedBranches, String updateId) throws SubmoduleException {
    if (!enableSuperProjectSubscriptions) {
        logDebug("Updating superprojects disabled");
        return;
    }
    this.updateId = updateId;
    logDebug("Updating superprojects");
    // These (repo/branch) will be updated later with all the given
    // individual submodule subscriptions
    Multimap<Branch.NameKey, SubmoduleSubscription> targets = HashMultimap.create();
    try {
        for (Branch.NameKey updatedBranch : updatedBranches) {
            for (SubmoduleSubscription sub : superProjectSubscriptionsForSubmoduleBranch(updatedBranch)) {
                targets.put(sub.getSuperProject(), sub);
            }
        }
    } catch (IOException e) {
        throw new SubmoduleException("Could not calculate all superprojects");
    }
    updatedSubscribers.addAll(updatedBranches);
    // Update subscribers.
    for (Branch.NameKey dest : targets.keySet()) {
        try {
            if (!updatedSubscribers.add(dest)) {
                log.error("Possible circular subscription involving " + dest);
            } else {
                updateGitlinks(db, dest, targets.get(dest));
            }
        } catch (SubmoduleException e) {
            log.warn("Cannot update gitlinks for " + dest, e);
        }
    }
}
#method_after
protected void updateSuperProjects(ReviewDb db, Collection<Branch.NameKey> updatedBranches, String updateId, MergeOpRepoManager orm) throws SubmoduleException {
    if (!enableSuperProjectSubscriptions) {
        logDebug("Updating superprojects disabled");
        return;
    }
    this.updateId = updateId;
    logDebug("Updating superprojects");
    // These (repo/branch) will be updated later with all the given
    // individual submodule subscriptions
    Multimap<Branch.NameKey, SubmoduleSubscription> targets = HashMultimap.create();
    try {
        for (Branch.NameKey updatedBranch : updatedBranches) {
            for (SubmoduleSubscription sub : superProjectSubscriptionsForSubmoduleBranch(updatedBranch, orm)) {
                targets.put(sub.getSuperProject(), sub);
            }
        }
    } catch (IOException e) {
        throw new SubmoduleException("Could not calculate all superprojects");
    }
    updatedSubscribers.addAll(updatedBranches);
    // Update subscribers.
    for (Branch.NameKey dest : targets.keySet()) {
        try {
            if (!updatedSubscribers.add(dest)) {
                log.error("Possible circular subscription involving " + dest);
            } else {
                updateGitlinks(db, dest, targets.get(dest), orm);
            }
        } catch (SubmoduleException e) {
            log.warn("Cannot update gitlinks for " + dest, e);
        }
    }
}
#end_block

#method_before
private void updateGitlinks(ReviewDb db, Branch.NameKey subscriber, Collection<SubmoduleSubscription> updates) throws SubmoduleException {
    PersonIdent author = null;
    StringBuilder msgbuf = new StringBuilder("Update git submodules\n\n");
    boolean sameAuthorForAll = true;
    try {
        mergeOp.openRepo(subscriber.getParentKey(), false);
    } catch (NoSuchProjectException | IOException e) {
        throw new SubmoduleException("Cannot access superproject", e);
    }
    OpenRepo or = mergeOp.getRepo(subscriber.getParentKey());
    Repository pdb = or.repo;
    try {
        if (pdb.exactRef(subscriber.get()) == null) {
            throw new SubmoduleException("The branch was probably deleted from the subscriber repository");
        }
        DirCache dc = readTree(pdb, pdb.exactRef(subscriber.get()));
        DirCacheEditor ed = dc.editor();
        for (SubmoduleSubscription s : updates) {
            try {
                mergeOp.openRepo(s.getSubmodule().getParentKey(), false);
            } catch (NoSuchProjectException | IOException e) {
                throw new SubmoduleException("Cannot access submodule", e);
            }
            OpenRepo subOr = mergeOp.getRepo(s.getSubmodule().getParentKey());
            Repository subrepo = subOr.repo;
            Ref ref = subrepo.getRefDatabase().exactRef(s.getSubmodule().get());
            if (ref == null) {
                ed.add(new DeletePath(s.getPath()));
                continue;
            }
            final ObjectId updateTo = ref.getObjectId();
            RevCommit newCommit = subOr.rw.parseCommit(updateTo);
            subOr.rw.parseBody(newCommit);
            if (author == null) {
                author = newCommit.getAuthorIdent();
            } else if (!author.equals(newCommit.getAuthorIdent())) {
                sameAuthorForAll = false;
            }
            DirCacheEntry dce = dc.getEntry(s.getPath());
            ObjectId oldId;
            if (dce != null) {
                if (!dce.getFileMode().equals(FileMode.GITLINK)) {
                    log.error("Requested to update gitlink " + s.getPath() + " in " + s.getSubmodule().getParentKey().get() + " but entry " + "doesn't have gitlink file mode.");
                    continue;
                }
                oldId = dce.getObjectId();
            } else {
                // This submodule did not exist before. We do not want to add
                // the full submodule history to the commit message, so omit it.
                oldId = updateTo;
            }
            ed.add(new PathEdit(s.getPath()) {

                @Override
                public void apply(DirCacheEntry ent) {
                    ent.setFileMode(FileMode.GITLINK);
                    ent.setObjectId(updateTo);
                }
            });
            if (verboseSuperProject) {
                msgbuf.append("Project: " + s.getSubmodule().getParentKey().get());
                msgbuf.append(" " + s.getSubmodule().getShortName());
                msgbuf.append(" " + updateTo.getName());
                msgbuf.append("\n\n");
                try {
                    subOr.rw.markStart(newCommit);
                    subOr.rw.markUninteresting(subOr.rw.parseCommit(oldId));
                    for (RevCommit c : subOr.rw) {
                        subOr.rw.parseBody(c);
                        msgbuf.append(c.getFullMessage() + "\n\n");
                    }
                } catch (IOException e) {
                    throw new SubmoduleException("Could not perform a revwalk to " + "create superproject commit message", e);
                }
            }
        }
        ed.finish();
        if (!sameAuthorForAll || author == null) {
            author = myIdent;
        }
        ObjectInserter oi = pdb.newObjectInserter();
        ObjectId tree = dc.writeTree(oi);
        ObjectId currentCommitId = pdb.exactRef(subscriber.get()).getObjectId();
        CommitBuilder commit = new CommitBuilder();
        commit.setTreeId(tree);
        commit.setParentIds(new ObjectId[] { currentCommitId });
        commit.setAuthor(author);
        commit.setCommitter(myIdent);
        commit.setMessage(msgbuf.toString());
        oi.insert(commit);
        oi.flush();
        ObjectId commitId = oi.idFor(Constants.OBJ_COMMIT, commit.build());
        final RefUpdate rfu = pdb.updateRef(subscriber.get());
        rfu.setForceUpdate(false);
        rfu.setNewObjectId(commitId);
        rfu.setExpectedOldObjectId(currentCommitId);
        rfu.setRefLogMessage("Submit to " + subscriber.getParentKey().get(), true);
        switch(rfu.update()) {
            case NEW:
            case FAST_FORWARD:
                gitRefUpdated.fire(subscriber.getParentKey(), rfu);
                changeHooks.doRefUpdatedHook(subscriber, rfu, account);
                // sent to inform users about the updated branch
                break;
            case FORCED:
            case IO_FAILURE:
            case LOCK_FAILURE:
            case NOT_ATTEMPTED:
            case NO_CHANGE:
            case REJECTED:
            case REJECTED_CURRENT_BRANCH:
            case RENAMED:
            default:
                throw new IOException(rfu.getResult().name());
        }
        // Recursive call: update subscribers of the subscriber
        updateSuperProjects(db, Sets.newHashSet(subscriber), updateId);
    } catch (IOException e) {
        throw new SubmoduleException("Cannot update gitlinks for " + subscriber.get(), e);
    }
}
#method_after
private void updateGitlinks(ReviewDb db, Branch.NameKey subscriber, Collection<SubmoduleSubscription> updates, MergeOpRepoManager orm) throws SubmoduleException {
    PersonIdent author = null;
    StringBuilder msgbuf = new StringBuilder("Update git submodules\n\n");
    boolean sameAuthorForAll = true;
    try {
        orm.openRepo(subscriber.getParentKey(), false);
    } catch (NoSuchProjectException | IOException e) {
        throw new SubmoduleException("Cannot access superproject", e);
    }
    OpenRepo or = orm.getRepo(subscriber.getParentKey());
    try {
        Ref r = or.repo.exactRef(subscriber.get());
        if (r == null) {
            throw new SubmoduleException("The branch was probably deleted from the subscriber repository");
        }
        DirCache dc = readTree(r, or.rw);
        DirCacheEditor ed = dc.editor();
        for (SubmoduleSubscription s : updates) {
            try {
                orm.openRepo(s.getSubmodule().getParentKey(), false);
            } catch (NoSuchProjectException | IOException e) {
                throw new SubmoduleException("Cannot access submodule", e);
            }
            OpenRepo subOr = orm.getRepo(s.getSubmodule().getParentKey());
            Repository subrepo = subOr.repo;
            Ref ref = subrepo.getRefDatabase().exactRef(s.getSubmodule().get());
            if (ref == null) {
                ed.add(new DeletePath(s.getPath()));
                continue;
            }
            final ObjectId updateTo = ref.getObjectId();
            RevCommit newCommit = subOr.rw.parseCommit(updateTo);
            subOr.rw.parseBody(newCommit);
            if (author == null) {
                author = newCommit.getAuthorIdent();
            } else if (!author.equals(newCommit.getAuthorIdent())) {
                sameAuthorForAll = false;
            }
            DirCacheEntry dce = dc.getEntry(s.getPath());
            ObjectId oldId;
            if (dce != null) {
                if (!dce.getFileMode().equals(FileMode.GITLINK)) {
                    log.error("Requested to update gitlink " + s.getPath() + " in " + s.getSubmodule().getParentKey().get() + " but entry " + "doesn't have gitlink file mode.");
                    continue;
                }
                oldId = dce.getObjectId();
            } else {
                // This submodule did not exist before. We do not want to add
                // the full submodule history to the commit message, so omit it.
                oldId = updateTo;
            }
            ed.add(new PathEdit(s.getPath()) {

                @Override
                public void apply(DirCacheEntry ent) {
                    ent.setFileMode(FileMode.GITLINK);
                    ent.setObjectId(updateTo);
                }
            });
            if (verboseSuperProject) {
                msgbuf.append("Project: " + s.getSubmodule().getParentKey().get());
                msgbuf.append(" " + s.getSubmodule().getShortName());
                msgbuf.append(" " + updateTo.getName());
                msgbuf.append("\n\n");
                try {
                    subOr.rw.markStart(newCommit);
                    subOr.rw.markUninteresting(subOr.rw.parseCommit(oldId));
                    for (RevCommit c : subOr.rw) {
                        subOr.rw.parseBody(c);
                        msgbuf.append(c.getFullMessage() + "\n\n");
                    }
                } catch (IOException e) {
                    throw new SubmoduleException("Could not perform a revwalk to " + "create superproject commit message", e);
                }
            }
        }
        ed.finish();
        if (!sameAuthorForAll || author == null) {
            author = myIdent;
        }
        ObjectInserter oi = or.repo.newObjectInserter();
        ObjectId tree = dc.writeTree(oi);
        ObjectId currentCommitId = or.repo.exactRef(subscriber.get()).getObjectId();
        CommitBuilder commit = new CommitBuilder();
        commit.setTreeId(tree);
        commit.setParentIds(new ObjectId[] { currentCommitId });
        commit.setAuthor(author);
        commit.setCommitter(myIdent);
        commit.setMessage(msgbuf.toString());
        oi.insert(commit);
        oi.flush();
        ObjectId commitId = oi.idFor(Constants.OBJ_COMMIT, commit.build());
        final RefUpdate rfu = or.repo.updateRef(subscriber.get());
        rfu.setForceUpdate(false);
        rfu.setNewObjectId(commitId);
        rfu.setExpectedOldObjectId(currentCommitId);
        rfu.setRefLogMessage("Submit to " + subscriber.getParentKey().get(), true);
        switch(rfu.update()) {
            case NEW:
            case FAST_FORWARD:
                gitRefUpdated.fire(subscriber.getParentKey(), rfu);
                changeHooks.doRefUpdatedHook(subscriber, rfu, account);
                // sent to inform users about the updated branch
                break;
            case FORCED:
            case IO_FAILURE:
            case LOCK_FAILURE:
            case NOT_ATTEMPTED:
            case NO_CHANGE:
            case REJECTED:
            case REJECTED_CURRENT_BRANCH:
            case RENAMED:
            default:
                throw new IOException(rfu.getResult().name());
        }
        // Recursive call: update subscribers of the subscriber
        updateSuperProjects(db, Sets.newHashSet(subscriber), updateId, orm);
    } catch (IOException e) {
        throw new SubmoduleException("Cannot update gitlinks for " + subscriber.get(), e);
    }
}
#end_block

#method_before
private static DirCache readTree(final Repository pdb, final Ref branch) throws MissingObjectException, IncorrectObjectTypeException, IOException {
    try (RevWalk rw = new RevWalk(pdb)) {
        final DirCache dc = DirCache.newInCore();
        final DirCacheBuilder b = dc.builder();
        // no prefix path
        b.addTree(// no prefix path
        new byte[0], // standard stage
        DirCacheEntry.STAGE_0, pdb.newObjectReader(), rw.parseTree(branch.getObjectId()));
        b.finish();
        return dc;
    }
}
#method_after
private static DirCache readTree(final Ref branch, RevWalk rw) throws MissingObjectException, IncorrectObjectTypeException, IOException {
    final DirCache dc = DirCache.newInCore();
    final DirCacheBuilder b = dc.builder();
    // no prefix path
    b.addTree(// no prefix path
    new byte[0], // standard stage
    DirCacheEntry.STAGE_0, rw.getObjectReader(), rw.parseTree(branch.getObjectId()));
    b.finish();
    return dc;
}
#end_block

#method_before
@Override
public void close() {
    for (OpenRepo repo : openRepos.values()) {
        repo.close();
    }
}
#method_after
@Override
public void close() {
    orm.close();
}
#end_block

#method_before
public void merge(ReviewDb db, Change change, IdentifiedUser caller, boolean checkSubmitRules, SubmitInput submitInput) throws OrmException, RestApiException {
    this.submitInput = submitInput;
    this.caller = caller;
    updateSubmissionId(change);
    this.db = db;
    logDebug("Beginning integration of {}", change);
    try {
        ChangeSet cs = mergeSuperSet.completeChangeSet(db, change, caller);
        checkState(cs.ids().contains(change.getId()), "change %s missing from %s", change.getId(), cs);
        this.commits = new CommitStatus(cs);
        MergeSuperSet.reloadChanges(cs);
        logDebug("Calculated to merge {}", cs);
        if (checkSubmitRules) {
            logDebug("Checking submit rules and state");
            checkSubmitRulesAndState(cs);
            // Done checks that don't involve opening repo.
            failFast(cs);
        } else {
            logDebug("Bypassing submit rules");
            bypassSubmitRules(cs);
        }
        try {
            integrateIntoHistory(cs);
        } catch (IntegrationException e) {
            logError("Error from integrateIntoHistory", e);
            throw new ResourceConflictException(e.getMessage(), e);
        }
    } catch (IOException e) {
        // Anything before the merge attempt is an error
        throw new OrmException(e);
    }
}
#method_after
public void merge(ReviewDb db, Change change, IdentifiedUser caller, boolean checkSubmitRules, SubmitInput submitInput) throws OrmException, RestApiException {
    this.submitInput = submitInput;
    this.caller = caller;
    updateSubmissionId(change);
    this.db = db;
    orm.setContext(db, ts, caller);
    logDebug("Beginning integration of {}", change);
    try {
        ChangeSet cs = mergeSuperSet.completeChangeSet(db, change, caller);
        checkState(cs.ids().contains(change.getId()), "change %s missing from %s", change.getId(), cs);
        this.commits = new CommitStatus(cs);
        MergeSuperSet.reloadChanges(cs);
        logDebug("Calculated to merge {}", cs);
        if (checkSubmitRules) {
            logDebug("Checking submit rules and state");
            checkSubmitRulesAndState(cs);
            // Done checks that don't involve opening repo.
            failFast(cs);
        } else {
            logDebug("Bypassing submit rules");
            bypassSubmitRules(cs);
        }
        try {
            integrateIntoHistory(cs);
        } catch (IntegrationException e) {
            logError("Error from integrateIntoHistory", e);
            throw new ResourceConflictException(e.getMessage(), e);
        }
    } catch (IOException e) {
        // Anything before the merge attempt is an error
        throw new OrmException(e);
    }
}
#end_block

#method_before
private void integrateIntoHistory(ChangeSet cs) throws IntegrationException, RestApiException {
    logDebug("Beginning merge attempt on {}", cs);
    Map<Branch.NameKey, BranchBatch> toSubmit = new HashMap<>();
    logDebug("Perform the merges");
    Multimap<Project.NameKey, Branch.NameKey> br;
    Multimap<Branch.NameKey, ChangeData> cbb;
    try {
        br = cs.branchesByProject();
        cbb = cs.changesByBranch();
    } catch (OrmException e) {
        throw new IntegrationException("Error reading changes to submit", e);
    }
    Set<Project.NameKey> projects = br.keySet();
    Collection<Branch.NameKey> branches = cbb.keySet();
    openRepos(projects);
    for (Branch.NameKey branch : branches) {
        OpenRepo or = getRepo(branch.getParentKey());
        toSubmit.put(branch, validateChangeList(or, cbb.get(branch)));
    }
    // Done checks that don't involve running submit strategies.
    failFast(cs);
    List<SubmitStrategy> strategies = new ArrayList<>(branches.size());
    for (Branch.NameKey branch : branches) {
        OpenRepo or = getRepo(branch.getParentKey());
        OpenBranch ob = or.getBranch(branch);
        BranchBatch submitting = toSubmit.get(branch);
        checkNotNull(submitting.submitType(), "null submit type for %s; expected to previously fail fast", submitting);
        Set<CodeReviewCommit> commitsToSubmit = commits(submitting.changes());
        ob.mergeTip = new MergeTip(ob.oldTip, commitsToSubmit);
        SubmitStrategy strategy = createStrategy(or, ob.mergeTip, branch, submitting.submitType(), ob.oldTip);
        strategies.add(strategy);
        strategy.addOps(or.getUpdate(), commitsToSubmit);
    }
    try {
        BatchUpdate.execute(batchUpdates(projects), new SubmitStrategyListener(submitInput, strategies, commits));
    } catch (UpdateException e) {
        // BatchUpdate may have inadvertently wrapped an IntegrationException
        // thrown by some legacy SubmitStrategyOp code that intended the error
        // message to be user-visible. Copy the message from the wrapped
        // exception.
        // 
        // If you happen across one of these, the correct fix is to convert the
        // inner IntegrationException to a ResourceConflictException.
        String msg;
        if (e.getCause() instanceof IntegrationException) {
            msg = e.getCause().getMessage();
        } else {
            msg = "Error submitting change" + (cs.size() != 1 ? "s" : "");
        }
        throw new IntegrationException(msg, e);
    }
    SubmoduleOp subOp = subOpProvider.get();
    updateSuperProjects(subOp, br.values());
}
#method_after
private void integrateIntoHistory(ChangeSet cs) throws IntegrationException, RestApiException {
    logDebug("Beginning merge attempt on {}", cs);
    Map<Branch.NameKey, BranchBatch> toSubmit = new HashMap<>();
    logDebug("Perform the merges");
    Multimap<Project.NameKey, Branch.NameKey> br;
    Multimap<Branch.NameKey, ChangeData> cbb;
    try {
        br = cs.branchesByProject();
        cbb = cs.changesByBranch();
    } catch (OrmException e) {
        throw new IntegrationException("Error reading changes to submit", e);
    }
    Set<Project.NameKey> projects = br.keySet();
    Collection<Branch.NameKey> branches = cbb.keySet();
    openRepos(projects);
    for (Branch.NameKey branch : branches) {
        OpenRepo or = orm.getRepo(branch.getParentKey());
        toSubmit.put(branch, validateChangeList(or, cbb.get(branch)));
    }
    // Done checks that don't involve running submit strategies.
    failFast(cs);
    List<SubmitStrategy> strategies = new ArrayList<>(branches.size());
    for (Branch.NameKey branch : branches) {
        OpenRepo or = orm.getRepo(branch.getParentKey());
        OpenBranch ob = or.getBranch(branch);
        BranchBatch submitting = toSubmit.get(branch);
        checkNotNull(submitting.submitType(), "null submit type for %s; expected to previously fail fast", submitting);
        Set<CodeReviewCommit> commitsToSubmit = commits(submitting.changes());
        ob.mergeTip = new MergeTip(ob.oldTip, commitsToSubmit);
        SubmitStrategy strategy = createStrategy(or, ob.mergeTip, branch, submitting.submitType(), ob.oldTip);
        strategies.add(strategy);
        strategy.addOps(or.getUpdate(), commitsToSubmit);
    }
    try {
        BatchUpdate.execute(batchUpdates(projects), new SubmitStrategyListener(submitInput, strategies, commits));
    } catch (UpdateException e) {
        // BatchUpdate may have inadvertently wrapped an IntegrationException
        // thrown by some legacy SubmitStrategyOp code that intended the error
        // message to be user-visible. Copy the message from the wrapped
        // exception.
        // 
        // If you happen across one of these, the correct fix is to convert the
        // inner IntegrationException to a ResourceConflictException.
        String msg;
        if (e.getCause() instanceof IntegrationException) {
            msg = e.getCause().getMessage();
        } else {
            msg = "Error submitting change" + (cs.size() != 1 ? "s" : "");
        }
        throw new IntegrationException(msg, e);
    }
    updateSuperProjects(br.values());
}
#end_block

#method_before
private List<BatchUpdate> batchUpdates(Collection<Project.NameKey> projects) {
    List<BatchUpdate> updates = new ArrayList<>(projects.size());
    for (Project.NameKey project : projects) {
        updates.add(getRepo(project).getUpdate());
    }
    return updates;
}
#method_after
private List<BatchUpdate> batchUpdates(Collection<Project.NameKey> projects) {
    List<BatchUpdate> updates = new ArrayList<>(projects.size());
    for (Project.NameKey project : projects) {
        updates.add(orm.getRepo(project).getUpdate());
    }
    return updates;
}
#end_block

#method_before
private SubmitStrategy createStrategy(OpenRepo or, MergeTip mergeTip, Branch.NameKey destBranch, SubmitType submitType, CodeReviewCommit branchTip) throws IntegrationException {
    return submitStrategyFactory.create(submitType, db, or.repo, or.rw, or.ins, or.canMergeFlag, getAlreadyAccepted(or, branchTip), destBranch, caller, mergeTip, commits, submissionId);
}
#method_after
private SubmitStrategy createStrategy(OpenRepo or, MergeTip mergeTip, Branch.NameKey destBranch, SubmitType submitType, CodeReviewCommit branchTip) throws IntegrationException {
    return submitStrategyFactory.create(submitType, db, or.repo, or.rw, or.ins, or.canMergeFlag, getAlreadyAccepted(or, branchTip), destBranch, caller, mergeTip, commits, submissionId, submitInput.notify);
}
#end_block

#method_before
private void updateSuperProjects(SubmoduleOp subOp, Collection<Branch.NameKey> branches) {
    logDebug("Updating superprojects");
    try {
        subOp.updateSuperProjects(db, branches, submissionId);
        logDebug("Updating superprojects done");
    } catch (SubmoduleException e) {
        logError("The gitlinks were not updated according to the " + "subscriptions", e);
    }
}
#method_after
private void updateSuperProjects(Collection<Branch.NameKey> branches) {
    logDebug("Updating superprojects");
    SubmoduleOp subOp = subOpProvider.get();
    try {
        subOp.updateSuperProjects(db, branches, submissionId, orm);
        logDebug("Updating superprojects done");
    } catch (SubmoduleException e) {
        logError("The gitlinks were not updated according to the " + "subscriptions", e);
    }
}
#end_block

#method_before
private void openRepos(Collection<Project.NameKey> projects) throws IntegrationException {
    for (Project.NameKey project : projects) {
        try {
            openRepo(project, true);
        } catch (NoSuchProjectException noProject) {
            logWarn("Project " + noProject.project() + " no longer exists, " + "abandoning open changes");
            abandonAllOpenChangeForDeletedProject(noProject.project());
        } catch (IOException e) {
            throw new IntegrationException("Error opening project " + project, e);
        }
    }
}
#method_after
private void openRepos(Collection<Project.NameKey> projects) throws IntegrationException {
    for (Project.NameKey project : projects) {
        try {
            orm.openRepo(project, true);
        } catch (NoSuchProjectException noProject) {
            logWarn("Project " + noProject.project() + " no longer exists, " + "abandoning open changes");
            abandonAllOpenChangeForDeletedProject(noProject.project());
        } catch (IOException e) {
            throw new IntegrationException("Error opening project " + project, e);
        }
    }
}
#end_block

#method_before
void load() throws IOException {
    Project.NameKey project = branch.getParentKey();
    logDebug("Loading .gitmodules of {} for project {}", branch, project);
    try {
        mergeOp.openRepo(project, false);
    } catch (NoSuchProjectException e) {
        throw new IOException(e);
    }
    OpenRepo or = mergeOp.getRepo(project);
    ObjectId id = or.repo.resolve(branch.get());
    if (id == null) {
        throw new IOException("Cannot open branch " + branch.get());
    }
    RevCommit commit = or.rw.parseCommit(id);
    TreeWalk tw = TreeWalk.forPath(or.repo, GIT_MODULES, commit.getTree());
    if (tw == null || (tw.getRawMode(0) & FileMode.TYPE_MASK) != FileMode.TYPE_FILE) {
        return;
    }
    try {
        BlobBasedConfig bbc = new BlobBasedConfig(null, or.repo, commit, GIT_MODULES);
        subscriptions = subSecParserFactory.create(bbc, thisServer, branch).parseAllSections();
    } catch (ConfigInvalidException e) {
        throw new IOException("Could not read .gitmodule file of super project: " + branch.getParentKey(), e);
    }
}
#method_after
void load() throws IOException {
    Project.NameKey project = branch.getParentKey();
    logDebug("Loading .gitmodules of {} for project {}", branch, project);
    try {
        orm.openRepo(project, false);
    } catch (NoSuchProjectException e) {
        throw new IOException(e);
    }
    OpenRepo or = orm.getRepo(project);
    ObjectId id = or.repo.resolve(branch.get());
    if (id == null) {
        throw new IOException("Cannot open branch " + branch.get());
    }
    RevCommit commit = or.rw.parseCommit(id);
    TreeWalk tw = TreeWalk.forPath(or.repo, GIT_MODULES, commit.getTree());
    if (tw == null || (tw.getRawMode(0) & FileMode.TYPE_MASK) != FileMode.TYPE_FILE) {
        return;
    }
    try {
        BlobBasedConfig bbc = new BlobBasedConfig(null, or.repo, commit, GIT_MODULES);
        subscriptions = subSecParserFactory.create(bbc, thisServer, branch).parseAllSections();
    } catch (ConfigInvalidException e) {
        throw new IOException("Could not read .gitmodule file of super project: " + branch.getParentKey(), e);
    }
}
#end_block

#method_before
@Override
public String healthCheck(final Check check) throws IOException {
    if (check.equals(Check.ACCESS))
        return healthCheckAccess();
    else
        return healthCheckSysinfo();
}
#method_after
@Override
public String healthCheck(final Check check) throws IOException {
    return execute(new Callable<String>() {

        @Override
        public String call() throws Exception {
            if (check.equals(Check.ACCESS))
                return healthCheckAccess();
            else
                return healthCheckSysinfo();
        }
    });
}
#end_block

#method_before
@Override
public void addComment(final String issueKey, final String comment) throws IOException {
    try {
        log.debug("Adding comment {} to issue {}", comment, issueKey);
        client().addComment(issueKey, Comment.valueOf(comment));
        log.debug("Added comment {} to issue {}", comment, issueKey);
    } catch (IOException e) {
        log.error("Failed to add comment {} to issue {}", comment, issueKey);
    }
}
#method_after
@Override
public void addComment(final String issueKey, final String comment) throws IOException {
    execute(new Callable<String>() {

        @Override
        public String call() throws Exception {
            log.debug("Adding comment {} to issue {}", comment, issueKey);
            client().addComment(issueKey, Comment.valueOf(comment));
            log.debug("Added comment {} to issue {}", comment, issueKey);
            return issueKey;
        }
    });
}
#end_block

#method_before
@Override
public void performAction(final String issueKey, final String actionName) throws IOException {
    try {
        log.debug("Performing action {} on issue {}", actionName, issueKey);
        doPerformAction(issueKey, actionName);
    } catch (IOException e) {
        log.error("Failed to perform action {} on issue {}", actionName, issueKey);
        throw new IOException(e);
    }
}
#method_after
@Override
public void performAction(final String issueKey, final String actionName) throws IOException {
    execute(new Callable<String>() {

        @Override
        public String call() throws Exception {
            log.debug("Performing action {} on issue {}", actionName, issueKey);
            doPerformAction(issueKey, actionName);
            return issueKey;
        }
    });
}
#end_block

#method_before
private void doPerformAction(final String issueKey, final String actionName) throws IOException {
    log.debug("Trying to perform action: " + actionName + " on issue " + issueKey);
    try {
        boolean ret = client().doTransition(issueKey, actionName);
        if (ret) {
            log.debug("Action " + actionName + " successful on Issue " + issueKey);
        } else {
            log.debug("Transitioning to current status not possible");
        }
    } catch (IOException e) {
        StringBuilder sb = new StringBuilder();
        for (Transition t : client().getTransitions(issueKey)) {
            if (sb.length() > 0) {
                sb.append(',');
            }
            sb.append('\'');
            sb.append(t.getName());
            sb.append('\'');
        }
        log.error("Available Transitions: " + sb);
        throw e;
    }
}
#method_after
private void doPerformAction(final String issueKey, final String actionName) throws IOException {
    log.debug("Trying to perform action: " + actionName + " on issue " + issueKey);
    boolean ret = client().doTransition(issueKey, actionName);
    if (ret) {
        log.debug("Action " + actionName + " successful on Issue " + issueKey);
    } else {
        log.debug("Action {} on Issue {} not possible", actionName, issueKey);
    }
}
#end_block

#method_before
@Override
public boolean exists(final String issueKey) throws IOException {
    return client().issueExists(issueKey);
}
#method_after
@Override
public boolean exists(final String issueKey) throws IOException {
    return execute(new Callable<Boolean>() {

        @Override
        public Boolean call() throws Exception {
            return client().issueExists(issueKey);
        }
    });
}
#end_block

#method_before
private JiraClient client() throws IOException {
    if (client == null) {
        try {
            log.debug("Connecting to jira at {}", getUrl());
            client = new JiraClient(getUrl(), getUsername(), getPassword());
            log.debug("Authenticating as User {}", getUsername());
        } catch (URISyntaxException e) {
            log.error("Connecting failed at {} as user {}", getUrl(), getUsername());
            throw new IOException(e);
        }
    }
    return client;
}
#method_after
private JiraClient client() throws IOException {
    if (client == null) {
        try {
            log.debug("Connecting to jira at {}", getUrl());
            client = new JiraClient(getUrl(), getUsername(), getPassword());
            log.debug("Authenticating as User {}", getUsername());
        } catch (Exception e) {
            log.info("Unable to connect to " + getUrl() + " as " + getUsername());
            throw new IOException(e);
        }
    }
    return client;
}
#end_block

#method_before
private String healthCheckAccess() throws IOException {
    try {
        new JiraClient(getUrl(), getUsername(), getPassword()).sysInfo();
    } catch (URISyntaxException e) {
        throw new IOException(e);
    }
    final String result = "{\"status\"=\"ok\",\"username\"=\"" + getUsername() + "\"}";
    log.debug("Healtheck on access result: {}", result);
    return result;
}
#method_after
private String healthCheckAccess() throws IOException {
    client().sysInfo();
    final String result = "{\"status\"=\"ok\",\"username\"=\"" + getUsername() + "\"}";
    log.debug("Healtheck on access result: {}", result);
    return result;
}
#end_block

#method_before
public Issue getIssue(String issueKey) throws IOException {
    IssueRestClient issueClient = this.client.getIssueClient();
    Promise<Issue> promise = issueClient.getIssue(issueKey);
    try {
        return promise.claim();
    } catch (Exception e) {
        log.error("Failed to get issue by issuekey " + issueKey);
        throw new IOException(e);
    }
}
#method_after
public Issue getIssue(String issueKey) throws RestClientException {
    IssueRestClient issueClient = this.client.getIssueClient();
    return issueClient.getIssue(issueKey).claim();
}
#end_block

#method_before
public boolean issueExists(String issueKey) {
    try {
        getIssue(issueKey);
        return true;
    } catch (IOException e) {
        log.error("Issue " + issueKey + " not found " + e.getCause().getMessage());
        return false;
    }
}
#method_after
public boolean issueExists(String issueKey) throws RestClientException {
    boolean ret = true;
    try {
        getIssue(issueKey);
    } catch (RestClientException e) {
        if (e.getStatusCode().get() == 404) {
            log.error("Issue " + issueKey + " not found ");
            ret = false;
        } else {
            throw e;
        }
    }
    return ret;
}
#end_block

#method_before
public Iterable<Transition> getTransitions(String issueKey) throws IOException {
    try {
        return client.getIssueClient().getTransitions(getIssue(issueKey)).get();
    } catch (Exception e) {
        log.error("Failed to retrieve transitions of issue " + issueKey);
        throw new IOException("Transitions error", e);
    }
}
#method_after
public Iterable<Transition> getTransitions(String issueKey) throws RestClientException {
    return client.getIssueClient().getTransitions(getIssue(issueKey)).claim();
}
#end_block

#method_before
public void addComment(String issueKey, Comment comment) throws IOException {
    try {
        log.debug("Trying to add comment for issue " + issueKey);
        Issue issue = getIssue(issueKey);
        URI issueUri = new URI(issue.getSelf().toString() + "/comment/");
        IssueRestClient issueClient = client.getIssueClient();
        Promise<Void> promise = issueClient.addComment(issueUri, comment);
        promise.claim();
        log.debug("Comment added to issue " + issueKey);
    } catch (Exception e) {
        log.error("Could not add comment to issue " + issueKey);
        throw new IOException("Adding Comment to issue " + issueKey + " failed", e);
    }
}
#method_after
public void addComment(String issueKey, Comment comment) throws RestClientException, URISyntaxException {
    log.debug("Trying to add comment for issue " + issueKey);
    Issue issue = getIssue(issueKey);
    URI issueUri;
    issueUri = new URI(issue.getSelf().toString() + "/comment/");
    IssueRestClient issueClient = client.getIssueClient();
    Promise<Void> promise = issueClient.addComment(issueUri, comment);
    promise.claim();
    log.debug("Comment added to issue " + issueKey);
}
#end_block

#method_before
public boolean doTransition(String issueKey, String transition) {
    Transition t;
    boolean result = false;
    try {
        t = getTransitionByName(getTransitions(issueKey), transition);
        TransitionInput input;
        input = new TransitionInput(t.getId());
        log.debug("Setting transition input to: " + input.toString());
        client.getIssueClient().transition(getIssue(issueKey), input).claim();
        result = true;
    } catch (IOException e) {
        log.error(e.getMessage());
    }
    return result;
}
#method_after
public boolean doTransition(String issueKey, String transition) throws RestClientException, InvalidTransitionException {
    Transition t = getTransitionByName(getTransitions(issueKey), transition);
    if (t == null) {
        throw new InvalidTransitionException("Action " + transition + " not executable on issue " + issueKey);
    }
    TransitionInput input;
    input = new TransitionInput(t.getId());
    log.debug("Setting transition input to: " + input.toString());
    client.getIssueClient().transition(getIssue(issueKey), input).claim();
    return true;
}
#end_block

#method_before
public ServerInfo sysInfo() throws IOException {
    try {
        return client.getMetadataClient().getServerInfo().get();
    } catch (InterruptedException e) {
        log.error("Serverinfo request interrupted");
        throw new IOException(e);
    } catch (ExecutionException e) {
        log.error(e.getMessage());
        throw new IOException(e);
    }
}
#method_after
public ServerInfo sysInfo() throws RestClientException {
    return client.getMetadataClient().getServerInfo().claim();
}
#end_block

#method_before
private Transition getTransitionByName(Iterable<Transition> transitions, String transition) throws IOException {
    for (Transition t : transitions) {
        if (transition.equals(t.getName())) {
            return t;
        }
    }
    throw new IOException("No matching transition found");
}
#method_after
private Transition getTransitionByName(Iterable<Transition> transitions, String transition) {
    Transition ret = null;
    for (Transition t : transitions) {
        if (transition.equals(t.getName())) {
            ret = t;
            break;
        }
    }
    return ret;
}
#end_block

#method_before
private boolean isJiraConnectSuccessful() {
    ui.message("Checking Jira connectivity ... ");
    try {
        new JiraClient(jiraUrl, jiraUsername, jiraPassword).sysInfo().getVersion();
        ui.message("[OK]\n");
        return true;
    } catch (URISyntaxException | IOException e) {
        ui.message("*FAILED* (%s)\n", e.toString());
        return false;
    }
}
#method_after
private boolean isJiraConnectSuccessful() {
    ui.message("Checking Jira connectivity ... ");
    try {
        new JiraClient(jiraUrl, jiraUsername, jiraPassword).sysInfo().getVersion();
        ui.message("[OK]\n");
        return true;
    } catch (URISyntaxException e) {
        ui.message("*FAILED* (%s)\n", e.toString());
        return false;
    }
}
#end_block

#method_before
@Override
public Response<?> apply(ReviewerResource rsrc, Input input) throws AuthException, ResourceNotFoundException, OrmException, IOException {
    ChangeControl control = rsrc.getControl();
    Change.Id changeId = rsrc.getId();
    ReviewDb db = dbProvider.get();
    ChangeUpdate update = updateFactory.create(rsrc.getControl());
    StringBuilder msg = new StringBuilder();
    db.changes().beginTransaction(changeId);
    try {
        List<PatchSetApproval> del = Lists.newArrayList();
        for (PatchSetApproval a : approvals(db, rsrc)) {
            if (control.canRemoveReviewer(a)) {
                del.add(a);
                if (a.getPatchSetId().equals(control.getChange().currentPatchSetId()) && a.getValue() != 0) {
                    if (msg.length() == 0) {
                        msg.append("Removed the following votes:\n\n");
                    }
                    msg.append("* ").append(a.getLabel()).append(formatLabelValue(a.getValue())).append(" by ").append(userFactory.create(a.getAccountId()).getNameEmail()).append("\n");
                }
            } else {
                throw new AuthException("delete not permitted");
            }
        }
        if (del.isEmpty()) {
            throw new ResourceNotFoundException();
        }
        ChangeUtil.bumpRowVersionNotLastUpdatedOn(rsrc.getId(), db);
        db.patchSetApprovals().delete(del);
        update.removeReviewer(rsrc.getUser().getAccountId());
        if (msg.length() > 0) {
            ChangeMessage changeMessage = new ChangeMessage(new ChangeMessage.Key(rsrc.getId(), ChangeUtil.messageUUID(db)), control.getUser().getAccountId(), TimeUtil.nowTs(), rsrc.getChange().currentPatchSetId());
            changeMessage.setMessage(msg.toString());
            cmUtil.addChangeMessage(db, update, changeMessage);
        }
        emailReviewers(rsrc.getChange(), del);
        if (!del.isEmpty()) {
            PatchSet patchSet = dbProvider.get().patchSets().get(rsrc.getChange().currentPatchSetId());
            for (PatchSetApproval psa : del) {
                Account account = accountCache.get(psa.getAccountId()).getAccount();
                hooks.doReviewerDeletedHook(rsrc.getChange(), account, patchSet, dbProvider.get());
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    indexer.index(db, rsrc.getChange());
    return Response.none();
}
#method_after
@Override
public Response<?> apply(ReviewerResource rsrc, Input input) throws RestApiException, UpdateException {
    try (BatchUpdate bu = batchUpdateFactory.create(dbProvider.get(), rsrc.getChangeResource().getProject(), rsrc.getChangeResource().getUser(), TimeUtil.nowTs())) {
        Op op = new Op(rsrc.getReviewerUser().getAccount());
        bu.addOp(rsrc.getChange().getId(), op);
        bu.execute();
    }
    return Response.none();
}
#end_block

#method_before
private void emailReviewers(Change change, List<PatchSetApproval> approvals) {
    if (approvals.isEmpty()) {
        return;
    }
    // Email the reviewers
    // 
    // The user knows they removed themselves, don't bother emailing them.
    List<Account.Id> toMail = Lists.newArrayListWithCapacity(approvals.size());
    Account.Id userId = user.get().getAccountId();
    for (PatchSetApproval psa : approvals) {
        if (!psa.getAccountId().equals(userId)) {
            toMail.add(psa.getAccountId());
        }
    }
    if (!toMail.isEmpty()) {
        try {
            DeleteReviewerSender cm = deleteReviewerSenderFactory.create(change.getId());
            cm.setFrom(userId);
            cm.addReviewers(toMail);
            cm.send();
        } catch (Exception err) {
            log.error("Cannot send email to new reviewers of change " + change.getId(), err);
        }
    }
}
#method_after
private void emailReviewers(Project.NameKey projectName, Change change, List<PatchSetApproval> dels, ChangeMessage changeMessage) {
    // The user knows they removed themselves, don't bother emailing them.
    List<Account.Id> toMail = Lists.newArrayListWithCapacity(dels.size());
    Account.Id userId = user.get().getAccountId();
    for (PatchSetApproval psa : dels) {
        if (!psa.getAccountId().equals(userId)) {
            toMail.add(psa.getAccountId());
        }
    }
    if (!toMail.isEmpty()) {
        try {
            DeleteReviewerSender cm = deleteReviewerSenderFactory.create(projectName, change.getId());
            cm.setFrom(userId);
            cm.addReviewers(toMail);
            cm.setChangeMessage(changeMessage);
            cm.send();
        } catch (Exception err) {
            log.error("Cannot email update for change " + change.getId(), err);
        }
    }
}
#end_block

#method_before
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(ChangeKindCacheImpl.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(MergeabilityCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new GitModule());
    install(new GroupModule());
    install(new NoteDbModule());
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(DeleteReviewerSender.Factory.class);
    factory(AddKeySender.Factory.class);
    factory(BatchUpdate.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeData.Factory.class);
    factory(ChangeJson.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(EmailMerge.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    factory(ProjectOwnerGroupsProvider.Factory.class);
    bind(RepositoryConfig.class);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(GitwebConfig.class);
    bind(GcConfig.class);
    bind(ChangeCleanupConfig.class);
    bind(ApprovalsUtil.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(Boolean.class).annotatedWith(DisableReverseDnsLookup.class).toProvider(DisableReverseDnsLookupProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), ReceivePackInitializer.class);
    DynamicSet.setOf(binder(), PostReceiveHook.class);
    DynamicSet.setOf(binder(), PreUploadHook.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), GarbageCollectorListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.setOf(binder(), UsageDataPublishedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ReindexAfterUpdate.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ProjectConfigEntry.UpdateChecker.class);
    DynamicSet.bind(binder(), EventListener.class).to(EventsMetrics.class);
    DynamicSet.setOf(binder(), EventListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), RefOperationValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicSet.setOf(binder(), ProjectCreationValidationListener.class);
    DynamicSet.setOf(binder(), GroupCreationValidationListener.class);
    DynamicSet.setOf(binder(), HashtagValidationListener.class);
    DynamicSet.setOf(binder(), OutgoingEmailValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), CloneCommand.class);
    DynamicMap.mapOf(binder(), ExternalIncludedIn.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    DynamicSet.setOf(binder(), PatchSetWebLink.class);
    DynamicSet.setOf(binder(), FileWebLink.class);
    DynamicSet.setOf(binder(), FileHistoryWebLink.class);
    DynamicSet.setOf(binder(), DiffWebLink.class);
    DynamicSet.setOf(binder(), ProjectWebLink.class);
    DynamicSet.setOf(binder(), BranchWebLink.class);
    factory(UploadValidators.Factory.class);
    DynamicSet.setOf(binder(), UploadValidationListener.class);
    DynamicMap.mapOf(binder(), ChangeQueryBuilder.ChangeOperatorFactory.class);
    bind(AnonymousUser.class);
    factory(CommitValidators.Factory.class);
    factory(RefOperationValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    factory(SubmoduleSectionParser.Factory.class);
    bind(AccountManager.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#method_after
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    bind(BlameCache.class).to(BlameCacheImpl.class);
    bind(Sequences.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(ChangeKindCacheImpl.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(MergeabilityCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(SubmitStrategy.module());
    install(TagCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new GitModule());
    install(new GroupModule());
    install(new NoteDbModule());
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(DeleteReviewerSender.Factory.class);
    factory(AddKeySender.Factory.class);
    factory(BatchUpdate.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeData.Factory.class);
    factory(ChangeJson.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(EmailMerge.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    factory(ProjectOwnerGroupsProvider.Factory.class);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(GitwebConfig.class);
    bind(GcConfig.class);
    bind(ChangeCleanupConfig.class);
    bind(ApprovalsUtil.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(Boolean.class).annotatedWith(DisableReverseDnsLookup.class).toProvider(DisableReverseDnsLookupProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), ReceivePackInitializer.class);
    DynamicSet.setOf(binder(), PostReceiveHook.class);
    DynamicSet.setOf(binder(), PreUploadHook.class);
    DynamicSet.setOf(binder(), ChangeIndexedListener.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), GarbageCollectorListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.setOf(binder(), UsageDataPublishedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ReindexAfterUpdate.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ProjectConfigEntry.UpdateChecker.class);
    DynamicSet.setOf(binder(), EventListener.class);
    DynamicSet.bind(binder(), EventListener.class).to(EventsMetrics.class);
    DynamicSet.setOf(binder(), UserScopedEventListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), RefOperationValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicSet.setOf(binder(), ProjectCreationValidationListener.class);
    DynamicSet.setOf(binder(), GroupCreationValidationListener.class);
    DynamicSet.setOf(binder(), HashtagValidationListener.class);
    DynamicSet.setOf(binder(), OutgoingEmailValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), CloneCommand.class);
    DynamicMap.mapOf(binder(), ExternalIncludedIn.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    DynamicSet.setOf(binder(), PatchSetWebLink.class);
    DynamicSet.setOf(binder(), FileWebLink.class);
    DynamicSet.setOf(binder(), FileHistoryWebLink.class);
    DynamicSet.setOf(binder(), DiffWebLink.class);
    DynamicSet.setOf(binder(), ProjectWebLink.class);
    DynamicSet.setOf(binder(), BranchWebLink.class);
    DynamicMap.mapOf(binder(), OAuthLoginProvider.class);
    DynamicSet.setOf(binder(), AccountExternalIdCreator.class);
    DynamicSet.setOf(binder(), WebUiPlugin.class);
    factory(UploadValidators.Factory.class);
    DynamicSet.setOf(binder(), UploadValidationListener.class);
    DynamicMap.mapOf(binder(), ChangeQueryBuilder.ChangeOperatorFactory.class);
    bind(AnonymousUser.class);
    factory(CommitValidators.Factory.class);
    factory(RefOperationValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    factory(SubmoduleSectionParser.Factory.class);
    factory(ReplaceOp.Factory.class);
    factory(GitModules.Factory.class);
    bind(AccountManager.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ChangeHookRunner.class);
    bind(ChangeHooks.class).to(ChangeHookRunner.class);
    bind(EventDispatcher.class).to(ChangeHookRunner.class);
    bind(EventSource.class).to(ChangeHookRunner.class);
    DynamicSet.bind(binder(), NewProjectCreatedListener.class).to(ChangeHookRunner.class);
    listener().to(ChangeHookRunner.class);
}
#method_after
@Override
protected void configure() {
    bind(ChangeHookRunner.class);
    bind(ChangeHooks.class).to(ChangeHookRunner.class);
    DynamicSet.bind(binder(), NewProjectCreatedListener.class).to(ChangeHookRunner.class);
    listener().to(ChangeHookRunner.class);
}
#end_block

#method_before
private static Path hook(Config config, Path path, String name) {
    String setting = name.replace("-", "") + "hook";
    String value = config.getString("hooks", null, setting);
    return path.resolve(value != null ? value : name);
}
#method_after
private static Optional<Path> hook(Config config, Path path, String name) {
    String setting = name.replace("-", "") + "hook";
    String value = config.getString("hooks", null, setting);
    Path p = path.resolve(value != null ? value : name);
    return Files.exists(p) ? Optional.of(p) : Optional.<Path>absent();
}
#end_block

#method_before
@Override
public HookResult doRefUpdateHook(Project project, String refname, Account uploader, ObjectId oldId, ObjectId newId) {
    List<String> args = new ArrayList<>();
    addArg(args, "--project", project.getName());
    addArg(args, "--refname", refname);
    addArg(args, "--uploader", getDisplayName(uploader));
    addArg(args, "--oldrev", oldId.getName());
    addArg(args, "--newrev", newId.getName());
    return runSyncHook(project.getNameKey(), refUpdateHook, args);
}
#method_after
@Override
public HookResult doRefUpdateHook(Project project, String refname, Account uploader, ObjectId oldId, ObjectId newId) {
    if (!refUpdateHook.isPresent()) {
        return null;
    }
    List<String> args = new ArrayList<>();
    addArg(args, "--project", project.getName());
    addArg(args, "--refname", refname);
    addArg(args, "--uploader", getDisplayName(uploader));
    addArg(args, "--oldrev", oldId.getName());
    addArg(args, "--newrev", newId.getName());
    return runSyncHook(project.getNameKey(), refUpdateHook, args);
}
#end_block

#method_before
@Override
public void doProjectCreatedHook(Project.NameKey project, String headName) {
    ProjectCreatedEvent event = new ProjectCreatedEvent();
    event.projectName = project.get();
    event.headName = headName;
    fireEvent(project, event);
    List<String> args = new ArrayList<>();
    addArg(args, "--project", project.get());
    addArg(args, "--head", headName);
    runHook(project, projectCreatedHook, args);
}
#method_after
@Override
public void doProjectCreatedHook(Project.NameKey project, String headName) {
    ProjectCreatedEvent event = new ProjectCreatedEvent();
    event.projectName = project.get();
    event.headName = headName;
    dispatcher.get().postEvent(project, event);
    if (!projectCreatedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    addArg(args, "--project", project.get());
    addArg(args, "--head", headName);
    runHook(project, projectCreatedHook, args);
}
#end_block

#method_before
@Override
public void doPatchsetCreatedHook(Change change, PatchSet patchSet, ReviewDb db) throws OrmException {
    PatchSetCreatedEvent event = new PatchSetCreatedEvent();
    AccountState uploader = accountCache.get(patchSet.getUploader());
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(db, change);
    event.patchSet = asPatchSetAttribute(change, patchSet, db);
    event.uploader = eventFactory.asAccountAttribute(uploader.getAccount());
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--is-draft", String.valueOf(patchSet.isDraft()));
    addArg(args, "--kind", String.valueOf(event.patchSet.kind));
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--uploader", getDisplayName(uploader.getAccount()));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--patchset", event.patchSet.number);
    runHook(change.getProject(), patchsetCreatedHook, args);
}
#method_after
@Override
public void doPatchsetCreatedHook(Change change, PatchSet patchSet, ReviewDb db) throws OrmException {
    PatchSetCreatedEvent event = new PatchSetCreatedEvent(change);
    Supplier<AccountState> uploader = getAccountSupplier(patchSet.getUploader());
    Supplier<AccountState> owner = getAccountSupplier(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.uploader = accountAttributeSupplier(uploader);
    dispatcher.get().postEvent(change, event, db);
    if (!patchsetCreatedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    PatchSetAttribute ps = event.patchSet.get();
    addArg(args, "--change", c.id);
    addArg(args, "--is-draft", String.valueOf(patchSet.isDraft()));
    addArg(args, "--kind", String.valueOf(ps.kind));
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.get().getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--topic", c.topic);
    addArg(args, "--uploader", getDisplayName(uploader.get().getAccount()));
    addArg(args, "--commit", ps.revision);
    addArg(args, "--patchset", ps.number);
    runHook(change.getProject(), patchsetCreatedHook, args);
}
#end_block

#method_before
@Override
public void doDraftPublishedHook(Change change, PatchSet patchSet, ReviewDb db) throws OrmException {
    DraftPublishedEvent event = new DraftPublishedEvent();
    AccountState uploader = accountCache.get(patchSet.getUploader());
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(db, change);
    event.patchSet = asPatchSetAttribute(change, patchSet, db);
    event.uploader = eventFactory.asAccountAttribute(uploader.getAccount());
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--uploader", getDisplayName(uploader.getAccount()));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--patchset", event.patchSet.number);
    runHook(change.getProject(), draftPublishedHook, args);
}
#method_after
@Override
public void doDraftPublishedHook(Change change, PatchSet patchSet, ReviewDb db) throws OrmException {
    DraftPublishedEvent event = new DraftPublishedEvent(change);
    Supplier<AccountState> uploader = getAccountSupplier(patchSet.getUploader());
    Supplier<AccountState> owner = getAccountSupplier(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.uploader = accountAttributeSupplier(uploader);
    dispatcher.get().postEvent(change, event, db);
    if (!draftPublishedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    PatchSetAttribute ps = event.patchSet.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.get().getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--topic", c.topic);
    addArg(args, "--uploader", getDisplayName(uploader.get().getAccount()));
    addArg(args, "--commit", ps.revision);
    addArg(args, "--patchset", ps.number);
    runHook(change.getProject(), draftPublishedHook, args);
}
#end_block

#method_before
@Override
public void doCommentAddedHook(Change change, Account account, PatchSet patchSet, String comment, Map<String, Short> approvals, ReviewDb db) throws OrmException {
    CommentAddedEvent event = new CommentAddedEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(db, change);
    event.author = eventFactory.asAccountAttribute(account);
    event.patchSet = asPatchSetAttribute(change, patchSet, db);
    event.comment = comment;
    LabelTypes labelTypes = projectCache.get(change.getProject()).getLabelTypes();
    if (approvals.size() > 0) {
        event.approvals = new ApprovalAttribute[approvals.size()];
        int i = 0;
        for (Map.Entry<String, Short> approval : approvals.entrySet()) {
            event.approvals[i++] = getApprovalAttribute(labelTypes, approval);
        }
    }
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--is-draft", patchSet.isDraft() ? "true" : "false");
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--author", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--comment", comment == null ? "" : comment);
    for (Map.Entry<String, Short> approval : approvals.entrySet()) {
        LabelType lt = labelTypes.byLabel(approval.getKey());
        if (lt != null) {
            addArg(args, "--" + lt.getName(), Short.toString(approval.getValue()));
        }
    }
    runHook(change.getProject(), commentAddedHook, args);
}
#method_after
@Override
public void doCommentAddedHook(final Change change, Account account, PatchSet patchSet, String comment, final Map<String, Short> approvals, final Map<String, Short> oldApprovals, ReviewDb db) throws OrmException {
    CommentAddedEvent event = new CommentAddedEvent(change);
    Supplier<AccountState> owner = getAccountSupplier(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.author = accountAttributeSupplier(account);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.comment = comment;
    event.approvals = Suppliers.memoize(new Supplier<ApprovalAttribute[]>() {

        @Override
        public ApprovalAttribute[] get() {
            LabelTypes labelTypes = projectCache.get(change.getProject()).getLabelTypes();
            if (approvals.size() > 0) {
                ApprovalAttribute[] r = new ApprovalAttribute[approvals.size()];
                int i = 0;
                for (Map.Entry<String, Short> approval : approvals.entrySet()) {
                    r[i++] = getApprovalAttribute(labelTypes, approval, oldApprovals);
                }
                return r;
            }
            return null;
        }
    });
    dispatcher.get().postEvent(change, event, db);
    if (!commentAddedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    PatchSetAttribute ps = event.patchSet.get();
    addArg(args, "--change", c.id);
    addArg(args, "--is-draft", patchSet.isDraft() ? "true" : "false");
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.get().getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--topic", c.topic);
    addArg(args, "--author", getDisplayName(account));
    addArg(args, "--commit", ps.revision);
    addArg(args, "--comment", comment == null ? "" : comment);
    LabelTypes labelTypes = projectCache.get(change.getProject()).getLabelTypes();
    for (Map.Entry<String, Short> approval : approvals.entrySet()) {
        LabelType lt = labelTypes.byLabel(approval.getKey());
        if (lt != null && approval.getValue() != null) {
            addArg(args, "--" + lt.getName(), Short.toString(approval.getValue()));
            if (oldApprovals != null && !oldApprovals.isEmpty()) {
                Short oldValue = oldApprovals.get(approval.getKey());
                if (oldValue != null) {
                    addArg(args, "--" + lt.getName() + "-oldValue", Short.toString(oldValue));
                }
            }
        }
    }
    runHook(change.getProject(), commentAddedHook, args);
}
#end_block

#method_before
@Override
public void doChangeMergedHook(Change change, Account account, PatchSet patchSet, ReviewDb db, String mergeResultRev) throws OrmException {
    ChangeMergedEvent event = new ChangeMergedEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(db, change);
    event.submitter = eventFactory.asAccountAttribute(account);
    event.patchSet = asPatchSetAttribute(change, patchSet, db);
    event.newRev = mergeResultRev;
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--submitter", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--newrev", mergeResultRev);
    runHook(change.getProject(), changeMergedHook, args);
}
#method_after
@Override
public void doChangeMergedHook(Change change, Account account, PatchSet patchSet, ReviewDb db, String mergeResultRev) throws OrmException {
    ChangeMergedEvent event = new ChangeMergedEvent(change);
    Supplier<AccountState> owner = getAccountSupplier(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.submitter = accountAttributeSupplier(account);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.newRev = mergeResultRev;
    dispatcher.get().postEvent(change, event, db);
    if (!changeMergedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    PatchSetAttribute ps = event.patchSet.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.get().getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--topic", c.topic);
    addArg(args, "--submitter", getDisplayName(account));
    addArg(args, "--commit", ps.revision);
    addArg(args, "--newrev", mergeResultRev);
    runHook(change.getProject(), changeMergedHook, args);
}
#end_block

#method_before
@Override
public void doMergeFailedHook(Change change, Account account, PatchSet patchSet, String reason, ReviewDb db) throws OrmException {
    MergeFailedEvent event = new MergeFailedEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(db, change);
    event.submitter = eventFactory.asAccountAttribute(account);
    event.patchSet = asPatchSetAttribute(change, patchSet, db);
    event.reason = reason;
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--submitter", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--reason", reason == null ? "" : reason);
    runHook(change.getProject(), mergeFailedHook, args);
}
#method_after
@Override
public void doMergeFailedHook(Change change, Account account, PatchSet patchSet, String reason, ReviewDb db) throws OrmException {
    MergeFailedEvent event = new MergeFailedEvent(change);
    Supplier<AccountState> owner = getAccountSupplier(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.submitter = accountAttributeSupplier(account);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.reason = reason;
    dispatcher.get().postEvent(change, event, db);
    if (!mergeFailedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    PatchSetAttribute ps = event.patchSet.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.get().getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--topic", c.topic);
    addArg(args, "--submitter", getDisplayName(account));
    addArg(args, "--commit", ps.revision);
    addArg(args, "--reason", reason == null ? "" : reason);
    runHook(change.getProject(), mergeFailedHook, args);
}
#end_block

#method_before
@Override
public void doChangeAbandonedHook(Change change, Account account, PatchSet patchSet, String reason, ReviewDb db) throws OrmException {
    ChangeAbandonedEvent event = new ChangeAbandonedEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(db, change);
    event.abandoner = eventFactory.asAccountAttribute(account);
    event.patchSet = asPatchSetAttribute(change, patchSet, db);
    event.reason = reason;
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--abandoner", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--reason", reason == null ? "" : reason);
    runHook(change.getProject(), changeAbandonedHook, args);
}
#method_after
@Override
public void doChangeAbandonedHook(Change change, Account account, PatchSet patchSet, String reason, ReviewDb db) throws OrmException {
    ChangeAbandonedEvent event = new ChangeAbandonedEvent(change);
    AccountState owner = accountCache.get(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.abandoner = accountAttributeSupplier(account);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.reason = reason;
    dispatcher.get().postEvent(change, event, db);
    if (!changeAbandonedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    PatchSetAttribute ps = event.patchSet.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--topic", c.topic);
    addArg(args, "--abandoner", getDisplayName(account));
    addArg(args, "--commit", ps.revision);
    addArg(args, "--reason", reason == null ? "" : reason);
    runHook(change.getProject(), changeAbandonedHook, args);
}
#end_block

#method_before
@Override
public void doChangeRestoredHook(Change change, Account account, PatchSet patchSet, String reason, ReviewDb db) throws OrmException {
    ChangeRestoredEvent event = new ChangeRestoredEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(db, change);
    event.restorer = eventFactory.asAccountAttribute(account);
    event.patchSet = asPatchSetAttribute(change, patchSet, db);
    event.reason = reason;
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--restorer", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--reason", reason == null ? "" : reason);
    runHook(change.getProject(), changeRestoredHook, args);
}
#method_after
@Override
public void doChangeRestoredHook(Change change, Account account, PatchSet patchSet, String reason, ReviewDb db) throws OrmException {
    ChangeRestoredEvent event = new ChangeRestoredEvent(change);
    AccountState owner = accountCache.get(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.restorer = accountAttributeSupplier(account);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.reason = reason;
    dispatcher.get().postEvent(change, event, db);
    if (!changeRestoredHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    PatchSetAttribute ps = event.patchSet.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--topic", c.topic);
    addArg(args, "--restorer", getDisplayName(account));
    addArg(args, "--commit", ps.revision);
    addArg(args, "--reason", reason == null ? "" : reason);
    runHook(change.getProject(), changeRestoredHook, args);
}
#end_block

#method_before
@Override
public void doRefUpdatedHook(Branch.NameKey refName, ObjectId oldId, ObjectId newId, Account account) {
    RefUpdatedEvent event = new RefUpdatedEvent();
    if (account != null) {
        event.submitter = eventFactory.asAccountAttribute(account);
    }
    event.refUpdate = eventFactory.asRefUpdateAttribute(oldId, newId, refName);
    fireEvent(refName, event);
    List<String> args = new ArrayList<>();
    addArg(args, "--oldrev", event.refUpdate.oldRev);
    addArg(args, "--newrev", event.refUpdate.newRev);
    addArg(args, "--refname", event.refUpdate.refName);
    addArg(args, "--project", event.refUpdate.project);
    if (account != null) {
        addArg(args, "--submitter", getDisplayName(account));
    }
    runHook(refName.getParentKey(), refUpdatedHook, args);
}
#method_after
@Override
public void doRefUpdatedHook(final Branch.NameKey refName, final ObjectId oldId, final ObjectId newId, Account account) {
    RefUpdatedEvent event = new RefUpdatedEvent();
    if (account != null) {
        event.submitter = accountAttributeSupplier(account);
    }
    event.refUpdate = Suppliers.memoize(new Supplier<RefUpdateAttribute>() {

        @Override
        public RefUpdateAttribute get() {
            return eventFactory.asRefUpdateAttribute(oldId, newId, refName);
        }
    });
    dispatcher.get().postEvent(refName, event);
    if (!refUpdatedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    RefUpdateAttribute r = event.refUpdate.get();
    addArg(args, "--oldrev", r.oldRev);
    addArg(args, "--newrev", r.newRev);
    addArg(args, "--refname", r.refName);
    addArg(args, "--project", r.project);
    if (account != null) {
        addArg(args, "--submitter", getDisplayName(account));
    }
    runHook(refName.getParentKey(), refUpdatedHook, args);
}
#end_block

#method_before
@Override
public void doReviewerAddedHook(Change change, Account account, PatchSet patchSet, ReviewDb db) throws OrmException {
    ReviewerAddedEvent event = new ReviewerAddedEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(db, change);
    event.patchSet = asPatchSetAttribute(change, patchSet, db);
    event.reviewer = eventFactory.asAccountAttribute(account);
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--reviewer", getDisplayName(account));
    runHook(change.getProject(), reviewerAddedHook, args);
}
#method_after
@Override
public void doReviewerAddedHook(Change change, Account account, PatchSet patchSet, ReviewDb db) throws OrmException {
    ReviewerAddedEvent event = new ReviewerAddedEvent(change);
    Supplier<AccountState> owner = getAccountSupplier(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.reviewer = accountAttributeSupplier(account);
    dispatcher.get().postEvent(change, event, db);
    if (!reviewerAddedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.get().getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--reviewer", getDisplayName(account));
    runHook(change.getProject(), reviewerAddedHook, args);
}
#end_block

#method_before
@Override
public void doReviewerDeletedHook(Change change, Account account, PatchSet patchSet, ReviewDb db) throws OrmException {
    ReviewerDeletedEvent event = new ReviewerDeletedEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(db, change);
    event.patchSet = asPatchSetAttribute(change, patchSet, db);
    event.reviewer = eventFactory.asAccountAttribute(account);
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--reviewer", getDisplayName(account));
    runHook(change.getProject(), reviewerDeletedHook, args);
}
#method_after
@Override
public void doReviewerDeletedHook(final Change change, Account account, PatchSet patchSet, String comment, final Map<String, Short> approvals, final Map<String, Short> oldApprovals, ReviewDb db) throws OrmException {
    ReviewerDeletedEvent event = new ReviewerDeletedEvent(change);
    event.change = changeAttributeSupplier(change);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.reviewer = accountAttributeSupplier(account);
    event.comment = comment;
    event.approvals = Suppliers.memoize(new Supplier<ApprovalAttribute[]>() {

        @Override
        public ApprovalAttribute[] get() {
            LabelTypes labelTypes = projectCache.get(change.getProject()).getLabelTypes();
            if (!approvals.isEmpty()) {
                ApprovalAttribute[] r = new ApprovalAttribute[approvals.size()];
                int i = 0;
                for (Map.Entry<String, Short> approval : approvals.entrySet()) {
                    r[i++] = getApprovalAttribute(labelTypes, approval, oldApprovals);
                }
                return r;
            }
            return null;
        }
    });
    dispatcher.get().postEvent(change, event, db);
    if (!reviewerDeletedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    AccountState owner = accountCache.get(change.getOwner());
    addArg(args, "--change", c.id);
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--reviewer", getDisplayName(account));
    LabelTypes labelTypes = projectCache.get(change.getProject()).getLabelTypes();
    // append votes that were removed
    for (Map.Entry<String, Short> approval : approvals.entrySet()) {
        LabelType lt = labelTypes.byLabel(approval.getKey());
        if (lt != null && approval.getValue() != null) {
            addArg(args, "--" + lt.getName(), Short.toString(approval.getValue()));
            if (oldApprovals != null && !oldApprovals.isEmpty()) {
                Short oldValue = oldApprovals.get(approval.getKey());
                if (oldValue != null) {
                    addArg(args, "--" + lt.getName() + "-oldValue", Short.toString(oldValue));
                }
            }
        }
    }
    runHook(change.getProject(), reviewerDeletedHook, args);
}
#end_block

#method_before
@Override
public void doTopicChangedHook(Change change, Account account, String oldTopic, ReviewDb db) throws OrmException {
    TopicChangedEvent event = new TopicChangedEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(db, change);
    event.changer = eventFactory.asAccountAttribute(account);
    event.oldTopic = oldTopic;
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--changer", getDisplayName(account));
    addArg(args, "--old-topic", oldTopic);
    addArg(args, "--new-topic", event.change.topic);
    runHook(change.getProject(), topicChangedHook, args);
}
#method_after
@Override
public void doTopicChangedHook(Change change, Account account, String oldTopic, ReviewDb db) throws OrmException {
    TopicChangedEvent event = new TopicChangedEvent(change);
    AccountState owner = accountCache.get(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.changer = accountAttributeSupplier(account);
    event.oldTopic = oldTopic;
    dispatcher.get().postEvent(change, event, db);
    if (!topicChangedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--changer", getDisplayName(account));
    addArg(args, "--old-topic", oldTopic);
    addArg(args, "--new-topic", c.topic);
    runHook(change.getProject(), topicChangedHook, args);
}
#end_block

#method_before
@Override
public void doHashtagsChangedHook(Change change, Account account, Set<String> added, Set<String> removed, Set<String> hashtags, ReviewDb db) throws OrmException {
    HashtagsChangedEvent event = new HashtagsChangedEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(db, change);
    event.editor = eventFactory.asAccountAttribute(account);
    event.hashtags = hashtagArray(hashtags);
    event.added = hashtagArray(added);
    event.removed = hashtagArray(removed);
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--editor", getDisplayName(account));
    if (hashtags != null) {
        for (String hashtag : hashtags) {
            addArg(args, "--hashtag", hashtag);
        }
    }
    if (added != null) {
        for (String hashtag : added) {
            addArg(args, "--added", hashtag);
        }
    }
    if (removed != null) {
        for (String hashtag : removed) {
            addArg(args, "--removed", hashtag);
        }
    }
    runHook(change.getProject(), hashtagsChangedHook, args);
}
#method_after
@Override
public void doHashtagsChangedHook(Change change, Account account, Set<String> added, Set<String> removed, Set<String> hashtags, ReviewDb db) throws OrmException {
    HashtagsChangedEvent event = new HashtagsChangedEvent(change);
    AccountState owner = accountCache.get(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.editor = accountAttributeSupplier(account);
    event.hashtags = hashtagArray(hashtags);
    event.added = hashtagArray(added);
    event.removed = hashtagArray(removed);
    dispatcher.get().postEvent(change, event, db);
    if (!hashtagsChangedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--editor", getDisplayName(account));
    if (hashtags != null) {
        for (String hashtag : hashtags) {
            addArg(args, "--hashtag", hashtag);
        }
    }
    if (added != null) {
        for (String hashtag : added) {
            addArg(args, "--added", hashtag);
        }
    }
    if (removed != null) {
        for (String hashtag : removed) {
            addArg(args, "--removed", hashtag);
        }
    }
    runHook(change.getProject(), hashtagsChangedHook, args);
}
#end_block

#method_before
@Override
public void doClaSignupHook(Account account, String claName) {
    if (account != null) {
        List<String> args = new ArrayList<>();
        addArg(args, "--submitter", getDisplayName(account));
        addArg(args, "--user-id", account.getId().toString());
        addArg(args, "--cla-name", claName);
        runHook(claSignedHook, args);
    }
}
#method_after
@Override
public void doClaSignupHook(Account account, String claName) {
    if (!claSignedHook.isPresent()) {
        return;
    }
    if (account != null) {
        List<String> args = new ArrayList<>();
        addArg(args, "--submitter", getDisplayName(account));
        addArg(args, "--user-id", account.getId().toString());
        addArg(args, "--cla-name", claName);
        runHook(claSignedHook, args);
    }
}
#end_block

#method_before
private ApprovalAttribute getApprovalAttribute(LabelTypes labelTypes, Entry<String, Short> approval) {
    ApprovalAttribute a = new ApprovalAttribute();
    a.type = approval.getKey();
    LabelType lt = labelTypes.byLabel(approval.getKey());
    if (lt != null) {
        a.description = lt.getName();
    }
    a.value = Short.toString(approval.getValue());
    return a;
}
#method_after
private ApprovalAttribute getApprovalAttribute(LabelTypes labelTypes, Entry<String, Short> approval, Map<String, Short> oldApprovals) {
    ApprovalAttribute a = new ApprovalAttribute();
    a.type = approval.getKey();
    if (oldApprovals != null && !oldApprovals.isEmpty()) {
        if (oldApprovals.get(approval.getKey()) != null) {
            a.oldValue = Short.toString(oldApprovals.get(approval.getKey()));
        }
    }
    LabelType lt = labelTypes.byLabel(approval.getKey());
    if (lt != null) {
        a.description = lt.getName();
    }
    if (approval.getValue() != null) {
        a.value = Short.toString(approval.getValue());
    }
    return a;
}
#end_block

#method_before
private synchronized void runHook(Path hook, List<String> args) {
    if (Files.exists(hook)) {
        hookQueue.execute(new AsyncHookTask(null, hook, args));
    }
}
#method_after
private synchronized void runHook(Project.NameKey project, Optional<Path> hook, List<String> args) {
    if (project != null && hook.isPresent()) {
        hookQueue.execute(new AsyncHookTask(project, hook.get(), args));
    }
}
#end_block

#method_before
private HookResult runSyncHook(Project.NameKey project, Path hook, List<String> args) {
    if (!Files.exists(hook)) {
        return null;
    }
    SyncHookTask syncHook = new SyncHookTask(project, hook, args);
    FutureTask<HookResult> task = new FutureTask<>(syncHook);
    syncHookThreadPool.execute(task);
    String message;
    try {
        return task.get(syncHookTimeout, TimeUnit.SECONDS);
    } catch (TimeoutException e) {
        message = "Synchronous hook timed out " + hook.toAbsolutePath();
        log.error(message);
    } catch (Exception e) {
        message = "Error running hook " + hook.toAbsolutePath();
        log.error(message, e);
    }
    task.cancel(true);
    syncHook.cancel();
    return new HookResult(syncHook.getOutput(), message);
}
#method_after
private HookResult runSyncHook(Project.NameKey project, Optional<Path> hook, List<String> args) {
    if (!hook.isPresent()) {
        return null;
    }
    SyncHookTask syncHook = new SyncHookTask(project, hook.get(), args);
    FutureTask<HookResult> task = new FutureTask<>(syncHook);
    syncHookThreadPool.execute(task);
    String message;
    try {
        return task.get(syncHookTimeout, TimeUnit.SECONDS);
    } catch (TimeoutException e) {
        message = "Synchronous hook timed out " + hook.get().toAbsolutePath();
        log.error(message);
    } catch (Exception e) {
        message = "Error running hook " + hook.get().toAbsolutePath();
        log.error(message, e);
    }
    task.cancel(true);
    syncHook.cancel();
    return new HookResult(syncHook.getOutput(), message);
}
#end_block

#method_before
@Override
public void doCommentAddedHook(Change change, Account account, PatchSet patchSet, String comment, Map<String, Short> approvals, ReviewDb db) {
}
#method_after
@Override
public void doCommentAddedHook(Change change, Account account, PatchSet patchSet, String comment, Map<String, Short> approvals, Map<String, Short> oldApprovals, ReviewDb db) {
}
#end_block

#method_before
@Override
public void doReviewerDeletedHook(Change change, Account account, PatchSet patchSet, ReviewDb db) {
}
#method_after
@Override
public void doReviewerDeletedHook(Change change, Account account, PatchSet patchSet, String comment, Map<String, Short> approvals, Map<String, Short> oldApprovals, ReviewDb db) {
}
#end_block

#method_before
@Override
public void postEvent(Branch.NameKey branchName, Event event) {
}
#method_after
@Override
public void postEvent(Change change, ChangeEvent event, ReviewDb db) {
}
#end_block

#method_before
@Override
protected void init() throws EmailException {
    super.init();
    ccExistingReviewers();
}
#method_after
@Override
protected void init() throws EmailException {
    super.init();
    ccAllApprovals();
    bccStarredBy();
    ccExistingReviewers();
    includeWatchers(NotifyType.ALL_COMMENTS);
    add(RecipientType.TO, reviewers);
}
#end_block

#method_before
@Override
protected void doGetJson(HttpServletRequest req, HttpServletResponse res) throws IOException {
    GitilesView view = ViewFilter.getView(req);
    Repository repo = ServletUtils.getRepository(req);
    boolean includeSizes = !Strings.isNullOrEmpty(req.getParameter("long"));
    try (RevWalk rw = new RevWalk(repo);
        WalkResult wr = WalkResult.forPath(rw, view)) {
        if (wr == null) {
            res.setStatus(SC_NOT_FOUND);
            return;
        }
        switch(wr.type) {
            case TREE:
                renderJson(req, res, TreeJsonData.toJsonData(wr.id, wr.tw, includeSizes ? repo : null), TreeJsonData.Tree.class);
                break;
            default:
                res.setStatus(SC_NOT_FOUND);
                break;
        }
    } catch (LargeObjectException e) {
        res.setStatus(SC_INTERNAL_SERVER_ERROR);
    }
}
#method_after
@Override
protected void doGetJson(HttpServletRequest req, HttpServletResponse res) throws IOException {
    GitilesView view = ViewFilter.getView(req);
    Repository repo = ServletUtils.getRepository(req);
    String longStr = req.getParameter("long");
    boolean includeSizes = (longStr != null) && (longStr.isEmpty() || Boolean.TRUE.equals(StringUtils.toBooleanOrNull(longStr)));
    try (RevWalk rw = new RevWalk(repo);
        WalkResult wr = WalkResult.forPath(rw, view)) {
        if (wr == null) {
            res.setStatus(SC_NOT_FOUND);
            return;
        }
        switch(wr.type) {
            case TREE:
                renderJson(req, res, TreeJsonData.toJsonData(wr.id, wr.tw, includeSizes), TreeJsonData.Tree.class);
                break;
            default:
                res.setStatus(SC_NOT_FOUND);
                break;
        }
    } catch (LargeObjectException e) {
        res.setStatus(SC_INTERNAL_SERVER_ERROR);
    }
}
#end_block

#method_before
static Tree toJsonData(ObjectId id, TreeWalk tw, @Nullable Repository repoForSizes) throws IOException {
    ObjectReader reader = repoForSizes != null ? repoForSizes.newObjectReader() : null;
    Tree tree = new Tree();
    tree.id = id.name();
    tree.entries = Lists.newArrayList();
    while (tw.next()) {
        Entry e = new Entry();
        FileMode mode = tw.getFileMode(0);
        e.mode = mode.getBits();
        e.type = Constants.typeString(mode.getObjectType());
        e.id = tw.getObjectId(0).name();
        e.name = tw.getNameString();
        if (reader != null) {
            FileMode fmode = FileMode.fromBits(mode.getBits());
            if (fmode == FileMode.REGULAR_FILE || fmode == FileMode.EXECUTABLE_FILE) {
                SizedEntry se = new SizedEntry();
                se.id = e.id;
                se.mode = e.mode;
                se.name = e.name;
                se.type = e.type;
                se.size = reader.getObjectSize(tw.getObjectId(0), Constants.OBJ_BLOB);
                e = se;
            } else if (fmode == FileMode.SYMLINK) {
                TargetEntry se = new TargetEntry();
                se.id = e.id;
                se.mode = e.mode;
                se.name = e.name;
                se.type = e.type;
                se.target = new String(repoForSizes.open(tw.getObjectId(0), Constants.OBJ_BLOB).getBytes(), UTF_8);
                e = se;
            }
        }
        tree.entries.add(e);
    }
    return tree;
}
#method_after
static Tree toJsonData(ObjectId id, TreeWalk tw, boolean includeSizes) throws IOException {
    Tree tree = new Tree();
    tree.id = id.name();
    tree.entries = Lists.newArrayList();
    while (tw.next()) {
        Entry e = new Entry();
        FileMode mode = tw.getFileMode(0);
        e.mode = mode.getBits();
        e.type = Constants.typeString(mode.getObjectType());
        e.id = tw.getObjectId(0).name();
        e.name = tw.getNameString();
        if (includeSizes) {
            if ((mode.getBits() & FileMode.TYPE_MASK) == FileMode.TYPE_FILE) {
                e.size = tw.getObjectReader().getObjectSize(tw.getObjectId(0), Constants.OBJ_BLOB);
            } else if ((mode.getBits() & FileMode.TYPE_MASK) == FileMode.TYPE_SYMLINK) {
                e.target = new String(tw.getObjectReader().open(tw.getObjectId(0)).getCachedBytes(), UTF_8);
            }
        }
        tree.entries.add(e);
    }
    return tree;
}
#end_block

#method_before
void close() {
    reopenThread.close();
    // not have flushed.
    try {
        searcherManager.maybeRefreshBlocking();
    } catch (IOException e) {
        log.warn("error finishing pending Lucene writes", e);
    }
    try {
        try {
            writer.getIndexWriter().close();
        } catch (AlreadyClosedException e) {
        // Ignore.
        }
    } catch (IOException e) {
        log.warn("error closing Lucene writer", e);
    }
    try {
        dir.close();
    } catch (IOException e) {
        log.warn("error closing Lucene directory", e);
    }
}
#method_after
void close() {
    reopenThread.close();
    // not have flushed.
    try {
        searcherManager.maybeRefreshBlocking();
    } catch (IOException e) {
        log.warn("error finishing pending Lucene writes", e);
    }
    try {
        writer.getIndexWriter().close();
    } catch (AlreadyClosedException e) {
    // Ignore.
    } catch (IOException e) {
        log.warn("error closing Lucene writer", e);
    }
    try {
        dir.close();
    } catch (IOException e) {
        log.warn("error closing Lucene directory", e);
    }
}
#end_block

#method_before
public void postRun() throws Exception {
    for (InitStep step : steps) {
        if (step instanceof InitPlugins && flags.skipPlugins) {
            continue;
        }
        step.postRun();
    }
}
#method_after
public void postRun(Injector injector) throws Exception {
    for (InitStep step : steps) {
        if (step instanceof InitPlugins && flags.skipPlugins) {
            continue;
        }
        injector.injectMembers(step);
        step.postRun();
    }
}
#end_block

#method_before
private void saveSecureStore() throws IOException {
    if (!secureStoreClassName.isEmpty() && !secureStoreJarPath.isEmpty()) {
        File secureStoreJar = new File(secureStoreJarPath);
        File dst = new File(site.lib_dir, secureStoreJar.getName());
        Files.copy(secureStoreJar, dst);
        Section gerritSection = sectionFactory.get("gerrit", null);
        gerritSection.set("secureStoreClass", secureStoreClassName);
    }
}
#method_after
private void saveSecureStore() throws IOException {
    if (secureStoreInitData != null) {
        File dst = new File(site.lib_dir, secureStoreInitData.jarFile.getName());
        Files.copy(secureStoreInitData.jarFile, dst);
        Section gerritSection = sectionFactory.get("gerrit", null);
        gerritSection.set("secureStoreClass", secureStoreInitData.className);
    }
}
#end_block

#method_before
@Test
public void testUpgrade() throws IOException, ConfigInvalidException {
    final File p = newSitePath();
    final SitePaths site = new SitePaths(p);
    assertTrue(site.isNew);
    assertTrue(site.site_path.mkdir());
    assertTrue(site.etc_dir.mkdir());
    for (String n : UpgradeFrom2_0_x.etcFiles) {
        Writer w = new FileWriter(new File(p, n));
        try {
            w.write("# " + n + "\n");
        } finally {
            w.close();
        }
    }
    FileBasedConfig old = new FileBasedConfig(new File(p, "gerrit.config"), FS.DETECTED);
    old.setString("ldap", null, "username", "ldap.user");
    old.setString("ldap", null, "password", "ldap.s3kr3t");
    old.setString("sendemail", null, "smtpUser", "email.user");
    old.setString("sendemail", null, "smtpPass", "email.s3kr3t");
    old.save();
    InMemorySecureStore secureStore = new InMemorySecureStore();
    final InitFlags flags = new InitFlags(site, secureStore, Collections.<String>emptyList());
    final ConsoleUI ui = createStrictMock(ConsoleUI.class);
    Section.Factory sections = new Section.Factory() {

        @Override
        public Section get(String name, String subsection) {
            return new Section(flags, site, ui, name, subsection);
        }
    };
    expect(ui.yesno(eq(true), eq("Upgrade '%s'"), eq(p.getCanonicalPath()))).andReturn(true);
    replay(ui);
    UpgradeFrom2_0_x u = new UpgradeFrom2_0_x(site, flags, ui, sections);
    assertTrue(u.isNeedUpgrade());
    u.run();
    assertFalse(u.isNeedUpgrade());
    verify(ui);
    for (String n : UpgradeFrom2_0_x.etcFiles) {
        if ("gerrit.config".equals(n))
            continue;
        if ("secure.config".equals(n))
            continue;
        assertEquals(// 
        "# " + n + "\n", new String(IO.readFully(new File(site.etc_dir, n)), "UTF-8"));
    }
    FileBasedConfig cfg = new FileBasedConfig(site.gerrit_config, FS.DETECTED);
    cfg.load();
    assertEquals("email.user", cfg.getString("sendemail", null, "smtpUser"));
    assertNull(cfg.getString("sendemail", null, "smtpPass"));
    assertEquals("email.s3kr3t", secureStore.get("sendemail", null, "smtpPass"));
    assertEquals("ldap.user", cfg.getString("ldap", null, "username"));
    assertNull(cfg.getString("ldap", null, "password"));
    assertEquals("ldap.s3kr3t", secureStore.get("ldap", null, "password"));
    u.run();
}
#method_after
@Test
public void testUpgrade() throws IOException, ConfigInvalidException {
    final File p = newSitePath();
    final SitePaths site = new SitePaths(p);
    assertTrue(site.isNew);
    assertTrue(site.site_path.mkdir());
    assertTrue(site.etc_dir.mkdir());
    for (String n : UpgradeFrom2_0_x.etcFiles) {
        Writer w = new FileWriter(new File(p, n));
        try {
            w.write("# " + n + "\n");
        } finally {
            w.close();
        }
    }
    FileBasedConfig old = new FileBasedConfig(new File(p, "gerrit.config"), FS.DETECTED);
    old.setString("ldap", null, "username", "ldap.user");
    old.setString("ldap", null, "password", "ldap.s3kr3t");
    old.setString("sendemail", null, "smtpUser", "email.user");
    old.setString("sendemail", null, "smtpPass", "email.s3kr3t");
    old.save();
    final InMemorySecureStore secureStore = new InMemorySecureStore();
    final InitFlags flags = new InitFlags(site, secureStore, Collections.<String>emptyList());
    final ConsoleUI ui = createStrictMock(ConsoleUI.class);
    Section.Factory sections = new Section.Factory() {

        @Override
        public Section get(String name, String subsection) {
            return new Section(flags, site, secureStore, ui, name, subsection);
        }
    };
    expect(ui.yesno(eq(true), eq("Upgrade '%s'"), eq(p.getCanonicalPath()))).andReturn(true);
    replay(ui);
    UpgradeFrom2_0_x u = new UpgradeFrom2_0_x(site, flags, ui, sections);
    assertTrue(u.isNeedUpgrade());
    u.run();
    assertFalse(u.isNeedUpgrade());
    verify(ui);
    for (String n : UpgradeFrom2_0_x.etcFiles) {
        if ("gerrit.config".equals(n))
            continue;
        if ("secure.config".equals(n))
            continue;
        assertEquals(// 
        "# " + n + "\n", new String(IO.readFully(new File(site.etc_dir, n)), "UTF-8"));
    }
    FileBasedConfig cfg = new FileBasedConfig(site.gerrit_config, FS.DETECTED);
    cfg.load();
    assertEquals("email.user", cfg.getString("sendemail", null, "smtpUser"));
    assertNull(cfg.getString("sendemail", null, "smtpPass"));
    assertEquals("email.s3kr3t", secureStore.get("sendemail", null, "smtpPass"));
    assertEquals("ldap.user", cfg.getString("ldap", null, "username"));
    assertNull(cfg.getString("ldap", null, "password"));
    assertEquals("ldap.s3kr3t", secureStore.get("ldap", null, "password"));
    u.run();
}
#end_block

#method_before
public void run() throws IOException, InterruptedException {
    ui.header("HTTP Daemon");
    boolean proxy = false, ssl = false;
    String address = "*";
    int port = -1;
    String context = "/";
    String listenUrl = httpd.get("listenUrl");
    if (listenUrl != null && !listenUrl.isEmpty()) {
        try {
            final URI uri = toURI(listenUrl);
            proxy = uri.getScheme().startsWith("proxy-");
            ssl = uri.getScheme().endsWith("https");
            address = isAnyAddress(new URI(listenUrl)) ? "*" : uri.getHost();
            port = uri.getPort();
            context = uri.getPath();
        } catch (URISyntaxException e) {
            System.err.println("warning: invalid httpd.listenUrl " + listenUrl);
        }
    }
    proxy = ui.yesno(proxy, "Behind reverse proxy");
    if (proxy) {
        ssl = ui.yesno(ssl, "Proxy uses SSL (https://)");
        context = ui.readString(context, "Subdirectory on proxy server");
    } else {
        ssl = ui.yesno(ssl, "Use SSL (https://)");
        context = "/";
    }
    address = ui.readString(address, "Listen on address");
    if (port < 0) {
        if (proxy) {
            port = 8081;
        } else if (ssl) {
            port = 8443;
        } else {
            port = 8080;
        }
    }
    port = ui.readInt(port, "Listen on port");
    final StringBuilder urlbuf = new StringBuilder();
    urlbuf.append(proxy ? "proxy-" : "");
    urlbuf.append(ssl ? "https" : "http");
    urlbuf.append("://");
    urlbuf.append(address);
    if (0 <= port) {
        urlbuf.append(":");
        urlbuf.append(port);
    }
    urlbuf.append(context);
    httpd.set("listenUrl", urlbuf.toString());
    URI uri;
    try {
        uri = toURI(httpd.get("listenUrl"));
        if (uri.getScheme().startsWith("proxy-")) {
            // If its a proxy URL, assume the reverse proxy is on our system
            // at the protocol standard ports (so omit the ports from the URL).
            // 
            String s = uri.getScheme().substring("proxy-".length());
            uri = new URI(s + "://" + uri.getHost() + uri.getPath());
        }
    } catch (URISyntaxException e) {
        throw die("invalid httpd.listenUrl");
    }
    gerrit.string("Canonical URL", "canonicalWebUrl", uri.toString());
    generateSslCertificate();
}
#method_after
@Override
public void run() throws IOException, InterruptedException {
    ui.header("HTTP Daemon");
    boolean proxy = false, ssl = false;
    String address = "*";
    int port = -1;
    String context = "/";
    String listenUrl = httpd.get("listenUrl");
    if (listenUrl != null && !listenUrl.isEmpty()) {
        try {
            final URI uri = toURI(listenUrl);
            proxy = uri.getScheme().startsWith("proxy-");
            ssl = uri.getScheme().endsWith("https");
            address = isAnyAddress(new URI(listenUrl)) ? "*" : uri.getHost();
            port = uri.getPort();
            context = uri.getPath();
        } catch (URISyntaxException e) {
            System.err.println("warning: invalid httpd.listenUrl " + listenUrl);
        }
    }
    proxy = ui.yesno(proxy, "Behind reverse proxy");
    if (proxy) {
        ssl = ui.yesno(ssl, "Proxy uses SSL (https://)");
        context = ui.readString(context, "Subdirectory on proxy server");
    } else {
        ssl = ui.yesno(ssl, "Use SSL (https://)");
        context = "/";
    }
    address = ui.readString(address, "Listen on address");
    if (port < 0) {
        if (proxy) {
            port = 8081;
        } else if (ssl) {
            port = 8443;
        } else {
            port = 8080;
        }
    }
    port = ui.readInt(port, "Listen on port");
    final StringBuilder urlbuf = new StringBuilder();
    urlbuf.append(proxy ? "proxy-" : "");
    urlbuf.append(ssl ? "https" : "http");
    urlbuf.append("://");
    urlbuf.append(address);
    if (0 <= port) {
        urlbuf.append(":");
        urlbuf.append(port);
    }
    urlbuf.append(context);
    httpd.set("listenUrl", urlbuf.toString());
    URI uri;
    try {
        uri = toURI(httpd.get("listenUrl"));
        if (uri.getScheme().startsWith("proxy-")) {
            // If its a proxy URL, assume the reverse proxy is on our system
            // at the protocol standard ports (so omit the ports from the URL).
            // 
            String s = uri.getScheme().substring("proxy-".length());
            uri = new URI(s + "://" + uri.getHost() + uri.getPath());
        }
    } catch (URISyntaxException e) {
        throw die("invalid httpd.listenUrl");
    }
    gerrit.string("Canonical URL", "canonicalWebUrl", uri.toString());
    generateSslCertificate();
}
#end_block

#method_before
public void run() throws IOException, ConfigInvalidException {
    if (!isNeedUpgrade()) {
        return;
    }
    if (!ui.yesno(true, "Upgrade '%s'", site_path.getCanonicalPath())) {
        throw die("aborted by user");
    }
    for (String name : etcFiles) {
        final File src = new File(site_path, name);
        final File dst = new File(etc_dir, name);
        if (src.exists()) {
            if (dst.exists()) {
                throw die("File " + src + " would overwrite " + dst);
            }
            if (!src.renameTo(dst)) {
                throw die("Cannot rename " + src + " to " + dst);
            }
        }
    }
    // We have to reload the configuration after the rename as
    // the initial load pulled up an non-existent (and thus
    // believed to be empty) file.
    // 
    cfg.load();
    final Properties oldprop = readGerritServerProperties();
    if (oldprop != null) {
        final Section database = sections.get("database", null);
        String url = oldprop.getProperty("url");
        if (url != null && !convertUrl(database, url)) {
            database.set("type", "jdbc");
            database.set("driver", oldprop.getProperty("driver"));
            database.set("url", url);
        }
        String username = oldprop.getProperty("user");
        if (username == null || username.isEmpty()) {
            username = oldprop.getProperty("username");
        }
        if (username != null && !username.isEmpty()) {
            cfg.setString("database", null, "username", username);
        }
        String password = oldprop.getProperty("password");
        if (password != null && !password.isEmpty()) {
            sec.set("database", null, "password", password);
        }
    }
    String[] values;
    values = cfg.getStringList("ldap", null, "password");
    cfg.unset("ldap", null, "password");
    sec.setList("ldap", null, "password", Arrays.asList(values));
    values = cfg.getStringList("sendemail", null, "smtpPass");
    cfg.unset("sendemail", null, "smtpPass");
    sec.setList("sendemail", null, "smtpPass", Arrays.asList(values));
    savePublic(cfg);
}
#method_after
@Override
public void run() throws IOException, ConfigInvalidException {
    if (!isNeedUpgrade()) {
        return;
    }
    if (!ui.yesno(true, "Upgrade '%s'", site_path.getCanonicalPath())) {
        throw die("aborted by user");
    }
    for (String name : etcFiles) {
        final File src = new File(site_path, name);
        final File dst = new File(etc_dir, name);
        if (src.exists()) {
            if (dst.exists()) {
                throw die("File " + src + " would overwrite " + dst);
            }
            if (!src.renameTo(dst)) {
                throw die("Cannot rename " + src + " to " + dst);
            }
        }
    }
    // We have to reload the configuration after the rename as
    // the initial load pulled up an non-existent (and thus
    // believed to be empty) file.
    // 
    cfg.load();
    final Properties oldprop = readGerritServerProperties();
    if (oldprop != null) {
        final Section database = sections.get("database", null);
        String url = oldprop.getProperty("url");
        if (url != null && !convertUrl(database, url)) {
            database.set("type", "jdbc");
            database.set("driver", oldprop.getProperty("driver"));
            database.set("url", url);
        }
        String username = oldprop.getProperty("user");
        if (username == null || username.isEmpty()) {
            username = oldprop.getProperty("username");
        }
        if (username != null && !username.isEmpty()) {
            cfg.setString("database", null, "username", username);
        }
        String password = oldprop.getProperty("password");
        if (password != null && !password.isEmpty()) {
            sec.set("database", null, "password", password);
        }
    }
    String[] values;
    values = cfg.getStringList("ldap", null, "password");
    cfg.unset("ldap", null, "password");
    sec.setList("ldap", null, "password", Arrays.asList(values));
    values = cfg.getStringList("sendemail", null, "smtpPass");
    cfg.unset("sendemail", null, "smtpPass");
    sec.setList("sendemail", null, "smtpPass", Arrays.asList(values));
    savePublic(cfg);
}
#end_block

#method_before
public <T extends Enum<?>> T select(final String title, final String name, final T defValue, final boolean nullIfDefault) {
    final boolean set = get(name) != null;
    T oldValue = ConfigUtil.getEnum(flags.cfg, section, subsection, name, defValue);
    T newValue = ui.readEnum(oldValue, "%s", title);
    if (nullIfDefault && newValue == defValue) {
        newValue = null;
    }
    if (!set || oldValue != newValue) {
        if (newValue != null) {
            set(name, newValue);
        } else {
            unset(name);
        }
    }
    return newValue;
}
#method_after
public <T extends Enum<?>> T select(final String title, final String name, final T defValue, final boolean nullIfDefault) {
    final boolean set = get(name) != null;
    T oldValue = flags.cfg.getEnum(section, subsection, name, defValue);
    T newValue = ui.readEnum(oldValue, "%s", title);
    if (nullIfDefault && newValue == defValue) {
        newValue = null;
    }
    if (!set || oldValue != newValue) {
        if (newValue != null) {
            set(name, newValue);
        } else {
            unset(name);
        }
    }
    return newValue;
}
#end_block

#method_before
public void setSecure(String name, String value) {
    if (value != null) {
        flags.sec.set(section, subsection, name, value);
    } else {
        flags.sec.unset(section, subsection, name);
    }
}
#method_after
public void setSecure(String name, String value) {
    if (value != null) {
        secureStore.set(section, subsection, name, value);
    } else {
        secureStore.unset(section, subsection, name);
    }
}
#end_block

#method_before
@Override
public int run() throws Exception {
    final SiteInit init = createSiteInit();
    if (beforeInit(init)) {
        return 0;
    }
    init.flags.autoStart = getAutoStart() && init.site.isNew;
    init.flags.skipPlugins = skipPlugins();
    final SiteRun run;
    try {
        init.initializer.run();
        init.flags.deleteOnFailure = false;
        run = createSiteRun(init);
        run.upgradeSchema();
        init.initializer.postRun();
    } catch (Exception failure) {
        if (init.flags.deleteOnFailure) {
            recursiveDelete(getSitePath());
        }
        throw failure;
    } catch (Error failure) {
        if (init.flags.deleteOnFailure) {
            recursiveDelete(getSitePath());
        }
        throw failure;
    }
    System.err.println("Initialized " + getSitePath().getCanonicalPath());
    afterInit(run);
    return 0;
}
#method_after
@Override
public int run() throws Exception {
    final SiteInit init = createSiteInit();
    if (beforeInit(init)) {
        return 0;
    }
    init.flags.autoStart = getAutoStart() && init.site.isNew;
    init.flags.skipPlugins = skipPlugins();
    final SiteRun run;
    try {
        init.initializer.run();
        init.flags.deleteOnFailure = false;
        run = createSiteRun(init);
        run.upgradeSchema();
        init.initializer.postRun(createSysInjector(init));
    } catch (Exception failure) {
        if (init.flags.deleteOnFailure) {
            recursiveDelete(getSitePath());
        }
        throw failure;
    } catch (Error failure) {
        if (init.flags.deleteOnFailure) {
            recursiveDelete(getSitePath());
        }
        throw failure;
    }
    System.err.println("Initialized " + getSitePath().getCanonicalPath());
    afterInit(run);
    return 0;
}
#end_block

#method_before
private SiteInit createSiteInit() {
    final ConsoleUI ui = getConsoleUI();
    final File sitePath = getSitePath();
    final List<Module> m = new ArrayList<>();
    m.add(new InitModule(standalone, initDb, getSecureStoreClassName()));
    m.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(ConsoleUI.class).toInstance(ui);
            bind(File.class).annotatedWith(SitePath.class).toInstance(sitePath);
            List<String> plugins = Objects.firstNonNull(getInstallPlugins(), Lists.<String>newArrayList());
            bind(new TypeLiteral<List<String>>() {
            }).annotatedWith(InstallPlugins.class).toInstance(plugins);
            bind(PluginsDistribution.class).toInstance(pluginsDistribution);
            bind(String.class).annotatedWith(SecureStoreJarPath.class).toInstance(Strings.nullToEmpty(getSecireStoreJarPath()));
            bind(String.class).annotatedWith(SecureStoreClassName.class).toInstance(Strings.nullToEmpty(getSecureStoreClassName()));
        }
    });
    try {
        return Guice.createInjector(PRODUCTION, m).getInstance(SiteInit.class);
    } catch (CreationException ce) {
        final Message first = ce.getErrorMessages().iterator().next();
        Throwable why = first.getCause();
        if (why instanceof Die) {
            throw (Die) why;
        }
        final StringBuilder buf = new StringBuilder(ce.getMessage());
        while (why != null) {
            buf.append("\n");
            buf.append(why.getMessage());
            why = why.getCause();
            if (why != null) {
                buf.append("\n  caused by ");
            }
        }
        throw die(buf.toString(), new RuntimeException("InitInjector failed", ce));
    }
}
#method_after
private SiteInit createSiteInit() {
    final ConsoleUI ui = getConsoleUI();
    final File sitePath = getSitePath();
    final List<Module> m = new ArrayList<>();
    final SecureStoreInitData secureStoreInitData = discoverSecureStoreClass();
    final String currentSecureStoreClassName = getConfiguredSecureStoreClass();
    if (secureStoreInitData != null && currentSecureStoreClassName != null && !currentSecureStoreClassName.equals(secureStoreInitData.className)) {
        String err = String.format("Different secure store was previously configured: %s.", currentSecureStoreClassName);
        die(err, new RuntimeException("secure store mismatch"));
    }
    m.add(new InitModule(standalone, initDb));
    m.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(ConsoleUI.class).toInstance(ui);
            bind(File.class).annotatedWith(SitePath.class).toInstance(sitePath);
            List<String> plugins = MoreObjects.firstNonNull(getInstallPlugins(), Lists.<String>newArrayList());
            bind(new TypeLiteral<List<String>>() {
            }).annotatedWith(InstallPlugins.class).toInstance(plugins);
            bind(PluginsDistribution.class).toInstance(pluginsDistribution);
            String secureStoreClassName;
            if (secureStoreInitData != null) {
                secureStoreClassName = secureStoreInitData.className;
            } else {
                secureStoreClassName = currentSecureStoreClassName;
            }
            if (secureStoreClassName != null) {
                ui.message("Using secure store: %s\n", secureStoreClassName);
            }
            bind(SecureStoreInitData.class).toProvider(Providers.of(secureStoreInitData));
            bind(String.class).annotatedWith(SecureStoreClassName.class).toProvider(Providers.of(secureStoreClassName));
            bind(SecureStore.class).toProvider(SecureStoreProvider.class).in(SINGLETON);
        }
    });
    try {
        return Guice.createInjector(PRODUCTION, m).getInstance(SiteInit.class);
    } catch (CreationException ce) {
        final Message first = ce.getErrorMessages().iterator().next();
        Throwable why = first.getCause();
        if (why instanceof Die) {
            throw (Die) why;
        }
        final StringBuilder buf = new StringBuilder(ce.getMessage());
        while (why != null) {
            buf.append("\n");
            buf.append(why.getMessage());
            why = why.getCause();
            if (why != null) {
                buf.append("\n  caused by ");
            }
        }
        throw die(buf.toString(), new RuntimeException("InitInjector failed", ce));
    }
}
#end_block

#method_before
void upgradeSchema() throws OrmException {
    final List<String> pruneList = new ArrayList<>();
    schemaUpdater.update(new UpdateUI() {

        @Override
        public void message(String msg) {
            System.err.println(msg);
            System.err.flush();
        }

        @Override
        public boolean yesno(boolean def, String msg) {
            return ui.yesno(def, msg);
        }

        @Override
        public boolean isBatch() {
            return ui.isBatch();
        }

        @Override
        public void pruneSchema(StatementExecutor e, List<String> prune) {
            for (String p : prune) {
                if (!pruneList.contains(p)) {
                    pruneList.add(p);
                }
            }
        }
    });
    if (!pruneList.isEmpty()) {
        StringBuilder msg = new StringBuilder();
        msg.append("Execute the following SQL to drop unused objects:\n");
        msg.append("\n");
        for (String sql : pruneList) {
            msg.append("  ");
            msg.append(sql);
            msg.append(";\n");
        }
        if (ui.isBatch()) {
            System.err.print(msg);
            System.err.flush();
        } else if (ui.yesno(true, "%s\nExecute now", msg)) {
            final JdbcSchema db = (JdbcSchema) schema.open();
            try {
                final JdbcExecutor e = new JdbcExecutor(db);
                try {
                    for (String sql : pruneList) {
                        e.execute(sql);
                    }
                } finally {
                    e.close();
                }
            } finally {
                db.close();
            }
        }
    }
}
#method_after
void upgradeSchema() throws OrmException {
    final List<String> pruneList = new ArrayList<>();
    schemaUpdater.update(new UpdateUI() {

        @Override
        public void message(String msg) {
            System.err.println(msg);
            System.err.flush();
        }

        @Override
        public boolean yesno(boolean def, String msg) {
            return ui.yesno(def, msg);
        }

        @Override
        public boolean isBatch() {
            return ui.isBatch();
        }

        @Override
        public void pruneSchema(StatementExecutor e, List<String> prune) {
            for (String p : prune) {
                if (!pruneList.contains(p)) {
                    pruneList.add(p);
                }
            }
        }
    });
    if (!pruneList.isEmpty()) {
        StringBuilder msg = new StringBuilder();
        msg.append("Execute the following SQL to drop unused objects:\n");
        msg.append("\n");
        for (String sql : pruneList) {
            msg.append("  ");
            msg.append(sql);
            msg.append(";\n");
        }
        if (ui.isBatch()) {
            System.err.print(msg);
            System.err.flush();
        } else if (ui.yesno(true, "%s\nExecute now", msg)) {
            try (JdbcSchema db = (JdbcSchema) schema.open();
                JdbcExecutor e = new JdbcExecutor(db)) {
                for (String sql : pruneList) {
                    e.execute(sql);
                }
            }
        }
    }
}
#end_block

#method_before
private Injector createSysInjector(final SiteInit init) {
    final List<Module> modules = new ArrayList<>();
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(ConsoleUI.class).toInstance(init.ui);
            bind(InitFlags.class).toInstance(init.flags);
        }
    });
    return createDbInjector(SINGLE_USER).createChildInjector(modules);
}
#method_after
private Injector createSysInjector(final SiteInit init) {
    if (sysInjector == null) {
        final List<Module> modules = new ArrayList<>();
        modules.add(new AbstractModule() {

            @Override
            protected void configure() {
                bind(ConsoleUI.class).toInstance(init.ui);
                bind(InitFlags.class).toInstance(init.flags);
            }
        });
        sysInjector = createDbInjector(SINGLE_USER).createChildInjector(modules);
    }
    return sysInjector;
}
#end_block

#method_before
@Override
protected void afterInit(SiteRun run) throws Exception {
    List<Module> modules = Lists.newArrayList();
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(File.class).annotatedWith(SitePath.class).toInstance(getSitePath());
            bind(Browser.class);
        }
    });
    modules.add(new GerritServerConfigModule());
    Guice.createInjector(modules).injectMembers(this);
    start(run);
}
#method_after
@Override
protected void afterInit(SiteRun run) throws Exception {
    List<Module> modules = Lists.newArrayList();
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(File.class).annotatedWith(SitePath.class).toInstance(getSitePath());
            bind(Browser.class);
            bind(String.class).annotatedWith(SecureStoreClassName.class).toProvider(Providers.of(getConfiguredSecureStoreClass()));
        }
    });
    modules.add(new GerritServerConfigModule());
    Guice.createInjector(modules).injectMembers(this);
    start(run);
}
#end_block

#method_before
@Test
public void publishCommentsAllRevisions() throws Exception {
    PushOneCommit.Result r1 = createChange();
    PushOneCommit.Result r2 = pushFactory.create(db, admin.getIdent(), testRepo, SUBJECT, FILE_NAME, "new\ncntent\n", r1.getChangeId()).to("refs/for/master");
    addDraft(r1.getChangeId(), r1.getCommit().getName(), newDraft(FILE_NAME, Side.REVISION, 1, "nit: trailing whitespace"));
    addDraft(r1.getChangeId(), r1.getCommit().getName(), newDraft(FILE_NAME, Side.PARENT, 2, "what happened to this?"));
    addDraft(r2.getChangeId(), r2.getCommit().getName(), newDraft(FILE_NAME, Side.REVISION, 1, "join lines"));
    addDraft(r2.getChangeId(), r2.getCommit().getName(), newDraft(FILE_NAME, Side.REVISION, 2, "typo: content"));
    PushOneCommit.Result other = createChange();
    // Drafts on other changes aren't returned.
    addDraft(other.getChangeId(), other.getCommit().getName(), newDraft(FILE_NAME, Side.REVISION, 1, "unrelated comment"));
    setApiUser(admin);
    // Drafts by other users aren't returned.
    addDraft(r2.getChangeId(), r2.getCommit().getName(), newDraft(FILE_NAME, Side.REVISION, 2, "oops"));
    setApiUser(user);
    ReviewInput reviewInput = new ReviewInput();
    reviewInput.drafts = DraftHandling.PUBLISH_ALL_REVISIONS;
    reviewInput.message = "comments";
    gApi.changes().id(r2.getChangeId()).current().review(reviewInput);
    assertThat(gApi.changes().id(r1.getChangeId()).revision(r1.getCommit().name()).drafts()).isEmpty();
    Map<String, List<CommentInfo>> ps1Map = gApi.changes().id(r1.getChangeId()).revision(r1.getCommit().name()).comments();
    assertThat(ps1Map.keySet()).containsExactly(FILE_NAME);
    List<CommentInfo> ps1List = ps1Map.get(FILE_NAME);
    assertThat(ps1List).hasSize(2);
    assertThat(ps1List.get(0).message).isEqualTo("what happened to this?");
    assertThat(ps1List.get(0).side).isEqualTo(Side.PARENT);
    assertThat(ps1List.get(1).message).isEqualTo("nit: trailing whitespace");
    assertThat(ps1List.get(1).side).isNull();
    assertThat(gApi.changes().id(r2.getChangeId()).revision(r2.getCommit().name()).drafts()).isEmpty();
    Map<String, List<CommentInfo>> ps2Map = gApi.changes().id(r2.getChangeId()).revision(r2.getCommit().name()).comments();
    assertThat(ps2Map.keySet()).containsExactly(FILE_NAME);
    List<CommentInfo> ps2List = ps2Map.get(FILE_NAME);
    assertThat(ps2List).hasSize(2);
    assertThat(ps2List.get(0).message).isEqualTo("join lines");
    assertThat(ps2List.get(1).message).isEqualTo("typo: content");
    ImmutableList<Message> messages = email.getMessages(r2.getChangeId(), "comment");
    assertThat(messages).hasSize(1);
    String url = canonicalWebUrl.get();
    int c = r1.getChange().getId().get();
    assertThat(extractComments(messages.get(0).body())).isEqualTo("Patch Set 2:\n" + "\n" + "(4 comments)\n" + "\n" + "comments\n" + "\n" + url + "#/c/" + c + "/1/a.txt\n" + "File a.txt:\n" + "\n" + "PS1, Line 2: \n" + "what happened to this?\n" + "\n" + "\n" + "PS1, Line 1: ew\n" + "nit: trailing whitespace\n" + "\n" + "\n" + url + "#/c/" + c + "/2/a.txt\n" + "File a.txt:\n" + "\n" + "PS2, Line 1: ew\n" + "join lines\n" + "\n" + "\n" + "PS2, Line 2: nten\n" + "typo: content\n" + "\n");
}
#method_after
@Test
public void publishCommentsAllRevisions() throws Exception {
    PushOneCommit.Result r1 = createChange();
    PushOneCommit.Result r2 = pushFactory.create(db, admin.getIdent(), testRepo, SUBJECT, FILE_NAME, "new\ncntent\n", r1.getChangeId()).to("refs/for/master");
    addDraft(r1.getChangeId(), r1.getCommit().getName(), newDraft(FILE_NAME, Side.REVISION, 1, "nit: trailing whitespace"));
    addDraft(r1.getChangeId(), r1.getCommit().getName(), newDraft(FILE_NAME, Side.PARENT, 2, "what happened to this?"));
    addDraft(r2.getChangeId(), r2.getCommit().getName(), newDraft(FILE_NAME, Side.REVISION, 1, "join lines"));
    addDraft(r2.getChangeId(), r2.getCommit().getName(), newDraft(FILE_NAME, Side.REVISION, 2, "typo: content"));
    addDraft(r2.getChangeId(), r2.getCommit().getName(), newDraft(FILE_NAME, Side.PARENT, 1, "comment 1 on base"));
    addDraft(r2.getChangeId(), r2.getCommit().getName(), newDraft(FILE_NAME, Side.PARENT, 2, "comment 2 on base"));
    PushOneCommit.Result other = createChange();
    // Drafts on other changes aren't returned.
    addDraft(other.getChangeId(), other.getCommit().getName(), newDraft(FILE_NAME, Side.REVISION, 1, "unrelated comment"));
    setApiUser(admin);
    // Drafts by other users aren't returned.
    addDraft(r2.getChangeId(), r2.getCommit().getName(), newDraft(FILE_NAME, Side.REVISION, 2, "oops"));
    setApiUser(user);
    ReviewInput reviewInput = new ReviewInput();
    reviewInput.drafts = DraftHandling.PUBLISH_ALL_REVISIONS;
    reviewInput.message = "comments";
    gApi.changes().id(r2.getChangeId()).current().review(reviewInput);
    assertThat(gApi.changes().id(r1.getChangeId()).revision(r1.getCommit().name()).drafts()).isEmpty();
    Map<String, List<CommentInfo>> ps1Map = gApi.changes().id(r1.getChangeId()).revision(r1.getCommit().name()).comments();
    assertThat(ps1Map.keySet()).containsExactly(FILE_NAME);
    List<CommentInfo> ps1List = ps1Map.get(FILE_NAME);
    assertThat(ps1List).hasSize(2);
    assertThat(ps1List.get(0).message).isEqualTo("what happened to this?");
    assertThat(ps1List.get(0).side).isEqualTo(Side.PARENT);
    assertThat(ps1List.get(1).message).isEqualTo("nit: trailing whitespace");
    assertThat(ps1List.get(1).side).isNull();
    assertThat(gApi.changes().id(r2.getChangeId()).revision(r2.getCommit().name()).drafts()).isEmpty();
    Map<String, List<CommentInfo>> ps2Map = gApi.changes().id(r2.getChangeId()).revision(r2.getCommit().name()).comments();
    assertThat(ps2Map.keySet()).containsExactly(FILE_NAME);
    List<CommentInfo> ps2List = ps2Map.get(FILE_NAME);
    assertThat(ps2List).hasSize(4);
    assertThat(ps2List.get(0).message).isEqualTo("comment 1 on base");
    assertThat(ps2List.get(1).message).isEqualTo("comment 2 on base");
    assertThat(ps2List.get(2).message).isEqualTo("join lines");
    assertThat(ps2List.get(3).message).isEqualTo("typo: content");
    ImmutableList<Message> messages = email.getMessages(r2.getChangeId(), "comment");
    assertThat(messages).hasSize(1);
    String url = canonicalWebUrl.get();
    int c = r1.getChange().getId().get();
    assertThat(extractComments(messages.get(0).body())).isEqualTo("Patch Set 2:\n" + "\n" + "(6 comments)\n" + "\n" + "comments\n" + "\n" + url + "#/c/" + c + "/1/a.txt\n" + "File a.txt:\n" + "\n" + "PS1, Line 2: \n" + "what happened to this?\n" + "\n" + "\n" + "PS1, Line 1: ew\n" + "nit: trailing whitespace\n" + "\n" + "\n" + url + "#/c/" + c + "/2/a.txt\n" + "File a.txt:\n" + "\n" + "PS2, Line 1: \n" + "comment 1 on base\n" + "\n" + "\n" + "PS2, Line 2: \n" + "comment 2 on base\n" + "\n" + "\n" + "PS2, Line 1: ew\n" + "join lines\n" + "\n" + "\n" + "PS2, Line 2: nten\n" + "typo: content\n" + "\n");
}
#end_block

#method_before
@Override
public NoteDbChangeState rebuild(ReviewDb db, Change.Id changeId) throws NoSuchChangeException, IOException, OrmException, ConfigInvalidException {
    db = unwrapDb(db);
    Change change = db.changes().get(changeId);
    if (change == null) {
        throw new NoSuchChangeException(changeId);
    }
    NoteDbUpdateManager manager = updateManagerFactory.create(change.getProject());
    buildUpdates(manager, ChangeBundle.fromReviewDb(db, changeId));
    return execute(db, changeId, manager);
}
#method_after
@Override
public NoteDbChangeState rebuild(ReviewDb db, Change.Id changeId) throws NoSuchChangeException, IOException, OrmException, ConfigInvalidException {
    db = unwrapDb(db);
    Change change = db.changes().get(changeId);
    if (change == null) {
        throw new NoSuchChangeException(changeId);
    }
    NoteDbUpdateManager manager = updateManagerFactory.create(change.getProject());
    buildUpdates(manager, ChangeBundle.fromReviewDb(db, changeId));
    NoteDbChangeState result = execute(db, changeId, manager);
    manager.execute();
    return result;
}
#end_block

#method_before
private void buildUpdates(NoteDbUpdateManager manager, ChangeBundle bundle) throws IOException, OrmException, ConfigInvalidException {
    Change change = new Change(bundle.getChange());
    // We will rebuild all events, except for draft comments, in buckets based
    // on author and timestamp.
    List<Event> events = Lists.newArrayList();
    Multimap<Account.Id, PatchLineCommentEvent> draftCommentEvents = ArrayListMultimap.create();
    Repository changeMetaRepo = manager.getChangeRepo().repo;
    events.addAll(getHashtagsEvents(change, manager));
    // Delete ref only after hashtags have been read
    deleteRef(change, changeMetaRepo, manager.getChangeRepo().cmds);
    for (PatchSet ps : bundle.getPatchSets()) {
        events.add(new PatchSetEvent(change, ps, manager.getChangeRepo().rw));
        for (PatchLineComment c : getPatchLineComments(bundle, ps)) {
            PatchLineCommentEvent e = new PatchLineCommentEvent(c, change, ps, patchListCache);
            if (c.getStatus() == Status.PUBLISHED) {
                events.add(e);
            } else {
                draftCommentEvents.put(c.getAuthor(), e);
            }
        }
    }
    for (PatchSetApproval psa : bundle.getPatchSetApprovals()) {
        events.add(new ApprovalEvent(psa, change.getCreatedOn()));
    }
    Change noteDbChange = new Change(null, null, null, null, null);
    for (ChangeMessage msg : bundle.getChangeMessages()) {
        events.add(new ChangeMessageEvent(msg, noteDbChange, change.getCreatedOn()));
    }
    sortEvents(change.getId(), events);
    events.add(new FinalUpdatesEvent(change, noteDbChange));
    EventList<Event> el = new EventList<>();
    for (Event e : events) {
        if (!el.canAdd(e)) {
            flushEventsToUpdate(manager, el, change);
            checkState(el.canAdd(e));
        }
        el.add(e);
    }
    flushEventsToUpdate(manager, el, change);
    EventList<PatchLineCommentEvent> plcel = new EventList<>();
    for (Account.Id author : draftCommentEvents.keys()) {
        for (PatchLineCommentEvent e : draftCommentEvents.get(author)) {
            if (!plcel.canAdd(e)) {
                flushEventsToDraftUpdate(manager, plcel, change);
                checkState(plcel.canAdd(e));
            }
            plcel.add(e);
        }
        flushEventsToDraftUpdate(manager, plcel, change);
    }
}
#method_after
private void buildUpdates(NoteDbUpdateManager manager, ChangeBundle bundle) throws IOException, OrmException {
    Change change = new Change(bundle.getChange());
    // We will rebuild all events, except for draft comments, in buckets based
    // on author and timestamp.
    List<Event> events = Lists.newArrayList();
    Multimap<Account.Id, PatchLineCommentEvent> draftCommentEvents = ArrayListMultimap.create();
    Repository changeMetaRepo = manager.getChangeRepo().repo;
    events.addAll(getHashtagsEvents(change, manager));
    // Delete ref only after hashtags have been read
    deleteRef(change, changeMetaRepo, manager.getChangeRepo().cmds);
    for (PatchSet ps : bundle.getPatchSets()) {
        events.add(new PatchSetEvent(change, ps, manager.getChangeRepo().rw));
        for (PatchLineComment c : getPatchLineComments(bundle, ps)) {
            PatchLineCommentEvent e = new PatchLineCommentEvent(c, change, ps, patchListCache);
            if (c.getStatus() == Status.PUBLISHED) {
                events.add(e);
            } else {
                draftCommentEvents.put(c.getAuthor(), e);
            }
        }
    }
    for (PatchSetApproval psa : bundle.getPatchSetApprovals()) {
        events.add(new ApprovalEvent(psa, change.getCreatedOn()));
    }
    Change noteDbChange = new Change(null, null, null, null, null);
    for (ChangeMessage msg : bundle.getChangeMessages()) {
        events.add(new ChangeMessageEvent(msg, noteDbChange, change.getCreatedOn()));
    }
    sortEvents(change.getId(), events);
    events.add(new FinalUpdatesEvent(change, noteDbChange));
    EventList<Event> el = new EventList<>();
    for (Event e : events) {
        if (!el.canAdd(e)) {
            flushEventsToUpdate(manager, el, change);
            checkState(el.canAdd(e));
        }
        el.add(e);
    }
    flushEventsToUpdate(manager, el, change);
    EventList<PatchLineCommentEvent> plcel = new EventList<>();
    for (Account.Id author : draftCommentEvents.keys()) {
        for (PatchLineCommentEvent e : EVENT_ORDER.sortedCopy(draftCommentEvents.get(author))) {
            if (!plcel.canAdd(e)) {
                flushEventsToDraftUpdate(manager, plcel, change);
                checkState(plcel.canAdd(e));
            }
            plcel.add(e);
        }
        flushEventsToDraftUpdate(manager, plcel, change);
    }
}
#end_block

#method_before
private void flushEventsToUpdate(NoteDbUpdateManager manager, EventList<Event> events, Change change) throws OrmException, IOException {
    if (events.isEmpty()) {
        return;
    }
    Comparator<String> labelNameComparator;
    if (projectCache != null) {
        labelNameComparator = projectCache.get(change.getProject()).getLabelTypes().nameComparator();
    } else {
        // No project cache available, bail and use natural ordering; there's no
        // semantic difference anyway difference.
        labelNameComparator = Ordering.natural();
    }
    ChangeUpdate update = updateFactory.create(notesFactory.createWithAutoRebuildingDisabled(change), events.getAccountId(), events.newAuthorIdent(), events.getWhen(), labelNameComparator);
    update.setAllowWriteToNewRef(true);
    update.setPatchSetId(events.getPatchSetId());
    update.setTag(events.getTag());
    for (Event e : events) {
        e.apply(update);
    }
    manager.add(update);
    events.clear();
}
#method_after
private void flushEventsToUpdate(NoteDbUpdateManager manager, EventList<Event> events, Change change) throws OrmException, IOException {
    if (events.isEmpty()) {
        return;
    }
    Comparator<String> labelNameComparator;
    if (projectCache != null) {
        labelNameComparator = projectCache.get(change.getProject()).getLabelTypes().nameComparator();
    } else {
        // No project cache available, bail and use natural ordering; there's no
        // semantic difference anyway difference.
        labelNameComparator = Ordering.natural();
    }
    ChangeUpdate update = updateFactory.create(notesFactory.createWithAutoRebuildingDisabled(change, manager.getChangeRepo().cmds), events.getAccountId(), events.newAuthorIdent(), events.getWhen(), labelNameComparator);
    update.setAllowWriteToNewRef(true);
    update.setPatchSetId(events.getPatchSetId());
    update.setTag(events.getTag());
    for (Event e : events) {
        e.apply(update);
    }
    manager.add(update);
    events.clear();
}
#end_block

#method_before
private void flushEventsToDraftUpdate(NoteDbUpdateManager manager, EventList<PatchLineCommentEvent> events, Change change) throws OrmException {
    if (events.isEmpty()) {
        return;
    }
    ChangeDraftUpdate update = draftUpdateFactory.create(notesFactory.createWithAutoRebuildingDisabled(change), events.getAccountId(), events.newAuthorIdent(), events.getWhen());
    update.setPatchSetId(events.getPatchSetId());
    for (PatchLineCommentEvent e : events) {
        e.applyDraft(update);
    }
    manager.add(update);
    events.clear();
}
#method_after
private void flushEventsToDraftUpdate(NoteDbUpdateManager manager, EventList<PatchLineCommentEvent> events, Change change) throws OrmException, IOException {
    if (events.isEmpty()) {
        return;
    }
    ChangeDraftUpdate update = draftUpdateFactory.create(notesFactory.createWithAutoRebuildingDisabled(change, manager.getChangeRepo().cmds), events.getAccountId(), events.newAuthorIdent(), events.getWhen());
    update.setPatchSetId(events.getPatchSetId());
    for (PatchLineCommentEvent e : events) {
        e.applyDraft(update);
    }
    manager.add(update);
    events.clear();
}
#end_block

#method_before
private List<HashtagsEvent> getHashtagsEvents(Change change, NoteDbUpdateManager manager) throws IOException, ConfigInvalidException {
    String refName = ChangeNoteUtil.changeRefName(change.getId());
    ObjectId old = manager.getChangeRepo().getObjectId(refName);
    if (old == null) {
        return Collections.emptyList();
    }
    RevWalk rw = manager.getChangeRepo().rw;
    List<HashtagsEvent> events = new ArrayList<>();
    rw.reset();
    rw.markStart(rw.parseCommit(old));
    for (RevCommit commit : rw) {
        Account.Id authorId = changeNoteUtil.parseIdent(commit.getAuthorIdent(), change.getId());
        PatchSet.Id psId = parsePatchSetId(change, commit);
        Set<String> hashtags = parseHashtags(commit);
        if (authorId == null || psId == null || hashtags == null) {
            continue;
        }
        Timestamp commitTime = new Timestamp(commit.getCommitterIdent().getWhen().getTime());
        events.add(new HashtagsEvent(psId, authorId, commitTime, hashtags, change.getCreatedOn()));
    }
    return events;
}
#method_after
private List<HashtagsEvent> getHashtagsEvents(Change change, NoteDbUpdateManager manager) throws IOException {
    String refName = ChangeNoteUtil.changeRefName(change.getId());
    ObjectId old = manager.getChangeRepo().getObjectId(refName);
    if (old == null) {
        return Collections.emptyList();
    }
    RevWalk rw = manager.getChangeRepo().rw;
    List<HashtagsEvent> events = new ArrayList<>();
    rw.reset();
    rw.markStart(rw.parseCommit(old));
    for (RevCommit commit : rw) {
        Account.Id authorId;
        try {
            authorId = changeNoteUtil.parseIdent(commit.getAuthorIdent(), change.getId());
        } catch (ConfigInvalidException e) {
            // Corrupt data, no valid hashtags in this commit.
            continue;
        }
        PatchSet.Id psId = parsePatchSetId(change, commit);
        Set<String> hashtags = parseHashtags(commit);
        if (authorId == null || psId == null || hashtags == null) {
            continue;
        }
        Timestamp commitTime = new Timestamp(commit.getCommitterIdent().getWhen().getTime());
        events.add(new HashtagsEvent(psId, authorId, commitTime, hashtags, change.getCreatedOn()));
    }
    return events;
}
#end_block

#method_before
@Override
public ProjectAccessInfo apply(ProjectResource resource) {
    final ProjectAccessInfo info = new ProjectAccessInfo();
    final ProjectConfig config = resource.getControl().getProjectState().getConfig();
    final ProjectControl pc = resource.getControl();
    final RefControl metaConfigControl = pc.controlForRef(RefNames.REFS_CONFIG);
    info.local = Maps.newHashMap();
    info.ownerOf = Sets.newHashSet();
    Map<UUID, Boolean> visibleGroups = new HashMap<>();
    for (AccessSection section : config.getAccessSections()) {
        String name = section.getName();
        if (AccessSection.GLOBAL_CAPABILITIES.equals(name)) {
            if (pc.isOwner()) {
                info.local.put(name, createAccessSection(section));
                info.ownerOf.add(name);
            } else if (metaConfigControl.isVisible()) {
                info.local.put(section.getName(), createAccessSection(section));
            }
        } else if (RefConfigSection.isValid(name)) {
            RefControl rc = pc.controlForRef(name);
            if (rc.isOwner()) {
                info.local.put(name, createAccessSection(section));
                info.ownerOf.add(name);
            } else if (metaConfigControl.isVisible()) {
                info.local.put(name, createAccessSection(section));
            } else if (rc.isVisible()) {
                // Filter the section to only add rules describing groups that
                // are visible to the current-user. This includes any group the
                // user is a member of, as well as groups they own or that
                // are visible to all users.
                AccessSection dst = null;
                for (Permission srcPerm : section.getPermissions()) {
                    Permission dstPerm = null;
                    for (PermissionRule srcRule : srcPerm.getRules()) {
                        AccountGroup.UUID group = srcRule.getGroup().getUUID();
                        if (group == null) {
                            continue;
                        }
                        Boolean canSeeGroup = visibleGroups.get(group);
                        if (canSeeGroup == null) {
                            try {
                                canSeeGroup = groupControlFactory.controlFor(group).isVisible();
                            } catch (NoSuchGroupException e) {
                                canSeeGroup = Boolean.FALSE;
                            }
                            visibleGroups.put(group, canSeeGroup);
                        }
                        if (canSeeGroup) {
                            if (dstPerm == null) {
                                if (dst == null) {
                                    dst = new AccessSection(name);
                                    info.local.put(name, createAccessSection(dst));
                                }
                                dstPerm = dst.getPermission(srcPerm.getName(), true);
                            }
                            dstPerm.add(srcRule);
                        }
                    }
                }
            }
        }
    }
    if (info.ownerOf.isEmpty() && pc.isOwnerAnyRef()) {
        // Special case: If the section list is empty, this project has no current
        // access control information. Rely on what ProjectControl determines
        // is ownership, which probably means falling back to site administrators.
        info.ownerOf.add(AccessSection.ALL);
    }
    if (config.getRevision() != null) {
        info.revision = config.getRevision().name();
    }
    ProjectState parent = Iterables.getFirst(pc.getProjectState().parents(), null);
    if (parent != null) {
        info.inheritsFrom = projectJson.format(parent.getProject());
    }
    if (pc.getProject().getNameKey().equals(allProjectsName)) {
        if (pc.isOwner()) {
            info.ownerOf.add(AccessSection.GLOBAL_CAPABILITIES);
        }
    }
    info.isOwner = toBoolean(pc.isOwner());
    info.canUpload = toBoolean(pc.isOwner() || (metaConfigControl.isVisible() && metaConfigControl.canUpload()));
    info.canAdd = toBoolean(pc.canAddRefs());
    info.configVisible = pc.isOwner() || metaConfigControl.isVisible();
    return info;
}
#method_after
public ProjectAccessInfo apply(Project.NameKey nameKey) throws ResourceNotFoundException, ResourceConflictException, IOException {
    try {
        return this.apply(new ProjectResource(projectControlFactory.controlFor(nameKey, self.get())));
    } catch (NoSuchProjectException e) {
        throw new ResourceNotFoundException(nameKey.get());
    }
}
#end_block

#method_before
@Override
public ProjectAccessInfo apply(ProjectResource resource) {
    final ProjectAccessInfo info = new ProjectAccessInfo();
    final ProjectConfig config = resource.getControl().getProjectState().getConfig();
    final ProjectControl pc = resource.getControl();
    final RefControl metaConfigControl = pc.controlForRef(RefNames.REFS_CONFIG);
    info.local = Maps.newHashMap();
    info.ownerOf = Sets.newHashSet();
    Map<UUID, Boolean> visibleGroups = new HashMap<>();
    for (AccessSection section : config.getAccessSections()) {
        String name = section.getName();
        if (AccessSection.GLOBAL_CAPABILITIES.equals(name)) {
            if (pc.isOwner()) {
                info.local.put(name, createAccessSection(section));
                info.ownerOf.add(name);
            } else if (metaConfigControl.isVisible()) {
                info.local.put(section.getName(), createAccessSection(section));
            }
        } else if (RefConfigSection.isValid(name)) {
            RefControl rc = pc.controlForRef(name);
            if (rc.isOwner()) {
                info.local.put(name, createAccessSection(section));
                info.ownerOf.add(name);
            } else if (metaConfigControl.isVisible()) {
                info.local.put(name, createAccessSection(section));
            } else if (rc.isVisible()) {
                // Filter the section to only add rules describing groups that
                // are visible to the current-user. This includes any group the
                // user is a member of, as well as groups they own or that
                // are visible to all users.
                AccessSection dst = null;
                for (Permission srcPerm : section.getPermissions()) {
                    Permission dstPerm = null;
                    for (PermissionRule srcRule : srcPerm.getRules()) {
                        AccountGroup.UUID group = srcRule.getGroup().getUUID();
                        if (group == null) {
                            continue;
                        }
                        Boolean canSeeGroup = visibleGroups.get(group);
                        if (canSeeGroup == null) {
                            try {
                                canSeeGroup = groupControlFactory.controlFor(group).isVisible();
                            } catch (NoSuchGroupException e) {
                                canSeeGroup = Boolean.FALSE;
                            }
                            visibleGroups.put(group, canSeeGroup);
                        }
                        if (canSeeGroup) {
                            if (dstPerm == null) {
                                if (dst == null) {
                                    dst = new AccessSection(name);
                                    info.local.put(name, createAccessSection(dst));
                                }
                                dstPerm = dst.getPermission(srcPerm.getName(), true);
                            }
                            dstPerm.add(srcRule);
                        }
                    }
                }
            }
        }
    }
    if (info.ownerOf.isEmpty() && pc.isOwnerAnyRef()) {
        // Special case: If the section list is empty, this project has no current
        // access control information. Rely on what ProjectControl determines
        // is ownership, which probably means falling back to site administrators.
        info.ownerOf.add(AccessSection.ALL);
    }
    if (config.getRevision() != null) {
        info.revision = config.getRevision().name();
    }
    ProjectState parent = Iterables.getFirst(pc.getProjectState().parents(), null);
    if (parent != null) {
        info.inheritsFrom = projectJson.format(parent.getProject());
    }
    if (pc.getProject().getNameKey().equals(allProjectsName)) {
        if (pc.isOwner()) {
            info.ownerOf.add(AccessSection.GLOBAL_CAPABILITIES);
        }
    }
    info.isOwner = toBoolean(pc.isOwner());
    info.canUpload = toBoolean(pc.isOwner() || (metaConfigControl.isVisible() && metaConfigControl.canUpload()));
    info.canAdd = toBoolean(pc.canAddRefs());
    info.configVisible = pc.isOwner() || metaConfigControl.isVisible();
    return info;
}
#method_after
@Override
public ProjectAccessInfo apply(ProjectResource rsrc) throws ResourceNotFoundException, ResourceConflictException, IOException {
    // Load the current configuration from the repository, ensuring it's the most
    // recent version available. If it differs from what was in the project
    // state, force a cache flush now.
    // 
    Project.NameKey projectName = rsrc.getNameKey();
    ProjectAccessInfo info = new ProjectAccessInfo();
    ProjectConfig config;
    ProjectControl pc = open(projectName);
    RefControl metaConfigControl = pc.controlForRef(RefNames.REFS_CONFIG);
    try (MetaDataUpdate md = metaDataUpdateFactory.create(projectName)) {
        config = ProjectConfig.read(md);
        if (config.updateGroupNames(groupBackend)) {
            md.setMessage("Update group names\n");
            config.commit(md);
            projectCache.evict(config.getProject());
            pc = open(projectName);
        } else if (config.getRevision() != null && !config.getRevision().equals(pc.getProjectState().getConfig().getRevision())) {
            projectCache.evict(config.getProject());
            pc = open(projectName);
        }
    } catch (ConfigInvalidException e) {
        throw new ResourceConflictException(e.getMessage());
    } catch (RepositoryNotFoundException e) {
        throw new ResourceNotFoundException(rsrc.getName());
    }
    info.local = new HashMap<>();
    info.ownerOf = Sets.newHashSet();
    Map<AccountGroup.UUID, Boolean> visibleGroups = new HashMap<>();
    for (AccessSection section : config.getAccessSections()) {
        String name = section.getName();
        if (AccessSection.GLOBAL_CAPABILITIES.equals(name)) {
            if (pc.isOwner()) {
                info.local.put(name, createAccessSection(section));
                info.ownerOf.add(name);
            } else if (metaConfigControl.isVisible()) {
                info.local.put(section.getName(), createAccessSection(section));
            }
        } else if (RefConfigSection.isValid(name)) {
            RefControl rc = pc.controlForRef(name);
            if (rc.isOwner()) {
                info.local.put(name, createAccessSection(section));
                info.ownerOf.add(name);
            } else if (metaConfigControl.isVisible()) {
                info.local.put(name, createAccessSection(section));
            } else if (rc.isVisible()) {
                // Filter the section to only add rules describing groups that
                // are visible to the current-user. This includes any group the
                // user is a member of, as well as groups they own or that
                // are visible to all users.
                AccessSection dst = null;
                for (Permission srcPerm : section.getPermissions()) {
                    Permission dstPerm = null;
                    for (PermissionRule srcRule : srcPerm.getRules()) {
                        AccountGroup.UUID group = srcRule.getGroup().getUUID();
                        if (group == null) {
                            continue;
                        }
                        Boolean canSeeGroup = visibleGroups.get(group);
                        if (canSeeGroup == null) {
                            try {
                                canSeeGroup = groupControlFactory.controlFor(group).isVisible();
                            } catch (NoSuchGroupException e) {
                                canSeeGroup = Boolean.FALSE;
                            }
                            visibleGroups.put(group, canSeeGroup);
                        }
                        if (canSeeGroup) {
                            if (dstPerm == null) {
                                if (dst == null) {
                                    dst = new AccessSection(name);
                                    info.local.put(name, createAccessSection(dst));
                                }
                                dstPerm = dst.getPermission(srcPerm.getName(), true);
                            }
                            dstPerm.add(srcRule);
                        }
                    }
                }
            }
        }
    }
    if (info.ownerOf.isEmpty() && pc.isOwnerAnyRef()) {
        // Special case: If the section list is empty, this project has no current
        // access control information. Rely on what ProjectControl determines
        // is ownership, which probably means falling back to site administrators.
        info.ownerOf.add(AccessSection.ALL);
    }
    if (config.getRevision() != null) {
        info.revision = config.getRevision().name();
    }
    ProjectState parent = Iterables.getFirst(pc.getProjectState().parents(), null);
    if (parent != null) {
        info.inheritsFrom = projectJson.format(parent.getProject());
    }
    if (pc.getProject().getNameKey().equals(allProjectsName)) {
        if (pc.isOwner()) {
            info.ownerOf.add(AccessSection.GLOBAL_CAPABILITIES);
        }
    }
    info.isOwner = toBoolean(pc.isOwner());
    info.canUpload = toBoolean(pc.isOwner() || (metaConfigControl.isVisible() && metaConfigControl.canUpload()));
    info.canAdd = toBoolean(pc.canAddRefs());
    info.configVisible = pc.isOwner() || metaConfigControl.isVisible();
    return info;
}
#end_block

#method_before
private AccessSectionInfo createAccessSection(AccessSection section) {
    AccessSectionInfo accessSectionInfo = new AccessSectionInfo();
    accessSectionInfo.permissions = Maps.newHashMap();
    for (Permission p : section.getPermissions()) {
        PermissionInfo pInfo = new PermissionInfo(p.getLabel(), p.getExclusiveGroup() ? true : null);
        pInfo.rules = Maps.newHashMap();
        for (PermissionRule r : p.getRules()) {
            PermissionRuleInfo info = new PermissionRuleInfo(PermissionRuleActionInfo.values()[r.getAction().ordinal()], r.getForce());
            if (r.hasRange()) {
                info.max = r.getMax();
                info.min = r.getMin();
            }
            pInfo.rules.put(r.getGroup().getUUID().get(), info);
        }
        accessSectionInfo.permissions.put(p.getName(), pInfo);
    }
    return accessSectionInfo;
}
#method_after
private AccessSectionInfo createAccessSection(AccessSection section) {
    AccessSectionInfo accessSectionInfo = new AccessSectionInfo();
    accessSectionInfo.permissions = new HashMap<>();
    for (Permission p : section.getPermissions()) {
        PermissionInfo pInfo = new PermissionInfo(p.getLabel(), p.getExclusiveGroup() ? true : null);
        pInfo.rules = new HashMap<>();
        for (PermissionRule r : p.getRules()) {
            PermissionRuleInfo info = new PermissionRuleInfo(ACTION_TYPE.get(r.getAction()), r.getForce());
            if (r.hasRange()) {
                info.max = r.getMax();
                info.min = r.getMin();
            }
            pInfo.rules.put(r.getGroup().getUUID().get(), info);
        }
        accessSectionInfo.permissions.put(p.getName(), pInfo);
    }
    return accessSectionInfo;
}
#end_block

#method_before
@Override
public ProjectAccessInfo get() throws RestApiException {
    return getAccess.apply(project);
}
#method_after
@Override
public ProjectAccessInfo get() throws RestApiException {
    try {
        return getAccess.apply(project);
    } catch (IOException e) {
        throw new RestApiException("Cannot get access rights", e);
    }
}
#end_block

#method_before
@Override
public ProjectAccessInfo access() throws RestApiException {
    return accessApi.create(checkExists(), projectJson).get();
}
#method_after
@Override
public ProjectAccessInfo access() throws RestApiException {
    return accessApi.create(checkExists()).get();
}
#end_block

#method_before
@Test
public void testGetDefaultInheritance() throws Exception {
    // create proj
    String newProjectName = name("newProjectAccess");
    RestResponse r = adminSession.put("/projects/" + newProjectName);
    String inheritedName = gApi.projects().name(newProjectName).access().inheritsFrom.name;
    assertThat(inheritedName).isEqualTo(allProjectsName.get());
}
#method_after
@Test
public void testGetDefaultInheritance() throws Exception {
    String newProjectName = createProject("newProjectAccess").get();
    String inheritedName = gApi.projects().name(newProjectName).access().inheritsFrom.name;
    assertThat(inheritedName).isEqualTo(AllProjectsNameProvider.DEFAULT);
}
#end_block

#method_before
@Override
public Map<String, ProjectAccessInfo> apply(TopLevelResource resource) throws ResourceNotFoundException, ResourceConflictException, IOException {
    Map<String, ProjectAccessInfo> access = Maps.newTreeMap();
    for (String p : projects) {
        // Load the current configuration from the repository, ensuring it's the most
        // recent version available. If it differs from what was in the project
        // state, force a cache flush now.
        // 
        Project.NameKey projectName = new Project.NameKey(p);
        try (MetaDataUpdate md = metaDataUpdateFactory.create(projectName)) {
            ProjectControl pc = open(projectName);
            ProjectConfig config = ProjectConfig.read(md);
            if (config.updateGroupNames(groupBackend)) {
                md.setMessage("Update group names\n");
                config.commit(md);
                projectCache.evict(config.getProject());
                pc = open(projectName);
            } else if (config.getRevision() != null && !config.getRevision().equals(pc.getProjectState().getConfig().getRevision())) {
                projectCache.evict(config.getProject());
                pc = open(projectName);
            }
            GetAccess ga = new GetAccess(groupControlFactory, allProjectsName, projectJson);
            access.put(p, ga.apply(new ProjectResource(pc)));
        } catch (ConfigInvalidException e) {
            throw new ResourceConflictException(e.getMessage());
        } catch (RepositoryNotFoundException e) {
            throw new ResourceNotFoundException(p);
        }
    }
    return access;
}
#method_after
@Override
public Map<String, ProjectAccessInfo> apply(TopLevelResource resource) throws ResourceNotFoundException, ResourceConflictException, IOException {
    Map<String, ProjectAccessInfo> access = Maps.newTreeMap();
    for (String p : projects) {
        Project.NameKey projectName = new Project.NameKey(p);
        access.put(p, getAccess.apply(projectName));
    }
    return access;
}
#end_block

#method_before
private void initKeyMapType() {
    keyMap.addItem(KeyMapType.DEFAULT.name().toLowerCase(), KeyMapType.DEFAULT.name());
    keyMap.addItem(KeyMapType.EMACS.name().toLowerCase(), KeyMapType.EMACS.name());
    keyMap.addItem(KeyMapType.SUBLIME.name().toLowerCase(), KeyMapType.SUBLIME.name());
    keyMap.addItem(KeyMapType.VIM.name().toLowerCase(), KeyMapType.VIM.name());
}
#method_after
private void initKeyMapType() {
    for (KeyMapType t : KeyMapType.values()) {
        keyMap.addItem(t.name().toLowerCase(), t.name());
    }
}
#end_block

#method_before
private <K, V, I extends Index<K, V>> void initIndex(IndexDefinition<K, V, I> def, FileBasedConfig cfg) {
    TreeMap<Integer, Version<V>> versions = scanVersions(def, cfg);
    // Search from the most recent ready version.
    // Write to the most recent ready version and the most recent version.
    Version<V> search = null;
    List<Version<V>> write = Lists.newArrayListWithCapacity(2);
    for (Version<V> v : versions.descendingMap().values()) {
        if (v.schema == null) {
            continue;
        }
        if (write.isEmpty() && onlineUpgrade) {
            write.add(v);
        }
        if (v.ready) {
            search = v;
            if (!write.contains(v)) {
                write.add(v);
            }
            break;
        }
    }
    if (search == null) {
        throw new ProvisionException(runReindexMsg);
    }
    IndexFactory<K, V, I> factory = def.getIndexFactory();
    I searchIndex = factory.create(search.schema);
    IndexCollection<K, V, I> indexes = def.getIndexCollection();
    indexes.setSearchIndex(searchIndex);
    for (Version<V> v : write) {
        if (v.schema != null) {
            if (v.version != search.version) {
                indexes.addWriteIndex(factory.create(v.schema));
            }
        } else {
            indexes.addWriteIndex(searchIndex);
        }
    }
    // TODO: include index name.
    markNotReady(cfg, versions.values(), write);
    int latest = write.get(0).version;
    if (onlineUpgrade && latest != search.version) {
        OnlineReindexer<K, V, I> reindexer = new OnlineReindexer<>(def, latest);
        synchronized (this) {
            if (!reindexers.containsKey(def.getName())) {
                reindexers.put(def.getName(), reindexer);
                reindexer.start();
            }
        }
    }
}
#method_after
private <K, V, I extends Index<K, V>> void initIndex(IndexDefinition<K, V, I> def, FileBasedConfig cfg) {
    TreeMap<Integer, Version<V>> versions = scanVersions(def, cfg);
    // Search from the most recent ready version.
    // Write to the most recent ready version and the most recent version.
    Version<V> search = null;
    List<Version<V>> write = Lists.newArrayListWithCapacity(2);
    for (Version<V> v : versions.descendingMap().values()) {
        if (v.schema == null) {
            continue;
        }
        if (write.isEmpty() && onlineUpgrade) {
            write.add(v);
        }
        if (v.ready) {
            search = v;
            if (!write.contains(v)) {
                write.add(v);
            }
            break;
        }
    }
    if (search == null) {
        throw new ProvisionException(runReindexMsg);
    }
    IndexFactory<K, V, I> factory = def.getIndexFactory();
    I searchIndex = factory.create(search.schema);
    IndexCollection<K, V, I> indexes = def.getIndexCollection();
    indexes.setSearchIndex(searchIndex);
    for (Version<V> v : write) {
        if (v.schema != null) {
            if (v.version != search.version) {
                indexes.addWriteIndex(factory.create(v.schema));
            } else {
                indexes.addWriteIndex(searchIndex);
            }
        }
    }
    // TODO: include index name.
    markNotReady(cfg, versions.values(), write);
    int latest = write.get(0).version;
    if (onlineUpgrade && latest != search.version) {
        OnlineReindexer<K, V, I> reindexer = new OnlineReindexer<>(def, latest);
        synchronized (this) {
            if (!reindexers.containsKey(def.getName())) {
                reindexers.put(def.getName(), reindexer);
                reindexer.start();
            }
        }
    }
}
#end_block

#method_before
@Override
public Map<String, VerificationInfo> apply(RevisionResource rsrc) throws IOException, OrmException {
    Map<String, VerificationInfo> out = Maps.newHashMap();
    try (CiDb db = schemaFactory.open()) {
        for (PatchSetVerification v : db.patchSetVerifications().byPatchSet(rsrc.getPatchSet().getId())) {
            VerificationInfo info = new VerificationInfo();
            info.value = v.getValue();
            info.url = v.getUrl();
            info.reporter = v.getVerifier();
            info.comment = v.getComment();
            info.granted = v.getGranted();
            info.category = v.getCategory();
            info.voting = v.getVoting();
            info.duration = v.getDuration();
            out.put(v.getJobId().get(), info);
        }
    }
    return out;
}
#method_after
@Override
public Map<String, VerificationInfo> apply(RevisionResource rsrc) throws IOException, OrmException {
    Map<String, VerificationInfo> out = Maps.newHashMap();
    try (CiDb db = schemaFactory.open()) {
        for (PatchSetVerification v : db.patchSetVerifications().byPatchSet(rsrc.getPatchSet().getId())) {
            VerificationInfo info = new VerificationInfo();
            info.value = v.getValue();
            info.abstain = v.getAbstain();
            info.url = v.getUrl();
            info.reporter = v.getReporter();
            info.comment = v.getComment();
            info.granted = v.getGranted();
            info.category = v.getCategory();
            info.duration = v.getDuration();
            out.put(v.getJobId().get(), info);
        }
    }
    return out;
}
#end_block

#method_before
private void parseWithEquals(String text) {
    log.debug("processing verification: " + text);
    checkArgument(!Strings.isNullOrEmpty(text), "Empty verification data");
    Map<String, String> params = null;
    try {
        params = Splitter.on("|").withKeyValueSeparator("=").split(text);
    } catch (IllegalArgumentException e) {
        throw new IllegalArgumentException(String.valueOf("Invalid verification parameters"));
    }
    String job = params.get("job");
    checkArgument(job != null, "Verification is missing a job");
    String value = params.get("value");
    checkArgument(value != null, "Verification is missing a value");
    VerificationInfo data = new VerificationInfo();
    data.value = Short.parseShort(value);
    String voting = params.get("voting");
    data.voting = Boolean.parseBoolean(voting);
    data.url = params.get("url");
    data.reporter = params.get("reporter");
    data.comment = params.get("comment");
    data.category = params.get("category");
    data.duration = params.get("duration");
    jobResult.put(job, data);
}
#method_after
private void parseWithEquals(String text) {
    log.debug("processing verification: " + text);
    checkArgument(!Strings.isNullOrEmpty(text), "Empty verification data");
    Map<String, String> params = null;
    try {
        params = Splitter.on("|").withKeyValueSeparator("=").split(text);
    } catch (IllegalArgumentException e) {
        throw new IllegalArgumentException(String.valueOf("Invalid verification parameters"));
    }
    String job = params.get("job");
    checkArgument(job != null, "Verification is missing a job");
    String value = params.get("value");
    checkArgument(value != null, "Verification is missing a value");
    String abstain = params.get("abstain");
    VerificationInfo data = new VerificationInfo();
    data.value = Short.parseShort(value);
    data.abstain = Boolean.valueOf(abstain);
    data.url = params.get("url");
    data.reporter = params.get("reporter");
    data.comment = params.get("comment");
    data.category = params.get("category");
    data.duration = params.get("duration");
    jobResult.put(job, data);
}
#end_block

#method_before
private boolean updateLabels(RevisionResource resource, CiDb db, Map<String, VerificationInfo> jobs) throws OrmException, BadRequestException {
    Preconditions.checkNotNull(jobs);
    List<PatchSetVerification> ups = Lists.newArrayList();
    Map<String, PatchSetVerification> current = scanLabels(resource, db);
    Timestamp ts = TimeUtil.nowTs();
    for (Map.Entry<String, VerificationInfo> ent : jobs.entrySet()) {
        String name = ent.getKey();
        PatchSetVerification c = current.remove(name);
        Short value = ent.getValue().value;
        if (value == null) {
            throw new BadRequestException("Missing value field");
        }
        if (c != null) {
            c.setGranted(ts);
            c.setValue(value);
            boolean voting = ent.getValue().voting;
            c.setVoting(voting);
            String url = ent.getValue().url;
            if (url != null) {
                c.setUrl(url);
            }
            String verifier = ent.getValue().reporter;
            if (verifier != null) {
                c.setVerifier(verifier);
            }
            String comment = ent.getValue().comment;
            if (comment != null) {
                c.setComment(comment);
            }
            String category = ent.getValue().category;
            if (category != null) {
                c.setCategory(category);
            }
            String duration = ent.getValue().duration;
            if (duration != null) {
                c.setDuration(duration);
            }
            log.info("Updating job " + c.getJob() + " for change " + c.getPatchSetId());
            ups.add(c);
        } else {
            c = new PatchSetVerification(new PatchSetVerification.Key(resource.getPatchSet().getId(), new LabelId(name)), value, TimeUtil.nowTs());
            c.setGranted(ts);
            c.setValue(value);
            c.setUrl(ent.getValue().url);
            c.setVerifier(ent.getValue().reporter);
            c.setVoting(ent.getValue().voting);
            c.setComment(ent.getValue().comment);
            c.setCategory(ent.getValue().category);
            c.setDuration(ent.getValue().duration);
            log.info("Adding job " + c.getJob() + " for change " + c.getPatchSetId());
            ups.add(c);
        }
    }
    db.patchSetVerifications().upsert(ups);
    return !ups.isEmpty();
}
#method_after
private boolean updateLabels(RevisionResource resource, CiDb db, Map<String, VerificationInfo> jobs) throws OrmException, BadRequestException {
    Preconditions.checkNotNull(jobs);
    List<PatchSetVerification> ups = Lists.newArrayList();
    Map<String, PatchSetVerification> current = scanLabels(resource, db);
    Timestamp ts = TimeUtil.nowTs();
    for (Map.Entry<String, VerificationInfo> ent : jobs.entrySet()) {
        String name = ent.getKey();
        PatchSetVerification c = current.remove(name);
        Short value = ent.getValue().value;
        if (value == null) {
            throw new BadRequestException("Missing value field");
        }
        if (c != null) {
            c.setGranted(ts);
            c.setValue(value);
            if (Boolean.TRUE.equals(ent.getValue().abstain)) {
                c.setAbstain(true);
            }
            String url = ent.getValue().url;
            if (url != null) {
                c.setUrl(url);
            }
            String reporter = ent.getValue().reporter;
            if (reporter != null) {
                c.setReporter(reporter);
            }
            String comment = ent.getValue().comment;
            if (comment != null) {
                c.setComment(comment);
            }
            String category = ent.getValue().category;
            if (category != null) {
                c.setCategory(category);
            }
            String duration = ent.getValue().duration;
            if (duration != null) {
                c.setDuration(duration);
            }
            log.info("Updating job " + c.getJob() + " for change " + c.getPatchSetId());
            ups.add(c);
        } else {
            c = new PatchSetVerification(new PatchSetVerification.Key(resource.getPatchSet().getId(), new LabelId(name)), value, ts);
            c.setAbstain(ent.getValue().abstain);
            c.setUrl(ent.getValue().url);
            c.setReporter(ent.getValue().reporter);
            c.setComment(ent.getValue().comment);
            c.setCategory(ent.getValue().category);
            c.setDuration(ent.getValue().duration);
            log.info("Adding job " + c.getJob() + " for change " + c.getPatchSetId());
            ups.add(c);
        }
    }
    db.patchSetVerifications().upsert(ups);
    return !ups.isEmpty();
}
#end_block

#method_before
public PatchSet currentPatchSet() throws OrmException {
    if (currentPatchSet == null) {
        Change c = change();
        if (c == null) {
            return null;
        }
        for (PatchSet p : patches()) {
            if (p.getId().equals(c.currentPatchSetId())) {
                if (changeControl().isPatchVisible(p, db)) {
                    currentPatchSet = p;
                    return p;
                }
            }
        }
    }
    return currentPatchSet;
}
#method_after
public PatchSet currentPatchSet() throws OrmException {
    if (currentPatchSet == null) {
        Change c = change();
        if (c == null) {
            return null;
        }
        for (PatchSet p : patches()) {
            if (p.getId().equals(c.currentPatchSetId())) {
                currentPatchSet = p;
                return p;
            }
        }
    }
    return currentPatchSet;
}
#end_block

#method_before
private void display(final CommentsCollections comments) {
    final DiffInfo diff = getDiff();
    setThemeStyles(prefs.theme().isDark());
    setShowIntraline(prefs.intralineDifference());
    // TODO: Handle showLineNumbers preference
    cm = newCm(diff.metaA() == null ? diff.metaB() : diff.metaA(), diff.textUnified(), diffTable.cm);
    setShowTabs(prefs.showTabs());
    chunkManager = new UnifiedChunkManager(this, cm, diffTable.scrollbar);
    setSkipManager(new SkipManager(this, commentManager));
    operation(new Runnable() {

        @Override
        public void run() {
            // Estimate initial CodeMirror height, fixed up in onShowView.
            int height = Window.getClientHeight() - (Gerrit.getHeaderFooterHeight() + 18);
            cm.setHeight(height);
            render(diff);
            commentManager.render(comments, prefs.expandAllComments());
            getSkipManager().render(prefs.context(), diff);
        }
    });
    registerCmEvents(cm);
    setPrefsAction(new PreferencesAction(this, prefs));
    header.init(getPrefsAction(), getSideBySideDiffLink(), diff.unifiedWebLinks());
    setAutoHideDiffHeader(prefs.autoHideDiffTableHeader());
    setupSyntaxHighlighting();
}
#method_after
private void display(final CommentsCollections comments) {
    final DiffInfo diff = getDiff();
    setThemeStyles(prefs.theme().isDark());
    setShowIntraline(prefs.intralineDifference());
    // TODO: Handle showLineNumbers preference
    cm = newCm(diff.metaA() == null ? diff.metaB() : diff.metaA(), diff.textUnified(), diffTable.cm);
    setShowTabs(prefs.showTabs());
    chunkManager = new UnifiedChunkManager(this, cm, diffTable.scrollbar);
    operation(new Runnable() {

        @Override
        public void run() {
            // Estimate initial CodeMirror height, fixed up in onShowView.
            int height = Window.getClientHeight() - (Gerrit.getHeaderFooterHeight() + 18);
            cm.setHeight(height);
            render(diff);
            commentManager.render(comments, prefs.expandAllComments());
            skipManager.render(prefs.context(), diff);
        }
    });
    registerCmEvents(cm);
    setPrefsAction(new PreferencesAction(this, prefs));
    header.init(getPrefsAction(), getSideBySideDiffLink(), diff.unifiedWebLinks());
    setAutoHideDiffHeader(prefs.autoHideDiffTableHeader());
    setupSyntaxHighlighting();
}
#end_block

#method_before
private void display(final CommentsCollections comments) {
    final DiffInfo diff = getDiff();
    setThemeStyles(prefs.theme().isDark());
    setShowIntraline(prefs.intralineDifference());
    if (prefs.showLineNumbers()) {
        diffTable.addStyleName(SideBySideTable.style.showLineNumbers());
    }
    cmA = newCm(diff.metaA(), diff.textA(), diffTable.cmA);
    cmB = newCm(diff.metaB(), diff.textB(), diffTable.cmB);
    cmA.extras().side(DisplaySide.A);
    cmB.extras().side(DisplaySide.B);
    setShowTabs(prefs.showTabs());
    chunkManager = new SideBySideChunkManager(this, cmA, cmB, diffTable.scrollbar);
    setSkipManager(new SkipManager(this, commentManager));
    operation(new Runnable() {

        @Override
        public void run() {
            // Estimate initial CodeMirror height, fixed up in onShowView.
            int height = Window.getClientHeight() - (Gerrit.getHeaderFooterHeight() + 18);
            cmA.setHeight(height);
            cmB.setHeight(height);
            render(diff);
            commentManager.render(comments, prefs.expandAllComments());
            getSkipManager().render(prefs.context(), diff);
        }
    });
    registerCmEvents(cmA);
    registerCmEvents(cmB);
    scrollSynchronizer = new ScrollSynchronizer(diffTable, cmA, cmB, chunkManager.getLineMapper());
    setPrefsAction(new PreferencesAction(this, prefs));
    header.init(getPrefsAction(), getUnifiedDiffLink(), diff.sideBySideWebLinks());
    scrollSynchronizer.setAutoHideDiffTableHeader(prefs.autoHideDiffTableHeader());
    setupSyntaxHighlighting();
}
#method_after
private void display(final CommentsCollections comments) {
    final DiffInfo diff = getDiff();
    setThemeStyles(prefs.theme().isDark());
    setShowIntraline(prefs.intralineDifference());
    if (prefs.showLineNumbers()) {
        diffTable.addStyleName(SideBySideTable.style.showLineNumbers());
    }
    cmA = newCm(diff.metaA(), diff.textA(), diffTable.cmA);
    cmB = newCm(diff.metaB(), diff.textB(), diffTable.cmB);
    cmA.extras().side(DisplaySide.A);
    cmB.extras().side(DisplaySide.B);
    setShowTabs(prefs.showTabs());
    chunkManager = new SideBySideChunkManager(this, cmA, cmB, diffTable.scrollbar);
    operation(new Runnable() {

        @Override
        public void run() {
            // Estimate initial CodeMirror height, fixed up in onShowView.
            int height = Window.getClientHeight() - (Gerrit.getHeaderFooterHeight() + 18);
            cmA.setHeight(height);
            cmB.setHeight(height);
            render(diff);
            commentManager.render(comments, prefs.expandAllComments());
            skipManager.render(prefs.context(), diff);
        }
    });
    registerCmEvents(cmA);
    registerCmEvents(cmB);
    scrollSynchronizer = new ScrollSynchronizer(diffTable, cmA, cmB, chunkManager.getLineMapper());
    setPrefsAction(new PreferencesAction(this, prefs));
    header.init(getPrefsAction(), getUnifiedDiffLink(), diff.sideBySideWebLinks());
    scrollSynchronizer.setAutoHideDiffTableHeader(prefs.autoHideDiffTableHeader());
    setupSyntaxHighlighting();
}
#end_block

#method_before
void render(int context, DiffInfo diff) {
    if (context == DiffPreferencesInfo.WHOLE_FILE_CONTEXT) {
        return;
    }
    List<SkippedLine> skips = new ArrayList<>();
    int lineA = 0;
    int lineB = 0;
    JsArray<Region> regions = diff.content();
    for (int i = 0; i < regions.length(); i++) {
        Region current = regions.get(i);
        if (current.ab() != null || current.common() || current.skip() > 0) {
            int len = current.skip() > 0 ? current.skip() : (current.ab() != null ? current.ab() : current.b()).length();
            if (i == 0 && len > context + 1) {
                skips.add(new SkippedLine(0, 0, len - context));
            } else if (i == regions.length() - 1 && len > context + 1) {
                skips.add(new SkippedLine(lineA + context, lineB + context, len - context));
            } else if (len > 2 * context + 1) {
                skips.add(new SkippedLine(lineA + context, lineB + context, len - 2 * context));
            }
            lineA += len;
            lineB += len;
        } else {
            lineA += current.a() != null ? current.a().length() : 0;
            lineB += current.b() != null ? current.b().length() : 0;
        }
    }
    skips = commentManager.splitSkips(context, skips);
    if (!skips.isEmpty()) {
        boolean isSideBySide = host.diffScreenType == DiffView.SIDE_BY_SIDE;
        CodeMirror cmA = null;
        if (isSideBySide) {
            cmA = host.getCmFromSide(DisplaySide.A);
        }
        CodeMirror cmB = host.getCmFromSide(DisplaySide.B);
        for (SkippedLine skip : skips) {
            SkipBar barA = null;
            SkipBar barB = newSkipBar(cmB, DisplaySide.B, skip);
            skipBars.add(barB);
            if (isSideBySide) {
                barA = newSkipBar(cmA, DisplaySide.A, skip);
                SkipBar.link(barA, barB);
                skipBars.add(barA);
            }
            if (skip.getStartA() == 0 || skip.getStartB() == 0) {
                if (isSideBySide) {
                    barA.upArrow.setVisible(false);
                }
                barB.upArrow.setVisible(false);
                setLine0(barB);
            } else if (skip.getStartA() + skip.getSize() == lineA || skip.getStartB() + skip.getSize() == lineB) {
                if (isSideBySide) {
                    barA.downArrow.setVisible(false);
                }
                barB.downArrow.setVisible(false);
            }
        }
    }
}
#method_after
void render(int context, DiffInfo diff) {
    if (context == DiffPreferencesInfo.WHOLE_FILE_CONTEXT) {
        return;
    }
    List<SkippedLine> skips = new ArrayList<>();
    int lineA = 0;
    int lineB = 0;
    JsArray<Region> regions = diff.content();
    for (int i = 0; i < regions.length(); i++) {
        Region current = regions.get(i);
        if (current.ab() != null || current.common() || current.skip() > 0) {
            int len = current.skip() > 0 ? current.skip() : (current.ab() != null ? current.ab() : current.b()).length();
            if (i == 0 && len > context + 1) {
                skips.add(new SkippedLine(0, 0, len - context));
            } else if (i == regions.length() - 1 && len > context + 1) {
                skips.add(new SkippedLine(lineA + context, lineB + context, len - context));
            } else if (len > 2 * context + 1) {
                skips.add(new SkippedLine(lineA + context, lineB + context, len - 2 * context));
            }
            lineA += len;
            lineB += len;
        } else {
            lineA += current.a() != null ? current.a().length() : 0;
            lineB += current.b() != null ? current.b().length() : 0;
        }
    }
    skips = host.getCommentManager().splitSkips(context, skips);
    renderSkips(skips, lineA, lineB);
}
#end_block

#method_before
@Override
public String generate() {
    String message;
    message = "";
    try {
        String template;
        template = ResourceHelper.loadNamedResourceAsString("basic-message-template.json");
        StringBuilder text;
        text = new StringBuilder();
        text.append(escape(event.author.name));
        text.append(" comments: ");
        text.append(escape(event.comment));
        text.append("\\n>>>");
        text.append(escape(event.change.project));
        text.append(" (");
        text.append(escape(event.change.branch));
        text.append("): ");
        text.append(escape(event.change.commitMessage.split("\n")[0]));
        text.append(" (");
        text.append(escape(event.change.url));
        text.append(")");
        message = String.format(template, text, config.getChannel(), config.getUsername());
    } catch (Exception e) {
        LOGGER.error("Error generating message: " + e.getMessage());
    }
    return message;
}
#method_after
@Override
public String generate() {
    String message;
    message = "";
    try {
        String template;
        template = ResourceHelper.loadNamedResourceAsString("basic-message-template.json");
        StringBuilder text;
        text = new StringBuilder();
        text.append(escape(event.author.name));
        text.append(" commented\\n>>>");
        text.append(escape(event.change.project));
        text.append(" (");
        text.append(escape(event.change.branch));
        text.append("): ");
        text.append(escape(Ascii.truncate(event.comment, 200, "...")));
        text.append(" (");
        text.append(escape(event.change.url));
        text.append(")");
        message = String.format(template, text, config.getChannel(), config.getUsername());
    } catch (Exception e) {
        LOGGER.error("Error generating message: " + e.getMessage(), e);
    }
    return message;
}
#end_block

#method_before
@Override
public String generate() {
    String message;
    message = "";
    try {
        String template;
        template = ResourceHelper.loadNamedResourceAsString("basic-message-template.json");
        StringBuilder text;
        text = new StringBuilder();
        text.append(escape(event.submitter.name));
        text.append(" merged\\n>>>");
        text.append(escape(event.change.project));
        text.append(" (");
        text.append(escape(event.change.branch));
        text.append("): ");
        text.append(escape(event.change.commitMessage.split("\n")[0]));
        text.append(" (");
        text.append(escape(event.change.url));
        text.append(")");
        message = String.format(template, text, config.getChannel(), config.getUsername());
    } catch (Exception e) {
        LOGGER.error("Error generating message: " + e.getMessage());
    }
    return message;
}
#method_after
@Override
public String generate() {
    String message;
    message = "";
    try {
        String template;
        template = ResourceHelper.loadNamedResourceAsString("basic-message-template.json");
        StringBuilder text;
        text = new StringBuilder();
        text.append(escape(event.submitter.name));
        text.append(" merged\\n>>>");
        text.append(escape(event.change.project));
        text.append(" (");
        text.append(escape(event.change.branch));
        text.append("): ");
        text.append(escape(event.change.commitMessage.split("\n")[0]));
        text.append(" (");
        text.append(escape(event.change.url));
        text.append(")");
        message = String.format(template, text, config.getChannel(), config.getUsername());
    } catch (Exception e) {
        LOGGER.error("Error generating message: " + e.getMessage(), e);
    }
    return message;
}
#end_block

#method_before
@Override
public String generate() {
    String message;
    message = "";
    try {
        String template;
        template = ResourceHelper.loadNamedResourceAsString("basic-message-template.json");
        StringBuilder text;
        text = new StringBuilder();
        text.append(escape(event.uploader.name));
        text.append(" proposed\\n>>>");
        text.append(escape(event.change.project));
        text.append(" (");
        text.append(escape(event.change.branch));
        text.append("): ");
        text.append(escape(event.change.commitMessage.split("\n")[0]));
        text.append(" (");
        text.append(escape(event.change.url));
        text.append(")");
        message = String.format(template, text, config.getChannel(), config.getUsername());
    } catch (Exception e) {
        LOGGER.error("Error generating message: " + e.getMessage());
    }
    return message;
}
#method_after
@Override
public String generate() {
    String message;
    message = "";
    try {
        String template;
        template = ResourceHelper.loadNamedResourceAsString("basic-message-template.json");
        StringBuilder text;
        text = new StringBuilder();
        text.append(escape(event.uploader.name));
        text.append(" proposed\\n>>>");
        text.append(escape(event.change.project));
        text.append(" (");
        text.append(escape(event.change.branch));
        text.append("): ");
        text.append(escape(event.change.commitMessage.split("\n")[0]));
        text.append(" (");
        text.append(escape(event.change.url));
        text.append(")");
        message = String.format(template, text, config.getChannel(), config.getUsername());
    } catch (Exception e) {
        LOGGER.error("Error generating message: " + e.getMessage(), e);
    }
    return message;
}
#end_block

#method_before
public void star(Account.Id accountId, Project.NameKey project, Change.Id changeId) throws OrmException, IOException {
    dbProvider.get().starredChanges().insert(Collections.singleton(new StarredChange(new StarredChange.Key(accountId, changeId))));
    if (!migration.writeAccounts()) {
        indexer.index(dbProvider.get(), project, changeId);
        return;
    }
    try (Repository repo = repoManager.openRepository(allUsers)) {
        String refName = RefNames.refsStarredChanges(accountId, changeId);
        ObjectId oldObjectId = getObjectId(repo, refName);
        SortedSet<String> labels = readLabels(repo, oldObjectId);
        labels.add(DEFAULT_LABEL);
        updateLabels(repo, refName, oldObjectId, labels);
        indexer.index(dbProvider.get(), project, changeId);
    } catch (IOException e) {
        throw new OrmException(String.format("Star change %d for account %d failed", changeId.get(), accountId.get()), e);
    }
}
#method_after
public void star(Account.Id accountId, Project.NameKey project, Change.Id changeId) throws OrmException, IOException {
    dbProvider.get().starredChanges().insert(Collections.singleton(new StarredChange(new StarredChange.Key(accountId, changeId))));
    if (!migration.writeAccounts()) {
        indexer.index(dbProvider.get(), project, changeId);
        return;
    }
    try (Repository repo = repoManager.openRepository(allUsers)) {
        String refName = RefNames.refsStarredChanges(changeId, accountId);
        ObjectId oldObjectId = getObjectId(repo, refName);
        SortedSet<String> labels = readLabels(repo, oldObjectId);
        labels.add(DEFAULT_LABEL);
        updateLabels(repo, refName, oldObjectId, labels);
        indexer.index(dbProvider.get(), project, changeId);
    } catch (IOException e) {
        throw new OrmException(String.format("Star change %d for account %d failed", changeId.get(), accountId.get()), e);
    }
}
#end_block

#method_before
public void unstar(Account.Id accountId, Project.NameKey project, Change.Id changeId) throws OrmException, IOException {
    dbProvider.get().starredChanges().delete(Collections.singleton(new StarredChange(new StarredChange.Key(accountId, changeId))));
    if (!migration.writeAccounts()) {
        indexer.index(dbProvider.get(), project, changeId);
        return;
    }
    try (Repository repo = repoManager.openRepository(allUsers);
        RevWalk rw = new RevWalk(repo)) {
        RefUpdate u = repo.updateRef(RefNames.refsStarredChanges(accountId, changeId));
        u.setForceUpdate(true);
        u.setRefLogIdent(serverIdent);
        u.setRefLogMessage("Unstar change " + changeId.get(), true);
        RefUpdate.Result result = u.delete();
        switch(result) {
            case FORCED:
                indexer.index(dbProvider.get(), project, changeId);
                return;
            case FAST_FORWARD:
            case IO_FAILURE:
            case LOCK_FAILURE:
            case NEW:
            case NOT_ATTEMPTED:
            case NO_CHANGE:
            case REJECTED:
            case REJECTED_CURRENT_BRANCH:
            case RENAMED:
            default:
                throw new OrmException(String.format("Unstar change %d for account %d failed: %s", changeId.get(), accountId.get(), result.name()));
        }
    } catch (IOException e) {
        throw new OrmException(String.format("Unstar change %d for account %d failed", changeId.get(), accountId.get()), e);
    }
}
#method_after
public void unstar(Account.Id accountId, Project.NameKey project, Change.Id changeId) throws OrmException, IOException {
    dbProvider.get().starredChanges().delete(Collections.singleton(new StarredChange(new StarredChange.Key(accountId, changeId))));
    if (!migration.writeAccounts()) {
        indexer.index(dbProvider.get(), project, changeId);
        return;
    }
    try (Repository repo = repoManager.openRepository(allUsers);
        RevWalk rw = new RevWalk(repo)) {
        RefUpdate u = repo.updateRef(RefNames.refsStarredChanges(changeId, accountId));
        u.setForceUpdate(true);
        u.setRefLogIdent(serverIdent);
        u.setRefLogMessage("Unstar change " + changeId.get(), true);
        RefUpdate.Result result = u.delete();
        switch(result) {
            case FORCED:
                indexer.index(dbProvider.get(), project, changeId);
                return;
            case FAST_FORWARD:
            case IO_FAILURE:
            case LOCK_FAILURE:
            case NEW:
            case NOT_ATTEMPTED:
            case NO_CHANGE:
            case REJECTED:
            case REJECTED_CURRENT_BRANCH:
            case RENAMED:
            default:
                throw new OrmException(String.format("Unstar change %d for account %d failed: %s", changeId.get(), accountId.get(), result.name()));
        }
    } catch (IOException e) {
        throw new OrmException(String.format("Unstar change %d for account %d failed", changeId.get(), accountId.get()), e);
    }
}
#end_block

#method_before
public void unstarAll(Project.NameKey project, Change.Id changeId) throws OrmException, IOException, NoSuchChangeException {
    dbProvider.get().starredChanges().delete(dbProvider.get().starredChanges().byChange(changeId));
    if (!migration.writeAccounts()) {
        indexer.index(dbProvider.get(), project, changeId);
        return;
    }
    try (Repository repo = repoManager.openRepository(allUsers);
        RevWalk rw = new RevWalk(repo)) {
        BatchRefUpdate batchUpdate = repo.getRefDatabase().newBatchUpdate();
        batchUpdate.setAllowNonFastForwards(true);
        batchUpdate.setRefLogIdent(serverIdent);
        batchUpdate.setRefLogMessage("Unstar change " + changeId.get(), true);
        for (Account.Id accountId : byChangeFromIndex(changeId)) {
            String refName = RefNames.refsStarredChanges(accountId, changeId);
            Ref ref = repo.getRefDatabase().getRef(refName);
            batchUpdate.addCommand(new ReceiveCommand(ref.getObjectId(), ObjectId.zeroId(), refName));
        }
        batchUpdate.execute(rw, NullProgressMonitor.INSTANCE);
        for (ReceiveCommand command : batchUpdate.getCommands()) {
            if (command.getResult() != ReceiveCommand.Result.OK) {
                throw new IOException(String.format("Unstar change %d failed, ref %s could not be deleted: %s", changeId.get(), command.getRefName(), command.getResult()));
            }
        }
        indexer.index(dbProvider.get(), project, changeId);
    } catch (IOException e) {
        throw new OrmException(String.format("Unstar change %d failed", changeId.get()), e);
    }
}
#method_after
public void unstarAll(Project.NameKey project, Change.Id changeId) throws OrmException, IOException, NoSuchChangeException {
    dbProvider.get().starredChanges().delete(dbProvider.get().starredChanges().byChange(changeId));
    if (!migration.writeAccounts()) {
        indexer.index(dbProvider.get(), project, changeId);
        return;
    }
    try (Repository repo = repoManager.openRepository(allUsers);
        RevWalk rw = new RevWalk(repo)) {
        BatchRefUpdate batchUpdate = repo.getRefDatabase().newBatchUpdate();
        batchUpdate.setAllowNonFastForwards(true);
        batchUpdate.setRefLogIdent(serverIdent);
        batchUpdate.setRefLogMessage("Unstar change " + changeId.get(), true);
        for (Account.Id accountId : byChangeFromIndex(changeId)) {
            String refName = RefNames.refsStarredChanges(changeId, accountId);
            Ref ref = repo.getRefDatabase().getRef(refName);
            batchUpdate.addCommand(new ReceiveCommand(ref.getObjectId(), ObjectId.zeroId(), refName));
        }
        batchUpdate.execute(rw, NullProgressMonitor.INSTANCE);
        for (ReceiveCommand command : batchUpdate.getCommands()) {
            if (command.getResult() != ReceiveCommand.Result.OK) {
                throw new IOException(String.format("Unstar change %d failed, ref %s could not be deleted: %s", changeId.get(), command.getRefName(), command.getResult()));
            }
        }
        indexer.index(dbProvider.get(), project, changeId);
    } catch (IOException e) {
        throw new OrmException(String.format("Unstar change %d failed", changeId.get()), e);
    }
}
#end_block

#method_before
public Iterable<Account.Id> byChange(final Change.Id changeId) throws OrmException {
    if (!migration.readAccounts()) {
        return FluentIterable.from(dbProvider.get().starredChanges().byChange(changeId)).transform(new Function<StarredChange, Account.Id>() {

            @Override
            public Account.Id apply(StarredChange in) {
                return in.getAccountId();
            }
        });
    }
    return FluentIterable.from(getRefNames(RefNames.REFS_STARRED_CHANGES)).filter(new Predicate<String>() {

        @Override
        public boolean apply(String refPart) {
            return refPart.endsWith("/" + changeId.get());
        }
    }).transform(new Function<String, Account.Id>() {

        @Override
        public Account.Id apply(String refPart) {
            return Account.Id.fromRefPart(refPart);
        }
    });
}
#method_after
public Set<Account.Id> byChange(Change.Id changeId) throws OrmException {
    if (!migration.readAccounts()) {
        return FluentIterable.from(dbProvider.get().starredChanges().byChange(changeId)).transform(new Function<StarredChange, Account.Id>() {

            @Override
            public Account.Id apply(StarredChange in) {
                return in.getAccountId();
            }
        }).toSet();
    }
    return FluentIterable.from(getRefNames(RefNames.refsStarredChangesPrefix(changeId))).transform(new Function<String, Account.Id>() {

        @Override
        public Account.Id apply(String refPart) {
            return Account.Id.parse(refPart);
        }
    }).toSet();
}
#end_block

#method_before
public Iterable<Account.Id> byChangeFromIndex(Change.Id changeId) throws OrmException, NoSuchChangeException {
    Set<String> fields = ImmutableSet.of(ChangeField.ID.getName(), ChangeField.STARREDBY.getName());
    List<ChangeData> changeData = queryProvider.get().setRequestedFields(fields).byLegacyChangeId(changeId);
    if (changeData.size() != 1) {
        throw new NoSuchChangeException(changeId);
    }
    return changeData.get(0).starredBy();
}
#method_after
public Set<Account.Id> byChangeFromIndex(Change.Id changeId) throws OrmException, NoSuchChangeException {
    Set<String> fields = ImmutableSet.of(ChangeField.ID.getName(), ChangeField.STARREDBY.getName());
    List<ChangeData> changeData = queryProvider.get().setRequestedFields(fields).byLegacyChangeId(changeId);
    if (changeData.size() != 1) {
        throw new NoSuchChangeException(changeId);
    }
    return changeData.get(0).starredBy();
}
#end_block

#method_before
private static TreeSet<String> readLabels(Repository repo, ObjectId id) throws IOException {
    if (ObjectId.zeroId().equals(id)) {
        return new TreeSet<>();
    }
    try (ObjectReader reader = repo.newObjectReader()) {
        ObjectLoader obj = reader.open(id, Constants.OBJ_BLOB);
        TreeSet<String> labels = new TreeSet<>();
        Collections.addAll(labels, new String(obj.getCachedBytes(Integer.MAX_VALUE), UTF_8).split("\n"));
        return labels;
    }
}
#method_after
private static TreeSet<String> readLabels(Repository repo, ObjectId id) throws IOException {
    if (ObjectId.zeroId().equals(id)) {
        return new TreeSet<>();
    }
    try (ObjectReader reader = repo.newObjectReader()) {
        ObjectLoader obj = reader.open(id, Constants.OBJ_BLOB);
        TreeSet<String> labels = new TreeSet<>();
        Iterables.addAll(labels, Splitter.on(CharMatcher.whitespace()).omitEmptyStrings().split(new String(obj.getCachedBytes(Integer.MAX_VALUE), UTF_8)));
        return labels;
    }
}
#end_block

#method_before
public static ObjectId writeLabels(Repository repo, SortedSet<String> labels) throws IOException {
    try (ObjectInserter oi = repo.newObjectInserter()) {
        ObjectId id = oi.insert(Constants.OBJ_BLOB, Joiner.on("\n").join(labels).getBytes(UTF_8));
        oi.flush();
        return id;
    }
}
#method_after
public static ObjectId writeLabels(Repository repo, SortedSet<String> labels) throws IOException {
    SortedSet<String> invalidLabels = validateLabels(labels);
    if (!invalidLabels.isEmpty()) {
        throw new IllegalArgumentException(String.format("Invalid star labels: %s", Joiner.on(", ").join(labels)));
    }
    try (ObjectInserter oi = repo.newObjectInserter()) {
        ObjectId id = oi.insert(Constants.OBJ_BLOB, Joiner.on("\n").join(labels).getBytes(UTF_8));
        oi.flush();
        return id;
    }
}
#end_block

#method_before
private void updateLabels(Repository repo, String refName, ObjectId oldObjectId, SortedSet<String> labels) throws IOException, OrmException {
    try (RevWalk rw = new RevWalk(repo)) {
        RefUpdate u = repo.updateRef(refName);
        u.setExpectedOldObjectId(oldObjectId);
        u.setForceUpdate(true);
        u.setNewObjectId(writeLabels(repo, labels));
        u.setRefLogIdent(serverIdent);
        u.setRefLogMessage("Update star labels", true);
        RefUpdate.Result result = u.update(rw);
        switch(result) {
            case NEW:
            case FORCED:
            case NO_CHANGE:
            case FAST_FORWARD:
                return;
            case IO_FAILURE:
            case LOCK_FAILURE:
            case NOT_ATTEMPTED:
            case REJECTED:
            case REJECTED_CURRENT_BRANCH:
            case RENAMED:
            default:
                throw new OrmException(String.format("Update star labels on ref %s failed: %s", refName, result.name()));
        }
    }
}
#method_after
private void updateLabels(Repository repo, String refName, ObjectId oldObjectId, SortedSet<String> labels) throws IOException, OrmException {
    try (RevWalk rw = new RevWalk(repo)) {
        RefUpdate u = repo.updateRef(refName);
        u.setExpectedOldObjectId(oldObjectId);
        u.setForceUpdate(true);
        u.setNewObjectId(writeLabels(repo, labels));
        u.setRefLogIdent(serverIdent);
        u.setRefLogMessage("Update star labels", true);
        RefUpdate.Result result = u.update(rw);
        switch(result) {
            case NEW:
            case FORCED:
            case NO_CHANGE:
            case FAST_FORWARD:
                return;
            case IO_FAILURE:
            case LOCK_FAILURE:
            case NOT_ATTEMPTED:
            case REJECTED:
            case REJECTED_CURRENT_BRANCH:
            case RENAMED:
                throw new OrmException(String.format("Update star labels on ref %s failed: %s", refName, result.name()));
        }
    }
}
#end_block

#method_before
private boolean insertComments(ChangeContext ctx) throws OrmException {
    Map<String, List<CommentInput>> map = in.comments;
    if (map == null) {
        map = Collections.emptyMap();
    }
    Map<String, PatchLineComment> drafts = Collections.emptyMap();
    if (!map.isEmpty() || in.drafts != DraftHandling.KEEP) {
        if (in.drafts == DraftHandling.PUBLISH_ALL_REVISIONS) {
            drafts = changeDrafts(ctx);
        } else {
            drafts = patchSetDrafts(ctx);
        }
    }
    List<PatchLineComment> del = Lists.newArrayList();
    List<PatchLineComment> ups = Lists.newArrayList();
    Set<CommentSetEntry> existingIds = in.omitDuplicateComments ? readExistingComments(ctx) : Collections.<CommentSetEntry>emptySet();
    for (Map.Entry<String, List<CommentInput>> ent : map.entrySet()) {
        String path = ent.getKey();
        for (CommentInput c : ent.getValue()) {
            String parent = Url.decode(c.inReplyTo);
            PatchLineComment e = drafts.remove(Url.decode(c.id));
            if (e == null) {
                e = new PatchLineComment(new PatchLineComment.Key(new Patch.Key(psId, path), null), c.line != null ? c.line : 0, user.getAccountId(), parent, ctx.getWhen());
            } else if (parent != null) {
                e.setParentUuid(parent);
            }
            e.setStatus(PatchLineComment.Status.PUBLISHED);
            e.setWrittenOn(ctx.getWhen());
            e.setSide(c.side == Side.PARENT ? (short) 0 : (short) 1);
            setCommentRevId(e, patchListCache, ctx.getChange(), ps);
            e.setMessage(c.message);
            if (c.range != null) {
                e.setRange(new CommentRange(c.range.startLine, c.range.startCharacter, c.range.endLine, c.range.endCharacter));
                e.setLine(c.range.endLine);
            }
            if (existingIds.contains(CommentSetEntry.create(e))) {
                continue;
            }
            if (e.getKey().get() == null) {
                e.getKey().set(ChangeUtil.messageUUID(ctx.getDb()));
            }
            ups.add(e);
        }
    }
    switch(firstNonNull(in.drafts, DraftHandling.DELETE)) {
        case KEEP:
        default:
            break;
        case DELETE:
            del.addAll(drafts.values());
            break;
        case PUBLISH:
        case PUBLISH_ALL_REVISIONS:
            for (PatchLineComment e : drafts.values()) {
                e.setStatus(PatchLineComment.Status.PUBLISHED);
                e.setWrittenOn(ctx.getWhen());
                setCommentRevId(e, patchListCache, ctx.getChange(), ps);
                ups.add(e);
            }
            break;
    }
    ChangeUpdate u = ctx.getUpdate(psId);
    // TODO(dborowitz): Currently doesn't work for PUBLISH_ALL_REVISIONS with
    // notedb.
    plcUtil.deleteComments(ctx.getDb(), u, del);
    plcUtil.putComments(ctx.getDb(), u, ups);
    comments.addAll(ups);
    return !del.isEmpty() || !ups.isEmpty();
}
#method_after
private boolean insertComments(ChangeContext ctx) throws OrmException {
    Map<String, List<CommentInput>> map = in.comments;
    if (map == null) {
        map = Collections.emptyMap();
    }
    Map<String, PatchLineComment> drafts = Collections.emptyMap();
    if (!map.isEmpty() || in.drafts != DraftHandling.KEEP) {
        if (in.drafts == DraftHandling.PUBLISH_ALL_REVISIONS) {
            drafts = changeDrafts(ctx);
        } else {
            drafts = patchSetDrafts(ctx);
        }
    }
    List<PatchLineComment> del = Lists.newArrayList();
    List<PatchLineComment> ups = Lists.newArrayList();
    Set<CommentSetEntry> existingIds = in.omitDuplicateComments ? readExistingComments(ctx) : Collections.<CommentSetEntry>emptySet();
    for (Map.Entry<String, List<CommentInput>> ent : map.entrySet()) {
        String path = ent.getKey();
        for (CommentInput c : ent.getValue()) {
            String parent = Url.decode(c.inReplyTo);
            PatchLineComment e = drafts.remove(Url.decode(c.id));
            if (e == null) {
                e = new PatchLineComment(new PatchLineComment.Key(new Patch.Key(psId, path), null), c.line != null ? c.line : 0, user.getAccountId(), parent, ctx.getWhen());
            } else if (parent != null) {
                e.setParentUuid(parent);
            }
            e.setStatus(PatchLineComment.Status.PUBLISHED);
            e.setWrittenOn(ctx.getWhen());
            e.setSide(c.side == Side.PARENT ? (short) 0 : (short) 1);
            setCommentRevId(e, patchListCache, ctx.getChange(), ps);
            e.setMessage(c.message);
            e.setTag(in.tag);
            if (c.range != null) {
                e.setRange(new CommentRange(c.range.startLine, c.range.startCharacter, c.range.endLine, c.range.endCharacter));
                e.setLine(c.range.endLine);
            }
            if (existingIds.contains(CommentSetEntry.create(e))) {
                continue;
            }
            if (e.getKey().get() == null) {
                e.getKey().set(ChangeUtil.messageUUID(ctx.getDb()));
            }
            ups.add(e);
        }
    }
    switch(firstNonNull(in.drafts, DraftHandling.DELETE)) {
        case KEEP:
        default:
            break;
        case DELETE:
            del.addAll(drafts.values());
            break;
        case PUBLISH:
            for (PatchLineComment e : drafts.values()) {
                ups.add(publishComment(ctx, e, ps));
            }
            break;
        case PUBLISH_ALL_REVISIONS:
            publishAllRevisions(ctx, drafts, ups);
            break;
    }
    ChangeUpdate u = ctx.getUpdate(psId);
    plcUtil.deleteComments(ctx.getDb(), u, del);
    plcUtil.putComments(ctx.getDb(), u, ups);
    comments.addAll(ups);
    return !del.isEmpty() || !ups.isEmpty();
}
#end_block

#method_before
private Map<String, PatchLineComment> changeDrafts(ChangeContext ctx) throws OrmException {
    Map<String, PatchLineComment> drafts = Maps.newHashMap();
    for (PatchLineComment c : plcUtil.draftByChangeAuthor(ctx.getDb(), ctx.getNotes(), user.getAccountId())) {
        drafts.put(c.getKey().get(), c);
    }
    return drafts;
}
#method_after
private Map<String, PatchLineComment> changeDrafts(ChangeContext ctx) throws OrmException {
    Map<String, PatchLineComment> drafts = Maps.newHashMap();
    for (PatchLineComment c : plcUtil.draftByChangeAuthor(ctx.getDb(), ctx.getNotes(), user.getAccountId())) {
        c.setTag(in.tag);
        drafts.put(c.getKey().get(), c);
    }
    return drafts;
}
#end_block

#method_before
private boolean updateLabels(ChangeContext ctx) throws OrmException, ResourceConflictException {
    Map<String, Short> inLabels = MoreObjects.firstNonNull(in.labels, Collections.<String, Short>emptyMap());
    List<PatchSetApproval> del = Lists.newArrayList();
    List<PatchSetApproval> ups = Lists.newArrayList();
    Map<String, PatchSetApproval> current = scanLabels(ctx, del);
    LabelTypes labelTypes = ctx.getControl().getLabelTypes();
    Map<String, Short> allApprovals = getAllApprovals(labelTypes, approvalsByKey(current.values()), inLabels);
    Map<String, Short> previous = getPreviousApprovals(allApprovals, approvalsByKey(current.values()));
    ChangeUpdate update = ctx.getUpdate(psId);
    for (Map.Entry<String, Short> ent : allApprovals.entrySet()) {
        String name = ent.getKey();
        LabelType lt = checkNotNull(labelTypes.byLabel(name), name);
        PatchSetApproval c = current.remove(lt.getName());
        String normName = lt.getName();
        approvals.put(normName, (short) 0);
        if (ent.getValue() == null || ent.getValue() == 0) {
            // User requested delete of this label.
            oldApprovals.put(normName, null);
            if (c != null) {
                if (c.getValue() != 0) {
                    addLabelDelta(normName, (short) 0);
                    oldApprovals.put(normName, previous.get(normName));
                }
                del.add(c);
                update.putApproval(normName, (short) 0);
            }
        } else if (c != null && c.getValue() != ent.getValue()) {
            c.setValue(ent.getValue());
            c.setGranted(ctx.getWhen());
            ups.add(c);
            addLabelDelta(normName, c.getValue());
            oldApprovals.put(normName, previous.get(normName));
            approvals.put(normName, c.getValue());
            update.putApproval(normName, ent.getValue());
        } else if (c != null && c.getValue() == ent.getValue()) {
            current.put(normName, c);
            oldApprovals.put(normName, null);
            approvals.put(normName, c.getValue());
        } else if (c == null) {
            c = new PatchSetApproval(new PatchSetApproval.Key(psId, user.getAccountId(), lt.getLabelId()), ent.getValue(), ctx.getWhen());
            c.setGranted(ctx.getWhen());
            ups.add(c);
            addLabelDelta(normName, c.getValue());
            oldApprovals.put(normName, previous.get(normName));
            approvals.put(normName, c.getValue());
            update.putReviewer(user.getAccountId(), REVIEWER);
            update.putApproval(normName, ent.getValue());
        }
    }
    if (!del.isEmpty() || !ups.isEmpty()) {
        if (ctx.getChange().getStatus().isClosed()) {
            throw new ResourceConflictException("change is closed");
        }
    }
    forceCallerAsReviewer(ctx, current, ups, del);
    ctx.getDb().patchSetApprovals().delete(del);
    ctx.getDb().patchSetApprovals().upsert(ups);
    return !del.isEmpty() || !ups.isEmpty();
}
#method_after
private boolean updateLabels(ChangeContext ctx) throws OrmException, ResourceConflictException {
    Map<String, Short> inLabels = MoreObjects.firstNonNull(in.labels, Collections.<String, Short>emptyMap());
    // losing access to a label after the change was submitted.
    if (inLabels.isEmpty() && ctx.getChange().getStatus().isClosed()) {
        return false;
    }
    List<PatchSetApproval> del = Lists.newArrayList();
    List<PatchSetApproval> ups = Lists.newArrayList();
    Map<String, PatchSetApproval> current = scanLabels(ctx, del);
    LabelTypes labelTypes = ctx.getControl().getLabelTypes();
    Map<String, Short> allApprovals = getAllApprovals(labelTypes, approvalsByKey(current.values()), inLabels);
    Map<String, Short> previous = getPreviousApprovals(allApprovals, approvalsByKey(current.values()));
    ChangeUpdate update = ctx.getUpdate(psId);
    for (Map.Entry<String, Short> ent : allApprovals.entrySet()) {
        String name = ent.getKey();
        LabelType lt = checkNotNull(labelTypes.byLabel(name), name);
        PatchSetApproval c = current.remove(lt.getName());
        String normName = lt.getName();
        approvals.put(normName, (short) 0);
        if (ent.getValue() == null || ent.getValue() == 0) {
            // User requested delete of this label.
            oldApprovals.put(normName, null);
            if (c != null) {
                if (c.getValue() != 0) {
                    addLabelDelta(normName, (short) 0);
                    oldApprovals.put(normName, previous.get(normName));
                }
                del.add(c);
                update.putApproval(normName, (short) 0);
            }
        } else if (c != null && c.getValue() != ent.getValue()) {
            c.setValue(ent.getValue());
            c.setGranted(ctx.getWhen());
            c.setTag(in.tag);
            ups.add(c);
            addLabelDelta(normName, c.getValue());
            oldApprovals.put(normName, previous.get(normName));
            approvals.put(normName, c.getValue());
            update.putApproval(normName, ent.getValue());
        } else if (c != null && c.getValue() == ent.getValue()) {
            current.put(normName, c);
            oldApprovals.put(normName, null);
            approvals.put(normName, c.getValue());
        } else if (c == null) {
            c = new PatchSetApproval(new PatchSetApproval.Key(psId, user.getAccountId(), lt.getLabelId()), ent.getValue(), ctx.getWhen());
            c.setTag(in.tag);
            c.setGranted(ctx.getWhen());
            ups.add(c);
            addLabelDelta(normName, c.getValue());
            oldApprovals.put(normName, previous.get(normName));
            approvals.put(normName, c.getValue());
            update.putReviewer(user.getAccountId(), REVIEWER);
            update.putApproval(normName, ent.getValue());
        }
    }
    if ((!del.isEmpty() || !ups.isEmpty()) && ctx.getChange().getStatus().isClosed()) {
        throw new ResourceConflictException("change is closed");
    }
    forceCallerAsReviewer(ctx, current, ups, del);
    ctx.getDb().patchSetApprovals().delete(del);
    ctx.getDb().patchSetApprovals().upsert(ups);
    return !del.isEmpty() || !ups.isEmpty();
}
#end_block

#method_before
private void forceCallerAsReviewer(ChangeContext ctx, Map<String, PatchSetApproval> current, List<PatchSetApproval> ups, List<PatchSetApproval> del) {
    if (current.isEmpty() && ups.isEmpty()) {
        // TODO Find another way to link reviewers to changes.
        if (del.isEmpty()) {
            // If no existing label is being set to 0, hack in the caller
            // as a reviewer by picking the first server-wide LabelType.
            PatchSetApproval c = new PatchSetApproval(new PatchSetApproval.Key(psId, user.getAccountId(), ctx.getControl().getLabelTypes().getLabelTypes().get(0).getLabelId()), (short) 0, ctx.getWhen());
            c.setGranted(ctx.getWhen());
            ups.add(c);
        } else {
            // Pick a random label that is about to be deleted and keep it.
            Iterator<PatchSetApproval> i = del.iterator();
            PatchSetApproval c = i.next();
            c.setValue((short) 0);
            c.setGranted(ctx.getWhen());
            i.remove();
            ups.add(c);
        }
    }
    ctx.getUpdate(ctx.getChange().currentPatchSetId()).putReviewer(user.getAccountId(), REVIEWER);
}
#method_after
private void forceCallerAsReviewer(ChangeContext ctx, Map<String, PatchSetApproval> current, List<PatchSetApproval> ups, List<PatchSetApproval> del) {
    if (current.isEmpty() && ups.isEmpty()) {
        // TODO Find another way to link reviewers to changes.
        if (del.isEmpty()) {
            // If no existing label is being set to 0, hack in the caller
            // as a reviewer by picking the first server-wide LabelType.
            PatchSetApproval c = new PatchSetApproval(new PatchSetApproval.Key(psId, user.getAccountId(), ctx.getControl().getLabelTypes().getLabelTypes().get(0).getLabelId()), (short) 0, ctx.getWhen());
            c.setTag(in.tag);
            c.setGranted(ctx.getWhen());
            ups.add(c);
        } else {
            // Pick a random label that is about to be deleted and keep it.
            Iterator<PatchSetApproval> i = del.iterator();
            PatchSetApproval c = i.next();
            c.setValue((short) 0);
            c.setGranted(ctx.getWhen());
            i.remove();
            ups.add(c);
        }
    }
    ctx.getUpdate(ctx.getChange().currentPatchSetId()).putReviewer(user.getAccountId(), REVIEWER);
}
#end_block

#method_before
private boolean insertMessage(ChangeContext ctx) throws OrmException {
    String msg = Strings.nullToEmpty(in.message).trim();
    StringBuilder buf = new StringBuilder();
    for (String d : labelDelta) {
        buf.append(" ").append(d);
    }
    if (comments.size() == 1) {
        buf.append("\n\n(1 comment)");
    } else if (comments.size() > 1) {
        buf.append(String.format("\n\n(%d comments)", comments.size()));
    }
    if (!msg.isEmpty()) {
        buf.append("\n\n").append(msg);
    }
    if (buf.length() == 0) {
        return false;
    }
    message = new ChangeMessage(new ChangeMessage.Key(psId.getParentKey(), ChangeUtil.messageUUID(ctx.getDb())), user.getAccountId(), ctx.getWhen(), psId);
    message.setMessage(String.format("Patch Set %d:%s", psId.get(), buf.toString()));
    cmUtil.addChangeMessage(ctx.getDb(), ctx.getUpdate(psId), message);
    return true;
}
#method_after
private boolean insertMessage(ChangeContext ctx) throws OrmException {
    String msg = Strings.nullToEmpty(in.message).trim();
    StringBuilder buf = new StringBuilder();
    for (String d : labelDelta) {
        buf.append(" ").append(d);
    }
    if (comments.size() == 1) {
        buf.append("\n\n(1 comment)");
    } else if (comments.size() > 1) {
        buf.append(String.format("\n\n(%d comments)", comments.size()));
    }
    if (!msg.isEmpty()) {
        buf.append("\n\n").append(msg);
    }
    if (buf.length() == 0) {
        return false;
    }
    message = new ChangeMessage(new ChangeMessage.Key(psId.getParentKey(), ChangeUtil.messageUUID(ctx.getDb())), user.getAccountId(), ctx.getWhen(), psId);
    message.setTag(in.tag);
    message.setMessage(String.format("Patch Set %d:%s", psId.get(), buf.toString()));
    cmUtil.addChangeMessage(ctx.getDb(), ctx.getUpdate(psId), message);
    return true;
}
#end_block

#method_before
private ApprovalAttribute getApprovalAttribute(String label) {
    ApprovalAttribute[] aa = lastCommentAddedEvent.approvals.get();
    ApprovalAttribute res = null;
    for (int i = 0; i < aa.length; i++) {
        if (aa[i].description.equals(label)) {
            res = aa[i];
        }
    }
    return res;
}
#method_after
private ApprovalAttribute getApprovalAttribute(LabelType label) {
    ApprovalAttribute[] aa = lastCommentAddedEvent.approvals.get();
    ApprovalAttribute res = null;
    for (int i = 0; i < aa.length; i++) {
        if (aa[i].description.equals(label.getName())) {
            res = aa[i];
        }
    }
    return res;
}
#end_block

#method_before
@Test
public void newChangeWithVote() throws Exception {
    saveLabelConfig();
    // push a new change with -1 vote
    PushOneCommit.Result r = createChange();
    ReviewInput reviewInput = new ReviewInput().label(label.getName(), (short) -1);
    revision(r).review(reviewInput);
    ApprovalAttribute attr = getApprovalAttribute(label.getName());
    String newVote = attr.value;
    String oldVote = attr.oldValue;
    assertThat(oldVote).isEqualTo("0");
    assertThat(newVote).isEqualTo("-1");
    assertThat(lastCommentAddedEvent.comment).isEqualTo(String.format("Patch Set 1: %s-1", label.getName()));
}
#method_after
@Test
public void newChangeWithVote() throws Exception {
    saveLabelConfig();
    // push a new change with -1 vote
    PushOneCommit.Result r = createChange();
    ReviewInput reviewInput = new ReviewInput().label(label.getName(), (short) -1);
    revision(r).review(reviewInput);
    ApprovalAttribute attr = getApprovalAttribute(label);
    assertThat(attr.oldValue).isEqualTo("0");
    assertThat(attr.value).isEqualTo("-1");
    assertThat(lastCommentAddedEvent.comment).isEqualTo(String.format("Patch Set 1: %s-1", label.getName()));
}
#end_block

#method_before
@Test
public void newPatchSetWithVote() throws Exception {
    saveLabelConfig();
    // push a new change
    PushOneCommit.Result r = createChange();
    ReviewInput reviewInput = new ReviewInput().message(label.getName());
    revision(r).review(reviewInput);
    // push a new revision with +1 vote
    ChangeInfo c = get(r.getChangeId());
    r = amendChange(c.changeId);
    reviewInput = new ReviewInput().label(label.getName(), (short) 1);
    revision(r).review(reviewInput);
    ApprovalAttribute attr = getApprovalAttribute(label.getName());
    String newVote = attr.value;
    String oldVote = attr.oldValue;
    assertThat(oldVote).isEqualTo("0");
    assertThat(newVote).isEqualTo("1");
    assertThat(lastCommentAddedEvent.comment).isEqualTo(String.format("Patch Set 2: %s+1", label.getName()));
}
#method_after
@Test
public void newPatchSetWithVote() throws Exception {
    saveLabelConfig();
    // push a new change
    PushOneCommit.Result r = createChange();
    ReviewInput reviewInput = new ReviewInput().message(label.getName());
    revision(r).review(reviewInput);
    // push a new revision with +1 vote
    ChangeInfo c = get(r.getChangeId());
    r = amendChange(c.changeId);
    reviewInput = new ReviewInput().label(label.getName(), (short) 1);
    revision(r).review(reviewInput);
    ApprovalAttribute attr = getApprovalAttribute(label);
    assertThat(attr.oldValue).isEqualTo("0");
    assertThat(attr.value).isEqualTo("1");
    assertThat(lastCommentAddedEvent.comment).isEqualTo(String.format("Patch Set 2: %s+1", label.getName()));
}
#end_block

#method_before
@Test
public void reviewChange() throws Exception {
    saveLabelConfig();
    // push a change
    PushOneCommit.Result r = createChange();
    // review with message only, do not apply votes
    ReviewInput reviewInput = new ReviewInput().message(label.getName());
    revision(r).review(reviewInput);
    // reply message only so votes is shown as 0
    ApprovalAttribute attr = getApprovalAttribute(label.getName());
    String newVote = attr.value;
    String oldVote = attr.oldValue;
    assertThat(oldVote).isNull();
    assertThat(newVote).isEqualTo("0");
    assertThat(lastCommentAddedEvent.comment).isEqualTo(String.format("Patch Set 1:\n\n%s", label.getName()));
    // transition from un-voted to -1 vote
    reviewInput = new ReviewInput().label(label.getName(), -1);
    revision(r).review(reviewInput);
    attr = getApprovalAttribute(label.getName());
    newVote = attr.value;
    oldVote = attr.oldValue;
    assertThat(oldVote).isEqualTo("0");
    assertThat(newVote).isEqualTo("-1");
    assertThat(lastCommentAddedEvent.comment).isEqualTo(String.format("Patch Set 1: %s-1", label.getName()));
    // transition vote from -1 to 0
    reviewInput = new ReviewInput().label(label.getName(), 0);
    revision(r).review(reviewInput);
    attr = getApprovalAttribute(label.getName());
    newVote = attr.value;
    oldVote = attr.oldValue;
    assertThat(oldVote).isEqualTo("-1");
    assertThat(newVote).isEqualTo("0");
    assertThat(lastCommentAddedEvent.comment).isEqualTo(String.format("Patch Set 1: -%s", label.getName()));
    // transition vote from 0 to 1
    reviewInput = new ReviewInput().label(label.getName(), 1);
    revision(r).review(reviewInput);
    attr = getApprovalAttribute(label.getName());
    newVote = attr.value;
    oldVote = attr.oldValue;
    assertThat(oldVote).isEqualTo("0");
    assertThat(newVote).isEqualTo("1");
    assertThat(lastCommentAddedEvent.comment).isEqualTo(String.format("Patch Set 1: %s+1", label.getName()));
    // transition vote from 1 to -1
    reviewInput = new ReviewInput().label(label.getName(), -1);
    revision(r).review(reviewInput);
    attr = getApprovalAttribute(label.getName());
    newVote = attr.value;
    oldVote = attr.oldValue;
    assertThat(oldVote).isEqualTo("1");
    assertThat(newVote).isEqualTo("-1");
    assertThat(lastCommentAddedEvent.comment).isEqualTo(String.format("Patch Set 1: %s-1", label.getName()));
    // review with message only, do not apply votes
    reviewInput = new ReviewInput().message(label.getName());
    revision(r).review(reviewInput);
    attr = getApprovalAttribute(label.getName());
    newVote = attr.value;
    oldVote = attr.oldValue;
    // no vote change so not included
    assertThat(oldVote).isEqualTo(null);
    assertThat(newVote).isEqualTo("-1");
    assertThat(lastCommentAddedEvent.comment).isEqualTo(String.format("Patch Set 1:\n\n%s", label.getName()));
}
#method_after
@Test
public void reviewChange() throws Exception {
    saveLabelConfig();
    // push a change
    PushOneCommit.Result r = createChange();
    // review with message only, do not apply votes
    ReviewInput reviewInput = new ReviewInput().message(label.getName());
    revision(r).review(reviewInput);
    // reply message only so vote is shown as 0
    ApprovalAttribute attr = getApprovalAttribute(label);
    assertThat(attr.oldValue).isNull();
    assertThat(attr.value).isEqualTo("0");
    assertThat(lastCommentAddedEvent.comment).isEqualTo(String.format("Patch Set 1:\n\n%s", label.getName()));
    // transition from un-voted to -1 vote
    reviewInput = new ReviewInput().label(label.getName(), -1);
    revision(r).review(reviewInput);
    attr = getApprovalAttribute(label);
    assertThat(attr.oldValue).isEqualTo("0");
    assertThat(attr.value).isEqualTo("-1");
    assertThat(lastCommentAddedEvent.comment).isEqualTo(String.format("Patch Set 1: %s-1", label.getName()));
    // transition vote from -1 to 0
    reviewInput = new ReviewInput().label(label.getName(), 0);
    revision(r).review(reviewInput);
    attr = getApprovalAttribute(label);
    assertThat(attr.oldValue).isEqualTo("-1");
    assertThat(attr.value).isEqualTo("0");
    assertThat(lastCommentAddedEvent.comment).isEqualTo(String.format("Patch Set 1: -%s", label.getName()));
    // transition vote from 0 to 1
    reviewInput = new ReviewInput().label(label.getName(), 1);
    revision(r).review(reviewInput);
    attr = getApprovalAttribute(label);
    assertThat(attr.oldValue).isEqualTo("0");
    assertThat(attr.value).isEqualTo("1");
    assertThat(lastCommentAddedEvent.comment).isEqualTo(String.format("Patch Set 1: %s+1", label.getName()));
    // transition vote from 1 to -1
    reviewInput = new ReviewInput().label(label.getName(), -1);
    revision(r).review(reviewInput);
    attr = getApprovalAttribute(label);
    assertThat(attr.oldValue).isEqualTo("1");
    assertThat(attr.value).isEqualTo("-1");
    assertThat(lastCommentAddedEvent.comment).isEqualTo(String.format("Patch Set 1: %s-1", label.getName()));
    // review with message only, do not apply votes
    reviewInput = new ReviewInput().message(label.getName());
    revision(r).review(reviewInput);
    attr = getApprovalAttribute(label);
    // no vote change so not included
    assertThat(attr.oldValue).isEqualTo(null);
    assertThat(attr.value).isEqualTo("-1");
    assertThat(lastCommentAddedEvent.comment).isEqualTo(String.format("Patch Set 1:\n\n%s", label.getName()));
}
#end_block

#method_before
@Test
public void reviewChange_MultipleVotes() throws Exception {
    saveLabelConfig();
    PushOneCommit.Result r = createChange();
    ReviewInput reviewInput = new ReviewInput().label(label.getName(), -1);
    reviewInput.message = label.getName();
    revision(r).review(reviewInput);
    ChangeInfo c = get(r.getChangeId());
    LabelInfo q = c.labels.get(label.getName());
    assertThat(q.all).hasSize(1);
    assertThat(lastCommentAddedEvent.comment).isEqualTo(String.format("Patch Set 1: %s-1\n\n%s", label.getName(), label.getName()));
    reviewInput = new ReviewInput().label(pLabel.getName(), 1);
    reviewInput.message = pLabel.getName();
    revision(r).review(reviewInput);
    c = get(r.getChangeId());
    q = c.labels.get(label.getName());
    assertThat(q.all).hasSize(1);
    assertThat(lastCommentAddedEvent.comment).isEqualTo(String.format("Patch Set 1: %s+1\n\n%s", pLabel.getName(), pLabel.getName()));
    assertThat(lastCommentAddedEvent.approvals.get()).hasLength(3);
    for (ApprovalAttribute approval : lastCommentAddedEvent.approvals.get()) {
        if (approval.type.equals(label.getName())) {
            assertThat(approval.value).isEqualTo("-1");
            assertThat(approval.oldValue).isNull();
        } else if (approval.type.equals(pLabel.getName())) {
            assertThat(approval.value).isEqualTo("1");
            assertThat(approval.oldValue).isEqualTo("0");
        } else if (approval.type.equals("Code-Review")) {
            assertThat(approval.value).isEqualTo("0");
            assertThat(approval.oldValue).isNull();
        } else {
            fail("Unexpected label: " + approval.type);
        }
    }
}
#method_after
@Test
public void reviewChange_MultipleVotes() throws Exception {
    saveLabelConfig();
    PushOneCommit.Result r = createChange();
    ReviewInput reviewInput = new ReviewInput().label(label.getName(), -1);
    reviewInput.message = label.getName();
    revision(r).review(reviewInput);
    ChangeInfo c = get(r.getChangeId());
    LabelInfo q = c.labels.get(label.getName());
    assertThat(q.all).hasSize(1);
    ApprovalAttribute labelAttr = getApprovalAttribute(label);
    assertThat(labelAttr.oldValue).isEqualTo("0");
    assertThat(labelAttr.value).isEqualTo("-1");
    assertThat(lastCommentAddedEvent.comment).isEqualTo(String.format("Patch Set 1: %s-1\n\n%s", label.getName(), label.getName()));
    // there should be 3 approval labels (label, pLabel, and CRVV)
    assertThat(lastCommentAddedEvent.approvals.get()).hasLength(3);
    // check the approvals that were not voted on
    ApprovalAttribute pLabelAttr = getApprovalAttribute(pLabel);
    assertThat(pLabelAttr.oldValue).isNull();
    assertThat(pLabelAttr.value).isEqualTo("0");
    LabelType crLabel = LabelType.withDefaultValues("Code-Review");
    ApprovalAttribute crlAttr = getApprovalAttribute(crLabel);
    assertThat(crlAttr.oldValue).isNull();
    assertThat(crlAttr.value).isEqualTo("0");
    // update pLabel approval
    reviewInput = new ReviewInput().label(pLabel.getName(), 1);
    reviewInput.message = pLabel.getName();
    revision(r).review(reviewInput);
    c = get(r.getChangeId());
    q = c.labels.get(label.getName());
    assertThat(q.all).hasSize(1);
    pLabelAttr = getApprovalAttribute(pLabel);
    assertThat(pLabelAttr.oldValue).isEqualTo("0");
    assertThat(pLabelAttr.value).isEqualTo("1");
    assertThat(lastCommentAddedEvent.comment).isEqualTo(String.format("Patch Set 1: %s+1\n\n%s", pLabel.getName(), pLabel.getName()));
    // check the approvals that were not voted on
    labelAttr = getApprovalAttribute(label);
    assertThat(labelAttr.oldValue).isNull();
    assertThat(labelAttr.value).isEqualTo("-1");
    crlAttr = getApprovalAttribute(crLabel);
    assertThat(crlAttr.oldValue).isNull();
    assertThat(crlAttr.value).isEqualTo("0");
}
#end_block

#method_before
@Test
public void test() throws Exception {
    String[] invalidFilenamePattern = { "^.*(\\[|\\]|\\*|#).*$", "^.*(%|:|@).*$" };
    RevCommit c = makeCommit();
    List<CommitValidationMessage> m = InvalidFilenameValidator.performValidation(repo, c, invalidFilenamePattern);
    Set<String> expected = new HashSet<>();
    for (String filenames : getInvalidFilenames()) {
        expected.add("ERROR: invalid characters found in filename: " + filenames);
    }
    assertThat(TestUtils.transformMessages(m)).containsExactlyElementsIn(expected);
}
#method_after
@Test
public void test() throws Exception {
    String[] invalidFilenamePattern = { "\\[|\\]|\\*|#", "[%:@]" };
    RevCommit c = makeCommit();
    List<CommitValidationMessage> m = InvalidFilenameValidator.performValidation(repo, c, invalidFilenamePattern);
    Set<String> expected = new HashSet<>();
    for (String filenames : getInvalidFilenames()) {
        expected.add("ERROR: invalid characters found in filename: " + filenames);
    }
    assertThat(TestUtils.transformMessages(m)).containsExactlyElementsIn(expected);
}
#end_block

#method_before
@Override
void render(DiffInfo diff) {
    super.render();
    LineMapper mapper = getLineMapper();
    chunks = new ArrayList<>();
    int cmLine = 0;
    boolean useIntralineBg = diff.metaA() == null || diff.metaB() == null;
    for (Region current : Natives.asList(diff.content())) {
        int origLineA = mapper.getLineA();
        int origLineB = mapper.getLineB();
        if (current.ab() != null) {
            int length = current.ab().length();
            mapper.appendCommon(length);
            for (int i = 0; i < length; i++) {
                host.setLineNumber(DisplaySide.A, cmLine + i, origLineA + i + 1);
                host.setLineNumber(DisplaySide.B, cmLine + i, origLineB + i + 1);
            }
            cmLine += length;
        } else if (current.skip() > 0) {
            mapper.appendCommon(current.skip());
            // Maybe current.ab().length();
            cmLine += current.skip();
        } else if (current.common()) {
            mapper.appendCommon(current.b().length());
            cmLine += current.b().length();
        } else {
            cmLine += render(current, cmLine, useIntralineBg);
        }
    }
    host.setLineNumber(DisplaySide.A, cmLine, mapper.getLineA() + 1);
    host.setLineNumber(DisplaySide.B, cmLine, mapper.getLineB() + 1);
}
#method_after
@Override
void render(DiffInfo diff) {
    super.render();
    LineMapper mapper = getLineMapper();
    chunks = new ArrayList<>();
    int cmLine = 0;
    boolean useIntralineBg = diff.metaA() == null || diff.metaB() == null;
    for (Region current : Natives.asList(diff.content())) {
        int origLineA = mapper.getLineA();
        int origLineB = mapper.getLineB();
        if (current.ab() != null) {
            int length = current.ab().length();
            mapper.appendCommon(length);
            for (int i = 0; i < length; i++) {
                host.setLineNumber(DisplaySide.A, cmLine + i, origLineA + i + 1);
                host.setLineNumber(DisplaySide.B, cmLine + i, origLineB + i + 1);
            }
            cmLine += length;
        } else if (current.skip() > 0) {
            mapper.appendCommon(current.skip());
            // Maybe current.ab().length();
            cmLine += current.skip();
        } else if (current.common()) {
            mapper.appendCommon(current.b().length());
            cmLine += current.b().length();
        } else {
            cmLine += render(current, cmLine, useIntralineBg);
        }
    }
}
#end_block

#method_before
private int render(Region region, int cmLine, boolean useIntralineBg) {
    LineMapper mapper = getLineMapper();
    int startA = mapper.getLineA();
    int startB = mapper.getLineB();
    JsArrayString a = region.a();
    JsArrayString b = region.b();
    int aLen = a != null ? a.length() : 0;
    int bLen = b != null ? b.length() : 0;
    boolean insertOrDelete = a == null || b == null;
    colorLines(cm, insertOrDelete && !useIntralineBg ? UnifiedTable.style.diffDelete() : UnifiedTable.style.intralineDelete(), cmLine, aLen);
    colorLines(cm, insertOrDelete && !useIntralineBg ? UnifiedTable.style.diffInsert() : UnifiedTable.style.intralineInsert(), cmLine + aLen, bLen);
    markEdit(DisplaySide.A, cmLine, a, region.editA());
    markEdit(DisplaySide.B, cmLine + aLen, b, region.editB());
    // TODO: verify addGutterTag
    addGutterTag(region, cmLine);
    mapper.appendReplace(aLen, bLen);
    int endA = mapper.getLineA() - 1;
    int endB = mapper.getLineB() - 1;
    if (aLen > 0) {
        addDiffChunk(DisplaySide.A, endA, aLen, cmLine, bLen > 0);
        for (int j = 0; j < aLen; j++) {
            host.setLineNumber(DisplaySide.A, cmLine + j, startA + j + 1);
            host.setLineNumberEmpty(DisplaySide.B, cmLine + j);
        }
    }
    if (bLen > 0) {
        addDiffChunk(DisplaySide.B, endB, bLen, cmLine + aLen, aLen > 0);
        for (int j = 0; j < bLen; j++) {
            host.setLineNumberEmpty(DisplaySide.A, cmLine + aLen + j);
            host.setLineNumber(DisplaySide.B, cmLine + aLen + j, startB + j + 1);
        }
    }
    return aLen + bLen;
}
#method_after
private int render(Region region, int cmLine, boolean useIntralineBg) {
    LineMapper mapper = getLineMapper();
    int startA = mapper.getLineA();
    int startB = mapper.getLineB();
    JsArrayString a = region.a();
    JsArrayString b = region.b();
    int aLen = a != null ? a.length() : 0;
    int bLen = b != null ? b.length() : 0;
    boolean insertOrDelete = a == null || b == null;
    colorLines(cm, insertOrDelete && !useIntralineBg ? UnifiedTable.style.diffDelete() : UnifiedTable.style.intralineDelete(), cmLine, aLen);
    colorLines(cm, insertOrDelete && !useIntralineBg ? UnifiedTable.style.diffInsert() : UnifiedTable.style.intralineInsert(), cmLine + aLen, bLen);
    markEdit(DisplaySide.A, cmLine, a, region.editA());
    markEdit(DisplaySide.B, cmLine + aLen, b, region.editB());
    // TODO: verify addGutterTag
    addGutterTag(region, cmLine);
    mapper.appendReplace(aLen, bLen);
    int endA = mapper.getLineA() - 1;
    int endB = mapper.getLineB() - 1;
    if (aLen > 0) {
        addDiffChunk(DisplaySide.A, endA, aLen, cmLine, bLen > 0);
        for (int j = 0; j < aLen; j++) {
            host.setLineNumber(DisplaySide.A, cmLine + j, startA + j + 1);
        }
    }
    if (bLen > 0) {
        addDiffChunk(DisplaySide.B, endB, bLen, cmLine + aLen, aLen > 0);
        for (int j = 0; j < bLen; j++) {
            host.setLineNumber(DisplaySide.B, cmLine + aLen + j, startB + j + 1);
        }
    }
    return aLen + bLen;
}
#end_block

#method_before
private void newDraft(CodeMirror cm) {
    if (cm.somethingSelected()) {
        FromTo fromTo = adjustSelection(cm);
        Pos from = fromTo.from();
        Pos to = fromTo.to();
        UnifiedChunkManager manager = host.getChunkManager();
        LineRegionInfo fromInfo = host.getLineRegionInfoFromCmLine(from.line());
        LineRegionInfo toInfo = host.getLineRegionInfoFromCmLine(to.line());
        DisplaySide side = toInfo.getSide();
        // start line to be on the same side as the end line.
        if ((fromInfo.type == RegionType.INSERT || fromInfo.type == RegionType.COMMON) && toInfo.type == RegionType.DELETE) {
            int startLineOnSideA = manager.getLineMapper().lineOnOther(DisplaySide.B, fromInfo.line).getLine();
            from.line(startLineOnSideA);
            if (fromInfo.type == RegionType.INSERT) {
                from.ch(cm.getLine(startLineOnSideA).length());
            }
            to.line(toInfo.line);
        } else if (fromInfo.type == RegionType.DELETE && toInfo.type == RegionType.INSERT) {
            int startLineOnSideB = manager.getLineMapper().lineOnOther(DisplaySide.A, fromInfo.line).getLine();
            from.line(startLineOnSideB);
            from.ch(cm.getLine(startLineOnSideB).length());
            to.line(toInfo.line);
        } else if (fromInfo.type == RegionType.DELETE && toInfo.type == RegionType.COMMON) {
            int toLineOnSideA = manager.getLineMapper().lineOnOther(DisplaySide.B, toInfo.line).getLine();
            from.line(fromInfo.line);
            to.line(toLineOnSideA);
            side = DisplaySide.A;
        } else {
            // Common case
            from.line(fromInfo.line);
            to.line(toInfo.line);
        }
        addDraftBox(side, CommentInfo.create(getPath(), getStoredSideFromDisplaySide(side), to.line() + 1, CommentRange.create(fromTo))).setEdit(true);
        cm.setCursor(Pos.create(host.getCmLine(to.line(), side), to.ch()));
        cm.setSelection(cm.getCursor());
    } else {
        int cmLine = cm.getLineNumber(cm.extras().activeLine());
        LineRegionInfo info = host.getLineRegionInfoFromCmLine(cmLine);
        insertNewDraft(info.getSide(), cmLine + 1);
    }
}
#method_after
private void newDraft(CodeMirror cm) {
    if (cm.somethingSelected()) {
        FromTo fromTo = adjustSelection(cm);
        Pos from = fromTo.from();
        Pos to = fromTo.to();
        UnifiedChunkManager manager = host.getChunkManager();
        LineRegionInfo fromInfo = host.getLineRegionInfoFromCmLine(from.line());
        LineRegionInfo toInfo = host.getLineRegionInfoFromCmLine(to.line());
        DisplaySide side = toInfo.getSide();
        // start line to be on the same side as the end line.
        if ((fromInfo.type == RegionType.INSERT || fromInfo.type == RegionType.COMMON) && toInfo.type == RegionType.DELETE) {
            LineOnOtherInfo infoOnSideA = manager.getLineMapper().lineOnOther(DisplaySide.B, fromInfo.line);
            int startLineOnSideA = infoOnSideA.getLine();
            if (infoOnSideA.isAligned()) {
                from.line(startLineOnSideA);
            } else {
                from.line(startLineOnSideA + 1);
            }
            from.ch(0);
            to.line(toInfo.line);
        } else if (fromInfo.type == RegionType.DELETE && toInfo.type == RegionType.INSERT) {
            LineOnOtherInfo infoOnSideB = manager.getLineMapper().lineOnOther(DisplaySide.A, fromInfo.line);
            int startLineOnSideB = infoOnSideB.getLine();
            if (infoOnSideB.isAligned()) {
                from.line(startLineOnSideB);
            } else {
                from.line(startLineOnSideB + 1);
            }
            from.ch(0);
            to.line(toInfo.line);
        } else if (fromInfo.type == RegionType.DELETE && toInfo.type == RegionType.COMMON) {
            int toLineOnSideA = manager.getLineMapper().lineOnOther(DisplaySide.B, toInfo.line).getLine();
            from.line(fromInfo.line);
            // Force the end line to be on the same side as the start line.
            to.line(toLineOnSideA);
            side = DisplaySide.A;
        } else {
            // Common case
            from.line(fromInfo.line);
            to.line(toInfo.line);
        }
        addDraftBox(side, CommentInfo.create(getPath(), getStoredSideFromDisplaySide(side), to.line() + 1, CommentRange.create(fromTo))).setEdit(true);
        cm.setCursor(Pos.create(host.getCmLine(to.line(), side), to.ch()));
        cm.setSelection(cm.getCursor());
    } else {
        int cmLine = cm.getLineNumber(cm.extras().activeLine());
        LineRegionInfo info = host.getLineRegionInfoFromCmLine(cmLine);
        insertNewDraft(info.getSide(), cmLine + 1);
    }
}
#end_block

#method_before
@Override
ScreenLoadCallback<ConfigInfoCache.Entry> getScreenLoadCallback(final CommentsCollections comments) {
    return new ScreenLoadCallback<ConfigInfoCache.Entry>(SideBySide.this) {

        @Override
        protected void preDisplay(ConfigInfoCache.Entry result) {
            commentManager = new SideBySideCommentManager(SideBySide.this, base, revision, path, result.getCommentLinkProcessor(), getChangeStatus().isOpen());
            setTheme(result.getTheme());
            display(comments);
        }
    };
}
#method_after
@Override
ScreenLoadCallback<ConfigInfoCache.Entry> getScreenLoadCallback(final CommentsCollections comments) {
    return new ScreenLoadCallback<ConfigInfoCache.Entry>(SideBySide.this) {

        @Override
        protected void preDisplay(ConfigInfoCache.Entry result) {
            commentManager = new SideBySideCommentManager(SideBySide.this, base, revision, path, result.getCommentLinkProcessor(), getChangeStatus().isOpen());
            setTheme(result.getTheme());
            display(comments);
            header.setupPrevNextFiles(comments);
        }
    };
}
#end_block

#method_before
@Override
public void onShowView() {
    super.onShowView();
    operation(new Runnable() {

        @Override
        public void run() {
            resizeCodeMirror();
            chunkManager.adjustPadding();
            cmA.refresh();
            cmB.refresh();
        }
    });
    setLineLength(Patch.COMMIT_MSG.equals(prefs) ? 72 : prefs.lineLength());
    diffTable.refresh();
    if (getStartLine() == 0) {
        DiffChunkInfo d = chunkManager.getFirst();
        if (d != null) {
            if (d.isEdit() && d.getSide() == DisplaySide.A) {
                setStartSide(DisplaySide.B);
                setStartLine(lineOnOther(d.getSide(), d.getStart()).getLine() + 1);
            } else {
                setStartSide(d.getSide());
                setStartLine(d.getStart() + 1);
            }
        }
    }
    if (getStartSide() != null && getStartLine() > 0) {
        CodeMirror cm = getCmFromSide(getStartSide());
        cm.scrollToLine(getStartLine() - 1);
        cm.focus();
    } else {
        cmA.setCursor(Pos.create(0));
        cmA.focus();
    }
    if (Gerrit.isSignedIn() && prefs.autoReview()) {
        header.autoReview();
    }
    prefetchNextFile();
}
#method_after
@Override
public void onShowView() {
    super.onShowView();
    operation(new Runnable() {

        @Override
        public void run() {
            resizeCodeMirror();
            chunkManager.adjustPadding();
            cmA.refresh();
            cmB.refresh();
        }
    });
    setLineLength(Patch.COMMIT_MSG.equals(path) ? 72 : prefs.lineLength());
    diffTable.refresh();
    if (getStartLine() == 0) {
        DiffChunkInfo d = chunkManager.getFirst();
        if (d != null) {
            if (d.isEdit() && d.getSide() == DisplaySide.A) {
                setStartSide(DisplaySide.B);
                setStartLine(lineOnOther(d.getSide(), d.getStart()).getLine() + 1);
            } else {
                setStartSide(d.getSide());
                setStartLine(d.getStart() + 1);
            }
        }
    }
    if (getStartSide() != null && getStartLine() > 0) {
        CodeMirror cm = getCmFromSide(getStartSide());
        cm.scrollToLine(getStartLine() - 1);
        cm.focus();
    } else {
        cmA.setCursor(Pos.create(0));
        cmA.focus();
    }
    if (Gerrit.isSignedIn() && prefs.autoReview()) {
        header.autoReview();
    }
    prefetchNextFile();
}
#end_block

#method_before
private void display(final CommentsCollections comments) {
    final DiffInfo diff = getDiff();
    setThemeStyles(prefs.theme().isDark());
    setShowIntraline(prefs.intralineDifference());
    if (prefs.showLineNumbers()) {
        diffTable.addStyleName(Resources.I.diffTableStyle().showLineNumbers());
    }
    cmA = newCm(diff.metaA(), diff.textA(), diffTable.cmA);
    cmB = newCm(diff.metaB(), diff.textB(), diffTable.cmB);
    cmA.extras().side(DisplaySide.A);
    cmB.extras().side(DisplaySide.B);
    setShowTabs(prefs.showTabs());
    chunkManager = new SideBySideChunkManager(this, cmA, cmB, diffTable.scrollbar);
    skipManager = new SideBySideSkipManager(this, commentManager);
    operation(new Runnable() {

        @Override
        public void run() {
            // Estimate initial CodeMirror height, fixed up in onShowView.
            int height = Window.getClientHeight() - (Gerrit.getHeaderFooterHeight() + 18);
            cmA.setHeight(height);
            cmB.setHeight(height);
            render(diff);
            commentManager.render(comments, prefs.expandAllComments());
            skipManager.render(prefs.context(), diff);
        }
    });
    registerCmEvents(cmA);
    registerCmEvents(cmB);
    scrollSynchronizer = new ScrollSynchronizer(diffTable, cmA, cmB, chunkManager.getLineMapper());
    setPrefsAction(new PreferencesAction(this, prefs));
    header.init(getPrefsAction(), getUnifiedDiffLink(), diff.sideBySideWebLinks());
    scrollSynchronizer.setAutoHideDiffTableHeader(prefs.autoHideDiffTableHeader());
    setupSyntaxHighlighting();
}
#method_after
private void display(final CommentsCollections comments) {
    final DiffInfo diff = getDiff();
    setThemeStyles(prefs.theme().isDark());
    setShowIntraline(prefs.intralineDifference());
    if (prefs.showLineNumbers()) {
        diffTable.addStyleName(SideBySideTable.style.showLineNumbers());
    }
    cmA = newCm(diff.metaA(), diff.textA(), diffTable.cmA);
    cmB = newCm(diff.metaB(), diff.textB(), diffTable.cmB);
    cmA.extras().side(DisplaySide.A);
    cmB.extras().side(DisplaySide.B);
    setShowTabs(prefs.showTabs());
    chunkManager = new SideBySideChunkManager(this, cmA, cmB, diffTable.scrollbar);
    skipManager = new SideBySideSkipManager(this, commentManager);
    operation(new Runnable() {

        @Override
        public void run() {
            // Estimate initial CodeMirror height, fixed up in onShowView.
            int height = Window.getClientHeight() - (Gerrit.getHeaderFooterHeight() + 18);
            cmA.setHeight(height);
            cmB.setHeight(height);
            render(diff);
            commentManager.render(comments, prefs.expandAllComments());
            skipManager.render(prefs.context(), diff);
        }
    });
    registerCmEvents(cmA);
    registerCmEvents(cmB);
    scrollSynchronizer = new ScrollSynchronizer(diffTable, cmA, cmB, chunkManager.getLineMapper());
    setPrefsAction(new PreferencesAction(this, prefs));
    header.init(getPrefsAction(), getUnifiedDiffLink(), diff.sideBySideWebLinks());
    scrollSynchronizer.setAutoHideDiffTableHeader(prefs.autoHideDiffTableHeader());
    setupSyntaxHighlighting();
}
#end_block

#method_before
@Override
void setShowLineNumbers(boolean b) {
    cmA.setOption("lineNumbers", b);
    cmB.setOption("lineNumbers", b);
    if (b) {
        diffTable.addStyleName(Resources.I.diffTableStyle().showLineNumbers());
    } else {
        diffTable.removeStyleName(Resources.I.diffTableStyle().showLineNumbers());
    }
}
#method_after
@Override
void setShowLineNumbers(boolean b) {
    cmA.setOption("lineNumbers", b);
    cmB.setOption("lineNumbers", b);
    if (b) {
        diffTable.addStyleName(SideBySideTable.style.showLineNumbers());
    } else {
        diffTable.removeStyleName(SideBySideTable.style.showLineNumbers());
    }
}
#end_block

#method_before
private SideBySideCommentGroup group(DisplaySide side, int line) {
    SideBySideCommentGroup w = map(side).get(line);
    if (w != null) {
        return w;
    }
    int lineA, lineB;
    if (line == 0) {
        lineA = lineB = 0;
    } else if (side == DisplaySide.A) {
        lineA = line;
        lineB = host.lineOnOther(side, line - 1).getLine() + 1;
    } else {
        lineA = host.lineOnOther(side, line - 1).getLine() + 1;
        lineB = line;
    }
    SideBySideCommentGroup a = newGroup(DisplaySide.A, lineA);
    SideBySideCommentGroup b = newGroup(DisplaySide.B, lineB);
    SideBySideCommentGroup.pair(a, b);
    sideA.put(lineA, a);
    sideB.put(lineB, b);
    if (isAttached()) {
        a.init(host.getDiffTable());
        b.handleRedraw();
    }
    return side == DisplaySide.A ? a : b;
}
#method_after
private SideBySideCommentGroup group(DisplaySide side, int line) {
    SideBySideCommentGroup w = map(side).get(line);
    if (w != null) {
        return w;
    }
    int lineA;
    int lineB;
    if (line == 0) {
        lineA = lineB = 0;
    } else if (side == DisplaySide.A) {
        lineA = line;
        lineB = host.lineOnOther(side, line - 1).getLine() + 1;
    } else {
        lineA = host.lineOnOther(side, line - 1).getLine() + 1;
        lineB = line;
    }
    SideBySideCommentGroup a = newGroup(DisplaySide.A, lineA);
    SideBySideCommentGroup b = newGroup(DisplaySide.B, lineB);
    SideBySideCommentGroup.pair(a, b);
    sideA.put(lineA, a);
    sideB.put(lineB, b);
    if (isAttached()) {
        a.init(host.getDiffTable());
        b.handleRedraw();
    }
    return side == DisplaySide.A ? a : b;
}
#end_block

#method_before
@Override
ScreenLoadCallback<ConfigInfoCache.Entry> getScreenLoadCallback(final CommentsCollections comments) {
    return new ScreenLoadCallback<ConfigInfoCache.Entry>(Unified.this) {

        @Override
        protected void preDisplay(ConfigInfoCache.Entry result) {
            commentManager = new UnifiedCommentManager(Unified.this, base, revision, path, result.getCommentLinkProcessor(), getChangeStatus().isOpen());
            setTheme(result.getTheme());
            display(comments);
        }
    };
}
#method_after
@Override
ScreenLoadCallback<ConfigInfoCache.Entry> getScreenLoadCallback(final CommentsCollections comments) {
    return new ScreenLoadCallback<ConfigInfoCache.Entry>(Unified.this) {

        @Override
        protected void preDisplay(ConfigInfoCache.Entry result) {
            commentManager = new UnifiedCommentManager(Unified.this, base, revision, path, result.getCommentLinkProcessor(), getChangeStatus().isOpen());
            setTheme(result.getTheme());
            display(comments);
            header.setupPrevNextFiles(comments);
        }
    };
}
#end_block

#method_before
private void display(final CommentsCollections comments) {
    final DiffInfo diff = getDiff();
    setThemeStyles(prefs.theme().isDark());
    setShowIntraline(prefs.intralineDifference());
    if (prefs.showLineNumbers()) {
        diffTable.addStyleName(Resources.I.diffTableStyle().showLineNumbers());
    }
    cm = newCm(diff.metaA() == null ? diff.metaB() : diff.metaA(), diff.textUnified(), diffTable.cm);
    setShowTabs(prefs.showTabs());
    chunkManager = new UnifiedChunkManager(this, cm, diffTable.scrollbar);
    skipManager = new UnifiedSkipManager(this, commentManager);
    operation(new Runnable() {

        @Override
        public void run() {
            // Estimate initial CodeMirror height, fixed up in onShowView.
            int height = Window.getClientHeight() - (Gerrit.getHeaderFooterHeight() + 18);
            cm.setHeight(height);
            render(diff);
            commentManager.render(comments, prefs.expandAllComments());
            skipManager.render(prefs.context(), diff);
        }
    });
    registerCmEvents(cm);
    setPrefsAction(new PreferencesAction(this, prefs));
    header.init(getPrefsAction(), getSideBySideDiffLink(), diff.unifiedWebLinks());
    setAutoHideDiffHeader(prefs.autoHideDiffTableHeader());
    setupSyntaxHighlighting();
}
#method_after
private void display(final CommentsCollections comments) {
    final DiffInfo diff = getDiff();
    setThemeStyles(prefs.theme().isDark());
    setShowIntraline(prefs.intralineDifference());
    // TODO: Handle showLineNumbers preference
    cm = newCm(diff.metaA() == null ? diff.metaB() : diff.metaA(), diff.textUnified(), diffTable.cm);
    setShowTabs(prefs.showTabs());
    chunkManager = new UnifiedChunkManager(this, cm, diffTable.scrollbar);
    skipManager = new UnifiedSkipManager(this, commentManager);
    operation(new Runnable() {

        @Override
        public void run() {
            // Estimate initial CodeMirror height, fixed up in onShowView.
            int height = Window.getClientHeight() - (Gerrit.getHeaderFooterHeight() + 18);
            cm.setHeight(height);
            render(diff);
            commentManager.render(comments, prefs.expandAllComments());
            skipManager.render(prefs.context(), diff);
        }
    });
    registerCmEvents(cm);
    setPrefsAction(new PreferencesAction(this, prefs));
    header.init(getPrefsAction(), getSideBySideDiffLink(), diff.unifiedWebLinks());
    setAutoHideDiffHeader(prefs.autoHideDiffTableHeader());
    setupSyntaxHighlighting();
}
#end_block

#method_before
@Override
void setShowLineNumbers(boolean b) {
    if (b) {
        diffTable.addStyleName(Resources.I.diffTableStyle().showLineNumbers());
    } else {
        diffTable.removeStyleName(Resources.I.diffTableStyle().showLineNumbers());
    }
    cm.refresh();
}
#method_after
@Override
void setShowLineNumbers(boolean b) {
// TODO: Implement this
}
#end_block

#method_before
void setLineNumber(DisplaySide side, int cmLine, int line) {
    setLineNumber(side, cmLine, String.valueOf(line), UnifiedTable.style.unifiedLineNumber());
}
#method_after
LineHandle setLineNumber(DisplaySide side, final int cmLine, int line) {
    Label gutter = new Label(String.valueOf(line));
    gutter.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            onGutterClick(cmLine);
        }
    });
    diffTable.add(gutter);
    gutter.setStyleName(UnifiedTable.style.unifiedLineNumber());
    return cm.setGutterMarker(cmLine, side == DisplaySide.A ? UnifiedTable.style.lineNumbersLeft() : UnifiedTable.style.lineNumbersRight(), gutter.getElement());
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    CallbackGroup group1 = new CallbackGroup();
    final CallbackGroup group2 = new CallbackGroup();
    CodeMirror.initLibrary(group1.add(new AsyncCallback<Void>() {

        final AsyncCallback<Void> themeCallback = group2.addEmpty();

        @Override
        public void onSuccess(Void result) {
            // Load theme after CM library to ensure theme can override CSS.
            ThemeLoader.loadTheme(prefs.theme(), themeCallback);
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
    DiffApi.diff(revision, path).base(base).wholeFile().intraline(prefs.intralineDifference()).ignoreWhitespace(prefs.ignoreWhitespace()).get(group1.addFinal(new GerritCallback<DiffInfo>() {

        final AsyncCallback<Void> modeInjectorCb = group2.addEmpty();

        @Override
        public void onSuccess(DiffInfo diffInfo) {
            diff = diffInfo;
            fileSize = bucketFileSize(diffInfo);
            if (prefs.syntaxHighlighting()) {
                if (fileSize.compareTo(FileSize.SMALL) > 0) {
                    modeInjectorCb.onSuccess(null);
                } else {
                    injectMode(diffInfo, modeInjectorCb);
                }
            } else {
                modeInjectorCb.onSuccess(null);
            }
        }
    }));
    if (Gerrit.isSignedIn()) {
        ChangeApi.edit(changeId.get(), group2.add(new AsyncCallback<EditInfo>() {

            @Override
            public void onSuccess(EditInfo result) {
                edit = result;
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        }));
    }
    final CommentsCollections comments = new CommentsCollections();
    comments.load(base, revision, path, group2);
    RestApi call = ChangeApi.detail(changeId.get());
    ChangeList.addOptions(call, EnumSet.of(ListChangesOption.ALL_REVISIONS));
    call.get(group2.add(new AsyncCallback<ChangeInfo>() {

        @Override
        public void onSuccess(ChangeInfo info) {
            changeStatus = info.status();
            info.revisions().copyKeysIntoChildren("name");
            if (edit != null) {
                edit.setName(edit.commit().commit());
                info.setEdit(edit);
                info.revisions().put(edit.name(), RevisionInfo.fromEdit(edit));
            }
            String currentRevision = info.currentRevision();
            boolean current = currentRevision != null && revision.get() == info.revision(currentRevision)._number();
            JsArray<RevisionInfo> list = info.revisions().values();
            RevisionInfo.sortRevisionInfoByNumber(list);
            getDiffTable().set(prefs, list, diff, edit != null, current, changeStatus.isOpen(), diff.binary());
            header.setChangeInfo(info);
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
    ConfigInfoCache.get(changeId, group2.addFinal(getScreenLoadCallback(comments)));
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    CallbackGroup group1 = new CallbackGroup();
    final CallbackGroup group2 = new CallbackGroup();
    CodeMirror.initLibrary(group1.add(new AsyncCallback<Void>() {

        final AsyncCallback<Void> themeCallback = group2.addEmpty();

        @Override
        public void onSuccess(Void result) {
            // Load theme after CM library to ensure theme can override CSS.
            ThemeLoader.loadTheme(prefs.theme(), themeCallback);
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
    DiffApi.diff(revision, path).base(base).wholeFile().intraline(prefs.intralineDifference()).ignoreWhitespace(prefs.ignoreWhitespace()).get(group1.addFinal(new GerritCallback<DiffInfo>() {

        final AsyncCallback<Void> modeInjectorCb = group2.addEmpty();

        @Override
        public void onSuccess(DiffInfo diffInfo) {
            diff = diffInfo;
            fileSize = bucketFileSize(diffInfo);
            if (prefs.syntaxHighlighting()) {
                if (fileSize.compareTo(FileSize.SMALL) > 0) {
                    modeInjectorCb.onSuccess(null);
                } else {
                    injectMode(diffInfo, modeInjectorCb);
                }
            } else {
                modeInjectorCb.onSuccess(null);
            }
        }
    }));
    if (Gerrit.isSignedIn()) {
        ChangeApi.edit(changeId.get(), group2.add(new AsyncCallback<EditInfo>() {

            @Override
            public void onSuccess(EditInfo result) {
                edit = result;
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        }));
    }
    final CommentsCollections comments = new CommentsCollections(base, revision, path);
    comments.load(group2);
    RestApi call = ChangeApi.detail(changeId.get());
    ChangeList.addOptions(call, EnumSet.of(ListChangesOption.ALL_REVISIONS));
    call.get(group2.add(new AsyncCallback<ChangeInfo>() {

        @Override
        public void onSuccess(ChangeInfo info) {
            changeStatus = info.status();
            info.revisions().copyKeysIntoChildren("name");
            if (edit != null) {
                edit.setName(edit.commit().commit());
                info.setEdit(edit);
                info.revisions().put(edit.name(), RevisionInfo.fromEdit(edit));
            }
            String currentRevision = info.currentRevision();
            boolean current = currentRevision != null && revision.get() == info.revision(currentRevision)._number();
            JsArray<RevisionInfo> list = info.revisions().values();
            RevisionInfo.sortRevisionInfoByNumber(list);
            getDiffTable().set(prefs, list, diff, edit != null, current, changeStatus.isOpen(), diff.binary());
            header.setChangeInfo(info);
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
    ConfigInfoCache.get(changeId, group2.addFinal(getScreenLoadCallback(comments)));
}
#end_block

#method_before
@Override
public void onShowView() {
    super.onShowView();
    Window.enableScrolling(false);
    JumpKeys.enable(false);
    if (prefs.hideTopMenu()) {
        Gerrit.setHeaderVisible(false);
    }
    resizeHandler = Window.addResizeHandler(new ResizeHandler() {

        @Override
        public void onResize(ResizeEvent event) {
            resizeCodeMirror();
        }
    });
}
#method_after
@Override
public void onShowView() {
    super.onShowView();
    Window.enableScrolling(false);
    if (prefs.hideTopMenu()) {
        Gerrit.setHeaderVisible(false);
    }
    resizeHandler = Window.addResizeHandler(new ResizeHandler() {

        @Override
        public void onResize(ResizeEvent event) {
            resizeCodeMirror();
        }
    });
}
#end_block

#method_before
@Override
protected void onUnload() {
    super.onUnload();
    removeKeyHandlerRegistrations();
    if (getCommentManager() != null) {
        CallbackGroup group = new CallbackGroup();
        getCommentManager().saveAllDrafts(group);
        group.done();
    }
    if (resizeHandler != null) {
        resizeHandler.removeHandler();
        resizeHandler = null;
    }
    for (CodeMirror cm : getCms()) {
        if (cm != null) {
            cm.getWrapperElement().removeFromParent();
        }
    }
    if (prefsAction != null) {
        prefsAction.hide();
    }
    Window.enableScrolling(true);
    Gerrit.setHeaderVisible(true);
    JumpKeys.enable(true);
}
#method_after
@Override
protected void onUnload() {
    super.onUnload();
    removeKeyHandlerRegistrations();
    if (getCommentManager() != null) {
        CallbackGroup group = new CallbackGroup();
        getCommentManager().saveAllDrafts(group);
        group.done();
    }
    if (resizeHandler != null) {
        resizeHandler.removeHandler();
        resizeHandler = null;
    }
    for (CodeMirror cm : getCms()) {
        if (cm != null) {
            cm.getWrapperElement().removeFromParent();
        }
    }
    if (prefsAction != null) {
        prefsAction.hide();
    }
    Window.enableScrolling(true);
    Gerrit.setHeaderVisible(true);
}
#end_block

#method_before
void registerCmEvents(final CodeMirror cm) {
    cm.on("cursorActivity", updateActiveLine(cm));
    cm.on("focus", updateActiveLine(cm));
    KeyMap keyMap = KeyMap.create().on("A", upToChange(true)).on("U", upToChange(false)).on("'['", header.navigate(Direction.PREV)).on("']'", header.navigate(Direction.NEXT)).on("R", header.toggleReviewed()).on("O", getCommentManager().toggleOpenBox(cm)).on("Enter", getCommentManager().toggleOpenBox(cm)).on("N", maybeNextVimSearch(cm)).on("E", openEditScreen(cm)).on("P", getChunkManager().diffChunkNav(cm, Direction.PREV)).on("Shift-M", header.reviewedAndNext()).on("Shift-N", maybePrevVimSearch(cm)).on("Shift-P", getCommentManager().commentNav(cm, Direction.PREV)).on("Shift-O", getCommentManager().openCloseAll(cm)).on("I", new Runnable() {

        @Override
        public void run() {
            switch(getIntraLineStatus()) {
                case OFF:
                case OK:
                    toggleShowIntraline();
                    break;
                case FAILURE:
                case TIMEOUT:
                default:
                    break;
            }
        }
    }).on("','", new Runnable() {

        @Override
        public void run() {
            prefsAction.show();
        }
    }).on("Shift-/", new Runnable() {

        @Override
        public void run() {
            new ShowHelpCommand().onKeyPress(null);
        }
    }).on("Space", new Runnable() {

        @Override
        public void run() {
            cm.vim().handleKey("<C-d>");
        }
    }).on("Shift-Space", new Runnable() {

        @Override
        public void run() {
            cm.vim().handleKey("<C-u>");
        }
    }).on("Ctrl-F", new Runnable() {

        @Override
        public void run() {
            cm.vim().handleKey("/");
        }
    }).on("Ctrl-A", new Runnable() {

        @Override
        public void run() {
            cm.execCommand("selectAll");
        }
    });
    if (revision.get() != 0) {
        cm.on("beforeSelectionChange", onSelectionChange(cm));
        cm.on("gutterClick", onGutterClick(cm));
        keyMap.on("C", getCommentManager().newDraftCallback(cm));
    }
    cm.addKeyMap(keyMap);
}
#method_after
void registerCmEvents(final CodeMirror cm) {
    cm.on("cursorActivity", updateActiveLine(cm));
    cm.on("focus", updateActiveLine(cm));
    KeyMap keyMap = KeyMap.create().on("A", upToChange(true)).on("U", upToChange(false)).on("'['", header.navigate(Direction.PREV)).on("']'", header.navigate(Direction.NEXT)).on("R", header.toggleReviewed()).on("O", getCommentManager().toggleOpenBox(cm)).on("Enter", getCommentManager().toggleOpenBox(cm)).on("N", maybeNextVimSearch(cm)).on("Ctrl-Alt-E", openEditScreen(cm)).on("P", getChunkManager().diffChunkNav(cm, Direction.PREV)).on("Shift-M", header.reviewedAndNext()).on("Shift-N", maybePrevVimSearch(cm)).on("Shift-P", getCommentManager().commentNav(cm, Direction.PREV)).on("Shift-O", getCommentManager().openCloseAll(cm)).on("I", new Runnable() {

        @Override
        public void run() {
            switch(getIntraLineStatus()) {
                case OFF:
                case OK:
                    toggleShowIntraline();
                    break;
                case FAILURE:
                case TIMEOUT:
                default:
                    break;
            }
        }
    }).on("','", new Runnable() {

        @Override
        public void run() {
            prefsAction.show();
        }
    }).on("Shift-/", new Runnable() {

        @Override
        public void run() {
            new ShowHelpCommand().onKeyPress(null);
        }
    }).on("Space", new Runnable() {

        @Override
        public void run() {
            cm.vim().handleKey("<C-d>");
        }
    }).on("Shift-Space", new Runnable() {

        @Override
        public void run() {
            cm.vim().handleKey("<C-u>");
        }
    }).on("Ctrl-F", new Runnable() {

        @Override
        public void run() {
            cm.vim().handleKey("/");
        }
    }).on("Ctrl-A", new Runnable() {

        @Override
        public void run() {
            cm.execCommand("selectAll");
        }
    }).on("G O", new Runnable() {

        @Override
        public void run() {
            Gerrit.display(PageLinks.toChangeQuery("status:open"));
        }
    }).on("G M", new Runnable() {

        @Override
        public void run() {
            Gerrit.display(PageLinks.toChangeQuery("status:merged"));
        }
    }).on("G A", new Runnable() {

        @Override
        public void run() {
            Gerrit.display(PageLinks.toChangeQuery("status:abandoned"));
        }
    });
    if (Gerrit.isSignedIn()) {
        keyMap.on("G I", new Runnable() {

            @Override
            public void run() {
                Gerrit.display(PageLinks.MINE);
            }
        }).on("G D", new Runnable() {

            @Override
            public void run() {
                Gerrit.display(PageLinks.toChangeQuery("owner:self is:draft"));
            }
        }).on("G C", new Runnable() {

            @Override
            public void run() {
                Gerrit.display(PageLinks.toChangeQuery("has:draft"));
            }
        }).on("G W", new Runnable() {

            @Override
            public void run() {
                Gerrit.display(PageLinks.toChangeQuery("is:watched status:open"));
            }
        }).on("G S", new Runnable() {

            @Override
            public void run() {
                Gerrit.display(PageLinks.toChangeQuery("is:starred"));
            }
        });
    }
    if (revision.get() != 0) {
        cm.on("beforeSelectionChange", onSelectionChange(cm));
        cm.on("gutterClick", onGutterClick(cm));
        keyMap.on("C", getCommentManager().newDraftCallback(cm));
    }
    // Needed to for multi-stroke keymaps
    CodeMirror.normalizeKeyMap(keyMap);
    cm.addKeyMap(keyMap);
}
#end_block

#method_before
@Override
public void registerKeys() {
    super.registerKeys();
    keysNavigation.add(new UpToChangeCommand(revision, 0, 'u'));
    keysNavigation.add(new NoOpKeyCommand(0, 'j', PatchUtil.C.lineNext()), new NoOpKeyCommand(0, 'k', PatchUtil.C.linePrev()));
    keysNavigation.add(new NoOpKeyCommand(0, 'n', PatchUtil.C.chunkNext2()), new NoOpKeyCommand(0, 'p', PatchUtil.C.chunkPrev2()));
    keysNavigation.add(new NoOpKeyCommand(KeyCommand.M_SHIFT, 'n', PatchUtil.C.commentNext()), new NoOpKeyCommand(KeyCommand.M_SHIFT, 'p', PatchUtil.C.commentPrev()));
    keysNavigation.add(new NoOpKeyCommand(KeyCommand.M_CTRL, 'f', Gerrit.C.keySearch()));
    keysAction = new KeyCommandSet(Gerrit.C.sectionActions());
    keysAction.add(new NoOpKeyCommand(0, KeyCodes.KEY_ENTER, PatchUtil.C.expandComment()));
    keysAction.add(new NoOpKeyCommand(0, 'o', PatchUtil.C.expandComment()));
    keysAction.add(new NoOpKeyCommand(KeyCommand.M_SHIFT, 'o', PatchUtil.C.expandAllCommentsOnCurrentLine()));
    if (Gerrit.isSignedIn()) {
        keysAction.add(new KeyCommand(0, 'r', PatchUtil.C.toggleReviewed()) {

            @Override
            public void onKeyPress(KeyPressEvent event) {
                header.toggleReviewed().run();
            }
        });
    }
    keysAction.add(new KeyCommand(KeyCommand.M_SHIFT, 'm', PatchUtil.C.markAsReviewedAndGoToNext()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            header.reviewedAndNext().run();
        }
    });
    keysAction.add(new KeyCommand(0, 'a', PatchUtil.C.openReply()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            upToChange(true).run();
        }
    });
    keysAction.add(new KeyCommand(0, ',', PatchUtil.C.showPreferences()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            prefsAction.show();
        }
    });
    if (getIntraLineStatus() == DiffInfo.IntraLineStatus.OFF || getIntraLineStatus() == DiffInfo.IntraLineStatus.OK) {
        keysAction.add(new KeyCommand(0, 'i', PatchUtil.C.toggleIntraline()) {

            @Override
            public void onKeyPress(KeyPressEvent event) {
                toggleShowIntraline();
            }
        });
    }
    if (Gerrit.isSignedIn()) {
        keysAction.add(new NoOpKeyCommand(0, 'c', PatchUtil.C.commentInsert()));
        keysComment = new KeyCommandSet(PatchUtil.C.commentEditorSet());
        keysComment.add(new NoOpKeyCommand(KeyCommand.M_CTRL, 's', PatchUtil.C.commentSaveDraft()));
        keysComment.add(new NoOpKeyCommand(0, KeyCodes.KEY_ESCAPE, PatchUtil.C.commentCancelEdit()));
    } else {
        keysComment = null;
    }
}
#method_after
@Override
public void registerKeys() {
    super.registerKeys();
    keysNavigation.add(new UpToChangeCommand(revision, 0, 'u'));
    keysNavigation.add(new NoOpKeyCommand(0, 'j', PatchUtil.C.lineNext()), new NoOpKeyCommand(0, 'k', PatchUtil.C.linePrev()));
    keysNavigation.add(new NoOpKeyCommand(0, 'n', PatchUtil.C.chunkNext()), new NoOpKeyCommand(0, 'p', PatchUtil.C.chunkPrev()));
    keysNavigation.add(new NoOpKeyCommand(KeyCommand.M_SHIFT, 'n', PatchUtil.C.commentNext()), new NoOpKeyCommand(KeyCommand.M_SHIFT, 'p', PatchUtil.C.commentPrev()));
    keysNavigation.add(new NoOpKeyCommand(KeyCommand.M_CTRL, 'f', Gerrit.C.keySearch()));
    keysAction = new KeyCommandSet(Gerrit.C.sectionActions());
    keysAction.add(new NoOpKeyCommand(0, KeyCodes.KEY_ENTER, PatchUtil.C.expandComment()));
    keysAction.add(new NoOpKeyCommand(0, 'o', PatchUtil.C.expandComment()));
    keysAction.add(new NoOpKeyCommand(KeyCommand.M_SHIFT, 'o', PatchUtil.C.expandAllCommentsOnCurrentLine()));
    if (Gerrit.isSignedIn()) {
        keysAction.add(new KeyCommand(0, 'r', PatchUtil.C.toggleReviewed()) {

            @Override
            public void onKeyPress(KeyPressEvent event) {
                header.toggleReviewed().run();
            }
        });
        keysAction.add(new NoOpKeyCommand(KeyCommand.M_CTRL | KeyCommand.M_ALT, 'e', Gerrit.C.keyEditor()));
    }
    keysAction.add(new KeyCommand(KeyCommand.M_SHIFT, 'm', PatchUtil.C.markAsReviewedAndGoToNext()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            header.reviewedAndNext().run();
        }
    });
    keysAction.add(new KeyCommand(0, 'a', PatchUtil.C.openReply()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            upToChange(true).run();
        }
    });
    keysAction.add(new KeyCommand(0, ',', PatchUtil.C.showPreferences()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            prefsAction.show();
        }
    });
    if (getIntraLineStatus() == DiffInfo.IntraLineStatus.OFF || getIntraLineStatus() == DiffInfo.IntraLineStatus.OK) {
        keysAction.add(new KeyCommand(0, 'i', PatchUtil.C.toggleIntraline()) {

            @Override
            public void onKeyPress(KeyPressEvent event) {
                toggleShowIntraline();
            }
        });
    }
    if (Gerrit.isSignedIn()) {
        keysAction.add(new NoOpKeyCommand(0, 'c', PatchUtil.C.commentInsert()));
        keysComment = new KeyCommandSet(PatchUtil.C.commentEditorSet());
        keysComment.add(new NoOpKeyCommand(KeyCommand.M_CTRL, 's', PatchUtil.C.commentSaveDraft()));
        keysComment.add(new NoOpKeyCommand(0, KeyCodes.KEY_ESCAPE, PatchUtil.C.commentCancelEdit()));
    } else {
        keysComment = null;
    }
}
#end_block

#method_before
private GutterClickHandler onGutterClick(final CodeMirror cm) {
    return new GutterClickHandler() {

        @Override
        public void handle(CodeMirror instance, final int line, final String gutterClass, NativeEvent clickEvent) {
            if (isLineNumberClick(clickEvent) && clickEvent.getButton() == NativeEvent.BUTTON_LEFT && !clickEvent.getMetaKey() && !clickEvent.getAltKey() && !clickEvent.getCtrlKey() && !clickEvent.getShiftKey()) {
                cm.setCursor(Pos.create(line));
                Scheduler.get().scheduleDeferred(new ScheduledCommand() {

                    @Override
                    public void execute() {
                        getCommentManager().newDraftOnGutterClick(cm, gutterClass, line + 1);
                    }
                });
            }
        }
    };
}
#method_after
private GutterClickHandler onGutterClick(final CodeMirror cm) {
    return new GutterClickHandler() {

        @Override
        public void handle(CodeMirror instance, final int line, final String gutterClass, NativeEvent clickEvent) {
            if (clickEvent.getButton() == NativeEvent.BUTTON_LEFT && !clickEvent.getMetaKey() && !clickEvent.getAltKey() && !clickEvent.getCtrlKey() && !clickEvent.getShiftKey()) {
                cm.setCursor(Pos.create(line));
                Scheduler.get().scheduleDeferred(new ScheduledCommand() {

                    @Override
                    public void execute() {
                        getCommentManager().newDraftOnGutterClick(cm, gutterClass, line + 1);
                    }
                });
            }
        }
    };
}
#end_block

#method_before
@UiHandler("indentUnit")
void onIndentUnit(ValueChangeEvent<String> e) {
    String v = e.getValue();
    if (v != null && v.length() > 0) {
        prefs.indentUnit(Math.max(1, Integer.parseInt(v)));
        if (view != null) {
            view.setIndentUnit(prefs.indentUnit());
        }
    }
}
#method_after
@UiHandler("indentUnit")
void onIndentUnit(ValueChangeEvent<String> e) {
    String v = e.getValue();
    if (v != null && v.length() > 0) {
        prefs.indentUnit(Math.max(0, Integer.parseInt(v)));
        if (view != null) {
            view.setIndentUnit(prefs.indentUnit());
        }
    }
}
#end_block

#method_before
void setIndentUnit(int indentunit) {
    cm.setOption("indentUnit", Patch.COMMIT_MSG.equals(path) ? 2 : indentunit);
}
#method_after
void setIndentUnit(int indent) {
    cm.setOption("indentUnit", Patch.COMMIT_MSG.equals(path) ? 2 : indent);
}
#end_block

#method_before
@Override
protected void onLoad() {
    DiffApi.list(patchSetId, base, new GerritCallback<NativeMap<FileInfo>>() {

        @Override
        public void onSuccess(NativeMap<FileInfo> result) {
            files = result.values();
            FileInfo.sortFileInfoByPath(files);
            fileNumber.setInnerText(Integer.toString(Natives.asList(files).indexOf(result.get(path)) + 1));
            fileCount.setInnerText(Integer.toString(files.length()));
            currIndex = 0;
            for (int i = 0; i < files.length(); i++) {
                if (path.equals(files.get(i).path())) {
                    currIndex = i;
                    break;
                }
            }
            setupPrevNextFiles();
        }
    });
    if (Gerrit.isSignedIn()) {
        ChangeApi.revision(patchSetId).view("files").addParameterTrue("reviewed").get(new AsyncCallback<JsArrayString>() {

            @Override
            public void onSuccess(JsArrayString result) {
                boolean b = Natives.asList(result).contains(path);
                reviewed.setValue(b, false);
                if (!b && reviewedState == ReviewedState.AUTO_REVIEW) {
                    postAutoReviewed();
                }
                reviewedState = ReviewedState.LOADED;
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        });
    }
}
#method_after
@Override
protected void onLoad() {
    DiffApi.list(patchSetId, base, new GerritCallback<NativeMap<FileInfo>>() {

        @Override
        public void onSuccess(NativeMap<FileInfo> result) {
            JsArray<FileInfo> files = result.values();
            FileInfo.sortFileInfoByPath(files);
            fileNumber.setInnerText(Integer.toString(Natives.asList(files).indexOf(result.get(path)) + 1));
            fileCount.setInnerText(Integer.toString(files.length()));
            setupPrevNextFiles(files, findCurrentFileIndex(files));
        }
    });
    if (Gerrit.isSignedIn()) {
        ChangeApi.revision(patchSetId).view("files").addParameterTrue("reviewed").get(new AsyncCallback<JsArrayString>() {

            @Override
            public void onSuccess(JsArrayString result) {
                boolean b = Natives.asList(result).contains(path);
                reviewed.setValue(b, false);
                if (!b && reviewedState == ReviewedState.AUTO_REVIEW) {
                    postAutoReviewed();
                }
                reviewedState = ReviewedState.LOADED;
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        });
    }
}
#end_block

#method_before
void setupPrevNextFiles() {
    FileInfo prevInfo = null;
    FileInfo nextInfo = null;
    for (int i = currIndex - 1; i >= 0; i--) {
        FileInfo curr = files.get(i);
        if (prefs.skipDeleted() && curr.status().equals("D")) {
            continue;
        } else {
            prevInfo = curr;
            break;
        }
    }
    for (int i = currIndex + 1; i < files.length(); i++) {
        FileInfo curr = files.get(i);
        if (prefs.skipDeleted() && curr.status().equals("D")) {
            continue;
        } else {
            nextInfo = curr;
            break;
        }
    }
    KeyCommand p = setupNav(prev, '[', PatchUtil.C.previousFileHelp(), prevInfo);
    KeyCommand n = setupNav(next, ']', PatchUtil.C.nextFileHelp(), nextInfo);
    if (p != null && n != null) {
        keys.pair(p, n);
    }
    nextPath = nextInfo != null ? nextInfo.path() : null;
}
#method_after
void setupPrevNextFiles(JsArray<FileInfo> files, int currIndex) {
    FileInfo prevInfo = null;
    FileInfo nextInfo = null;
    for (int i = currIndex - 1; i >= 0; i--) {
        FileInfo curr = files.get(i);
        if (prefs.skipDeleted() && ChangeType.DELETED.matches(curr.status())) {
            continue;
        } else {
            prevInfo = curr;
            break;
        }
    }
    for (int i = currIndex + 1; i < files.length(); i++) {
        FileInfo curr = files.get(i);
        if (prefs.skipDeleted() && ChangeType.DELETED.matches(curr.status())) {
            continue;
        } else {
            nextInfo = curr;
            break;
        }
    }
    KeyCommand p = setupNav(prev, '[', PatchUtil.C.previousFileHelp(), prevInfo);
    KeyCommand n = setupNav(next, ']', PatchUtil.C.nextFileHelp(), nextInfo);
    if (p != null && n != null) {
        keys.pair(p, n);
    }
    nextPath = nextInfo != null ? nextInfo.path() : null;
}
#end_block

#method_before
public SubmitStrategy create(SubmitType submitType, ReviewDb db, Repository repo, CodeReviewRevWalk rw, ObjectInserter inserter, RevFlag canMergeFlag, Set<RevCommit> alreadyAccepted, Branch.NameKey destBranch, IdentifiedUser caller, MergeTip mergeTip, CommitStatus commits, String submissionId, SubmitInput submitInput) throws IntegrationException {
    SubmitStrategy.Arguments args = argsFactory.create(submitType, destBranch, commits, rw, caller, mergeTip, inserter, repo, canMergeFlag, db, alreadyAccepted, submissionId, submitInput);
    switch(submitType) {
        case CHERRY_PICK:
            return new CherryPick(args);
        case FAST_FORWARD_ONLY:
            return new FastForwardOnly(args);
        case MERGE_ALWAYS:
            return new MergeAlways(args);
        case MERGE_IF_NECESSARY:
            return new MergeIfNecessary(args);
        case REBASE_IF_NECESSARY:
            return new RebaseIfNecessary(args);
        default:
            String errorMsg = "No submit strategy for: " + submitType;
            log.error(errorMsg);
            throw new IntegrationException(errorMsg);
    }
}
#method_after
public SubmitStrategy create(SubmitType submitType, ReviewDb db, Repository repo, CodeReviewRevWalk rw, ObjectInserter inserter, RevFlag canMergeFlag, Set<RevCommit> alreadyAccepted, Branch.NameKey destBranch, IdentifiedUser caller, MergeTip mergeTip, CommitStatus commits, String submissionId, NotifyHandling notifyHandling) throws IntegrationException {
    SubmitStrategy.Arguments args = argsFactory.create(submitType, destBranch, commits, rw, caller, mergeTip, inserter, repo, canMergeFlag, db, alreadyAccepted, submissionId, notifyHandling);
    switch(submitType) {
        case CHERRY_PICK:
            return new CherryPick(args);
        case FAST_FORWARD_ONLY:
            return new FastForwardOnly(args);
        case MERGE_ALWAYS:
            return new MergeAlways(args);
        case MERGE_IF_NECESSARY:
            return new MergeIfNecessary(args);
        case REBASE_IF_NECESSARY:
            return new RebaseIfNecessary(args);
        default:
            String errorMsg = "No submit strategy for: " + submitType;
            log.error(errorMsg);
            throw new IntegrationException(errorMsg);
    }
}
#end_block

#method_before
@Override
public final void postUpdate(Context ctx) throws Exception {
    postUpdateImpl(ctx);
    if (command != null) {
        args.tagCache.updateFastForward(getProject(), command.getRefName(), command.getOldId(), command.getNewId());
        // per project even if multiple changes to refs/meta/config are submitted.
        if (RefNames.REFS_CONFIG.equals(getDest().get())) {
            args.projectCache.evict(getProject());
            ProjectState p = args.projectCache.get(getProject());
            args.repoManager.setProjectDescription(p.getProject().getNameKey(), p.getProject().getDescription());
        }
    }
    // have failed fast in one of the other steps.
    try {
        args.mergedSenderFactory.create(ctx.getProject(), getId(), submitter.getAccountId(), args.submitInput).sendAsync();
    } catch (Exception e) {
        log.error("Cannot email merged notification for " + getId(), e);
    }
    if (mergeResultRev != null) {
        try {
            args.hooks.doChangeMergedHook(updatedChange, args.accountCache.get(submitter.getAccountId()).getAccount(), mergedPatchSet, ctx.getDb(), mergeResultRev.name());
        } catch (OrmException ex) {
            logError("Cannot run hook for submitted patch set " + getId(), ex);
        }
    }
}
#method_after
@Override
public final void postUpdate(Context ctx) throws Exception {
    postUpdateImpl(ctx);
    if (command != null) {
        args.tagCache.updateFastForward(getProject(), command.getRefName(), command.getOldId(), command.getNewId());
        // per project even if multiple changes to refs/meta/config are submitted.
        if (RefNames.REFS_CONFIG.equals(getDest().get())) {
            args.projectCache.evict(getProject());
            ProjectState p = args.projectCache.get(getProject());
            args.repoManager.setProjectDescription(p.getProject().getNameKey(), p.getProject().getDescription());
        }
    }
    // have failed fast in one of the other steps.
    try {
        args.mergedSenderFactory.create(ctx.getProject(), getId(), submitter.getAccountId(), args.notifyHandling).sendAsync();
    } catch (Exception e) {
        log.error("Cannot email merged notification for " + getId(), e);
    }
    if (mergeResultRev != null) {
        try {
            args.hooks.doChangeMergedHook(updatedChange, args.accountCache.get(submitter.getAccountId()).getAccount(), mergedPatchSet, ctx.getDb(), mergeResultRev.name());
        } catch (OrmException ex) {
            logError("Cannot run hook for submitted patch set " + getId(), ex);
        }
    }
}
#end_block

#method_before
private SubmitStrategy createStrategy(OpenRepo or, MergeTip mergeTip, Branch.NameKey destBranch, SubmitType submitType, CodeReviewCommit branchTip) throws IntegrationException {
    return submitStrategyFactory.create(submitType, db, or.repo, or.rw, or.ins, or.canMergeFlag, getAlreadyAccepted(or, branchTip), destBranch, caller, mergeTip, commits, submissionId, submitInput);
}
#method_after
private SubmitStrategy createStrategy(OpenRepo or, MergeTip mergeTip, Branch.NameKey destBranch, SubmitType submitType, CodeReviewCommit branchTip) throws IntegrationException {
    return submitStrategyFactory.create(submitType, db, or.repo, or.rw, or.ins, or.canMergeFlag, getAlreadyAccepted(or, branchTip), destBranch, caller, mergeTip, commits, submissionId, submitInput.notify);
}
#end_block

#method_before
@Override
public void run() {
    RequestContext old = requestContext.setContext(this);
    try {
        MergedSender cm = mergedSenderFactory.create(project, changeId);
        if (submitter != null) {
            cm.setFrom(submitter);
        }
        if (submitInput != null) {
            cm.setNotify(submitInput.notify);
        }
        cm.send();
    } catch (Exception e) {
        log.error("Cannot email merged notification for " + changeId, e);
    } finally {
        requestContext.setContext(old);
        if (db != null) {
            db.close();
            db = null;
        }
    }
}
#method_after
@Override
public void run() {
    RequestContext old = requestContext.setContext(this);
    try {
        MergedSender cm = mergedSenderFactory.create(project, changeId);
        if (submitter != null) {
            cm.setFrom(submitter);
        }
        cm.setNotify(notifyHandling);
        cm.send();
    } catch (Exception e) {
        log.error("Cannot email merged notification for " + changeId, e);
    } finally {
        requestContext.setContext(old);
        if (db != null) {
            db.close();
            db = null;
        }
    }
}
#end_block

#method_before
@Override
protected boolean beforeInit(SiteInit init) throws Exception {
    ErrorLogFile.errorOnlyConsole();
    if (!skipPlugins) {
        final List<PluginData> plugins = InitPlugins.listPluginsAndRemoveTempFiles(init.site, pluginsDistribution);
        ConsoleUI ui = ConsoleUI.getInstance(false);
        if (installAllPlugins && !nullOrEmpty(installPlugins)) {
            ui.message("Conflicting plugin installation options.\n");
            return true;
        }
        verifyInstallPluginList(ui, plugins);
        if (listPlugins) {
            if (!plugins.isEmpty()) {
                ui.message("Available plugins:\n");
                for (PluginData plugin : plugins) {
                    ui.message(" * %s version %s\n", plugin.name, plugin.version);
                }
            } else {
                ui.message("No plugins found.\n");
            }
            return true;
        }
    }
    return false;
}
#method_after
@Override
protected boolean beforeInit(SiteInit init) throws Exception {
    ErrorLogFile.errorOnlyConsole();
    if (!skipPlugins) {
        final List<PluginData> plugins = InitPlugins.listPluginsAndRemoveTempFiles(init.site, pluginsDistribution);
        ConsoleUI ui = ConsoleUI.getInstance(false);
        if (installAllPlugins && !nullOrEmpty(installPlugins)) {
            ui.message("Cannot use --install-plugin together with --install-all-plugins.\n");
            return true;
        }
        verifyInstallPluginList(ui, plugins);
        if (listPlugins) {
            if (!plugins.isEmpty()) {
                ui.message("Available plugins:\n");
                for (PluginData plugin : plugins) {
                    ui.message(" * %s version %s\n", plugin.name, plugin.version);
                }
            } else {
                ui.message("No plugins found.\n");
            }
            return true;
        }
    }
    return false;
}
#end_block

#method_before
private void selectNewAndReplacedChangesFromMagicBranch() {
    newChanges = Lists.newArrayList();
    SetMultimap<ObjectId, Ref> existing = changeRefsById();
    GroupCollector groupCollector = GroupCollector.create(refsById, db, psUtil, notesFactory, project.getNameKey());
    rp.getRevWalk().reset();
    rp.getRevWalk().sort(RevSort.TOPO);
    rp.getRevWalk().sort(RevSort.REVERSE, true);
    try {
        rp.getRevWalk().markStart(rp.getRevWalk().parseCommit(magicBranch.cmd.getNewId()));
        if (magicBranch.baseCommit != null) {
            for (RevCommit c : magicBranch.baseCommit) {
                rp.getRevWalk().markUninteresting(c);
            }
            Ref targetRef = allRefs.get(magicBranch.ctl.getRefName());
            if (targetRef != null) {
                rp.getRevWalk().markUninteresting(rp.getRevWalk().parseCommit(targetRef.getObjectId()));
            }
        } else {
            markHeadsAsUninteresting(rp.getRevWalk(), magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
        }
        List<ChangeLookup> pending = Lists.newArrayList();
        final Set<Change.Key> newChangeIds = new HashSet<>();
        final int maxBatchChanges = receiveConfig.getEffectiveMaxBatchChangesLimit(user);
        for (; ; ) {
            final RevCommit c = rp.getRevWalk().next();
            if (c == null) {
                break;
            }
            groupCollector.visit(c);
            Collection<Ref> existingRefs = existing.get(c);
            if (!existingRefs.isEmpty()) {
                // A's group.
                for (Ref ref : existingRefs) {
                    updateGroups.add(new UpdateGroupsRequest(ref, c));
                }
                continue;
            }
            if (!validCommit(rp.getRevWalk(), magicBranch.ctl, magicBranch.cmd, c)) {
                // Not a change the user can propose? Abort as early as possible.
                newChanges = Collections.emptyList();
                return;
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
            }
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(c, magicBranch.dest.get()));
                continue;
            }
            final String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                newChanges = Collections.emptyList();
                return;
            }
            pending.add(new ChangeLookup(c, new Change.Key(idStr)));
            if (maxBatchChanges != 0 && pending.size() + newChanges.size() > maxBatchChanges) {
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                newChanges = Collections.emptyList();
                return;
            }
        }
        for (ChangeLookup p : pending) {
            if (newChangeIds.contains(p.changeKey)) {
                reject(magicBranch.cmd, "same change-id in multiple changes. Squash the commits with the same change-id or " + "ensure change-ids are unique for each commit");
                newChanges = Collections.emptyList();
                return;
            }
            List<ChangeData> changes = p.destChanges;
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 1) {
                // 
                if (requestReplace(magicBranch.cmd, false, changes.get(0).change(), p.commit)) {
                    continue;
                } else {
                    newChanges = Collections.emptyList();
                    return;
                }
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    newChanges = Collections.emptyList();
                    return;
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(p.commit, magicBranch.dest.get()));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        newChanges = Collections.emptyList();
        return;
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        newChanges = Collections.emptyList();
        return;
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return;
    }
    if (!newChanges.isEmpty() && magicBranch.edit) {
        reject(magicBranch.cmd, "edit is not supported for new changes");
        return;
    }
    try {
        SortedSetMultimap<ObjectId, String> groups = groupCollector.getGroups();
        for (CreateRequest create : newChanges) {
            batch.addCommand(create.cmd);
            create.groups = ImmutableList.copyOf(groups.get(create.commitId));
        }
        for (ReplaceRequest replace : replaceByChange.values()) {
            replace.groups = ImmutableList.copyOf(groups.get(replace.newCommitId));
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.groups = ImmutableList.copyOf((groups.get(update.commit)));
        }
    } catch (OrmException | NoSuchChangeException e) {
        log.error("Error collecting groups for changes", e);
        reject(magicBranch.cmd, "internal server error");
        return;
    }
}
#method_after
private void selectNewAndReplacedChangesFromMagicBranch() {
    newChanges = Lists.newArrayList();
    SetMultimap<ObjectId, Ref> existing = changeRefsById();
    GroupCollector groupCollector = GroupCollector.create(refsById, db, psUtil, notesFactory, project.getNameKey());
    rp.getRevWalk().reset();
    rp.getRevWalk().sort(RevSort.TOPO);
    rp.getRevWalk().sort(RevSort.REVERSE, true);
    try {
        rp.getRevWalk().markStart(rp.getRevWalk().parseCommit(magicBranch.cmd.getNewId()));
        if (magicBranch.baseCommit != null) {
            for (RevCommit c : magicBranch.baseCommit) {
                rp.getRevWalk().markUninteresting(c);
            }
            Ref targetRef = allRefs.get(magicBranch.ctl.getRefName());
            if (targetRef != null) {
                rp.getRevWalk().markUninteresting(rp.getRevWalk().parseCommit(targetRef.getObjectId()));
            }
        } else {
            markHeadsAsUninteresting(rp.getRevWalk(), magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
        }
        List<ChangeLookup> pending = Lists.newArrayList();
        final Set<Change.Key> newChangeIds = new HashSet<>();
        final int maxBatchChanges = receiveConfig.getEffectiveMaxBatchChangesLimit(user);
        for (; ; ) {
            final RevCommit c = rp.getRevWalk().next();
            if (c == null) {
                break;
            }
            groupCollector.visit(c);
            Collection<Ref> existingRefs = existing.get(c);
            if (!existingRefs.isEmpty()) {
                // A's group.
                for (Ref ref : existingRefs) {
                    updateGroups.add(new UpdateGroupsRequest(ref, c));
                }
                continue;
            }
            if (!validCommit(rp.getRevWalk(), magicBranch.ctl, magicBranch.cmd, c)) {
                // Not a change the user can propose? Abort as early as possible.
                newChanges = Collections.emptyList();
                return;
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
            }
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(c, magicBranch.dest.get()));
                continue;
            }
            final String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                newChanges = Collections.emptyList();
                return;
            }
            pending.add(new ChangeLookup(c, new Change.Key(idStr)));
            if (maxBatchChanges != 0 && pending.size() + newChanges.size() > maxBatchChanges) {
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                newChanges = Collections.emptyList();
                return;
            }
        }
        for (ChangeLookup p : pending) {
            if (newChangeIds.contains(p.changeKey)) {
                reject(magicBranch.cmd, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
                newChanges = Collections.emptyList();
                return;
            }
            List<ChangeData> changes = p.destChanges;
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 1) {
                // 
                if (requestReplace(magicBranch.cmd, false, changes.get(0).change(), p.commit)) {
                    continue;
                } else {
                    newChanges = Collections.emptyList();
                    return;
                }
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    newChanges = Collections.emptyList();
                    return;
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(p.commit, magicBranch.dest.get()));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        newChanges = Collections.emptyList();
        return;
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        newChanges = Collections.emptyList();
        return;
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return;
    }
    if (!newChanges.isEmpty() && magicBranch.edit) {
        reject(magicBranch.cmd, "edit is not supported for new changes");
        return;
    }
    try {
        SortedSetMultimap<ObjectId, String> groups = groupCollector.getGroups();
        for (CreateRequest create : newChanges) {
            batch.addCommand(create.cmd);
            create.groups = ImmutableList.copyOf(groups.get(create.commitId));
        }
        for (ReplaceRequest replace : replaceByChange.values()) {
            replace.groups = ImmutableList.copyOf(groups.get(replace.newCommitId));
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.groups = ImmutableList.copyOf((groups.get(update.commit)));
        }
    } catch (OrmException | NoSuchChangeException e) {
        log.error("Error collecting groups for changes", e);
        reject(magicBranch.cmd, "internal server error");
        return;
    }
}
#end_block

#method_before
boolean validate(boolean autoClose) throws IOException, OrmException {
    if (!autoClose && inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    } else if (change == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    priorPatchSet = change.currentPatchSetId();
    if (!revisions.containsValue(priorPatchSet)) {
        reject(inputCommand, "change " + ontoChange + " missing revisions");
        return false;
    }
    RevCommit newCommit = rp.getRevWalk().parseCommit(newCommitId);
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    if (newCommit.equals(priorCommit)) {
        // Ignore requests to make the change its current state.
        skip = true;
        reject(inputCommand, "commit already exists (as current patchset)");
        return false;
    }
    changeCtl = projectControl.controlFor(db, change);
    if (!changeCtl.canAddPatchSet(db)) {
        String locked = ".";
        if (changeCtl.isPatchSetLocked(db)) {
            locked = ". Change is patch set locked.";
        }
        reject(inputCommand, "cannot replace " + ontoChange + locked);
        return false;
    } else if (change.getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    } else if (revisions.containsKey(newCommit)) {
        reject(inputCommand, "commit already exists (in the change)");
        return false;
    }
    for (final Ref r : rp.getRepository().getRefDatabase().getRefs("refs/changes").values()) {
        if (r.getObjectId().equals(newCommit)) {
            reject(inputCommand, "commit already exists (in the project)");
            return false;
        }
    }
    for (RevCommit prior : revisions.keySet()) {
        // amending when trying to address review comments.
        if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
            reject(inputCommand, "squash commits first");
            return false;
        }
    }
    if (!validCommit(rp.getRevWalk(), changeCtl.getRefControl(), inputCommand, newCommit)) {
        return false;
    }
    rp.getRevWalk().parseBody(priorCommit);
    // of the commit was modified.
    if (newCommit.getTree().equals(priorCommit.getTree())) {
        final boolean messageEq = eq(newCommit.getFullMessage(), priorCommit.getFullMessage());
        final boolean parentsEq = parentsEqual(newCommit, priorCommit);
        final boolean authorEq = authorEqual(newCommit, priorCommit);
        final ObjectReader reader = rp.getRevWalk().getObjectReader();
        if (messageEq && parentsEq && authorEq && !autoClose) {
            addMessage(String.format("(W) No changes between prior commit %s and new commit %s", reader.abbreviate(priorCommit).name(), reader.abbreviate(newCommit).name()));
        } else {
            StringBuilder msg = new StringBuilder();
            msg.append("(W) ");
            msg.append(reader.abbreviate(newCommit).name());
            msg.append(":");
            msg.append(" no files changed");
            if (!authorEq) {
                msg.append(", author changed");
            }
            if (!messageEq) {
                msg.append(", message updated");
            }
            if (!parentsEq) {
                msg.append(", was rebased");
            }
            addMessage(msg.toString());
        }
    }
    if (magicBranch != null && magicBranch.edit) {
        return newEdit();
    }
    newPatchSet();
    return true;
}
#method_after
boolean validate(boolean autoClose) throws IOException, OrmException {
    if (!autoClose && inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    } else if (change == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    priorPatchSet = change.currentPatchSetId();
    if (!revisions.containsValue(priorPatchSet)) {
        reject(inputCommand, "change " + ontoChange + " missing revisions");
        return false;
    }
    RevCommit newCommit = rp.getRevWalk().parseCommit(newCommitId);
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    if (newCommit.equals(priorCommit)) {
        // Ignore requests to make the change its current state.
        skip = true;
        reject(inputCommand, "commit already exists (as current patchset)");
        return false;
    }
    changeCtl = projectControl.controlFor(db, change);
    if (!changeCtl.canAddPatchSet(db)) {
        String locked = ".";
        if (changeCtl.isPatchSetLocked(db)) {
            locked = ". Change is patch set locked.";
        }
        reject(inputCommand, "cannot replace " + ontoChange + locked);
        return false;
    } else if (change.getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    } else if (revisions.containsKey(newCommit)) {
        reject(inputCommand, "commit already exists (in the change)");
        return false;
    }
    for (final Ref r : rp.getRepository().getRefDatabase().getRefs("refs/changes").values()) {
        if (r.getObjectId().equals(newCommit)) {
            reject(inputCommand, "commit already exists (in the project)");
            return false;
        }
    }
    for (RevCommit prior : revisions.keySet()) {
        // amending when trying to address review comments.
        if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
            reject(inputCommand, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
            return false;
        }
    }
    if (!validCommit(rp.getRevWalk(), changeCtl.getRefControl(), inputCommand, newCommit)) {
        return false;
    }
    rp.getRevWalk().parseBody(priorCommit);
    // of the commit was modified.
    if (newCommit.getTree().equals(priorCommit.getTree())) {
        final boolean messageEq = eq(newCommit.getFullMessage(), priorCommit.getFullMessage());
        final boolean parentsEq = parentsEqual(newCommit, priorCommit);
        final boolean authorEq = authorEqual(newCommit, priorCommit);
        final ObjectReader reader = rp.getRevWalk().getObjectReader();
        if (messageEq && parentsEq && authorEq && !autoClose) {
            addMessage(String.format("(W) No changes between prior commit %s and new commit %s", reader.abbreviate(priorCommit).name(), reader.abbreviate(newCommit).name()));
        } else {
            StringBuilder msg = new StringBuilder();
            msg.append("(W) ");
            msg.append(reader.abbreviate(newCommit).name());
            msg.append(":");
            msg.append(" no files changed");
            if (!authorEq) {
                msg.append(", author changed");
            }
            if (!messageEq) {
                msg.append(", message updated");
            }
            if (!parentsEq) {
                msg.append(", was rebased");
            }
            addMessage(msg.toString());
        }
    }
    if (magicBranch != null && magicBranch.edit) {
        return newEdit();
    }
    newPatchSet();
    return true;
}
#end_block

#method_before
public RevCommit merge(Repository repo, RevWalk rw, RevCommit merge, ThreeWayMergeStrategy mergeStrategy) throws IOException {
    String hash = merge.name();
    String refName = RefNames.REFS_CACHE_AUTOMERGE + hash.substring(0, 2) + "/" + hash.substring(2);
    Ref ref = repo.getRefDatabase().exactRef(refName);
    if (ref != null && ref.getObjectId() != null) {
        RevObject obj = rw.parseAny(ref.getObjectId());
        if (obj instanceof RevCommit) {
            return (RevCommit) obj;
        }
        return commit(repo, rw, refName, obj, merge.getParents());
    }
    ResolveMerger m = (ResolveMerger) mergeStrategy.newMerger(repo, true);
    try (ObjectInserter ins = repo.newObjectInserter()) {
        DirCache dc = DirCache.newInCore();
        m.setDirCache(dc);
        m.setObjectInserter(new ObjectInserter.Filter() {

            @Override
            protected ObjectInserter delegate() {
                return ins;
            }

            @Override
            public void flush() {
            }

            @Override
            public void close() {
            }
        });
        boolean couldMerge;
        try {
            couldMerge = m.merge(merge.getParents());
        } catch (IOException e) {
            // It is not safe to continue further down in this method as throwing
            // an exception most likely means that the merge tree was not created
            // and m.getMergeResults() is empty. This would mean that all paths are
            // unmerged and Gerrit UI would show all paths in the patch list.
            log.warn("Error attempting automerge " + refName, e);
            return null;
        }
        ObjectId treeId;
        if (couldMerge) {
            treeId = m.getResultTreeId();
        } else {
            RevCommit ours = merge.getParent(0);
            RevCommit theirs = merge.getParent(1);
            rw.parseBody(ours);
            rw.parseBody(theirs);
            String oursMsg = ours.getShortMessage();
            String theirsMsg = theirs.getShortMessage();
            String oursName = String.format("HEAD   (%s %s)", ours.abbreviate(6).name(), oursMsg.substring(0, Math.min(oursMsg.length(), 60)));
            String theirsName = String.format("BRANCH (%s %s)", theirs.abbreviate(6).name(), theirsMsg.substring(0, Math.min(theirsMsg.length(), 60)));
            MergeFormatter fmt = new MergeFormatter();
            Map<String, MergeResult<? extends Sequence>> r = m.getMergeResults();
            Map<String, ObjectId> resolved = new HashMap<>();
            for (Map.Entry<String, MergeResult<? extends Sequence>> entry : r.entrySet()) {
                MergeResult<? extends Sequence> p = entry.getValue();
                try (TemporaryBuffer buf = new TemporaryBuffer.LocalFile(null, 10 * 1024 * 1024)) {
                    fmt.formatMerge(buf, p, "BASE", oursName, theirsName, UTF_8.name());
                    buf.close();
                    try (InputStream in = buf.openInputStream()) {
                        resolved.put(entry.getKey(), ins.insert(Constants.OBJ_BLOB, buf.length(), in));
                    }
                }
            }
            DirCacheBuilder builder = dc.builder();
            int cnt = dc.getEntryCount();
            for (int i = 0; i < cnt; ) {
                DirCacheEntry entry = dc.getEntry(i);
                if (entry.getStage() == 0) {
                    builder.add(entry);
                    i++;
                    continue;
                }
                int next = dc.nextEntry(i);
                String path = entry.getPathString();
                DirCacheEntry res = new DirCacheEntry(path);
                if (resolved.containsKey(path)) {
                    // For a file with content merge conflict that we produced a result
                    // above on, collapse the file down to a single stage 0 with just
                    // the blob content, and a randomly selected mode (the lowest stage,
                    // which should be the merge base, or ours).
                    res.setFileMode(entry.getFileMode());
                    res.setObjectId(resolved.get(path));
                } else if (next == i + 1) {
                    // If there is exactly one stage present, shouldn't be a conflict...
                    res.setFileMode(entry.getFileMode());
                    res.setObjectId(entry.getObjectId());
                } else if (next == i + 2) {
                    // Two stages suggests a delete/modify conflict. Pick the higher
                    // stage as the automatic result.
                    entry = dc.getEntry(i + 1);
                    res.setFileMode(entry.getFileMode());
                    res.setObjectId(entry.getObjectId());
                } else {
                    // 3 stage conflict, no resolve above
                    // Punt on the 3-stage conflict and show the base, for now.
                    res.setFileMode(entry.getFileMode());
                    res.setObjectId(entry.getObjectId());
                }
                builder.add(res);
                i = next;
            }
            builder.finish();
            treeId = dc.writeTree(ins);
        }
        ins.flush();
        return commit(repo, rw, refName, treeId, merge.getParents());
    }
}
#method_after
public RevCommit merge(Repository repo, RevWalk rw, RevCommit merge, ThreeWayMergeStrategy mergeStrategy) throws IOException {
    rw.parseHeaders(merge);
    String hash = merge.name();
    String refName = RefNames.REFS_CACHE_AUTOMERGE + hash.substring(0, 2) + "/" + hash.substring(2);
    Ref ref = repo.getRefDatabase().exactRef(refName);
    if (ref != null && ref.getObjectId() != null) {
        RevObject obj = rw.parseAny(ref.getObjectId());
        if (obj instanceof RevCommit) {
            return (RevCommit) obj;
        }
        return commit(repo, rw, refName, obj, merge);
    }
    ResolveMerger m = (ResolveMerger) mergeStrategy.newMerger(repo, true);
    try (ObjectInserter ins = repo.newObjectInserter()) {
        DirCache dc = DirCache.newInCore();
        m.setDirCache(dc);
        m.setObjectInserter(new ObjectInserter.Filter() {

            @Override
            protected ObjectInserter delegate() {
                return ins;
            }

            @Override
            public void flush() {
            }

            @Override
            public void close() {
            }
        });
        boolean couldMerge;
        try {
            couldMerge = m.merge(merge.getParents());
        } catch (IOException e) {
            // It is not safe to continue further down in this method as throwing
            // an exception most likely means that the merge tree was not created
            // and m.getMergeResults() is empty. This would mean that all paths are
            // unmerged and Gerrit UI would show all paths in the patch list.
            log.warn("Error attempting automerge " + refName, e);
            return null;
        }
        ObjectId treeId;
        if (couldMerge) {
            treeId = m.getResultTreeId();
        } else {
            RevCommit ours = merge.getParent(0);
            RevCommit theirs = merge.getParent(1);
            rw.parseBody(ours);
            rw.parseBody(theirs);
            String oursMsg = ours.getShortMessage();
            String theirsMsg = theirs.getShortMessage();
            String oursName = String.format("HEAD   (%s %s)", ours.abbreviate(6).name(), oursMsg.substring(0, Math.min(oursMsg.length(), 60)));
            String theirsName = String.format("BRANCH (%s %s)", theirs.abbreviate(6).name(), theirsMsg.substring(0, Math.min(theirsMsg.length(), 60)));
            MergeFormatter fmt = new MergeFormatter();
            Map<String, MergeResult<? extends Sequence>> r = m.getMergeResults();
            Map<String, ObjectId> resolved = new HashMap<>();
            for (Map.Entry<String, MergeResult<? extends Sequence>> entry : r.entrySet()) {
                MergeResult<? extends Sequence> p = entry.getValue();
                try (TemporaryBuffer buf = new TemporaryBuffer.LocalFile(null, 10 * 1024 * 1024)) {
                    fmt.formatMerge(buf, p, "BASE", oursName, theirsName, UTF_8.name());
                    buf.close();
                    try (InputStream in = buf.openInputStream()) {
                        resolved.put(entry.getKey(), ins.insert(Constants.OBJ_BLOB, buf.length(), in));
                    }
                }
            }
            DirCacheBuilder builder = dc.builder();
            int cnt = dc.getEntryCount();
            for (int i = 0; i < cnt; ) {
                DirCacheEntry entry = dc.getEntry(i);
                if (entry.getStage() == 0) {
                    builder.add(entry);
                    i++;
                    continue;
                }
                int next = dc.nextEntry(i);
                String path = entry.getPathString();
                DirCacheEntry res = new DirCacheEntry(path);
                if (resolved.containsKey(path)) {
                    // For a file with content merge conflict that we produced a result
                    // above on, collapse the file down to a single stage 0 with just
                    // the blob content, and a randomly selected mode (the lowest stage,
                    // which should be the merge base, or ours).
                    res.setFileMode(entry.getFileMode());
                    res.setObjectId(resolved.get(path));
                } else if (next == i + 1) {
                    // If there is exactly one stage present, shouldn't be a conflict...
                    res.setFileMode(entry.getFileMode());
                    res.setObjectId(entry.getObjectId());
                } else if (next == i + 2) {
                    // Two stages suggests a delete/modify conflict. Pick the higher
                    // stage as the automatic result.
                    entry = dc.getEntry(i + 1);
                    res.setFileMode(entry.getFileMode());
                    res.setObjectId(entry.getObjectId());
                } else {
                    // 3 stage conflict, no resolve above
                    // Punt on the 3-stage conflict and show the base, for now.
                    res.setFileMode(entry.getFileMode());
                    res.setObjectId(entry.getObjectId());
                }
                builder.add(res);
                i = next;
            }
            builder.finish();
            treeId = dc.writeTree(ins);
        }
        ins.flush();
        return commit(repo, rw, refName, treeId, merge);
    }
}
#end_block

#method_before
private RevCommit commit(Repository repo, RevWalk rw, String refName, ObjectId tree, RevCommit[] parents) throws IOException {
    CommitBuilder cb = new CommitBuilder();
    cb.setAuthor(gerritIdent);
    cb.setCommitter(gerritIdent);
    cb.setTreeId(tree);
    for (RevCommit p : parents) {
        cb.addParentId(p);
    }
    ObjectId commitId;
    try (ObjectInserter inserter = repo.newObjectInserter()) {
        commitId = inserter.insert(cb);
        inserter.flush();
    }
    RefUpdate update = repo.updateRef(refName);
    update.setNewObjectId(commitId);
    update.disableRefLog();
    update.forceUpdate();
    return rw.lookupCommit(commitId);
}
#method_after
private RevCommit commit(Repository repo, RevWalk rw, String refName, ObjectId tree, RevCommit merge) throws IOException {
    rw.parseHeaders(merge);
    // For maximum stability, choose a single ident using the committer time of
    // the input commit, using the server name and timezone.
    PersonIdent ident = new PersonIdent(gerritIdent, merge.getCommitterIdent().getWhen(), gerritIdent.getTimeZone());
    CommitBuilder cb = new CommitBuilder();
    cb.setAuthor(ident);
    cb.setCommitter(ident);
    cb.setTreeId(tree);
    cb.setMessage("Auto-merge of " + merge.name() + '\n');
    for (RevCommit p : merge.getParents()) {
        cb.addParentId(p);
    }
    ObjectId commitId;
    try (ObjectInserter ins = repo.newObjectInserter()) {
        commitId = ins.insert(cb);
        ins.flush();
    }
    RefUpdate ru = repo.updateRef(refName);
    ru.setNewObjectId(commitId);
    ru.disableRefLog();
    ru.forceUpdate();
    return rw.parseCommit(commitId);
}
#end_block

#method_before
private RevTree aFor(RevCommit b, RevWalk walk) throws IOException {
    switch(b.getParentCount()) {
        case 0:
            return walk.parseTree(emptyTree());
        case 1:
            RevCommit a = b.getParent(0);
            walk.parseBody(a);
            return walk.parseTree(a.getTree());
        case 2:
            return autoMerger.merge(repo, walk, b, mergeStrategy).getTree();
        default:
            return null;
    }
}
#method_after
private RevTree aFor(RevCommit b, RevWalk walk) throws IOException {
    switch(b.getParentCount()) {
        case 0:
            return walk.parseTree(emptyTree());
        case 1:
            RevCommit a = b.getParent(0);
            walk.parseBody(a);
            return walk.parseTree(a.getTree());
        case 2:
            RevCommit am = autoMerger.merge(repo, walk, b, mergeStrategy);
            return am == null ? null : am.getTree();
        default:
            return null;
    }
}
#end_block

#method_before
@Override
public String toString() {
    return new StringBuilder().append('[').append(key).append(": ").append(value).append(']').toString();
}
#method_after
@Override
public String toString() {
    return new StringBuilder().append('[').append(key).append(": ").append(value).append(",tag:").append(tag).append(']').toString();
}
#end_block

#method_before
@Override
public String toString() {
    return "ChangeMessage{" + "key=" + key + ", author=" + author + ", writtenOn=" + writtenOn + ", patchset=" + patchset + ", message=[" + message + ", tag=[" + tag + "]}";
}
#method_after
@Override
public String toString() {
    return "ChangeMessage{" + "key=" + key + ", author=" + author + ", writtenOn=" + writtenOn + ", patchset=" + patchset + ", tag=" + tag + ", message=[" + message + "]}";
}
#end_block

#method_before
@Override
public void postUpdate(Context ctx) {
    if (message == null) {
        return;
    }
    if (in.notify.compareTo(NotifyHandling.NONE) > 0) {
        email.create(in.notify, notes, ps, user, message, comments).sendAsync();
    }
    try {
        hooks.doCommentAddedHook(notes.getChange(), user.getAccount(), ps, message.getMessage(), categories, ctx.getDb());
    } catch (OrmException e) {
        log.warn("ChangeHook.doCommentAddedHook delivery failed", e);
    }
}
#method_after
@Override
public void postUpdate(Context ctx) {
    if (message == null) {
        return;
    }
    if (in.notify.compareTo(NotifyHandling.NONE) > 0) {
        email.create(in.notify, notes, ps, user, message, comments).sendAsync();
    }
    try {
        hooks.doCommentAddedHook(notes.getChange(), user.getAccount(), ps, message.getMessage(), approvals, oldApprovals, ctx.getDb());
    } catch (OrmException e) {
        log.warn("ChangeHook.doCommentAddedHook delivery failed", e);
    }
}
#end_block

#method_before
private boolean insertComments(ChangeContext ctx) throws OrmException {
    Map<String, List<CommentInput>> map = in.comments;
    if (map == null) {
        map = Collections.emptyMap();
    }
    Map<String, PatchLineComment> drafts = Collections.emptyMap();
    if (!map.isEmpty() || in.drafts != DraftHandling.KEEP) {
        if (in.drafts == DraftHandling.PUBLISH_ALL_REVISIONS) {
            drafts = changeDrafts(ctx);
        } else {
            drafts = patchSetDrafts(ctx);
        }
    }
    List<PatchLineComment> del = Lists.newArrayList();
    List<PatchLineComment> ups = Lists.newArrayList();
    Set<CommentSetEntry> existingIds = in.omitDuplicateComments ? readExistingComments(ctx) : Collections.<CommentSetEntry>emptySet();
    for (Map.Entry<String, List<CommentInput>> ent : map.entrySet()) {
        String path = ent.getKey();
        for (CommentInput c : ent.getValue()) {
            String parent = Url.decode(c.inReplyTo);
            PatchLineComment e = drafts.remove(Url.decode(c.id));
            if (e == null) {
                e = new PatchLineComment(new PatchLineComment.Key(new Patch.Key(psId, path), null), c.line != null ? c.line : 0, user.getAccountId(), parent, ctx.getWhen());
            } else if (parent != null) {
                e.setParentUuid(parent);
            }
            e.setStatus(PatchLineComment.Status.PUBLISHED);
            e.setWrittenOn(ctx.getWhen());
            e.setSide(c.side == Side.PARENT ? (short) 0 : (short) 1);
            setCommentRevId(e, patchListCache, ctx.getChange(), ps);
            e.setMessage(c.message);
            if (c.range != null) {
                e.setRange(new CommentRange(c.range.startLine, c.range.startCharacter, c.range.endLine, c.range.endCharacter));
                e.setLine(c.range.endLine);
            }
            if (existingIds.contains(CommentSetEntry.create(e))) {
                continue;
            }
            if (e.getKey().get() == null) {
                e.getKey().set(ChangeUtil.messageUUID(ctx.getDb()));
            }
            ups.add(e);
        }
    }
    switch(firstNonNull(in.drafts, DraftHandling.DELETE)) {
        case KEEP:
        default:
            break;
        case DELETE:
            del.addAll(drafts.values());
            break;
        case PUBLISH:
        case PUBLISH_ALL_REVISIONS:
            for (PatchLineComment e : drafts.values()) {
                e.setStatus(PatchLineComment.Status.PUBLISHED);
                e.setWrittenOn(ctx.getWhen());
                setCommentRevId(e, patchListCache, ctx.getChange(), ps);
                ups.add(e);
            }
            break;
    }
    ChangeUpdate u = ctx.getUpdate(psId);
    // TODO(dborowitz): Currently doesn't work for PUBLISH_ALL_REVISIONS with
    // notedb.
    plcUtil.deleteComments(ctx.getDb(), u, del);
    plcUtil.putComments(ctx.getDb(), u, ups);
    comments.addAll(ups);
    return !del.isEmpty() || !ups.isEmpty();
}
#method_after
private boolean insertComments(ChangeContext ctx) throws OrmException {
    Map<String, List<CommentInput>> map = in.comments;
    if (map == null) {
        map = Collections.emptyMap();
    }
    Map<String, PatchLineComment> drafts = Collections.emptyMap();
    if (!map.isEmpty() || in.drafts != DraftHandling.KEEP) {
        if (in.drafts == DraftHandling.PUBLISH_ALL_REVISIONS) {
            drafts = changeDrafts(ctx);
        } else {
            drafts = patchSetDrafts(ctx);
        }
    }
    List<PatchLineComment> del = Lists.newArrayList();
    List<PatchLineComment> ups = Lists.newArrayList();
    Set<CommentSetEntry> existingIds = in.omitDuplicateComments ? readExistingComments(ctx) : Collections.<CommentSetEntry>emptySet();
    for (Map.Entry<String, List<CommentInput>> ent : map.entrySet()) {
        String path = ent.getKey();
        for (CommentInput c : ent.getValue()) {
            String parent = Url.decode(c.inReplyTo);
            PatchLineComment e = drafts.remove(Url.decode(c.id));
            if (e == null) {
                e = new PatchLineComment(new PatchLineComment.Key(new Patch.Key(psId, path), null), c.line != null ? c.line : 0, user.getAccountId(), parent, ctx.getWhen());
            } else if (parent != null) {
                e.setParentUuid(parent);
            }
            e.setStatus(PatchLineComment.Status.PUBLISHED);
            e.setWrittenOn(ctx.getWhen());
            e.setSide(c.side == Side.PARENT ? (short) 0 : (short) 1);
            setCommentRevId(e, patchListCache, ctx.getChange(), ps);
            e.setMessage(c.message);
            e.setTag(in.tag);
            if (c.range != null) {
                e.setRange(new CommentRange(c.range.startLine, c.range.startCharacter, c.range.endLine, c.range.endCharacter));
                e.setLine(c.range.endLine);
            }
            if (existingIds.contains(CommentSetEntry.create(e))) {
                continue;
            }
            if (e.getKey().get() == null) {
                e.getKey().set(ChangeUtil.messageUUID(ctx.getDb()));
            }
            ups.add(e);
        }
    }
    switch(firstNonNull(in.drafts, DraftHandling.DELETE)) {
        case KEEP:
        default:
            break;
        case DELETE:
            del.addAll(drafts.values());
            break;
        case PUBLISH:
            for (PatchLineComment e : drafts.values()) {
                ups.add(publishComment(ctx, e, ps));
            }
            break;
        case PUBLISH_ALL_REVISIONS:
            publishAllRevisions(ctx, drafts, ups);
            break;
    }
    ChangeUpdate u = ctx.getUpdate(psId);
    plcUtil.deleteComments(ctx.getDb(), u, del);
    plcUtil.putComments(ctx.getDb(), u, ups);
    comments.addAll(ups);
    return !del.isEmpty() || !ups.isEmpty();
}
#end_block

#method_before
private Map<String, PatchLineComment> changeDrafts(ChangeContext ctx) throws OrmException {
    Map<String, PatchLineComment> drafts = Maps.newHashMap();
    for (PatchLineComment c : plcUtil.draftByChangeAuthor(ctx.getDb(), ctx.getNotes(), user.getAccountId())) {
        drafts.put(c.getKey().get(), c);
    }
    return drafts;
}
#method_after
private Map<String, PatchLineComment> changeDrafts(ChangeContext ctx) throws OrmException {
    Map<String, PatchLineComment> drafts = Maps.newHashMap();
    for (PatchLineComment c : plcUtil.draftByChangeAuthor(ctx.getDb(), ctx.getNotes(), user.getAccountId())) {
        c.setTag(in.tag);
        drafts.put(c.getKey().get(), c);
    }
    return drafts;
}
#end_block

#method_before
private boolean updateLabels(ChangeContext ctx) throws OrmException, ResourceConflictException {
    Map<String, Short> labels = in.labels;
    if (labels == null) {
        labels = Collections.emptyMap();
    }
    List<PatchSetApproval> del = Lists.newArrayList();
    List<PatchSetApproval> ups = Lists.newArrayList();
    Map<String, PatchSetApproval> current = scanLabels(ctx, del);
    ChangeUpdate update = ctx.getUpdate(psId);
    LabelTypes labelTypes = ctx.getControl().getLabelTypes();
    for (Map.Entry<String, Short> ent : labels.entrySet()) {
        String name = ent.getKey();
        LabelType lt = checkNotNull(labelTypes.byLabel(name), name);
        PatchSetApproval c = current.remove(lt.getName());
        String normName = lt.getName();
        if (ent.getValue() == null || ent.getValue() == 0) {
            // User requested delete of this label.
            if (c != null) {
                if (c.getValue() != 0) {
                    addLabelDelta(normName, (short) 0);
                }
                del.add(c);
                update.putApproval(ent.getKey(), (short) 0);
            }
        } else if (c != null && c.getValue() != ent.getValue()) {
            c.setValue(ent.getValue());
            c.setGranted(ctx.getWhen());
            c.setTag(in.tag);
            ups.add(c);
            addLabelDelta(normName, c.getValue());
            categories.put(normName, c.getValue());
            update.putApproval(ent.getKey(), ent.getValue());
        } else if (c != null && c.getValue() == ent.getValue()) {
            current.put(normName, c);
        } else if (c == null) {
            c = new PatchSetApproval(new PatchSetApproval.Key(psId, user.getAccountId(), lt.getLabelId()), ent.getValue(), ctx.getWhen(), in.tag);
            c.setGranted(ctx.getWhen());
            ups.add(c);
            addLabelDelta(normName, c.getValue());
            categories.put(normName, c.getValue());
            update.putReviewer(user.getAccountId(), REVIEWER);
            update.putApproval(ent.getKey(), ent.getValue());
        }
    }
    if (!del.isEmpty() || !ups.isEmpty()) {
        if (ctx.getChange().getStatus().isClosed()) {
            throw new ResourceConflictException("change is closed");
        }
    }
    forceCallerAsReviewer(ctx, current, ups, del);
    ctx.getDb().patchSetApprovals().delete(del);
    ctx.getDb().patchSetApprovals().upsert(ups);
    return !del.isEmpty() || !ups.isEmpty();
}
#method_after
private boolean updateLabels(ChangeContext ctx) throws OrmException, ResourceConflictException {
    Map<String, Short> inLabels = MoreObjects.firstNonNull(in.labels, Collections.<String, Short>emptyMap());
    // losing access to a label after the change was submitted.
    if (inLabels.isEmpty() && ctx.getChange().getStatus().isClosed()) {
        return false;
    }
    List<PatchSetApproval> del = Lists.newArrayList();
    List<PatchSetApproval> ups = Lists.newArrayList();
    Map<String, PatchSetApproval> current = scanLabels(ctx, del);
    // get all approvals in cases of quick approve vote
    Map<String, Short> allApprovals = approvalsByKey(current.values());
    allApprovals.putAll(inLabels);
    // get previous label votes
    Map<String, Short> currentLabels = new HashMap<>();
    for (Map.Entry<String, PatchSetApproval> ent : current.entrySet()) {
        currentLabels.put(ent.getValue().getLabel(), ent.getValue().getValue());
    }
    Map<String, Short> previous = new HashMap<>();
    for (Map.Entry<String, Short> ent : allApprovals.entrySet()) {
        if (!currentLabels.containsKey(ent.getKey())) {
            previous.put(ent.getKey(), (short) 0);
        } else {
            previous.put(ent.getKey(), currentLabels.get(ent.getKey()));
        }
    }
    ChangeUpdate update = ctx.getUpdate(psId);
    LabelTypes labelTypes = ctx.getControl().getLabelTypes();
    for (Map.Entry<String, Short> ent : allApprovals.entrySet()) {
        String name = ent.getKey();
        LabelType lt = checkNotNull(labelTypes.byLabel(name), name);
        PatchSetApproval c = current.remove(lt.getName());
        String normName = lt.getName();
        approvals.put(normName, (short) 0);
        if (ent.getValue() == null || ent.getValue() == 0) {
            // User requested delete of this label.
            oldApprovals.put(normName, null);
            if (c != null) {
                if (c.getValue() != 0) {
                    addLabelDelta(normName, (short) 0);
                    oldApprovals.put(normName, previous.get(normName));
                }
                del.add(c);
                update.putApproval(normName, (short) 0);
            }
        } else if (c != null && c.getValue() != ent.getValue()) {
            c.setValue(ent.getValue());
            c.setGranted(ctx.getWhen());
            c.setTag(in.tag);
            ups.add(c);
            addLabelDelta(normName, c.getValue());
            oldApprovals.put(normName, previous.get(normName));
            approvals.put(normName, c.getValue());
            update.putApproval(normName, ent.getValue());
        } else if (c != null && c.getValue() == ent.getValue()) {
            current.put(normName, c);
            oldApprovals.put(normName, null);
            approvals.put(normName, c.getValue());
        } else if (c == null) {
            c = new PatchSetApproval(new PatchSetApproval.Key(psId, user.getAccountId(), lt.getLabelId()), ent.getValue(), ctx.getWhen());
            c.setTag(in.tag);
            c.setGranted(ctx.getWhen());
            ups.add(c);
            addLabelDelta(normName, c.getValue());
            oldApprovals.put(normName, previous.get(normName));
            approvals.put(normName, c.getValue());
            update.putReviewer(user.getAccountId(), REVIEWER);
            update.putApproval(normName, ent.getValue());
        }
    }
    if ((!del.isEmpty() || !ups.isEmpty()) && ctx.getChange().getStatus().isClosed()) {
        throw new ResourceConflictException("change is closed");
    }
    forceCallerAsReviewer(ctx, current, ups, del);
    ctx.getDb().patchSetApprovals().delete(del);
    ctx.getDb().patchSetApprovals().upsert(ups);
    return !del.isEmpty() || !ups.isEmpty();
}
#end_block

#method_before
private void forceCallerAsReviewer(ChangeContext ctx, Map<String, PatchSetApproval> current, List<PatchSetApproval> ups, List<PatchSetApproval> del) {
    if (current.isEmpty() && ups.isEmpty()) {
        // TODO Find another way to link reviewers to changes.
        if (del.isEmpty()) {
            // If no existing label is being set to 0, hack in the caller
            // as a reviewer by picking the first server-wide LabelType.
            PatchSetApproval c = new PatchSetApproval(new PatchSetApproval.Key(psId, user.getAccountId(), ctx.getControl().getLabelTypes().getLabelTypes().get(0).getLabelId()), (short) 0, ctx.getWhen(), in.tag);
            c.setGranted(ctx.getWhen());
            ups.add(c);
        } else {
            // Pick a random label that is about to be deleted and keep it.
            Iterator<PatchSetApproval> i = del.iterator();
            PatchSetApproval c = i.next();
            c.setValue((short) 0);
            c.setGranted(ctx.getWhen());
            i.remove();
            ups.add(c);
        }
    }
    ctx.getUpdate(ctx.getChange().currentPatchSetId()).putReviewer(user.getAccountId(), REVIEWER);
}
#method_after
private void forceCallerAsReviewer(ChangeContext ctx, Map<String, PatchSetApproval> current, List<PatchSetApproval> ups, List<PatchSetApproval> del) {
    if (current.isEmpty() && ups.isEmpty()) {
        // TODO Find another way to link reviewers to changes.
        if (del.isEmpty()) {
            // If no existing label is being set to 0, hack in the caller
            // as a reviewer by picking the first server-wide LabelType.
            PatchSetApproval c = new PatchSetApproval(new PatchSetApproval.Key(psId, user.getAccountId(), ctx.getControl().getLabelTypes().getLabelTypes().get(0).getLabelId()), (short) 0, ctx.getWhen());
            c.setTag(in.tag);
            c.setGranted(ctx.getWhen());
            ups.add(c);
        } else {
            // Pick a random label that is about to be deleted and keep it.
            Iterator<PatchSetApproval> i = del.iterator();
            PatchSetApproval c = i.next();
            c.setValue((short) 0);
            c.setGranted(ctx.getWhen());
            i.remove();
            ups.add(c);
        }
    }
    ctx.getUpdate(ctx.getChange().currentPatchSetId()).putReviewer(user.getAccountId(), REVIEWER);
}
#end_block

#method_before
private boolean insertMessage(ChangeContext ctx) throws OrmException {
    String msg = Strings.nullToEmpty(in.message).trim();
    StringBuilder buf = new StringBuilder();
    for (String d : labelDelta) {
        buf.append(" ").append(d);
    }
    if (comments.size() == 1) {
        buf.append("\n\n(1 comment)");
    } else if (comments.size() > 1) {
        buf.append(String.format("\n\n(%d comments)", comments.size()));
    }
    if (!msg.isEmpty()) {
        buf.append("\n\n").append(msg);
    }
    if (buf.length() == 0) {
        return false;
    }
    message = new ChangeMessage(new ChangeMessage.Key(psId.getParentKey(), ChangeUtil.messageUUID(ctx.getDb())), user.getAccountId(), ctx.getWhen(), psId, in.tag);
    message.setMessage(String.format("Patch Set %d:%s", psId.get(), buf.toString()));
    cmUtil.addChangeMessage(ctx.getDb(), ctx.getUpdate(psId), message);
    return true;
}
#method_after
private boolean insertMessage(ChangeContext ctx) throws OrmException {
    String msg = Strings.nullToEmpty(in.message).trim();
    StringBuilder buf = new StringBuilder();
    for (String d : labelDelta) {
        buf.append(" ").append(d);
    }
    if (comments.size() == 1) {
        buf.append("\n\n(1 comment)");
    } else if (comments.size() > 1) {
        buf.append(String.format("\n\n(%d comments)", comments.size()));
    }
    if (!msg.isEmpty()) {
        buf.append("\n\n").append(msg);
    }
    if (buf.length() == 0) {
        return false;
    }
    message = new ChangeMessage(new ChangeMessage.Key(psId.getParentKey(), ChangeUtil.messageUUID(ctx.getDb())), user.getAccountId(), ctx.getWhen(), psId);
    message.setTag(in.tag);
    message.setMessage(String.format("Patch Set %d:%s", psId.get(), buf.toString()));
    cmUtil.addChangeMessage(ctx.getDb(), ctx.getUpdate(psId), message);
    return true;
}
#end_block

#method_before
@Test
public void testWithSubmodule() throws Exception {
    RevCommit c = makeCommitWithSubmodule();
    List<CommitValidationMessage> m = SubmoduleValidator.performValidation(repo, c);
    assertThat(m).hasSize(1);
    List<ComparableCommitValidationMessage> expected = new ArrayList<>();
    expected.add(new ComparableCommitValidationMessage("submodules are not allowed: modules/library", true));
    assertThat(TestUtils.transformMessages(m)).containsAllIn(expected);
}
#method_after
@Test
public void testWithSubmodule() throws Exception {
    RevCommit c = makeCommitWithSubmodule();
    List<CommitValidationMessage> m = SubmoduleValidator.performValidation(repo, c);
    assertThat(TestUtils.transformMessages(m)).containsExactlyElementsIn(ImmutableSet.of("ERROR: submodules are not allowed: modules/library"));
}
#end_block

#method_before
@Test
public void testWithSymlink() throws Exception {
    RevCommit c = makeCommitWithSymlink();
    List<CommitValidationMessage> m = SymlinkValidator.performValidation(repo, c);
    assertThat(m).hasSize(2);
    List<ComparableCommitValidationMessage> expected = new ArrayList<>();
    expected.add(new ComparableCommitValidationMessage("Symbolic links are not allowed: foo.txt", true));
    expected.add(new ComparableCommitValidationMessage("Symbolic links are not allowed: symbolicFolder", true));
    assertThat(TestUtils.transformMessages(m)).containsAllIn(expected);
}
#method_after
@Test
public void testWithSymlink() throws Exception {
    RevCommit c = makeCommitWithSymlink();
    List<CommitValidationMessage> m = SymlinkValidator.performValidation(repo, c);
    Set<String> expected = ImmutableSet.of("ERROR: Symbolic links are not allowed: foo.txt", "ERROR: Symbolic links are not allowed: symbolicFolder");
    assertThat(TestUtils.transformMessages(m)).containsExactlyElementsIn(expected);
}
#end_block

#method_before
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    try {
        PluginConfig cfg = cfgFactory.getFromProjectConfig(receiveEvent.project.getNameKey(), pluginName);
        if (!doCheckBlockedKeywords(cfg)) {
            return Collections.emptyList();
        }
        ImmutableMap<String, Pattern> blockedKeywordPatterns = patternCache.getAll(Arrays.asList(cfg.getStringList(KEY_CHECK_BLOCKED_KEYWORD_PATTERN)));
        try (Repository repo = repoManager.openRepository(receiveEvent.project.getNameKey())) {
            List<CommitValidationMessage> messages = performValidation(repo, receiveEvent.commit, blockedKeywordPatterns.values());
            if (!messages.isEmpty()) {
                throw new CommitValidationException("includes files containing blocked keywords", messages);
            }
        }
    } catch (NoSuchProjectException | IOException | ExecutionException e) {
        throw new CommitValidationException("failed to check on blocked keywords", e);
    }
    return Collections.emptyList();
}
#method_after
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    try {
        PluginConfig cfg = cfgFactory.getFromProjectConfig(receiveEvent.project.getNameKey(), pluginName);
        if (!isActive(cfg)) {
            return Collections.emptyList();
        }
        ImmutableMap<String, Pattern> blockedKeywordPatterns = patternCache.getAll(Arrays.asList(cfg.getStringList(KEY_CHECK_BLOCKED_KEYWORD_PATTERN)));
        try (Repository repo = repoManager.openRepository(receiveEvent.project.getNameKey())) {
            List<CommitValidationMessage> messages = performValidation(repo, receiveEvent.commit, blockedKeywordPatterns.values());
            if (!messages.isEmpty()) {
                throw new CommitValidationException("includes files containing blocked keywords", messages);
            }
        }
    } catch (NoSuchProjectException | IOException | ExecutionException e) {
        throw new CommitValidationException("failed to check on blocked keywords", e);
    }
    return Collections.emptyList();
}
#end_block

#method_before
@Test
public void test() throws Exception {
    String[] invalidFilenamePattern = { "[@:]", "[#%*]" };
    RevCommit c = makeCommit();
    List<CommitValidationMessage> m = InvalidFilenameValidator.performValidation(repo, c, invalidFilenamePattern);
    List<ComparableCommitValidationMessage> expected = new ArrayList<>();
    for (String filenames : getInvalidFilenames()) {
        expected.add(new ComparableCommitValidationMessage("invalid characters found in filename: " + filenames, true));
    }
    assertThat(m).hasSize(5);
    assertThat(TestUtils.transformMessages(m)).containsAllIn(expected);
}
#method_after
@Test
public void test() throws Exception {
    String[] invalidFilenamePattern = { "[@:]", "[#%*]" };
    RevCommit c = makeCommit();
    List<CommitValidationMessage> m = InvalidFilenameValidator.performValidation(repo, c, invalidFilenamePattern);
    Set<String> expected = new HashSet<>();
    for (String filenames : getInvalidFilenames()) {
        expected.add("ERROR: invalid characters found in filename: " + filenames);
    }
    assertThat(TestUtils.transformMessages(m)).containsExactlyElementsIn(expected);
}
#end_block

#method_before
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    try {
        PluginConfig cfg = cfgFactory.getFromProjectConfig(receiveEvent.project.getNameKey(), pluginName);
        if (!doCheckSubmodules(cfg)) {
            return Collections.emptyList();
        }
        try (Repository repo = repoManager.openRepository(receiveEvent.project.getNameKey())) {
            List<CommitValidationMessage> messages = performValidation(repo, receiveEvent.commit);
            if (!messages.isEmpty()) {
                throw new CommitValidationException("contains submodules", messages);
            }
        }
    } catch (NoSuchProjectException | IOException e) {
        throw new CommitValidationException("failed to check on submodules", e);
    }
    return Collections.emptyList();
}
#method_after
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    try {
        PluginConfig cfg = cfgFactory.getFromProjectConfig(receiveEvent.project.getNameKey(), pluginName);
        if (!isActive(cfg)) {
            return Collections.emptyList();
        }
        try (Repository repo = repoManager.openRepository(receiveEvent.project.getNameKey())) {
            List<CommitValidationMessage> messages = performValidation(repo, receiveEvent.commit);
            if (!messages.isEmpty()) {
                throw new CommitValidationException("contains submodules", messages);
            }
        }
    } catch (NoSuchProjectException | IOException e) {
        throw new CommitValidationException("failed to check on submodules", e);
    }
    return Collections.emptyList();
}
#end_block

#method_before
@Test
public void testCarriageReturn() throws Exception {
    RevCommit c = makeCommit();
    List<CommitValidationMessage> m = InvalidLineEndingValidator.performValidation(repo, c, Sets.newHashSet(new String[] { "" }));
    assertThat(m).hasSize(1);
    List<ComparableCommitValidationMessage> expected = new ArrayList<>();
    expected.add(new ComparableCommitValidationMessage("found carriage return (CR) character in file: foo.txt", true));
    assertThat(TestUtils.transformMessages(m)).containsAllIn(expected);
}
#method_after
@Test
public void testCarriageReturn() throws Exception {
    RevCommit c = makeCommit();
    List<CommitValidationMessage> m = InvalidLineEndingValidator.performValidation(repo, c, Sets.newHashSet(new String[] { "" }));
    assertThat(TestUtils.transformMessages(m)).containsExactlyElementsIn(ImmutableSet.of("ERROR: found carriage return (CR) character in file: foo.txt"));
}
#end_block

#method_before
@Test
public void testCarriageReturnWithBinaries() throws Exception {
    RevCommit c = makeCommitWithPseudoBinaries();
    List<CommitValidationMessage> m = InvalidLineEndingValidator.performValidation(repo, c, Sets.newHashSet(new String[] { "" }));
    assertThat(m).hasSize(2);
    List<ComparableCommitValidationMessage> expected = new ArrayList<>();
    expected.add(new ComparableCommitValidationMessage("found carriage return (CR) character in file: foo.jpeg", true));
    expected.add(new ComparableCommitValidationMessage("found carriage return (CR) character in file: foo.iso", true));
    assertThat(TestUtils.transformMessages(m)).containsAllIn(expected);
}
#method_after
@Test
public void testCarriageReturnWithBinaries() throws Exception {
    RevCommit c = makeCommitWithPseudoBinaries();
    List<CommitValidationMessage> m = InvalidLineEndingValidator.performValidation(repo, c, Sets.newHashSet(new String[] { "" }));
    Set<String> expected = ImmutableSet.of("ERROR: found carriage return (CR) character in file: foo.jpeg", "ERROR: found carriage return (CR) character in file: foo.iso");
    assertThat(TestUtils.transformMessages(m)).containsExactlyElementsIn(expected);
}
#end_block

#method_before
public static Collection<ComparableCommitValidationMessage> transformMessages(List<CommitValidationMessage> messages) {
    return Collections2.transform(messages, new Function<CommitValidationMessage, ComparableCommitValidationMessage>() {

        @Override
        public ComparableCommitValidationMessage apply(CommitValidationMessage input) {
            return new ComparableCommitValidationMessage(input.getMessage(), input.isError());
        }
    });
}
#method_after
public static List<String> transformMessages(List<CommitValidationMessage> messages) {
    return Lists.transform(messages, new Function<CommitValidationMessage, String>() {

        @Override
        public String apply(CommitValidationMessage input) {
            String pre = (input.isError()) ? "ERROR: " : "MSG: ";
            return pre + input.getMessage();
        }
    });
}
#end_block

#method_before
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    try {
        PluginConfig cfg = cfgFactory.getFromProjectConfig(receiveEvent.project.getNameKey(), pluginName);
        if (!doCheckInvalidLineEndings(cfg)) {
            return Collections.emptyList();
        }
        try (Repository repo = repoManager.openRepository(receiveEvent.project.getNameKey())) {
            List<CommitValidationMessage> messages = performValidation(repo, receiveEvent.commit, Sets.newHashSet(cfg.getStringList(KEY_IGNORE_FILES)));
            if (!messages.isEmpty()) {
                throw new CommitValidationException("contains files with a Windows line ending", messages);
            }
        }
    } catch (NoSuchProjectException | IOException e) {
        throw new CommitValidationException("failed to check on Windows line endings", e);
    }
    return Collections.emptyList();
}
#method_after
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    try {
        PluginConfig cfg = cfgFactory.getFromProjectConfig(receiveEvent.project.getNameKey(), pluginName);
        if (!isActive(cfg)) {
            return Collections.emptyList();
        }
        try (Repository repo = repoManager.openRepository(receiveEvent.project.getNameKey())) {
            List<CommitValidationMessage> messages = performValidation(repo, receiveEvent.commit, Sets.newHashSet(cfg.getStringList(KEY_IGNORE_FILES)));
            if (!messages.isEmpty()) {
                throw new CommitValidationException("contains files with a Windows line ending", messages);
            }
        }
    } catch (NoSuchProjectException | IOException e) {
        throw new CommitValidationException("failed to check on Windows line endings", e);
    }
    return Collections.emptyList();
}
#end_block

#method_before
private RevCommit makeCommit() throws NoFilepatternException, IOException, GitAPIException {
    Map<File, byte[]> files = new HashMap<>();
    // invalid files
    String content = "http://foo.bar.tld/?pw=myp4ssw0rdTefoobarstline2\n";
    files.put(new File(repo.getDirectory().getParent(), "foo.txt"), content.getBytes(StandardCharsets.UTF_8));
    content = "$Id$\n" + "$Header$\n" + "$Author$\n" + "processXFile($File::Find::name, $Config{$type});\n" + "$Id: bla bla bla$\n";
    files.put(new File(repo.getDirectory().getParent(), "bar.txt"), content.getBytes(StandardCharsets.UTF_8));
    // valid file
    content = "Testline1\n" + "Testline2\n" + "Testline3\n" + "Testline4";
    files.put(new File(repo.getDirectory().getParent(), "foobar.txt"), content.getBytes(StandardCharsets.UTF_8));
    return TestUtils.makeCommit(repo, "Commit with test files.", files);
}
#method_after
private RevCommit makeCommit() throws NoFilepatternException, IOException, GitAPIException {
    Map<File, byte[]> files = new HashMap<>();
    // invalid files
    String content = "http://foo.bar.tld/?pw=myp4ssw0rdTefoobarstline2\n";
    files.put(new File(repo.getDirectory().getParent(), "foo.txt"), content.getBytes(StandardCharsets.UTF_8));
    content = "$Id$\n" + "$Header$\n" + "$Author$\n" + "processXFile($File::Find::name, $Config{$type});\n" + "$Id: foo bar$\n";
    files.put(new File(repo.getDirectory().getParent(), "bar.txt"), content.getBytes(StandardCharsets.UTF_8));
    // valid file
    content = "Testline1\n" + "Testline2\n" + "Testline3\n" + "Testline4";
    files.put(new File(repo.getDirectory().getParent(), "foobar.txt"), content.getBytes(StandardCharsets.UTF_8));
    return TestUtils.makeCommit(repo, "Commit with test files.", files);
}
#end_block

#method_before
@Test
public void testKeywords() throws Exception {
    RevCommit c = makeCommit();
    List<CommitValidationMessage> m = BlockedKeywordValidator.performValidation(repo, c, getPatterns().values());
    assertThat(m).hasSize(2);
    List<ComparableCommitValidationMessage> expected = new ArrayList<>();
    expected.add(new ComparableCommitValidationMessage("blocked keyword(s) found in file: foo.txt (Line: 1) " + "(found: myp4ssw0rd, foobar)", true));
    expected.add(new ComparableCommitValidationMessage("blocked keyword(s) found in file: bar.txt (Line: 5) " + "(found: $Id: bla bla bla$)", true));
    assertThat(TestUtils.transformMessages(m)).containsAllIn(expected);
}
#method_after
@Test
public void testKeywords() throws Exception {
    RevCommit c = makeCommit();
    List<CommitValidationMessage> m = BlockedKeywordValidator.performValidation(repo, c, getPatterns().values());
    Set<String> expected = ImmutableSet.of("ERROR: blocked keyword(s) found in file: foo.txt (Line: 1)" + " (found: myp4ssw0rd, foobar)", "ERROR: blocked keyword(s) found in file: bar.txt (Line: 5)" + " (found: $Id: foo bar$)");
    assertThat(TestUtils.transformMessages(m)).containsExactlyElementsIn(expected);
}
#end_block

#method_before
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    try {
        PluginConfig cfg = cfgFactory.getFromProjectConfig(receiveEvent.project.getNameKey(), pluginName);
        if (!doCheckSymlinks(cfg)) {
            return Collections.emptyList();
        }
        try (Repository repo = repoManager.openRepository(receiveEvent.project.getNameKey())) {
            List<CommitValidationMessage> messages = performValidation(repo, receiveEvent.commit);
            if (!messages.isEmpty()) {
                throw new CommitValidationException("contains symbolic links", messages);
            }
        }
    } catch (NoSuchProjectException | IOException e) {
        throw new CommitValidationException("failed to check on symbolic links", e);
    }
    return Collections.emptyList();
}
#method_after
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    try {
        PluginConfig cfg = cfgFactory.getFromProjectConfig(receiveEvent.project.getNameKey(), pluginName);
        if (!isActive(cfg)) {
            return Collections.emptyList();
        }
        try (Repository repo = repoManager.openRepository(receiveEvent.project.getNameKey())) {
            List<CommitValidationMessage> messages = performValidation(repo, receiveEvent.commit);
            if (!messages.isEmpty()) {
                throw new CommitValidationException("contains symbolic links", messages);
            }
        }
    } catch (NoSuchProjectException | IOException e) {
        throw new CommitValidationException("failed to check on symbolic links", e);
    }
    return Collections.emptyList();
}
#end_block

#method_before
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    try {
        PluginConfig cfg = cfgFactory.getFromProjectConfig(receiveEvent.project.getNameKey(), pluginName);
        if (!doCheckInvalidFilenames(cfg)) {
            return Collections.emptyList();
        }
        try (Repository repo = repoManager.openRepository(receiveEvent.project.getNameKey())) {
            List<CommitValidationMessage> messages = performValidation(repo, receiveEvent.commit, cfg.getStringList(KEY_INVALID_FILENAME_PATTERN));
            if (!messages.isEmpty()) {
                throw new CommitValidationException("contains files with an invalid filename", messages);
            }
        }
    } catch (NoSuchProjectException | IOException e) {
        throw new CommitValidationException("failed to check on invalid file names", e);
    }
    return Collections.emptyList();
}
#method_after
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    try {
        PluginConfig cfg = cfgFactory.getFromProjectConfig(receiveEvent.project.getNameKey(), pluginName);
        if (!isActive(cfg)) {
            return Collections.emptyList();
        }
        try (Repository repo = repoManager.openRepository(receiveEvent.project.getNameKey())) {
            List<CommitValidationMessage> messages = performValidation(repo, receiveEvent.commit, cfg.getStringList(KEY_INVALID_FILENAME_PATTERN));
            if (!messages.isEmpty()) {
                throw new CommitValidationException("contains files with an invalid filename", messages);
            }
        }
    } catch (NoSuchProjectException | IOException e) {
        throw new CommitValidationException("failed to check on invalid file names", e);
    }
    return Collections.emptyList();
}
#end_block

#method_before
@Test
public void testWithSubmodule() throws Exception {
    RevCommit c = makeCommitWithSubmodule();
    List<CommitValidationMessage> m = SubmoduleValidator.performValidation(repo, c);
    assertThat(m).hasSize(1);
    List<ComparableCommitValidationMessage> expected = new ArrayList<>();
    expected.add(new ComparableCommitValidationMessage("submodules are not allowed: modules/library", true));
    assertThat(TestUtils.transformMessages(m)).containsAnyIn(expected);
}
#method_after
@Test
public void testWithSubmodule() throws Exception {
    RevCommit c = makeCommitWithSubmodule();
    List<CommitValidationMessage> m = SubmoduleValidator.performValidation(repo, c);
    assertThat(TestUtils.transformMessages(m)).containsExactlyElementsIn(ImmutableSet.of("ERROR: submodules are not allowed: modules/library"));
}
#end_block

#method_before
@Test
public void testCarriageReturn() throws Exception {
    RevCommit c = makeCommit();
    List<CommitValidationMessage> m = InvalidLineEndingValidator.performValidation(repo, c, Sets.newHashSet(new String[] { "" }));
    assertThat(m).hasSize(1);
    List<ComparableCommitValidationMessage> expected = new ArrayList<>();
    expected.add(new ComparableCommitValidationMessage("found carriage return (CR) character in file: foo.txt", true));
    assertThat(TestUtils.transformMessages(m)).containsAnyIn(expected);
}
#method_after
@Test
public void testCarriageReturn() throws Exception {
    RevCommit c = makeCommit();
    List<CommitValidationMessage> m = InvalidLineEndingValidator.performValidation(repo, c, Sets.newHashSet(new String[] { "" }));
    assertThat(TestUtils.transformMessages(m)).containsExactlyElementsIn(ImmutableSet.of("ERROR: found carriage return (CR) character in file: foo.txt"));
}
#end_block

#method_before
@Test
public void testCarriageReturnWithBinaries() throws Exception {
    RevCommit c = makeCommitWithPseudoBinaries();
    List<CommitValidationMessage> m = InvalidLineEndingValidator.performValidation(repo, c, Sets.newHashSet(new String[] { "" }));
    assertThat(m).hasSize(2);
    List<ComparableCommitValidationMessage> expected = new ArrayList<>();
    expected.add(new ComparableCommitValidationMessage("found carriage return (CR) character in file: foo.jpeg", true));
    expected.add(new ComparableCommitValidationMessage("found carriage return (CR) character in file: foo.iso", true));
    assertThat(TestUtils.transformMessages(m)).containsAnyIn(expected);
}
#method_after
@Test
public void testCarriageReturnWithBinaries() throws Exception {
    RevCommit c = makeCommitWithPseudoBinaries();
    List<CommitValidationMessage> m = InvalidLineEndingValidator.performValidation(repo, c, Sets.newHashSet(new String[] { "" }));
    Set<String> expected = ImmutableSet.of("ERROR: found carriage return (CR) character in file: foo.jpeg", "ERROR: found carriage return (CR) character in file: foo.iso");
    assertThat(TestUtils.transformMessages(m)).containsExactlyElementsIn(expected);
}
#end_block

#method_before
public static Collection<ComparableCommitValidationMessage> transformMessages(List<CommitValidationMessage> messages) {
    return Collections2.transform(messages, new Function<CommitValidationMessage, ComparableCommitValidationMessage>() {

        @Override
        public ComparableCommitValidationMessage apply(CommitValidationMessage input) {
            return new ComparableCommitValidationMessage(input.getMessage(), input.isError());
        }
    });
}
#method_after
public static List<String> transformMessages(List<CommitValidationMessage> messages) {
    return Lists.transform(messages, new Function<CommitValidationMessage, String>() {

        @Override
        public String apply(CommitValidationMessage input) {
            String pre = (input.isError()) ? "ERROR: " : "MSG: ";
            return pre + input.getMessage();
        }
    });
}
#end_block

#method_before
@Test
public void test() throws Exception {
    String[] invalidFilenamePattern = { "[@:]", "[#%*]" };
    RevCommit c = makeCommit();
    List<CommitValidationMessage> m = InvalidFilenameValidator.performValidation(repo, c, invalidFilenamePattern);
    List<ComparableCommitValidationMessage> expected = new ArrayList<>();
    for (String filenames : getInvalidFilenames()) {
        expected.add(new ComparableCommitValidationMessage("invalid characters found in filename: " + filenames, true));
    }
    assertThat(m).hasSize(5);
    assertThat(TestUtils.transformMessages(m)).containsAnyIn(expected);
}
#method_after
@Test
public void test() throws Exception {
    String[] invalidFilenamePattern = { "[@:]", "[#%*]" };
    RevCommit c = makeCommit();
    List<CommitValidationMessage> m = InvalidFilenameValidator.performValidation(repo, c, invalidFilenamePattern);
    Set<String> expected = new HashSet<>();
    for (String filenames : getInvalidFilenames()) {
        expected.add("ERROR: invalid characters found in filename: " + filenames);
    }
    assertThat(TestUtils.transformMessages(m)).containsExactlyElementsIn(expected);
}
#end_block

#method_before
private RevCommit makeCommit() throws NoFilepatternException, IOException, GitAPIException {
    Map<File, byte[]> files = new HashMap<>();
    // invalid files
    String content = "http://foo.bar.tld/?pw=myp4ssw0rdTefoobarstline2\n";
    files.put(new File(repo.getDirectory().getParent(), "foo.txt"), content.getBytes(StandardCharsets.UTF_8));
    content = "$Id$\n" + "$Header$\n" + "$Author$\n" + "processXFile($File::Find::name, $Config{$type});\n" + "$Id: bla bla bla$\n";
    files.put(new File(repo.getDirectory().getParent(), "bar.txt"), content.getBytes(StandardCharsets.UTF_8));
    // valid file
    content = "Testline1\n" + "Testline2\n" + "Testline3\n" + "Testline4";
    files.put(new File(repo.getDirectory().getParent(), "foobar.txt"), content.getBytes(StandardCharsets.UTF_8));
    return TestUtils.makeCommit(repo, "Commit with test files.", files);
}
#method_after
private RevCommit makeCommit() throws NoFilepatternException, IOException, GitAPIException {
    Map<File, byte[]> files = new HashMap<>();
    // invalid files
    String content = "http://foo.bar.tld/?pw=myp4ssw0rdTefoobarstline2\n";
    files.put(new File(repo.getDirectory().getParent(), "foo.txt"), content.getBytes(StandardCharsets.UTF_8));
    content = "$Id$\n" + "$Header$\n" + "$Author$\n" + "processXFile($File::Find::name, $Config{$type});\n" + "$Id: foo bar$\n";
    files.put(new File(repo.getDirectory().getParent(), "bar.txt"), content.getBytes(StandardCharsets.UTF_8));
    // valid file
    content = "Testline1\n" + "Testline2\n" + "Testline3\n" + "Testline4";
    files.put(new File(repo.getDirectory().getParent(), "foobar.txt"), content.getBytes(StandardCharsets.UTF_8));
    return TestUtils.makeCommit(repo, "Commit with test files.", files);
}
#end_block

#method_before
@Test
public void testKeywords() throws Exception {
    RevCommit c = makeCommit();
    List<CommitValidationMessage> m = BlockedKeywordValidator.performValidation(repo, c, getPatterns().values());
    assertThat(m).hasSize(2);
    List<ComparableCommitValidationMessage> expected = new ArrayList<>();
    expected.add(new ComparableCommitValidationMessage("blocked keyword(s) found in file: foo.txt (Line: 1) " + "(found: myp4ssw0rd, foobar)", true));
    expected.add(new ComparableCommitValidationMessage("blocked keyword(s) found in file: bar.txt (Line: 5) " + "(found: $Id: bla bla bla$)", true));
    assertThat(TestUtils.transformMessages(m)).containsAnyIn(expected);
}
#method_after
@Test
public void testKeywords() throws Exception {
    RevCommit c = makeCommit();
    List<CommitValidationMessage> m = BlockedKeywordValidator.performValidation(repo, c, getPatterns().values());
    Set<String> expected = ImmutableSet.of("ERROR: blocked keyword(s) found in file: foo.txt (Line: 1)" + " (found: myp4ssw0rd, foobar)", "ERROR: blocked keyword(s) found in file: bar.txt (Line: 5)" + " (found: $Id: foo bar$)");
    assertThat(TestUtils.transformMessages(m)).containsExactlyElementsIn(expected);
}
#end_block

#method_before
@Test
public void testWithSymlink() throws Exception {
    RevCommit c = makeCommitWithSymlink();
    List<CommitValidationMessage> m = SymlinkValidator.performValidation(repo, c);
    assertThat(m).hasSize(2);
    List<ComparableCommitValidationMessage> expected = new ArrayList<>();
    expected.add(new ComparableCommitValidationMessage("Symbolic links are not allowed: foo.txt", true));
    expected.add(new ComparableCommitValidationMessage("Symbolic links are not allowed: symbolicFolder", true));
    assertThat(TestUtils.transformMessages(m)).containsAnyIn(expected);
}
#method_after
@Test
public void testWithSymlink() throws Exception {
    RevCommit c = makeCommitWithSymlink();
    List<CommitValidationMessage> m = SymlinkValidator.performValidation(repo, c);
    Set<String> expected = ImmutableSet.of("ERROR: Symbolic links are not allowed: foo.txt", "ERROR: Symbolic links are not allowed: symbolicFolder");
    assertThat(TestUtils.transformMessages(m)).containsExactlyElementsIn(expected);
}
#end_block

#method_before
@Override
public ScheduledThreadPoolExecutor get() {
    return executor;
}
#method_after
@Override
public Executor get() {
    return executor;
}
#end_block

#method_before
@Test
public void testIndexChangeOK() throws Exception {
    event = setUpMocks(INDEX_OP, true, "", false);
    assertThat(restClient.index(event)).isTrue();
}
#method_after
@Test
public void testIndexChangeOK() throws Exception {
    setUpMocks(INDEX_OP, SUCCESSFUL, EMPTY_MSG, DO_NOT_THROW_EXCEPTION);
    assertThat(restClient.index(CHANGE_NUMBER)).isTrue();
}
#end_block

#method_before
@Test
public void testIndexChangeFailed() throws Exception {
    event = setUpMocks(INDEX_OP, false, "Error", false);
    assertThat(restClient.index(event)).isFalse();
}
#method_after
@Test
public void testIndexChangeFailed() throws Exception {
    setUpMocks(INDEX_OP, FAILED, ERROR_MSG, DO_NOT_THROW_EXCEPTION);
    assertThat(restClient.index(CHANGE_NUMBER)).isFalse();
}
#end_block

#method_before
@Test
public void testIndexChangeThrowsException() throws Exception {
    event = setUpMocks(INDEX_OP, false, "Exception", true);
    assertThat(restClient.index(event)).isFalse();
}
#method_after
@Test
public void testIndexChangeThrowsException() throws Exception {
    setUpMocks(INDEX_OP, FAILED, EXCEPTION_MSG, THROW_EXCEPTION);
    assertThat(restClient.index(CHANGE_NUMBER)).isFalse();
}
#end_block

#method_before
@Test
public void testChangeDeletedFromIndexOK() throws Exception {
    event = setUpMocks(DELETE_OP, true, "", false);
    assertThat(restClient.deleteFromIndex(event)).isTrue();
}
#method_after
@Test
public void testChangeDeletedFromIndexOK() throws Exception {
    setUpMocks(DELETE_OP, SUCCESSFUL, EMPTY_MSG, DO_NOT_THROW_EXCEPTION);
    assertThat(restClient.deleteFromIndex(CHANGE_NUMBER)).isTrue();
}
#end_block

#method_before
@Test
public void testChangeDeletedFromIndexFailed() throws Exception {
    event = setUpMocks(DELETE_OP, false, "Error", false);
    assertThat(restClient.deleteFromIndex(event)).isFalse();
}
#method_after
@Test
public void testChangeDeletedFromIndexFailed() throws Exception {
    setUpMocks(DELETE_OP, FAILED, ERROR_MSG, DO_NOT_THROW_EXCEPTION);
    assertThat(restClient.deleteFromIndex(CHANGE_NUMBER)).isFalse();
}
#end_block

#method_before
@Test
public void testChangeDeletedFromThrowsException() throws Exception {
    event = setUpMocks(DELETE_OP, false, "Exception", true);
    assertThat(restClient.deleteFromIndex(event)).isFalse();
}
#method_after
@Test
public void testChangeDeletedFromThrowsException() throws Exception {
    setUpMocks(DELETE_OP, FAILED, EXCEPTION_MSG, THROW_EXCEPTION);
    assertThat(restClient.deleteFromIndex(CHANGE_NUMBER)).isFalse();
}
#end_block

#method_before
private Event setUpMocks(String operation, boolean ok, String msg, boolean exception) throws Exception {
    String request = Joiner.on("/").join("/plugins", PLUGIN_NAME, operation, CHANGE_NUMBER);
    HttpSession httpSession = createNiceMock(HttpSession.class);
    if (exception) {
        expect(httpSession.post(request)).andThrow(new IOException());
    } else {
        IndexResult result = new IndexResult(ok, msg);
        expect(httpSession.post(request)).andReturn(result);
    }
    restClient = new RestSession(httpSession, PLUGIN_NAME);
    Event event = createNiceMock(Event.class);
    expect(event.getChangeId()).andReturn(CHANGE_NUMBER);
    replayAll();
    return event;
}
#method_after
private void setUpMocks(String operation, boolean isOperationSuccessful, String msg, boolean exception) throws Exception {
    String request = Joiner.on("/").join("/plugins", PLUGIN_NAME, INDEX_OP, CHANGE_NUMBER);
    HttpSession httpSession = createNiceMock(HttpSession.class);
    if (exception) {
        if (operation.equals(INDEX_OP)) {
            expect(httpSession.post(request)).andThrow(new IOException());
        } else {
            expect(httpSession.delete(request)).andThrow(new IOException());
        }
    } else {
        IndexResult result = new IndexResult(isOperationSuccessful, msg);
        if (operation.equals(INDEX_OP)) {
            expect(httpSession.post(request)).andReturn(result);
        } else {
            expect(httpSession.delete(request)).andReturn(result);
        }
    }
    restClient = new RestSession(httpSession, PLUGIN_NAME);
    replayAll();
}
#end_block

#method_before
private void setUpMocks(boolean mockRestClient) {
    eventMock = createNiceMock(Event.class);
    pool = new PoolMock(1);
    if (mockRestClient) {
        restClient = createMock(RestSession.class);
    } else {
        restClient = null;
    }
    replayAll();
    indexEventHandler = new IndexEventHandler(pool, PLUGIN_NAME, restClient);
}
#method_after
@Before
public void setUpMocks() {
    cd = createNiceMock(ChangeData.class);
    id = Change.Id.parse(Integer.toString(CHANGE_ID));
    expect(cd.getId()).andReturn(id).anyTimes();
    poolMock = createMock(Executor.class);
    poolMock.execute(anyObject(SyncIndexTask.class));
    expectLastCall().andDelegateTo(MoreExecutors.directExecutor());
    restClientMock = createMock(RestSession.class);
    indexEventHandler = new IndexEventHandler(poolMock, PLUGIN_NAME, restClientMock);
}
#end_block

#method_before
@Override
protected void configure() {
    bind(CloseableHttpClient.class).toProvider(HttpClientProvider.class);
    bind(Configuration.class).in(Scopes.SINGLETON);
    bind(HttpSession.class);
    bind(RestSession.class);
    bind(ScheduledThreadPoolExecutor.class).annotatedWith(SyncIndexExecutor.class).toProvider(SyncIndexExecutorProvider.class).in(Scopes.SINGLETON);
    listener().to(SyncIndexExecutorProvider.class);
    DynamicSet.bind(binder(), ChangeIndexedListener.class).to(IndexEventHandler.class);
}
#method_after
@Override
protected void configure() {
    bind(CloseableHttpClient.class).toProvider(HttpClientProvider.class).in(Scopes.SINGLETON);
    bind(Configuration.class).in(Scopes.SINGLETON);
    bind(HttpSession.class);
    bind(RestSession.class);
    bind(Executor.class).annotatedWith(SyncIndexExecutor.class).toProvider(SyncIndexExecutorProvider.class);
    listener().to(SyncIndexExecutorProvider.class);
    DynamicSet.bind(binder(), ChangeIndexedListener.class).to(IndexEventHandler.class);
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    cfg = createMock(Configuration.class);
    expect(cfg.getUrl()).andReturn(URL).anyTimes();
    expect(cfg.getUser()).andReturn("user");
    expect(cfg.getPassword()).andReturn("pass");
    expect(cfg.getMaxTries()).andReturn(MAX_TRIES).anyTimes();
    expect(cfg.getConnectionTimeout()).andReturn(TIMEOUT).anyTimes();
    expect(cfg.getSocketTimeout()).andReturn(TIMEOUT).anyTimes();
    expect(cfg.getRetryInterval()).andReturn(RETRY_INTERVAL).anyTimes();
    replayAll();
    httpClient = new HttpClientProvider(cfg).get();
    httpSession = new HttpSession(httpClient, URL);
}
#method_after
@Before
public void setUp() throws Exception {
    String url = "http://localhost:" + wireMockRule.port();
    cfg = createMock(Configuration.class);
    expect(cfg.getUrl()).andReturn(url).anyTimes();
    expect(cfg.getUser()).andReturn("user");
    expect(cfg.getPassword()).andReturn("pass");
    expect(cfg.getMaxTries()).andReturn(MAX_TRIES).anyTimes();
    expect(cfg.getConnectionTimeout()).andReturn(TIMEOUT).anyTimes();
    expect(cfg.getSocketTimeout()).andReturn(TIMEOUT).anyTimes();
    expect(cfg.getRetryInterval()).andReturn(RETRY_INTERVAL).anyTimes();
    replayAll();
    httpClient = new HttpClientProvider(cfg).get();
    httpSession = new HttpSession(httpClient, url);
    wireMockRule.resetRequests();
}
#end_block

#method_before
@Test
public void testResponseOK() throws Exception {
    stubFor(post(urlEqualTo(ENDPOINT)).willReturn(aResponse().withStatus(OK)));
    assertThat(httpSession.post(ENDPOINT).isSuccessful()).isTrue();
}
#method_after
@Test
public void testResponseOK() throws Exception {
    wireMockRule.givenThat(post(urlEqualTo(ENDPOINT)).willReturn(aResponse().withStatus(OK)));
    assertThat(httpSession.post(ENDPOINT).isSuccessful()).isTrue();
}
#end_block

#method_before
@Test
public void testNotAuthorized() throws Exception {
    String expected = "unauthorized";
    stubFor(post(urlEqualTo(ENDPOINT)).willReturn(aResponse().withStatus(UNAUTHORIZED).withBody(expected)));
    IndexResult result = httpSession.post(ENDPOINT);
    assertThat(result.isSuccessful()).isFalse();
    assertThat(result.getMessage()).isEqualTo(expected);
}
#method_after
@Test
public void testNotAuthorized() throws Exception {
    String expected = "unauthorized";
    wireMockRule.givenThat(post(urlEqualTo(ENDPOINT)).willReturn(aResponse().withStatus(UNAUTHORIZED).withBody(expected)));
    IndexResult result = httpSession.post(ENDPOINT);
    assertThat(result.isSuccessful()).isFalse();
    assertThat(result.getMessage()).isEqualTo(expected);
}
#end_block

#method_before
@Test
public void testNotFound() throws Exception {
    String expected = "not found";
    stubFor(post(urlEqualTo(ENDPOINT)).willReturn(aResponse().withStatus(NOT_FOUND).withBody(expected)));
    IndexResult result = httpSession.post(ENDPOINT);
    assertThat(result.isSuccessful()).isFalse();
    assertThat(result.getMessage()).isEqualTo(expected);
}
#method_after
@Test
public void testNotFound() throws Exception {
    String expected = "not found";
    wireMockRule.givenThat(post(urlEqualTo(ENDPOINT)).willReturn(aResponse().withStatus(NOT_FOUND).withBody(expected)));
    IndexResult result = httpSession.post(ENDPOINT);
    assertThat(result.isSuccessful()).isFalse();
    assertThat(result.getMessage()).isEqualTo(expected);
}
#end_block

#method_before
@Test
public void testBadResponseRetryThenOK() throws Exception {
    stubFor(post(urlEqualTo(ENDPOINT)).inScenario(RETRY_AT_ERROR).whenScenarioStateIs(Scenario.STARTED).willSetStateTo(REQUEST_MADE).willReturn(aResponse().withStatus(ERROR)));
    stubFor(post(urlEqualTo(ENDPOINT)).inScenario(RETRY_AT_ERROR).whenScenarioStateIs(REQUEST_MADE).willReturn(aResponse().withStatus(OK)));
    assertThat(httpSession.post(ENDPOINT).isSuccessful()).isTrue();
}
#method_after
@Test
public void testBadResponseRetryThenOK() throws Exception {
    wireMockRule.givenThat(post(urlEqualTo(ENDPOINT)).inScenario(RETRY_AT_ERROR).whenScenarioStateIs(Scenario.STARTED).willSetStateTo(REQUEST_MADE).willReturn(aResponse().withStatus(ERROR)));
    wireMockRule.givenThat(post(urlEqualTo(ENDPOINT)).inScenario(RETRY_AT_ERROR).whenScenarioStateIs(REQUEST_MADE).willReturn(aResponse().withStatus(OK)));
    assertThat(httpSession.post(ENDPOINT).isSuccessful()).isTrue();
}
#end_block

#method_before
@Test
public void testBadResponseRetryThenGiveUp() throws Exception {
    stubFor(post(urlEqualTo(ENDPOINT)).willReturn(aResponse().withStatus(ERROR).withBody(ERROR_MESSAGE)));
    IndexResult result = httpSession.post(ENDPOINT);
    assertThat(result.isSuccessful()).isFalse();
    assertThat(result.getMessage()).isEqualTo(ERROR_MESSAGE);
}
#method_after
@Test
public void testBadResponseRetryThenGiveUp() throws Exception {
    wireMockRule.givenThat(post(urlEqualTo(ENDPOINT)).willReturn(aResponse().withStatus(ERROR).withBody(ERROR_MESSAGE)));
    IndexResult result = httpSession.post(ENDPOINT);
    assertThat(result.isSuccessful()).isFalse();
    assertThat(result.getMessage()).isEqualTo(ERROR_MESSAGE);
}
#end_block

#method_before
@Test
public void testRetryAfterDelay() throws Exception {
    stubFor(post(urlEqualTo(ENDPOINT)).inScenario(RETRY_AT_DELAY).whenScenarioStateIs(Scenario.STARTED).willSetStateTo(REQUEST_MADE).willReturn(aResponse().withStatus(ERROR).withFixedDelay(TIMEOUT / 2)));
    stubFor(post(urlEqualTo(ENDPOINT)).inScenario(RETRY_AT_DELAY).whenScenarioStateIs(REQUEST_MADE).willReturn(aResponse().withStatus(OK)));
    assertThat(httpSession.post(ENDPOINT).isSuccessful()).isTrue();
}
#method_after
@Test
public void testRetryAfterDelay() throws Exception {
    wireMockRule.givenThat(post(urlEqualTo(ENDPOINT)).inScenario(RETRY_AT_DELAY).whenScenarioStateIs(Scenario.STARTED).willSetStateTo(REQUEST_MADE).willReturn(aResponse().withStatus(ERROR).withFixedDelay(TIMEOUT / 2)));
    wireMockRule.givenThat(post(urlEqualTo(ENDPOINT)).inScenario(RETRY_AT_DELAY).whenScenarioStateIs(REQUEST_MADE).willReturn(aResponse().withStatus(OK)));
    assertThat(httpSession.post(ENDPOINT).isSuccessful()).isTrue();
}
#end_block

#method_before
@Test
public void testGiveUpAtTimeout() throws Exception {
    stubFor(post(urlEqualTo(ENDPOINT)).inScenario(RETRY_AT_DELAY).whenScenarioStateIs(Scenario.STARTED).willSetStateTo(REQUEST_MADE).willReturn(aResponse().withStatus(ERROR).withFixedDelay(TIMEOUT)));
    assertThat(httpSession.post(ENDPOINT).isSuccessful()).isFalse();
}
#method_after
@Test
public void testGiveUpAtTimeout() throws Exception {
    wireMockRule.givenThat(post(urlEqualTo(ENDPOINT)).inScenario(RETRY_AT_DELAY).whenScenarioStateIs(Scenario.STARTED).willSetStateTo(REQUEST_MADE).willReturn(aResponse().withStatus(ERROR).withFixedDelay(TIMEOUT)));
    assertThat(httpSession.post(ENDPOINT).isSuccessful()).isFalse();
}
#end_block

#method_before
@Test
public void testResponseWithMalformedResponse() throws Exception {
    stubFor(post(urlEqualTo(ENDPOINT)).willReturn(aResponse().withFault(Fault.MALFORMED_RESPONSE_CHUNK)));
    assertThat(httpSession.post(ENDPOINT).isSuccessful()).isFalse();
}
#method_after
@Test
public void testResponseWithMalformedResponse() throws Exception {
    wireMockRule.givenThat(post(urlEqualTo(ENDPOINT)).willReturn(aResponse().withFault(Fault.MALFORMED_RESPONSE_CHUNK)));
    assertThat(httpSession.post(ENDPOINT).isSuccessful()).isFalse();
}
#end_block

#method_before
@Override
public void onChangeIndexed(Event event) {
    executeIndexTask(event, false);
}
#method_after
@Override
public void onChangeIndexed(ChangeData cd) {
    executeIndexTask(cd.getId(), false);
}
#end_block

#method_before
@Override
public void onChangeDeleted(Event event) {
    executeIndexTask(event, true);
}
#method_after
@Override
public void onChangeDeleted(Change.Id id) {
    executeIndexTask(id, true);
}
#end_block

#method_before
private void executeIndexTask(Event event, boolean removed) {
    if (!Context.isForwardedEvent()) {
        executor.execute(new SyncIndexTask(event, removed));
    }
}
#method_after
private void executeIndexTask(Change.Id id, boolean deleted) {
    if (!Context.isForwardedEvent()) {
        SyncIndexTask syncIndexTask = new SyncIndexTask(id.get(), deleted);
        if (queuedTasks.add(syncIndexTask)) {
            executor.execute(syncIndexTask);
        }
    }
}
#end_block

#method_before
@Override
public void run() {
    if (removed) {
        restClient.deleteFromIndex(event);
    } else {
        restClient.index(event);
    }
}
#method_after
@Override
public void run() {
    queuedTasks.remove(this);
    if (deleted) {
        restClient.deleteFromIndex(changeId);
    } else {
        restClient.index(changeId);
    }
}
#end_block

#method_before
@Override
public String toString() {
    return String.format("[%s] Index change %s in target instance", pluginName, event.getChangeId());
}
#method_after
@Override
public String toString() {
    return String.format("[%s] Index change %s in target instance", pluginName, changeId);
}
#end_block

#method_before
private boolean index(Event event, boolean removed) {
    int changeId = event.getChangeId();
    try {
        IndexResult result = httpSession.post(buildEndpoint(changeId, removed));
        if (result.isSuccessful()) {
            return true;
        }
        String operation = removed ? "delete from index change " : "index change ";
        log.error("Unable to " + operation + changeId + " Cause: " + result.getMessage());
    } catch (IOException e) {
        log.error("Error trying to update index for change " + changeId, e);
    }
    return false;
}
#method_after
boolean index(int changeId) {
    try {
        IndexResult result = httpSession.post(buildEndpoint(changeId));
        if (result.isSuccessful()) {
            return true;
        }
        log.error("Unable to index change {}. Cause: {}", changeId, result.getMessage());
    } catch (IOException e) {
        log.error("Error trying to index change " + changeId, e);
    }
    return false;
}
#end_block

#method_before
boolean deleteFromIndex(Event event) {
    return index(event, true);
}
#method_after
boolean deleteFromIndex(int changeId) {
    try {
        IndexResult result = httpSession.delete(buildEndpoint(changeId));
        if (result.isSuccessful()) {
            return true;
        }
        log.error("Unable to delete from index change {}. Cause: {}", changeId, result.getMessage());
    } catch (IOException e) {
        log.error("Error trying to delete from index change " + changeId, e);
    }
    return false;
}
#end_block

#method_before
private String buildEndpoint(int changeNumber, boolean removed) {
    String operation = removed ? "delete" : "index";
    return Joiner.on("/").join("/plugins", pluginName, operation, changeNumber);
}
#method_after
private String buildEndpoint(int changeId) {
    return Joiner.on("/").join("/plugins", pluginName, "index", changeId);
}
#end_block

#method_before
@Override
public CloseableHttpClient get() {
    if (httpClient == null) {
        httpClient = HttpClients.custom().setSSLSocketFactory(sslSocketFactory).setConnectionManager(customConnectionManager()).setDefaultCredentialsProvider(buildCredentials()).setDefaultRequestConfig(customRequestConfig()).setRetryHandler(customRetryHandler()).setServiceUnavailableRetryStrategy(customServiceUnavailRetryStrategy()).build();
    }
    return httpClient;
}
#method_after
@Override
public CloseableHttpClient get() {
    return HttpClients.custom().setSSLSocketFactory(sslSocketFactory).setConnectionManager(customConnectionManager()).setDefaultCredentialsProvider(buildCredentials()).setDefaultRequestConfig(customRequestConfig()).setRetryHandler(customRetryHandler()).setServiceUnavailableRetryStrategy(customServiceUnavailRetryStrategy()).build();
}
#end_block

#method_before
private void logRetry(String cause) {
    log.warn("Retrying request to '" + cfg.getUrl() + "' Cause: " + cause);
}
#method_after
private void logRetry(String cause) {
    log.debug("Retrying request to '" + cfg.getUrl() + "' Cause: " + cause);
}
#end_block

#method_before
private HttpClientConnectionManager customConnectionManager() {
    Registry<ConnectionSocketFactory> socketFactoryRegistry = RegistryBuilder.<ConnectionSocketFactory>create().register("https", sslSocketFactory).register("http", PlainConnectionSocketFactory.INSTANCE).build();
    PoolingHttpClientConnectionManager connManager = new PoolingHttpClientConnectionManager(socketFactoryRegistry);
    connManager.setDefaultMaxPerRoute(CONNECTIONS_PER_ROUTE);
    connManager.setMaxTotal(MAX_CONNECTIONS);
    connManager.setValidateAfterInactivity(10000);
    return connManager;
}
#method_after
private HttpClientConnectionManager customConnectionManager() {
    Registry<ConnectionSocketFactory> socketFactoryRegistry = RegistryBuilder.<ConnectionSocketFactory>create().register("https", sslSocketFactory).register("http", PlainConnectionSocketFactory.INSTANCE).build();
    PoolingHttpClientConnectionManager connManager = new PoolingHttpClientConnectionManager(socketFactoryRegistry);
    connManager.setDefaultMaxPerRoute(CONNECTIONS_PER_ROUTE);
    connManager.setMaxTotal(MAX_CONNECTIONS);
    connManager.setValidateAfterInactivity(MAX_CONNECTION_INACTIVITY);
    return connManager;
}
#end_block

#method_before
private SSLConnectionSocketFactory buildSslSocketFactory() {
    return new SSLConnectionSocketFactory(buildSslContext(), new DummyHostnameVerifier());
}
#method_after
private SSLConnectionSocketFactory buildSslSocketFactory() {
    return new SSLConnectionSocketFactory(buildSslContext(), NoopHostnameVerifier.INSTANCE);
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    config = createNiceMock(Configuration.class);
    expect(config.getUrl()).andReturn(EMPTY);
    expect(config.getUser()).andReturn(EMPTY);
    expect(config.getPassword()).andReturn(EMPTY);
    expect(config.getMaxTries()).andReturn(1);
    expect(config.getConnectionTimeout()).andReturn(TIME_INTERVAL);
    expect(config.getSocketTimeout()).andReturn(TIME_INTERVAL);
    expect(config.getRetryInterval()).andReturn(TIME_INTERVAL);
    replayAll();
    httpClientProvider = new HttpClientProvider(config);
}
#method_after
@Before
public void setUp() throws Exception {
    config = createNiceMock(Configuration.class);
    expect(config.getUrl()).andReturn(EMPTY).anyTimes();
    expect(config.getUser()).andReturn(EMPTY).anyTimes();
    expect(config.getPassword()).andReturn(EMPTY).anyTimes();
    expect(config.getMaxTries()).andReturn(1).anyTimes();
    expect(config.getConnectionTimeout()).andReturn(TIME_INTERVAL).anyTimes();
    expect(config.getSocketTimeout()).andReturn(TIME_INTERVAL).anyTimes();
    expect(config.getRetryInterval()).andReturn(TIME_INTERVAL).anyTimes();
    replayAll();
}
#end_block

#method_before
@Test
public void testGet() throws Exception {
    CloseableHttpClient httpClient1 = httpClientProvider.get();
    assertThat(httpClient1).isNotNull();
    CloseableHttpClient httpClient2 = httpClientProvider.get();
    assertThat(httpClient1).isEqualTo(httpClient2);
}
#method_after
@Test
public void testGet() throws Exception {
    Injector injector = Guice.createInjector(new TestModule());
    CloseableHttpClient httpClient1 = injector.getInstance(CloseableHttpClient.class);
    assertThat(httpClient1).isNotNull();
    CloseableHttpClient httpClient2 = injector.getInstance(CloseableHttpClient.class);
    assertThat(httpClient1).isEqualTo(httpClient2);
}
#end_block

#method_before
IndexResult post(String endpoint) throws IOException {
    HttpPost post = new HttpPost(url + endpoint);
    return httpClient.execute(post, new IndexResponseHandler());
}
#method_after
IndexResult post(String endpoint) throws IOException {
    return httpClient.execute(new HttpPost(url + endpoint), new IndexResponseHandler());
}
#end_block

#method_before
@Override
protected void doPost(HttpServletRequest req, HttpServletResponse rsp) throws IOException, ServletException {
    rsp.setContentType("text/plain");
    rsp.setCharacterEncoding("UTF-8");
    try {
        List<String> params = Splitter.on('/').splitToList(req.getPathInfo());
        String operation = params.get(OPERATION_INDEX);
        String changeId = params.get(ID_INDEX);
        Change.Id id = Change.Id.parse(changeId);
        Context.setForwardedEvent(true);
        if ("index".equals(operation)) {
            verifyChange(changeId);
            index(id);
        } else if ("delete".equals(operation)) {
            indexer.delete(id);
        }
        rsp.setStatus(SC_NO_CONTENT);
    } catch (IOException e) {
        rsp.sendError(SC_BAD_REQUEST, e.getMessage());
        logger.error("Unable to update index", e);
    } catch (ResourceNotFoundException | OrmException e) {
        rsp.sendError(SC_NOT_FOUND, "Change not found\n");
        logger.debug("Error trying to find a change ", e);
    } finally {
        Context.unsetForwardedEvent();
    }
}
#method_after
@Override
protected void doPost(HttpServletRequest req, HttpServletResponse rsp) throws IOException, ServletException {
    rsp.setContentType("text/plain");
    rsp.setCharacterEncoding("UTF-8");
    Change.Id id = getIdFromRequest(req.getPathInfo());
    try (ReviewDb db = schemaFactory.open()) {
        Context.setForwardedEvent(true);
        Change change = db.changes().get(id);
        if (change == null) {
            throw new NoSuchChangeException(id);
        }
        indexer.index(db, change);
        rsp.setStatus(SC_NO_CONTENT);
    } catch (IOException e) {
        rsp.sendError(SC_CONFLICT, e.getMessage());
        logger.error("Unable to update index", e);
    } catch (OrmException | NoSuchChangeException e) {
        rsp.sendError(SC_NOT_FOUND, "Change not found\n");
        logger.debug("Error trying to find a change ", e);
    } finally {
        Context.unsetForwardedEvent();
    }
}
#end_block

#method_before
@Override
protected void configureServlets() {
    serveRegex("/(index|delete)/\\d+$").with(SyncIndexRestApiServlet.class);
}
#method_after
@Override
protected void configureServlets() {
    serveRegex("/index/\\d+$").with(SyncIndexRestApiServlet.class);
}
#end_block

#method_before
@Test
public void testValuesPresentInGerritConfig() throws Exception {
    buildMocks(true);
    assertThat(configuration.getUrl()).isEqualTo(URL);
    assertThat(configuration.getUser()).isEqualTo(USER);
    assertThat(configuration.getPassword()).isEqualTo(PASS);
    assertThat(configuration.getConnectionTimeout()).isEqualTo(TIMEOUT);
    assertThat(configuration.getSocketTimeout()).isEqualTo(TIMEOUT);
    assertThat(configuration.getMaxTries()).isEqualTo(MAX_TRIES);
    assertThat(configuration.getRetryInterval()).isEqualTo(RETRY_INTERVAL);
}
#method_after
@Test
public void testValuesPresentInGerritConfig() throws Exception {
    buildMocks(true);
    assertThat(configuration.getUrl()).isEqualTo(URL);
    assertThat(configuration.getUser()).isEqualTo(USER);
    assertThat(configuration.getPassword()).isEqualTo(PASS);
    assertThat(configuration.getConnectionTimeout()).isEqualTo(TIMEOUT);
    assertThat(configuration.getSocketTimeout()).isEqualTo(TIMEOUT);
    assertThat(configuration.getMaxTries()).isEqualTo(MAX_TRIES);
    assertThat(configuration.getRetryInterval()).isEqualTo(RETRY_INTERVAL);
    assertThat(configuration.getThreadPoolSize()).isEqualTo(THREAD_POOL_SIZE);
}
#end_block

#method_before
@Test
public void testValuesNotPresentInGerritConfig() throws Exception {
    buildMocks(false);
    assertThat(configuration.getUrl()).isEqualTo(EMPTY);
    assertThat(configuration.getUser()).isEqualTo(EMPTY);
    assertThat(configuration.getPassword()).isEqualTo(EMPTY);
    assertThat(configuration.getConnectionTimeout()).isEqualTo(0);
    assertThat(configuration.getSocketTimeout()).isEqualTo(0);
    assertThat(configuration.getMaxTries()).isEqualTo(0);
    assertThat(configuration.getRetryInterval()).isEqualTo(0);
}
#method_after
@Test
public void testValuesNotPresentInGerritConfig() throws Exception {
    buildMocks(false);
    assertThat(configuration.getUrl()).isEqualTo(EMPTY);
    assertThat(configuration.getUser()).isEqualTo(EMPTY);
    assertThat(configuration.getPassword()).isEqualTo(EMPTY);
    assertThat(configuration.getConnectionTimeout()).isEqualTo(0);
    assertThat(configuration.getSocketTimeout()).isEqualTo(0);
    assertThat(configuration.getMaxTries()).isEqualTo(0);
    assertThat(configuration.getRetryInterval()).isEqualTo(0);
    assertThat(configuration.getThreadPoolSize()).isEqualTo(0);
}
#end_block

#method_before
private void buildMocks(boolean values) {
    expect(configMock.getString("url")).andReturn(values ? URL : null);
    expect(configMock.getString("user")).andReturn(values ? USER : null);
    expect(configMock.getString("password")).andReturn(values ? PASS : null);
    expect(configMock.getInt("connectionTimeout", TIMEOUT)).andReturn(values ? TIMEOUT : 0);
    expect(configMock.getInt("socketTimeout", TIMEOUT)).andReturn(values ? TIMEOUT : 0);
    expect(configMock.getInt("maxTries", MAX_TRIES)).andReturn(values ? MAX_TRIES : 0);
    expect(configMock.getInt("retryInterval", RETRY_INTERVAL)).andReturn(values ? RETRY_INTERVAL : 0);
    replayAll();
    configuration = new Configuration(cfgFactoryMock, pluginName);
}
#method_after
private void buildMocks(boolean values) {
    expect(configMock.getString("url")).andReturn(values ? URL : null);
    expect(configMock.getString("user")).andReturn(values ? USER : null);
    expect(configMock.getString("password")).andReturn(values ? PASS : null);
    expect(configMock.getInt("connectionTimeout", TIMEOUT)).andReturn(values ? TIMEOUT : 0);
    expect(configMock.getInt("socketTimeout", TIMEOUT)).andReturn(values ? TIMEOUT : 0);
    expect(configMock.getInt("maxTries", MAX_TRIES)).andReturn(values ? MAX_TRIES : 0);
    expect(configMock.getInt("retryInterval", RETRY_INTERVAL)).andReturn(values ? RETRY_INTERVAL : 0);
    expect(configMock.getInt("threadPoolSize", THREAD_POOL_SIZE)).andReturn(values ? THREAD_POOL_SIZE : 0);
    replayAll();
    configuration = new Configuration(cfgFactoryMock, pluginName);
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    executorMock = createStrictMock(WorkQueue.Executor.class);
    WorkQueue workQueueMock = createNiceMock(WorkQueue.class);
    expect(workQueueMock.createQueue(1, "Sync remote index")).andReturn(executorMock);
    replayAll();
    syncIndexExecutorProvider = new SyncIndexExecutorProvider(workQueueMock);
}
#method_after
@Before
public void setUp() throws Exception {
    executorMock = createStrictMock(WorkQueue.Executor.class);
    WorkQueue workQueueMock = createNiceMock(WorkQueue.class);
    expect(workQueueMock.createQueue(4, "Sync remote index")).andReturn(executorMock);
    Configuration configMock = createStrictMock(Configuration.class);
    expect(configMock.getThreadPoolSize()).andReturn(4);
    replayAll();
    syncIndexExecutorProvider = new SyncIndexExecutorProvider(workQueueMock, configMock);
}
#end_block

#method_before
@Override
public void onShowView() {
    super.onShowView();
    Window.enableScrolling(false);
    JumpKeys.enable(false);
    if (prefs.hideTopMenu()) {
        Gerrit.setHeaderVisible(false);
    }
    resizeHandler = Window.addResizeHandler(new ResizeHandler() {

        @Override
        public void onResize(ResizeEvent event) {
            resizeCodeMirror();
        }
    });
}
#method_after
@Override
public void onShowView() {
    super.onShowView();
    Window.enableScrolling(false);
    if (prefs.hideTopMenu()) {
        Gerrit.setHeaderVisible(false);
    }
    resizeHandler = Window.addResizeHandler(new ResizeHandler() {

        @Override
        public void onResize(ResizeEvent event) {
            resizeCodeMirror();
        }
    });
}
#end_block

#method_before
@Override
protected void onUnload() {
    super.onUnload();
    removeKeyHandlerRegistrations();
    if (getCommentManager() != null) {
        CallbackGroup group = new CallbackGroup();
        getCommentManager().saveAllDrafts(group);
        group.done();
    }
    if (resizeHandler != null) {
        resizeHandler.removeHandler();
        resizeHandler = null;
    }
    for (CodeMirror cm : getCms()) {
        if (cm != null) {
            cm.getWrapperElement().removeFromParent();
        }
    }
    if (prefsAction != null) {
        prefsAction.hide();
    }
    Window.enableScrolling(true);
    Gerrit.setHeaderVisible(true);
    JumpKeys.enable(true);
}
#method_after
@Override
protected void onUnload() {
    super.onUnload();
    removeKeyHandlerRegistrations();
    if (getCommentManager() != null) {
        CallbackGroup group = new CallbackGroup();
        getCommentManager().saveAllDrafts(group);
        group.done();
    }
    if (resizeHandler != null) {
        resizeHandler.removeHandler();
        resizeHandler = null;
    }
    for (CodeMirror cm : getCms()) {
        if (cm != null) {
            cm.getWrapperElement().removeFromParent();
        }
    }
    if (prefsAction != null) {
        prefsAction.hide();
    }
    Window.enableScrolling(true);
    Gerrit.setHeaderVisible(true);
}
#end_block

#method_before
void registerCmEvents(final CodeMirror cm) {
    cm.on("cursorActivity", updateActiveLine(cm));
    cm.on("focus", updateActiveLine(cm));
    KeyMap keyMap = KeyMap.create().on("A", upToChange(true)).on("U", upToChange(false)).on("'['", header.navigate(Direction.PREV)).on("']'", header.navigate(Direction.NEXT)).on("R", header.toggleReviewed()).on("O", getCommentManager().toggleOpenBox(cm)).on("Enter", getCommentManager().toggleOpenBox(cm)).on("N", maybeNextVimSearch(cm)).on("E", openEditScreen(cm)).on("P", getChunkManager().diffChunkNav(cm, Direction.PREV)).on("Shift-M", header.reviewedAndNext()).on("Shift-N", maybePrevVimSearch(cm)).on("Shift-P", getCommentManager().commentNav(cm, Direction.PREV)).on("Shift-O", getCommentManager().openCloseAll(cm)).on("I", new Runnable() {

        @Override
        public void run() {
            switch(getIntraLineStatus()) {
                case OFF:
                case OK:
                    toggleShowIntraline();
                    break;
                case FAILURE:
                case TIMEOUT:
                default:
                    break;
            }
        }
    }).on("','", new Runnable() {

        @Override
        public void run() {
            prefsAction.show();
        }
    }).on("Shift-/", new Runnable() {

        @Override
        public void run() {
            new ShowHelpCommand().onKeyPress(null);
        }
    }).on("Space", new Runnable() {

        @Override
        public void run() {
            cm.vim().handleKey("<C-d>");
        }
    }).on("Shift-Space", new Runnable() {

        @Override
        public void run() {
            cm.vim().handleKey("<C-u>");
        }
    }).on("Ctrl-F", new Runnable() {

        @Override
        public void run() {
            cm.vim().handleKey("/");
        }
    }).on("Ctrl-A", new Runnable() {

        @Override
        public void run() {
            cm.execCommand("selectAll");
        }
    });
    if (revision.get() != 0) {
        cm.on("beforeSelectionChange", onSelectionChange(cm));
        cm.on("gutterClick", onGutterClick(cm));
        keyMap.on("C", getCommentManager().newDraftCallback(cm));
    }
    cm.addKeyMap(keyMap);
}
#method_after
void registerCmEvents(final CodeMirror cm) {
    cm.on("cursorActivity", updateActiveLine(cm));
    cm.on("focus", updateActiveLine(cm));
    KeyMap keyMap = KeyMap.create().on("A", upToChange(true)).on("U", upToChange(false)).on("'['", header.navigate(Direction.PREV)).on("']'", header.navigate(Direction.NEXT)).on("R", header.toggleReviewed()).on("O", getCommentManager().toggleOpenBox(cm)).on("Enter", getCommentManager().toggleOpenBox(cm)).on("N", maybeNextVimSearch(cm)).on("Ctrl-Alt-E", openEditScreen(cm)).on("P", getChunkManager().diffChunkNav(cm, Direction.PREV)).on("Shift-M", header.reviewedAndNext()).on("Shift-N", maybePrevVimSearch(cm)).on("Shift-P", getCommentManager().commentNav(cm, Direction.PREV)).on("Shift-O", getCommentManager().openCloseAll(cm)).on("I", new Runnable() {

        @Override
        public void run() {
            switch(getIntraLineStatus()) {
                case OFF:
                case OK:
                    toggleShowIntraline();
                    break;
                case FAILURE:
                case TIMEOUT:
                default:
                    break;
            }
        }
    }).on("','", new Runnable() {

        @Override
        public void run() {
            prefsAction.show();
        }
    }).on("Shift-/", new Runnable() {

        @Override
        public void run() {
            new ShowHelpCommand().onKeyPress(null);
        }
    }).on("Space", new Runnable() {

        @Override
        public void run() {
            cm.vim().handleKey("<C-d>");
        }
    }).on("Shift-Space", new Runnable() {

        @Override
        public void run() {
            cm.vim().handleKey("<C-u>");
        }
    }).on("Ctrl-F", new Runnable() {

        @Override
        public void run() {
            cm.vim().handleKey("/");
        }
    }).on("Ctrl-A", new Runnable() {

        @Override
        public void run() {
            cm.execCommand("selectAll");
        }
    }).on("G O", new Runnable() {

        @Override
        public void run() {
            Gerrit.display(PageLinks.toChangeQuery("status:open"));
        }
    }).on("G M", new Runnable() {

        @Override
        public void run() {
            Gerrit.display(PageLinks.toChangeQuery("status:merged"));
        }
    }).on("G A", new Runnable() {

        @Override
        public void run() {
            Gerrit.display(PageLinks.toChangeQuery("status:abandoned"));
        }
    });
    if (Gerrit.isSignedIn()) {
        keyMap.on("G I", new Runnable() {

            @Override
            public void run() {
                Gerrit.display(PageLinks.MINE);
            }
        }).on("G D", new Runnable() {

            @Override
            public void run() {
                Gerrit.display(PageLinks.toChangeQuery("owner:self is:draft"));
            }
        }).on("G C", new Runnable() {

            @Override
            public void run() {
                Gerrit.display(PageLinks.toChangeQuery("has:draft"));
            }
        }).on("G W", new Runnable() {

            @Override
            public void run() {
                Gerrit.display(PageLinks.toChangeQuery("is:watched status:open"));
            }
        }).on("G S", new Runnable() {

            @Override
            public void run() {
                Gerrit.display(PageLinks.toChangeQuery("is:starred"));
            }
        });
    }
    if (revision.get() != 0) {
        cm.on("beforeSelectionChange", onSelectionChange(cm));
        cm.on("gutterClick", onGutterClick(cm));
        keyMap.on("C", getCommentManager().newDraftCallback(cm));
    }
    // Needed to for multi-stroke keymaps
    CodeMirror.normalizeKeyMap(keyMap);
    cm.addKeyMap(keyMap);
}
#end_block

#method_before
@Override
public void registerKeys() {
    super.registerKeys();
    keysNavigation.add(new UpToChangeCommand(revision, 0, 'u'));
    keysNavigation.add(new NoOpKeyCommand(0, 'j', PatchUtil.C.lineNext()), new NoOpKeyCommand(0, 'k', PatchUtil.C.linePrev()));
    keysNavigation.add(new NoOpKeyCommand(0, 'n', PatchUtil.C.chunkNext()), new NoOpKeyCommand(0, 'p', PatchUtil.C.chunkPrev()));
    keysNavigation.add(new NoOpKeyCommand(KeyCommand.M_SHIFT, 'n', PatchUtil.C.commentNext()), new NoOpKeyCommand(KeyCommand.M_SHIFT, 'p', PatchUtil.C.commentPrev()));
    keysNavigation.add(new NoOpKeyCommand(KeyCommand.M_CTRL, 'f', Gerrit.C.keySearch()));
    keysAction = new KeyCommandSet(Gerrit.C.sectionActions());
    keysAction.add(new NoOpKeyCommand(0, KeyCodes.KEY_ENTER, PatchUtil.C.expandComment()));
    keysAction.add(new NoOpKeyCommand(0, 'o', PatchUtil.C.expandComment()));
    keysAction.add(new NoOpKeyCommand(KeyCommand.M_SHIFT, 'o', PatchUtil.C.expandAllCommentsOnCurrentLine()));
    if (Gerrit.isSignedIn()) {
        keysAction.add(new KeyCommand(0, 'r', PatchUtil.C.toggleReviewed()) {

            @Override
            public void onKeyPress(KeyPressEvent event) {
                header.toggleReviewed().run();
            }
        });
    }
    keysAction.add(new KeyCommand(KeyCommand.M_SHIFT, 'm', PatchUtil.C.markAsReviewedAndGoToNext()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            header.reviewedAndNext().run();
        }
    });
    keysAction.add(new KeyCommand(0, 'a', PatchUtil.C.openReply()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            upToChange(true).run();
        }
    });
    keysAction.add(new KeyCommand(0, ',', PatchUtil.C.showPreferences()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            prefsAction.show();
        }
    });
    if (getIntraLineStatus() == DiffInfo.IntraLineStatus.OFF || getIntraLineStatus() == DiffInfo.IntraLineStatus.OK) {
        keysAction.add(new KeyCommand(0, 'i', PatchUtil.C.toggleIntraline()) {

            @Override
            public void onKeyPress(KeyPressEvent event) {
                toggleShowIntraline();
            }
        });
    }
    if (Gerrit.isSignedIn()) {
        keysAction.add(new NoOpKeyCommand(0, 'c', PatchUtil.C.commentInsert()));
        keysComment = new KeyCommandSet(PatchUtil.C.commentEditorSet());
        keysComment.add(new NoOpKeyCommand(KeyCommand.M_CTRL, 's', PatchUtil.C.commentSaveDraft()));
        keysComment.add(new NoOpKeyCommand(0, KeyCodes.KEY_ESCAPE, PatchUtil.C.commentCancelEdit()));
    } else {
        keysComment = null;
    }
}
#method_after
@Override
public void registerKeys() {
    super.registerKeys();
    keysNavigation.add(new UpToChangeCommand(revision, 0, 'u'));
    keysNavigation.add(new NoOpKeyCommand(0, 'j', PatchUtil.C.lineNext()), new NoOpKeyCommand(0, 'k', PatchUtil.C.linePrev()));
    keysNavigation.add(new NoOpKeyCommand(0, 'n', PatchUtil.C.chunkNext()), new NoOpKeyCommand(0, 'p', PatchUtil.C.chunkPrev()));
    keysNavigation.add(new NoOpKeyCommand(KeyCommand.M_SHIFT, 'n', PatchUtil.C.commentNext()), new NoOpKeyCommand(KeyCommand.M_SHIFT, 'p', PatchUtil.C.commentPrev()));
    keysNavigation.add(new NoOpKeyCommand(KeyCommand.M_CTRL, 'f', Gerrit.C.keySearch()));
    keysAction = new KeyCommandSet(Gerrit.C.sectionActions());
    keysAction.add(new NoOpKeyCommand(0, KeyCodes.KEY_ENTER, PatchUtil.C.expandComment()));
    keysAction.add(new NoOpKeyCommand(0, 'o', PatchUtil.C.expandComment()));
    keysAction.add(new NoOpKeyCommand(KeyCommand.M_SHIFT, 'o', PatchUtil.C.expandAllCommentsOnCurrentLine()));
    if (Gerrit.isSignedIn()) {
        keysAction.add(new KeyCommand(0, 'r', PatchUtil.C.toggleReviewed()) {

            @Override
            public void onKeyPress(KeyPressEvent event) {
                header.toggleReviewed().run();
            }
        });
        keysAction.add(new NoOpKeyCommand(KeyCommand.M_CTRL | KeyCommand.M_ALT, 'e', Gerrit.C.keyEditor()));
    }
    keysAction.add(new KeyCommand(KeyCommand.M_SHIFT, 'm', PatchUtil.C.markAsReviewedAndGoToNext()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            header.reviewedAndNext().run();
        }
    });
    keysAction.add(new KeyCommand(0, 'a', PatchUtil.C.openReply()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            upToChange(true).run();
        }
    });
    keysAction.add(new KeyCommand(0, ',', PatchUtil.C.showPreferences()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            prefsAction.show();
        }
    });
    if (getIntraLineStatus() == DiffInfo.IntraLineStatus.OFF || getIntraLineStatus() == DiffInfo.IntraLineStatus.OK) {
        keysAction.add(new KeyCommand(0, 'i', PatchUtil.C.toggleIntraline()) {

            @Override
            public void onKeyPress(KeyPressEvent event) {
                toggleShowIntraline();
            }
        });
    }
    if (Gerrit.isSignedIn()) {
        keysAction.add(new NoOpKeyCommand(0, 'c', PatchUtil.C.commentInsert()));
        keysComment = new KeyCommandSet(PatchUtil.C.commentEditorSet());
        keysComment.add(new NoOpKeyCommand(KeyCommand.M_CTRL, 's', PatchUtil.C.commentSaveDraft()));
        keysComment.add(new NoOpKeyCommand(0, KeyCodes.KEY_ESCAPE, PatchUtil.C.commentCancelEdit()));
    } else {
        keysComment = null;
    }
}
#end_block

#method_before
private List<Destination> allDestinations() throws ConfigInvalidException, IOException {
    if (!config.getFile().exists()) {
        log.warn("Config file " + config.getFile() + " does not exist; not replicating");
        return Collections.emptyList();
    }
    if (config.getFile().length() == 0) {
        log.info("Config file " + config.getFile() + " is empty; not replicating");
        return Collections.emptyList();
    }
    try {
        config.load();
    } catch (ConfigInvalidException e) {
        throw new ConfigInvalidException(String.format("Config file %s is invalid: %s", config.getFile(), e.getMessage()), e);
    } catch (IOException e) {
        throw new IOException(String.format("Cannot read %s: %s", config.getFile(), e.getMessage()), e);
    }
    replicateAllOnPluginStart = config.getBoolean("gerrit", "replicateOnStartup", true);
    defaultForceUpdate = config.getBoolean("gerrit", "defaultForceUpdate", false);
    ImmutableList.Builder<Destination> dest = ImmutableList.builder();
    for (RemoteConfig c : allRemotes(config)) {
        if (c.getURIs().isEmpty()) {
            continue;
        }
        // If destination for push is not set assume equal to source.
        for (RefSpec ref : c.getPushRefSpecs()) {
            if (ref.getDestination() == null) {
                ref.setDestination(ref.getSource());
            }
        }
        if (c.getPushRefSpecs().isEmpty()) {
            c.addPushRefSpec(new RefSpec().setSourceDestination("refs/*", "refs/*").setForceUpdate(defaultForceUpdate));
        }
        Destination destination = new Destination(injector, c, new DefaultDestinationConfiguration(c, config), replicationUserFactory, pluginUser, gitRepositoryManager, groupBackend, stateLog, groupIncludeCache);
        if (!destination.isSingleProjectMatch()) {
            for (URIish u : c.getURIs()) {
                if (u.getPath() == null || !u.getPath().contains("${name}")) {
                    throw new ConfigInvalidException(String.format("remote.%s.url \"%s\" lacks ${name} placeholder in %s", c.getName(), u, config.getFile()));
                }
            }
        }
        dest.add(destination);
    }
    return dest.build();
}
#method_after
private List<Destination> allDestinations() throws ConfigInvalidException, IOException {
    if (!config.getFile().exists()) {
        log.warn("Config file " + config.getFile() + " does not exist; not replicating");
        return Collections.emptyList();
    }
    if (config.getFile().length() == 0) {
        log.info("Config file " + config.getFile() + " is empty; not replicating");
        return Collections.emptyList();
    }
    try {
        config.load();
    } catch (ConfigInvalidException e) {
        throw new ConfigInvalidException(String.format("Config file %s is invalid: %s", config.getFile(), e.getMessage()), e);
    } catch (IOException e) {
        throw new IOException(String.format("Cannot read %s: %s", config.getFile(), e.getMessage()), e);
    }
    replicateAllOnPluginStart = config.getBoolean("gerrit", "replicateOnStartup", true);
    defaultForceUpdate = config.getBoolean("gerrit", "defaultForceUpdate", false);
    ImmutableList.Builder<Destination> dest = ImmutableList.builder();
    for (RemoteConfig c : allRemotes(config)) {
        if (c.getURIs().isEmpty()) {
            continue;
        }
        // If destination for push is not set assume equal to source.
        for (RefSpec ref : c.getPushRefSpecs()) {
            if (ref.getDestination() == null) {
                ref.setDestination(ref.getSource());
            }
        }
        if (c.getPushRefSpecs().isEmpty()) {
            c.addPushRefSpec(new RefSpec().setSourceDestination("refs/*", "refs/*").setForceUpdate(defaultForceUpdate));
        }
        Destination destination = new Destination(injector, new DestinationConfiguration(c, config), replicationUserFactory, pluginUser, gitRepositoryManager, groupBackend, stateLog, groupIncludeCache);
        if (!destination.isSingleProjectMatch()) {
            for (URIish u : c.getURIs()) {
                if (u.getPath() == null || !u.getPath().contains("${name}")) {
                    throw new ConfigInvalidException(String.format("remote.%s.url \"%s\" lacks ${name} placeholder in %s", c.getName(), u, config.getFile()));
                }
            }
        }
        dest.add(destination);
    }
    return dest.build();
}
#end_block

#method_before
public void start(WorkQueue workQueue) {
    pool = workQueue.createQueue(config.getPoolThreads(), poolName);
}
#method_after
public void start(WorkQueue workQueue) {
    String poolName = "ReplicateTo-" + config.getRemoteConfig().getName();
    pool = workQueue.createQueue(config.getPoolThreads(), poolName);
}
#end_block

#method_before
private boolean isVisible(final Project.NameKey project, ReplicationState... states) {
    try {
        return threadScoper.scope(new Callable<Boolean>() {

            @Override
            public Boolean call() throws NoSuchProjectException {
                return controlFor(project).isVisible();
            }
        }).call();
    } catch (NoSuchProjectException err) {
        stateLog.error(String.format("source project %s not available", project), err, states);
    } catch (Exception e) {
        throw Throwables.propagate(e);
    }
    return false;
}
#method_after
private boolean isVisible(final Project.NameKey project, ReplicationState... states) {
    try {
        return threadScoper.scope(new Callable<Boolean>() {

            @Override
            public Boolean call() throws NoSuchProjectException {
                return controlFor(project).isVisible();
            }
        }).call();
    } catch (NoSuchProjectException err) {
        stateLog.error(String.format("source project %s not available", project), err, states);
    } catch (Exception e) {
        Throwables.propagateIfPossible(e);
        throw new RuntimeException(e);
    }
    return false;
}
#end_block

#method_before
void schedule(final Project.NameKey project, final String ref, final URIish uri, ReplicationState state) {
    repLog.info("scheduling replication {}:{} => {}", project, ref, uri);
    if (!isVisible(project, state)) {
        return;
    }
    if (!config.replicatePermissions()) {
        PushOne e;
        synchronized (stateLock) {
            e = pending.get(uri);
        }
        if (e == null) {
            try (Repository git = gitManager.openRepository(project)) {
                try {
                    Ref head = git.exactRef(Constants.HEAD);
                    if (head != null && head.isSymbolic() && RefNames.REFS_CONFIG.equals(head.getLeaf().getName())) {
                        return;
                    }
                } catch (IOException err) {
                    stateLog.error(String.format("cannot check type of project %s", project), err, state);
                    return;
                }
            } catch (IOException err) {
                stateLog.error(String.format("source project %s not available", project), err, state);
                return;
            }
        }
    }
    synchronized (stateLock) {
        PushOne e = pending.get(uri);
        if (e == null) {
            e = opFactory.create(project, uri);
            pool.schedule(e, config.getDelay(), TimeUnit.SECONDS);
            pending.put(uri, e);
        }
        e.addRef(ref);
        state.increasePushTaskCount(project.get(), ref);
        e.addState(ref, state);
        repLog.info("scheduled {}:{} => {} to run after {}s", project, ref, e, config.getDelay());
    }
}
#method_after
void schedule(Project.NameKey project, String ref, URIish uri, ReplicationState state) {
    repLog.info("scheduling replication {}:{} => {}", project, ref, uri);
    if (!isVisible(project, state)) {
        return;
    }
    if (!config.replicatePermissions()) {
        PushOne e;
        synchronized (stateLock) {
            e = pending.get(uri);
        }
        if (e == null) {
            try (Repository git = gitManager.openRepository(project)) {
                try {
                    Ref head = git.exactRef(Constants.HEAD);
                    if (head != null && head.isSymbolic() && RefNames.REFS_CONFIG.equals(head.getLeaf().getName())) {
                        return;
                    }
                } catch (IOException err) {
                    stateLog.error(String.format("cannot check type of project %s", project), err, state);
                    return;
                }
            } catch (IOException err) {
                stateLog.error(String.format("source project %s not available", project), err, state);
                return;
            }
        }
    }
    synchronized (stateLock) {
        PushOne e = pending.get(uri);
        if (e == null) {
            e = opFactory.create(project, uri);
            pool.schedule(e, config.getDelay(), TimeUnit.SECONDS);
            pending.put(uri, e);
        }
        e.addRef(ref);
        state.increasePushTaskCount(project.get(), ref);
        e.addState(ref, state);
        repLog.info("scheduled {}:{} => {} to run after {}s", project, ref, e, config.getDelay());
    }
}
#end_block

#method_before
boolean wouldPushProject(final Project.NameKey project) {
    if (!isVisible(project)) {
        return false;
    }
    // by default push all projects
    String[] projects = config.getProjects();
    if (projects.length < 1) {
        return true;
    }
    return (new ReplicationFilter(Arrays.asList(projects))).matches(project);
}
#method_after
boolean wouldPushProject(Project.NameKey project) {
    if (!isVisible(project)) {
        return false;
    }
    // by default push all projects
    String[] projects = config.getProjects();
    if (projects.length < 1) {
        return true;
    }
    return (new ReplicationFilter(Arrays.asList(projects))).matches(project);
}
#end_block

#method_before
boolean wouldPushRef(String ref) {
    if (!config.replicatePermissions() && RefNames.REFS_CONFIG.equals(ref)) {
        return false;
    }
    for (RefSpec s : remote.getPushRefSpecs()) {
        if (s.matchSource(ref)) {
            return true;
        }
    }
    return false;
}
#method_after
boolean wouldPushRef(String ref) {
    if (!config.replicatePermissions() && RefNames.REFS_CONFIG.equals(ref)) {
        return false;
    }
    for (RefSpec s : config.getRemoteConfig().getPushRefSpecs()) {
        if (s.matchSource(ref)) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
List<URIish> getURIs(Project.NameKey project, String urlMatch) {
    List<URIish> r = Lists.newArrayListWithCapacity(remote.getURIs().size());
    for (URIish uri : remote.getURIs()) {
        if (matches(uri, urlMatch)) {
            String name = project.get();
            if (needsUrlEncoding(uri)) {
                name = encode(name);
            }
            String remoteNameStyle = config.getRemoteNameStyle();
            if (remoteNameStyle.equals("dash")) {
                name = name.replace("/", "-");
            } else if (remoteNameStyle.equals("underscore")) {
                name = name.replace("/", "_");
            } else if (remoteNameStyle.equals("basenameOnly")) {
                name = FilenameUtils.getBaseName(name);
            } else if (!remoteNameStyle.equals("slash")) {
                repLog.debug(String.format("Unknown remoteNameStyle: %s, falling back to slash", remoteNameStyle));
            }
            String replacedPath = ReplicationQueue.replaceName(uri.getPath(), name, isSingleProjectMatch());
            if (replacedPath != null) {
                uri = uri.setPath(replacedPath);
                r.add(uri);
            }
        }
    }
    return r;
}
#method_after
List<URIish> getURIs(Project.NameKey project, String urlMatch) {
    List<URIish> r = Lists.newArrayListWithCapacity(config.getRemoteConfig().getURIs().size());
    for (URIish uri : config.getRemoteConfig().getURIs()) {
        if (matches(uri, urlMatch)) {
            String name = project.get();
            if (needsUrlEncoding(uri)) {
                name = encode(name);
            }
            String remoteNameStyle = config.getRemoteNameStyle();
            if (remoteNameStyle.equals("dash")) {
                name = name.replace("/", "-");
            } else if (remoteNameStyle.equals("underscore")) {
                name = name.replace("/", "_");
            } else if (remoteNameStyle.equals("basenameOnly")) {
                name = FilenameUtils.getBaseName(name);
            } else if (!remoteNameStyle.equals("slash")) {
                repLog.debug(String.format("Unknown remoteNameStyle: %s, falling back to slash", remoteNameStyle));
            }
            String replacedPath = ReplicationQueue.replaceName(uri.getPath(), name, isSingleProjectMatch());
            if (replacedPath != null) {
                uri = uri.setPath(replacedPath);
                r.add(uri);
            }
        }
    }
    return r;
}
#end_block

#method_before
private void verifyComment(PatchLineComment c) {
    checkArgument(c.getRevId() != null);
    checkArgument(c.getAuthor().equals(getUser().getAccountId()), "The author for the following comment does not match the author of" + " this ChangeDraftUpdate (%s): %s", getUser().getAccountId(), c);
}
#method_after
private void verifyComment(PatchLineComment c) {
    checkArgument(c.getRevId() != null, "RevId required for comment: %s", c);
    checkArgument(c.getAuthor().equals(getUser().getAccountId()), "The author for the following comment does not match the author of" + " this ChangeDraftUpdate (%s): %s", getUser().getAccountId(), c);
}
#end_block

#method_before
@Test
public void applyDeltaToNullWithNoNewMetaId() {
    Change c = newChange();
    assertThat(c.getNoteDbState()).isNull();
    applyDelta(c, new Delta(c.getId(), noMetaId(), noDrafts()));
    assertThat(c.getNoteDbState()).isNull();
    applyDelta(c, new Delta(c.getId(), noMetaId(), drafts(new Account.Id(1001), zeroId())));
    assertThat(c.getNoteDbState()).isNull();
}
#method_after
@Test
public void applyDeltaToNullWithNoNewMetaId() {
    Change c = newChange();
    assertThat(c.getNoteDbState()).isNull();
    applyDelta(c, Delta.create(c.getId(), noMetaId(), noDrafts()));
    assertThat(c.getNoteDbState()).isNull();
    applyDelta(c, Delta.create(c.getId(), noMetaId(), drafts(new Account.Id(1001), zeroId())));
    assertThat(c.getNoteDbState()).isNull();
}
#end_block

#method_before
@Test
public void applyDeltaToMetaId() {
    Change c = newChange();
    applyDelta(c, new Delta(c.getId(), metaId(SHA1), noDrafts()));
    assertThat(c.getNoteDbState()).isEqualTo(SHA1.name());
    applyDelta(c, new Delta(c.getId(), metaId(SHA2), noDrafts()));
    assertThat(c.getNoteDbState()).isEqualTo(SHA2.name());
    // No-op delta.
    applyDelta(c, new Delta(c.getId(), noMetaId(), noDrafts()));
    assertThat(c.getNoteDbState()).isEqualTo(SHA2.name());
    // Set to zero clears the field.
    applyDelta(c, new Delta(c.getId(), metaId(zeroId()), noDrafts()));
    assertThat(c.getNoteDbState()).isNull();
}
#method_after
@Test
public void applyDeltaToMetaId() {
    Change c = newChange();
    applyDelta(c, Delta.create(c.getId(), metaId(SHA1), noDrafts()));
    assertThat(c.getNoteDbState()).isEqualTo(SHA1.name());
    applyDelta(c, Delta.create(c.getId(), metaId(SHA2), noDrafts()));
    assertThat(c.getNoteDbState()).isEqualTo(SHA2.name());
    // No-op delta.
    applyDelta(c, Delta.create(c.getId(), noMetaId(), noDrafts()));
    assertThat(c.getNoteDbState()).isEqualTo(SHA2.name());
    // Set to zero clears the field.
    applyDelta(c, Delta.create(c.getId(), metaId(zeroId()), noDrafts()));
    assertThat(c.getNoteDbState()).isNull();
}
#end_block

#method_before
@Test
public void applyDeltaToDrafts() {
    Change c = newChange();
    applyDelta(c, new Delta(c.getId(), metaId(SHA1), drafts(new Account.Id(1001), SHA2)));
    assertThat(c.getNoteDbState()).isEqualTo(SHA1.name() + ",1001=" + SHA2.name());
    applyDelta(c, new Delta(c.getId(), noMetaId(), drafts(new Account.Id(2003), SHA3)));
    assertThat(c.getNoteDbState()).isEqualTo(SHA1.name() + ",1001=" + SHA2.name() + ",2003=" + SHA3.name());
    applyDelta(c, new Delta(c.getId(), noMetaId(), drafts(new Account.Id(2003), zeroId())));
    assertThat(c.getNoteDbState()).isEqualTo(SHA1.name() + ",1001=" + SHA2.name());
    applyDelta(c, new Delta(c.getId(), metaId(SHA3), noDrafts()));
    assertThat(c.getNoteDbState()).isEqualTo(SHA3.name() + ",1001=" + SHA2.name());
}
#method_after
@Test
public void applyDeltaToDrafts() {
    Change c = newChange();
    applyDelta(c, Delta.create(c.getId(), metaId(SHA1), drafts(new Account.Id(1001), SHA2)));
    assertThat(c.getNoteDbState()).isEqualTo(SHA1.name() + ",1001=" + SHA2.name());
    applyDelta(c, Delta.create(c.getId(), noMetaId(), drafts(new Account.Id(2003), SHA3)));
    assertThat(c.getNoteDbState()).isEqualTo(SHA1.name() + ",1001=" + SHA2.name() + ",2003=" + SHA3.name());
    applyDelta(c, Delta.create(c.getId(), noMetaId(), drafts(new Account.Id(2003), zeroId())));
    assertThat(c.getNoteDbState()).isEqualTo(SHA1.name() + ",1001=" + SHA2.name());
    applyDelta(c, Delta.create(c.getId(), metaId(SHA3), noDrafts()));
    assertThat(c.getNoteDbState()).isEqualTo(SHA3.name() + ",1001=" + SHA2.name());
}
#end_block

#method_before
public ChangeUpdate getUpdate(PatchSet.Id psId) {
    ChangeUpdate u = updates.get(psId);
    if (u == null) {
        u = changeUpdateFactory.create(ctl, when);
        u.setPatchSetId(psId);
        updates.put(psId, u);
    }
    return u;
}
#method_after
public ChangeUpdate getUpdate(PatchSet.Id psId) {
    ChangeUpdate u = updates.get(psId);
    if (u == null) {
        u = changeUpdateFactory.create(ctl, when);
        if (newChanges.containsKey(ctl.getId())) {
            u.setAllowWriteToNewRef(true);
        }
        u.setPatchSetId(psId);
        updates.put(psId, u);
    }
    return u;
}
#end_block

#method_before
private void executeChangeOps() throws UpdateException, RestApiException {
    try {
        for (Map.Entry<Change.Id, Collection<Op>> e : ops.asMap().entrySet()) {
            Change.Id id = e.getKey();
            db.changes().beginTransaction(id);
            ChangeContext ctx;
            NoteDbUpdateManager updateManager = null;
            boolean dirty = false;
            try {
                ctx = newChangeContext(id);
                // Call updateChange on each op.
                for (Op op : e.getValue()) {
                    dirty |= op.updateChange(ctx);
                }
                if (!dirty) {
                    return;
                }
                // Stage the NoteDb update and store its state in the Change.
                if (ctx.deleted) {
                    if (notesMigration.writeChanges()) {
                        new ChangeDelete(plcUtil, getRepository(), ctx.getNotes()).delete();
                    }
                } else {
                    if (notesMigration.writeChanges()) {
                        updateManager = updateManagerFactory.create(ctx.getProject());
                        for (ChangeUpdate u : ctx.updates.values()) {
                            updateManager.add(u);
                        }
                        NoteDbChangeState.applyDelta(ctx.getChange(), updateManager.stage().get(id));
                    }
                }
                // Bump lastUpdatedOn or rowVersion and commit.
                if (newChanges.containsKey(id)) {
                    db.changes().insert(bumpLastUpdatedOn(ctx));
                } else if (ctx.saved) {
                    db.changes().update(bumpLastUpdatedOn(ctx));
                } else if (ctx.deleted) {
                    db.changes().delete(bumpLastUpdatedOn(ctx));
                } else {
                    db.changes().update(bumpRowVersionNotLastUpdatedOn(ctx));
                }
                db.commit();
            } finally {
                db.rollback();
            }
            // Execute NoteDb updates after committing ReviewDb updates.
            if (updateManager != null) {
                updateManager.execute();
            }
            // Reindex changes.
            if (ctx.deleted) {
                indexFutures.add(indexer.deleteAsync(id));
            } else {
                indexFutures.add(indexer.indexAsync(ctx.getProject(), id));
            }
        }
    } catch (Exception e) {
        Throwables.propagateIfPossible(e, RestApiException.class);
        throw new UpdateException(e);
    }
}
#method_after
private void executeChangeOps() throws UpdateException, RestApiException {
    try {
        for (Map.Entry<Change.Id, Collection<Op>> e : ops.asMap().entrySet()) {
            Change.Id id = e.getKey();
            db.changes().beginTransaction(id);
            ChangeContext ctx;
            NoteDbUpdateManager updateManager = null;
            boolean dirty = false;
            try {
                ctx = newChangeContext(id);
                // Call updateChange on each op.
                for (Op op : e.getValue()) {
                    dirty |= op.updateChange(ctx);
                }
                if (!dirty) {
                    return;
                }
                // Stage the NoteDb update and store its state in the Change.
                if (!ctx.deleted && notesMigration.writeChanges()) {
                    updateManager = updateManagerFactory.create(ctx.getProject());
                    for (ChangeUpdate u : ctx.updates.values()) {
                        updateManager.add(u);
                    }
                    NoteDbChangeState.applyDelta(ctx.getChange(), updateManager.stage().get(id));
                }
                // Bump lastUpdatedOn or rowVersion and commit.
                if (newChanges.containsKey(id)) {
                    db.changes().insert(bumpLastUpdatedOn(ctx));
                } else if (ctx.saved) {
                    db.changes().update(bumpLastUpdatedOn(ctx));
                } else if (ctx.deleted) {
                    db.changes().delete(bumpLastUpdatedOn(ctx));
                } else {
                    db.changes().update(bumpRowVersionNotLastUpdatedOn(ctx));
                }
                db.commit();
            } finally {
                db.rollback();
            }
            // Execute NoteDb updates after committing ReviewDb updates.
            if (notesMigration.writeChanges()) {
                if (updateManager != null) {
                    updateManager.execute();
                }
                if (ctx.deleted) {
                    new ChangeDelete(plcUtil, getRepository(), ctx.getNotes()).delete();
                }
            }
            // Reindex changes.
            if (ctx.deleted) {
                indexFutures.add(indexer.deleteAsync(id));
            } else {
                indexFutures.add(indexer.indexAsync(ctx.getProject(), id));
            }
        }
    } catch (Exception e) {
        Throwables.propagateIfPossible(e, RestApiException.class);
        throw new UpdateException(e);
    }
}
#end_block

#method_before
@Test
public void changeFields() throws Exception {
    PushOneCommit.Result r = createChange();
    Change.Id id = r.getPatchSetId().getParentKey();
    gApi.changes().id(id.get()).topic(name("a-topic"));
    checker.checkChanges(id);
}
#method_after
@Test
public void changeFields() throws Exception {
    PushOneCommit.Result r = createChange();
    Change.Id id = r.getPatchSetId().getParentKey();
    gApi.changes().id(id.get()).topic(name("a-topic"));
    checker.rebuildAndCheckChanges(id);
}
#end_block

#method_before
@Test
public void patchSets() throws Exception {
    PushOneCommit.Result r = createChange();
    Change.Id id = r.getPatchSetId().getParentKey();
    r = amendChange(r.getChangeId());
    checker.checkChanges(id);
}
#method_after
@Test
public void patchSets() throws Exception {
    PushOneCommit.Result r = createChange();
    Change.Id id = r.getPatchSetId().getParentKey();
    r = amendChange(r.getChangeId());
    checker.rebuildAndCheckChanges(id);
}
#end_block

#method_before
@Test
public void noteDbChangeState() throws Exception {
    notesMigration.setAllEnabled(true);
    PushOneCommit.Result r = createChange();
    Change.Id id = r.getPatchSetId().getParentKey();
    ObjectId changeMetaId = getMetaRef(project, ChangeNoteUtil.changeRefName(id));
    assertThat(db.changes().get(id).getNoteDbState()).isEqualTo(changeMetaId.name());
    DraftInput in = new DraftInput();
    in.line = 1;
    in.message = "comment by user";
    in.path = PushOneCommit.FILE_NAME;
    setApiUser(user);
    gApi.changes().id(id.get()).current().createDraft(in);
    ObjectId userDraftsId = getMetaRef(allUsers, RefNames.refsDraftComments(user.getId(), id));
    assertThat(db.changes().get(id).getNoteDbState()).isEqualTo(changeMetaId.name() + "," + user.getId() + "=" + userDraftsId.name());
    in = new DraftInput();
    in.line = 2;
    in.message = "comment by admin";
    in.path = PushOneCommit.FILE_NAME;
    setApiUser(admin);
    gApi.changes().id(id.get()).current().createDraft(in);
    ObjectId adminDraftsId = getMetaRef(allUsers, RefNames.refsDraftComments(admin.getId(), id));
    assertThat(admin.getId().get()).isLessThan(user.getId().get());
    assertThat(db.changes().get(id).getNoteDbState()).isEqualTo(changeMetaId.name() + "," + admin.getId() + "=" + adminDraftsId.name() + "," + user.getId() + "=" + userDraftsId.name());
    in.message = "revised comment by admin";
    gApi.changes().id(id.get()).current().createDraft(in);
    adminDraftsId = getMetaRef(allUsers, RefNames.refsDraftComments(admin.getId(), id));
    assertThat(db.changes().get(id).getNoteDbState()).isEqualTo(changeMetaId.name() + "," + admin.getId() + "=" + adminDraftsId.name() + "," + user.getId() + "=" + userDraftsId.name());
}
#method_after
@Test
public void noteDbChangeState() throws Exception {
    notesMigration.setAllEnabled(true);
    PushOneCommit.Result r = createChange();
    Change.Id id = r.getPatchSetId().getParentKey();
    ObjectId changeMetaId = getMetaRef(project, ChangeNoteUtil.changeRefName(id));
    assertThat(unwrapDb().changes().get(id).getNoteDbState()).isEqualTo(changeMetaId.name());
    DraftInput in = new DraftInput();
    in.line = 1;
    in.message = "comment by user";
    in.path = PushOneCommit.FILE_NAME;
    setApiUser(user);
    gApi.changes().id(id.get()).current().createDraft(in);
    ObjectId userDraftsId = getMetaRef(allUsers, RefNames.refsDraftComments(user.getId(), id));
    assertThat(unwrapDb().changes().get(id).getNoteDbState()).isEqualTo(changeMetaId.name() + "," + user.getId() + "=" + userDraftsId.name());
    in = new DraftInput();
    in.line = 2;
    in.message = "comment by admin";
    in.path = PushOneCommit.FILE_NAME;
    setApiUser(admin);
    gApi.changes().id(id.get()).current().createDraft(in);
    ObjectId adminDraftsId = getMetaRef(allUsers, RefNames.refsDraftComments(admin.getId(), id));
    assertThat(admin.getId().get()).isLessThan(user.getId().get());
    assertThat(unwrapDb().changes().get(id).getNoteDbState()).isEqualTo(changeMetaId.name() + "," + admin.getId() + "=" + adminDraftsId.name() + "," + user.getId() + "=" + userDraftsId.name());
    in.message = "revised comment by admin";
    gApi.changes().id(id.get()).current().createDraft(in);
    adminDraftsId = getMetaRef(allUsers, RefNames.refsDraftComments(admin.getId(), id));
    assertThat(unwrapDb().changes().get(id).getNoteDbState()).isEqualTo(changeMetaId.name() + "," + admin.getId() + "=" + adminDraftsId.name() + "," + user.getId() + "=" + userDraftsId.name());
}
#end_block

#method_before
@VisibleForTesting
static NoteDbChangeState parse(Change.Id id, String str) {
    if (str == null) {
        return null;
    }
    List<String> parts = Splitter.on(',').splitToList(str);
    checkArgument(!parts.isEmpty(), "invalid state string: %s", str);
    ObjectId changeMetaId = ObjectId.fromString(parts.get(0));
    Map<Account.Id, ObjectId> draftIds = Maps.newHashMapWithExpectedSize(parts.size());
    Splitter s = Splitter.on('=');
    for (int i = 1; i < parts.size(); i++) {
        String p = parts.get(i);
        List<String> draftParts = s.splitToList(p);
        checkArgument(draftParts.size() == 2, "invalid draft state part: %s", p);
        draftIds.put(Account.Id.parse(draftParts.get(0)), ObjectId.fromString(draftParts.get(1)));
    }
    return new NoteDbChangeState(id, changeMetaId, draftIds);
}
#method_after
@VisibleForTesting
static NoteDbChangeState parse(Change.Id id, String str) {
    if (str == null) {
        return null;
    }
    List<String> parts = Splitter.on(',').splitToList(str);
    checkArgument(!parts.isEmpty(), "invalid state string for change %s: %s", id, str);
    ObjectId changeMetaId = ObjectId.fromString(parts.get(0));
    Map<Account.Id, ObjectId> draftIds = Maps.newHashMapWithExpectedSize(parts.size() - 1);
    Splitter s = Splitter.on('=');
    for (int i = 1; i < parts.size(); i++) {
        String p = parts.get(i);
        List<String> draftParts = s.splitToList(p);
        checkArgument(draftParts.size() == 2, "invalid draft state part for change %s: %s", id, p);
        draftIds.put(Account.Id.parse(draftParts.get(0)), ObjectId.fromString(draftParts.get(1)));
    }
    return new NoteDbChangeState(id, changeMetaId, draftIds);
}
#end_block

#method_before
public static void applyDelta(Change change, Delta delta) {
    String oldStr = change.getNoteDbState();
    if (oldStr == null && (delta == null || !delta.newChangeMetaId.isPresent())) {
        // Can't construct a complete state, bail.
        return;
    }
    NoteDbChangeState oldState = parse(change.getId(), oldStr);
    if (delta == null) {
        return;
    }
    ObjectId changeMetaId;
    if (delta.newChangeMetaId.isPresent()) {
        changeMetaId = delta.newChangeMetaId.get();
        if (changeMetaId.equals(ObjectId.zeroId())) {
            change.setNoteDbState(null);
            return;
        }
    } else {
        changeMetaId = oldState.changeMetaId;
    }
    Map<Account.Id, ObjectId> draftIds = new HashMap<>();
    if (oldState != null) {
        draftIds.putAll(oldState.draftIds);
    }
    for (Map.Entry<Account.Id, ObjectId> e : delta.newDraftIds.entrySet()) {
        if (e.getValue().equals(ObjectId.zeroId())) {
            draftIds.remove(e.getKey());
        } else {
            draftIds.put(e.getKey(), e.getValue());
        }
    }
    change.setNoteDbState(new NoteDbChangeState(change.getId(), changeMetaId, draftIds).toString());
}
#method_after
public static void applyDelta(Change change, Delta delta) {
    if (delta == null) {
        return;
    }
    String oldStr = change.getNoteDbState();
    if (oldStr == null && !delta.newChangeMetaId().isPresent()) {
        // point in proceeding.
        return;
    }
    NoteDbChangeState oldState = parse(change.getId(), oldStr);
    ObjectId changeMetaId;
    if (delta.newChangeMetaId().isPresent()) {
        changeMetaId = delta.newChangeMetaId().get();
        if (changeMetaId.equals(ObjectId.zeroId())) {
            change.setNoteDbState(null);
            return;
        }
    } else {
        changeMetaId = oldState.changeMetaId;
    }
    Map<Account.Id, ObjectId> draftIds = new HashMap<>();
    if (oldState != null) {
        draftIds.putAll(oldState.draftIds);
    }
    for (Map.Entry<Account.Id, ObjectId> e : delta.newDraftIds().entrySet()) {
        if (e.getValue().equals(ObjectId.zeroId())) {
            draftIds.remove(e.getKey());
        } else {
            draftIds.put(e.getKey(), e.getValue());
        }
    }
    change.setNoteDbState(toString(changeMetaId, draftIds));
}
#end_block

#method_before
@Override
public String toString() {
    List<Account.Id> accountIds = Lists.newArrayList(draftIds.keySet());
    Collections.sort(accountIds, ReviewDbUtil.intKeyOrdering());
    StringBuilder sb = new StringBuilder(changeMetaId.name());
    for (Account.Id id : accountIds) {
        sb.append(',').append(id.get()).append('=').append(draftIds.get(id).name());
    }
    return sb.toString();
}
#method_after
private static String toString(ObjectId changeMetaId, Map<Account.Id, ObjectId> draftIds) {
    List<Account.Id> accountIds = Lists.newArrayList(draftIds.keySet());
    Collections.sort(accountIds, ReviewDbUtil.intKeyOrdering());
    StringBuilder sb = new StringBuilder(changeMetaId.name());
    for (Account.Id id : accountIds) {
        sb.append(',').append(id.get()).append('=').append(draftIds.get(id).name());
    }
    return sb.toString();
}
#end_block

#method_before
@Override
public String toString() {
    List<Account.Id> accountIds = Lists.newArrayList(draftIds.keySet());
    Collections.sort(accountIds, ReviewDbUtil.intKeyOrdering());
    StringBuilder sb = new StringBuilder(changeMetaId.name());
    for (Account.Id id : accountIds) {
        sb.append(',').append(id.get()).append('=').append(draftIds.get(id).name());
    }
    return sb.toString();
}
#method_after
@Override
public String toString() {
    return toString(changeMetaId, draftIds);
}
#end_block

#method_before
private static void diffChanges(List<String> diffs, ChangeBundle bundleA, ChangeBundle bundleB) {
    Change a = bundleA.change;
    Change b = bundleB.change;
    String desc = a.getId().equals(b.getId()) ? describe(a.getId()) : "Changes";
    diffColumns(diffs, Change.class, desc, bundleA, a, bundleB, b);
}
#method_after
private static void diffChanges(List<String> diffs, ChangeBundle bundleA, ChangeBundle bundleB) {
    Change a = bundleA.change;
    Change b = bundleB.change;
    String desc = a.getId().equals(b.getId()) ? describe(a.getId()) : "Changes";
    diffColumnsExcluding(diffs, Change.class, desc, bundleA, a, bundleB, b, "rowVersion", "noteDbState");
}
#end_block

#method_before
public Map<Change.Id, NoteDbChangeState.Delta> stage() throws OrmException, IOException {
    if (staged != null) {
        return staged;
    }
    staged = new HashMap<>();
    if (isEmpty()) {
        return staged;
    }
    initChangeRepo();
    if (!draftUpdates.isEmpty()) {
        initAllUsersRepo();
    }
    addCommands();
    Table<Change.Id, Account.Id, ObjectId> allDraftIds = getDraftIds();
    Set<Change.Id> changeIds = new HashSet<>();
    for (ReceiveCommand cmd : changeRepo.cmds.getCommands().values()) {
        Change.Id changeId = Change.Id.fromRef(cmd.getRefName());
        changeIds.add(changeId);
        Optional<ObjectId> metaId = Optional.of(cmd.getNewId());
        staged.put(changeId, new NoteDbChangeState.Delta(changeId, metaId, allDraftIds.rowMap().remove(changeId)));
    }
    for (Map.Entry<Change.Id, Map<Account.Id, ObjectId>> e : allDraftIds.rowMap().entrySet()) {
        // If a change remains in the table at this point, it means we are
        // updating its drafts but not the change itself.
        staged.put(e.getKey(), new NoteDbChangeState.Delta(e.getKey(), Optional.<ObjectId>absent(), e.getValue()));
    }
    return staged;
}
#method_after
public Map<Change.Id, NoteDbChangeState.Delta> stage() throws OrmException, IOException {
    if (staged != null) {
        return staged;
    }
    try (Timer1.Context timer = metrics.stageUpdateLatency.start(CHANGES)) {
        staged = new HashMap<>();
        if (isEmpty()) {
            return staged;
        }
        initChangeRepo();
        if (!draftUpdates.isEmpty()) {
            initAllUsersRepo();
        }
        addCommands();
        Table<Change.Id, Account.Id, ObjectId> allDraftIds = getDraftIds();
        Set<Change.Id> changeIds = new HashSet<>();
        for (ReceiveCommand cmd : changeRepo.cmds.getCommands().values()) {
            Change.Id changeId = Change.Id.fromRef(cmd.getRefName());
            changeIds.add(changeId);
            Optional<ObjectId> metaId = Optional.of(cmd.getNewId());
            staged.put(changeId, NoteDbChangeState.Delta.create(changeId, metaId, allDraftIds.rowMap().remove(changeId)));
        }
        for (Map.Entry<Change.Id, Map<Account.Id, ObjectId>> e : allDraftIds.rowMap().entrySet()) {
            // If a change remains in the table at this point, it means we are
            // updating its drafts but not the change itself.
            staged.put(e.getKey(), NoteDbChangeState.Delta.create(e.getKey(), Optional.<ObjectId>absent(), e.getValue()));
        }
        return staged;
    }
}
#end_block

#method_before
private Table<Change.Id, Account.Id, ObjectId> getDraftIds() {
    Table<Change.Id, Account.Id, ObjectId> draftIds = HashBasedTable.create();
    if (allUsersRepo == null) {
        return draftIds;
    }
    for (ReceiveCommand cmd : allUsersRepo.cmds.getCommands().values()) {
        String r = cmd.getRefName();
        if (r.startsWith(REFS_DRAFT_COMMENTS)) {
            String msg = "invalid draft ref: %s";
            Account.Id accountId = Account.Id.fromRefPart(r.substring(REFS_DRAFT_COMMENTS.length()));
            checkState(accountId != null, msg, r);
            int s = r.lastIndexOf('/');
            checkState(s >= 0 && s < r.length() - 1, msg, r);
            Change.Id changeId = Change.Id.parse(r.substring(s + 1));
            draftIds.put(changeId, accountId, cmd.getNewId());
        }
    }
    return draftIds;
}
#method_after
private Table<Change.Id, Account.Id, ObjectId> getDraftIds() {
    Table<Change.Id, Account.Id, ObjectId> draftIds = HashBasedTable.create();
    if (allUsersRepo == null) {
        return draftIds;
    }
    for (ReceiveCommand cmd : allUsersRepo.cmds.getCommands().values()) {
        String r = cmd.getRefName();
        if (r.startsWith(REFS_DRAFT_COMMENTS)) {
            Account.Id accountId = Account.Id.fromRefPart(r.substring(REFS_DRAFT_COMMENTS.length()));
            checkDraftRef(accountId != null, r);
            int s = r.lastIndexOf('/');
            checkDraftRef(s >= 0 && s < r.length() - 1, r);
            Change.Id changeId = Change.Id.parse(r.substring(s + 1));
            draftIds.put(changeId, accountId, cmd.getNewId());
        }
    }
    return draftIds;
}
#end_block

#method_before
public void execute() throws OrmException, IOException {
    if (isEmpty()) {
        return;
    }
    // TODO(dborowitz): Separate metric for staging latency?
    stage();
    try (Timer1.Context timer = metrics.updateLatency.start(CHANGES)) {
        // ChangeUpdates must execute before ChangeDraftUpdates.
        // 
        // ChangeUpdate will automatically delete draft comments for any published
        // comments, but the updates to the two repos don't happen atomically.
        // Thus if the change meta update succeeds and the All-Users update fails,
        // we may have stale draft comments. Doing it in this order allows stale
        // comments to be filtered out by ChangeNotes, reflecting the fact that
        // comments can only go from DRAFT to PUBLISHED, not vice versa.
        execute(changeRepo);
        execute(allUsersRepo);
    } finally {
        if (allUsersRepo != null) {
            allUsersRepo.close();
        }
        if (changeRepo != null) {
            changeRepo.close();
        }
    }
}
#method_after
public void execute() throws OrmException, IOException {
    if (isEmpty()) {
        return;
    }
    try (Timer1.Context timer = metrics.updateLatency.start(CHANGES)) {
        stage();
        // ChangeUpdates must execute before ChangeDraftUpdates.
        // 
        // ChangeUpdate will automatically delete draft comments for any published
        // comments, but the updates to the two repos don't happen atomically.
        // Thus if the change meta update succeeds and the All-Users update fails,
        // we may have stale draft comments. Doing it in this order allows stale
        // comments to be filtered out by ChangeNotes, reflecting the fact that
        // comments can only go from DRAFT to PUBLISHED, not vice versa.
        execute(changeRepo);
        execute(allUsersRepo);
    } finally {
        if (allUsersRepo != null) {
            allUsersRepo.close();
        }
        if (changeRepo != null) {
            changeRepo.close();
        }
    }
}
#end_block

#method_before
private static void addUpdates(ListMultimap<String, ? extends AbstractChangeUpdate> updates, OpenRepo or) throws OrmException, IOException {
    for (String refName : updates.keySet()) {
        ObjectId old = firstNonNull(or.cmds.getObjectId(or.repo, refName), ObjectId.zeroId());
        ObjectId curr = old;
        for (AbstractChangeUpdate u : updates.get(refName)) {
            ObjectId next = u.apply(or.rw, or.ins, curr);
            if (next == null) {
                continue;
            }
            curr = next;
        }
        if (!old.equals(curr)) {
            or.cmds.add(new ReceiveCommand(old, curr, refName));
        }
    }
}
#method_after
private static <U extends AbstractChangeUpdate> void addUpdates(ListMultimap<String, U> all, OpenRepo or) throws OrmException, IOException {
    for (Map.Entry<String, Collection<U>> e : all.asMap().entrySet()) {
        String refName = e.getKey();
        Collection<U> updates = e.getValue();
        ObjectId old = firstNonNull(or.cmds.getObjectId(or.repo, refName), ObjectId.zeroId());
        // writing partial change meta if the change hasn't been backfilled yet.
        if (!allowWrite(updates, old)) {
            continue;
        }
        ObjectId curr = old;
        for (U u : updates) {
            ObjectId next = u.apply(or.rw, or.ins, curr);
            if (next == null) {
                continue;
            }
            curr = next;
        }
        if (!old.equals(curr)) {
            or.cmds.add(new ReceiveCommand(old, curr, refName));
        }
    }
}
#end_block

#method_before
@Override
public NoteDbChangeState rebuild(ReviewDb db, Change.Id changeId) throws NoSuchChangeException, IOException, OrmException, ConfigInvalidException {
    db = unwrapDb(db);
    Change change = db.changes().get(changeId);
    if (change == null) {
        throw new NoSuchChangeException(changeId);
    }
    NoteDbUpdateManager manager = updateManagerFactory.create(change.getProject());
    // We will rebuild all events, except for draft comments, in buckets based
    // on author and timestamp.
    List<Event> events = Lists.newArrayList();
    Multimap<Account.Id, PatchLineCommentEvent> draftCommentEvents = ArrayListMultimap.create();
    Repository changeMetaRepo = manager.getChangeRepo();
    events.addAll(getHashtagsEvents(change, manager));
    // Delete ref only after hashtags have been read
    deleteRef(change, changeMetaRepo, manager.getChangeCommands());
    try (Repository codeRepo = repoManager.openRepository(change.getProject());
        RevWalk codeRw = new RevWalk(codeRepo)) {
        for (PatchSet ps : db.patchSets().byChange(changeId)) {
            events.add(new PatchSetEvent(change, ps, codeRw));
            List<PatchLineComment> comments = PatchLineCommentsUtil.PLC_ORDER.sortedCopy(db.patchComments().byPatchSet(ps.getId()));
            for (PatchLineComment c : comments) {
                PatchLineCommentEvent e = new PatchLineCommentEvent(c, change, ps, patchListCache);
                if (c.getStatus() == Status.PUBLISHED) {
                    events.add(e);
                } else {
                    draftCommentEvents.put(c.getAuthor(), e);
                }
            }
        }
    }
    for (PatchSetApproval psa : db.patchSetApprovals().byChange(changeId)) {
        events.add(new ApprovalEvent(psa, change.getCreatedOn()));
    }
    Change noteDbChange = new Change(null, null, null, null, null);
    for (ChangeMessage msg : db.changeMessages().byChange(changeId)) {
        events.add(new ChangeMessageEvent(msg, noteDbChange, change.getCreatedOn()));
    }
    Collections.sort(events, EVENT_ORDER);
    events.add(new FinalUpdatesEvent(change, noteDbChange));
    EventList<Event> el = new EventList<>();
    for (Event e : events) {
        if (!el.canAdd(e)) {
            flushEventsToUpdate(db, manager, el, change);
            checkState(el.canAdd(e));
        }
        el.add(e);
    }
    flushEventsToUpdate(db, manager, el, change);
    EventList<PatchLineCommentEvent> plcel = new EventList<>();
    for (Account.Id author : draftCommentEvents.keys()) {
        for (PatchLineCommentEvent e : draftCommentEvents.get(author)) {
            if (!plcel.canAdd(e)) {
                flushEventsToDraftUpdate(db, manager, plcel, change);
                checkState(plcel.canAdd(e));
            }
            plcel.add(e);
        }
        flushEventsToDraftUpdate(db, manager, plcel, change);
    }
    createStarredChangesRefs(db, changeId, manager.getAllUsersCommands(), manager.getAllUsersRepo());
    return execute(db, changeId, manager);
}
#method_after
@Override
public NoteDbChangeState rebuild(ReviewDb db, Change.Id changeId) throws NoSuchChangeException, IOException, OrmException, ConfigInvalidException {
    db = unwrapDb(db);
    Change change = db.changes().get(changeId);
    if (change == null) {
        throw new NoSuchChangeException(changeId);
    }
    NoteDbUpdateManager manager = updateManagerFactory.create(change.getProject());
    // We will rebuild all events, except for draft comments, in buckets based
    // on author and timestamp.
    List<Event> events = Lists.newArrayList();
    Multimap<Account.Id, PatchLineCommentEvent> draftCommentEvents = ArrayListMultimap.create();
    Repository changeMetaRepo = manager.getChangeRepo();
    events.addAll(getHashtagsEvents(change, manager));
    // Delete ref only after hashtags have been read
    deleteRef(change, changeMetaRepo, manager.getChangeCommands());
    try (Repository codeRepo = repoManager.openRepository(change.getProject());
        RevWalk codeRw = new RevWalk(codeRepo)) {
        for (PatchSet ps : db.patchSets().byChange(changeId)) {
            events.add(new PatchSetEvent(change, ps, codeRw));
            List<PatchLineComment> comments = PatchLineCommentsUtil.PLC_ORDER.sortedCopy(db.patchComments().byPatchSet(ps.getId()));
            for (PatchLineComment c : comments) {
                PatchLineCommentEvent e = new PatchLineCommentEvent(c, change, ps, patchListCache);
                if (c.getStatus() == Status.PUBLISHED) {
                    events.add(e);
                } else {
                    draftCommentEvents.put(c.getAuthor(), e);
                }
            }
        }
    }
    for (PatchSetApproval psa : db.patchSetApprovals().byChange(changeId)) {
        events.add(new ApprovalEvent(psa, change.getCreatedOn()));
    }
    Change noteDbChange = new Change(null, null, null, null, null);
    for (ChangeMessage msg : db.changeMessages().byChange(changeId)) {
        events.add(new ChangeMessageEvent(msg, noteDbChange, change.getCreatedOn()));
    }
    Collections.sort(events, EVENT_ORDER);
    events.add(new FinalUpdatesEvent(change, noteDbChange));
    EventList<Event> el = new EventList<>();
    for (Event e : events) {
        if (!el.canAdd(e)) {
            flushEventsToUpdate(db, manager, el, change);
            checkState(el.canAdd(e));
        }
        el.add(e);
    }
    flushEventsToUpdate(db, manager, el, change);
    EventList<PatchLineCommentEvent> plcel = new EventList<>();
    for (Account.Id author : draftCommentEvents.keys()) {
        for (PatchLineCommentEvent e : draftCommentEvents.get(author)) {
            if (!plcel.canAdd(e)) {
                flushEventsToDraftUpdate(db, manager, plcel, change);
                checkState(plcel.canAdd(e));
            }
            plcel.add(e);
        }
        flushEventsToDraftUpdate(db, manager, plcel, change);
    }
    return execute(db, changeId, manager);
}
#end_block

#method_before
private LoadHandle rebuildAndOpen(Repository repo) throws IOException {
    try {
        NoteDbChangeState newState = args.rebuilder.get().rebuild(args.db.get(), getChangeId());
        if (newState == null) {
            return super.openHandle(repo);
        }
        // if we need to reopen the repo.
        return LoadHandle.create(new RevWalk(repo), newState.getChangeMetaId());
    } catch (NoSuchChangeException e) {
        return super.openHandle(repo);
    } catch (OrmException | ConfigInvalidException e) {
        throw new IOException(e);
    }
}
#method_after
private LoadHandle rebuildAndOpen(Repository repo) throws IOException {
    try {
        NoteDbChangeState newState = args.rebuilder.get().rebuild(args.db.get(), getChangeId());
        if (newState == null) {
            // May be null in tests.
            return super.openHandle(repo);
        }
        repo.scanForRepoChanges();
        return LoadHandle.create(new RevWalk(repo), newState.getChangeMetaId());
    } catch (NoSuchChangeException e) {
        return super.openHandle(repo);
    } catch (OrmException | ConfigInvalidException e) {
        throw new IOException(e);
    }
}
#end_block

#method_before
@VisibleForTesting
static NoteDbChangeState parse(Change.Id id, String str) {
    if (str == null) {
        return null;
    }
    List<String> parts = Splitter.on(',').splitToList(str);
    checkArgument(!parts.isEmpty(), "invalid state string: %s", str);
    ObjectId changeMetaId = ObjectId.fromString(parts.get(0));
    Map<Account.Id, ObjectId> draftIds = Maps.newHashMapWithExpectedSize(parts.size());
    Splitter s = Splitter.on('=');
    for (int i = 1; i < parts.size(); i++) {
        String p = parts.get(i);
        List<String> draftParts = s.splitToList(p);
        checkArgument(draftParts.size() == 2, "invalid draft state part: %s", p);
        draftIds.put(Account.Id.parse(draftParts.get(0)), ObjectId.fromString(draftParts.get(1)));
    }
    return new NoteDbChangeState(id, changeMetaId, draftIds);
}
#method_after
@VisibleForTesting
static NoteDbChangeState parse(Change.Id id, String str) {
    if (str == null) {
        return null;
    }
    List<String> parts = Splitter.on(',').splitToList(str);
    checkArgument(!parts.isEmpty(), "invalid state string for change %s: %s", id, str);
    ObjectId changeMetaId = ObjectId.fromString(parts.get(0));
    Map<Account.Id, ObjectId> draftIds = Maps.newHashMapWithExpectedSize(parts.size() - 1);
    Splitter s = Splitter.on('=');
    for (int i = 1; i < parts.size(); i++) {
        String p = parts.get(i);
        List<String> draftParts = s.splitToList(p);
        checkArgument(draftParts.size() == 2, "invalid draft state part for change %s: %s", id, p);
        draftIds.put(Account.Id.parse(draftParts.get(0)), ObjectId.fromString(draftParts.get(1)));
    }
    return new NoteDbChangeState(id, changeMetaId, draftIds);
}
#end_block

#method_before
private boolean isSubmittable(ChangeInfo info) {
    boolean canSubmit = info.status().isOpen() && revision.equals(info.currentRevision()) && !info.revision(revision).draft();
    if (canSubmit && info.status() == Change.Status.NEW) {
        for (String name : info.labels()) {
            LabelInfo label = info.label(name);
            switch(label.status()) {
                case NEED:
                    statusText.setInnerText("Needs " + name);
                    canSubmit = false;
                    break;
                case REJECT:
                case IMPOSSIBLE:
                    if (label.blocking()) {
                        statusText.setInnerText("Blocked on " + name);
                        canSubmit = false;
                    }
                    break;
                case MAY:
                case OK:
                default:
                    break;
            }
        }
    }
    return canSubmit;
}
#method_after
private boolean isSubmittable(ChangeInfo info) {
    boolean canSubmit = info.status().isOpen() && revision.equals(info.currentRevision()) && !info.revision(revision).draft();
    if (canSubmit && info.status() == Change.Status.NEW) {
        for (String name : info.labels()) {
            LabelInfo label = info.label(name);
            switch(label.status()) {
                case NEED:
                    statusText.setInnerText(Util.M.needs(name));
                    canSubmit = false;
                    break;
                case REJECT:
                case IMPOSSIBLE:
                    if (label.blocking()) {
                        statusText.setInnerText(Util.M.blockedOn(name));
                        canSubmit = false;
                    }
                    break;
                case MAY:
                case OK:
                default:
                    break;
            }
        }
    }
    return canSubmit;
}
#end_block

#method_before
@Override
public GeneralPreferencesInfo getPreferences() throws RestApiException {
    GetPreferences myGetPreferences = getPreferences.get();
    try {
        return myGetPreferences.apply(account);
    } catch (OrmException | IOException | ConfigInvalidException e) {
        throw new RestApiException("Cannot query preferences", e);
    }
}
#method_after
@Override
public GeneralPreferencesInfo getPreferences() throws RestApiException {
    return getPreferences.apply(account);
}
#end_block

#method_before
private Handler appHandler() {
    DebugRenderer renderer = new DebugRenderer(STATIC_PREFIX, Arrays.asList(cfg.getStringList("gitiles", null, "customTemplates")), new File(sourceRoot, "gitiles-servlet/src/main/resources/com/google/gitiles/templates").getPath(), firstNonNull(cfg.getString("gitiles", null, "siteTitle"), "Gitiles"));
    String docRoot = cfg.getString("gitiles", null, "docroot");
    Servlet servlet;
    if (!Strings.isNullOrEmpty(docRoot)) {
        servlet = createRootedDocServlet(renderer, docRoot);
    } else {
        servlet = new GitilesServlet(cfg, renderer, null, null, null, null, null, null, null);
    }
    ServletContextHandler handler = new ServletContextHandler();
    handler.setContextPath("");
    handler.addServlet(new ServletHolder(servlet), "/*");
    return handler;
}
#method_after
private Handler appHandler() {
    DebugRenderer renderer = new DebugRenderer(STATIC_PREFIX, Arrays.asList(cfg.getStringList("gitiles", null, "customTemplates")), sourceRoot.resolve("gitiles-servlet/src/main/resources/com/google/gitiles/templates").toString(), firstNonNull(cfg.getString("gitiles", null, "siteTitle"), "Gitiles"));
    String docRoot = cfg.getString("gitiles", null, "docroot");
    Servlet servlet;
    if (!Strings.isNullOrEmpty(docRoot)) {
        servlet = createRootedDocServlet(renderer, docRoot);
    } else {
        servlet = new GitilesServlet(cfg, renderer, null, null, null, null, null, null, null);
    }
    ServletContextHandler handler = new ServletContextHandler();
    handler.setContextPath("");
    handler.addServlet(new ServletHolder(servlet), "/*");
    return handler;
}
#end_block

#method_before
private Handler staticHandler() throws IOException {
    File staticRoot = new File(sourceRoot, "gitiles-servlet/src/main/resources/com/google/gitiles/static");
    ResourceHandler rh = new ResourceHandler();
    try {
        rh.setBaseResource(new FileResource(staticRoot.toURI().toURL()));
    } catch (URISyntaxException e) {
        throw new IOException(e);
    }
    rh.setWelcomeFiles(new String[] {});
    rh.setDirectoriesListed(false);
    ContextHandler handler = new ContextHandler("/+static");
    handler.setHandler(rh);
    return handler;
}
#method_after
private Handler staticHandler() throws IOException {
    Path staticRoot = sourceRoot.resolve("gitiles-servlet/src/main/resources/com/google/gitiles/static");
    ResourceHandler rh = new ResourceHandler();
    try {
        rh.setBaseResource(new FileResource(staticRoot.toUri().toURL()));
    } catch (URISyntaxException e) {
        throw new IOException(e);
    }
    rh.setWelcomeFiles(new String[] {});
    rh.setDirectoriesListed(false);
    ContextHandler handler = new ContextHandler("/+static");
    handler.setHandler(rh);
    return handler;
}
#end_block

#method_before
@Override
protected void configure() {
    factory(AbandonedSender.Factory.class);
    factory(DeleteVoteSender.Factory.class);
    factory(CommentSender.Factory.class);
    factory(RevertedSender.Factory.class);
    factory(RestoredSender.Factory.class);
}
#method_after
@Override
protected void configure() {
    factory(AbandonedSender.Factory.class);
    factory(CommentSender.Factory.class);
    factory(DeleteVoteSender.Factory.class);
    factory(RestoredSender.Factory.class);
    factory(RevertedSender.Factory.class);
}
#end_block

#method_before
@Override
public Response<?> apply(VoteResource rsrc, Input input) throws RestApiException, UpdateException {
    ReviewerResource r = rsrc.getReviewer();
    ChangeControl ctl = r.getControl();
    Change change = r.getChange();
    try (BatchUpdate bu = batchUpdateFactory.create(db.get(), change.getProject(), ctl.getUser().asIdentifiedUser(), TimeUtil.nowTs())) {
        bu.addOp(change.getId(), new Op(r.getUser().getAccountId(), rsrc.getLabel()));
        bu.execute();
    }
    return Response.none();
}
#method_after
@Override
public Response<?> apply(VoteResource rsrc, Input input) throws RestApiException, UpdateException {
    ReviewerResource r = rsrc.getReviewer();
    Change change = r.getChange();
    try (BatchUpdate bu = batchUpdateFactory.create(db.get(), change.getProject(), r.getControl().getUser(), TimeUtil.nowTs())) {
        bu.addOp(change.getId(), new Op(r.getReviewerUser().getAccountId(), rsrc.getLabel()));
        bu.execute();
    }
    return Response.none();
}
#end_block

#method_before
@Override
public void updateChange(ChangeContext ctx) throws OrmException, AuthException, ResourceNotFoundException {
    user = ctx.getUser().asIdentifiedUser();
    change = ctx.getChange();
    ChangeControl ctl = ctx.getChangeControl();
    psId = change.currentPatchSetId();
    ps = ctx.getDb().patchSets().get(psId);
    PatchSetApproval psa = null;
    StringBuilder msg = new StringBuilder();
    for (PatchSetApproval a : approvalsUtil.byPatchSetUser(ctx.getDb(), ctl, psId, accountId)) {
        if (ctl.canRemoveReviewer(a)) {
            if (a.getLabel().equals(label)) {
                msg.append("Removed ").append(a.getLabel()).append(formatLabelValue(a.getValue())).append(" by ").append(userFactory.create(user.getAccountId()).getNameEmail()).append("\n");
                psa = a;
                a.setValue((short) 0);
                categories.put(a.getLabel(), a.getValue());
                ctx.getChangeUpdate().setPatchSetId(psId);
                ctx.getChangeUpdate().removeApproval(label);
                break;
            }
        } else {
            throw new AuthException("delete not permitted");
        }
    }
    if (psa == null) {
        throw new ResourceNotFoundException();
    }
    ChangeUtil.bumpRowVersionNotLastUpdatedOn(change.getId(), ctx.getDb());
    ctx.getDb().patchSetApprovals().update(Collections.singleton(psa));
    if (msg.length() > 0) {
        changeMessage = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(ctx.getDb())), user.getAccountId(), ctx.getWhen(), change.currentPatchSetId());
        changeMessage.setMessage(msg.toString());
        cmUtil.addChangeMessage(ctx.getDb(), ctx.getChangeUpdate(), changeMessage);
    }
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, AuthException, ResourceNotFoundException {
    ChangeControl ctl = ctx.getControl();
    change = ctl.getChange();
    PatchSet.Id psId = change.currentPatchSetId();
    ps = psUtil.current(db.get(), ctl.getNotes());
    PatchSetApproval psa = null;
    StringBuilder msg = new StringBuilder();
    // get all of the current approvals
    LabelTypes labelTypes = ctx.getControl().getLabelTypes();
    Map<String, Short> currentApprovals = new HashMap<>();
    for (LabelType lt : labelTypes.getLabelTypes()) {
        currentApprovals.put(lt.getName(), (short) 0);
        for (PatchSetApproval a : approvalsUtil.byPatchSetUser(ctx.getDb(), ctl, psId, accountId)) {
            if (lt.getLabelId().equals(a.getLabelId())) {
                currentApprovals.put(lt.getName(), a.getValue());
            }
        }
    }
    // removing votes so we need to determine the new set of approval scores
    newApprovals.putAll(currentApprovals);
    for (PatchSetApproval a : approvalsUtil.byPatchSetUser(ctx.getDb(), ctl, psId, accountId)) {
        if (ctl.canRemoveReviewer(a)) {
            if (a.getLabel().equals(label)) {
                // set the approval to 0 if vote is being removed
                newApprovals.put(a.getLabel(), (short) 0);
                // set old value only if the vote changed
                oldApprovals.put(a.getLabel(), a.getValue());
                msg.append("Removed ").append(a.getLabel()).append(formatLabelValue(a.getValue())).append(" by ").append(userFactory.create(a.getAccountId()).getNameEmail()).append("\n");
                psa = a;
                a.setValue((short) 0);
                ctx.getUpdate(psId).removeApprovalFor(a.getAccountId(), label);
                break;
            }
        } else {
            throw new AuthException("delete not permitted");
        }
    }
    if (psa == null) {
        throw new ResourceNotFoundException();
    }
    ctx.saveChange();
    ctx.getDb().patchSetApprovals().update(Collections.singleton(psa));
    if (msg.length() > 0) {
        changeMessage = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(ctx.getDb())), ctx.getUser().asIdentifiedUser().getAccountId(), ctx.getWhen(), change.currentPatchSetId());
        changeMessage.setMessage(msg.toString());
        cmUtil.addChangeMessage(ctx.getDb(), ctx.getUpdate(psId), changeMessage);
    }
    return true;
}
#end_block

#method_before
@Override
public void postUpdate(Context ctx) {
    if (changeMessage == null) {
        return;
    }
    try {
        ReplyToChangeSender cm = deleteVoteSenderFactory.create(change.getId());
        if (user.getAccountId() != null) {
            cm.setFrom(user.getAccountId());
        }
        cm.setChangeMessage(changeMessage);
        cm.send();
    } catch (Exception e) {
        log.error("Cannot email update for change " + change.getId(), e);
    }
    try {
        hooks.doCommentAddedHook(change, user.getAccount(), ps, changeMessage.getMessage(), categories, ctx.getDb());
    } catch (OrmException e) {
        log.warn("ChangeHook.doCommentAddedHook delivery failed", e);
    }
}
#method_after
@Override
public void postUpdate(Context ctx) {
    if (changeMessage == null) {
        return;
    }
    IdentifiedUser user = ctx.getUser().asIdentifiedUser();
    try {
        ReplyToChangeSender cm = deleteVoteSenderFactory.create(ctx.getProject(), change.getId());
        cm.setFrom(user.getAccountId());
        cm.setChangeMessage(changeMessage);
        cm.send();
    } catch (Exception e) {
        log.error("Cannot email update for change " + change.getId(), e);
    }
    try {
        hooks.doCommentAddedHook(change, user.getAccount(), ps, changeMessage.getMessage(), newApprovals, oldApprovals, ctx.getDb());
    } catch (OrmException e) {
        log.warn("ChangeHook.doCommentAddedHook delivery failed", e);
    }
}
#end_block

#method_before
@Override
public Output apply(RevisionResource revision, ReviewInput input) throws AuthException, BadRequestException, ResourceConflictException, UnprocessableEntityException, OrmException, IOException {
    return apply(revision, input, TimeUtil.nowTs());
}
#method_after
@Override
public Output apply(RevisionResource revision, ReviewInput input) throws RestApiException, UpdateException, OrmException {
    return apply(revision, input, TimeUtil.nowTs());
}
#end_block

#method_before
public Output apply(RevisionResource revision, ReviewInput input, Timestamp ts) throws AuthException, BadRequestException, ResourceConflictException, UnprocessableEntityException, OrmException, IOException {
    timestamp = ts;
    if (revision.getEdit().isPresent()) {
        throw new ResourceConflictException("cannot post review on edit");
    }
    if (input.onBehalfOf != null) {
        revision = onBehalfOf(revision, input);
    }
    if (input.labels != null) {
        checkLabels(revision, input.strictLabels, input.labels);
    }
    if (input.comments != null) {
        checkComments(revision, input.comments);
    }
    if (input.notify == null) {
        log.warn("notify = null; assuming notify = NONE");
        input.notify = NotifyHandling.NONE;
    }
    db.get().changes().beginTransaction(revision.getChange().getId());
    boolean dirty = false;
    try {
        change = db.get().changes().get(revision.getChange().getId());
        if (change.getLastUpdatedOn().before(timestamp)) {
            change.setLastUpdatedOn(timestamp);
        }
        ChangeUpdate update = updateFactory.create(revision.getControl(), timestamp);
        update.setPatchSetId(revision.getPatchSet().getId());
        dirty |= insertComments(revision, update, input.comments, input.drafts);
        dirty |= updateLabels(revision, update, input.labels);
        dirty |= insertMessage(revision, input.message, update);
        if (dirty) {
            db.get().changes().update(Collections.singleton(change));
            db.get().commit();
        }
        update.commit();
    } finally {
        db.get().rollback();
    }
    if (dirty) {
        indexer.index(db.get(), change);
    }
    if (message != null && input.notify.compareTo(NotifyHandling.NONE) > 0) {
        email.create(input.notify, change, revision.getPatchSet(), revision.getAccountId(), message, comments).sendAsync();
    }
    Output output = new Output();
    output.labels = input.labels;
    if (message != null) {
        fireCommentAddedHook(revision);
    }
    return output;
}
#method_after
public Output apply(RevisionResource revision, ReviewInput input, Timestamp ts) throws RestApiException, UpdateException, OrmException {
    // Respect timestamp, but truncate at change created-on time.
    ts = Ordering.natural().max(ts, revision.getChange().getCreatedOn());
    if (revision.getEdit().isPresent()) {
        throw new ResourceConflictException("cannot post review on edit");
    }
    if (input.onBehalfOf != null) {
        revision = onBehalfOf(revision, input);
    }
    if (input.labels != null) {
        checkLabels(revision, input.strictLabels, input.labels);
    }
    if (input.comments != null) {
        checkComments(revision, input.comments);
    }
    if (input.notify == null) {
        log.warn("notify = null; assuming notify = NONE");
        input.notify = NotifyHandling.NONE;
    }
    try (BatchUpdate bu = batchUpdateFactory.create(db.get(), revision.getChange().getProject(), revision.getUser(), ts)) {
        bu.addOp(revision.getChange().getId(), new Op(revision.getPatchSet().getId(), input));
        bu.execute();
    }
    Output output = new Output();
    output.labels = input.labels;
    return output;
}
#end_block

#method_before
@Override
public void doClaSignupHook(Account account, ContributorAgreement cla) {
}
#method_after
@Override
public void doClaSignupHook(Account account, String claName) {
}
#end_block

#method_before
@Override
public void doCommentAddedHook(Change change, Account account, PatchSet patchSet, String comment, Map<String, Short> approvals, Map<String, Boolean> approvalUpdated, ReviewDb db) {
}
#method_after
@Override
public void doCommentAddedHook(Change change, Account account, PatchSet patchSet, String comment, Map<String, Short> approvals, Map<String, Short> oldApprovals, ReviewDb db) {
}
#end_block

#method_before
@Override
public void postEvent(Branch.NameKey branchName, Event event) {
}
#method_after
@Override
public void postEvent(Change change, ChangeEvent event, ReviewDb db) {
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ChangeHookRunner.class);
    bind(ChangeHooks.class).to(ChangeHookRunner.class);
    bind(EventDispatcher.class).to(ChangeHookRunner.class);
    bind(EventSource.class).to(ChangeHookRunner.class);
    DynamicSet.bind(binder(), NewProjectCreatedListener.class).to(ChangeHookRunner.class);
    listener().to(ChangeHookRunner.class);
}
#method_after
@Override
protected void configure() {
    bind(ChangeHookRunner.class);
    bind(ChangeHooks.class).to(ChangeHookRunner.class);
    DynamicSet.bind(binder(), NewProjectCreatedListener.class).to(ChangeHookRunner.class);
    listener().to(ChangeHookRunner.class);
}
#end_block

#method_before
private static Path hook(Config config, Path path, String name) {
    String setting = name.replace("-", "") + "hook";
    String value = config.getString("hooks", null, setting);
    return path.resolve(value != null ? value : name);
}
#method_after
private static Optional<Path> hook(Config config, Path path, String name) {
    String setting = name.replace("-", "") + "hook";
    String value = config.getString("hooks", null, setting);
    Path p = path.resolve(value != null ? value : name);
    return Files.exists(p) ? Optional.of(p) : Optional.<Path>absent();
}
#end_block

#method_before
@Override
public HookResult doRefUpdateHook(Project project, String refname, Account uploader, ObjectId oldId, ObjectId newId) {
    List<String> args = new ArrayList<>();
    addArg(args, "--project", project.getName());
    addArg(args, "--refname", refname);
    addArg(args, "--uploader", getDisplayName(uploader));
    addArg(args, "--oldrev", oldId.getName());
    addArg(args, "--newrev", newId.getName());
    return runSyncHook(project.getNameKey(), refUpdateHook, args);
}
#method_after
@Override
public HookResult doRefUpdateHook(Project project, String refname, Account uploader, ObjectId oldId, ObjectId newId) {
    if (!refUpdateHook.isPresent()) {
        return null;
    }
    List<String> args = new ArrayList<>();
    addArg(args, "--project", project.getName());
    addArg(args, "--refname", refname);
    addArg(args, "--uploader", getDisplayName(uploader));
    addArg(args, "--oldrev", oldId.getName());
    addArg(args, "--newrev", newId.getName());
    return runSyncHook(project.getNameKey(), refUpdateHook, args);
}
#end_block

#method_before
@Override
public void doProjectCreatedHook(Project.NameKey project, String headName) {
    ProjectCreatedEvent event = new ProjectCreatedEvent();
    event.projectName = project.get();
    event.headName = headName;
    fireEvent(project, event);
    List<String> args = new ArrayList<>();
    addArg(args, "--project", project.get());
    addArg(args, "--head", headName);
    runHook(project, projectCreatedHook, args);
}
#method_after
@Override
public void doProjectCreatedHook(Project.NameKey project, String headName) {
    ProjectCreatedEvent event = new ProjectCreatedEvent();
    event.projectName = project.get();
    event.headName = headName;
    dispatcher.get().postEvent(project, event);
    if (!projectCreatedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    addArg(args, "--project", project.get());
    addArg(args, "--head", headName);
    runHook(project, projectCreatedHook, args);
}
#end_block

#method_before
@Override
public void doPatchsetCreatedHook(Change change, PatchSet patchSet, ReviewDb db) throws OrmException {
    PatchSetCreatedEvent event = new PatchSetCreatedEvent();
    AccountState uploader = accountCache.get(patchSet.getUploader());
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(change);
    event.patchSet = eventFactory.asPatchSetAttribute(patchSet);
    event.uploader = eventFactory.asAccountAttribute(uploader.getAccount());
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--is-draft", String.valueOf(patchSet.isDraft()));
    addArg(args, "--kind", String.valueOf(event.patchSet.kind));
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--uploader", getDisplayName(uploader.getAccount()));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--patchset", event.patchSet.number);
    runHook(change.getProject(), patchsetCreatedHook, args);
}
#method_after
@Override
public void doPatchsetCreatedHook(Change change, PatchSet patchSet, ReviewDb db) throws OrmException {
    PatchSetCreatedEvent event = new PatchSetCreatedEvent(change);
    Supplier<AccountState> uploader = getAccountSupplier(patchSet.getUploader());
    Supplier<AccountState> owner = getAccountSupplier(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.uploader = accountAttributeSupplier(uploader);
    dispatcher.get().postEvent(change, event, db);
    if (!patchsetCreatedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    PatchSetAttribute ps = event.patchSet.get();
    addArg(args, "--change", c.id);
    addArg(args, "--is-draft", String.valueOf(patchSet.isDraft()));
    addArg(args, "--kind", String.valueOf(ps.kind));
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.get().getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--topic", c.topic);
    addArg(args, "--uploader", getDisplayName(uploader.get().getAccount()));
    addArg(args, "--commit", ps.revision);
    addArg(args, "--patchset", ps.number);
    runHook(change.getProject(), patchsetCreatedHook, args);
}
#end_block

#method_before
@Override
public void doDraftPublishedHook(Change change, PatchSet patchSet, ReviewDb db) throws OrmException {
    DraftPublishedEvent event = new DraftPublishedEvent();
    AccountState uploader = accountCache.get(patchSet.getUploader());
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(change);
    event.patchSet = eventFactory.asPatchSetAttribute(patchSet);
    event.uploader = eventFactory.asAccountAttribute(uploader.getAccount());
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--uploader", getDisplayName(uploader.getAccount()));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--patchset", event.patchSet.number);
    runHook(change.getProject(), draftPublishedHook, args);
}
#method_after
@Override
public void doDraftPublishedHook(Change change, PatchSet patchSet, ReviewDb db) throws OrmException {
    DraftPublishedEvent event = new DraftPublishedEvent(change);
    Supplier<AccountState> uploader = getAccountSupplier(patchSet.getUploader());
    Supplier<AccountState> owner = getAccountSupplier(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.uploader = accountAttributeSupplier(uploader);
    dispatcher.get().postEvent(change, event, db);
    if (!draftPublishedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    PatchSetAttribute ps = event.patchSet.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.get().getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--topic", c.topic);
    addArg(args, "--uploader", getDisplayName(uploader.get().getAccount()));
    addArg(args, "--commit", ps.revision);
    addArg(args, "--patchset", ps.number);
    runHook(change.getProject(), draftPublishedHook, args);
}
#end_block

#method_before
@Override
public void doCommentAddedHook(Change change, Account account, PatchSet patchSet, String comment, Map<String, Short> approvals, Map<String, Boolean> approvalStatus, ReviewDb db) throws OrmException {
    CommentAddedEvent event = new CommentAddedEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(change);
    event.author = eventFactory.asAccountAttribute(account);
    event.patchSet = eventFactory.asPatchSetAttribute(patchSet);
    event.comment = comment;
    LabelTypes labelTypes = projectCache.get(change.getProject()).getLabelTypes();
    if (approvals.size() > 0) {
        event.approvals = new ApprovalAttribute[approvals.size()];
        int i = 0;
        for (Map.Entry<String, Short> approval : approvals.entrySet()) {
            event.approvals[i++] = getApprovalAttribute(labelTypes, approval, approvalStatus);
        }
    }
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--is-draft", patchSet.isDraft() ? "true" : "false");
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--author", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--comment", comment == null ? "" : comment);
    for (Map.Entry<String, Short> approval : approvals.entrySet()) {
        LabelType lt = labelTypes.byLabel(approval.getKey());
        if (lt != null) {
            addArg(args, "--" + lt.getName(), Short.toString(approval.getValue()));
            addArg(args, "--" + lt.getName() + "-Updated", Boolean.toString(approvalStatus.get(approval.getKey())));
        }
    }
    runHook(change.getProject(), commentAddedHook, args);
}
#method_after
@Override
public void doCommentAddedHook(final Change change, Account account, PatchSet patchSet, String comment, final Map<String, Short> approvals, final Map<String, Short> oldApprovals, ReviewDb db) throws OrmException {
    CommentAddedEvent event = new CommentAddedEvent(change);
    Supplier<AccountState> owner = getAccountSupplier(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.author = accountAttributeSupplier(account);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.comment = comment;
    event.approvals = Suppliers.memoize(new Supplier<ApprovalAttribute[]>() {

        @Override
        public ApprovalAttribute[] get() {
            LabelTypes labelTypes = projectCache.get(change.getProject()).getLabelTypes();
            if (approvals.size() > 0) {
                ApprovalAttribute[] r = new ApprovalAttribute[approvals.size()];
                int i = 0;
                for (Map.Entry<String, Short> approval : approvals.entrySet()) {
                    r[i++] = getApprovalAttribute(labelTypes, approval, oldApprovals);
                }
                return r;
            }
            return null;
        }
    });
    dispatcher.get().postEvent(change, event, db);
    if (!commentAddedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    PatchSetAttribute ps = event.patchSet.get();
    addArg(args, "--change", c.id);
    addArg(args, "--is-draft", patchSet.isDraft() ? "true" : "false");
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.get().getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--topic", c.topic);
    addArg(args, "--author", getDisplayName(account));
    addArg(args, "--commit", ps.revision);
    addArg(args, "--comment", comment == null ? "" : comment);
    LabelTypes labelTypes = projectCache.get(change.getProject()).getLabelTypes();
    for (Map.Entry<String, Short> approval : approvals.entrySet()) {
        LabelType lt = labelTypes.byLabel(approval.getKey());
        if (lt != null && approval.getValue() != null) {
            addArg(args, "--" + lt.getName(), Short.toString(approval.getValue()));
            if (oldApprovals != null && !oldApprovals.isEmpty()) {
                Short oldValue = oldApprovals.get(approval.getKey());
                if (oldValue != null) {
                    addArg(args, "--" + lt.getName() + "-oldValue", Short.toString(oldValue));
                }
            }
        }
    }
    runHook(change.getProject(), commentAddedHook, args);
}
#end_block

#method_before
@Override
public void doChangeMergedHook(Change change, Account account, PatchSet patchSet, ReviewDb db, String mergeResultRev) throws OrmException {
    ChangeMergedEvent event = new ChangeMergedEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(change);
    event.submitter = eventFactory.asAccountAttribute(account);
    event.patchSet = eventFactory.asPatchSetAttribute(patchSet);
    event.newRev = mergeResultRev;
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--submitter", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--newrev", mergeResultRev);
    runHook(change.getProject(), changeMergedHook, args);
}
#method_after
@Override
public void doChangeMergedHook(Change change, Account account, PatchSet patchSet, ReviewDb db, String mergeResultRev) throws OrmException {
    ChangeMergedEvent event = new ChangeMergedEvent(change);
    Supplier<AccountState> owner = getAccountSupplier(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.submitter = accountAttributeSupplier(account);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.newRev = mergeResultRev;
    dispatcher.get().postEvent(change, event, db);
    if (!changeMergedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    PatchSetAttribute ps = event.patchSet.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.get().getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--topic", c.topic);
    addArg(args, "--submitter", getDisplayName(account));
    addArg(args, "--commit", ps.revision);
    addArg(args, "--newrev", mergeResultRev);
    runHook(change.getProject(), changeMergedHook, args);
}
#end_block

#method_before
@Override
public void doMergeFailedHook(Change change, Account account, PatchSet patchSet, String reason, ReviewDb db) throws OrmException {
    MergeFailedEvent event = new MergeFailedEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(change);
    event.submitter = eventFactory.asAccountAttribute(account);
    event.patchSet = eventFactory.asPatchSetAttribute(patchSet);
    event.reason = reason;
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--submitter", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--reason", reason == null ? "" : reason);
    runHook(change.getProject(), mergeFailedHook, args);
}
#method_after
@Override
public void doMergeFailedHook(Change change, Account account, PatchSet patchSet, String reason, ReviewDb db) throws OrmException {
    MergeFailedEvent event = new MergeFailedEvent(change);
    Supplier<AccountState> owner = getAccountSupplier(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.submitter = accountAttributeSupplier(account);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.reason = reason;
    dispatcher.get().postEvent(change, event, db);
    if (!mergeFailedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    PatchSetAttribute ps = event.patchSet.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.get().getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--topic", c.topic);
    addArg(args, "--submitter", getDisplayName(account));
    addArg(args, "--commit", ps.revision);
    addArg(args, "--reason", reason == null ? "" : reason);
    runHook(change.getProject(), mergeFailedHook, args);
}
#end_block

#method_before
@Override
public void doChangeAbandonedHook(Change change, Account account, PatchSet patchSet, String reason, ReviewDb db) throws OrmException {
    ChangeAbandonedEvent event = new ChangeAbandonedEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(change);
    event.abandoner = eventFactory.asAccountAttribute(account);
    event.patchSet = eventFactory.asPatchSetAttribute(patchSet);
    event.reason = reason;
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--abandoner", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--reason", reason == null ? "" : reason);
    runHook(change.getProject(), changeAbandonedHook, args);
}
#method_after
@Override
public void doChangeAbandonedHook(Change change, Account account, PatchSet patchSet, String reason, ReviewDb db) throws OrmException {
    ChangeAbandonedEvent event = new ChangeAbandonedEvent(change);
    AccountState owner = accountCache.get(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.abandoner = accountAttributeSupplier(account);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.reason = reason;
    dispatcher.get().postEvent(change, event, db);
    if (!changeAbandonedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    PatchSetAttribute ps = event.patchSet.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--topic", c.topic);
    addArg(args, "--abandoner", getDisplayName(account));
    addArg(args, "--commit", ps.revision);
    addArg(args, "--reason", reason == null ? "" : reason);
    runHook(change.getProject(), changeAbandonedHook, args);
}
#end_block

#method_before
@Override
public void doChangeRestoredHook(Change change, Account account, PatchSet patchSet, String reason, ReviewDb db) throws OrmException {
    ChangeRestoredEvent event = new ChangeRestoredEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(change);
    event.restorer = eventFactory.asAccountAttribute(account);
    event.patchSet = eventFactory.asPatchSetAttribute(patchSet);
    event.reason = reason;
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--restorer", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--reason", reason == null ? "" : reason);
    runHook(change.getProject(), changeRestoredHook, args);
}
#method_after
@Override
public void doChangeRestoredHook(Change change, Account account, PatchSet patchSet, String reason, ReviewDb db) throws OrmException {
    ChangeRestoredEvent event = new ChangeRestoredEvent(change);
    AccountState owner = accountCache.get(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.restorer = accountAttributeSupplier(account);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.reason = reason;
    dispatcher.get().postEvent(change, event, db);
    if (!changeRestoredHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    PatchSetAttribute ps = event.patchSet.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--topic", c.topic);
    addArg(args, "--restorer", getDisplayName(account));
    addArg(args, "--commit", ps.revision);
    addArg(args, "--reason", reason == null ? "" : reason);
    runHook(change.getProject(), changeRestoredHook, args);
}
#end_block

#method_before
@Override
public void doRefUpdatedHook(Branch.NameKey refName, ObjectId oldId, ObjectId newId, Account account) {
    RefUpdatedEvent event = new RefUpdatedEvent();
    if (account != null) {
        event.submitter = eventFactory.asAccountAttribute(account);
    }
    event.refUpdate = eventFactory.asRefUpdateAttribute(oldId, newId, refName);
    fireEvent(refName, event);
    List<String> args = new ArrayList<>();
    addArg(args, "--oldrev", event.refUpdate.oldRev);
    addArg(args, "--newrev", event.refUpdate.newRev);
    addArg(args, "--refname", event.refUpdate.refName);
    addArg(args, "--project", event.refUpdate.project);
    if (account != null) {
        addArg(args, "--submitter", getDisplayName(account));
    }
    runHook(refName.getParentKey(), refUpdatedHook, args);
}
#method_after
@Override
public void doRefUpdatedHook(final Branch.NameKey refName, final ObjectId oldId, final ObjectId newId, Account account) {
    RefUpdatedEvent event = new RefUpdatedEvent();
    if (account != null) {
        event.submitter = accountAttributeSupplier(account);
    }
    event.refUpdate = Suppliers.memoize(new Supplier<RefUpdateAttribute>() {

        @Override
        public RefUpdateAttribute get() {
            return eventFactory.asRefUpdateAttribute(oldId, newId, refName);
        }
    });
    dispatcher.get().postEvent(refName, event);
    if (!refUpdatedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    RefUpdateAttribute r = event.refUpdate.get();
    addArg(args, "--oldrev", r.oldRev);
    addArg(args, "--newrev", r.newRev);
    addArg(args, "--refname", r.refName);
    addArg(args, "--project", r.project);
    if (account != null) {
        addArg(args, "--submitter", getDisplayName(account));
    }
    runHook(refName.getParentKey(), refUpdatedHook, args);
}
#end_block

#method_before
@Override
public void doReviewerAddedHook(Change change, Account account, PatchSet patchSet, ReviewDb db) throws OrmException {
    ReviewerAddedEvent event = new ReviewerAddedEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(change);
    event.patchSet = eventFactory.asPatchSetAttribute(patchSet);
    event.reviewer = eventFactory.asAccountAttribute(account);
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--reviewer", getDisplayName(account));
    runHook(change.getProject(), reviewerAddedHook, args);
}
#method_after
@Override
public void doReviewerAddedHook(Change change, Account account, PatchSet patchSet, ReviewDb db) throws OrmException {
    ReviewerAddedEvent event = new ReviewerAddedEvent(change);
    Supplier<AccountState> owner = getAccountSupplier(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.reviewer = accountAttributeSupplier(account);
    dispatcher.get().postEvent(change, event, db);
    if (!reviewerAddedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.get().getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--reviewer", getDisplayName(account));
    runHook(change.getProject(), reviewerAddedHook, args);
}
#end_block

#method_before
@Override
public void doTopicChangedHook(Change change, Account account, String oldTopic, ReviewDb db) throws OrmException {
    TopicChangedEvent event = new TopicChangedEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(change);
    event.changer = eventFactory.asAccountAttribute(account);
    event.oldTopic = oldTopic;
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--changer", getDisplayName(account));
    addArg(args, "--old-topic", oldTopic);
    addArg(args, "--new-topic", event.change.topic);
    runHook(change.getProject(), topicChangedHook, args);
}
#method_after
@Override
public void doTopicChangedHook(Change change, Account account, String oldTopic, ReviewDb db) throws OrmException {
    TopicChangedEvent event = new TopicChangedEvent(change);
    AccountState owner = accountCache.get(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.changer = accountAttributeSupplier(account);
    event.oldTopic = oldTopic;
    dispatcher.get().postEvent(change, event, db);
    if (!topicChangedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--changer", getDisplayName(account));
    addArg(args, "--old-topic", oldTopic);
    addArg(args, "--new-topic", c.topic);
    runHook(change.getProject(), topicChangedHook, args);
}
#end_block

#method_before
@Override
public void doHashtagsChangedHook(Change change, Account account, Set<String> added, Set<String> removed, Set<String> hashtags, ReviewDb db) throws OrmException {
    HashtagsChangedEvent event = new HashtagsChangedEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(change);
    event.editor = eventFactory.asAccountAttribute(account);
    event.hashtags = hashtagArray(hashtags);
    event.added = hashtagArray(added);
    event.removed = hashtagArray(removed);
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--editor", getDisplayName(account));
    if (hashtags != null) {
        for (String hashtag : hashtags) {
            addArg(args, "--hashtag", hashtag);
        }
    }
    if (added != null) {
        for (String hashtag : added) {
            addArg(args, "--added", hashtag);
        }
    }
    if (removed != null) {
        for (String hashtag : removed) {
            addArg(args, "--removed", hashtag);
        }
    }
    runHook(change.getProject(), hashtagsChangedHook, args);
}
#method_after
@Override
public void doHashtagsChangedHook(Change change, Account account, Set<String> added, Set<String> removed, Set<String> hashtags, ReviewDb db) throws OrmException {
    HashtagsChangedEvent event = new HashtagsChangedEvent(change);
    AccountState owner = accountCache.get(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.editor = accountAttributeSupplier(account);
    event.hashtags = hashtagArray(hashtags);
    event.added = hashtagArray(added);
    event.removed = hashtagArray(removed);
    dispatcher.get().postEvent(change, event, db);
    if (!hashtagsChangedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--editor", getDisplayName(account));
    if (hashtags != null) {
        for (String hashtag : hashtags) {
            addArg(args, "--hashtag", hashtag);
        }
    }
    if (added != null) {
        for (String hashtag : added) {
            addArg(args, "--added", hashtag);
        }
    }
    if (removed != null) {
        for (String hashtag : removed) {
            addArg(args, "--removed", hashtag);
        }
    }
    runHook(change.getProject(), hashtagsChangedHook, args);
}
#end_block

#method_before
@Override
public void doClaSignupHook(Account account, ContributorAgreement cla) {
    if (account != null) {
        List<String> args = new ArrayList<>();
        addArg(args, "--submitter", getDisplayName(account));
        addArg(args, "--user-id", account.getId().toString());
        addArg(args, "--cla-name", cla.getName());
        runHook(claSignedHook, args);
    }
}
#method_after
@Override
public void doClaSignupHook(Account account, String claName) {
    if (!claSignedHook.isPresent()) {
        return;
    }
    if (account != null) {
        List<String> args = new ArrayList<>();
        addArg(args, "--submitter", getDisplayName(account));
        addArg(args, "--user-id", account.getId().toString());
        addArg(args, "--cla-name", claName);
        runHook(claSignedHook, args);
    }
}
#end_block

#method_before
private ApprovalAttribute getApprovalAttribute(LabelTypes labelTypes, Entry<String, Short> approval, Map<String, Boolean> approvalStatus) {
    ApprovalAttribute a = new ApprovalAttribute();
    a.type = approval.getKey();
    LabelType lt = labelTypes.byLabel(approval.getKey());
    if (lt != null) {
        a.description = lt.getName();
    }
    a.value = Short.toString(approval.getValue());
    a.updated = approvalStatus.get(approval.getKey());
    return a;
}
#method_after
private ApprovalAttribute getApprovalAttribute(LabelTypes labelTypes, Entry<String, Short> approval, Map<String, Short> oldApprovals) {
    ApprovalAttribute a = new ApprovalAttribute();
    a.type = approval.getKey();
    if (oldApprovals != null && !oldApprovals.isEmpty()) {
        if (oldApprovals.get(approval.getKey()) != null) {
            a.oldValue = Short.toString(oldApprovals.get(approval.getKey()));
        }
    }
    LabelType lt = labelTypes.byLabel(approval.getKey());
    if (lt != null) {
        a.description = lt.getName();
    }
    if (approval.getValue() != null) {
        a.value = Short.toString(approval.getValue());
    }
    return a;
}
#end_block

#method_before
private synchronized void runHook(Path hook, List<String> args) {
    if (Files.exists(hook)) {
        hookQueue.execute(new AsyncHookTask(null, hook, args));
    }
}
#method_after
private synchronized void runHook(Project.NameKey project, Optional<Path> hook, List<String> args) {
    if (project != null && hook.isPresent()) {
        hookQueue.execute(new AsyncHookTask(project, hook.get(), args));
    }
}
#end_block

#method_before
private HookResult runSyncHook(Project.NameKey project, Path hook, List<String> args) {
    if (!Files.exists(hook)) {
        return null;
    }
    SyncHookTask syncHook = new SyncHookTask(project, hook, args);
    FutureTask<HookResult> task = new FutureTask<>(syncHook);
    syncHookThreadPool.execute(task);
    String message;
    try {
        return task.get(syncHookTimeout, TimeUnit.SECONDS);
    } catch (TimeoutException e) {
        message = "Synchronous hook timed out " + hook.toAbsolutePath();
        log.error(message);
    } catch (Exception e) {
        message = "Error running hook " + hook.toAbsolutePath();
        log.error(message, e);
    }
    task.cancel(true);
    syncHook.cancel();
    return new HookResult(syncHook.getOutput(), message);
}
#method_after
private HookResult runSyncHook(Project.NameKey project, Optional<Path> hook, List<String> args) {
    if (!hook.isPresent()) {
        return null;
    }
    SyncHookTask syncHook = new SyncHookTask(project, hook.get(), args);
    FutureTask<HookResult> task = new FutureTask<>(syncHook);
    syncHookThreadPool.execute(task);
    String message;
    try {
        return task.get(syncHookTimeout, TimeUnit.SECONDS);
    } catch (TimeoutException e) {
        message = "Synchronous hook timed out " + hook.get().toAbsolutePath();
        log.error(message);
    } catch (Exception e) {
        message = "Error running hook " + hook.get().toAbsolutePath();
        log.error(message, e);
    }
    task.cancel(true);
    syncHook.cancel();
    return new HookResult(syncHook.getOutput(), message);
}
#end_block

#method_before
public ChangeAttribute asChangeAttribute(final Change change) {
    ChangeAttribute a = new ChangeAttribute();
    a.project = change.getProject().get();
    a.branch = change.getDest().getShortName();
    a.topic = change.getTopic();
    a.id = change.getKey().get();
    a.number = change.getId().toString();
    a.subject = change.getSubject();
    try {
        a.commitMessage = changeDataFactory.create(db.get(), change).commitMessage();
    } catch (Exception e) {
        log.error("Error while getting full commit message for" + " change " + a.number);
    }
    a.url = getChangeUrl(change);
    a.owner = asAccountAttribute(change.getOwner());
    a.status = change.getStatus();
    return a;
}
#method_after
public ChangeAttribute asChangeAttribute(Change change) {
    try (ReviewDb db = schema.open()) {
        return asChangeAttribute(db, change);
    } catch (OrmException e) {
        log.error("Cannot open database connection", e);
        return new ChangeAttribute();
    }
}
#end_block

#method_before
public ChangeAttribute asChangeAttribute(final Change change) {
    ChangeAttribute a = new ChangeAttribute();
    a.project = change.getProject().get();
    a.branch = change.getDest().getShortName();
    a.topic = change.getTopic();
    a.id = change.getKey().get();
    a.number = change.getId().toString();
    a.subject = change.getSubject();
    try {
        a.commitMessage = changeDataFactory.create(db.get(), change).commitMessage();
    } catch (Exception e) {
        log.error("Error while getting full commit message for" + " change " + a.number);
    }
    a.url = getChangeUrl(change);
    a.owner = asAccountAttribute(change.getOwner());
    a.status = change.getStatus();
    return a;
}
#method_after
public ChangeAttribute asChangeAttribute(ReviewDb db, Change change) {
    ChangeAttribute a = new ChangeAttribute();
    a.project = change.getProject().get();
    a.branch = change.getDest().getShortName();
    a.topic = change.getTopic();
    a.id = change.getKey().get();
    a.number = change.getId().toString();
    a.subject = change.getSubject();
    try {
        a.commitMessage = changeDataFactory.create(db, change).commitMessage();
    } catch (Exception e) {
        log.error("Error while getting full commit message for" + " change " + a.number);
    }
    a.url = getChangeUrl(change);
    a.owner = asAccountAttribute(change.getOwner());
    a.status = change.getStatus();
    return a;
}
#end_block

#method_before
public RefUpdateAttribute asRefUpdateAttribute(final ObjectId oldId, final ObjectId newId, final Branch.NameKey refName) {
    RefUpdateAttribute ru = new RefUpdateAttribute();
    ru.newRev = newId != null ? newId.getName() : ObjectId.zeroId().getName();
    ru.oldRev = oldId != null ? oldId.getName() : ObjectId.zeroId().getName();
    ru.project = refName.getParentKey().get();
    ru.refName = refName.get();
    return ru;
}
#method_after
public RefUpdateAttribute asRefUpdateAttribute(ObjectId oldId, ObjectId newId, Branch.NameKey refName) {
    RefUpdateAttribute ru = new RefUpdateAttribute();
    ru.newRev = newId != null ? newId.getName() : ObjectId.zeroId().getName();
    ru.oldRev = oldId != null ? oldId.getName() : ObjectId.zeroId().getName();
    ru.project = refName.getParentKey().get();
    ru.refName = refName.get();
    return ru;
}
#end_block

#method_before
public void addAllReviewers(ChangeAttribute a, ChangeNotes notes) throws OrmException {
    Collection<Account.Id> reviewers = approvalsUtil.getReviewers(db.get(), notes).values();
    if (!reviewers.isEmpty()) {
        a.allReviewers = Lists.newArrayListWithCapacity(reviewers.size());
        for (Account.Id id : reviewers) {
            a.allReviewers.add(asAccountAttribute(id));
        }
    }
}
#method_after
public void addAllReviewers(ReviewDb db, ChangeAttribute a, ChangeNotes notes) throws OrmException {
    Collection<Account.Id> reviewers = approvalsUtil.getReviewers(db, notes).values();
    if (!reviewers.isEmpty()) {
        a.allReviewers = Lists.newArrayListWithCapacity(reviewers.size());
        for (Account.Id id : reviewers) {
            a.allReviewers.add(asAccountAttribute(id));
        }
    }
}
#end_block

#method_before
public void addDependencies(ChangeAttribute ca, Change change) {
    ca.dependsOn = new ArrayList<>();
    ca.neededBy = new ArrayList<>();
    try (ReviewDb db = schema.open()) {
        final PatchSet.Id psId = change.currentPatchSetId();
        for (PatchSetAncestor a : db.patchSetAncestors().ancestorsOf(psId)) {
            for (PatchSet p : db.patchSets().byRevision(a.getAncestorRevision())) {
                Change c = db.changes().get(p.getId().getParentKey());
                if (c == null) {
                    log.error("Error while generating the ancestor change for" + " revision " + a.getAncestorRevision() + ": Cannot find" + " Change entry in database for " + p.getId().getParentKey());
                    continue;
                }
                ca.dependsOn.add(newDependsOn(c, p));
            }
        }
        final PatchSet ps = db.patchSets().get(psId);
        if (ps == null) {
            log.error("Error while generating the list of descendants for" + " PatchSet " + psId + ": Cannot find PatchSet entry in" + " database.");
        } else {
            final RevId revId = ps.getRevision();
            for (PatchSetAncestor a : db.patchSetAncestors().descendantsOf(revId)) {
                final PatchSet p = db.patchSets().get(a.getPatchSet());
                if (p == null) {
                    log.error("Error while generating the list of descendants for" + " revision " + revId.get() + ": Cannot find PatchSet entry in" + " database for " + a.getPatchSet());
                    continue;
                }
                final Change c = db.changes().get(p.getId().getParentKey());
                if (c == null) {
                    log.error("Error while generating the list of descendants for" + " revision " + revId.get() + ": Cannot find Change entry in" + " database for " + p.getId().getParentKey());
                    continue;
                }
                ca.neededBy.add(newNeededBy(c, p));
            }
        }
    } catch (OrmException e) {
    // Squash DB exceptions and leave dependency lists partially filled.
    }
    // Remove empty lists so a confusing label won't be displayed in the output.
    if (ca.dependsOn.isEmpty()) {
        ca.dependsOn = null;
    }
    if (ca.neededBy.isEmpty()) {
        ca.neededBy = null;
    }
}
#method_after
public void addDependencies(RevWalk rw, ChangeAttribute ca, Change change, PatchSet currentPs) {
    if (change == null || currentPs == null) {
        return;
    }
    ca.dependsOn = new ArrayList<>();
    ca.neededBy = new ArrayList<>();
    try {
        addDependsOn(rw, ca, change, currentPs);
        addNeededBy(rw, ca, change, currentPs);
    } catch (OrmException | IOException e) {
    // Squash DB exceptions and leave dependency lists partially filled.
    }
    // Remove empty lists so a confusing label won't be displayed in the output.
    if (ca.dependsOn.isEmpty()) {
        ca.dependsOn = null;
    }
    if (ca.neededBy.isEmpty()) {
        ca.neededBy = null;
    }
}
#end_block

#method_before
public void addPatchSets(ChangeAttribute ca, Collection<PatchSet> ps, Map<PatchSet.Id, Collection<PatchSetApproval>> approvals, boolean includeFiles, Change change, LabelTypes labelTypes) {
    if (!ps.isEmpty()) {
        ca.patchSets = new ArrayList<>(ps.size());
        for (PatchSet p : ps) {
            PatchSetAttribute psa = asPatchSetAttribute(p);
            if (approvals != null) {
                addApprovals(psa, p.getId(), approvals, labelTypes);
            }
            ca.patchSets.add(psa);
            if (includeFiles && change != null) {
                addPatchSetFileNames(psa, change, p);
            }
        }
    }
}
#method_after
public void addPatchSets(ReviewDb db, RevWalk revWalk, ChangeAttribute ca, Collection<PatchSet> ps, Map<PatchSet.Id, Collection<PatchSetApproval>> approvals, LabelTypes labelTypes) {
    addPatchSets(db, revWalk, ca, ps, approvals, false, null, labelTypes);
}
#end_block

#method_before
public PatchSetAttribute asPatchSetAttribute(final PatchSet patchSet) {
    PatchSetAttribute p = new PatchSetAttribute();
    p.revision = patchSet.getRevision().get();
    p.number = Integer.toString(patchSet.getPatchSetId());
    p.ref = patchSet.getRefName();
    p.uploader = asAccountAttribute(patchSet.getUploader());
    p.createdOn = patchSet.getCreatedOn().getTime() / 1000L;
    p.isDraft = patchSet.isDraft();
    final PatchSet.Id pId = patchSet.getId();
    try (ReviewDb db = schema.open()) {
        p.parents = new ArrayList<>();
        for (PatchSetAncestor a : db.patchSetAncestors().ancestorsOf(patchSet.getId())) {
            p.parents.add(a.getAncestorRevision().get());
        }
        UserIdentity author = psInfoFactory.get(db, pId).getAuthor();
        if (author.getAccount() == null) {
            p.author = new AccountAttribute();
            p.author.email = author.getEmail();
            p.author.name = author.getName();
            p.author.username = "";
        } else {
            p.author = asAccountAttribute(author.getAccount());
        }
        Change change = db.changes().get(pId.getParentKey());
        List<Patch> list = patchListCache.get(change, patchSet).toPatchList(pId);
        for (Patch pe : list) {
            if (!Patch.COMMIT_MSG.equals(pe.getFileName())) {
                p.sizeDeletions -= pe.getDeletions();
                p.sizeInsertions += pe.getInsertions();
            }
        }
        p.kind = changeKindCache.getChangeKind(db, change, patchSet);
    } catch (OrmException e) {
        log.error("Cannot load patch set data for " + patchSet.getId(), e);
    } catch (PatchSetInfoNotAvailableException e) {
        log.error(String.format("Cannot get authorEmail for %s.", pId), e);
    } catch (PatchListNotAvailableException e) {
        log.error(String.format("Cannot get size information for %s.", pId), e);
    }
    return p;
}
#method_after
public PatchSetAttribute asPatchSetAttribute(RevWalk revWalk, Change change, PatchSet patchSet) {
    try (ReviewDb db = schema.open()) {
        return asPatchSetAttribute(db, revWalk, change, patchSet);
    } catch (OrmException e) {
        log.error("Cannot open database connection", e);
        return new PatchSetAttribute();
    }
}
#end_block

#method_before
public AccountAttribute asAccountAttribute(final Account account) {
    if (account == null) {
        return null;
    }
    AccountAttribute who = new AccountAttribute();
    who.name = account.getFullName();
    who.email = account.getPreferredEmail();
    who.username = account.getUserName();
    return who;
}
#method_after
public AccountAttribute asAccountAttribute(Account account) {
    if (account == null) {
        return null;
    }
    AccountAttribute who = new AccountAttribute();
    who.name = account.getFullName();
    who.email = account.getPreferredEmail();
    who.username = account.getUserName();
    return who;
}
#end_block

#method_before
public ApprovalAttribute asApprovalAttribute(PatchSetApproval approval, LabelTypes labelTypes) {
    ApprovalAttribute a = new ApprovalAttribute();
    a.type = approval.getLabelId().get();
    a.value = Short.toString(approval.getValue());
    a.by = asAccountAttribute(approval.getAccountId());
    a.grantedOn = approval.getGranted().getTime() / 1000L;
    a.updated = false;
    LabelType lt = labelTypes.byLabel(approval.getLabelId());
    if (lt != null) {
        a.description = lt.getName();
    }
    return a;
}
#method_after
public ApprovalAttribute asApprovalAttribute(PatchSetApproval approval, LabelTypes labelTypes) {
    ApprovalAttribute a = new ApprovalAttribute();
    a.type = approval.getLabelId().get();
    a.value = Short.toString(approval.getValue());
    a.by = asAccountAttribute(approval.getAccountId());
    a.grantedOn = approval.getGranted().getTime() / 1000L;
    a.oldValue = null;
    LabelType lt = labelTypes.byLabel(approval.getLabelId());
    if (lt != null) {
        a.description = lt.getName();
    }
    return a;
}
#end_block

#method_before
private String getChangeUrl(final Change change) {
    if (change != null && urlProvider.get() != null) {
        final StringBuilder r = new StringBuilder();
        r.append(urlProvider.get());
        r.append(change.getChangeId());
        return r.toString();
    }
    return null;
}
#method_after
private String getChangeUrl(Change change) {
    if (change != null && urlProvider.get() != null) {
        StringBuilder r = new StringBuilder();
        r.append(urlProvider.get());
        r.append(change.getChangeId());
        return r.toString();
    }
    return null;
}
#end_block

#method_before
void add(Widget widget) {
    ((HTMLPanel) getWidget()).add(widget);
}
#method_after
void add(Widget widget) {
    widgets.add(widget);
}
#end_block

#method_before
public final void addLineClass(int line, LineClassWhere where, String className) {
    addLineClassNative(line, where.name().toLowerCase(), className);
}
#method_after
public final void addLineClass(int line, LineClassWhere where, String className) {
    addLineClassNative(line, where.value(), className);
}
#end_block

#method_before
public final void addLineClass(LineHandle line, LineClassWhere where, String className) {
    addLineClassNative(line, where.name().toLowerCase(), className);
}
#method_after
public final void addLineClass(LineHandle line, LineClassWhere where, String className) {
    addLineClassNative(line, where.value(), className);
}
#end_block

#method_before
public final void removeLineClass(int line, LineClassWhere where, String className) {
    removeLineClassNative(line, where.name().toLowerCase(), className);
}
#method_after
public final void removeLineClass(int line, LineClassWhere where, String className) {
    removeLineClassNative(line, where.value(), className);
}
#end_block

#method_before
public final void removeLineClass(LineHandle line, LineClassWhere where, String className) {
    removeLineClassNative(line, where.name().toLowerCase(), className);
}
#method_after
public final void removeLineClass(LineHandle line, LineClassWhere where, String className) {
    removeLineClassNative(line, where.value(), className);
}
#end_block

#method_before
void setOpen(boolean open) {
    UIObject.setVisible(summary, !open);
    UIObject.setVisible(message, open);
    UIObject.setVisible(buttons, open);
    if (open) {
        removeStyleName(style.closed());
    } else {
        addStyleName(style.closed());
    }
    super.setOpen(open);
}
#method_after
@Override
void setOpen(boolean open) {
    UIObject.setVisible(summary, !open);
    UIObject.setVisible(message, open);
    UIObject.setVisible(buttons, open && replyBox == null);
    if (open) {
        removeStyleName(style.closed());
    } else {
        addStyleName(style.closed());
    }
    super.setOpen(open);
}
#end_block

#method_before
void unregisterReplyBox() {
    replyBox = null;
}
#method_after
void unregisterReplyBox() {
    replyBox = null;
    UIObject.setVisible(buttons, isOpen());
}
#end_block

#method_before
DraftBox addReplyBox() {
    DraftBox box = getDiffScreen().addDraftBox(getDiffScreen().createReply(comment), getSide());
    registerReplyBox(box);
    return box;
}
#method_after
void addReplyBox(boolean quote) {
    CommentInfo commentReply = CommentInfo.createReply(comment);
    if (quote) {
        commentReply.message(ReplyBox.quote(comment.message()));
    }
    getCommentManager().addDraftBox(getCm().side(), commentReply).setEdit(true);
}
#end_block

#method_before
void doReply() {
    if (!Gerrit.isSignedIn()) {
        Gerrit.doSignIn(getDiffScreen().getToken());
    } else if (replyBox == null) {
        DraftBox box = addReplyBox();
        if (!getCommentInfo().has_line()) {
            getDiffScreen().addFileCommentBox(box);
        }
    } else {
        openReplyBox();
    }
}
#method_after
void doReply() {
    if (!Gerrit.isSignedIn()) {
        Gerrit.doSignIn(getCommentManager().getDiffScreen().getToken());
    } else if (replyBox == null) {
        addReplyBox(false);
    } else {
        openReplyBox();
    }
}
#end_block

#method_before
@UiHandler("done")
void onReplyDone(ClickEvent e) {
    e.stopPropagation();
    if (!Gerrit.isSignedIn()) {
        Gerrit.doSignIn(getDiffScreen().getToken());
    } else if (replyBox == null) {
        done.setEnabled(false);
        CommentInput input = CommentInput.create(getDiffScreen().createReply(comment));
        input.setMessage(PatchUtil.C.cannedReplyDone());
        CommentApi.createDraft(psId, input, new GerritCallback<CommentInfo>() {

            @Override
            public void onSuccess(CommentInfo result) {
                done.setEnabled(true);
                setOpen(false);
                DraftBox box = getDiffScreen().addDraftBox(result, getSide());
                registerReplyBox(box);
                if (!getCommentInfo().has_line()) {
                    getDiffScreen().addFileCommentBox(box);
                }
            }
        });
    } else {
        openReplyBox();
        setOpen(false);
    }
}
#method_after
@UiHandler("done")
void onReplyDone(ClickEvent e) {
    e.stopPropagation();
    if (!Gerrit.isSignedIn()) {
        Gerrit.doSignIn(getCommentManager().getDiffScreen().getToken());
    } else if (replyBox == null) {
        done.setEnabled(false);
        CommentInfo input = CommentInfo.createReply(comment);
        input.message(PatchUtil.C.cannedReplyDone());
        CommentApi.createDraft(psId, input, new GerritCallback<CommentInfo>() {

            @Override
            public void onSuccess(CommentInfo result) {
                done.setEnabled(true);
                setOpen(false);
                getCommentManager().addDraftBox(getCm().side(), result);
            }
        });
    } else {
        openReplyBox();
        setOpen(false);
    }
}
#end_block

#method_before
private static String authorName(CommentInfo info) {
    if (info.author() != null) {
        if (info.author().name() != null) {
            return info.author().name();
        }
        return Gerrit.getConfig().getAnonymousCowardName();
    }
    return Util.C.messageNoAuthor();
}
#method_after
private static String authorName(CommentInfo info) {
    if (info.author() != null) {
        if (info.author().name() != null) {
            return info.author().name();
        }
        return Gerrit.info().user().anonymousCowardName();
    }
    return Util.C.messageNoAuthor();
}
#end_block

#method_before
void setOpen(boolean open) {
    resizePaddingWidget();
    setRangeHighlight(open);
    getCm().focus();
}
#method_after
void setOpen(boolean open) {
    group.resize();
    setRangeHighlight(open);
    getCm().focus();
}
#end_block

#method_before
void setRangeHighlight(boolean highlight) {
    if (fromTo != null) {
        if (highlight && rangeHighlightMarker == null) {
            rangeHighlightMarker = cm.markText(fromTo.getFrom(), fromTo.getTo(), Configuration.create().set("className", Resources.I.diffTableStyle().rangeHighlight()));
        } else if (!highlight && rangeHighlightMarker != null) {
            rangeHighlightMarker.clear();
            rangeHighlightMarker = null;
        }
    }
}
#method_after
void setRangeHighlight(boolean highlight) {
    if (fromTo != null) {
        if (highlight && rangeHighlightMarker == null) {
            rangeHighlightMarker = group.getCm().markText(fromTo.from(), fromTo.to(), Configuration.create().set("className", Resources.I.diffTableStyle().rangeHighlight()));
        } else if (!highlight && rangeHighlightMarker != null) {
            rangeHighlightMarker.clear();
            rangeHighlightMarker = null;
        }
    }
}
#end_block

#method_before
void clearRange() {
    if (rangeMarker != null) {
        rangeMarker.clear();
    }
}
#method_after
void clearRange() {
    if (rangeMarker != null) {
        rangeMarker.clear();
        rangeMarker = null;
    }
}
#end_block

#method_before
CodeMirror getCm() {
    return cm;
}
#method_after
CodeMirror getCm() {
    return group.getCm();
}
#end_block

#method_before
private static String toPatch(String type, PatchSet.Id diffBase, Patch.Key id) {
    return toPatch(type, diffBase, id.getParentKey(), id.get());
}
#method_after
public static String toPatch(String type, PatchSet.Id diffBase, Patch.Key id) {
    return toPatch(type, diffBase, id.getParentKey(), id.get(), null, 0);
}
#end_block

#method_before
public static String toPatch(final PatchScreen.Type type, final Patch.Key id) {
    if (type == PatchScreen.Type.SIDE_BY_SIDE) {
        return toPatchSideBySide(id);
    } else {
        return toPatchUnified(id);
    }
}
#method_after
private static String toPatch(String type, PatchSet.Id diffBase, PatchSet.Id revision, String fileName, DisplaySide side, int line) {
    Change.Id c = revision.getParentKey();
    StringBuilder p = new StringBuilder();
    p.append("/c/").append(c).append("/");
    if (diffBase != null) {
        p.append(diffBase.get()).append("..");
    }
    p.append(revision.getId()).append("/").append(KeyUtil.encode(fileName));
    if (type != null && !type.isEmpty() && (!"sidebyside".equals(type) || preferUnified())) {
        p.append(",").append(type);
    }
    if (side == DisplaySide.A && line > 0) {
        p.append("@a").append(line);
    } else if (line > 0) {
        p.append("@").append(line);
    }
    return p.toString();
}
#end_block

#method_before
public static String toGroup(final AccountGroup.Id id) {
    return "/admin/groups/" + id.toString();
}
#method_after
public static String toGroup(final AccountGroup.Id id) {
    return ADMIN_GROUPS + id.toString();
}
#end_block

#method_before
public static String toGroup(AccountGroup.Id id, String panel) {
    return "/admin/groups/" + id.toString() + "," + panel;
}
#method_after
public static String toGroup(AccountGroup.Id id, String panel) {
    return ADMIN_GROUPS + id.toString() + "," + panel;
}
#end_block

#method_before
public static String toProjectAdmin(Project.NameKey n, String panel) {
    if (panel == null || ProjectScreen.INFO.equals(panel)) {
        return "/admin/projects/" + n.toString();
    }
    return "/admin/projects/" + n.toString() + "," + panel;
}
#method_after
public static String toProjectAdmin(Project.NameKey n, String panel) {
    if (panel == null || ProjectScreen.INFO.equals(panel)) {
        return ADMIN_PROJECTS + n.toString();
    }
    return ADMIN_PROJECTS + n.toString() + "," + panel;
}
#end_block

#method_before
private static void select(final String token) {
    if (matchPrefix("/q/", token)) {
        query(token);
    } else if (matchPrefix("/c/", token)) {
        change(token);
    } else if (matchExact(MINE, token)) {
        Gerrit.display(token, mine(token));
    } else if (matchPrefix("/dashboard/", token)) {
        dashboard(token);
    } else if (matchPrefix(PROJECTS, token)) {
        projects(token);
    } else if (// 
    matchExact(SETTINGS, token) || // 
    matchPrefix("/settings/", token) || // 
    matchExact("register", token) || // 
    matchExact(REGISTER, token) || // 
    matchPrefix("/register/", token) || matchPrefix("/VE/", token) || // 
    matchPrefix("VE,", token) || matchPrefix("/SignInFailure,", token)) {
        settings(token);
    } else if (matchPrefix("/admin/", token)) {
        admin(token);
    } else if (/* DEPRECATED URL */
    matchPrefix("/c2/", token)) {
        changeScreen2 = true;
        change(token);
    } else if (/* LEGACY URL */
    matchPrefix("all,", token)) {
        redirectFromLegacyToken(token, legacyAll(token));
    } else if (/* LEGACY URL */
    matchPrefix("mine,", token) || matchExact("mine", token)) {
        redirectFromLegacyToken(token, legacyMine(token));
    } else if (/* LEGACY URL */
    matchPrefix("project,", token)) {
        redirectFromLegacyToken(token, legacyProject(token));
    } else if (/* LEGACY URL */
    matchPrefix("change,", token)) {
        redirectFromLegacyToken(token, legacyChange(token));
    } else if (/* LEGACY URL */
    matchPrefix("patch,", token)) {
        redirectFromLegacyToken(token, legacyPatch(token));
    } else if (/* LEGACY URL */
    matchPrefix("admin,", token)) {
        redirectFromLegacyToken(token, legacyAdmin(token));
    } else if (/* LEGACY URL */
    matchPrefix("settings,", token) || matchPrefix("register,", token) || matchPrefix("q,", token)) {
        redirectFromLegacyToken(token, legacySettings(token));
    } else {
        Gerrit.display(token, new NotFoundScreen());
    }
}
#method_after
private static void select(String token) {
    token = Gerrit.getUrlAliasMatcher().replace(token);
    if (matchPrefix(QUERY, token)) {
        query(token);
    } else if (matchPrefix("/Documentation/", token)) {
        docSearch(token);
    } else if (matchPrefix("/c/", token)) {
        change(token);
    } else if (matchPrefix("/x/", token)) {
        extension(token);
    } else if (matchExact(MINE, token)) {
        String defaultScreenToken = Gerrit.getDefaultScreenToken();
        if (defaultScreenToken != null && !MINE.equals(defaultScreenToken)) {
            select(defaultScreenToken);
        } else {
            Gerrit.display(token, mine());
        }
    } else if (matchPrefix("/dashboard/", token)) {
        dashboard(token);
    } else if (matchPrefix(PROJECTS, token)) {
        projects(token);
    } else if (matchExact(SETTINGS, token) || matchPrefix("/settings/", token) || matchExact(MY_GROUPS, token) || matchExact("register", token) || matchExact(REGISTER, token) || matchPrefix("/register/", token) || matchPrefix("/VE/", token) || matchPrefix("VE,", token) || matchPrefix("/SignInFailure,", token)) {
        settings(token);
    } else if (matchPrefix("/admin/", token)) {
        admin(token);
    } else {
        Gerrit.display(token, new NotFoundScreen());
    }
}
#end_block

#method_before
private static void query(final String token) {
    final String s = skip(token);
    final int c = s.indexOf(',');
    Gerrit.display(token, new QueryScreen(s.substring(0, c), s.substring(c + 1)));
}
#method_after
private static void query(String token) {
    String s = skip(token);
    int c = s.indexOf(',');
    Screen screen;
    if (c >= 0) {
        String prefix = s.substring(0, c);
        if (s.substring(c).equals(",n,z")) {
            // Respect legacy token with max sortkey.
            screen = new QueryScreen(prefix, 0);
        } else {
            screen = new QueryScreen(prefix, Integer.parseInt(s.substring(c + 1)));
        }
    } else {
        screen = new QueryScreen(s, 0);
    }
    Gerrit.display(token, screen);
}
#end_block

#method_before
private static Screen mine(final String token) {
    if (Gerrit.isSignedIn()) {
        return new AccountDashboardScreen(Gerrit.getUserAccount().getId());
    } else {
        Screen r = new AccountDashboardScreen(null);
        r.setRequiresSignIn(true);
        return r;
    }
}
#method_after
private static Screen mine() {
    if (Gerrit.isSignedIn()) {
        return new AccountDashboardScreen(Gerrit.getUserAccount().getId());
    } else {
        Screen r = new AccountDashboardScreen(null);
        r.setRequiresSignIn(true);
        return r;
    }
}
#end_block

#method_before
private static void dashboard(final String token) {
    String rest = skip(token);
    if (rest.matches("[0-9]+")) {
        Gerrit.display(token, new AccountDashboardScreen(Account.Id.parse(rest)));
        return;
    }
    if (rest.startsWith("?")) {
        Gerrit.display(token, new CustomDashboardScreen(rest.substring(1)));
        return;
    }
    Gerrit.display(token, new NotFoundScreen());
}
#method_after
private static void dashboard(final String token) {
    String rest = skip(token);
    if (rest.matches("[0-9]+")) {
        Gerrit.display(token, new AccountDashboardScreen(Account.Id.parse(rest)));
        return;
    }
    if (rest.equals("self")) {
        if (Gerrit.isSignedIn()) {
            Gerrit.display(token, new AccountDashboardScreen(Gerrit.getUserAccount().getId()));
        } else {
            Screen s = new AccountDashboardScreen(null);
            s.setRequiresSignIn(true);
            Gerrit.display(token, s);
        }
        return;
    }
    if (rest.startsWith("?")) {
        Gerrit.display(token, new CustomDashboardScreen(rest.substring(1)));
        return;
    }
    Gerrit.display(token, new NotFoundScreen());
}
#end_block

#method_before
private static void projects(final String token) {
    String rest = skip(token);
    int c = rest.indexOf(DASHBOARDS);
    if (0 <= c) {
        final String project = URL.decodePathSegment(rest.substring(0, c));
        rest = rest.substring(c);
        if (matchPrefix(DASHBOARDS, rest)) {
            final String dashboardId = skip(rest);
            GerritCallback<DashboardInfo> cb = new GerritCallback<DashboardInfo>() {

                @Override
                public void onSuccess(DashboardInfo result) {
                    if (matchPrefix("/dashboard/", result.url())) {
                        String params = skip(result.url()).substring(1);
                        ProjectDashboardScreen dash = new ProjectDashboardScreen(new Project.NameKey(project), params);
                        Gerrit.display(token, dash);
                    }
                }

                @Override
                public void onFailure(Throwable caught) {
                    if ("default".equals(dashboardId) && RestApi.isNotFound(caught)) {
                        Gerrit.display(PageLinks.toChangeQuery(PageLinks.projectQuery(new Project.NameKey(project))));
                    } else {
                        super.onFailure(caught);
                    }
                }
            };
            if ("default".equals(dashboardId)) {
                DashboardList.getDefault(new Project.NameKey(project), cb);
                return;
            }
            c = dashboardId.indexOf(":");
            if (0 <= c) {
                final String ref = URL.decodeQueryString(dashboardId.substring(0, c));
                final String path = URL.decodeQueryString(dashboardId.substring(c + 1));
                DashboardList.get(new Project.NameKey(project), ref + ":" + path, cb);
                return;
            }
        }
    }
    Gerrit.display(token, new NotFoundScreen());
}
#method_after
private static void projects(final String token) {
    String rest = skip(token);
    int c = rest.indexOf(DASHBOARDS);
    if (0 <= c) {
        final String project = URL.decodePathSegment(rest.substring(0, c));
        rest = rest.substring(c);
        if (matchPrefix(DASHBOARDS, rest)) {
            final String dashboardId = skip(rest);
            GerritCallback<DashboardInfo> cb = new GerritCallback<DashboardInfo>() {

                @Override
                public void onSuccess(DashboardInfo result) {
                    if (matchPrefix("/dashboard/", result.url())) {
                        String params = skip(result.url()).substring(1);
                        ProjectDashboardScreen dash = new ProjectDashboardScreen(new Project.NameKey(project), params);
                        Gerrit.display(token, dash);
                    }
                }

                @Override
                public void onFailure(Throwable caught) {
                    if ("default".equals(dashboardId) && RestApi.isNotFound(caught)) {
                        Gerrit.display(toChangeQuery(PageLinks.projectQuery(new Project.NameKey(project))));
                    } else {
                        super.onFailure(caught);
                    }
                }
            };
            if ("default".equals(dashboardId)) {
                DashboardList.getDefault(new Project.NameKey(project), cb);
                return;
            }
            c = dashboardId.indexOf(":");
            if (0 <= c) {
                final String ref = URL.decodeQueryString(dashboardId.substring(0, c));
                final String path = URL.decodeQueryString(dashboardId.substring(c + 1));
                DashboardList.get(new Project.NameKey(project), ref + ":" + path, cb);
                return;
            }
        }
    }
    Gerrit.display(token, new NotFoundScreen());
}
#end_block

#method_before
private static void change(final String token) {
    String rest = skip(token);
    int c = rest.lastIndexOf(',');
    String panel = null;
    if (0 <= c) {
        panel = rest.substring(c + 1);
        rest = rest.substring(0, c);
    }
    Change.Id id;
    int s = rest.indexOf('/');
    if (0 <= s) {
        id = Change.Id.parse(rest.substring(0, s));
        rest = rest.substring(s + 1);
    } else {
        id = Change.Id.parse(rest);
        rest = "";
    }
    if (rest.isEmpty()) {
        Gerrit.display(token, panel == null ? (isChangeScreen2() ? new ChangeScreen2(id, null, false) : new ChangeScreen(id)) : new NotFoundScreen());
        return;
    }
    String psIdStr;
    s = rest.indexOf('/');
    if (0 <= s) {
        psIdStr = rest.substring(0, s);
        rest = rest.substring(s + 1);
    } else {
        psIdStr = rest;
        rest = "";
    }
    PatchSet.Id base;
    PatchSet.Id ps;
    int dotdot = psIdStr.indexOf("..");
    if (1 <= dotdot) {
        base = new PatchSet.Id(id, Integer.parseInt(psIdStr.substring(0, dotdot)));
        ps = new PatchSet.Id(id, Integer.parseInt(psIdStr.substring(dotdot + 2)));
    } else {
        base = null;
        ps = new PatchSet.Id(id, Integer.parseInt(psIdStr));
    }
    if (!rest.isEmpty()) {
        Patch.Key p = new Patch.Key(ps, KeyUtil.decode(rest));
        patch(token, base, p, 0, null, null, panel);
    } else {
        if (panel == null) {
            Gerrit.display(token, isChangeScreen2() ? new ChangeScreen2(id, String.valueOf(ps.get()), false) : new ChangeScreen(id));
        } else if ("publish".equals(panel)) {
            publish(ps);
        } else {
            Gerrit.display(token, new NotFoundScreen());
        }
    }
}
#method_after
private static void change(final String token) {
    String rest = skip(token);
    int c = rest.lastIndexOf(',');
    String panel = null;
    if (0 <= c) {
        panel = rest.substring(c + 1);
        rest = rest.substring(0, c);
        int at = panel.lastIndexOf('@');
        if (at > 0) {
            rest += panel.substring(at);
            panel = panel.substring(0, at);
        }
    }
    Change.Id id;
    int s = rest.indexOf('/');
    if (0 <= s) {
        id = Change.Id.parse(rest.substring(0, s));
        rest = rest.substring(s + 1);
    } else {
        id = Change.Id.parse(rest);
        rest = "";
    }
    if (rest.isEmpty()) {
        FileTable.Mode mode = FileTable.Mode.REVIEW;
        if (panel != null && (panel.equals("edit") || panel.startsWith("edit/"))) {
            mode = FileTable.Mode.EDIT;
            panel = null;
        }
        Gerrit.display(token, panel == null ? new ChangeScreen(id, null, null, false, mode) : new NotFoundScreen());
        return;
    }
    String psIdStr;
    s = rest.indexOf('/');
    if (0 <= s) {
        psIdStr = rest.substring(0, s);
        rest = rest.substring(s + 1);
    } else {
        psIdStr = rest;
        rest = "";
    }
    PatchSet.Id base = null;
    PatchSet.Id ps;
    int dotdot = psIdStr.indexOf("..");
    if (1 <= dotdot) {
        base = new PatchSet.Id(id, Integer.parseInt(psIdStr.substring(0, dotdot)));
        psIdStr = psIdStr.substring(dotdot + 2);
    }
    ps = toPsId(id, psIdStr);
    if (!rest.isEmpty()) {
        DisplaySide side = DisplaySide.B;
        int line = 0;
        int at = rest.lastIndexOf('@');
        if (at > 0) {
            String l = rest.substring(at + 1);
            if (l.startsWith("a")) {
                side = DisplaySide.A;
                l = l.substring(1);
            }
            line = Integer.parseInt(l);
            rest = rest.substring(0, at);
        }
        Patch.Key p = new Patch.Key(ps, KeyUtil.decode(rest));
        patch(token, base, p, side, line, panel);
    } else {
        if (panel == null) {
            Gerrit.display(token, new ChangeScreen(id, base != null ? String.valueOf(base.get()) : null, String.valueOf(ps.get()), false, FileTable.Mode.REVIEW));
        } else {
            Gerrit.display(token, new NotFoundScreen());
        }
    }
}
#end_block

#method_before
public static void patch(String token, final PatchSet.Id baseId, final Patch.Key id, final int patchIndex, final PatchSetDetail patchSetDetail, final PatchTable patchTable, final PatchScreen.TopView topView, final String panelType) {
    final PatchScreen.TopView top = topView == null ? Gerrit.getPatchScreenTopView() : topView;
    GWT.runAsync(new AsyncSplit(token) {

        public void onSuccess() {
            Gerrit.display(token, select());
        }

        private Screen select() {
            if (id != null) {
                String panel = panelType;
                if (panel == null) {
                    int c = token.lastIndexOf(',');
                    panel = 0 <= c ? token.substring(c + 1) : "";
                }
                if ("".equals(panel)) {
                    return new // 
                    PatchScreen.SideBySide(// 
                    id, // 
                    patchIndex, // 
                    patchSetDetail, // 
                    patchTable, // 
                    top, // 
                    baseId);
                } else if ("unified".equals(panel)) {
                    return new // 
                    PatchScreen.Unified(// 
                    id, // 
                    patchIndex, // 
                    patchSetDetail, // 
                    patchTable, // 
                    top, // 
                    baseId);
                } else if ("cm".equals(panel)) {
                    if (Gerrit.isSignedIn() && DiffView.UNIFIED_DIFF.equals(Gerrit.getUserAccount().getGeneralPreferences().getDiffView())) {
                        return new // 
                        PatchScreen.Unified(// 
                        id, // 
                        patchIndex, // 
                        patchSetDetail, // 
                        patchTable, // 
                        top, // 
                        baseId);
                    }
                    return new SideBySide2(baseId, id.getParentKey(), id.get());
                } else if ("unified2".equals(panel)) {
                    return new Unified2(baseId, id.getParentKey(), id.get());
                }
            }
            return new NotFoundScreen();
        }
    });
}
#method_after
private static void patch(String token, PatchSet.Id baseId, Patch.Key id, DisplaySide side, int line, String panelType) {
    String panel = panelType;
    if (panel == null) {
        int c = token.lastIndexOf(',');
        panel = 0 <= c ? token.substring(c + 1) : "";
    }
    if ("".equals(panel) || /* DEPRECATED URL */
    "cm".equals(panel)) {
        if (preferUnified()) {
            unified(token, baseId, id, side, line);
        } else {
            codemirror(token, baseId, id, side, line, false);
        }
    } else if ("sidebyside".equals(panel)) {
        codemirror(token, null, id, side, line, false);
    } else if ("unified".equals(panel)) {
        unified(token, baseId, id, side, line);
    } else if ("unified1".equals(panel)) {
        unified1(token, baseId, id);
    } else if ("edit".equals(panel)) {
        codemirror(token, null, id, side, line, true);
    } else {
        Gerrit.display(token, new NotFoundScreen());
    }
}
#end_block

#method_before
private static void settings(String token) {
    GWT.runAsync(new AsyncSplit(token) {

        public void onSuccess() {
            Gerrit.display(token, select());
        }

        private Screen select() {
            if (matchExact(SETTINGS, token)) {
                return new MyProfileScreen();
            }
            if (matchExact(SETTINGS_PREFERENCES, token)) {
                return new MyPreferencesScreen();
            }
            if (matchExact(SETTINGS_PROJECTS, token)) {
                return new MyWatchedProjectsScreen();
            }
            if (matchExact(SETTINGS_CONTACT, token)) {
                return new MyContactInformationScreen();
            }
            if (matchExact(SETTINGS_SSHKEYS, token)) {
                return new MySshKeysScreen();
            }
            if (matchExact(SETTINGS_WEBIDENT, token)) {
                return new MyIdentitiesScreen();
            }
            if (matchExact(SETTINGS_HTTP_PASSWORD, token)) {
                return new MyPasswordScreen();
            }
            if (matchExact(SETTINGS_MYGROUPS, token)) {
                return new MyGroupsScreen();
            }
            if (matchExact(SETTINGS_AGREEMENTS, token) && Gerrit.getConfig().isUseContributorAgreements()) {
                return new MyAgreementsScreen();
            }
            if (matchExact(REGISTER, token) || matchExact("/register/", token) || matchExact("register", token)) {
                return new RegisterScreen(MINE);
            } else if (matchPrefix("/register/", token)) {
                return new RegisterScreen("/" + skip(token));
            }
            if (matchPrefix("/VE/", token) || matchPrefix("VE,", token))
                return new ValidateEmailScreen(skip(token));
            if (matchExact(SETTINGS_NEW_AGREEMENT, token))
                return new NewAgreementScreen();
            if (matchPrefix(SETTINGS_NEW_AGREEMENT + "/", token)) {
                return new NewAgreementScreen(skip(token));
            }
            return new NotFoundScreen();
        }
    });
}
#method_after
private static void settings(String token) {
    GWT.runAsync(new AsyncSplit(token) {

        @Override
        public void onSuccess() {
            Gerrit.display(token, select());
        }

        private Screen select() {
            if (matchExact(SETTINGS, token)) {
                return new MyProfileScreen();
            }
            if (matchExact(SETTINGS_PREFERENCES, token)) {
                return new MyPreferencesScreen();
            }
            if (matchExact(SETTINGS_DIFF_PREFERENCES, token)) {
                return new MyDiffPreferencesScreen();
            }
            if (matchExact(SETTINGS_EDIT_PREFERENCES, token)) {
                return new MyEditPreferencesScreen();
            }
            if (matchExact(SETTINGS_PROJECTS, token)) {
                return new MyWatchedProjectsScreen();
            }
            if (matchExact(SETTINGS_CONTACT, token)) {
                return new MyContactInformationScreen();
            }
            if (matchExact(SETTINGS_SSHKEYS, token)) {
                return new MySshKeysScreen();
            }
            if (matchExact(SETTINGS_GPGKEYS, token) && Gerrit.info().gerrit().editGpgKeys()) {
                return new MyGpgKeysScreen();
            }
            if (matchExact(SETTINGS_WEBIDENT, token)) {
                return new MyIdentitiesScreen();
            }
            if (matchExact(SETTINGS_HTTP_PASSWORD, token)) {
                return new MyPasswordScreen();
            }
            if (matchExact(MY_GROUPS, token) || matchExact(SETTINGS_MYGROUPS, token)) {
                return new MyGroupsScreen();
            }
            if (matchExact(SETTINGS_AGREEMENTS, token) && Gerrit.info().auth().useContributorAgreements()) {
                return new MyAgreementsScreen();
            }
            if (matchExact(REGISTER, token) || matchExact("/register/", token) || matchExact("register", token)) {
                return new RegisterScreen(MINE);
            } else if (matchPrefix("/register/", token)) {
                return new RegisterScreen("/" + skip(token));
            }
            if (matchPrefix("/VE/", token) || matchPrefix("VE,", token)) {
                return new ValidateEmailScreen(skip(token));
            }
            if (matchExact(SETTINGS_NEW_AGREEMENT, token)) {
                return new NewAgreementScreen();
            }
            if (matchPrefix(SETTINGS_NEW_AGREEMENT + "/", token)) {
                return new NewAgreementScreen(skip(token));
            }
            if (matchPrefix(SETTINGS_EXTENSION, token)) {
                ExtensionSettingsScreen view = new ExtensionSettingsScreen(skip(token));
                if (view.isFound()) {
                    return view;
                } else {
                    return new NotFoundScreen();
                }
            }
            return new NotFoundScreen();
        }
    });
}
#end_block

#method_before
private static void admin(String token) {
    GWT.runAsync(new AsyncSplit(token) {

        public void onSuccess() {
            if (matchExact(ADMIN_GROUPS, token) || matchExact("/admin/groups", token)) {
                Gerrit.display(token, new GroupListScreen());
            } else if (matchPrefix("/admin/groups/", token)) {
                String rest = skip(token);
                if (rest.startsWith("?")) {
                    Gerrit.display(token, new GroupListScreen(rest.substring(1)));
                } else {
                    group();
                }
            } else if (matchPrefix("/admin/groups", token)) {
                String rest = skip(token);
                if (rest.startsWith("?")) {
                    Gerrit.display(token, new GroupListScreen(rest.substring(1)));
                }
            } else if (matchExact(ADMIN_PROJECTS, token) || matchExact("/admin/projects", token)) {
                Gerrit.display(token, new ProjectListScreen());
            } else if (matchPrefix("/admin/projects/", token)) {
                String rest = skip(token);
                if (rest.startsWith("?")) {
                    Gerrit.display(token, new ProjectListScreen(rest.substring(1)));
                } else {
                    Gerrit.display(token, selectProject());
                }
            } else if (matchPrefix("/admin/projects", token)) {
                String rest = skip(token);
                if (rest.startsWith("?")) {
                    Gerrit.display(token, new ProjectListScreen(rest.substring(1)));
                }
            } else if (matchPrefix(ADMIN_PLUGINS, token) || matchExact("/admin/plugins", token)) {
                Gerrit.display(token, new PluginListScreen());
            } else if (matchExact(ADMIN_CREATE_PROJECT, token) || matchExact("/admin/create-project", token)) {
                Gerrit.display(token, new CreateProjectScreen());
            } else if (matchExact(ADMIN_CREATE_GROUP, token) || matchExact("/admin/create-group", token)) {
                Gerrit.display(token, new CreateGroupScreen());
            } else {
                Gerrit.display(token, new NotFoundScreen());
            }
        }

        private void group() {
            final String panel;
            final String group;
            if (matchPrefix("/admin/groups/uuid-", token)) {
                String p = skip(token);
                int c = p.indexOf(',');
                if (c < 0) {
                    group = p;
                    panel = null;
                } else {
                    group = p.substring(0, c);
                    panel = p.substring(c + 1);
                }
            } else if (matchPrefix("/admin/groups/", token)) {
                String p = skip(token);
                int c = p.indexOf(',');
                if (c < 0) {
                    group = p;
                    panel = null;
                } else {
                    group = p.substring(0, c);
                    panel = p.substring(c + 1);
                }
            } else {
                Gerrit.display(token, new NotFoundScreen());
                return;
            }
            GroupApi.getGroupDetail(group, new GerritCallback<GroupInfo>() {

                @Override
                public void onSuccess(GroupInfo group) {
                    if (panel == null || panel.isEmpty()) {
                        // 
                        if (AccountGroup.isInternalGroup(group.getGroupUUID()) && !AccountGroup.isSystemGroup(group.getGroupUUID())) {
                            Gerrit.display(toGroup(group.getGroupId(), AccountGroupScreen.MEMBERS), new AccountGroupMembersScreen(group, token));
                        } else {
                            Gerrit.display(toGroup(group.getGroupId(), AccountGroupScreen.INFO), new AccountGroupInfoScreen(group, token));
                        }
                    } else if (AccountGroupScreen.INFO.equals(panel)) {
                        Gerrit.display(token, new AccountGroupInfoScreen(group, token));
                    } else if (AccountGroupScreen.MEMBERS.equals(panel)) {
                        Gerrit.display(token, new AccountGroupMembersScreen(group, token));
                    } else {
                        Gerrit.display(token, new NotFoundScreen());
                    }
                }
            });
        }

        private Screen selectProject() {
            if (matchPrefix("/admin/projects/", token)) {
                String rest = skip(token);
                int c = rest.lastIndexOf(',');
                if (c < 0) {
                    return new ProjectInfoScreen(Project.NameKey.parse(rest));
                } else if (c == 0) {
                    return new NotFoundScreen();
                }
                Project.NameKey k = Project.NameKey.parse(rest.substring(0, c));
                String panel = rest.substring(c + 1);
                if (ProjectScreen.INFO.equals(panel)) {
                    return new ProjectInfoScreen(k);
                }
                if (ProjectScreen.BRANCH.equals(panel)) {
                    return new ProjectBranchesScreen(k);
                }
                if (ProjectScreen.ACCESS.equals(panel)) {
                    return new ProjectAccessScreen(k);
                }
                if (ProjectScreen.DASHBOARDS.equals(panel)) {
                    return new ProjectDashboardsScreen(k);
                }
            }
            return new NotFoundScreen();
        }
    });
}
#method_after
private static void admin(String token) {
    GWT.runAsync(new AsyncSplit(token) {

        @Override
        public void onSuccess() {
            if (matchExact(ADMIN_GROUPS, token) || matchExact("/admin/groups", token)) {
                Gerrit.display(token, new GroupListScreen());
            } else if (matchPrefix(ADMIN_GROUPS, token)) {
                String rest = skip(token);
                if (rest.startsWith("?")) {
                    Gerrit.display(token, new GroupListScreen(rest.substring(1)));
                } else {
                    group();
                }
            } else if (matchPrefix("/admin/groups", token)) {
                String rest = skip(token);
                if (rest.startsWith("?")) {
                    Gerrit.display(token, new GroupListScreen(rest.substring(1)));
                }
            } else if (matchExact(ADMIN_PROJECTS, token) || matchExact("/admin/projects", token)) {
                Gerrit.display(token, new ProjectListScreen());
            } else if (matchPrefix(ADMIN_PROJECTS, token)) {
                String rest = skip(token);
                if (rest.startsWith("?")) {
                    Gerrit.display(token, new ProjectListScreen(rest.substring(1)));
                } else {
                    Gerrit.display(token, selectProject());
                }
            } else if (matchPrefix("/admin/projects", token)) {
                String rest = skip(token);
                if (rest.startsWith("?")) {
                    Gerrit.display(token, new ProjectListScreen(rest.substring(1)));
                }
            } else if (matchPrefix(ADMIN_PLUGINS, token) || matchExact("/admin/plugins", token)) {
                Gerrit.display(token, new PluginListScreen());
            } else if (matchExact(ADMIN_CREATE_PROJECT, token) || matchExact("/admin/create-project", token)) {
                Gerrit.display(token, new CreateProjectScreen());
            } else if (matchExact(ADMIN_CREATE_GROUP, token) || matchExact("/admin/create-group", token)) {
                Gerrit.display(token, new CreateGroupScreen());
            } else {
                Gerrit.display(token, new NotFoundScreen());
            }
        }

        private void group() {
            final String panel;
            final String group;
            if (matchPrefix("/admin/groups/uuid-", token)) {
                String p = skip(token);
                int c = p.indexOf(',');
                if (c < 0) {
                    group = p;
                    panel = null;
                } else {
                    group = p.substring(0, c);
                    panel = p.substring(c + 1);
                }
            } else if (matchPrefix(ADMIN_GROUPS, token)) {
                String p = skip(token);
                int c = p.indexOf(',');
                if (c < 0) {
                    group = p;
                    panel = null;
                } else {
                    group = p.substring(0, c);
                    panel = p.substring(c + 1);
                }
            } else {
                Gerrit.display(token, new NotFoundScreen());
                return;
            }
            GroupApi.getGroupDetail(group, new GerritCallback<GroupInfo>() {

                @Override
                public void onSuccess(GroupInfo group) {
                    if (panel == null || panel.isEmpty()) {
                        // 
                        if (AccountGroup.isInternalGroup(group.getGroupUUID())) {
                            Gerrit.display(toGroup(group.getGroupId(), AccountGroupScreen.MEMBERS), new AccountGroupMembersScreen(group, token));
                        } else {
                            Gerrit.display(toGroup(group.getGroupId(), AccountGroupScreen.INFO), new AccountGroupInfoScreen(group, token));
                        }
                    } else if (AccountGroupScreen.INFO.equals(panel)) {
                        Gerrit.display(token, new AccountGroupInfoScreen(group, token));
                    } else if (AccountGroupScreen.MEMBERS.equals(panel)) {
                        Gerrit.display(token, new AccountGroupMembersScreen(group, token));
                    } else if (AccountGroupScreen.AUDIT_LOG.equals(panel)) {
                        Gerrit.display(token, new AccountGroupAuditLogScreen(group, token));
                    } else {
                        Gerrit.display(token, new NotFoundScreen());
                    }
                }
            });
        }

        private Screen selectProject() {
            if (matchPrefix(ADMIN_PROJECTS, token)) {
                String rest = skip(token);
                int c = rest.lastIndexOf(',');
                if (c < 0) {
                    return new ProjectInfoScreen(Project.NameKey.parse(rest));
                } else if (c == 0) {
                    return new NotFoundScreen();
                }
                int q = rest.lastIndexOf('?');
                if (q > 0 && rest.lastIndexOf(',', q) > 0) {
                    c = rest.substring(0, q - 1).lastIndexOf(',');
                }
                Project.NameKey k = Project.NameKey.parse(rest.substring(0, c));
                String panel = rest.substring(c + 1);
                if (ProjectScreen.INFO.equals(panel)) {
                    return new ProjectInfoScreen(k);
                }
                if (ProjectScreen.BRANCHES.equals(panel) || matchPrefix(ProjectScreen.BRANCHES, panel)) {
                    return new ProjectBranchesScreen(k);
                }
                if (ProjectScreen.TAGS.equals(panel) || matchPrefix(ProjectScreen.TAGS, panel)) {
                    return new ProjectTagsScreen(k);
                }
                if (ProjectScreen.ACCESS.equals(panel)) {
                    return new ProjectAccessScreen(k);
                }
                if (ProjectScreen.DASHBOARDS.equals(panel)) {
                    return new ProjectDashboardsScreen(k);
                }
            }
            return new NotFoundScreen();
        }
    });
}
#end_block

#method_before
public final void onFailure(Throwable reason) {
    if (!isReloadUi && "HTTP download failed with status 404".equals(reason.getMessage())) {
        // The server was upgraded since we last download the main script,
        // so the pointers to the splits aren't valid anymore.  Force the
        // page to reload itself and pick up the new code.
        // 
        Gerrit.upgradeUI(token);
    } else {
        new ErrorDialog(reason).center();
    }
}
#method_after
@Override
public final void onFailure(Throwable reason) {
    if (!isReloadUi && "HTTP download failed with status 404".equals(reason.getMessage())) {
        // The server was upgraded since we last download the main script,
        // so the pointers to the splits aren't valid anymore.  Force the
        // page to reload itself and pick up the new code.
        // 
        Gerrit.upgradeUI(token);
    } else {
        new ErrorDialog(reason).center();
    }
}
#end_block

#method_before
private static boolean canCopy(ProjectState project, PatchSetApproval psa, PatchSet.Id psId, NavigableSet<Integer> allPsIds, ChangeKind kind) {
    int n = psa.getKey().getParentKey().get();
    checkArgument(n != psId.get());
    LabelType type = project.getLabelTypes().byLabel(psa.getLabelId());
    if (type == null) {
        return false;
    } else if (Objects.equals(n, previous(allPsIds, psId.get())) && (type.isCopyMinScore() && type.isMaxNegative(psa) || type.isCopyMaxScore() && type.isMaxPositive(psa))) {
        // may not be psId.get() - 1).
        return true;
    }
    return (type.isCopyAllScoresOnMergeBaseUpdate() && kind == MERGE_FIRST_PARENT_UPDATE) || (type.isCopyAllScoresOnTrivialRebase() && kind == TRIVIAL_REBASE) || (type.isCopyAllScoresIfNoCodeChange() && kind == NO_CODE_CHANGE) || (type.isCopyAllScoresIfNoChange() && kind == NO_CHANGE);
}
#method_after
private static boolean canCopy(ProjectState project, PatchSetApproval psa, PatchSet.Id psId, NavigableSet<Integer> allPsIds, ChangeKind kind) {
    int n = psa.getKey().getParentKey().get();
    checkArgument(n != psId.get());
    LabelType type = project.getLabelTypes().byLabel(psa.getLabelId());
    if (type == null) {
        return false;
    } else if (Objects.equals(n, previous(allPsIds, psId.get())) && (type.isCopyMinScore() && type.isMaxNegative(psa) || type.isCopyMaxScore() && type.isMaxPositive(psa))) {
        // may not be psId.get() - 1).
        return true;
    }
    return (type.isCopyAllScoresOnMergeFirstParentUpdate() && kind == MERGE_FIRST_PARENT_UPDATE) || (type.isCopyAllScoresOnTrivialRebase() && kind == TRIVIAL_REBASE) || (type.isCopyAllScoresIfNoCodeChange() && kind == NO_CODE_CHANGE) || (type.isCopyAllScoresIfNoChange() && kind == NO_CHANGE);
}
#end_block

#method_before
private void selectNewAndReplacedChangesFromMagicBranch() {
    newChanges = Lists.newArrayList();
    SetMultimap<ObjectId, Ref> existing = changeRefsById();
    GroupCollector groupCollector = new GroupCollector(refsById, db);
    rp.getRevWalk().reset();
    rp.getRevWalk().sort(RevSort.TOPO);
    rp.getRevWalk().sort(RevSort.REVERSE, true);
    try {
        rp.getRevWalk().markStart(rp.getRevWalk().parseCommit(magicBranch.cmd.getNewId()));
        if (magicBranch.baseCommit != null) {
            for (RevCommit c : magicBranch.baseCommit) {
                rp.getRevWalk().markUninteresting(c);
            }
            Ref targetRef = allRefs.get(magicBranch.ctl.getRefName());
            if (targetRef != null) {
                rp.getRevWalk().markUninteresting(rp.getRevWalk().parseCommit(targetRef.getObjectId()));
            }
        } else {
            markHeadsAsUninteresting(rp.getRevWalk(), magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
        }
        List<ChangeLookup> pending = Lists.newArrayList();
        final Set<Change.Key> newChangeIds = new HashSet<>();
        final int maxBatchChanges = receiveConfig.getEffectiveMaxBatchChangesLimit(user);
        for (; ; ) {
            final RevCommit c = rp.getRevWalk().next();
            if (c == null) {
                break;
            }
            groupCollector.visit(c);
            Collection<Ref> existingRefs = existing.get(c);
            if (!existingRefs.isEmpty()) {
                // A's group.
                for (Ref ref : existingRefs) {
                    updateGroups.add(new UpdateGroupsRequest(ref, c));
                }
                continue;
            }
            if (!validCommit(rp.getRevWalk(), magicBranch.ctl, magicBranch.cmd, c)) {
                // Not a change the user can propose? Abort as early as possible.
                newChanges = Collections.emptyList();
                return;
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
            }
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(c, magicBranch.dest.get()));
                continue;
            }
            final String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                newChanges = Collections.emptyList();
                return;
            }
            pending.add(new ChangeLookup(c, new Change.Key(idStr)));
            if (maxBatchChanges != 0 && pending.size() + newChanges.size() > maxBatchChanges) {
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                newChanges = Collections.emptyList();
                return;
            }
        }
        for (ChangeLookup p : pending) {
            if (newChangeIds.contains(p.changeKey)) {
                reject(magicBranch.cmd, "squash commits first");
                newChanges = Collections.emptyList();
                return;
            }
            List<ChangeData> changes = p.destChanges;
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 1) {
                // 
                if (requestReplace(magicBranch.cmd, false, changes.get(0).change(), p.commit)) {
                    continue;
                } else {
                    newChanges = Collections.emptyList();
                    return;
                }
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    newChanges = Collections.emptyList();
                    return;
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(p.commit, magicBranch.dest.get()));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        newChanges = Collections.emptyList();
        return;
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        newChanges = Collections.emptyList();
        return;
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return;
    }
    if (!newChanges.isEmpty() && magicBranch.edit) {
        reject(magicBranch.cmd, "edit is not supported for new changes");
        return;
    }
    try {
        Multimap<ObjectId, String> groups = groupCollector.getGroups();
        for (CreateRequest create : newChanges) {
            batch.addCommand(create.cmd);
            create.groups = groups.get(create.commitId);
        }
        for (ReplaceRequest replace : replaceByChange.values()) {
            replace.groups = groups.get(replace.newCommitId);
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.groups = Sets.newHashSet(groups.get(update.commit));
        }
    } catch (OrmException e) {
        log.error("Error collecting groups for changes", e);
        reject(magicBranch.cmd, "internal server error");
        return;
    }
}
#method_after
private void selectNewAndReplacedChangesFromMagicBranch() {
    newChanges = Lists.newArrayList();
    SetMultimap<ObjectId, Ref> existing = changeRefsById();
    GroupCollector groupCollector = GroupCollector.create(refsById, db, psUtil, notesFactory);
    rp.getRevWalk().reset();
    rp.getRevWalk().sort(RevSort.TOPO);
    rp.getRevWalk().sort(RevSort.REVERSE, true);
    try {
        rp.getRevWalk().markStart(rp.getRevWalk().parseCommit(magicBranch.cmd.getNewId()));
        if (magicBranch.baseCommit != null) {
            for (RevCommit c : magicBranch.baseCommit) {
                rp.getRevWalk().markUninteresting(c);
            }
            Ref targetRef = allRefs.get(magicBranch.ctl.getRefName());
            if (targetRef != null) {
                rp.getRevWalk().markUninteresting(rp.getRevWalk().parseCommit(targetRef.getObjectId()));
            }
        } else {
            markHeadsAsUninteresting(rp.getRevWalk(), magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
        }
        List<ChangeLookup> pending = Lists.newArrayList();
        final Set<Change.Key> newChangeIds = new HashSet<>();
        final int maxBatchChanges = receiveConfig.getEffectiveMaxBatchChangesLimit(user);
        for (; ; ) {
            final RevCommit c = rp.getRevWalk().next();
            if (c == null) {
                break;
            }
            groupCollector.visit(c);
            Collection<Ref> existingRefs = existing.get(c);
            if (!existingRefs.isEmpty()) {
                // A's group.
                for (Ref ref : existingRefs) {
                    updateGroups.add(new UpdateGroupsRequest(ref, c));
                }
                continue;
            }
            if (!validCommit(rp.getRevWalk(), magicBranch.ctl, magicBranch.cmd, c)) {
                // Not a change the user can propose? Abort as early as possible.
                newChanges = Collections.emptyList();
                return;
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
            }
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(c, magicBranch.dest.get()));
                continue;
            }
            final String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                newChanges = Collections.emptyList();
                return;
            }
            pending.add(new ChangeLookup(c, new Change.Key(idStr)));
            if (maxBatchChanges != 0 && pending.size() + newChanges.size() > maxBatchChanges) {
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                newChanges = Collections.emptyList();
                return;
            }
        }
        for (ChangeLookup p : pending) {
            if (newChangeIds.contains(p.changeKey)) {
                reject(magicBranch.cmd, "squash commits first");
                newChanges = Collections.emptyList();
                return;
            }
            List<ChangeData> changes = p.destChanges;
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 1) {
                // 
                if (requestReplace(magicBranch.cmd, false, changes.get(0).change(), p.commit)) {
                    continue;
                } else {
                    newChanges = Collections.emptyList();
                    return;
                }
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    newChanges = Collections.emptyList();
                    return;
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(p.commit, magicBranch.dest.get()));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        newChanges = Collections.emptyList();
        return;
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        newChanges = Collections.emptyList();
        return;
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return;
    }
    if (!newChanges.isEmpty() && magicBranch.edit) {
        reject(magicBranch.cmd, "edit is not supported for new changes");
        return;
    }
    try {
        SortedSetMultimap<ObjectId, String> groups = groupCollector.getGroups();
        for (CreateRequest create : newChanges) {
            batch.addCommand(create.cmd);
            create.groups = ImmutableList.copyOf(groups.get(create.commitId));
        }
        for (ReplaceRequest replace : replaceByChange.values()) {
            replace.groups = ImmutableList.copyOf(groups.get(replace.newCommitId));
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.groups = ImmutableList.copyOf((groups.get(update.commit)));
        }
    } catch (OrmException e) {
        log.error("Error collecting groups for changes", e);
        reject(magicBranch.cmd, "internal server error");
        return;
    }
}
#end_block

#method_before
private void insertChange(RequestState state) throws OrmException, IOException, RestApiException, UpdateException {
    RevCommit commit = state.rw.parseCommit(commitId);
    state.rw.parseBody(commit);
    final PatchSet.Id psId = ins.setGroups(groups).getPatchSetId();
    final Account.Id me = user.getAccountId();
    final List<FooterLine> footerLines = commit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    Map<String, Short> approvals = new HashMap<>();
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.labels;
    }
    recipients.add(getRecipientsFromFooters(accountResolver, magicBranch.draft, footerLines));
    recipients.remove(me);
    String msg = renderMessageWithApprovals(psId.get(), null, approvals, Collections.<String, PatchSetApproval>emptyMap());
    try (BatchUpdate bu = batchUpdateFactory.create(state.db, magicBranch.dest.getParentKey(), user, TimeUtil.nowTs())) {
        bu.setRepository(state.repo, state.rw, state.ins);
        bu.insertChange(ins.setReviewers(recipients.getReviewers()).setExtraCC(recipients.getCcOnly()).setApprovals(approvals).setMessage(msg).setRequestScopePropagator(requestScopePropagator).setSendMail(true).setUpdateRef(false));
        if (magicBranch != null) {
            bu.addOp(changeId, hashtagsFactory.create(new HashtagsInput(magicBranch.hashtags)).setRunHooks(false));
            if (!Strings.isNullOrEmpty(magicBranch.topic)) {
                bu.addOp(changeId, new BatchUpdate.Op() {

                    @Override
                    public boolean updateChange(ChangeContext ctx) {
                        ctx.getUpdate(psId).setTopic(magicBranch.topic);
                        return true;
                    }
                });
            }
        }
        bu.execute();
    }
    change = ins.getChange();
    if (magicBranch != null && magicBranch.submit) {
        submit(projectControl.controlFor(change), ins.getPatchSet());
    }
}
#method_after
private void insertChange(RequestState state) throws OrmException, IOException, RestApiException, UpdateException {
    RevCommit commit = state.rw.parseCommit(commitId);
    state.rw.parseBody(commit);
    final PatchSet.Id psId = ins.setGroups(groups).getPatchSetId();
    final Account.Id me = user.getAccountId();
    final List<FooterLine> footerLines = commit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    Map<String, Short> approvals = new HashMap<>();
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.labels;
    }
    recipients.add(getRecipientsFromFooters(accountResolver, magicBranch.draft, footerLines));
    recipients.remove(me);
    String msg = renderMessageWithApprovals(psId.get(), null, approvals, Collections.<String, PatchSetApproval>emptyMap());
    try (BatchUpdate bu = batchUpdateFactory.create(state.db, magicBranch.dest.getParentKey(), user, TimeUtil.nowTs())) {
        bu.setRepository(state.repo, state.rw, state.ins);
        bu.insertChange(ins.setReviewers(recipients.getReviewers()).setExtraCC(recipients.getCcOnly()).setApprovals(approvals).setMessage(msg).setRequestScopePropagator(requestScopePropagator).setSendMail(true).setUpdateRef(true));
        if (magicBranch != null) {
            bu.addOp(changeId, hashtagsFactory.create(new HashtagsInput(magicBranch.hashtags)).setRunHooks(false));
            if (!Strings.isNullOrEmpty(magicBranch.topic)) {
                bu.addOp(changeId, new BatchUpdate.Op() {

                    @Override
                    public boolean updateChange(ChangeContext ctx) {
                        ctx.getUpdate(psId).setTopic(magicBranch.topic);
                        return true;
                    }
                });
            }
        }
        bu.execute();
    }
    change = ins.getChange();
    if (magicBranch != null && magicBranch.submit) {
        submit(projectControl.controlFor(change), ins.getPatchSet());
    }
}
#end_block

#method_before
private void submit(ChangeControl changeCtl, PatchSet ps) throws OrmException, RestApiException {
    Submit submit = submitProvider.get();
    RevisionResource rsrc = new RevisionResource(changes.parse(changeCtl), ps);
    try (MergeOp op = mergeOpProvider.get()) {
        op.merge(db, rsrc.getChange(), changeCtl.getUser().asIdentifiedUser(), false);
    }
    addMessage("");
    Change c = db.changes().get(rsrc.getChange().getId());
    switch(c.getStatus()) {
        case MERGED:
            addMessage("Change " + c.getChangeId() + " merged.");
            break;
        case NEW:
            ChangeMessage msg = submit.getConflictMessage(rsrc);
            if (msg != null) {
                addMessage("Change " + c.getChangeId() + ": " + msg.getMessage());
                break;
            }
        // $FALL-THROUGH$
        case ABANDONED:
        case DRAFT:
        default:
            addMessage("change " + c.getChangeId() + " is " + c.getStatus().name().toLowerCase());
    }
}
#method_after
private void submit(ChangeControl changeCtl, PatchSet ps) throws OrmException, RestApiException {
    Submit submit = submitProvider.get();
    RevisionResource rsrc = new RevisionResource(changes.parse(changeCtl), ps);
    try (MergeOp op = mergeOpProvider.get()) {
        op.merge(db, rsrc.getChange(), changeCtl.getUser().asIdentifiedUser(), false, null);
    }
    addMessage("");
    Change c = db.changes().get(rsrc.getChange().getId());
    switch(c.getStatus()) {
        case MERGED:
            addMessage("Change " + c.getChangeId() + " merged.");
            break;
        case NEW:
            ChangeMessage msg = submit.getConflictMessage(rsrc);
            if (msg != null) {
                addMessage("Change " + c.getChangeId() + ": " + msg.getMessage());
                break;
            }
        // $FALL-THROUGH$
        case ABANDONED:
        case DRAFT:
        default:
            addMessage("change " + c.getChangeId() + " is " + c.getStatus().name().toLowerCase());
    }
}
#end_block

#method_before
PatchSet.Id insertPatchSet(RequestState state) throws OrmException, IOException, RestApiException {
    ReviewDb db = state.db;
    Repository repo = state.repo;
    final RevCommit newCommit = state.rw.parseCommit(newCommitId);
    state.rw.parseBody(newCommit);
    final Account.Id me = user.getAccountId();
    final List<FooterLine> footerLines = newCommit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    final PatchSet newPatchSet;
    Map<String, Short> approvals = new HashMap<>();
    ChangeUpdate update = updateFactory.create(changeCtl, createdOn);
    update.setSubjectForCommit("Create patch set " + psId.get());
    update.setPatchSetId(psId);
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.labels;
        Set<String> hashtags = magicBranch.hashtags;
        ChangeNotes notes = changeCtl.getNotes().load();
        if (!hashtags.isEmpty()) {
            hashtags.addAll(notes.getHashtags());
            update.setHashtags(hashtags);
        }
        if (magicBranch.topic != null && !magicBranch.topic.equals(notes.getChange().getTopic())) {
            update.setTopic(magicBranch.topic);
        }
    }
    db.changes().beginTransaction(change.getId());
    ChangeKind changeKind = ChangeKind.REWORK;
    try {
        change = db.changes().get(change.getId());
        if (change == null || change.getStatus().isClosed()) {
            reject(inputCommand, "change is closed");
            return null;
        }
        Iterable<String> newGroups = groups;
        if (newGroups == null) {
            PatchSet prevPs = psUtil.current(db, update.getChangeNotes());
            newGroups = prevPs != null ? prevPs.getGroups() : null;
        }
        boolean draft = magicBranch != null && magicBranch.draft;
        newPatchSet = psUtil.insert(db, state.rw, update, psId, newCommit, draft, newGroups, rp.getPushCertificate() != null ? rp.getPushCertificate().toTextWithSignature() : null);
        if (checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), newCommit);
            mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        recipients.add(getRecipientsFromFooters(accountResolver, draft, footerLines));
        recipients.remove(me);
        ChangeData cd = changeDataFactory.create(db, changeCtl);
        MailRecipients oldRecipients = getRecipientsFromReviewers(cd.reviewers());
        approvalCopier.copy(db, changeCtl, newPatchSet);
        approvalsUtil.addReviewers(db, update, labelTypes, change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
        approvalsUtil.addApprovals(db, update, labelTypes, newPatchSet, changeCtl, approvals);
        recipients.add(oldRecipients);
        RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
        changeKind = changeKindCache.getChangeKind(projectControl.getProjectState(), repo, priorCommit, newCommit);
        cmUtil.addChangeMessage(db, update, newChangeMessage(db, changeKind, approvals));
        if (mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isClosed()) {
                        return null;
                    }
                    if (!change.currentPatchSetId().equals(priorPatchSet)) {
                        return change;
                    }
                    if (magicBranch != null && magicBranch.topic != null) {
                        change.setTopic(magicBranch.topic);
                    }
                    if (change.getStatus() == Change.Status.DRAFT && newPatchSet.isDraft()) {
                    // Leave in draft status.
                    } else {
                        change.setStatus(Change.Status.NEW);
                    }
                    change.setCurrentPatchSet(info);
                    final List<String> idList = newCommit.getFooterLines(CHANGE_ID);
                    if (idList.isEmpty()) {
                        change.setKey(new Change.Key("I" + newCommit.name()));
                    } else {
                        change.setKey(new Change.Key(idList.get(idList.size() - 1).trim()));
                    }
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(newPatchSet));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(inputCommand, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    if (mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, info, mergedIntoRef, changeCtl);
    }
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    indexer.index(db, change);
    if (changeKind != ChangeKind.TRIVIAL_REBASE) {
        sendEmailExecutor.submit(requestScopePropagator.wrap(new Runnable() {

            @Override
            public void run() {
                try {
                    ReplacePatchSetSender cm = replacePatchSetFactory.create(change.getId());
                    cm.setFrom(me);
                    cm.setPatchSet(newPatchSet, info);
                    cm.setChangeMessage(msg);
                    cm.addReviewers(recipients.getReviewers());
                    cm.addExtraCC(recipients.getCcOnly());
                    cm.send();
                } catch (Exception e) {
                    log.error("Cannot send email for new patch set " + newPatchSet.getId(), e);
                }
                if (mergedIntoRef != null) {
                    sendMergedEmail(newPatchSet, info);
                }
            }

            @Override
            public String toString() {
                return "send-email newpatchset";
            }
        }));
    }
    gitRefUpdated.fire(project.getNameKey(), newPatchSet.getRefName(), ObjectId.zeroId(), newCommit);
    hooks.doPatchsetCreatedHook(change, newPatchSet, db);
    if (mergedIntoRef != null) {
        hooks.doChangeMergedHook(change, user.getAccount(), newPatchSet, db, newCommit.getName());
    }
    if (!approvals.isEmpty()) {
        hooks.doCommentAddedHook(change, user.getAccount(), newPatchSet, null, approvals, db);
    }
    if (magicBranch != null && magicBranch.submit) {
        submit(changeCtl, newPatchSet);
    }
    return newPatchSet.getId();
}
#method_after
PatchSet.Id insertPatchSet(RequestState state) throws OrmException, IOException, RestApiException {
    ReviewDb db = state.db;
    Repository repo = state.repo;
    final RevCommit newCommit = state.rw.parseCommit(newCommitId);
    state.rw.parseBody(newCommit);
    final Account.Id me = user.getAccountId();
    final List<FooterLine> footerLines = newCommit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    final PatchSet newPatchSet;
    Map<String, Short> approvals = new HashMap<>();
    ChangeUpdate update = updateFactory.create(changeCtl, createdOn);
    update.setSubjectForCommit("Create patch set " + psId.get());
    update.setPatchSetId(psId);
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.labels;
        Set<String> hashtags = magicBranch.hashtags;
        ChangeNotes notes = changeCtl.getNotes().load();
        if (!hashtags.isEmpty()) {
            hashtags.addAll(notes.getHashtags());
            update.setHashtags(hashtags);
        }
        if (magicBranch.topic != null && !magicBranch.topic.equals(notes.getChange().getTopic())) {
            update.setTopic(magicBranch.topic);
        }
    }
    db.changes().beginTransaction(change.getId());
    ChangeKind changeKind = ChangeKind.REWORK;
    try {
        change = db.changes().get(change.getId());
        if (change == null || change.getStatus().isClosed()) {
            reject(inputCommand, "change is closed");
            return null;
        }
        List<String> newGroups = groups;
        if (newGroups.isEmpty()) {
            PatchSet prevPs = psUtil.current(db, update.getChangeNotes());
            newGroups = prevPs != null ? prevPs.getGroups() : ImmutableList.<String>of();
        }
        boolean draft = magicBranch != null && magicBranch.draft;
        newPatchSet = psUtil.insert(db, state.rw, update, psId, newCommit, draft, newGroups, rp.getPushCertificate() != null ? rp.getPushCertificate().toTextWithSignature() : null);
        if (checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), newCommit);
            mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        recipients.add(getRecipientsFromFooters(accountResolver, draft, footerLines));
        recipients.remove(me);
        ChangeData cd = changeDataFactory.create(db, changeCtl);
        MailRecipients oldRecipients = getRecipientsFromReviewers(cd.reviewers());
        approvalCopier.copy(db, changeCtl, newPatchSet);
        approvalsUtil.addReviewers(db, update, labelTypes, change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
        approvalsUtil.addApprovals(db, update, labelTypes, newPatchSet, changeCtl, approvals);
        recipients.add(oldRecipients);
        RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
        changeKind = changeKindCache.getChangeKind(projectControl.getProjectState(), repo, priorCommit, newCommit);
        cmUtil.addChangeMessage(db, update, newChangeMessage(db, changeKind, approvals));
        if (mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isClosed()) {
                        return null;
                    }
                    if (!change.currentPatchSetId().equals(priorPatchSet)) {
                        return change;
                    }
                    if (magicBranch != null && magicBranch.topic != null) {
                        change.setTopic(magicBranch.topic);
                    }
                    if (change.getStatus() == Change.Status.DRAFT && newPatchSet.isDraft()) {
                    // Leave in draft status.
                    } else {
                        change.setStatus(Change.Status.NEW);
                    }
                    change.setCurrentPatchSet(info);
                    final List<String> idList = newCommit.getFooterLines(CHANGE_ID);
                    if (idList.isEmpty()) {
                        change.setKey(new Change.Key("I" + newCommit.name()));
                    } else {
                        change.setKey(new Change.Key(idList.get(idList.size() - 1).trim()));
                    }
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(newPatchSet));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(inputCommand, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    if (mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, info, mergedIntoRef, changeCtl);
    }
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    indexer.index(db, change);
    if (changeKind != ChangeKind.TRIVIAL_REBASE) {
        sendEmailExecutor.submit(requestScopePropagator.wrap(new Runnable() {

            @Override
            public void run() {
                try {
                    ReplacePatchSetSender cm = replacePatchSetFactory.create(change.getId());
                    cm.setFrom(me);
                    cm.setPatchSet(newPatchSet, info);
                    cm.setChangeMessage(msg);
                    if (magicBranch != null) {
                        cm.setNotify(magicBranch.notify);
                    }
                    cm.addReviewers(recipients.getReviewers());
                    cm.addExtraCC(recipients.getCcOnly());
                    cm.send();
                } catch (Exception e) {
                    log.error("Cannot send email for new patch set " + newPatchSet.getId(), e);
                }
                if (mergedIntoRef != null) {
                    sendMergedEmail(newPatchSet, info);
                }
            }

            @Override
            public String toString() {
                return "send-email newpatchset";
            }
        }));
    }
    gitRefUpdated.fire(project.getNameKey(), newPatchSet.getRefName(), ObjectId.zeroId(), newCommit);
    hooks.doPatchsetCreatedHook(change, newPatchSet, db);
    if (mergedIntoRef != null) {
        hooks.doChangeMergedHook(change, user.getAccount(), newPatchSet, db, newCommit.getName());
    }
    if (!approvals.isEmpty()) {
        hooks.doCommentAddedHook(change, user.getAccount(), newPatchSet, null, approvals, db);
    }
    if (magicBranch != null && magicBranch.submit) {
        submit(changeCtl, newPatchSet);
    }
    return newPatchSet.getId();
}
#end_block

#method_before
private void markChangeMergedByPush(ReviewDb db, final PatchSetInfo info, String mergedIntoRef, ChangeControl control) throws OrmException, IOException {
    Change.Id id = info.getKey().getParentKey();
    db.changes().beginTransaction(id);
    Change change;
    ChangeUpdate update;
    try {
        change = db.changes().atomicUpdate(id, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.setCurrentPatchSet(info);
                    change.setStatus(Change.Status.MERGED);
                    ChangeUtil.updated(change);
                }
                return change;
            }
        });
        StringBuilder msgBuf = new StringBuilder();
        msgBuf.append("Change has been successfully pushed");
        if (!mergedIntoRef.equals(change.getDest().get())) {
            msgBuf.append(" into ");
            if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
                msgBuf.append("branch ");
                msgBuf.append(Repository.shortenRefName(mergedIntoRef));
            } else {
                msgBuf.append(mergedIntoRef);
            }
        }
        msgBuf.append(".");
        ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(id, ChangeUtil.messageUUID(db)), user.getAccountId(), change.getLastUpdatedOn(), info.getKey());
        msg.setMessage(msgBuf.toString());
        update = updateFactory.create(control, change.getLastUpdatedOn());
        cmUtil.addChangeMessage(db, update, msg);
        db.commit();
    } finally {
        db.rollback();
    }
    indexer.index(db, change);
    update.commit();
}
#method_after
private void markChangeMergedByPush(ReviewDb db, final PatchSetInfo info, String mergedIntoRef, ChangeControl control) throws OrmException, IOException {
    Change.Id id = info.getKey().getParentKey();
    db.changes().beginTransaction(id);
    Change change;
    ChangeUpdate update;
    try {
        change = db.changes().atomicUpdate(id, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.setCurrentPatchSet(info);
                    change.setStatus(Change.Status.MERGED);
                    ChangeUtil.updated(change);
                }
                return change;
            }
        });
        StringBuilder msgBuf = new StringBuilder();
        msgBuf.append("Change has been successfully pushed");
        if (!mergedIntoRef.equals(change.getDest().get())) {
            msgBuf.append(" into ");
            if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
                msgBuf.append("branch ");
                msgBuf.append(Repository.shortenRefName(mergedIntoRef));
            } else {
                msgBuf.append(mergedIntoRef);
            }
        }
        msgBuf.append(".");
        ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(id, ChangeUtil.messageUUID(db)), user.getAccountId(), change.getLastUpdatedOn(), info.getKey());
        msg.setMessage(msgBuf.toString());
        update = updateFactory.create(control, change.getLastUpdatedOn());
        // we cannot reconstruct the submit records for when this change was
        // submitted, this is why we must fix the status
        update.fixStatus(Change.Status.MERGED);
        cmUtil.addChangeMessage(db, update, msg);
        db.commit();
    } finally {
        db.rollback();
    }
    indexer.index(db, change);
    update.commit();
}
#end_block

#method_before
public void setCopyAllScoresOnMergeFirstParentUpdate(boolean copyAllScoresOnMergeFirstParentUpdate) {
    this.copyAllScoresOnMergeFirestParentUpdate = copyAllScoresOnMergeFirstParentUpdate;
}
#method_after
public void setCopyAllScoresOnMergeFirstParentUpdate(boolean copyAllScoresOnMergeFirstParentUpdate) {
    this.copyAllScoresOnMergeFirstParentUpdate = copyAllScoresOnMergeFirstParentUpdate;
}
#end_block

#method_before
@Override
public ChangeKind call() throws IOException {
    if (Objects.equals(key.prior, key.next)) {
        return ChangeKind.NO_CODE_CHANGE;
    }
    try (RevWalk walk = new RevWalk(repo)) {
        RevCommit prior = walk.parseCommit(key.prior);
        walk.parseBody(prior);
        RevCommit next = walk.parseCommit(key.next);
        walk.parseBody(next);
        if (!next.getFullMessage().equals(prior.getFullMessage())) {
            if (isSameDeltaAndTree(prior, next)) {
                return ChangeKind.NO_CODE_CHANGE;
            } else {
                return ChangeKind.REWORK;
            }
        }
        if (isSameDeltaAndTree(prior, next)) {
            return ChangeKind.NO_CHANGE;
        }
        if ((prior.getParentCount() != 1 || next.getParentCount() != 1) && (sameFirstParents(prior, next) || !sameRestOfParents(prior, next))) {
            // Trivial rebases done by machine only work well on 1 parent.
            return ChangeKind.REWORK;
        }
        // A trivial rebase can be detected by looking for the next commit
        // having the same tree as would exist when the prior commit is
        // cherry-picked onto the next commit's new first parent.
        ThreeWayMerger merger = MergeUtil.newThreeWayMerger(repo, MergeUtil.createDryRunInserter(repo), key.strategyName);
        merger.setBase(prior.getParent(0));
        try {
            if (merger.merge(next.getParent(0), prior) && merger.getResultTreeId().equals(next.getTree())) {
                if (prior.getParentCount() == 1) {
                    return ChangeKind.TRIVIAL_REBASE;
                } else {
                    return ChangeKind.MERGE_FIRST_PARENT_UPDATE;
                }
            }
        } catch (LargeObjectException e) {
        // Some object is too large for the merge attempt to succeed. Assume
        // it was a rework.
        }
        return ChangeKind.REWORK;
    }
}
#method_after
@Override
public ChangeKind call() throws IOException {
    if (Objects.equals(key.prior, key.next)) {
        return ChangeKind.NO_CODE_CHANGE;
    }
    try (RevWalk walk = new RevWalk(repo)) {
        RevCommit prior = walk.parseCommit(key.prior);
        walk.parseBody(prior);
        RevCommit next = walk.parseCommit(key.next);
        walk.parseBody(next);
        if (!next.getFullMessage().equals(prior.getFullMessage())) {
            if (isSameDeltaAndTree(prior, next)) {
                return ChangeKind.NO_CODE_CHANGE;
            } else {
                return ChangeKind.REWORK;
            }
        }
        if (isSameDeltaAndTree(prior, next)) {
            return ChangeKind.NO_CHANGE;
        }
        if ((prior.getParentCount() != 1 || next.getParentCount() != 1) && !onlyFirstParentChanged(prior, next)) {
            // Trivial rebases done by machine only work well on 1 parent.
            return ChangeKind.REWORK;
        }
        // A trivial rebase can be detected by looking for the next commit
        // having the same tree as would exist when the prior commit is
        // cherry-picked onto the next commit's new first parent.
        ThreeWayMerger merger = MergeUtil.newThreeWayMerger(repo, MergeUtil.createDryRunInserter(repo), key.strategyName);
        merger.setBase(prior.getParent(0));
        try {
            if (merger.merge(next.getParent(0), prior) && merger.getResultTreeId().equals(next.getTree())) {
                if (prior.getParentCount() == 1) {
                    return ChangeKind.TRIVIAL_REBASE;
                } else {
                    return ChangeKind.MERGE_FIRST_PARENT_UPDATE;
                }
            }
        } catch (LargeObjectException e) {
        // Some object is too large for the merge attempt to succeed. Assume
        // it was a rework.
        }
        return ChangeKind.REWORK;
    }
}
#end_block

#method_before
private static boolean sameRestOfParents(RevCommit prior, RevCommit next) {
    Set<RevCommit> priorRestParents = mergedInParents(prior.getParents());
    Set<RevCommit> nextRestParents = mergedInParents(next.getParents());
    return priorRestParents.equals(nextRestParents);
}
#method_after
private static boolean sameRestOfParents(RevCommit prior, RevCommit next) {
    Set<RevCommit> priorRestParents = allExceptFirstParent(prior.getParents());
    Set<RevCommit> nextRestParents = allExceptFirstParent(next.getParents());
    return priorRestParents.equals(nextRestParents);
}
#end_block

#method_before
@Override
public void doProjectCreatedHook(Project.NameKey project, String headName) {
    if (!projectCreatedHook.isPresent()) {
        return;
    }
    ProjectCreatedEvent event = new ProjectCreatedEvent();
    event.projectName = project.get();
    event.headName = headName;
    fireEvent(project, event);
    List<String> args = new ArrayList<>();
    addArg(args, "--project", project.get());
    addArg(args, "--head", headName);
    runHook(project, projectCreatedHook, args);
}
#method_after
@Override
public void doProjectCreatedHook(Project.NameKey project, String headName) {
    ProjectCreatedEvent event = new ProjectCreatedEvent();
    event.projectName = project.get();
    event.headName = headName;
    fireEvent(project, event);
    if (!projectCreatedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    addArg(args, "--project", project.get());
    addArg(args, "--head", headName);
    runHook(project, projectCreatedHook, args);
}
#end_block

#method_before
@Override
public void doPatchsetCreatedHook(Change change, PatchSet patchSet, ReviewDb db) throws OrmException {
    if (!patchsetCreatedHook.isPresent()) {
        return;
    }
    PatchSetCreatedEvent event = new PatchSetCreatedEvent();
    AccountState uploader = accountCache.get(patchSet.getUploader());
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(db, change);
    event.patchSet = asPatchSetAttribute(change, patchSet, db);
    event.uploader = eventFactory.asAccountAttribute(uploader.getAccount());
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--is-draft", String.valueOf(patchSet.isDraft()));
    addArg(args, "--kind", String.valueOf(event.patchSet.kind));
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--uploader", getDisplayName(uploader.getAccount()));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--patchset", event.patchSet.number);
    runHook(change.getProject(), patchsetCreatedHook, args);
}
#method_after
@Override
public void doPatchsetCreatedHook(Change change, PatchSet patchSet, ReviewDb db) throws OrmException {
    PatchSetCreatedEvent event = new PatchSetCreatedEvent();
    Supplier<AccountState> uploader = getAccountSupplier(patchSet.getUploader());
    Supplier<AccountState> owner = getAccountSupplier(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.uploader = accountAttributeSupplier(uploader);
    fireEvent(change, event, db);
    if (!patchsetCreatedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    PatchSetAttribute ps = event.patchSet.get();
    addArg(args, "--change", c.id);
    addArg(args, "--is-draft", String.valueOf(patchSet.isDraft()));
    addArg(args, "--kind", String.valueOf(ps.kind));
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.get().getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--topic", c.topic);
    addArg(args, "--uploader", getDisplayName(uploader.get().getAccount()));
    addArg(args, "--commit", ps.revision);
    addArg(args, "--patchset", ps.number);
    runHook(change.getProject(), patchsetCreatedHook, args);
}
#end_block

#method_before
@Override
public void doDraftPublishedHook(Change change, PatchSet patchSet, ReviewDb db) throws OrmException {
    if (!draftPublishedHook.isPresent()) {
        return;
    }
    DraftPublishedEvent event = new DraftPublishedEvent();
    AccountState uploader = accountCache.get(patchSet.getUploader());
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(db, change);
    event.patchSet = asPatchSetAttribute(change, patchSet, db);
    event.uploader = eventFactory.asAccountAttribute(uploader.getAccount());
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--uploader", getDisplayName(uploader.getAccount()));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--patchset", event.patchSet.number);
    runHook(change.getProject(), draftPublishedHook, args);
}
#method_after
@Override
public void doDraftPublishedHook(Change change, PatchSet patchSet, ReviewDb db) throws OrmException {
    DraftPublishedEvent event = new DraftPublishedEvent();
    Supplier<AccountState> uploader = getAccountSupplier(patchSet.getUploader());
    Supplier<AccountState> owner = getAccountSupplier(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.uploader = accountAttributeSupplier(uploader);
    fireEvent(change, event, db);
    if (!draftPublishedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    PatchSetAttribute ps = event.patchSet.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.get().getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--topic", c.topic);
    addArg(args, "--uploader", getDisplayName(uploader.get().getAccount()));
    addArg(args, "--commit", ps.revision);
    addArg(args, "--patchset", ps.number);
    runHook(change.getProject(), draftPublishedHook, args);
}
#end_block

#method_before
@Override
public void doCommentAddedHook(Change change, Account account, PatchSet patchSet, String comment, Map<String, Short> approvals, ReviewDb db) throws OrmException {
    if (!commentAddedHook.isPresent()) {
        return;
    }
    CommentAddedEvent event = new CommentAddedEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(db, change);
    event.author = eventFactory.asAccountAttribute(account);
    event.patchSet = asPatchSetAttribute(change, patchSet, db);
    event.comment = comment;
    LabelTypes labelTypes = projectCache.get(change.getProject()).getLabelTypes();
    if (approvals.size() > 0) {
        event.approvals = new ApprovalAttribute[approvals.size()];
        int i = 0;
        for (Map.Entry<String, Short> approval : approvals.entrySet()) {
            event.approvals[i++] = getApprovalAttribute(labelTypes, approval);
        }
    }
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--is-draft", patchSet.isDraft() ? "true" : "false");
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--author", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--comment", comment == null ? "" : comment);
    for (Map.Entry<String, Short> approval : approvals.entrySet()) {
        LabelType lt = labelTypes.byLabel(approval.getKey());
        if (lt != null) {
            addArg(args, "--" + lt.getName(), Short.toString(approval.getValue()));
        }
    }
    runHook(change.getProject(), commentAddedHook, args);
}
#method_after
@Override
public void doCommentAddedHook(final Change change, Account account, PatchSet patchSet, String comment, final Map<String, Short> approvals, ReviewDb db) throws OrmException {
    CommentAddedEvent event = new CommentAddedEvent();
    Supplier<AccountState> owner = getAccountSupplier(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.author = accountAttributeSupplier(account);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.comment = comment;
    event.approvals = Suppliers.memoize(new Supplier<ApprovalAttribute[]>() {

        @Override
        public ApprovalAttribute[] get() {
            LabelTypes labelTypes = projectCache.get(change.getProject()).getLabelTypes();
            if (approvals.size() > 0) {
                ApprovalAttribute[] r = new ApprovalAttribute[approvals.size()];
                int i = 0;
                for (Map.Entry<String, Short> approval : approvals.entrySet()) {
                    r[i++] = getApprovalAttribute(labelTypes, approval);
                }
                return r;
            }
            return null;
        }
    });
    fireEvent(change, event, db);
    if (!commentAddedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    PatchSetAttribute ps = event.patchSet.get();
    addArg(args, "--change", c.id);
    addArg(args, "--is-draft", patchSet.isDraft() ? "true" : "false");
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.get().getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--topic", c.topic);
    addArg(args, "--author", getDisplayName(account));
    addArg(args, "--commit", ps.revision);
    addArg(args, "--comment", comment == null ? "" : comment);
    LabelTypes labelTypes = projectCache.get(change.getProject()).getLabelTypes();
    for (Map.Entry<String, Short> approval : approvals.entrySet()) {
        LabelType lt = labelTypes.byLabel(approval.getKey());
        if (lt != null) {
            addArg(args, "--" + lt.getName(), Short.toString(approval.getValue()));
        }
    }
    runHook(change.getProject(), commentAddedHook, args);
}
#end_block

#method_before
@Override
public void doChangeMergedHook(Change change, Account account, PatchSet patchSet, ReviewDb db, String mergeResultRev) throws OrmException {
    if (!changeMergedHook.isPresent()) {
        return;
    }
    ChangeMergedEvent event = new ChangeMergedEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(db, change);
    event.submitter = eventFactory.asAccountAttribute(account);
    event.patchSet = asPatchSetAttribute(change, patchSet, db);
    event.newRev = mergeResultRev;
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--submitter", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--newrev", mergeResultRev);
    runHook(change.getProject(), changeMergedHook, args);
}
#method_after
@Override
public void doChangeMergedHook(Change change, Account account, PatchSet patchSet, ReviewDb db, String mergeResultRev) throws OrmException {
    ChangeMergedEvent event = new ChangeMergedEvent();
    Supplier<AccountState> owner = getAccountSupplier(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.submitter = accountAttributeSupplier(account);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.newRev = mergeResultRev;
    fireEvent(change, event, db);
    if (!changeMergedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    PatchSetAttribute ps = event.patchSet.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.get().getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--topic", c.topic);
    addArg(args, "--submitter", getDisplayName(account));
    addArg(args, "--commit", ps.revision);
    addArg(args, "--newrev", mergeResultRev);
    runHook(change.getProject(), changeMergedHook, args);
}
#end_block

#method_before
@Override
public void doMergeFailedHook(Change change, Account account, PatchSet patchSet, String reason, ReviewDb db) throws OrmException {
    if (!mergeFailedHook.isPresent()) {
        return;
    }
    MergeFailedEvent event = new MergeFailedEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(db, change);
    event.submitter = eventFactory.asAccountAttribute(account);
    event.patchSet = asPatchSetAttribute(change, patchSet, db);
    event.reason = reason;
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--submitter", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--reason", reason == null ? "" : reason);
    runHook(change.getProject(), mergeFailedHook, args);
}
#method_after
@Override
public void doMergeFailedHook(Change change, Account account, PatchSet patchSet, String reason, ReviewDb db) throws OrmException {
    MergeFailedEvent event = new MergeFailedEvent();
    Supplier<AccountState> owner = getAccountSupplier(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.submitter = accountAttributeSupplier(account);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.reason = reason;
    fireEvent(change, event, db);
    if (!mergeFailedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    PatchSetAttribute ps = event.patchSet.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.get().getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--topic", c.topic);
    addArg(args, "--submitter", getDisplayName(account));
    addArg(args, "--commit", ps.revision);
    addArg(args, "--reason", reason == null ? "" : reason);
    runHook(change.getProject(), mergeFailedHook, args);
}
#end_block

#method_before
@Override
public void doChangeAbandonedHook(Change change, Account account, PatchSet patchSet, String reason, ReviewDb db) throws OrmException {
    if (!changeAbandonedHook.isPresent()) {
        return;
    }
    ChangeAbandonedEvent event = new ChangeAbandonedEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(db, change);
    event.abandoner = eventFactory.asAccountAttribute(account);
    event.patchSet = asPatchSetAttribute(change, patchSet, db);
    event.reason = reason;
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--abandoner", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--reason", reason == null ? "" : reason);
    runHook(change.getProject(), changeAbandonedHook, args);
}
#method_after
@Override
public void doChangeAbandonedHook(Change change, Account account, PatchSet patchSet, String reason, ReviewDb db) throws OrmException {
    ChangeAbandonedEvent event = new ChangeAbandonedEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.abandoner = accountAttributeSupplier(account);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.reason = reason;
    fireEvent(change, event, db);
    if (!changeAbandonedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    PatchSetAttribute ps = event.patchSet.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--topic", c.topic);
    addArg(args, "--abandoner", getDisplayName(account));
    addArg(args, "--commit", ps.revision);
    addArg(args, "--reason", reason == null ? "" : reason);
    runHook(change.getProject(), changeAbandonedHook, args);
}
#end_block

#method_before
@Override
public void doChangeRestoredHook(Change change, Account account, PatchSet patchSet, String reason, ReviewDb db) throws OrmException {
    if (!changeRestoredHook.isPresent()) {
        return;
    }
    ChangeRestoredEvent event = new ChangeRestoredEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(db, change);
    event.restorer = eventFactory.asAccountAttribute(account);
    event.patchSet = asPatchSetAttribute(change, patchSet, db);
    event.reason = reason;
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--restorer", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--reason", reason == null ? "" : reason);
    runHook(change.getProject(), changeRestoredHook, args);
}
#method_after
@Override
public void doChangeRestoredHook(Change change, Account account, PatchSet patchSet, String reason, ReviewDb db) throws OrmException {
    ChangeRestoredEvent event = new ChangeRestoredEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.restorer = accountAttributeSupplier(account);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.reason = reason;
    fireEvent(change, event, db);
    if (!changeRestoredHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    PatchSetAttribute ps = event.patchSet.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--topic", c.topic);
    addArg(args, "--restorer", getDisplayName(account));
    addArg(args, "--commit", ps.revision);
    addArg(args, "--reason", reason == null ? "" : reason);
    runHook(change.getProject(), changeRestoredHook, args);
}
#end_block

#method_before
@Override
public void doRefUpdatedHook(Branch.NameKey refName, ObjectId oldId, ObjectId newId, Account account) {
    if (!refUpdatedHook.isPresent()) {
        return;
    }
    RefUpdatedEvent event = new RefUpdatedEvent();
    if (account != null) {
        event.submitter = eventFactory.asAccountAttribute(account);
    }
    event.refUpdate = eventFactory.asRefUpdateAttribute(oldId, newId, refName);
    fireEvent(refName, event);
    List<String> args = new ArrayList<>();
    addArg(args, "--oldrev", event.refUpdate.oldRev);
    addArg(args, "--newrev", event.refUpdate.newRev);
    addArg(args, "--refname", event.refUpdate.refName);
    addArg(args, "--project", event.refUpdate.project);
    if (account != null) {
        addArg(args, "--submitter", getDisplayName(account));
    }
    runHook(refName.getParentKey(), refUpdatedHook, args);
}
#method_after
@Override
public void doRefUpdatedHook(final Branch.NameKey refName, final ObjectId oldId, final ObjectId newId, Account account) {
    RefUpdatedEvent event = new RefUpdatedEvent();
    if (account != null) {
        event.submitter = accountAttributeSupplier(account);
    }
    event.refUpdate = Suppliers.memoize(new Supplier<RefUpdateAttribute>() {

        @Override
        public RefUpdateAttribute get() {
            return eventFactory.asRefUpdateAttribute(oldId, newId, refName);
        }
    });
    fireEvent(refName, event);
    if (!refUpdatedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    RefUpdateAttribute r = event.refUpdate.get();
    addArg(args, "--oldrev", r.oldRev);
    addArg(args, "--newrev", r.newRev);
    addArg(args, "--refname", r.refName);
    addArg(args, "--project", r.project);
    if (account != null) {
        addArg(args, "--submitter", getDisplayName(account));
    }
    runHook(refName.getParentKey(), refUpdatedHook, args);
}
#end_block

#method_before
@Override
public void doReviewerAddedHook(Change change, Account account, PatchSet patchSet, ReviewDb db) throws OrmException {
    if (!reviewerAddedHook.isPresent()) {
        return;
    }
    ReviewerAddedEvent event = new ReviewerAddedEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(db, change);
    event.patchSet = asPatchSetAttribute(change, patchSet, db);
    event.reviewer = eventFactory.asAccountAttribute(account);
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--reviewer", getDisplayName(account));
    runHook(change.getProject(), reviewerAddedHook, args);
}
#method_after
@Override
public void doReviewerAddedHook(Change change, Account account, PatchSet patchSet, ReviewDb db) throws OrmException {
    ReviewerAddedEvent event = new ReviewerAddedEvent();
    Supplier<AccountState> owner = getAccountSupplier(change.getOwner());
    event.change = changeAttributeSupplier(change);
    // patchSetAttributeSupplier(change, patchSet, db);
    event.patchSet = null;
    // accountAttributeSupplier(account);
    event.reviewer = null;
    fireEvent(change, event, db);
    if (!reviewerAddedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.get().getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--reviewer", getDisplayName(account));
    runHook(change.getProject(), reviewerAddedHook, args);
}
#end_block

#method_before
@Override
public void doTopicChangedHook(Change change, Account account, String oldTopic, ReviewDb db) throws OrmException {
    if (!topicChangedHook.isPresent()) {
        return;
    }
    TopicChangedEvent event = new TopicChangedEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(db, change);
    event.changer = eventFactory.asAccountAttribute(account);
    event.oldTopic = oldTopic;
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--changer", getDisplayName(account));
    addArg(args, "--old-topic", oldTopic);
    addArg(args, "--new-topic", event.change.topic);
    runHook(change.getProject(), topicChangedHook, args);
}
#method_after
@Override
public void doTopicChangedHook(Change change, Account account, String oldTopic, ReviewDb db) throws OrmException {
    TopicChangedEvent event = new TopicChangedEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.changer = accountAttributeSupplier(account);
    event.oldTopic = oldTopic;
    fireEvent(change, event, db);
    if (!topicChangedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--changer", getDisplayName(account));
    addArg(args, "--old-topic", oldTopic);
    addArg(args, "--new-topic", c.topic);
    runHook(change.getProject(), topicChangedHook, args);
}
#end_block

#method_before
@Override
public void doHashtagsChangedHook(Change change, Account account, Set<String> added, Set<String> removed, Set<String> hashtags, ReviewDb db) throws OrmException {
    if (!hashtagsChangedHook.isPresent()) {
        return;
    }
    HashtagsChangedEvent event = new HashtagsChangedEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(db, change);
    event.editor = eventFactory.asAccountAttribute(account);
    event.hashtags = hashtagArray(hashtags);
    event.added = hashtagArray(added);
    event.removed = hashtagArray(removed);
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--editor", getDisplayName(account));
    if (hashtags != null) {
        for (String hashtag : hashtags) {
            addArg(args, "--hashtag", hashtag);
        }
    }
    if (added != null) {
        for (String hashtag : added) {
            addArg(args, "--added", hashtag);
        }
    }
    if (removed != null) {
        for (String hashtag : removed) {
            addArg(args, "--removed", hashtag);
        }
    }
    runHook(change.getProject(), hashtagsChangedHook, args);
}
#method_after
@Override
public void doHashtagsChangedHook(Change change, Account account, Set<String> added, Set<String> removed, Set<String> hashtags, ReviewDb db) throws OrmException {
    HashtagsChangedEvent event = new HashtagsChangedEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.editor = accountAttributeSupplier(account);
    event.hashtags = hashtagArray(hashtags);
    event.added = hashtagArray(added);
    event.removed = hashtagArray(removed);
    fireEvent(change, event, db);
    if (!hashtagsChangedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--editor", getDisplayName(account));
    if (hashtags != null) {
        for (String hashtag : hashtags) {
            addArg(args, "--hashtag", hashtag);
        }
    }
    if (added != null) {
        for (String hashtag : added) {
            addArg(args, "--added", hashtag);
        }
    }
    if (removed != null) {
        for (String hashtag : removed) {
            addArg(args, "--removed", hashtag);
        }
    }
    runHook(change.getProject(), hashtagsChangedHook, args);
}
#end_block

#method_before
public CheckedFuture<?, IOException> indexAsync(Collection<Change.Id> ids) {
    List<ListenableFuture<?>> futures = new ArrayList<>(ids.size());
    for (Change.Id id : ids) {
        futures.add(indexAsync(id));
    }
    return allAsList(futures);
}
#method_after
public CheckedFuture<?, IOException> indexAsync(Project.NameKey project, Change.Id id) {
    return executor != null ? submit(new IndexTask(project, id)) : Futures.<Object, IOException>immediateCheckedFuture(null);
}
#end_block

#method_before
public void index(ChangeData cd) throws IOException {
    for (ChangeIndex i : getWriteIndexes()) {
        i.replace(cd);
    }
    fireChangeIndexedEvent(cd.getId());
}
#method_after
public void index(ChangeData cd) throws IOException {
    for (ChangeIndex i : getWriteIndexes()) {
        i.replace(cd);
    }
    fireChangeIndexedEvent(cd);
}
#end_block

#method_before
private void fireChangeIndexedEvent(Change.Id id) {
    Event indexEvent = createIndexEvent(id);
    for (ChangeIndexedListener listener : indexedListener) {
        listener.onChangeIndexed(indexEvent);
    }
}
#method_after
private void fireChangeIndexedEvent(ChangeData change) {
    for (ChangeIndexedListener listener : indexedListener) {
        listener.onChangeIndexed(change);
    }
}
#end_block

#method_before
private void fireChangeDeletedFromIndexEvent(Change.Id id) {
    Event indexEvent = createIndexEvent(id);
    for (ChangeIndexedListener listener : indexedListener) {
        listener.onChangeDeleted(indexEvent);
    }
}
#method_after
private void fireChangeDeletedFromIndexEvent(Change.Id id) {
    for (ChangeIndexedListener listener : indexedListener) {
        listener.onChangeDeleted(id);
    }
}
#end_block

#method_before
@Override
public Void call() throws Exception {
    try {
        final AtomicReference<Provider<ReviewDb>> dbRef = Atomics.newReference();
        RequestContext newCtx = new RequestContext() {

            @Override
            public Provider<ReviewDb> getReviewDbProvider() {
                Provider<ReviewDb> db = dbRef.get();
                if (db == null) {
                    try {
                        db = Providers.of(schemaFactory.open());
                    } catch (OrmException e) {
                        ProvisionException pe = new ProvisionException("error opening ReviewDb");
                        pe.initCause(e);
                        throw pe;
                    }
                    dbRef.set(db);
                }
                return db;
            }

            @Override
            public CurrentUser getUser() {
                throw new OutOfScopeException("No user during ChangeIndexer");
            }
        };
        RequestContext oldCtx = context.setContext(newCtx);
        try {
            ChangeData cd = changeDataFactory.create(newCtx.getReviewDbProvider().get(), id);
            index(cd);
            return null;
        } finally {
            context.setContext(oldCtx);
            Provider<ReviewDb> db = dbRef.get();
            if (db != null) {
                db.get().close();
            }
        }
    } catch (Exception e) {
        log.error(String.format("Failed to index change %d", id.get()), e);
        throw e;
    }
}
#method_after
@Override
public Void call() throws Exception {
    try {
        final AtomicReference<Provider<ReviewDb>> dbRef = Atomics.newReference();
        RequestContext newCtx = new RequestContext() {

            @Override
            public Provider<ReviewDb> getReviewDbProvider() {
                Provider<ReviewDb> db = dbRef.get();
                if (db == null) {
                    try {
                        db = Providers.of(schemaFactory.open());
                    } catch (OrmException e) {
                        ProvisionException pe = new ProvisionException("error opening ReviewDb");
                        pe.initCause(e);
                        throw pe;
                    }
                    dbRef.set(db);
                }
                return db;
            }

            @Override
            public CurrentUser getUser() {
                throw new OutOfScopeException("No user during ChangeIndexer");
            }
        };
        RequestContext oldCtx = context.setContext(newCtx);
        try {
            ChangeData cd = changeDataFactory.create(newCtx.getReviewDbProvider().get(), project, id);
            index(cd);
            return null;
        } finally {
            context.setContext(oldCtx);
            Provider<ReviewDb> db = dbRef.get();
            if (db != null) {
                db.get().close();
            }
        }
    } catch (Exception e) {
        log.error(String.format("Failed to index change %d", id.get()), e);
        throw e;
    }
}
#end_block

#method_before
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(ChangeKindCacheImpl.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(MergeabilityCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new GitModule());
    install(new GroupModule());
    install(new NoteDbModule());
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(AddKeySender.Factory.class);
    factory(BatchUpdate.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeData.Factory.class);
    factory(ChangeJson.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(EmailMerge.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    factory(ProjectOwnerGroupsProvider.Factory.class);
    bind(RepositoryConfig.class);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(GitwebConfig.class);
    bind(GcConfig.class);
    bind(ChangeCleanupConfig.class);
    bind(ApprovalsUtil.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(Boolean.class).annotatedWith(DisableReverseDnsLookup.class).toProvider(DisableReverseDnsLookupProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), ReceivePackInitializer.class);
    DynamicSet.setOf(binder(), PostReceiveHook.class);
    DynamicSet.setOf(binder(), PreUploadHook.class);
    DynamicSet.setOf(binder(), ChangeIndexedListener.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), GarbageCollectorListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.setOf(binder(), UsageDataPublishedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ReindexAfterUpdate.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ProjectConfigEntry.UpdateChecker.class);
    DynamicSet.bind(binder(), EventListener.class).to(EventsMetrics.class);
    DynamicSet.setOf(binder(), EventListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), RefOperationValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicSet.setOf(binder(), ProjectCreationValidationListener.class);
    DynamicSet.setOf(binder(), GroupCreationValidationListener.class);
    DynamicSet.setOf(binder(), HashtagValidationListener.class);
    DynamicSet.setOf(binder(), OutgoingEmailValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), CloneCommand.class);
    DynamicMap.mapOf(binder(), ExternalIncludedIn.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    DynamicSet.setOf(binder(), PatchSetWebLink.class);
    DynamicSet.setOf(binder(), FileWebLink.class);
    DynamicSet.setOf(binder(), FileHistoryWebLink.class);
    DynamicSet.setOf(binder(), DiffWebLink.class);
    DynamicSet.setOf(binder(), ProjectWebLink.class);
    DynamicSet.setOf(binder(), BranchWebLink.class);
    factory(UploadValidators.Factory.class);
    DynamicSet.setOf(binder(), UploadValidationListener.class);
    DynamicMap.mapOf(binder(), ChangeQueryBuilder.ChangeOperatorFactory.class);
    bind(AnonymousUser.class);
    factory(CommitValidators.Factory.class);
    factory(RefOperationValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    factory(SubmoduleSectionParser.Factory.class);
    bind(AccountManager.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#method_after
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    bind(Sequences.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(ChangeKindCacheImpl.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(MergeabilityCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(SubmitStrategy.module());
    install(TagCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new GitModule());
    install(new GroupModule());
    install(new NoteDbModule());
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(AddKeySender.Factory.class);
    factory(BatchUpdate.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeData.Factory.class);
    factory(ChangeJson.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(EmailMerge.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    factory(ProjectOwnerGroupsProvider.Factory.class);
    bind(RepositoryConfig.class);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(GitwebConfig.class);
    bind(GcConfig.class);
    bind(ChangeCleanupConfig.class);
    bind(ApprovalsUtil.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(Boolean.class).annotatedWith(DisableReverseDnsLookup.class).toProvider(DisableReverseDnsLookupProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), ReceivePackInitializer.class);
    DynamicSet.setOf(binder(), PostReceiveHook.class);
    DynamicSet.setOf(binder(), PreUploadHook.class);
    DynamicSet.setOf(binder(), ChangeIndexedListener.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), GarbageCollectorListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.setOf(binder(), UsageDataPublishedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ReindexAfterUpdate.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ProjectConfigEntry.UpdateChecker.class);
    DynamicSet.setOf(binder(), EventListener.class);
    DynamicSet.bind(binder(), EventListener.class).to(EventsMetrics.class);
    DynamicSet.setOf(binder(), UserScopedEventListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), RefOperationValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicSet.setOf(binder(), ProjectCreationValidationListener.class);
    DynamicSet.setOf(binder(), GroupCreationValidationListener.class);
    DynamicSet.setOf(binder(), HashtagValidationListener.class);
    DynamicSet.setOf(binder(), OutgoingEmailValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), CloneCommand.class);
    DynamicMap.mapOf(binder(), ExternalIncludedIn.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    DynamicSet.setOf(binder(), PatchSetWebLink.class);
    DynamicSet.setOf(binder(), FileWebLink.class);
    DynamicSet.setOf(binder(), FileHistoryWebLink.class);
    DynamicSet.setOf(binder(), DiffWebLink.class);
    DynamicSet.setOf(binder(), ProjectWebLink.class);
    DynamicSet.setOf(binder(), BranchWebLink.class);
    DynamicMap.mapOf(binder(), OAuthLoginProvider.class);
    DynamicSet.setOf(binder(), AccountExternalIdCreator.class);
    factory(UploadValidators.Factory.class);
    DynamicSet.setOf(binder(), UploadValidationListener.class);
    DynamicMap.mapOf(binder(), ChangeQueryBuilder.ChangeOperatorFactory.class);
    bind(AnonymousUser.class);
    factory(CommitValidators.Factory.class);
    factory(RefOperationValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    factory(SubmoduleSectionParser.Factory.class);
    factory(ReplaceOp.Factory.class);
    bind(AccountManager.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#end_block

#method_before
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    try {
        PluginConfig cfg = cfgFactory.getFromProjectConfig(receiveEvent.project.getNameKey(), pluginName);
        boolean symlinkCheck = cfg.getBoolean(KEY_CHECK_SYMLINK, false);
        if (symlinkCheck) {
            try (Repository repo = repoManager.openRepository(receiveEvent.project.getNameKey())) {
                List<CommitValidationMessage> messages = new LinkedList<>();
                TreeWalk tw = new TreeWalk(repo);
                tw.setRecursive(true);
                tw.setFilter(TreeFilter.ANY_DIFF);
                if (receiveEvent.commit.getParentCount() > 1) {
                    List<RevTree> trees = new ArrayList<>();
                    trees.add(receiveEvent.commit.getTree());
                    for (RevCommit p : receiveEvent.commit.getParents()) {
                        trees.add(p.getTree());
                    }
                    tw.reset(trees.toArray(new AnyObjectId[trees.size()]));
                    while (tw.next()) {
                        boolean diff = true;
                        for (int p = 1; p < trees.size(); p++) {
                            if (tw.getObjectId(0).equals(tw.getObjectId(p))) {
                                diff = false;
                            }
                        }
                        if (((tw.getRawMode(0) & FileMode.TYPE_MASK) == FileMode.TYPE_SYMLINK) && diff) {
                            messages.add(new CommitValidationMessage("Symbolic links are not allowed: " + tw.getPathString(), true));
                        }
                    }
                    tw.close();
                } else {
                    tw.reset(receiveEvent.commit.getTree());
                    while (tw.next()) {
                        if ((tw.getRawMode(0) & FileMode.TYPE_MASK) == FileMode.TYPE_SYMLINK)
                            messages.add(new CommitValidationMessage("Symbolic links are not allowed: " + tw.getPathString(), true));
                    }
                }
                if (!messages.isEmpty()) {
                    throw new CommitValidationException("contains symbolic links", messages);
                }
            }
        }
    } catch (NoSuchProjectException | IOException e) {
        throw new CommitValidationException("failed to check on invalid line endings", e);
    }
    return Collections.emptyList();
}
#method_after
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    try {
        PluginConfig cfg = cfgFactory.getFromProjectConfig(receiveEvent.project.getNameKey(), pluginName);
        boolean rejectSymlink = cfg.getBoolean(KEY_CHECK_SYMLINK, false);
        if (!rejectSymlink) {
            return Collections.emptyList();
        }
        try (Repository repo = repoManager.openRepository(receiveEvent.project.getNameKey())) {
            List<CommitValidationMessage> messages = performValidation(repo, receiveEvent.commit);
            if (!messages.isEmpty()) {
                throw new CommitValidationException("contains symbolic links", messages);
            }
        }
    } catch (NoSuchProjectException | IOException e) {
        throw new CommitValidationException("failed to check on symbolic links", e);
    }
    return Collections.emptyList();
}
#end_block

#method_before
@Override
protected void configure() {
    DynamicSet.bind(binder(), CommitValidationListener.class).to(FileExtensionValidator.class);
    bind(ProjectConfigEntry.class).annotatedWith(Exports.named(KEY_BLOCKED_FILE_EXTENSION)).toInstance(new ProjectConfigEntry("Blocked File Extensions", null, ProjectConfigEntry.Type.ARRAY, null, false, "Forbidden file extensions. Pushes of commits that " + "contain files with these extensions will be rejected."));
    DynamicSet.bind(binder(), CommitValidationListener.class).to(FooterValidator.class);
    bind(ProjectConfigEntry.class).annotatedWith(Exports.named(KEY_REQUIRED_FOOTER)).toInstance(new ProjectConfigEntry("Required Footers", null, ProjectConfigEntry.Type.ARRAY, null, false, "Required footers. Pushes of commits that miss any" + " of the footers will be rejected."));
    DynamicSet.bind(binder(), CommitValidationListener.class).to(InvalidFilenameValidator.class);
    bind(ProjectConfigEntry.class).annotatedWith(Exports.named(KEY_INVALID_FILENAME_PATTERN)).toInstance(new ProjectConfigEntry("Invalid Filename Pattern", null, ProjectConfigEntry.Type.ARRAY, null, false, "Invalid filenames. Pushes of commits that " + "contain filenames which match one of these patterns " + "will be rejected."));
    DynamicSet.bind(binder(), CommitValidationListener.class).to(SymlinkValidator.class);
    bind(ProjectConfigEntry.class).annotatedWith(Exports.named(KEY_CHECK_SYMLINK)).toInstance(new ProjectConfigEntry("Contains Symbolic Links", "false", ProjectConfigEntry.Type.BOOLEAN, null, false, "Symbolic Links. " + "Pushes of commits that include symbolic links will be " + "rejected."));
    DynamicSet.bind(binder(), CommitValidationListener.class).to(MaxPathLengthValidator.class);
    bind(ProjectConfigEntry.class).annotatedWith(Exports.named(KEY_MAX_PATH_LENGTH)).toInstance(new ProjectConfigEntry("Max Path Length", 0, false, "Maximum path length. Pushes of commits that " + "contain files with longer paths will be rejected. " + "'0' means no limit."));
}
#method_after
@Override
protected void configure() {
    install(FileExtensionValidator.module());
    install(FooterValidator.module());
    install(InvalidFilenameValidator.module());
    install(InvalidLineEndingValidator.module());
    install(MaxPathLengthValidator.module());
    install(SymlinkValidator.module());
}
#end_block

#method_before
@Override
protected void configure() {
    if (ui) {
        DynamicSet.bind(binder(), TopMenu.class).to(ReviewersTopMenu.class);
    }
    DynamicSet.bind(binder(), EventListener.class).to(ChangeEventListener.class);
    factory(DefaultReviewers.Factory.class);
    factory(ReviewersConfig.Factory.class);
    install(new RestApiModule() {

        @Override
        protected void configure() {
            get(PROJECT_KIND, "reviewers").to(GetReviewers.class);
            put(PROJECT_KIND, "reviewers").to(PutReviewers.class);
            get(PROJECT_KIND, "suggest_reviewers").to(SuggestReviewers.class);
        }
    });
}
#method_after
@Override
protected void configure() {
    if (ui) {
        DynamicSet.bind(binder(), TopMenu.class).to(ReviewersTopMenu.class);
    }
    DynamicSet.bind(binder(), EventListener.class).to(ChangeEventListener.class);
    factory(DefaultReviewers.Factory.class);
    factory(ReviewersConfig.Factory.class);
    install(new RestApiModule() {

        @Override
        protected void configure() {
            get(PROJECT_KIND, "reviewers").to(GetReviewers.class);
            put(PROJECT_KIND, "reviewers").to(PutReviewers.class);
            get(PROJECT_KIND, "suggest_reviewers").to(SuggestProjectReviewers.class);
        }
    });
}
#end_block

#method_before
Panel createInputPanel() {
    final NpTextBox filterBox = new NpTextBox();
    // TODO(davido): Remove hard coded start suggest char 3
    final ReviewerSuggestOracle oracle = new ReviewerSuggestOracle(3, projectName);
    final SuggestBox reviewerBox = new SuggestBox(oracle, new NpTextBox());
    filterBox.getElement().setPropertyString("placeholder", "filter");
    reviewerBox.getElement().setPropertyString("placeholder", "reviewer");
    Button addButton = new Button("Add");
    addButton.setStyleName("reviewers-addButton");
    addButton.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            ReviewerEntry e = new ReviewerEntry(filterBox.getValue(), reviewerBox.getValue());
            if (!rEntries.contains(e) && !e.filter.isEmpty() && !e.reviewer.isEmpty()) {
                doSave(Action.ADD, e);
            }
            filterBox.setText("");
            reviewerBox.setText("");
        }
    });
    filterBox.setEnabled(isOwner);
    reviewerBox.setEnabled(isOwner);
    addButton.setEnabled(isOwner);
    Panel p = new VerticalPanel();
    p.setStyleName("reviewers-inputPanel");
    p.add(filterBox);
    p.add(reviewerBox);
    p.add(addButton);
    return p;
}
#method_after
Panel createInputPanel() {
    Grid inputGrid = new Grid(2, 2);
    final NpTextBox filterBox = new NpTextBox();
    filterBox.getElement().setPropertyString("placeholder", "filter");
    inputGrid.setText(0, 0, "Filter: ");
    inputGrid.setWidget(0, 1, filterBox);
    // TODO(davido): Remove hard coded start suggest char 3
    final ReviewerSuggestOracle oracle = new ReviewerSuggestOracle(3, projectName);
    final SuggestBox reviewerBox = new SuggestBox(oracle, new NpTextBox());
    reviewerBox.getElement().setPropertyString("placeholder", "reviewer");
    inputGrid.setText(1, 0, "Reviewer: ");
    inputGrid.setWidget(1, 1, reviewerBox);
    Button addButton = new Button("Add");
    addButton.setStyleName("reviewers-addButton");
    addButton.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            ReviewerEntry e = new ReviewerEntry(filterBox.getValue(), reviewerBox.getValue());
            if (!rEntries.contains(e) && !e.filter.isEmpty() && !e.reviewer.isEmpty()) {
                doSave(Action.ADD, e);
            }
            filterBox.setText("");
            reviewerBox.setText("");
        }
    });
    filterBox.setEnabled(isOwner);
    reviewerBox.setEnabled(isOwner);
    addButton.setEnabled(isOwner);
    Panel p = new VerticalPanel();
    p.setStyleName("reviewers-inputPanel");
    p.add(inputGrid);
    p.add(addButton);
    return p;
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ChangesCollection.class);
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(DraftComments.class);
    bind(Comments.class);
    bind(Files.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), DRAFT_COMMENT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    DynamicMap.mapOf(binder(), CHANGE_EDIT_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    get(CHANGE_KIND, "in").to(IncludedIn.class);
    get(CHANGE_KIND, "hashtags").to(GetHashtags.class);
    get(CHANGE_KIND, "comments").to(ListChangeComments.class);
    get(CHANGE_KIND, "drafts").to(ListChangeDrafts.class);
    get(CHANGE_KIND, "check").to(Check.class);
    post(CHANGE_KIND, "check").to(Check.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND).to(DeleteDraftChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "hashtags").to(PostHashtags.class);
    post(CHANGE_KIND, "publish").to(PublishDraftPatchSet.CurrentRevision.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    get(CHANGE_KIND, "submitted_together").to(SubmittedTogether.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "index").to(Index.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    get(CHANGE_KIND, "suggest_reviewers").to(ChangeSuggestReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    get(REVISION_KIND, "actions").to(GetRevisionActions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    delete(REVISION_KIND).to(DeleteDraftPatchSet.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    post(REVISION_KIND, "publish").to(PublishDraftPatchSet.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    get(REVISION_KIND, "archive").to(GetArchive.class);
    child(REVISION_KIND, "drafts").to(DraftComments.class);
    put(REVISION_KIND, "drafts").to(CreateDraftComment.class);
    get(DRAFT_COMMENT_KIND).to(GetDraftComment.class);
    put(DRAFT_COMMENT_KIND).to(PutDraftComment.class);
    delete(DRAFT_COMMENT_KIND).to(DeleteDraftComment.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "download").to(DownloadContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    child(CHANGE_KIND, "edit").to(ChangeEdits.class);
    delete(CHANGE_KIND, "edit").to(DeleteChangeEdit.class);
    child(CHANGE_KIND, "edit:publish").to(PublishChangeEdit.class);
    child(CHANGE_KIND, "edit:rebase").to(RebaseChangeEdit.class);
    put(CHANGE_KIND, "edit:message").to(ChangeEdits.EditMessage.class);
    get(CHANGE_KIND, "edit:message").to(ChangeEdits.GetMessage.class);
    put(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Put.class);
    delete(CHANGE_EDIT_KIND).to(ChangeEdits.DeleteContent.class);
    get(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Get.class);
    get(CHANGE_EDIT_KIND, "meta").to(ChangeEdits.GetMeta.class);
    factory(AccountLoader.Factory.class);
    factory(ChangeEdits.Create.Factory.class);
    factory(ChangeEdits.DeleteFile.Factory.class);
    factory(ChangeInserter.Factory.class);
    factory(EmailReviewComments.Factory.class);
    factory(PatchSetInserter.Factory.class);
    factory(RebaseChangeOp.Factory.class);
    factory(ReviewerResource.Factory.class);
    factory(SetHashtagsOp.Factory.class);
}
#method_after
@Override
protected void configure() {
    bind(ChangesCollection.class);
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(DraftComments.class);
    bind(Comments.class);
    bind(Files.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), DRAFT_COMMENT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    DynamicMap.mapOf(binder(), CHANGE_EDIT_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    get(CHANGE_KIND, "in").to(IncludedIn.class);
    get(CHANGE_KIND, "hashtags").to(GetHashtags.class);
    get(CHANGE_KIND, "comments").to(ListChangeComments.class);
    get(CHANGE_KIND, "drafts").to(ListChangeDrafts.class);
    get(CHANGE_KIND, "check").to(Check.class);
    post(CHANGE_KIND, "check").to(Check.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND).to(DeleteDraftChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "hashtags").to(PostHashtags.class);
    post(CHANGE_KIND, "publish").to(PublishDraftPatchSet.CurrentRevision.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    get(CHANGE_KIND, "submitted_together").to(SubmittedTogether.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "index").to(Index.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    get(CHANGE_KIND, "suggest_reviewers").to(SuggestChangeReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    get(REVISION_KIND, "actions").to(GetRevisionActions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    delete(REVISION_KIND).to(DeleteDraftPatchSet.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    post(REVISION_KIND, "publish").to(PublishDraftPatchSet.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    get(REVISION_KIND, "archive").to(GetArchive.class);
    child(REVISION_KIND, "drafts").to(DraftComments.class);
    put(REVISION_KIND, "drafts").to(CreateDraftComment.class);
    get(DRAFT_COMMENT_KIND).to(GetDraftComment.class);
    put(DRAFT_COMMENT_KIND).to(PutDraftComment.class);
    delete(DRAFT_COMMENT_KIND).to(DeleteDraftComment.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "download").to(DownloadContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    child(CHANGE_KIND, "edit").to(ChangeEdits.class);
    delete(CHANGE_KIND, "edit").to(DeleteChangeEdit.class);
    child(CHANGE_KIND, "edit:publish").to(PublishChangeEdit.class);
    child(CHANGE_KIND, "edit:rebase").to(RebaseChangeEdit.class);
    put(CHANGE_KIND, "edit:message").to(ChangeEdits.EditMessage.class);
    get(CHANGE_KIND, "edit:message").to(ChangeEdits.GetMessage.class);
    put(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Put.class);
    delete(CHANGE_EDIT_KIND).to(ChangeEdits.DeleteContent.class);
    get(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Get.class);
    get(CHANGE_EDIT_KIND, "meta").to(ChangeEdits.GetMeta.class);
    factory(AccountLoader.Factory.class);
    factory(ChangeEdits.Create.Factory.class);
    factory(ChangeEdits.DeleteFile.Factory.class);
    factory(ChangeInserter.Factory.class);
    factory(EmailReviewComments.Factory.class);
    factory(PatchSetInserter.Factory.class);
    factory(RebaseChangeOp.Factory.class);
    factory(ReviewerResource.Factory.class);
    factory(SetHashtagsOp.Factory.class);
}
#end_block

#method_before
private List<SuggestedReviewerInfo> suggestReviewers(SuggestedReviewersRequest r) throws RestApiException {
    try {
        ChangeSuggestReviewers mySuggestReviewers = suggestReviewers.get();
        mySuggestReviewers.setQuery(r.getQuery());
        mySuggestReviewers.setLimit(r.getLimit());
        return mySuggestReviewers.apply(change);
    } catch (OrmException | IOException e) {
        throw new RestApiException("Cannot retrieve suggested reviewers", e);
    }
}
#method_after
private List<SuggestedReviewerInfo> suggestReviewers(SuggestedReviewersRequest r) throws RestApiException {
    try {
        SuggestChangeReviewers mySuggestReviewers = suggestReviewers.get();
        mySuggestReviewers.setQuery(r.getQuery());
        mySuggestReviewers.setLimit(r.getLimit());
        return mySuggestReviewers.apply(change);
    } catch (OrmException | IOException e) {
        throw new RestApiException("Cannot retrieve suggested reviewers", e);
    }
}
#end_block

#method_before
@Override
public String getChangeAvatarUrl(IdentifiedUser forUser) {
    return changeUrl;
}
#method_after
@Override
public String getChangeAvatarUrl(IdentifiedUser forUser) {
    return changeAvatarUrl;
}
#end_block

#method_before
@Override
public String getRefName() {
    return R_HEADS + change.branch;
}
#method_after
@Override
public String getRefName() {
    return RefNames.fullName(change.branch);
}
#end_block

#method_before
public void fireEvent(final Event event, final ReviewDb db) throws OrmException {
    if (event instanceof ChangeEvent) {
        ChangeEvent cev = (ChangeEvent) event;
        Change change = db.changes().get(cev.getChangeId());
        fireEvent(change, cev, db);
    } else if (event instanceof RefEvent) {
        RefEvent rev = (RefEvent) event;
        fireEvent(rev.getBranchNameKey(), rev);
    }
}
#method_after
private void fireEvent(Project.NameKey project, ProjectEvent event) {
    for (EventListenerHolder holder : listeners.values()) {
        if (isVisibleTo(project, event, holder.user)) {
            holder.listener.onEvent(event);
        }
    }
    fireEventForUnrestrictedListeners(event);
}
#end_block

#method_before
public void fireEvent(final Event event, final ReviewDb db) throws OrmException {
    if (event instanceof ChangeEvent) {
        ChangeEvent cev = (ChangeEvent) event;
        Change change = db.changes().get(cev.getChangeId());
        fireEvent(change, cev, db);
    } else if (event instanceof RefEvent) {
        RefEvent rev = (RefEvent) event;
        fireEvent(rev.getBranchNameKey(), rev);
    }
}
#method_after
protected void fireEvent(Event event, ReviewDb db) throws OrmException {
    for (EventListenerHolder holder : listeners.values()) {
        if (isVisibleTo(event, holder.user, db)) {
            holder.listener.onEvent(event);
        }
    }
    fireEventForUnrestrictedListeners(event);
}
#end_block

#method_before
private boolean isVisibleTo(Branch.NameKey branchName, CurrentUser user) {
    final ProjectState pe = projectCache.get(branchName.getParentKey());
    if (pe == null) {
        return false;
    }
    final ProjectControl pc = pe.controlFor(user);
    return pc.controlForRef(branchName).isVisible();
}
#method_after
private boolean isVisibleTo(Project.NameKey project, ProjectEvent event, CurrentUser user) {
    ProjectState pe = projectCache.get(project);
    if (pe == null) {
        return false;
    }
    ProjectControl pc = pe.controlFor(user);
    return pc.controlForRef(((ProjectCreatedEvent) event).getHeadName()).isVisible();
}
#end_block

#method_before
public void fireEventForUnrestrictedListeners(final Event event) {
    for (ChangeListener listener : unrestrictedListeners) {
        listener.onEvent(event);
    }
}
#method_after
protected void fireEventForUnrestrictedListeners(final Event event) {
    for (EventListener listener : unrestrictedListeners) {
        listener.onEvent(event);
    }
}
#end_block

#method_before
public void fireEvent(final Change change, final ChangeEvent event, final ReviewDb db) throws OrmException {
    for (ChangeListenerHolder holder : listeners.values()) {
        if (isVisibleTo(change, holder.user, db)) {
            holder.listener.onEvent(event);
        }
    }
    fireEventForUnrestrictedListeners(event);
}
#method_after
protected void fireEvent(Change change, ChangeEvent event, ReviewDb db) throws OrmException {
    for (EventListenerHolder holder : listeners.values()) {
        if (isVisibleTo(change, holder.user, db)) {
            holder.listener.onEvent(event);
        }
    }
    fireEventForUnrestrictedListeners(event);
}
#end_block

#method_before
public void fireEvent(Branch.NameKey branchName, final RefEvent event) {
    if (event instanceof ChangeEvent) {
        throw new IllegalArgumentException("ChangeEvents require a Change to fire");
    }
    for (ChangeListenerHolder holder : listeners.values()) {
        if (isVisibleTo(branchName, holder.user)) {
            holder.listener.onEvent(event);
        }
    }
    fireEventForUnrestrictedListeners(event);
}
#method_after
protected void fireEvent(Branch.NameKey branchName, RefEvent event) {
    if (event instanceof ChangeEvent) {
        throw new IllegalArgumentException("ChangeEvents require a Change to fire");
    }
    for (EventListenerHolder holder : listeners.values()) {
        if (isVisibleTo(branchName, holder.user)) {
            holder.listener.onEvent(event);
        }
    }
    fireEventForUnrestrictedListeners(event);
}
#end_block

#method_before
private boolean isVisibleTo(Change change, CurrentUser user, ReviewDb db) throws OrmException {
    final ProjectState pe = projectCache.get(change.getProject());
    if (pe == null) {
        return false;
    }
    final ProjectControl pc = pe.controlFor(user);
    return pc.controlFor(change).isVisible(db);
}
#method_after
protected boolean isVisibleTo(Change change, CurrentUser user, ReviewDb db) throws OrmException {
    ProjectState pe = projectCache.get(change.getProject());
    if (pe == null) {
        return false;
    }
    ProjectControl pc = pe.controlFor(user);
    return pc.controlFor(change).isVisible(db);
}
#end_block

#method_before
private boolean isVisibleTo(Branch.NameKey branchName, CurrentUser user) {
    final ProjectState pe = projectCache.get(branchName.getParentKey());
    if (pe == null) {
        return false;
    }
    final ProjectControl pc = pe.controlFor(user);
    return pc.controlForRef(branchName).isVisible();
}
#method_after
protected boolean isVisibleTo(Branch.NameKey branchName, CurrentUser user) {
    ProjectState pe = projectCache.get(branchName.getParentKey());
    if (pe == null) {
        return false;
    }
    ProjectControl pc = pe.controlFor(user);
    return pc.controlForRef(branchName).isVisible();
}
#end_block

#method_before
private String replaceInUrl(String placeholder, String url, String replacement) {
    if (replacement == null || url == null || url.contains(placeholder) == false) {
        return url;
    }
    // as we can't assume anything of 'replacement', we're URL encoding it
    return url.replace(placeholder, Url.encode(replacement));
}
#method_after
private String replaceInUrl(String placeholder, String url, String replacement) {
    if (!url.contains(placeholder)) {
        return url;
    }
    // as we can't assume anything of 'replacement', we're URL encoding it
    return url.replace(placeholder, Url.encode(replacement));
}
#end_block

#method_before
private void saveCookie() {
    if (response == null) {
        return;
    }
    final String token;
    final int ageSeconds;
    if (key == null) {
        token = "";
        ageSeconds = 0;
    } else {
        token = key.getToken();
        ageSeconds = manager.getCookieAge(val);
    }
    String path = authConfig.getCookiePath();
    if (path == null || path.isEmpty()) {
        path = request.getContextPath();
        if (path == null || path.isEmpty()) {
            path = "/";
        }
    }
    if (outCookie != null) {
        throw new IllegalStateException("Cookie " + ACCOUNT_COOKIE + " was set");
    }
    outCookie = new Cookie(ACCOUNT_COOKIE, token);
    String domain = authConfig.getCookieDomain();
    if (domain != null && !domain.isEmpty()) {
        outCookie.setDomain(domain);
    }
    outCookie.setSecure(isSecure(request));
    outCookie.setPath(path);
    outCookie.setMaxAge(ageSeconds);
    outCookie.setSecure(authConfig.getCookieSecure());
    response.addCookie(outCookie);
}
#method_after
private void saveCookie() {
    if (response == null) {
        return;
    }
    final String token;
    final int ageSeconds;
    if (key == null) {
        token = "";
        ageSeconds = 0;
    } else {
        token = key.getToken();
        ageSeconds = manager.getCookieAge(val);
    }
    String path = authConfig.getCookiePath();
    if (Strings.isNullOrEmpty(path)) {
        path = request.getContextPath();
        if (Strings.isNullOrEmpty(path)) {
            path = "/";
        }
    }
    if (outCookie != null) {
        throw new IllegalStateException("Cookie " + ACCOUNT_COOKIE + " was set");
    }
    outCookie = new Cookie(ACCOUNT_COOKIE, token);
    String domain = authConfig.getCookieDomain();
    if (!Strings.isNullOrEmpty(domain)) {
        outCookie.setDomain(domain);
    }
    outCookie.setSecure(isSecure(request));
    outCookie.setPath(path);
    outCookie.setMaxAge(ageSeconds);
    outCookie.setSecure(authConfig.getCookieSecure());
    response.addCookie(outCookie);
}
#end_block

#method_before
@Test
public void revert() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.approve());
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).submit();
    ChangeInfo revertChange = gApi.changes().id(r.getChangeId()).revert().get();
    // expected messages on source change:
    // 1. Uploaded patch set 1.
    // 2. Patch Set 1: Code-Review+2
    // 3. Change has been successfully merged by Administrator
    // 4. Patch Set 1: Reverted
    List<ChangeMessageInfo> sourceMessages = new ArrayList<>(gApi.changes().id(r.getChangeId()).get().messages);
    assertThat(sourceMessages).hasSize(4);
    String expectedMessage = String.format("Patch Set 1: Reverted\n\n" + "A change to revert this patchset was created: %s", revertChange.changeId);
    assertThat(sourceMessages.get(3).message).isEqualTo(expectedMessage);
    assertThat(revertChange.messages).hasSize(1);
    assertThat(revertChange.messages.iterator().next().message).isEqualTo("Uploaded patch set 1.");
}
#method_after
@Test
public void revert() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.approve());
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).submit();
    ChangeInfo revertChange = gApi.changes().id(r.getChangeId()).revert().get();
    // expected messages on source change:
    // 1. Uploaded patch set 1.
    // 2. Patch Set 1: Code-Review+2
    // 3. Change has been successfully merged by Administrator
    // 4. Patch Set 1: Reverted
    List<ChangeMessageInfo> sourceMessages = new ArrayList<>(gApi.changes().id(r.getChangeId()).get().messages);
    assertThat(sourceMessages).hasSize(4);
    String expectedMessage = String.format("Created a revert of this change as %s", revertChange.changeId);
    assertThat(sourceMessages.get(3).message).isEqualTo(expectedMessage);
    assertThat(revertChange.messages).hasSize(1);
    assertThat(revertChange.messages.iterator().next().message).isEqualTo("Uploaded patch set 1.");
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws Exception {
    Change change = ctx.getChange();
    PatchSet.Id patchSetId = change.currentPatchSetId();
    ChangeMessage changeMessage = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db.get())), ctx.getUser().getAccountId(), ctx.getWhen(), patchSetId);
    StringBuilder msgBuf = new StringBuilder();
    msgBuf.append("Patch Set ").append(patchSetId.get()).append(": Reverted");
    msgBuf.append("\n\n");
    msgBuf.append("A change to revert this patchset was created: ").append("I").append(computedChangeId.name());
    changeMessage.setMessage(msgBuf.toString());
    cmUtil.addChangeMessage(ctx.getDb(), ctx.getUpdate(patchSetId), changeMessage);
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws Exception {
    Change change = ctx.getChange();
    PatchSet.Id patchSetId = change.currentPatchSetId();
    ChangeMessage changeMessage = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db.get())), ctx.getUser().getAccountId(), ctx.getWhen(), patchSetId);
    StringBuilder msgBuf = new StringBuilder();
    msgBuf.append("Created a revert of this change as ").append("I").append(computedChangeId.name());
    changeMessage.setMessage(msgBuf.toString());
    cmUtil.addChangeMessage(ctx.getDb(), ctx.getUpdate(patchSetId), changeMessage);
    return true;
}
#end_block

#method_before
@Override
public void afterUpdateRepos() throws ResourceConflictException {
    try {
        markCleanMerges();
        checkCommitStatus();
        findUnmergedChanges();
    } catch (IntegrationException e) {
        throw new ResourceConflictException(e.getMessage(), e);
    }
}
#method_after
@Override
public void afterUpdateRepos() throws ResourceConflictException {
    try {
        markCleanMerges();
        List<Change.Id> alreadyMerged = checkCommitStatus();
        findUnmergedChanges(alreadyMerged);
    } catch (IntegrationException e) {
        throw new ResourceConflictException(e.getMessage(), e);
    }
}
#end_block

#method_before
private void findUnmergedChanges() throws ResourceConflictException, IntegrationException {
    for (SubmitStrategy strategy : strategies) {
        if (strategy instanceof CherryPick) {
            // Might have picked a subset of changes, can't do this sanity check.
            continue;
        }
        SubmitStrategy.Arguments args = strategy.args;
        Set<Change.Id> unmerged = args.mergeUtil.findUnmergedChanges(args.commits.getChangeIds(args.destBranch), args.rw, args.canMergeFlag, args.mergeTip.getInitialTip(), args.mergeTip.getCurrentTip());
        for (Change.Id id : unmerged) {
            commits.problem(id, "internal error: change not reachable from new branch tip");
        }
    }
    commits.maybeFailVerbose();
}
#method_after
private void findUnmergedChanges(List<Change.Id> alreadyMerged) throws ResourceConflictException, IntegrationException {
    for (SubmitStrategy strategy : strategies) {
        if (strategy instanceof CherryPick) {
            // Might have picked a subset of changes, can't do this sanity check.
            continue;
        }
        SubmitStrategy.Arguments args = strategy.args;
        Set<Change.Id> unmerged = args.mergeUtil.findUnmergedChanges(args.commits.getChangeIds(args.destBranch), args.rw, args.canMergeFlag, args.mergeTip.getInitialTip(), args.mergeTip.getCurrentTip(), alreadyMerged);
        for (Change.Id id : unmerged) {
            commits.problem(id, "internal error: change not reachable from new branch tip");
        }
    }
    commits.maybeFailVerbose();
}
#end_block

#method_before
private void checkCommitStatus() throws ResourceConflictException {
    for (Change.Id id : commits.getChangeIds()) {
        CodeReviewCommit commit = commits.get(id);
        CommitMergeStatus s = commit != null ? commit.getStatusCode() : null;
        if (s == null) {
            commits.problem(id, "internal error: change not processed by merge strategy");
            return;
        }
        switch(s) {
            case CLEAN_MERGE:
            case CLEAN_REBASE:
            case CLEAN_PICK:
            case ALREADY_MERGED:
                // Merge strategy accepted this change.
                break;
            case PATH_CONFLICT:
            case REBASE_MERGE_CONFLICT:
            case MANUAL_RECURSIVE_MERGE:
            case CANNOT_CHERRY_PICK_ROOT:
            case CANNOT_REBASE_ROOT:
            case NOT_FAST_FORWARD:
                // TODO(dborowitz): Reformat these messages to be more appropriate for
                // short problem descriptions.
                commits.problem(id, CharMatcher.is('\n').collapseFrom(s.getMessage(), ' '));
                break;
            case MISSING_DEPENDENCY:
                commits.problem(id, "depends on change that was not submitted");
                break;
            default:
                commits.problem(id, "unspecified merge failure: " + s);
                break;
        }
    }
    commits.maybeFailVerbose();
}
#method_after
private List<Change.Id> checkCommitStatus() throws ResourceConflictException {
    List<Change.Id> alreadyMerged = new ArrayList<>(commits.getChangeIds().size());
    for (Change.Id id : commits.getChangeIds()) {
        CodeReviewCommit commit = commits.get(id);
        CommitMergeStatus s = commit != null ? commit.getStatusCode() : null;
        if (s == null) {
            commits.problem(id, "internal error: change not processed by merge strategy");
            continue;
        }
        switch(s) {
            case CLEAN_MERGE:
            case CLEAN_REBASE:
            case CLEAN_PICK:
                // Merge strategy accepted this change.
                break;
            case ALREADY_MERGED:
                // Already an ancestor of tip.
                alreadyMerged.add(commit.getPatchsetId().getParentKey());
                break;
            case PATH_CONFLICT:
            case REBASE_MERGE_CONFLICT:
            case MANUAL_RECURSIVE_MERGE:
            case CANNOT_CHERRY_PICK_ROOT:
            case CANNOT_REBASE_ROOT:
            case NOT_FAST_FORWARD:
                // TODO(dborowitz): Reformat these messages to be more appropriate for
                // short problem descriptions.
                commits.problem(id, CharMatcher.is('\n').collapseFrom(s.getMessage(), ' '));
                break;
            case MISSING_DEPENDENCY:
                commits.problem(id, "depends on change that was not submitted");
                break;
            default:
                commits.problem(id, "unspecified merge failure: " + s);
                break;
        }
    }
    commits.maybeFailVerbose();
    return alreadyMerged;
}
#end_block

#method_before
@Override
public Response<ChangeInfo> apply(TopLevelResource parent, ChangeInfo input) throws OrmException, IOException, InvalidChangeOperationException, RestApiException, UpdateException {
    if (Strings.isNullOrEmpty(input.project)) {
        throw new BadRequestException("project must be non-empty");
    }
    if (Strings.isNullOrEmpty(input.branch)) {
        throw new BadRequestException("branch must be non-empty");
    }
    if (Strings.isNullOrEmpty(input.subject)) {
        throw new BadRequestException("commit message must be non-empty");
    }
    if (input.status != null) {
        if (input.status != ChangeStatus.NEW && input.status != ChangeStatus.DRAFT) {
            throw new BadRequestException("unsupported change status");
        }
        if (!allowDrafts && input.status == ChangeStatus.DRAFT) {
            throw new MethodNotAllowedException("draft workflow is disabled");
        }
    }
    String refName = RefNames.fullName(input.branch);
    ProjectResource rsrc = projectsCollection.parse(input.project);
    Capable r = rsrc.getControl().canPushToAtLeastOneRef();
    if (r != Capable.OK) {
        throw new AuthException(r.getMessage());
    }
    RefControl refControl = rsrc.getControl().controlForRef(refName);
    if (!refControl.canUpload() || !refControl.canRead()) {
        throw new AuthException("cannot upload review");
    }
    Project.NameKey project = rsrc.getNameKey();
    try (Repository git = gitManager.openRepository(project);
        RevWalk rw = new RevWalk(git)) {
        ObjectId parentCommit;
        List<String> groups;
        if (input.baseChange != null) {
            List<ChangeControl> ctls = changeFinder.find(input.baseChange, rsrc.getControl().getUser());
            if (ctls.size() != 1) {
                throw new InvalidChangeOperationException("Base change not found: " + input.baseChange);
            }
            ChangeControl ctl = Iterables.getOnlyElement(ctls);
            if (!ctl.isVisible(db.get())) {
                throw new InvalidChangeOperationException("Base change not found: " + input.baseChange);
            }
            PatchSet ps = psUtil.current(db.get(), ctl.getNotes());
            parentCommit = ObjectId.fromString(ps.getRevision().get());
            groups = ps.getGroups();
        } else {
            Ref destRef = git.getRefDatabase().exactRef(refName);
            if (destRef != null) {
                parentCommit = destRef.getObjectId();
            } else {
                if (input.newBranch) {
                    parentCommit = null;
                } else {
                    throw new UnprocessableEntityException(String.format("Branch %s does not exist.", refName));
                }
            }
            groups = Collections.emptyList();
        }
        RevCommit mergeTip = parentCommit == null ? null : rw.parseCommit(parentCommit);
        Timestamp now = TimeUtil.nowTs();
        IdentifiedUser me = user.get().asIdentifiedUser();
        PersonIdent author = me.newCommitterIdent(now, serverTimeZone);
        try (ObjectInserter oi = git.newObjectInserter()) {
            ObjectId treeId = mergeTip == null ? emptyTreeId(oi) : mergeTip.getTree();
            ObjectId id = ChangeIdUtil.computeChangeId(treeId, mergeTip, author, author, input.subject);
            String commitMessage = ChangeIdUtil.insertId(input.subject, id);
            RevCommit c = newCommit(oi, rw, author, mergeTip, commitMessage);
            Change.Id changeId = new Change.Id(seq.nextChangeId());
            ChangeInserter ins = changeInserterFactory.create(changeId, c, refName).setValidatePolicy(CommitValidators.Policy.GERRIT);
            ins.setMessage(String.format("Uploaded patch set %s.", ins.getPatchSetId().get()));
            String topic = input.topic;
            if (topic != null) {
                topic = Strings.emptyToNull(topic.trim());
            }
            ins.setTopic(topic);
            ins.setDraft(input.status != null && input.status == ChangeStatus.DRAFT);
            ins.setGroups(groups);
            try (BatchUpdate bu = updateFactory.create(db.get(), project, me, now)) {
                bu.setRepository(git, rw, oi);
                bu.insertChange(ins);
                bu.execute();
            }
            ChangeJson json = jsonFactory.create(ChangeJson.NO_OPTIONS);
            return Response.created(json.format(project, changeId));
        }
    }
}
#method_after
@Override
public Response<ChangeInfo> apply(TopLevelResource parent, ChangeInput input) throws OrmException, IOException, InvalidChangeOperationException, RestApiException, UpdateException {
    if (Strings.isNullOrEmpty(input.project)) {
        throw new BadRequestException("project must be non-empty");
    }
    if (Strings.isNullOrEmpty(input.branch)) {
        throw new BadRequestException("branch must be non-empty");
    }
    if (Strings.isNullOrEmpty(input.subject)) {
        throw new BadRequestException("commit message must be non-empty");
    }
    if (input.status != null) {
        if (input.status != ChangeStatus.NEW && input.status != ChangeStatus.DRAFT) {
            throw new BadRequestException("unsupported change status");
        }
        if (!allowDrafts && input.status == ChangeStatus.DRAFT) {
            throw new MethodNotAllowedException("draft workflow is disabled");
        }
    }
    String refName = RefNames.fullName(input.branch);
    ProjectResource rsrc = projectsCollection.parse(input.project);
    Capable r = rsrc.getControl().canPushToAtLeastOneRef();
    if (r != Capable.OK) {
        throw new AuthException(r.getMessage());
    }
    RefControl refControl = rsrc.getControl().controlForRef(refName);
    if (!refControl.canUpload() || !refControl.canRead()) {
        throw new AuthException("cannot upload review");
    }
    Project.NameKey project = rsrc.getNameKey();
    try (Repository git = gitManager.openRepository(project);
        RevWalk rw = new RevWalk(git)) {
        ObjectId parentCommit;
        List<String> groups;
        if (input.baseChange != null) {
            List<ChangeControl> ctls = changeFinder.find(input.baseChange, rsrc.getControl().getUser());
            if (ctls.size() != 1) {
                throw new InvalidChangeOperationException("Base change not found: " + input.baseChange);
            }
            ChangeControl ctl = Iterables.getOnlyElement(ctls);
            if (!ctl.isVisible(db.get())) {
                throw new InvalidChangeOperationException("Base change not found: " + input.baseChange);
            }
            PatchSet ps = psUtil.current(db.get(), ctl.getNotes());
            parentCommit = ObjectId.fromString(ps.getRevision().get());
            groups = ps.getGroups();
        } else {
            Ref destRef = git.getRefDatabase().exactRef(refName);
            if (destRef != null) {
                if (Boolean.TRUE.equals(input.newBranch)) {
                    throw new ResourceConflictException(String.format("Branch %s already exists.", refName));
                } else {
                    parentCommit = destRef.getObjectId();
                }
            } else {
                if (Boolean.TRUE.equals(input.newBranch)) {
                    parentCommit = null;
                } else {
                    throw new UnprocessableEntityException(String.format("Branch %s does not exist.", refName));
                }
            }
            groups = Collections.emptyList();
        }
        RevCommit mergeTip = parentCommit == null ? null : rw.parseCommit(parentCommit);
        Timestamp now = TimeUtil.nowTs();
        IdentifiedUser me = user.get().asIdentifiedUser();
        PersonIdent author = me.newCommitterIdent(now, serverTimeZone);
        try (ObjectInserter oi = git.newObjectInserter()) {
            ObjectId treeId = mergeTip == null ? emptyTreeId(oi) : mergeTip.getTree();
            ObjectId id = ChangeIdUtil.computeChangeId(treeId, mergeTip, author, author, input.subject);
            String commitMessage = ChangeIdUtil.insertId(input.subject, id);
            RevCommit c = newCommit(oi, rw, author, mergeTip, commitMessage);
            Change.Id changeId = new Change.Id(seq.nextChangeId());
            ChangeInserter ins = changeInserterFactory.create(changeId, c, refName).setValidatePolicy(CommitValidators.Policy.GERRIT);
            ins.setMessage(String.format("Uploaded patch set %s.", ins.getPatchSetId().get()));
            String topic = input.topic;
            if (topic != null) {
                topic = Strings.emptyToNull(topic.trim());
            }
            ins.setTopic(topic);
            ins.setDraft(input.status != null && input.status == ChangeStatus.DRAFT);
            ins.setGroups(groups);
            try (BatchUpdate bu = updateFactory.create(db.get(), project, me, now)) {
                bu.setRepository(git, rw, oi);
                bu.insertChange(ins);
                bu.execute();
            }
            ChangeJson json = jsonFactory.create(ChangeJson.NO_OPTIONS);
            return Response.created(json.format(project, changeId));
        }
    }
}
#end_block

#method_before
private static ObjectId emptyTreeId(ObjectInserter inserter) throws IOException {
    return inserter.insert(new TreeFormatter());
}
#method_after
private static ObjectId emptyTreeId(ObjectInserter inserter) throws IOException {
    ObjectId id = inserter.insert(new TreeFormatter());
    inserter.flush();
    return id;
}
#end_block

#method_before
private void insertChange(RequestState state) throws OrmException, IOException, RestApiException, UpdateException {
    RevCommit commit = state.rw.parseCommit(commitId);
    state.rw.parseBody(commit);
    final PatchSet.Id psId = ins.setGroups(groups).getPatchSetId();
    final Account.Id me = user.getAccountId();
    final List<FooterLine> footerLines = commit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    Map<String, Short> approvals = new HashMap<>();
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.labels;
    }
    recipients.add(getRecipientsFromFooters(accountResolver, magicBranch.draft, footerLines));
    recipients.remove(me);
    String msg = renderMessageWithApprovals(psId.get(), null, approvals, Collections.<String, PatchSetApproval>emptyMap());
    try (BatchUpdate bu = batchUpdateFactory.create(state.db, magicBranch.dest.getParentKey(), user, TimeUtil.nowTs())) {
        bu.setRepository(state.repo, state.rw, state.ins);
        bu.insertChange(ins.setReviewers(recipients.getReviewers()).setExtraCC(recipients.getCcOnly()).setApprovals(approvals).setMessage(msg).setRequestScopePropagator(requestScopePropagator).setSendMail(true).setUpdateRef(true));
        if (magicBranch != null) {
            bu.addOp(changeId, hashtagsFactory.create(new HashtagsInput(magicBranch.hashtags)).setRunHooks(false));
            if (!Strings.isNullOrEmpty(magicBranch.topic)) {
                bu.addOp(changeId, new BatchUpdate.Op() {

                    @Override
                    public boolean updateChange(ChangeContext ctx) {
                        ctx.getUpdate(psId).setTopic(magicBranch.topic);
                        return true;
                    }
                });
            }
        }
        bu.execute();
    }
    change = ins.getChange();
    if (magicBranch != null && magicBranch.submit) {
        submit(projectControl.controlFor(change), ins.getPatchSet());
    }
}
#method_after
private void insertChange(RequestState state) throws OrmException, IOException, RestApiException, UpdateException {
    RevCommit commit = state.rw.parseCommit(commitId);
    state.rw.parseBody(commit);
    final PatchSet.Id psId = ins.setGroups(groups).getPatchSetId();
    final Account.Id me = user.getAccountId();
    final List<FooterLine> footerLines = commit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    Map<String, Short> approvals = new HashMap<>();
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.labels;
    }
    recipients.add(getRecipientsFromFooters(accountResolver, magicBranch.draft, footerLines));
    recipients.remove(me);
    String msg = renderMessageWithApprovals(psId.get(), null, approvals, Collections.<String, PatchSetApproval>emptyMap());
    try (BatchUpdate bu = batchUpdateFactory.create(state.db, magicBranch.dest.getParentKey(), user, TimeUtil.nowTs())) {
        bu.setRepository(state.repo, state.rw, state.ins);
        bu.insertChange(ins.setReviewers(recipients.getReviewers()).setExtraCC(recipients.getCcOnly()).setApprovals(approvals).setMessage(msg).setRequestScopePropagator(requestScopePropagator).setSendMail(true).setUpdateRef(true));
        if (magicBranch != null) {
            bu.addOp(changeId, hashtagsFactory.create(new HashtagsInput(magicBranch.hashtags)).setRunHooks(false));
            if (!Strings.isNullOrEmpty(magicBranch.topic)) {
                bu.addOp(changeId, new BatchUpdate.Op() {

                    @Override
                    public boolean updateChange(ChangeContext ctx) {
                        ctx.getUpdate(psId).setTopic(magicBranch.topic);
                        return true;
                    }
                });
            }
        }
        bu.execute();
    }
    change = ins.getChange();
    if (magicBranch != null && magicBranch.submit) {
        submit(projectControl.controlFor(state.db, change), ins.getPatchSet());
    }
}
#end_block

#method_before
boolean validate(boolean autoClose) throws IOException, OrmException {
    if (!autoClose && inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    } else if (change == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    priorPatchSet = change.currentPatchSetId();
    if (!revisions.containsValue(priorPatchSet)) {
        reject(inputCommand, "change " + ontoChange + " missing revisions");
        return false;
    }
    RevCommit newCommit = rp.getRevWalk().parseCommit(newCommitId);
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    if (newCommit.equals(priorCommit)) {
        // Ignore requests to make the change its current state.
        skip = true;
        reject(inputCommand, "commit already exists (as current patchset)");
        return false;
    }
    changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet(db)) {
        String locked = ".";
        if (changeCtl.isPatchSetLocked(db)) {
            locked = ". Change is patch set locked.";
        }
        reject(inputCommand, "cannot replace " + ontoChange + locked);
        return false;
    } else if (change.getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    } else if (revisions.containsKey(newCommit)) {
        reject(inputCommand, "commit already exists (in the change)");
        return false;
    }
    for (final Ref r : rp.getRepository().getRefDatabase().getRefs("refs/changes").values()) {
        if (r.getObjectId().equals(newCommit)) {
            reject(inputCommand, "commit already exists (in the project)");
            return false;
        }
    }
    for (RevCommit prior : revisions.keySet()) {
        // amending when trying to address review comments.
        if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
            reject(inputCommand, "squash commits first");
            return false;
        }
    }
    if (!validCommit(rp.getRevWalk(), changeCtl.getRefControl(), inputCommand, newCommit)) {
        return false;
    }
    rp.getRevWalk().parseBody(priorCommit);
    // of the commit was modified.
    if (newCommit.getTree().equals(priorCommit.getTree())) {
        final boolean messageEq = eq(newCommit.getFullMessage(), priorCommit.getFullMessage());
        final boolean parentsEq = parentsEqual(newCommit, priorCommit);
        final boolean authorEq = authorEqual(newCommit, priorCommit);
        final ObjectReader reader = rp.getRevWalk().getObjectReader();
        if (messageEq && parentsEq && authorEq && !autoClose) {
            addMessage(String.format("(W) No changes between prior commit %s and new commit %s", reader.abbreviate(priorCommit).name(), reader.abbreviate(newCommit).name()));
        } else {
            StringBuilder msg = new StringBuilder();
            msg.append("(W) ");
            msg.append(reader.abbreviate(newCommit).name());
            msg.append(":");
            msg.append(" no files changed");
            if (!authorEq) {
                msg.append(", author changed");
            }
            if (!messageEq) {
                msg.append(", message updated");
            }
            if (!parentsEq) {
                msg.append(", was rebased");
            }
            addMessage(msg.toString());
        }
    }
    if (magicBranch != null && magicBranch.edit) {
        return newEdit();
    }
    newPatchSet();
    return true;
}
#method_after
boolean validate(boolean autoClose) throws IOException, OrmException {
    if (!autoClose && inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    } else if (change == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    priorPatchSet = change.currentPatchSetId();
    if (!revisions.containsValue(priorPatchSet)) {
        reject(inputCommand, "change " + ontoChange + " missing revisions");
        return false;
    }
    RevCommit newCommit = rp.getRevWalk().parseCommit(newCommitId);
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    if (newCommit.equals(priorCommit)) {
        // Ignore requests to make the change its current state.
        skip = true;
        reject(inputCommand, "commit already exists (as current patchset)");
        return false;
    }
    changeCtl = projectControl.controlFor(db, change);
    if (!changeCtl.canAddPatchSet(db)) {
        String locked = ".";
        if (changeCtl.isPatchSetLocked(db)) {
            locked = ". Change is patch set locked.";
        }
        reject(inputCommand, "cannot replace " + ontoChange + locked);
        return false;
    } else if (change.getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    } else if (revisions.containsKey(newCommit)) {
        reject(inputCommand, "commit already exists (in the change)");
        return false;
    }
    for (final Ref r : rp.getRepository().getRefDatabase().getRefs("refs/changes").values()) {
        if (r.getObjectId().equals(newCommit)) {
            reject(inputCommand, "commit already exists (in the project)");
            return false;
        }
    }
    for (RevCommit prior : revisions.keySet()) {
        // amending when trying to address review comments.
        if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
            reject(inputCommand, "squash commits first");
            return false;
        }
    }
    if (!validCommit(rp.getRevWalk(), changeCtl.getRefControl(), inputCommand, newCommit)) {
        return false;
    }
    rp.getRevWalk().parseBody(priorCommit);
    // of the commit was modified.
    if (newCommit.getTree().equals(priorCommit.getTree())) {
        final boolean messageEq = eq(newCommit.getFullMessage(), priorCommit.getFullMessage());
        final boolean parentsEq = parentsEqual(newCommit, priorCommit);
        final boolean authorEq = authorEqual(newCommit, priorCommit);
        final ObjectReader reader = rp.getRevWalk().getObjectReader();
        if (messageEq && parentsEq && authorEq && !autoClose) {
            addMessage(String.format("(W) No changes between prior commit %s and new commit %s", reader.abbreviate(priorCommit).name(), reader.abbreviate(newCommit).name()));
        } else {
            StringBuilder msg = new StringBuilder();
            msg.append("(W) ");
            msg.append(reader.abbreviate(newCommit).name());
            msg.append(":");
            msg.append(" no files changed");
            if (!authorEq) {
                msg.append(", author changed");
            }
            if (!messageEq) {
                msg.append(", message updated");
            }
            if (!parentsEq) {
                msg.append(", was rebased");
            }
            addMessage(msg.toString());
        }
    }
    if (magicBranch != null && magicBranch.edit) {
        return newEdit();
    }
    newPatchSet();
    return true;
}
#end_block

#method_before
private Change.Key closeChange(ReceiveCommand cmd, PatchSet.Id psi, ObjectId commitId) throws OrmException, IOException {
    String refName = cmd.getRefName();
    Change.Id cid = psi.getParentKey();
    Change change = notesFactory.create(db, project.getNameKey(), cid).getChange();
    ChangeControl ctl = projectControl.controlFor(change);
    PatchSet ps = psUtil.get(db, ctl.getNotes(), psi);
    if (change == null || ps == null) {
        log.warn(project.getName() + " " + psi + " is missing");
        return null;
    }
    if (change.getStatus() == Change.Status.MERGED || change.getStatus() == Change.Status.ABANDONED || !change.getDest().get().equals(refName)) {
        // 
        return null;
    }
    RevCommit commit = rp.getRevWalk().parseCommit(commitId);
    rp.getRevWalk().parseBody(commit);
    PatchSetInfo info = patchSetInfoFactory.get(rp.getRevWalk(), commit, psi);
    markChangeMergedByPush(db, info, refName, ctl);
    hooks.doChangeMergedHook(change, user.getAccount(), ps, db, commit.getName());
    sendMergedEmail(ps, info);
    return change.getKey();
}
#method_after
private Change.Key closeChange(ReceiveCommand cmd, PatchSet.Id psi, ObjectId commitId) throws OrmException, IOException {
    String refName = cmd.getRefName();
    Change.Id cid = psi.getParentKey();
    Change change = notesFactory.create(db, project.getNameKey(), cid).getChange();
    ChangeControl ctl = projectControl.controlFor(db, change);
    PatchSet ps = psUtil.get(db, ctl.getNotes(), psi);
    if (change == null || ps == null) {
        log.warn(project.getName() + " " + psi + " is missing");
        return null;
    }
    if (change.getStatus() == Change.Status.MERGED || change.getStatus() == Change.Status.ABANDONED || !change.getDest().get().equals(refName)) {
        // 
        return null;
    }
    RevCommit commit = rp.getRevWalk().parseCommit(commitId);
    rp.getRevWalk().parseBody(commit);
    PatchSetInfo info = patchSetInfoFactory.get(rp.getRevWalk(), commit, psi);
    markChangeMergedByPush(db, info, refName, ctl);
    hooks.doChangeMergedHook(change, user.getAccount(), ps, db, commit.getName());
    sendMergedEmail(ps, info);
    return change.getKey();
}
#end_block

#method_before
@Override
public PostResult apply(ChangeResource rsrc, AddReviewerInput input) throws AuthException, BadRequestException, UnprocessableEntityException, UpdateException, OrmException, RestApiException, IOException {
    if (input.reviewer == null) {
        throw new BadRequestException("missing reviewer field");
    }
    try {
        Account.Id accountId = accounts.parse(input.reviewer).getAccountId();
        return putAccount(reviewerFactory.create(rsrc, accountId));
    } catch (UnprocessableEntityException e) {
        try {
            return putGroup(rsrc, input);
        } catch (UnprocessableEntityException e2) {
            throw new UnprocessableEntityException(MessageFormat.format(ChangeMessages.get().reviewerNotFound, input.reviewer));
        }
    }
}
#method_after
@Override
public PostResult apply(ChangeResource rsrc, AddReviewerInput input) throws UpdateException, OrmException, RestApiException, IOException {
    if (input.reviewer == null) {
        throw new BadRequestException("missing reviewer field");
    }
    try {
        Account.Id accountId = accounts.parse(input.reviewer).getAccountId();
        return putAccount(reviewerFactory.create(rsrc, accountId));
    } catch (UnprocessableEntityException e) {
        try {
            return putGroup(rsrc, input);
        } catch (UnprocessableEntityException e2) {
            throw new UnprocessableEntityException(MessageFormat.format(ChangeMessages.get().reviewerNotFound, input.reviewer));
        }
    }
}
#end_block

#method_before
private PostResult putAccount(ReviewerResource rsrc) throws OrmException, IOException, UpdateException, RestApiException {
    Account member = rsrc.getReviewerUser().getAccount();
    ChangeControl control = rsrc.getReviewerControl();
    PostResult result = new PostResult();
    if (isValidReviewer(member, control)) {
        addReviewers(rsrc.getChangeResource(), result, ImmutableMap.of(member.getId(), control));
    }
    return result;
}
#method_after
private PostResult putAccount(ReviewerResource rsrc) throws OrmException, UpdateException, RestApiException {
    Account member = rsrc.getReviewerUser().getAccount();
    ChangeControl control = rsrc.getReviewerControl();
    PostResult result = new PostResult();
    if (isValidReviewer(member, control)) {
        addReviewers(rsrc.getChangeResource(), result, ImmutableMap.of(member.getId(), control));
    }
    return result;
}
#end_block

#method_before
private PostResult putGroup(ChangeResource rsrc, AddReviewerInput input) throws BadRequestException, UpdateException, RestApiException, UnprocessableEntityException, OrmException, IOException {
    GroupDescription.Basic group = groupsCollection.parseInternal(input.reviewer);
    PostResult result = new PostResult();
    if (!isLegalReviewerGroup(group.getGroupUUID())) {
        result.error = MessageFormat.format(ChangeMessages.get().groupIsNotAllowed, group.getName());
        return result;
    }
    Map<Account.Id, ChangeControl> reviewers = Maps.newHashMap();
    ChangeControl control = rsrc.getControl();
    Set<Account> members;
    try {
        members = groupMembersFactory.create(control.getUser()).listAccounts(group.getGroupUUID(), control.getProject().getNameKey());
    } catch (NoSuchGroupException e) {
        throw new UnprocessableEntityException(e.getMessage());
    } catch (NoSuchProjectException e) {
        throw new BadRequestException(e.getMessage());
    }
    // if maxAllowed is set to 0, it is allowed to add any number of
    // reviewers
    int maxAllowed = cfg.getInt("addreviewer", "maxAllowed", DEFAULT_MAX_REVIEWERS);
    if (maxAllowed > 0 && members.size() > maxAllowed) {
        result.error = MessageFormat.format(ChangeMessages.get().groupHasTooManyMembers, group.getName());
        return result;
    }
    // if maxWithoutCheck is set to 0, we never ask for confirmation
    int maxWithoutConfirmation = cfg.getInt("addreviewer", "maxWithoutConfirmation", DEFAULT_MAX_REVIEWERS_WITHOUT_CHECK);
    if (!input.confirmed() && maxWithoutConfirmation > 0 && members.size() > maxWithoutConfirmation) {
        result.confirm = true;
        result.error = MessageFormat.format(ChangeMessages.get().groupManyMembersConfirmation, group.getName(), members.size());
        return result;
    }
    for (Account member : members) {
        if (isValidReviewer(member, control)) {
            reviewers.put(member.getId(), control);
        }
    }
    addReviewers(rsrc, result, reviewers);
    return result;
}
#method_after
private PostResult putGroup(ChangeResource rsrc, AddReviewerInput input) throws UpdateException, RestApiException, OrmException, IOException {
    GroupDescription.Basic group = groupsCollection.parseInternal(input.reviewer);
    PostResult result = new PostResult();
    if (!isLegalReviewerGroup(group.getGroupUUID())) {
        result.error = MessageFormat.format(ChangeMessages.get().groupIsNotAllowed, group.getName());
        return result;
    }
    Map<Account.Id, ChangeControl> reviewers = Maps.newHashMap();
    ChangeControl control = rsrc.getControl();
    Set<Account> members;
    try {
        members = groupMembersFactory.create(control.getUser()).listAccounts(group.getGroupUUID(), control.getProject().getNameKey());
    } catch (NoSuchGroupException e) {
        throw new UnprocessableEntityException(e.getMessage());
    } catch (NoSuchProjectException e) {
        throw new BadRequestException(e.getMessage());
    }
    // if maxAllowed is set to 0, it is allowed to add any number of
    // reviewers
    int maxAllowed = cfg.getInt("addreviewer", "maxAllowed", DEFAULT_MAX_REVIEWERS);
    if (maxAllowed > 0 && members.size() > maxAllowed) {
        result.error = MessageFormat.format(ChangeMessages.get().groupHasTooManyMembers, group.getName());
        return result;
    }
    // if maxWithoutCheck is set to 0, we never ask for confirmation
    int maxWithoutConfirmation = cfg.getInt("addreviewer", "maxWithoutConfirmation", DEFAULT_MAX_REVIEWERS_WITHOUT_CHECK);
    if (!input.confirmed() && maxWithoutConfirmation > 0 && members.size() > maxWithoutConfirmation) {
        result.confirm = true;
        result.error = MessageFormat.format(ChangeMessages.get().groupManyMembersConfirmation, group.getName(), members.size());
        return result;
    }
    for (Account member : members) {
        if (isValidReviewer(member, control)) {
            reviewers.put(member.getId(), control);
        }
    }
    addReviewers(rsrc, result, reviewers);
    return result;
}
#end_block

#method_before
private void addReviewers(ChangeResource rsrc, PostResult result, Map<Account.Id, ChangeControl> reviewers) throws RestApiException, UpdateException {
    try (BatchUpdate bu = batchUpdateFactory.create(dbProvider.get(), rsrc.getProject(), rsrc.getUser(), TimeUtil.nowTs())) {
        Change.Id id = rsrc.getChange().getId();
        bu.addOp(id, new Op(rsrc, result, reviewers));
        bu.execute();
    }
}
#method_after
private void addReviewers(ChangeResource rsrc, PostResult result, Map<Account.Id, ChangeControl> reviewers) throws OrmException, RestApiException, UpdateException {
    try (BatchUpdate bu = batchUpdateFactory.create(dbProvider.get(), rsrc.getProject(), rsrc.getUser(), TimeUtil.nowTs())) {
        Op op = new Op(rsrc, reviewers);
        Change.Id id = rsrc.getChange().getId();
        bu.addOp(id, op);
        bu.execute();
        result.reviewers = Lists.newArrayListWithCapacity(op.added.size());
        for (PatchSetApproval psa : op.added) {
            // New reviewers have value 0, don't bother normalizing.
            result.reviewers.add(json.format(new ReviewerInfo(psa.getAccountId()), reviewers.get(psa.getAccountId()), ImmutableList.of(psa)));
        }
        // We don't do this inside Op, since the accounts are in a different
        // table.
        accountLoaderFactory.create(true).fill(result.reviewers);
    }
}
#end_block

#method_before
@Override
public boolean updateChange(BatchUpdate.ChangeContext ctx) throws RestApiException, OrmException, IOException {
    added = approvalsUtil.addReviewers(ctx.getDb(), ctx.getNotes(), ctx.getUpdate(ctx.getChange().currentPatchSetId()), rsrc.getControl().getLabelTypes(), rsrc.getChange(), reviewers.keySet());
    return !added.isEmpty();
}
#method_after
@Override
public boolean updateChange(BatchUpdate.ChangeContext ctx) throws RestApiException, OrmException, IOException {
    added = approvalsUtil.addReviewers(ctx.getDb(), ctx.getNotes(), ctx.getUpdate(ctx.getChange().currentPatchSetId()), rsrc.getControl().getLabelTypes(), rsrc.getChange(), reviewers.keySet());
    if (!added.isEmpty()) {
        patchSet = psUtil.current(dbProvider.get(), rsrc.getNotes());
    }
    return !added.isEmpty();
}
#end_block

#method_before
@Override
public void postUpdate(BatchUpdate.Context ctx) throws Exception {
    result.reviewers = Lists.newArrayListWithCapacity(added.size());
    for (PatchSetApproval psa : added) {
        // New reviewers have value 0, don't bother normalizing.
        result.reviewers.add(json.format(new ReviewerInfo(psa.getAccountId()), reviewers.get(psa.getAccountId()), ImmutableList.of(psa)));
    }
    accountLoaderFactory.create(true).fill(result.reviewers);
    if (!added.isEmpty()) {
        PatchSet patchSet = psUtil.current(dbProvider.get(), rsrc.getNotes());
        for (PatchSetApproval psa : added) {
            Account account = accountCache.get(psa.getAccountId()).getAccount();
            hooks.doReviewerAddedHook(rsrc.getChange(), account, patchSet, dbProvider.get());
        }
    }
}
#method_after
@Override
public void postUpdate(BatchUpdate.Context ctx) throws Exception {
    emailReviewers(rsrc.getChange(), added);
    if (!added.isEmpty()) {
        for (PatchSetApproval psa : added) {
            Account account = accountCache.get(psa.getAccountId()).getAccount();
            hooks.doReviewerAddedHook(rsrc.getChange(), account, patchSet, dbProvider.get());
        }
    }
}
#end_block

#method_before
private void emailReviewers(Change change, List<PatchSetApproval> added) {
    if (added.isEmpty()) {
        return;
    }
    // Email the reviewers
    // 
    // The user knows they added themselves, don't bother emailing them.
    List<Account.Id> toMail = Lists.newArrayListWithCapacity(added.size());
    Account.Id userId = user.get().getAccountId();
    for (PatchSetApproval psa : added) {
        if (!psa.getAccountId().equals(userId)) {
            toMail.add(psa.getAccountId());
        }
    }
    if (!toMail.isEmpty()) {
        try {
            AddReviewerSender cm = addReviewerSenderFactory.create(change.getId());
            cm.setFrom(userId);
            cm.addReviewers(toMail);
            cm.send();
        } catch (Exception err) {
            log.error("Cannot send email to new reviewers of change " + change.getId(), err);
        }
    }
}
#method_after
private void emailReviewers(Change change, List<PatchSetApproval> added) {
    if (added.isEmpty()) {
        return;
    }
    // Email the reviewers
    // 
    // The user knows they added themselves, don't bother emailing them.
    List<Account.Id> toMail = Lists.newArrayListWithCapacity(added.size());
    Account.Id userId = user.get().getAccountId();
    for (PatchSetApproval psa : added) {
        if (!psa.getAccountId().equals(userId)) {
            toMail.add(psa.getAccountId());
        }
    }
    if (!toMail.isEmpty()) {
        try {
            AddReviewerSender cm = addReviewerSenderFactory.create(change.getProject(), change.getId());
            cm.setFrom(userId);
            cm.addReviewers(toMail);
            cm.send();
        } catch (Exception err) {
            log.error("Cannot send email to new reviewers of change " + change.getId(), err);
        }
    }
}
#end_block

#method_before
private AccountGroup createGroup(CreateGroupArgs createGroupArgs) throws OrmException, ResourceConflictException {
    // Do not allow creating groups with the same name as system groups
    Map<String, GroupReference> sysGroupNames = SystemGroupBackend.getNames();
    if (sysGroupNames.containsKey(createGroupArgs.getGroupName().toLowerCase())) {
        throw new ResourceConflictException("group '" + createGroupArgs.getGroupName() + "' already exists");
    }
    AccountGroup.Id groupId = new AccountGroup.Id(db.nextAccountGroupId());
    AccountGroup.UUID uuid = GroupUUID.make(createGroupArgs.getGroupName(), self.get().newCommitterIdent(serverIdent.getWhen(), serverIdent.getTimeZone()));
    AccountGroup group = new AccountGroup(createGroupArgs.getGroup(), groupId, uuid);
    group.setVisibleToAll(createGroupArgs.visibleToAll);
    if (createGroupArgs.ownerGroupId != null) {
        AccountGroup ownerGroup = groupCache.get(createGroupArgs.ownerGroupId);
        if (ownerGroup != null) {
            group.setOwnerGroupUUID(ownerGroup.getGroupUUID());
        }
    }
    if (createGroupArgs.groupDescription != null) {
        group.setDescription(createGroupArgs.groupDescription);
    }
    AccountGroupName gn = new AccountGroupName(group);
    // already been used to create another group
    try {
        db.accountGroupNames().insert(Collections.singleton(gn));
    } catch (OrmDuplicateKeyException e) {
        throw new ResourceConflictException("group '" + createGroupArgs.getGroupName() + "' already exists");
    }
    db.accountGroups().insert(Collections.singleton(group));
    addMembers.addMembers(groupId, createGroupArgs.initialMembers);
    groupCache.onCreateGroup(createGroupArgs.getGroup());
    return group;
}
#method_after
private AccountGroup createGroup(CreateGroupArgs createGroupArgs) throws OrmException, ResourceConflictException {
    // Do not allow creating groups with the same name as system groups
    List<String> sysGroupNames = SystemGroupBackend.getNames();
    for (String name : sysGroupNames) {
        if (name.toLowerCase(Locale.US).equals(createGroupArgs.getGroupName().toLowerCase(Locale.US))) {
            throw new ResourceConflictException("group '" + name + "' already exists");
        }
    }
    AccountGroup.Id groupId = new AccountGroup.Id(db.nextAccountGroupId());
    AccountGroup.UUID uuid = GroupUUID.make(createGroupArgs.getGroupName(), self.get().newCommitterIdent(serverIdent.getWhen(), serverIdent.getTimeZone()));
    AccountGroup group = new AccountGroup(createGroupArgs.getGroup(), groupId, uuid);
    group.setVisibleToAll(createGroupArgs.visibleToAll);
    if (createGroupArgs.ownerGroupId != null) {
        AccountGroup ownerGroup = groupCache.get(createGroupArgs.ownerGroupId);
        if (ownerGroup != null) {
            group.setOwnerGroupUUID(ownerGroup.getGroupUUID());
        }
    }
    if (createGroupArgs.groupDescription != null) {
        group.setDescription(createGroupArgs.groupDescription);
    }
    AccountGroupName gn = new AccountGroupName(group);
    // already been used to create another group
    try {
        db.accountGroupNames().insert(Collections.singleton(gn));
    } catch (OrmDuplicateKeyException e) {
        throw new ResourceConflictException("group '" + createGroupArgs.getGroupName() + "' already exists");
    }
    db.accountGroups().insert(Collections.singleton(group));
    addMembers.addMembers(groupId, createGroupArgs.initialMembers);
    groupCache.onCreateGroup(createGroupArgs.getGroup());
    return group;
}
#end_block

#method_before
public static boolean isSystemGroup(AccountGroup.UUID uuid) {
    return uuid.get().startsWith("global:");
}
#method_after
public static boolean isSystemGroup(AccountGroup.UUID uuid) {
    return uuid.get().startsWith(SYSTEM_GROUP_SCHEME);
}
#end_block

#method_before
public static Map<String, GroupReference> getNames() {
    return names;
}
#method_after
public static List<String> getNames() {
    List<String> names = new ArrayList<>();
    for (AccountGroup.UUID uuid : all) {
        int c = uuid.get().indexOf(':');
        names.add(uuid.get().substring(c + 1).replace('-', ' '));
    }
    return names;
}
#end_block

#method_before
private List<SubmitRecord> submitRecords(ChangeData cd) throws OrmException {
    if (cd.getSubmitRecords() != null) {
        return cd.getSubmitRecords();
    }
    cd.setSubmitRecords(new SubmitRuleEvaluator(cd).setFastEvalLabels(true).setAllowDraft(true).evaluate());
    return cd.getSubmitRecords();
}
#method_after
private List<SubmitRecord> submitRecords(ChangeData cd) throws OrmException {
    // TODO(dborowitz): Handle this better at the ChangeData level.
    if (submitRecords == null) {
        submitRecords = new HashMap<>();
    }
    List<SubmitRecord> records = submitRecords.get(cd.getId());
    if (records == null) {
        records = new SubmitRuleEvaluator(cd).setFastEvalLabels(true).setAllowDraft(true).evaluate();
        submitRecords.put(cd.getId(), records);
    }
    return records;
}
#end_block

#method_before
private Map<String, LabelWithStatus> initLabels(ChangeData cd, LabelTypes labelTypes, boolean standard) throws OrmException {
    // Don't use Maps.newTreeMap(Comparator) due to OpenJDK bug 100167.
    Map<String, LabelWithStatus> labels = new TreeMap<>(labelTypes.nameComparator());
    for (SubmitRecord rec : submitRecords(cd)) {
        if (rec.labels == null) {
            continue;
        }
        for (SubmitRecord.Label r : rec.labels) {
            LabelWithStatus p = labels.get(r.label);
            if (p == null || p.status().compareTo(r.status) < 0) {
                LabelInfo n = new LabelInfo();
                if (standard) {
                    switch(r.status) {
                        case OK:
                            n.approved = accountLoader.get(r.appliedBy);
                            break;
                        case REJECT:
                            n.rejected = accountLoader.get(r.appliedBy);
                            n.blocking = true;
                            break;
                        default:
                            break;
                    }
                }
                n.optional = r.status == SubmitRecord.Label.Status.MAY ? true : null;
                labels.put(r.label, LabelWithStatus.create(n, r.status));
            }
        }
    }
    return labels;
}
#method_after
private Map<String, LabelWithStatus> initLabels(ChangeData cd, LabelTypes labelTypes, boolean standard) throws OrmException {
    // Don't use Maps.newTreeMap(Comparator) due to OpenJDK bug 100167.
    Map<String, LabelWithStatus> labels = new TreeMap<>(labelTypes.nameComparator());
    for (SubmitRecord rec : submitRecords(cd)) {
        if (rec.labels == null) {
            continue;
        }
        for (SubmitRecord.Label r : rec.labels) {
            LabelWithStatus p = labels.get(r.label);
            if (p == null || p.status().compareTo(r.status) < 0) {
                LabelInfo n = new LabelInfo();
                if (standard) {
                    switch(r.status) {
                        case OK:
                            n.approved = accountLoader.get(r.appliedBy);
                            break;
                        case REJECT:
                            n.rejected = accountLoader.get(r.appliedBy);
                            n.blocking = true;
                            break;
                        case IMPOSSIBLE:
                        case MAY:
                        case NEED:
                        default:
                            break;
                    }
                }
                n.optional = r.status == SubmitRecord.Label.Status.MAY ? true : null;
                labels.put(r.label, LabelWithStatus.create(n, r.status));
            }
        }
    }
    return labels;
}
#end_block

#method_before
private Timestamp getSubmittedOn(ChangeData cd) throws OrmException {
    for (PatchSetApproval psa : cd.approvals().values()) {
        if (psa.getLabelId().equals(LabelId.SUBMIT)) {
            return psa.getGranted();
        }
    }
    return null;
}
#method_after
private Timestamp getSubmittedOn(ChangeData cd) throws OrmException {
    Optional<PatchSetApproval> s = cd.getSubmitApproval();
    return s.isPresent() ? s.get().getGranted() : null;
}
#end_block

#method_before
CommitInfo toCommit(ChangeControl ctl, RevWalk rw, RevCommit commit, boolean addLinks) throws IOException {
    Project.NameKey project = ctl.getChange().getProject();
    CommitInfo info = new CommitInfo();
    info.parents = new ArrayList<>(commit.getParentCount());
    info.author = toGitPerson(commit.getAuthorIdent());
    info.committer = toGitPerson(commit.getCommitterIdent());
    info.subject = commit.getShortMessage();
    info.message = commit.getFullMessage();
    if (addLinks) {
        FluentIterable<WebLinkInfo> links = webLinks.getPatchSetLinks(project, commit.name());
        info.webLinks = links.isEmpty() ? null : links.toList();
    }
    for (RevCommit parent : commit.getParents()) {
        rw.parseBody(parent);
        CommitInfo i = new CommitInfo();
        i.commit = parent.name();
        i.subject = parent.getShortMessage();
        if (addLinks) {
            FluentIterable<WebLinkInfo> parentLinks = webLinks.getPatchSetLinks(project, parent.name());
            i.webLinks = parentLinks.isEmpty() ? null : parentLinks.toList();
        }
        info.parents.add(i);
    }
    return info;
}
#method_after
CommitInfo toCommit(ChangeControl ctl, RevWalk rw, RevCommit commit, boolean addLinks) throws IOException {
    Project.NameKey project = ctl.getProject().getNameKey();
    CommitInfo info = new CommitInfo();
    info.parents = new ArrayList<>(commit.getParentCount());
    info.author = toGitPerson(commit.getAuthorIdent());
    info.committer = toGitPerson(commit.getCommitterIdent());
    info.subject = commit.getShortMessage();
    info.message = commit.getFullMessage();
    if (addLinks) {
        FluentIterable<WebLinkInfo> links = webLinks.getPatchSetLinks(project, commit.name());
        info.webLinks = links.isEmpty() ? null : links.toList();
    }
    for (RevCommit parent : commit.getParents()) {
        rw.parseBody(parent);
        CommitInfo i = new CommitInfo();
        i.commit = parent.name();
        i.subject = parent.getShortMessage();
        if (addLinks) {
            FluentIterable<WebLinkInfo> parentLinks = webLinks.getPatchSetLinks(project, parent.name());
            i.webLinks = parentLinks.isEmpty() ? null : parentLinks.toList();
        }
        info.parents.add(i);
    }
    return info;
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    CallbackGroup group = new CallbackGroup();
    if (Gerrit.isSignedIn()) {
        ChangeApi.editWithFiles(changeId.get(), group.add(new AsyncCallback<EditInfo>() {

            @Override
            public void onSuccess(EditInfo result) {
                edit = result;
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        }));
    }
    loadChangeInfo(true, group.addFinal(new GerritCallback<ChangeInfo>() {

        @Override
        public void onSuccess(ChangeInfo info) {
            info.init();
            loadConfigInfo(info, base);
        }
    }));
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    CallbackGroup group = new CallbackGroup();
    if (Gerrit.isSignedIn()) {
        ChangeList.query("change:" + changeId.get() + " has:draft", Collections.<ListChangesOption>emptySet(), group.add(new AsyncCallback<ChangeList>() {

            @Override
            public void onSuccess(ChangeList result) {
                hasDraftComments = result.length() > 0;
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        }));
        ChangeApi.editWithFiles(changeId.get(), group.add(new AsyncCallback<EditInfo>() {

            @Override
            public void onSuccess(EditInfo result) {
                edit = result;
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        }));
    }
    loadChangeInfo(true, group.addFinal(new GerritCallback<ChangeInfo>() {

        @Override
        public void onSuccess(ChangeInfo info) {
            info.init();
            addExtensionPoints(info);
            loadConfigInfo(info, base);
        }
    }));
}
#end_block

#method_before
void loadChangeInfo(boolean fg, AsyncCallback<ChangeInfo> cb) {
    RestApi call = ChangeApi.detail(changeId.get());
    ChangeList.addOptions(call, EnumSet.of(ListChangesOption.CHANGE_ACTIONS, ListChangesOption.ALL_REVISIONS));
    if (!fg) {
        call.background();
    }
    call.get(cb);
}
#method_after
void loadChangeInfo(boolean fg, AsyncCallback<ChangeInfo> cb) {
    RestApi call = ChangeApi.detail(changeId.get());
    EnumSet<ListChangesOption> opts = EnumSet.of(ListChangesOption.ALL_REVISIONS, ListChangesOption.CHANGE_ACTIONS);
    if (enableSignedPush()) {
        opts.add(ListChangesOption.PUSH_CERTIFICATES);
    }
    ChangeList.addOptions(call, opts);
    if (!fg) {
        call.background();
    }
    call.get(cb);
}
#end_block

#method_before
private void initReplyButton(ChangeInfo info, String revision) {
    if (!info.revision(revision).is_edit()) {
        reply.setTitle(Gerrit.getConfig().getReplyTitle());
        reply.setHTML(new SafeHtmlBuilder().openDiv().append(Gerrit.getConfig().getReplyLabel()).closeDiv());
        reply.setVisible(true);
    }
}
#method_after
private void initReplyButton(ChangeInfo info, String revision) {
    if (!info.revision(revision).isEdit()) {
        reply.setTitle(Gerrit.info().change().replyLabel());
        reply.setHTML(new SafeHtmlBuilder().openDiv().append(Gerrit.info().change().replyLabel()).closeDiv());
        if (hasDraftComments) {
            reply.setStyleName(style.highlight());
        }
        reply.setVisible(true);
    }
}
#end_block

#method_before
private void gotoSibling(final int offset) {
    if (offset > 0 && changeInfo.current_revision().equals(revision)) {
        return;
    }
    if (offset < 0 && changeInfo.revision(revision)._number() == 1) {
        return;
    }
    JsArray<RevisionInfo> revisions = changeInfo.revisions().values();
    RevisionInfo.sortRevisionInfoByNumber(revisions);
    for (int i = 0; i < revisions.length(); i++) {
        if (revision.equals(revisions.get(i).name())) {
            if (0 <= i + offset && i + offset < revisions.length()) {
                Gerrit.display(PageLinks.toChange(new PatchSet.Id(changeInfo.legacy_id(), revisions.get(i + offset)._number())));
                return;
            }
            return;
        }
    }
}
#method_after
private void gotoSibling(final int offset) {
    if (offset > 0 && changeInfo.currentRevision().equals(revision)) {
        return;
    }
    if (offset < 0 && changeInfo.revision(revision)._number() == 1) {
        return;
    }
    JsArray<RevisionInfo> revisions = changeInfo.revisions().values();
    RevisionInfo.sortRevisionInfoByNumber(revisions);
    for (int i = 0; i < revisions.length(); i++) {
        if (revision.equals(revisions.get(i).name())) {
            if (0 <= i + offset && i + offset < revisions.length()) {
                Gerrit.display(PageLinks.toChange(new PatchSet.Id(changeInfo.legacyId(), revisions.get(i + offset)._number())));
                return;
            }
            return;
        }
    }
}
#end_block

#method_before
private void initIncludedInAction(ChangeInfo info) {
    if (info.status() == Status.MERGED) {
        includedInAction = new IncludedInAction(info.legacy_id(), style, headerLine, includedIn);
        includedIn.setVisible(true);
    }
}
#method_after
private void initIncludedInAction(ChangeInfo info) {
    if (info.status() == Status.MERGED) {
        includedInAction = new IncludedInAction(info.legacyId(), style, headerLine, includedIn);
        includedIn.setVisible(true);
    }
}
#end_block

#method_before
private void initChangeAction(ChangeInfo info) {
    if (info.status() == Status.DRAFT) {
        NativeMap<ActionInfo> actions = info.has_actions() ? info.actions() : NativeMap.<ActionInfo>create();
        actions.copyKeysIntoChildren("id");
        if (actions.containsKey("/")) {
            deleteChange.setVisible(true);
            deleteChange.setTitle(actions.get("/").title());
        }
    }
}
#method_after
private void initChangeAction(ChangeInfo info) {
    if (info.status() == Status.DRAFT) {
        NativeMap<ActionInfo> actions = info.hasActions() ? info.actions() : NativeMap.<ActionInfo>create();
        actions.copyKeysIntoChildren("id");
        if (actions.containsKey("/")) {
            deleteChange.setVisible(true);
            deleteChange.setTitle(actions.get("/").title());
        }
    }
}
#end_block

#method_before
private void initRevisionsAction(ChangeInfo info, String revision, NativeMap<ActionInfo> actions) {
    int currentPatchSet;
    if (info.current_revision() != null && info.revisions().containsKey(info.current_revision())) {
        currentPatchSet = info.revision(info.current_revision())._number();
    } else {
        JsArray<RevisionInfo> revList = info.revisions().values();
        RevisionInfo.sortRevisionInfoByNumber(revList);
        currentPatchSet = revList.get(revList.length() - 1)._number();
    }
    String currentlyViewedPatchSet;
    boolean isPatchSetCurrent = true;
    final String revisionId = info.revision(revision).id();
    if (revisionId.equals("edit")) {
        currentlyViewedPatchSet = Resources.M.editPatchSet(RevisionInfo.findEditParent(info.revisions().values()));
        currentPatchSet = info.revisions().values().length() - 1;
    } else {
        currentlyViewedPatchSet = revisionId;
        if (currentlyViewedPatchSet != Integer.toString(currentPatchSet)) {
            isPatchSetCurrent = false;
        }
    }
    patchSetsText.setInnerText(Resources.M.patchSets(currentlyViewedPatchSet, currentPatchSet));
    if (isPatchSetCurrent) {
        patchSetsText.removeClassName(style.notCurrentPatchSet());
    } else {
        patchSetsText.addClassName(style.notCurrentPatchSet());
    }
    patchSetsAction = new PatchSetsAction(info.legacy_id(), revision, style, headerLine, patchSets);
    RevisionInfo revInfo = info.revision(revision);
    if (revInfo.draft()) {
        if (actions.containsKey("publish")) {
            publish.setVisible(true);
            publish.setTitle(actions.get("publish").title());
        }
        if (actions.containsKey("/")) {
            deleteRevision.setVisible(true);
            deleteRevision.setTitle(actions.get("/").title());
        }
    }
}
#method_after
private void initRevisionsAction(ChangeInfo info, String revision, NativeMap<ActionInfo> actions) {
    int currentPatchSet;
    if (info.currentRevision() != null && info.revisions().containsKey(info.currentRevision())) {
        currentPatchSet = info.revision(info.currentRevision())._number();
    } else {
        JsArray<RevisionInfo> revList = info.revisions().values();
        RevisionInfo.sortRevisionInfoByNumber(revList);
        currentPatchSet = revList.get(revList.length() - 1)._number();
    }
    String currentlyViewedPatchSet;
    boolean isPatchSetCurrent = true;
    String revisionId = info.revision(revision).id();
    if (revisionId.equals("edit")) {
        currentlyViewedPatchSet = Resources.M.editPatchSet(RevisionInfo.findEditParent(info.revisions().values()));
        currentPatchSet = info.revisions().values().length() - 1;
    } else {
        currentlyViewedPatchSet = revisionId;
        if (!currentlyViewedPatchSet.equals(Integer.toString(currentPatchSet))) {
            isPatchSetCurrent = false;
        }
    }
    patchSetsText.setInnerText(Resources.M.patchSets(currentlyViewedPatchSet, currentPatchSet));
    updatePatchSetsTextStyle(isPatchSetCurrent);
    patchSetsAction = new PatchSetsAction(info.legacyId(), revision, edit, style, headerLine, patchSets);
    RevisionInfo revInfo = info.revision(revision);
    if (revInfo.draft()) {
        if (actions.containsKey("publish")) {
            publish.setVisible(true);
            publish.setTitle(actions.get("publish").title());
        }
        if (actions.containsKey("/")) {
            deleteRevision.setVisible(true);
            deleteRevision.setTitle(actions.get("/").title());
        }
    }
}
#end_block

#method_before
private void initProjectLinks(final ChangeInfo info) {
    projectSettingsLink.setHref("#" + PageLinks.toProject(info.project_name_key()));
    projectSettings.addDomHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            if (Hyperlink.impl.handleAsClick((Event) event.getNativeEvent())) {
                event.stopPropagation();
                event.preventDefault();
                Gerrit.display(PageLinks.toProject(info.project_name_key()));
            }
        }
    }, ClickEvent.getType());
    projectDashboard.setText(info.project());
    projectDashboard.setTargetHistoryToken(PageLinks.toProjectDefaultDashboard(info.project_name_key()));
}
#method_after
private void initProjectLinks(final ChangeInfo info) {
    projectSettingsLink.setHref("#" + PageLinks.toProject(info.projectNameKey()));
    projectSettings.addDomHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            if (Hyperlink.impl.handleAsClick((Event) event.getNativeEvent())) {
                event.stopPropagation();
                event.preventDefault();
                Gerrit.display(PageLinks.toProject(info.projectNameKey()));
            }
        }
    }, ClickEvent.getType());
    projectDashboard.setText(info.project());
    projectDashboard.setTargetHistoryToken(PageLinks.toProjectDefaultDashboard(info.projectNameKey()));
}
#end_block

#method_before
private void initBranchLink(ChangeInfo info) {
    branchLink.setText(info.branch());
    branchLink.setTargetHistoryToken(PageLinks.toChangeQuery(BranchLink.query(info.project_name_key(), info.status(), info.branch(), null)));
}
#method_after
private void initBranchLink(ChangeInfo info) {
    branchLink.setText(info.branch());
    branchLink.setTargetHistoryToken(PageLinks.toChangeQuery(BranchLink.query(info.projectNameKey(), info.status(), info.branch(), null)));
}
#end_block

#method_before
private void initEditMode(ChangeInfo info, String revision) {
    if (Gerrit.isSignedIn() && info.status().isOpen()) {
        RevisionInfo rev = info.revision(revision);
        if (isEditModeEnabled(info, rev)) {
            editMode.setVisible(fileTableMode == FileTable.Mode.REVIEW);
            addFile.setVisible(!editMode.isVisible());
            deleteFile.setVisible(!editMode.isVisible());
            renameFile.setVisible(!editMode.isVisible());
            reviewMode.setVisible(!editMode.isVisible());
            addFileAction = new AddFileAction(changeId, info.revision(revision), style, addFile);
            deleteFileAction = new DeleteFileAction(changeId, info.revision(revision), style, addFile);
            renameFileAction = new RenameFileAction(changeId, info.revision(revision), style, addFile);
        } else {
            editMode.setVisible(false);
            addFile.setVisible(false);
            reviewMode.setVisible(false);
        }
        if (rev.is_edit()) {
            if (info.hasEditBasedOnCurrentPatchSet()) {
                publishEdit.setVisible(true);
            } else {
                rebaseEdit.setVisible(true);
            }
            deleteEdit.setVisible(true);
        }
    }
}
#method_after
private void initEditMode(ChangeInfo info, String revision) {
    if (Gerrit.isSignedIn() && info.status().isOpen()) {
        RevisionInfo rev = info.revision(revision);
        if (isEditModeEnabled(info, rev)) {
            editMode.setVisible(fileTableMode == FileTable.Mode.REVIEW);
            addFile.setVisible(!editMode.isVisible());
            deleteFile.setVisible(!editMode.isVisible());
            renameFile.setVisible(!editMode.isVisible());
            reviewMode.setVisible(!editMode.isVisible());
            addFileAction = new AddFileAction(changeId, info.revision(revision), style, addFile, files);
            deleteFileAction = new DeleteFileAction(changeId, info.revision(revision), style, addFile);
            renameFileAction = new RenameFileAction(changeId, info.revision(revision), style, addFile);
        } else {
            editMode.setVisible(false);
            addFile.setVisible(false);
            reviewMode.setVisible(false);
        }
        if (rev.isEdit()) {
            if (info.hasEditBasedOnCurrentPatchSet()) {
                publishEdit.setVisible(true);
            } else {
                rebaseEdit.setVisible(true);
            }
            deleteEdit.setVisible(true);
        }
    }
}
#end_block

#method_before
private boolean isEditModeEnabled(ChangeInfo info, RevisionInfo rev) {
    if (rev.is_edit()) {
        return true;
    }
    if (edit == null) {
        return revision.equals(info.current_revision());
    }
    return rev._number() == RevisionInfo.findEditParent(info.revisions().values());
}
#method_after
private boolean isEditModeEnabled(ChangeInfo info, RevisionInfo rev) {
    if (rev.isEdit()) {
        return true;
    }
    if (edit == null) {
        return revision.equals(info.currentRevision());
    }
    return rev._number() == RevisionInfo.findEditParent(info.revisions().values());
}
#end_block

#method_before
private void loadConfigInfo(final ChangeInfo info, final String base) {
    info.revisions().copyKeysIntoChildren("name");
    if (edit != null) {
        edit.set_name(edit.commit().commit());
        info.set_edit(edit);
        if (edit.has_files()) {
            edit.files().copyKeysIntoChildren("path");
        }
        info.revisions().put(edit.name(), RevisionInfo.fromEdit(edit));
        JsArray<RevisionInfo> list = info.revisions().values();
        // use the edit regardless of which patch set it is based on
        if (revision == null) {
            RevisionInfo.sortRevisionInfoByNumber(list);
            RevisionInfo rev = list.get(list.length() - 1);
            if (rev.is_edit()) {
                info.set_current_revision(rev.name());
            }
        } else if (revision.equals("edit") || revision.equals("0")) {
            for (int i = 0; i < list.length(); i++) {
                RevisionInfo r = list.get(i);
                if (r.is_edit()) {
                    info.set_current_revision(r.name());
                    break;
                }
            }
        }
    }
    final RevisionInfo rev = resolveRevisionToDisplay(info);
    final RevisionInfo b = resolveRevisionOrPatchSetId(info, base, null);
    CallbackGroup group = new CallbackGroup();
    Timestamp lastReply = myLastReply(info);
    if (rev.is_edit()) {
        loadFileList(b, rev, lastReply, group, null, null);
    } else {
        loadDiff(b, rev, lastReply, group);
    }
    loadCommit(rev, group);
    if (loaded) {
        group.done();
        return;
    }
    RevisionInfoCache.add(changeId, rev);
    ConfigInfoCache.add(info);
    ConfigInfoCache.get(info.project_name_key(), group.addFinal(new ScreenLoadCallback<ConfigInfoCache.Entry>(this) {

        @Override
        protected void preDisplay(Entry result) {
            loaded = true;
            commentLinkProcessor = result.getCommentLinkProcessor();
            setTheme(result.getTheme());
            renderChangeInfo(info);
            loadRevisionInfo();
        }
    }));
}
#method_after
private void loadConfigInfo(final ChangeInfo info, final String base) {
    info.revisions().copyKeysIntoChildren("name");
    if (edit != null) {
        edit.setName(edit.commit().commit());
        info.setEdit(edit);
        if (edit.hasFiles()) {
            edit.files().copyKeysIntoChildren("path");
        }
        info.revisions().put(edit.name(), RevisionInfo.fromEdit(edit));
        JsArray<RevisionInfo> list = info.revisions().values();
        // use the edit regardless of which patch set it is based on
        if (revision == null) {
            RevisionInfo.sortRevisionInfoByNumber(list);
            RevisionInfo rev = list.get(list.length() - 1);
            if (rev.isEdit()) {
                info.setCurrentRevision(rev.name());
            }
        } else if (revision.equals("edit") || revision.equals("0")) {
            for (int i = 0; i < list.length(); i++) {
                RevisionInfo r = list.get(i);
                if (r.isEdit()) {
                    info.setCurrentRevision(r.name());
                    break;
                }
            }
        }
    }
    final RevisionInfo rev = resolveRevisionToDisplay(info);
    final RevisionInfo b = resolveRevisionOrPatchSetId(info, base, null);
    CallbackGroup group = new CallbackGroup();
    Timestamp lastReply = myLastReply(info);
    if (rev.isEdit()) {
        loadFileList(b, rev, lastReply, group, null, null);
    } else {
        loadDiff(b, rev, lastReply, group);
    }
    loadCommit(rev, group);
    if (loaded) {
        group.done();
        return;
    }
    RevisionInfoCache.add(changeId, rev);
    ConfigInfoCache.add(info);
    ConfigInfoCache.get(info.projectNameKey(), group.addFinal(new ScreenLoadCallback<ConfigInfoCache.Entry>(this) {

        @Override
        protected void preDisplay(Entry result) {
            loaded = true;
            commentLinkProcessor = result.getCommentLinkProcessor();
            setTheme(result.getTheme());
            renderChangeInfo(info);
            loadRevisionInfo();
        }
    }));
}
#end_block

#method_before
static Timestamp myLastReply(ChangeInfo info) {
    if (Gerrit.isSignedIn() && info.messages() != null) {
        int self = Gerrit.getUserAccountInfo()._account_id();
        for (int i = info.messages().length() - 1; i >= 0; i--) {
            MessageInfo m = info.messages().get(i);
            if (m.author() != null && m.author()._account_id() == self) {
                return m.date();
            }
        }
    }
    return null;
}
#method_after
static Timestamp myLastReply(ChangeInfo info) {
    if (Gerrit.isSignedIn() && info.messages() != null) {
        int self = Gerrit.getUserAccount()._accountId();
        for (int i = info.messages().length() - 1; i >= 0; i--) {
            MessageInfo m = info.messages().get(i);
            if (m.author() != null && m.author()._accountId() == self) {
                return m.date();
            }
        }
    }
    return null;
}
#end_block

#method_before
private List<NativeMap<JsArray<CommentInfo>>> loadComments(RevisionInfo rev, CallbackGroup group) {
    final int id = rev._number();
    final List<NativeMap<JsArray<CommentInfo>>> r = new ArrayList<>(1);
    ChangeApi.revision(changeId.get(), rev.name()).view("comments").get(group.add(new AsyncCallback<NativeMap<JsArray<CommentInfo>>>() {

        @Override
        public void onSuccess(NativeMap<JsArray<CommentInfo>> result) {
            r.add(result);
            history.addComments(id, result);
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
    return r;
}
#method_after
private List<NativeMap<JsArray<CommentInfo>>> loadComments(final RevisionInfo rev, CallbackGroup group) {
    final List<NativeMap<JsArray<CommentInfo>>> r = new ArrayList<>(1);
    // TODO(dborowitz): Could eliminate this call by adding an option to include
    // inline comments in the change detail.
    ChangeApi.comments(changeId.get()).get(group.add(new AsyncCallback<NativeMap<JsArray<CommentInfo>>>() {

        @Override
        public void onSuccess(NativeMap<JsArray<CommentInfo>> result) {
            // Return value is used for populating the file table, so only count
            // comments for the current revision. Still include all comments in
            // the history table.
            r.add(filterForRevision(result, rev._number()));
            history.addComments(result);
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
    return r;
}
#end_block

#method_before
private void loadCommit(final RevisionInfo rev, CallbackGroup group) {
    if (rev.is_edit()) {
        return;
    }
    ChangeApi.commitWithLinks(changeId.get(), rev.name(), group.add(new AsyncCallback<CommitInfo>() {

        @Override
        public void onSuccess(CommitInfo info) {
            rev.set_commit(info);
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
}
#method_after
private void loadCommit(final RevisionInfo rev, CallbackGroup group) {
    if (rev.isEdit()) {
        return;
    }
    ChangeApi.commitWithLinks(changeId.get(), rev.name(), group.add(new AsyncCallback<CommitInfo>() {

        @Override
        public void onSuccess(CommitInfo info) {
            rev.setCommit(info);
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
}
#end_block

#method_before
private RevisionInfo resolveRevisionToDisplay(ChangeInfo info) {
    RevisionInfo rev = resolveRevisionOrPatchSetId(info, revision, info.current_revision());
    if (rev != null) {
        revision = rev.name();
        return rev;
    }
    // the revision is not visible to the calling user (maybe it is a draft?)
    // or the change is corrupt, take the last revision that was returned,
    // if no revision was returned display an error
    JsArray<RevisionInfo> revisions = info.revisions().values();
    if (revisions.length() > 0) {
        RevisionInfo.sortRevisionInfoByNumber(revisions);
        rev = revisions.get(revisions.length() - 1);
        revision = rev.name();
        return rev;
    } else {
        new ErrorDialog(Resources.M.changeWithNoRevisions(info.legacy_id().get())).center();
        throw new IllegalStateException("no revision, cannot proceed");
    }
}
#method_after
private RevisionInfo resolveRevisionToDisplay(ChangeInfo info) {
    RevisionInfo rev = resolveRevisionOrPatchSetId(info, revision, info.currentRevision());
    if (rev != null) {
        revision = rev.name();
        return rev;
    }
    // the revision is not visible to the calling user (maybe it is a draft?)
    // or the change is corrupt, take the last revision that was returned,
    // if no revision was returned display an error
    JsArray<RevisionInfo> revisions = info.revisions().values();
    if (revisions.length() > 0) {
        RevisionInfo.sortRevisionInfoByNumber(revisions);
        rev = revisions.get(revisions.length() - 1);
        revision = rev.name();
        return rev;
    } else {
        new ErrorDialog(Resources.M.changeWithNoRevisions(info.legacyId().get())).center();
        throw new IllegalStateException("no revision, cannot proceed");
    }
}
#end_block

#method_before
private boolean isSubmittable(ChangeInfo info) {
    boolean canSubmit = info.status().isOpen();
    if (canSubmit && info.status() == Change.Status.NEW) {
        for (String name : info.labels()) {
            LabelInfo label = info.label(name);
            switch(label.status()) {
                case NEED:
                    statusText.setInnerText("Needs " + name);
                    canSubmit = false;
                    break;
                case REJECT:
                case IMPOSSIBLE:
                    if (label.blocking()) {
                        statusText.setInnerText("Not " + name);
                        canSubmit = false;
                    }
                    break;
                default:
                    break;
            }
        }
    }
    return canSubmit;
}
#method_after
private boolean isSubmittable(ChangeInfo info) {
    boolean canSubmit = info.status().isOpen() && revision.equals(info.currentRevision()) && !info.revision(revision).draft();
    if (canSubmit && info.status() == Change.Status.NEW) {
        for (String name : info.labels()) {
            LabelInfo label = info.label(name);
            switch(label.status()) {
                case NEED:
                    statusText.setInnerText("Needs " + name);
                    canSubmit = false;
                    break;
                case REJECT:
                case IMPOSSIBLE:
                    if (label.blocking()) {
                        statusText.setInnerText("Not " + name);
                        canSubmit = false;
                    }
                    break;
                default:
                    break;
            }
        }
    }
    return canSubmit;
}
#end_block

#method_before
private void renderChangeInfo(ChangeInfo info) {
    changeInfo = info;
    lastDisplayedUpdate = info.updated();
    labels.set(info);
    renderOwner(info);
    renderActionTextDate(info);
    renderDiffBaseListBox(info);
    initReplyButton(info, revision);
    initIncludedInAction(info);
    initChangeAction(info);
    initDownloadAction(info, revision);
    initProjectLinks(info);
    initBranchLink(info);
    initEditMode(info, revision);
    actions.display(info, revision);
    star.setValue(info.starred());
    permalink.setHref(ChangeLink.permalink(changeId));
    permalink.setText(String.valueOf(info.legacy_id()));
    topic.set(info, revision);
    commit.set(commentLinkProcessor, info, revision);
    related.set(info, revision);
    reviewers.set(info);
    if (Gerrit.isNoteDbEnabled()) {
        hashtags.set(info);
    } else {
        setVisible(hashtagTableRow, false);
    }
    StringBuilder sb = new StringBuilder();
    sb.append(Util.M.changeScreenTitleId(info.id_abbreviated()));
    if (info.subject() != null) {
        sb.append(": ");
        sb.append(info.subject());
    }
    setWindowTitle(sb.toString());
    // render it faster.
    if (!info.status().isOpen() || !revision.equals(info.current_revision()) || info.revision(revision).is_edit()) {
        setVisible(strategy, false);
    }
    // Properly render revision actions initially while waiting for
    // the callback to populate them correctly.
    NativeMap<ActionInfo> emptyMap = NativeMap.<ActionInfo>create();
    initRevisionsAction(info, revision, emptyMap);
    quickApprove.setVisible(false);
    actions.reloadRevisionActions(emptyMap);
}
#method_after
private void renderChangeInfo(ChangeInfo info) {
    RevisionInfo revisionInfo = info.revision(revision);
    changeInfo = info;
    lastDisplayedUpdate = info.updated();
    labels.set(info);
    renderOwner(info);
    renderUploader(info, revisionInfo);
    renderActionTextDate(info);
    renderDiffBaseListBox(info);
    initReplyButton(info, revision);
    initIncludedInAction(info);
    initChangeAction(info);
    initDownloadAction(info, revision);
    initProjectLinks(info);
    initBranchLink(info);
    initEditMode(info, revision);
    actions.display(info, revision);
    star.setValue(info.starred());
    permalink.setHref(ChangeLink.permalink(changeId));
    permalink.setText(String.valueOf(info.legacyId()));
    topic.set(info, revision);
    commit.set(commentLinkProcessor, info, revision);
    related.set(info, revision);
    reviewers.set(info);
    if (Gerrit.isNoteDbEnabled()) {
        hashtags.set(info);
    } else {
        setVisible(hashtagTableRow, false);
    }
    StringBuilder sb = new StringBuilder();
    sb.append(Util.M.changeScreenTitleId(info.idAbbreviated()));
    if (info.subject() != null) {
        sb.append(": ");
        sb.append(info.subject());
    }
    setWindowTitle(sb.toString());
    // render it faster.
    if (!info.status().isOpen() || !revision.equals(info.currentRevision()) || revisionInfo.isEdit()) {
        setVisible(strategy, false);
    }
    // Properly render revision actions initially while waiting for
    // the callback to populate them correctly.
    NativeMap<ActionInfo> emptyMap = NativeMap.<ActionInfo>create();
    initRevisionsAction(info, revision, emptyMap);
    quickApprove.setVisible(false);
    actions.reloadRevisionActions(emptyMap);
    boolean current = revision.equals(info.currentRevision()) && !revisionInfo.isEdit();
    if (revisionInfo.isEdit()) {
        statusText.setInnerText(Util.C.changeEdit());
    } else if (!current) {
        statusText.setInnerText(Util.C.notCurrent());
        labels.setVisible(false);
    } else {
        Status s = info.revision(revision).draft() ? Status.DRAFT : info.status();
        statusText.setInnerText(Util.toLongString(s));
    }
    if (Gerrit.isSignedIn()) {
        replyAction = new ReplyAction(info, revision, hasDraftComments, style, commentLinkProcessor, reply, quickApprove);
    }
    history.set(commentLinkProcessor, replyAction, changeId, info);
    if (current && info.status().isOpen()) {
        quickApprove.set(info, revision, replyAction);
        loadSubmitType(info.status(), isSubmittable(info));
    } else {
        quickApprove.setVisible(false);
    }
}
#end_block

#method_before
private void renderRevisionInfo(ChangeInfo info, NativeMap<ActionInfo> actionMap) {
    RevisionInfo revisionInfo = info.revision(revision);
    boolean current = info.status().isOpen() && revision.equals(info.current_revision()) && !revisionInfo.is_edit();
    if (revisionInfo.is_edit()) {
        statusText.setInnerText(Util.C.changeEdit());
    } else if (!current && info.status() == Change.Status.NEW) {
        statusText.setInnerText(Util.C.notCurrent());
        labels.setVisible(false);
    } else {
        statusText.setInnerText(Util.toLongString(info.status()));
    }
    initRevisionsAction(info, revision, actionMap);
    if (Gerrit.isSignedIn()) {
        replyAction = new ReplyAction(info, revision, style, commentLinkProcessor, reply, quickApprove);
    }
    history.set(commentLinkProcessor, replyAction, changeId, info);
    if (current) {
        quickApprove.set(info, revision, replyAction);
        loadSubmitType(info.status(), isSubmittable(info));
    } else {
        quickApprove.setVisible(false);
    }
    actions.reloadRevisionActions(actionMap);
}
#method_after
private void renderRevisionInfo(ChangeInfo info, NativeMap<ActionInfo> actionMap) {
    initRevisionsAction(info, revision, actionMap);
    commit.setParentNotCurrent(actionMap.containsKey("rebase") && actionMap.get("rebase").enabled());
    actions.reloadRevisionActions(actionMap);
}
#end_block

#method_before
private void renderOwner(ChangeInfo info) {
    // TODO info card hover
    String name = info.owner().name() != null ? info.owner().name() : Gerrit.getConfig().getAnonymousCowardName();
    if (info.owner().avatar(AvatarInfo.DEFAULT_SIZE) != null) {
        ownerPanel.insert(new AvatarImage(info.owner()), 0);
    }
    ownerLink.setText(name);
    ownerLink.setTitle(info.owner().email() != null ? info.owner().email() : name);
    ownerLink.setTargetHistoryToken(PageLinks.toAccountQuery(info.owner().name() != null ? info.owner().name() : info.owner().email() != null ? info.owner().email() : String.valueOf(info.owner()._account_id()), Change.Status.NEW));
}
#method_after
private void renderOwner(ChangeInfo info) {
    // TODO info card hover
    String name = name(info.owner());
    if (info.owner().avatar(AvatarInfo.DEFAULT_SIZE) != null) {
        ownerPanel.insert(new AvatarImage(info.owner()), 0);
    }
    ownerLink.setText(name);
    ownerLink.setTitle(email(info.owner(), name));
    ownerLink.setTargetHistoryToken(PageLinks.toAccountQuery(info.owner().name() != null ? info.owner().name() : info.owner().email() != null ? info.owner().email() : String.valueOf(info.owner()._accountId()), Change.Status.NEW));
}
#end_block

#method_before
private void startPoller() {
    if (Gerrit.isSignedIn() && 0 < Gerrit.getConfig().getChangeUpdateDelay()) {
        updateCheck = new UpdateCheckTimer(this);
        updateCheck.schedule();
        handlers.add(UserActivityMonitor.addValueChangeHandler(updateCheck));
    }
}
#method_after
private void startPoller() {
    if (Gerrit.isSignedIn() && 0 < Gerrit.info().change().updateDelay()) {
        updateCheck = new UpdateCheckTimer(this);
        updateCheck.schedule();
        handlers.add(UserActivityMonitor.addValueChangeHandler(updateCheck));
    }
}
#end_block

#method_before
public static IndexConfig create(int maxLimit, int maxPages, int maxTerms, int maxPrefixTerms) {
    return new AutoValue_IndexConfig(checkLimit(maxLimit, "maxLimit", Integer.MAX_VALUE), checkLimit(maxPages, "maxPages", Integer.MAX_VALUE), checkLimit(maxTerms, "maxTerms", BooleanQuery.getMaxClauseCount()), checkLimit(maxPrefixTerms, "maxPrefixTerms", DEFAULT_MAX_PREFIX_TERMS));
}
#method_after
public static IndexConfig create(int maxLimit, int maxPages, int maxTerms, int maxPrefixTerms) {
    return new AutoValue_IndexConfig(checkLimit(maxLimit, "maxLimit", Integer.MAX_VALUE), checkLimit(maxPages, "maxPages", Integer.MAX_VALUE), checkLimit(maxTerms, "maxTerms", DEFAULT_MAX_TERMS), checkLimit(maxPrefixTerms, "maxPrefixTerms", DEFAULT_MAX_PREFIX_TERMS));
}
#end_block

#method_before
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException {
    if (!(repoManager instanceof LocalDiskRepositoryManager)) {
        return;
    }
    ui.message("listing all repositories ...");
    SortedSet<Project.NameKey> repoList = repoManager.list();
    ui.message("done");
    ui.message(String.format("creating reflog files for %s branches ...", RefNames.REFS_CONFIG));
    ExecutorService executorPool = createExecutor(ui, repoList.size());
    List<Future<Void>> futures = new ArrayList<>();
    for (Project.NameKey project : repoList) {
        Callable<Void> callable = new ReflogCreator(project);
        futures.add(executorPool.submit(callable));
    }
    executorPool.shutdown();
    try {
        for (Future<Void> future : futures) {
            try {
                future.get();
            } catch (ExecutionException e) {
                ui.message(e.getCause().getMessage());
            }
        }
        ui.message("done");
    } catch (InterruptedException ex) {
        String msg = String.format("Migration step 106 was interrupted. Reflog created in %d of %d repositories only.", countDone(futures), repoList.size());
        ui.message(msg);
    }
}
#method_after
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException {
    if (!(repoManager instanceof LocalDiskRepositoryManager)) {
        return;
    }
    ui.message("listing all repositories ...");
    SortedSet<Project.NameKey> repoList = repoManager.list();
    ui.message("done");
    ui.message(String.format("creating reflog files for %s branches ...", RefNames.REFS_CONFIG));
    ExecutorService executorPool = createExecutor(ui, repoList.size());
    List<Future<Void>> futures = new ArrayList<>();
    for (Project.NameKey project : repoList) {
        Callable<Void> callable = new ReflogCreator(project);
        futures.add(executorPool.submit(callable));
    }
    executorPool.shutdown();
    try {
        for (Future<Void> future : futures) {
            try {
                future.get();
            } catch (ExecutionException e) {
                ui.message(e.getCause().getMessage());
            }
        }
        ui.message("done");
    } catch (InterruptedException ex) {
        String msg = String.format("Migration step 106 was interrupted. " + "Reflog created in %d of %d repositories only.", countDone(futures), repoList.size());
        ui.message(msg);
    }
}
#end_block

#method_before
protected static void renameColumn(ReviewDb db, String table, String from, String to) throws OrmException {
    JdbcSchema s = (JdbcSchema) db;
    try (JdbcExecutor e = new JdbcExecutor(s)) {
        s.renameField(e, table, from, to);
    }
}
#method_after
protected static void renameColumn(ReviewDb db, String table, String from, String to) throws OrmException {
    JdbcSchema s = (JdbcSchema) db;
    try (JdbcExecutor e = new JdbcExecutor(s)) {
        s.renameColumn(e, table, from, to);
    }
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, InvalidChangeOperationException, IOException {
    ChangeControl ctl = ctx.getControl();
    change = ctx.getChange();
    ChangeUpdate update = ctx.getUpdate(psId);
    update.setSubjectForCommit("Create patch set " + psId.get());
    if (!change.getStatus().isOpen() && !allowClosed) {
        throw new InvalidChangeOperationException(String.format("Change %s is closed", change.getId()));
    }
    Iterable<String> newGroups = groups;
    if (newGroups == null) {
        PatchSet prevPs = psUtil.current(ctx.getDb(), ctx.getNotes());
        newGroups = prevPs != null ? prevPs.getGroups() : null;
    }
    ctx.getRevWalk().parseBody(commit);
    patchSet = psUtil.insert(ctx.getDb(), ctx.getRevWalk(), ctx.getUpdate(psId), psId, commit, draft, newGroups, null);
    if (sendMail) {
        oldReviewers = approvalsUtil.getReviewers(db, ctl.getNotes());
    }
    if (message != null) {
        changeMessage = new ChangeMessage(new ChangeMessage.Key(ctl.getId(), ChangeUtil.messageUUID(db)), ctx.getUser().getAccountId(), ctx.getWhen(), patchSet.getId());
        changeMessage.setMessage(message);
    }
    patchSetInfo = patchSetInfoFactory.get(ctx.getRevWalk(), commit, psId);
    if (change.getStatus() != Change.Status.DRAFT && !allowClosed) {
        change.setStatus(Change.Status.NEW);
    }
    change.setCurrentPatchSet(patchSetInfo);
    ctx.saveChange();
    if (copyApprovals) {
        approvalCopier.copy(db, ctl, patchSet);
    }
    if (changeMessage != null) {
        cmUtil.addChangeMessage(db, update, changeMessage);
    }
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, InvalidChangeOperationException, IOException {
    ChangeControl ctl = ctx.getControl();
    change = ctx.getChange();
    ChangeUpdate update = ctx.getUpdate(psId);
    update.setSubjectForCommit("Create patch set " + psId.get());
    if (!change.getStatus().isOpen() && !allowClosed) {
        throw new InvalidChangeOperationException(String.format("Change %s is closed", change.getId()));
    }
    Iterable<String> newGroups = groups;
    if (newGroups == null) {
        PatchSet prevPs = psUtil.current(ctx.getDb(), ctx.getNotes());
        newGroups = prevPs != null ? prevPs.getGroups() : null;
    }
    patchSet = psUtil.insert(ctx.getDb(), ctx.getRevWalk(), ctx.getUpdate(psId), psId, commit, draft, newGroups, null);
    if (sendMail) {
        oldReviewers = approvalsUtil.getReviewers(db, ctl.getNotes());
    }
    if (message != null) {
        changeMessage = new ChangeMessage(new ChangeMessage.Key(ctl.getId(), ChangeUtil.messageUUID(db)), ctx.getUser().getAccountId(), ctx.getWhen(), patchSet.getId());
        changeMessage.setMessage(message);
    }
    patchSetInfo = patchSetInfoFactory.get(ctx.getRevWalk(), commit, psId);
    if (change.getStatus() != Change.Status.DRAFT && !allowClosed) {
        change.setStatus(Change.Status.NEW);
    }
    change.setCurrentPatchSet(patchSetInfo);
    ctx.saveChange();
    if (copyApprovals) {
        approvalCopier.copy(db, ctl, patchSet);
    }
    if (changeMessage != null) {
        cmUtil.addChangeMessage(db, update, changeMessage);
    }
    return true;
}
#end_block

#method_before
private void submit(ChangeControl changeCtl, PatchSet ps) throws OrmException, RestApiException {
    Submit submit = submitProvider.get();
    RevisionResource rsrc = new RevisionResource(changes.parse(changeCtl), ps);
    try (MergeOp op = mergeOpProvider.get()) {
        op.merge(db, rsrc.getChange(), changeCtl.getUser().asIdentifiedUser(), false);
    }
    addMessage("");
    Change c = db.changes().get(rsrc.getChange().getId());
    switch(c.getStatus()) {
        case MERGED:
            addMessage("Change " + c.getChangeId() + " merged.");
            break;
        case NEW:
            ChangeMessage msg = submit.getConflictMessage(rsrc);
            if (msg != null) {
                addMessage("Change " + c.getChangeId() + ": " + msg.getMessage());
                break;
            }
        // $FALL-THROUGH$
        default:
            addMessage("change " + c.getChangeId() + " is " + c.getStatus().name().toLowerCase());
    }
}
#method_after
private void submit(ChangeControl changeCtl, PatchSet ps) throws OrmException, RestApiException {
    Submit submit = submitProvider.get();
    RevisionResource rsrc = new RevisionResource(changes.parse(changeCtl), ps);
    try (MergeOp op = mergeOpProvider.get()) {
        op.merge(db, rsrc.getChange(), changeCtl.getUser().asIdentifiedUser(), false);
    }
    addMessage("");
    Change c = db.changes().get(rsrc.getChange().getId());
    switch(c.getStatus()) {
        case MERGED:
            addMessage("Change " + c.getChangeId() + " merged.");
            break;
        case NEW:
            ChangeMessage msg = submit.getConflictMessage(rsrc);
            if (msg != null) {
                addMessage("Change " + c.getChangeId() + ": " + msg.getMessage());
                break;
            }
        // $FALL-THROUGH$
        case ABANDONED:
        case DRAFT:
        default:
            addMessage("change " + c.getChangeId() + " is " + c.getStatus().name().toLowerCase());
    }
}
#end_block

#method_before
private void checkMandatoryFooters() throws ConfigInvalidException {
    List<FooterKey> missing = new ArrayList<>();
    if (branch == null) {
        missing.add(FOOTER_BRANCH);
    }
    if (!missing.isEmpty()) {
        throw parseException("Missing footers: " + Joiner.on(", ").join(Lists.transform(missing, new Function<FooterKey, String>() {

            @Override
            public String apply(FooterKey input) {
                return input.getName();
            }
        })));
    }
}
#method_after
private void checkMandatoryFooters() throws ConfigInvalidException {
    List<FooterKey> missing = new ArrayList<>();
    if (branch == null) {
        missing.add(FOOTER_BRANCH);
    }
    if (originalSubject == null || subject == null) {
        missing.add(FOOTER_SUBJECT);
    }
    if (!missing.isEmpty()) {
        throw parseException("Missing footers: " + Joiner.on(", ").join(Lists.transform(missing, new Function<FooterKey, String>() {

            @Override
            public String apply(FooterKey input) {
                return input.getName();
            }
        })));
    }
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    assume().that(notesMigration.enabled()).isFalse();
    // Ignore client clone of project; repurpose as server-side TestRepository.
    testRepo = new TestRepository<>((InMemoryRepository) repoManager.openRepository(project));
    tip = testRepo.getRevWalk().parseCommit(testRepo.getRepository().exactRef("HEAD").getObjectId());
    adminId = admin.getId();
    checker = checkerProvider.get();
}
#method_after
@Before
public void setUp() throws Exception {
    // TODO(dborowitz): Re-enable when ConsistencyChecker supports notedb.
    assume().that(notesMigration.enabled()).isFalse();
    // Ignore client clone of project; repurpose as server-side TestRepository.
    testRepo = new TestRepository<>((InMemoryRepository) repoManager.openRepository(project));
    tip = testRepo.getRevWalk().parseCommit(testRepo.getRepository().exactRef("HEAD").getObjectId());
    adminId = admin.getId();
    checker = checkerProvider.get();
}
#end_block

#method_before
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    ObjectId rev = getRevision();
    if (rev == null) {
        loadDefaults();
        return;
    }
    try (RevWalk walk = new RevWalk(reader);
        ChangeNotesParser parser = new ChangeNotesParser(change, rev, walk, repoManager)) {
        parser.parseAll();
        if (parser.status != null) {
            change.setStatus(parser.status);
        }
        approvals = parser.buildApprovals();
        changeMessagesByPatchSet = parser.buildMessagesByPatchSet();
        allChangeMessages = parser.buildAllMessages();
        comments = ImmutableListMultimap.copyOf(parser.comments);
        noteMap = parser.commentNoteMap;
        change.setDest(new Branch.NameKey(getProjectName(), parser.branch));
        change.setTopic(Strings.emptyToNull(parser.topic));
        change.setCreatedOn(parser.createdOn);
        change.setLastUpdatedOn(parser.lastUpdatedOn);
        change.setOwner(parser.ownerId);
        change.setSubmissionId(parser.submissionId);
        patchSets = ImmutableSortedMap.copyOf(parser.patchSets, ReviewDbUtil.intKeyOrdering());
        if (!patchSets.isEmpty()) {
            change.setCurrentPatchSet(parser.currentPatchSetId, parser.subject, parser.originalSubject);
        } else {
            // This is generally an error, but for now at least we support it in
            // tests.
            change.clearCurrentPatchSet();
        }
        if (parser.hashtags != null) {
            hashtags = ImmutableSet.copyOf(parser.hashtags);
        } else {
            hashtags = ImmutableSet.of();
        }
        ImmutableSetMultimap.Builder<ReviewerStateInternal, Account.Id> reviewers = ImmutableSetMultimap.builder();
        for (Map.Entry<Account.Id, ReviewerStateInternal> e : parser.reviewers.entrySet()) {
            reviewers.put(e.getValue(), e.getKey());
        }
        this.reviewers = reviewers.build();
        this.allPastReviewers = ImmutableList.copyOf(parser.allPastReviewers);
        submitRecords = ImmutableList.copyOf(parser.submitRecords);
    }
}
#method_after
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    ObjectId rev = getRevision();
    if (rev == null) {
        loadDefaults();
        return;
    }
    try (RevWalk walk = new RevWalk(reader);
        ChangeNotesParser parser = new ChangeNotesParser(change, rev, walk, repoManager)) {
        parser.parseAll();
        if (parser.status != null) {
            change.setStatus(parser.status);
        }
        approvals = parser.buildApprovals();
        changeMessagesByPatchSet = parser.buildMessagesByPatchSet();
        allChangeMessages = parser.buildAllMessages();
        comments = ImmutableListMultimap.copyOf(parser.comments);
        noteMap = parser.commentNoteMap;
        change.setDest(new Branch.NameKey(getProjectName(), parser.branch));
        change.setTopic(Strings.emptyToNull(parser.topic));
        change.setCreatedOn(parser.createdOn);
        change.setLastUpdatedOn(parser.lastUpdatedOn);
        change.setOwner(parser.ownerId);
        change.setSubmissionId(parser.submissionId);
        patchSets = ImmutableSortedMap.copyOf(parser.patchSets, ReviewDbUtil.intKeyOrdering());
        if (!patchSets.isEmpty()) {
            change.setCurrentPatchSet(parser.currentPatchSetId, parser.subject, parser.originalSubject);
        } else {
            // TODO(dborowitz): This should be an error, but for now it's required
            // for some tests to pass.
            change.clearCurrentPatchSet();
        }
        if (parser.hashtags != null) {
            hashtags = ImmutableSet.copyOf(parser.hashtags);
        } else {
            hashtags = ImmutableSet.of();
        }
        ImmutableSetMultimap.Builder<ReviewerStateInternal, Account.Id> reviewers = ImmutableSetMultimap.builder();
        for (Map.Entry<Account.Id, ReviewerStateInternal> e : parser.reviewers.entrySet()) {
            reviewers.put(e.getValue(), e.getKey());
        }
        this.reviewers = reviewers.build();
        this.allPastReviewers = ImmutableList.copyOf(parser.allPastReviewers);
        submitRecords = ImmutableList.copyOf(parser.submitRecords);
    }
}
#end_block

#method_before
@Test
public void commitChangeNotesUnique() throws Exception {
    // PatchSetId -> RevId must be a one to one mapping
    Change c = newChange();
    RevCommit commit = tr.commit().message("PS1").create();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.setCommit(rw, commit);
    update.commit();
    ChangeNotes notes = newNotes(c);
    assertThat(notes.getCurrentPatchSet().getRevision().get()).isEqualTo(commit.name());
    // new revId for the same patch set, ps1
    commit = tr.commit().message("PS2").create();
    update.setCommit(rw, commit);
    update.commit();
    exception.expect(OrmException.class);
    exception.expectMessage("Multiple revisions parsed for patch set");
    notes = newNotes(c);
}
#method_after
@Test
public void commitChangeNotesUnique() throws Exception {
    // PatchSetId -> RevId must be a one to one mapping
    Change c = newChange();
    ChangeNotes notes = newNotes(c);
    PatchSet ps = notes.getCurrentPatchSet();
    assertThat(ps).isNotNull();
    // new revId for the same patch set, ps1
    ChangeUpdate update = newUpdate(c, changeOwner);
    RevCommit commit = tr.commit().message("PS1 again").create();
    update.setCommit(rw, commit);
    update.commit();
    exception.expect(OrmException.class);
    exception.expectMessage("Multiple revisions parsed for patch set");
    notes = newNotes(c);
}
#end_block

#method_before
@Test
public void patchSetChangeNotes() throws Exception {
    Change c = newChange();
    // ps1
    ChangeUpdate update = newUpdate(c, changeOwner);
    RevCommit commit = tr.commit().message("PS1").create();
    update = newUpdate(c, changeOwner);
    update.setCommit(rw, commit);
    update.commit();
    ChangeNotes notes = newNotes(c);
    PatchSet ps = notes.getCurrentPatchSet();
    assertThat(notes.getChange().currentPatchSetId()).isEqualTo(ps.getId());
    assertThat(notes.getChange().getSubject()).isEqualTo("PS1");
    assertThat(notes.getChange().getOriginalSubject()).isEqualTo("PS1");
    assertThat(ps.getId()).isEqualTo(new PatchSet.Id(c.getId(), 1));
    assertThat(ps.getRevision().get()).isEqualTo(commit.name());
    assertThat(ps.getUploader()).isEqualTo(changeOwner.getAccountId());
    assertThat(ps.getCreatedOn()).isEqualTo(update.getWhen());
    // ps2 by other user
    incrementPatchSet(c);
    commit = tr.commit().message("PS2").create();
    update = newUpdate(c, otherUser);
    update.setCommit(rw, commit);
    update.commit();
    notes = newNotes(c);
    ps = notes.getCurrentPatchSet();
    assertThat(ps.getId()).isEqualTo(new PatchSet.Id(c.getId(), 2));
    assertThat(notes.getChange().getSubject()).isEqualTo("PS2");
    assertThat(notes.getChange().getOriginalSubject()).isEqualTo("PS1");
    assertThat(notes.getChange().currentPatchSetId()).isEqualTo(ps.getId());
    assertThat(ps.getRevision().get()).isEqualTo(commit.name());
    assertThat(ps.getUploader()).isEqualTo(otherUser.getAccountId());
    assertThat(ps.getCreatedOn()).isEqualTo(update.getWhen());
}
#method_after
@Test
public void patchSetChangeNotes() throws Exception {
    Change c = newChange();
    // ps1 created by newChange()
    ChangeNotes notes = newNotes(c);
    PatchSet ps1 = notes.getCurrentPatchSet();
    assertThat(notes.getChange().currentPatchSetId()).isEqualTo(ps1.getId());
    assertThat(notes.getChange().getSubject()).isEqualTo("Change subject");
    assertThat(notes.getChange().getOriginalSubject()).isEqualTo("Change subject");
    assertThat(ps1.getId()).isEqualTo(new PatchSet.Id(c.getId(), 1));
    assertThat(ps1.getUploader()).isEqualTo(changeOwner.getAccountId());
    // ps2 by other user
    incrementPatchSet(c);
    RevCommit commit = tr.commit().message("PS2").create();
    ChangeUpdate update = newUpdate(c, otherUser);
    update.setCommit(rw, commit);
    update.commit();
    notes = newNotes(c);
    PatchSet ps2 = notes.getCurrentPatchSet();
    assertThat(ps2.getId()).isEqualTo(new PatchSet.Id(c.getId(), 2));
    assertThat(notes.getChange().getSubject()).isEqualTo("PS2");
    assertThat(notes.getChange().getOriginalSubject()).isEqualTo("Change subject");
    assertThat(notes.getChange().currentPatchSetId()).isEqualTo(ps2.getId());
    assertThat(ps2.getRevision().get()).isNotEqualTo(ps1.getRevision());
    assertThat(ps2.getRevision().get()).isEqualTo(commit.name());
    assertThat(ps2.getUploader()).isEqualTo(otherUser.getAccountId());
    assertThat(ps2.getCreatedOn()).isEqualTo(update.getWhen());
}
#end_block

#method_before
protected Change newChange() throws IOException, OrmException, ConfigInvalidException {
    Change c = TestChanges.newChange(project, changeOwner.getAccountId());
    ChangeUpdate u = newUpdate(c, changeOwner);
    u.setBranch(c.getDest().get());
    u.commit();
    return c;
}
#method_after
protected Change newChange() throws Exception {
    Change c = TestChanges.newChange(project, changeOwner.getAccountId());
    ChangeUpdate u = newUpdate(c, changeOwner);
    u.setBranch(c.getDest().get());
    u.commit();
    return c;
}
#end_block

#method_before
protected ChangeUpdate newUpdate(Change c, IdentifiedUser user) throws OrmException, IOException, ConfigInvalidException {
    ChangeUpdate update = TestChanges.newUpdate(injector, repoManager, MIGRATION, c, allUsers, user);
    try (Repository repo = repoManager.openMetadataRepository(c.getProject())) {
        update.load(repo);
    }
    return update;
}
#method_after
protected ChangeUpdate newUpdate(Change c, IdentifiedUser user) throws Exception {
    ChangeUpdate update = TestChanges.newUpdate(injector, repoManager, MIGRATION, c, allUsers, user);
    try (Repository repo = repoManager.openMetadataRepository(c.getProject())) {
        update.load(repo);
    }
    return update;
}
#end_block

#method_before
@VisibleForTesting
void setSubject(String subject) {
    this.subject = subject;
}
#method_after
void setSubject(String subject) {
    this.subject = subject;
}
#end_block

#method_before
@Test
public void approvalsCommitFormatSimple() throws Exception {
    Change c = TestChanges.newChange(project, changeOwner.getAccountId(), 1);
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.putApproval("Verified", (short) 1);
    update.putApproval("Code-Review", (short) -1);
    update.putReviewer(changeOwner.getAccount().getId(), REVIEWER);
    update.putReviewer(otherUser.getAccount().getId(), CC);
    update.commit();
    assertThat(update.getRefName()).isEqualTo("refs/changes/01/1/meta");
    RevCommit commit = parseCommit(update.getRevision());
    assertBodyEquals("Update patch set 1\n" + "\n" + "Patch-set: 1\n" + "Reviewer: Change Owner <1@gerrit>\n" + "CC: Other Account <2@gerrit>\n" + "Label: Code-Review=-1\n" + "Label: Verified=+1\n", commit);
    PersonIdent author = commit.getAuthorIdent();
    assertThat(author.getName()).isEqualTo("Change Owner");
    assertThat(author.getEmailAddress()).isEqualTo("1@gerrit");
    assertThat(author.getWhen()).isEqualTo(new Date(c.getCreatedOn().getTime() + 1000));
    assertThat(author.getTimeZone()).isEqualTo(TimeZone.getTimeZone("GMT-7:00"));
    PersonIdent committer = commit.getCommitterIdent();
    assertThat(committer.getName()).isEqualTo("Gerrit Server");
    assertThat(committer.getEmailAddress()).isEqualTo("noreply@gerrit.com");
    assertThat(committer.getWhen()).isEqualTo(author.getWhen());
    assertThat(committer.getTimeZone()).isEqualTo(author.getTimeZone());
}
#method_after
@Test
public void approvalsCommitFormatSimple() throws Exception {
    Change c = TestChanges.newChange(project, changeOwner.getAccountId(), 1);
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.putApproval("Verified", (short) 1);
    update.putApproval("Code-Review", (short) -1);
    update.putReviewer(changeOwner.getAccount().getId(), REVIEWER);
    update.putReviewer(otherUser.getAccount().getId(), CC);
    update.commit();
    assertThat(update.getRefName()).isEqualTo("refs/changes/01/1/meta");
    RevCommit commit = parseCommit(update.getRevision());
    assertBodyEquals("Update patch set 1\n" + "\n" + "Patch-set: 1\n" + "Subject: Change subject\n" + "Branch: refs/heads/master\n" + "Commit: " + update.getCommit().name() + "\n" + "Reviewer: Change Owner <1@gerrit>\n" + "CC: Other Account <2@gerrit>\n" + "Label: Code-Review=-1\n" + "Label: Verified=+1\n", commit);
    PersonIdent author = commit.getAuthorIdent();
    assertThat(author.getName()).isEqualTo("Change Owner");
    assertThat(author.getEmailAddress()).isEqualTo("1@gerrit");
    assertThat(author.getWhen()).isEqualTo(new Date(c.getCreatedOn().getTime() + 1000));
    assertThat(author.getTimeZone()).isEqualTo(TimeZone.getTimeZone("GMT-7:00"));
    PersonIdent committer = commit.getCommitterIdent();
    assertThat(committer.getName()).isEqualTo("Gerrit Server");
    assertThat(committer.getEmailAddress()).isEqualTo("noreply@gerrit.com");
    assertThat(committer.getWhen()).isEqualTo(author.getWhen());
    assertThat(committer.getTimeZone()).isEqualTo(author.getTimeZone());
}
#end_block

#method_before
@Test
public void changeMessageCommitFormatSimple() throws Exception {
    Change c = TestChanges.newChange(project, changeOwner.getAccountId(), 1);
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.setChangeMessage("Just a little code change.\n" + "How about a new line");
    update.commit();
    assertThat(update.getRefName()).isEqualTo("refs/changes/01/1/meta");
    assertBodyEquals("Update patch set 1\n" + "\n" + "Just a little code change.\n" + "How about a new line\n" + "\n" + "Patch-set: 1\n", update.getRevision());
}
#method_after
@Test
public void changeMessageCommitFormatSimple() throws Exception {
    Change c = TestChanges.newChange(project, changeOwner.getAccountId(), 1);
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.setChangeMessage("Just a little code change.\n" + "How about a new line");
    update.commit();
    assertThat(update.getRefName()).isEqualTo("refs/changes/01/1/meta");
    assertBodyEquals("Update patch set 1\n" + "\n" + "Just a little code change.\n" + "How about a new line\n" + "\n" + "Patch-set: 1\n" + "Subject: Change subject\n" + "Branch: refs/heads/master\n" + "Commit: " + update.getCommit().name() + "\n", update.getRevision());
}
#end_block

#method_before
@Test
public void changeWithRevision() throws Exception {
    Change c = TestChanges.newChange(project, changeOwner.getAccountId(), 1);
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.setChangeMessage("Foo");
    RevCommit commit = tr.commit().message("Subject").create();
    update.setCommit(rw, commit);
    update.commit();
    assertThat(update.getRefName()).isEqualTo("refs/changes/01/1/meta");
    assertBodyEquals("Update patch set 1\n" + "\n" + "Foo\n" + "\n" + "Patch-set: 1\n" + "Subject: Subject\n" + "Commit: " + commit.name() + "\n", update.getRevision());
}
#method_after
@Test
public void changeWithRevision() throws Exception {
    Change c = TestChanges.newChange(project, changeOwner.getAccountId(), 1);
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.setChangeMessage("Foo");
    RevCommit commit = tr.commit().message("Subject").create();
    update.setCommit(rw, commit);
    update.commit();
    assertThat(update.getRefName()).isEqualTo("refs/changes/01/1/meta");
    assertBodyEquals("Update patch set 1\n" + "\n" + "Foo\n" + "\n" + "Patch-set: 1\n" + "Subject: Subject\n" + "Branch: refs/heads/master\n" + "Commit: " + commit.name() + "\n", update.getRevision());
}
#end_block

#method_before
public void putApproval(String label, short value) {
    approvals.put(label, Optional.of(value));
}
#method_after
public void putApproval(String label, short value) {
    putApprovalFor(getUser().getAccountId(), label, value);
}
#end_block

#method_before
public void removeApproval(String label) {
    approvals.put(label, Optional.<Short>absent());
}
#method_after
public void removeApproval(String label) {
    removeApprovalFor(getUser().getAccountId(), label);
}
#end_block

#method_before
public void merge(Iterable<SubmitRecord> submitRecords) {
    this.status = Change.Status.MERGED;
    this.submitRecords = ImmutableList.copyOf(submitRecords);
    checkArgument(!this.submitRecords.isEmpty(), "no submit records specified at submit time");
}
#method_after
public void merge(String submissionId, Iterable<SubmitRecord> submitRecords) {
    this.status = Change.Status.MERGED;
    this.submissionId = submissionId;
    this.submitRecords = ImmutableList.copyOf(submitRecords);
    checkArgument(!this.submitRecords.isEmpty(), "no submit records specified at submit time");
}
#end_block

#method_before
public RevCommit commit() throws IOException {
    BatchMetaDataUpdate batch = openUpdate();
    try {
        writeCommit(batch);
        if (draftUpdate != null) {
            draftUpdate.commit();
        }
        RevCommit c = batch.commit();
        return c;
    } catch (OrmException e) {
        throw new IOException(e);
    } finally {
        batch.close();
    }
}
#method_after
public RevCommit commit() throws IOException {
    BatchMetaDataUpdate batch = openUpdate();
    try {
        writeCommit(batch);
        RevCommit c = batch.commit();
        return c;
    } catch (OrmException e) {
        throw new IOException(e);
    } finally {
        batch.close();
    }
}
#end_block

#method_before
@Override
public void writeCommit(BatchMetaDataUpdate batch) throws OrmException, IOException {
    CommitBuilder builder = new CommitBuilder();
    if (migration.writeChanges()) {
        ObjectId treeId = storeCommentsInNotes();
        if (treeId != null) {
            builder.setTreeId(treeId);
        }
    }
    batch.write(this, builder);
}
#method_after
@Override
public void writeCommit(BatchMetaDataUpdate batch) throws OrmException, IOException {
    CommitBuilder builder = new CommitBuilder();
    if (migration.writeChanges()) {
        ObjectId treeId = storeCommentsInNotes();
        if (treeId != null) {
            builder.setTreeId(treeId);
        }
    }
    batch.write(this, builder);
    if (draftUpdate != null) {
        draftUpdate.commit();
    }
}
#end_block

#method_before
@Override
protected boolean onSave(CommitBuilder commit) {
    if (isEmpty()) {
        return false;
    }
    commit.setAuthor(newIdent(getUser().getAccount(), when));
    commit.setCommitter(new PersonIdent(serverIdent, when));
    int ps = psId != null ? psId.get() : getChange().currentPatchSetId().get();
    StringBuilder msg = new StringBuilder();
    if (subject != null) {
        msg.append(subject);
    } else {
        msg.append("Update patch set ").append(ps);
    }
    msg.append("\n\n");
    if (changeMessage != null) {
        msg.append(changeMessage);
        msg.append("\n\n");
    }
    addFooter(msg, FOOTER_PATCH_SET, ps);
    if (status != null) {
        addFooter(msg, FOOTER_STATUS, status.name().toLowerCase());
    }
    if (topic != null) {
        addFooter(msg, FOOTER_TOPIC, topic);
    }
    if (revId != null) {
        addFooter(msg, FOOTER_COMMIT, revId);
    }
    if (hashtags != null) {
        addFooter(msg, FOOTER_HASHTAGS, Joiner.on(",").join(hashtags));
    }
    for (Map.Entry<Account.Id, ReviewerStateInternal> e : reviewers.entrySet()) {
        Account account = accountCache.get(e.getKey()).getAccount();
        PersonIdent ident = newIdent(account, when);
        addFooter(msg, e.getValue().getFooterKey()).append(ident.getName()).append(" <").append(ident.getEmailAddress()).append(">\n");
    }
    for (Map.Entry<String, Optional<Short>> e : approvals.entrySet()) {
        if (!e.getValue().isPresent()) {
            addFooter(msg, FOOTER_LABEL, '-', e.getKey());
        } else {
            addFooter(msg, FOOTER_LABEL, LabelVote.create(e.getKey(), e.getValue().get()).formatWithEquals());
        }
    }
    if (submitRecords != null) {
        for (SubmitRecord rec : submitRecords) {
            addFooter(msg, FOOTER_SUBMITTED_WITH).append(rec.status);
            if (rec.errorMessage != null) {
                msg.append(' ').append(sanitizeFooter(rec.errorMessage));
            }
            msg.append('\n');
            if (rec.labels != null) {
                for (SubmitRecord.Label label : rec.labels) {
                    addFooter(msg, FOOTER_SUBMITTED_WITH).append(label.status).append(": ").append(label.label);
                    if (label.appliedBy != null) {
                        PersonIdent ident = newIdent(accountCache.get(label.appliedBy).getAccount(), when);
                        msg.append(": ").append(ident.getName()).append(" <").append(ident.getEmailAddress()).append('>');
                    }
                    msg.append('\n');
                }
            }
        }
    }
    commit.setMessage(msg.toString());
    return true;
}
#method_after
@Override
protected boolean onSave(CommitBuilder cb) {
    if (getRevision() != null && isEmpty()) {
        return false;
    }
    cb.setAuthor(newIdent(getUser().getAccount(), when));
    cb.setCommitter(new PersonIdent(serverIdent, when));
    int ps = psId != null ? psId.get() : getChange().currentPatchSetId().get();
    StringBuilder msg = new StringBuilder();
    if (commitSubject != null) {
        msg.append(commitSubject);
    } else {
        msg.append("Update patch set ").append(ps);
    }
    msg.append("\n\n");
    if (changeMessage != null) {
        msg.append(changeMessage);
        msg.append("\n\n");
    }
    addFooter(msg, FOOTER_PATCH_SET, ps);
    if (subject != null) {
        addFooter(msg, FOOTER_SUBJECT, subject);
    }
    if (branch != null) {
        addFooter(msg, FOOTER_BRANCH, branch);
    }
    if (status != null) {
        addFooter(msg, FOOTER_STATUS, status.name().toLowerCase());
    }
    if (topic != null) {
        addFooter(msg, FOOTER_TOPIC, topic);
    }
    if (commit != null) {
        addFooter(msg, FOOTER_COMMIT, commit.name());
    }
    if (hashtags != null) {
        addFooter(msg, FOOTER_HASHTAGS, Joiner.on(",").join(hashtags));
    }
    for (Map.Entry<Account.Id, ReviewerStateInternal> e : reviewers.entrySet()) {
        addFooter(msg, e.getValue().getFooterKey());
        addIdent(msg, e.getKey()).append('\n');
    }
    for (Table.Cell<String, Account.Id, Optional<Short>> c : approvals.cellSet()) {
        addFooter(msg, FOOTER_LABEL);
        if (!c.getValue().isPresent()) {
            msg.append('-').append(c.getRowKey());
        } else {
            msg.append(LabelVote.create(c.getRowKey(), c.getValue().get()).formatWithEquals());
        }
        Account.Id id = c.getColumnKey();
        if (!id.equals(ctl.getUser().getAccountId())) {
            addIdent(msg.append(' '), id);
        }
        msg.append('\n');
    }
    if (submissionId != null) {
        addFooter(msg, FOOTER_SUBMISSION_ID, submissionId);
    }
    if (submitRecords != null) {
        for (SubmitRecord rec : submitRecords) {
            addFooter(msg, FOOTER_SUBMITTED_WITH).append(rec.status);
            if (rec.errorMessage != null) {
                msg.append(' ').append(sanitizeFooter(rec.errorMessage));
            }
            msg.append('\n');
            if (rec.labels != null) {
                for (SubmitRecord.Label label : rec.labels) {
                    addFooter(msg, FOOTER_SUBMITTED_WITH).append(label.status).append(": ").append(label.label);
                    if (label.appliedBy != null) {
                        PersonIdent ident = newIdent(accountCache.get(label.appliedBy).getAccount(), when);
                        msg.append(": ").append(ident.getName()).append(" <").append(ident.getEmailAddress()).append('>');
                    }
                    msg.append('\n');
                }
            }
        }
    }
    cb.setMessage(msg.toString());
    return true;
}
#end_block

#method_before
private boolean isEmpty() {
    return approvals.isEmpty() && changeMessage == null && comments.isEmpty() && reviewers.isEmpty() && status == null && subject == null && submitRecords == null && hashtags == null && topic == null;
}
#method_after
private boolean isEmpty() {
    return commitSubject == null && approvals.isEmpty() && changeMessage == null && comments.isEmpty() && reviewers.isEmpty() && branch == null && status == null && subject == null && submissionId == null && submitRecords == null && hashtags == null && topic == null && commit == null;
}
#end_block

#method_before
static PersonIdent newIdent(Account author, Date when, PersonIdent serverIdent, String anonymousCowardName) {
    return new PersonIdent(new AccountInfo(author).getName(anonymousCowardName), author.getId().get() + "@" + GERRIT_PLACEHOLDER_HOST, when, serverIdent.getTimeZone());
}
#method_after
@VisibleForTesting
public static PersonIdent newIdent(Account author, Date when, PersonIdent serverIdent, String anonymousCowardName) {
    return new PersonIdent(new AccountInfo(author).getName(anonymousCowardName), author.getId().get() + "@" + GERRIT_PLACEHOLDER_HOST, when, serverIdent.getTimeZone());
}
#end_block

#method_before
@Test
public void parseAuthor() throws Exception {
    assertParseSucceeds("Update change\n" + "\n" + "Patch-Set: 1\n");
    assertParseFails(writeCommit("Update change\n" + "\n" + "Patch-Set: 1\n", new PersonIdent("Change Owner", "owner@example.com", serverIdent.getWhen(), serverIdent.getTimeZone())));
    assertParseFails(writeCommit("Update change\n" + "\n" + "Patch-Set: 1\n", new PersonIdent("Change Owner", "x@gerrit", serverIdent.getWhen(), serverIdent.getTimeZone())));
}
#method_after
@Test
public void parseAuthor() throws Exception {
    assertParseSucceeds("Update change\n" + "\n" + "Branch: refs/heads/master\n" + "Patch-Set: 1\n" + "Subject: This is a test change\n");
    assertParseFails(writeCommit("Update change\n" + "\n" + "Patch-Set: 1\n", new PersonIdent("Change Owner", "owner@example.com", serverIdent.getWhen(), serverIdent.getTimeZone())));
    assertParseFails(writeCommit("Update change\n" + "\n" + "Patch-Set: 1\n", new PersonIdent("Change Owner", "x@gerrit", serverIdent.getWhen(), serverIdent.getTimeZone())));
}
#end_block

#method_before
@Test
public void parseStatus() throws Exception {
    assertParseSucceeds("Update change\n" + "\n" + "Patch-Set: 1\n" + "Status: NEW\n");
    assertParseSucceeds("Update change\n" + "\n" + "Patch-Set: 1\n" + "Status: new\n");
    assertParseFails("Update change\n" + "\n" + "Patch-Set: 1\n" + "Status: OOPS\n");
    assertParseFails("Update change\n" + "\n" + "Patch-Set: 1\n" + "Status: NEW\n" + "Status: NEW\n");
}
#method_after
@Test
public void parseStatus() throws Exception {
    assertParseSucceeds("Update change\n" + "\n" + "Branch: refs/heads/master\n" + "Patch-Set: 1\n" + "Status: NEW\n" + "Subject: This is a test change\n");
    assertParseSucceeds("Update change\n" + "\n" + "Branch: refs/heads/master\n" + "Patch-Set: 1\n" + "Status: new\n" + "Subject: This is a test change\n");
    assertParseFails("Update change\n" + "\n" + "Patch-Set: 1\n" + "Status: OOPS\n");
    assertParseFails("Update change\n" + "\n" + "Patch-Set: 1\n" + "Status: NEW\n" + "Status: NEW\n");
}
#end_block

#method_before
@Test
public void parsePatchSetId() throws Exception {
    assertParseSucceeds("Update change\n" + "\n" + "Patch-Set: 1\n");
    assertParseFails("Update change\n" + "\n");
    assertParseFails("Update change\n" + "\n" + "Patch-Set: 1\n" + "Patch-Set: 1\n");
    assertParseSucceeds("Update change\n" + "\n" + "Patch-Set: 1\n");
    assertParseFails("Update change\n" + "\n" + "Patch-Set: x\n");
}
#method_after
@Test
public void parsePatchSetId() throws Exception {
    assertParseSucceeds("Update change\n" + "\n" + "Branch: refs/heads/master\n" + "Patch-Set: 1\n" + "Subject: This is a test change\n");
    assertParseFails("Update change\n" + "\n");
    assertParseFails("Update change\n" + "\n" + "Patch-Set: 1\n" + "Patch-Set: 1\n");
    assertParseSucceeds("Update change\n" + "\n" + "Branch: refs/heads/master\n" + "Patch-Set: 1\n" + "Subject: This is a test change\n");
    assertParseFails("Update change\n" + "\n" + "Patch-Set: x\n");
}
#end_block

#method_before
@Test
public void parseApproval() throws Exception {
    assertParseSucceeds("Update change\n" + "\n" + "Patch-Set: 1\n" + "Label: Label1=+1\n" + "Label: Label2=1\n" + "Label: Label3=0\n" + "Label: Label4=-1\n");
    assertParseFails("Update change\n" + "\n" + "Patch-Set: 1\n" + "Label: Label1=X\n");
    assertParseFails("Update change\n" + "\n" + "Patch-Set: 1\n" + "Label: Label1 = 1\n");
    assertParseFails("Update change\n" + "\n" + "Patch-Set: 1\n" + "Label: X+Y\n");
}
#method_after
@Test
public void parseApproval() throws Exception {
    assertParseSucceeds("Update change\n" + "\n" + "Branch: refs/heads/master\n" + "Patch-Set: 1\n" + "Label: Label1=+1\n" + "Label: Label2=1\n" + "Label: Label3=0\n" + "Label: Label4=-1\n" + "Subject: This is a test change\n");
    assertParseSucceeds("Update change\n" + "\n" + "Branch: refs/heads/master\n" + "Patch-Set: 1\n" + "Label: -Label1\n" + "Label: -Label1 Other Account <2@gerrit>\n" + "Subject: This is a test change\n");
    assertParseFails("Update change\n" + "\n" + "Patch-Set: 1\n" + "Label: Label1=X\n");
    assertParseFails("Update change\n" + "\n" + "Patch-Set: 1\n" + "Label: Label1 = 1\n");
    assertParseFails("Update change\n" + "\n" + "Patch-Set: 1\n" + "Label: X+Y\n");
    assertParseFails("Update change\n" + "\n" + "Patch-Set: 1\n" + "Label: Label1 Other Account <2@gerrit>\n");
    assertParseFails("Update change\n" + "\n" + "Patch-Set: 1\n" + "Label: -Label!1\n");
    assertParseFails("Update change\n" + "\n" + "Patch-Set: 1\n" + "Label: -Label!1 Other Account <2@gerrit>\n");
}
#end_block

#method_before
@Test
public void parseSubmitRecords() throws Exception {
    assertParseSucceeds("Update change\n" + "\n" + "Patch-Set: 1\n" + "Submitted-with: NOT_READY\n" + "Submitted-with: OK: Verified: Change Owner <1@gerrit>\n" + "Submitted-with: NEED: Code-Review\n" + "Submitted-with: NOT_READY\n" + "Submitted-with: OK: Verified: Change Owner <1@gerrit>\n" + "Submitted-with: NEED: Alternative-Code-Review\n");
    assertParseFails("Update change\n" + "\n" + "Patch-Set: 1\n" + "Submitted-with: OOPS\n");
    assertParseFails("Update change\n" + "\n" + "Patch-Set: 1\n" + "Submitted-with: NEED: X+Y\n");
    assertParseFails("Update change\n" + "\n" + "Patch-Set: 1\n" + "Submitted-with: OK: X+Y: Change Owner <1@gerrit>\n");
    assertParseFails("Update change\n" + "\n" + "Patch-Set: 1\n" + "Submitted-with: OK: Code-Review: 1@gerrit\n");
}
#method_after
@Test
public void parseSubmitRecords() throws Exception {
    assertParseSucceeds("Update change\n" + "\n" + "Branch: refs/heads/master\n" + "Patch-Set: 1\n" + "Subject: This is a test change\n" + "Submitted-with: NOT_READY\n" + "Submitted-with: OK: Verified: Change Owner <1@gerrit>\n" + "Submitted-with: NEED: Code-Review\n" + "Submitted-with: NOT_READY\n" + "Submitted-with: OK: Verified: Change Owner <1@gerrit>\n" + "Submitted-with: NEED: Alternative-Code-Review\n");
    assertParseFails("Update change\n" + "\n" + "Patch-Set: 1\n" + "Submitted-with: OOPS\n");
    assertParseFails("Update change\n" + "\n" + "Patch-Set: 1\n" + "Submitted-with: NEED: X+Y\n");
    assertParseFails("Update change\n" + "\n" + "Patch-Set: 1\n" + "Submitted-with: OK: X+Y: Change Owner <1@gerrit>\n");
    assertParseFails("Update change\n" + "\n" + "Patch-Set: 1\n" + "Submitted-with: OK: Code-Review: 1@gerrit\n");
}
#end_block

#method_before
@Test
public void parseReviewer() throws Exception {
    assertParseSucceeds("Update change\n" + "\n" + "Patch-Set: 1\n" + "Reviewer: Change Owner <1@gerrit>\n" + "CC: Other Account <2@gerrit>\n");
    assertParseFails("Update change\n" + "\n" + "Patch-Set: 1\n" + "Reviewer: 1@gerrit\n");
}
#method_after
@Test
public void parseReviewer() throws Exception {
    assertParseSucceeds("Update change\n" + "\n" + "Branch: refs/heads/master\n" + "Patch-Set: 1\n" + "Reviewer: Change Owner <1@gerrit>\n" + "CC: Other Account <2@gerrit>\n" + "Subject: This is a test change\n");
    assertParseFails("Update change\n" + "\n" + "Patch-Set: 1\n" + "Reviewer: 1@gerrit\n");
}
#end_block

#method_before
@Test
public void parseTopic() throws Exception {
    assertParseSucceeds("Update change\n" + "\n" + "Patch-Set: 1\n" + "Topic: Some Topic");
    assertParseSucceeds("Update change\n" + "\n" + "Patch-Set: 1\n" + "Topic:");
    assertParseFails("Update change\n" + "\n" + "Patch-Set: 1\n" + "Topic: Some Topic\n" + "Topic: Other Topic");
}
#method_after
@Test
public void parseTopic() throws Exception {
    assertParseSucceeds("Update change\n" + "\n" + "Branch: refs/heads/master\n" + "Patch-Set: 1\n" + "Topic: Some Topic\n" + "Subject: This is a test change\n");
    assertParseSucceeds("Update change\n" + "\n" + "Branch: refs/heads/master\n" + "Patch-Set: 1\n" + "Topic:\n" + "Subject: This is a test change\n");
    assertParseFails("Update change\n" + "\n" + "Patch-Set: 1\n" + "Topic: Some Topic\n" + "Topic: Other Topic");
}
#end_block

#method_before
@Test
public void parseCommit() throws Exception {
    assertParseSucceeds("Update change\n" + "\n" + "Patch-set: 1\n" + "Commit: f11d66c4e8d1660f871b7ccf7df802a966975b85");
}
#method_after
@Test
public void parseCommit() throws Exception {
    assertParseSucceeds("Update change\n" + "\n" + "Patch-set: 1\n" + "Branch: refs/heads/master\n" + "Subject: Some subject of a change\n" + "Commit: abcd1234abcd1234abcd1234abcd1234abcd1234");
    assertParseFails("Update change\n" + "\n" + "Patch-set: 1\n" + "Branch: refs/heads/master\n" + "Subject: Some subject of a change\n" + "Commit: abcd1234abcd1234abcd1234abcd1234abcd1234\n" + "Commit: deadbeefdeadbeefdeadbeefdeadbeefdeadbeef");
    assertParseFails("Update patch set 1\n" + "Uploaded patch set 1.\n" + "Patch-set: 1\n" + "Branch: refs/heads/master\n" + "Subject: Some subject of a change\n" + "Commit: beef");
}
#end_block

#method_before
@Override
public AccountGeneralPreferencesInfo apply(AccountResource rsrc) throws AuthException, ResourceNotFoundException, OrmException, IOException, ConfigInvalidException {
    if (self.get() != rsrc.getUser() && !self.get().getCapabilities().canAdministrateServer()) {
        throw new AuthException("restricted to administrator");
    }
    Account.Id accountId = rsrc.getUser().getAccountId();
    return readFromGit ? readFromGit(accountId, gitMgr, allUsersName, null) : readFromDb(accountId);
}
#method_after
@Override
public GeneralPreferencesInfo apply(AccountResource rsrc) throws AuthException, ResourceNotFoundException, OrmException, IOException, ConfigInvalidException {
    if (self.get() != rsrc.getUser() && !self.get().getCapabilities().canAdministrateServer()) {
        throw new AuthException("restricted to administrator");
    }
    Account.Id accountId = rsrc.getUser().getAccountId();
    return readFromGit ? readFromGit(accountId, gitMgr, allUsersName, null) : readFromDb(accountId);
}
#end_block

#method_before
private AccountGeneralPreferencesInfo readFromDb(Id accountId) throws IOException, ConfigInvalidException, RepositoryNotFoundException, OrmException {
    Account a = db.get().accounts().get(accountId);
    AccountGeneralPreferencesInfo r = nullify(initFromDb(a.getGeneralPreferences()));
    try (Repository allUsers = gitMgr.openRepository(allUsersName)) {
        VersionedAccountPreferences p = VersionedAccountPreferences.forUser(accountId);
        p.load(allUsers);
        return loadFromAllUsers(r, p, allUsers);
    }
}
#method_after
private GeneralPreferencesInfo readFromDb(Account.Id accountId) throws IOException, ConfigInvalidException, RepositoryNotFoundException, OrmException {
    Account a = db.get().accounts().get(accountId);
    GeneralPreferencesInfo r = nullify(initFromDb(a.getGeneralPreferences()));
    try (Repository allUsers = gitMgr.openRepository(allUsersName)) {
        VersionedAccountPreferences p = VersionedAccountPreferences.forUser(accountId);
        p.load(allUsers);
        return loadFromAllUsers(r, p, allUsers);
    }
}
#end_block

#method_before
public static AccountGeneralPreferencesInfo readFromGit(Account.Id id, GitRepositoryManager gitMgr, AllUsersName allUsersName, AccountGeneralPreferencesInfo in) throws IOException, ConfigInvalidException, RepositoryNotFoundException {
    try (Repository allUsers = gitMgr.openRepository(allUsersName)) {
        VersionedAccountPreferences p = VersionedAccountPreferences.forUser(id);
        p.load(allUsers);
        AccountGeneralPreferencesInfo r = loadSection(p.getConfig(), UserConfigSections.GENERAL, null, new AccountGeneralPreferencesInfo(), AccountGeneralPreferencesInfo.defaults(), in);
        return loadFromAllUsers(r, p, allUsers);
    }
}
#method_after
public static GeneralPreferencesInfo readFromGit(Account.Id id, GitRepositoryManager gitMgr, AllUsersName allUsersName, GeneralPreferencesInfo in) throws IOException, ConfigInvalidException, RepositoryNotFoundException {
    try (Repository allUsers = gitMgr.openRepository(allUsersName)) {
        VersionedAccountPreferences p = VersionedAccountPreferences.forUser(id);
        p.load(allUsers);
        GeneralPreferencesInfo r = loadSection(p.getConfig(), UserConfigSections.GENERAL, null, new GeneralPreferencesInfo(), GeneralPreferencesInfo.defaults(), in);
        return loadFromAllUsers(r, p, allUsers);
    }
}
#end_block

#method_before
public static AccountGeneralPreferencesInfo loadFromAllUsers(AccountGeneralPreferencesInfo r, VersionedAccountPreferences v, Repository allUsers) {
    r.my = my(v);
    if (r.my.isEmpty() && !v.isDefaults()) {
        try {
            VersionedAccountPreferences d = VersionedAccountPreferences.forDefault();
            d.load(allUsers);
            r.my = my(d);
        } catch (ConfigInvalidException | IOException e) {
            log.warn("cannot read default preferences", e);
        }
    }
    if (r.my.isEmpty()) {
        r.my.add(new MenuItem("Changes", "#/dashboard/self", null));
        r.my.add(new MenuItem("Drafts", "#/q/owner:self+is:draft", null));
        r.my.add(new MenuItem("Draft Comments", "#/q/has:draft", null));
        r.my.add(new MenuItem("Edits", "#/q/has:edit", null));
        r.my.add(new MenuItem("Watched Changes", "#/q/is:watched+is:open", null));
        r.my.add(new MenuItem("Starred Changes", "#/q/is:starred", null));
        r.my.add(new MenuItem("Groups", "#/groups/self", null));
    }
    r.urlAliases = urlAliases(v);
    return r;
}
#method_after
public static GeneralPreferencesInfo loadFromAllUsers(GeneralPreferencesInfo r, VersionedAccountPreferences v, Repository allUsers) {
    r.my = my(v);
    if (r.my.isEmpty() && !v.isDefaults()) {
        try {
            VersionedAccountPreferences d = VersionedAccountPreferences.forDefault();
            d.load(allUsers);
            r.my = my(d);
        } catch (ConfigInvalidException | IOException e) {
            log.warn("cannot read default preferences", e);
        }
    }
    if (r.my.isEmpty()) {
        r.my.add(new MenuItem("Changes", "#/dashboard/self", null));
        r.my.add(new MenuItem("Drafts", "#/q/owner:self+is:draft", null));
        r.my.add(new MenuItem("Draft Comments", "#/q/has:draft", null));
        r.my.add(new MenuItem("Edits", "#/q/has:edit", null));
        r.my.add(new MenuItem("Watched Changes", "#/q/is:watched+is:open", null));
        r.my.add(new MenuItem("Starred Changes", "#/q/is:starred", null));
        r.my.add(new MenuItem("Groups", "#/groups/self", null));
    }
    r.urlAliases = urlAliases(v);
    return r;
}
#end_block

#method_before
static AccountGeneralPreferencesInfo initFromDb(AccountGeneralPreferences a) {
    AccountGeneralPreferencesInfo p = AccountGeneralPreferencesInfo.defaults();
    if (a != null) {
        p.changesPerPage = (int) a.getMaximumPageSize();
        p.showSiteHeader = a.isShowSiteHeader();
        p.useFlashClipboard = a.isUseFlashClipboard();
        p.downloadScheme = a.getDownloadUrl();
        if (a.getDownloadCommand() != null) {
            p.downloadCommand = DownloadCommand.valueOf(a.getDownloadCommand().name());
        }
        p.emailStrategy = EmailStrategy.valueOf(a.getEmailStrategy().name());
        p.dateFormat = DateFormat.valueOf(a.getDateFormat().name());
        p.timeFormat = TimeFormat.valueOf(a.getTimeFormat().name());
        p.relativeDateInChangeTable = a.isRelativeDateInChangeTable();
        p.sizeBarInChangeTable = a.isSizeBarInChangeTable();
        p.legacycidInChangeTable = a.isLegacycidInChangeTable();
        p.muteCommonPathPrefixes = a.isMuteCommonPathPrefixes();
        p.reviewCategoryStrategy = ReviewCategoryStrategy.valueOf(a.getReviewCategoryStrategy().name());
        p.diffView = DiffView.valueOf(a.getDiffView().name());
    }
    return p;
}
#method_after
static GeneralPreferencesInfo initFromDb(AccountGeneralPreferences a) {
    GeneralPreferencesInfo p = GeneralPreferencesInfo.defaults();
    if (a != null) {
        p.changesPerPage = (int) a.getMaximumPageSize();
        p.showSiteHeader = a.isShowSiteHeader();
        p.useFlashClipboard = a.isUseFlashClipboard();
        p.downloadScheme = a.getDownloadUrl();
        if (a.getDownloadCommand() != null) {
            p.downloadCommand = DownloadCommand.valueOf(a.getDownloadCommand().name());
        }
        p.emailStrategy = EmailStrategy.valueOf(a.getEmailStrategy().name());
        p.dateFormat = DateFormat.valueOf(a.getDateFormat().name());
        p.timeFormat = TimeFormat.valueOf(a.getTimeFormat().name());
        p.relativeDateInChangeTable = a.isRelativeDateInChangeTable();
        p.sizeBarInChangeTable = a.isSizeBarInChangeTable();
        p.legacycidInChangeTable = a.isLegacycidInChangeTable();
        p.muteCommonPathPrefixes = a.isMuteCommonPathPrefixes();
        p.reviewCategoryStrategy = ReviewCategoryStrategy.valueOf(a.getReviewCategoryStrategy().name());
        p.diffView = DiffView.valueOf(a.getDiffView().name());
    }
    return p;
}
#end_block

#method_before
private static AccountGeneralPreferencesInfo nullify(AccountGeneralPreferencesInfo p) {
    p.showSiteHeader = b(p.showSiteHeader);
    p.useFlashClipboard = b(p.useFlashClipboard);
    p.relativeDateInChangeTable = b(p.relativeDateInChangeTable);
    p.legacycidInChangeTable = b(p.legacycidInChangeTable);
    p.muteCommonPathPrefixes = b(p.muteCommonPathPrefixes);
    return p;
}
#method_after
private static GeneralPreferencesInfo nullify(GeneralPreferencesInfo p) {
    p.showSiteHeader = b(p.showSiteHeader);
    p.useFlashClipboard = b(p.useFlashClipboard);
    p.relativeDateInChangeTable = b(p.relativeDateInChangeTable);
    p.legacycidInChangeTable = b(p.legacycidInChangeTable);
    p.muteCommonPathPrefixes = b(p.muteCommonPathPrefixes);
    p.sizeBarInChangeTable = b(p.sizeBarInChangeTable);
    return p;
}
#end_block

#method_before
@Override
public AccountGeneralPreferencesInfo apply(ConfigResource rsrc, AccountGeneralPreferencesInfo i) throws BadRequestException, IOException, ConfigInvalidException {
    if (i.changesPerPage != null || i.showSiteHeader != null || i.useFlashClipboard != null || i.downloadScheme != null || i.downloadCommand != null || i.dateFormat != null || i.timeFormat != null || i.relativeDateInChangeTable != null || i.sizeBarInChangeTable != null || i.legacycidInChangeTable != null || i.muteCommonPathPrefixes != null || i.reviewCategoryStrategy != null || i.emailStrategy != null) {
        throw new BadRequestException("unsupported option");
    }
    VersionedAccountPreferences p;
    try (MetaDataUpdate md = metaDataUpdateFactory.get().create(allUsersName)) {
        p = VersionedAccountPreferences.forDefault();
        p.load(md);
        com.google.gerrit.server.account.SetPreferences.storeMyMenus(p, i.my);
        p.commit(md);
        AccountGeneralPreferencesInfo a = new AccountGeneralPreferencesInfo();
        return loadFromAllUsers(a, p, md.getRepository());
    }
}
#method_after
@Override
public GeneralPreferencesInfo apply(ConfigResource rsrc, GeneralPreferencesInfo i) throws BadRequestException, IOException, ConfigInvalidException {
    if (i.changesPerPage != null || i.showSiteHeader != null || i.useFlashClipboard != null || i.downloadScheme != null || i.downloadCommand != null || i.dateFormat != null || i.timeFormat != null || i.relativeDateInChangeTable != null || i.sizeBarInChangeTable != null || i.legacycidInChangeTable != null || i.muteCommonPathPrefixes != null || i.reviewCategoryStrategy != null || i.emailStrategy != null) {
        throw new BadRequestException("unsupported option");
    }
    VersionedAccountPreferences p;
    try (MetaDataUpdate md = metaDataUpdateFactory.get().create(allUsersName)) {
        p = VersionedAccountPreferences.forDefault();
        p.load(md);
        com.google.gerrit.server.account.SetPreferences.storeMyMenus(p, i.my);
        p.commit(md);
        GeneralPreferencesInfo a = new GeneralPreferencesInfo();
        return loadFromAllUsers(a, p, md.getRepository());
    }
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    showSiteHeader = new CheckBox(Util.C.showSiteHeader());
    useFlashClipboard = new CheckBox(Util.C.useFlashClipboard());
    maximumPageSize = new ListBox();
    for (final int v : PAGESIZE_CHOICES) {
        maximumPageSize.addItem(Util.M.rowsPerPage(v), String.valueOf(v));
    }
    reviewCategoryStrategy = new ListBox();
    reviewCategoryStrategy.addItem(Util.C.messageShowInReviewCategoryNone(), AccountGeneralPreferencesInfo.ReviewCategoryStrategy.NONE.name());
    reviewCategoryStrategy.addItem(Util.C.messageShowInReviewCategoryName(), AccountGeneralPreferencesInfo.ReviewCategoryStrategy.NAME.name());
    reviewCategoryStrategy.addItem(Util.C.messageShowInReviewCategoryEmail(), AccountGeneralPreferencesInfo.ReviewCategoryStrategy.EMAIL.name());
    reviewCategoryStrategy.addItem(Util.C.messageShowInReviewCategoryUsername(), AccountGeneralPreferencesInfo.ReviewCategoryStrategy.USERNAME.name());
    reviewCategoryStrategy.addItem(Util.C.messageShowInReviewCategoryAbbrev(), AccountGeneralPreferencesInfo.ReviewCategoryStrategy.ABBREV.name());
    emailStrategy = new ListBox();
    emailStrategy.addItem(Util.C.messageEnabled(), AccountGeneralPreferencesInfo.EmailStrategy.ENABLED.name());
    emailStrategy.addItem(Util.C.messageCCMeOnMyComments(), AccountGeneralPreferencesInfo.EmailStrategy.CC_ON_OWN_COMMENTS.name());
    emailStrategy.addItem(Util.C.messageDisabled(), AccountGeneralPreferencesInfo.EmailStrategy.DISABLED.name());
    diffView = new ListBox();
    diffView.addItem(com.google.gerrit.client.changes.Util.C.sideBySide(), AccountGeneralPreferencesInfo.DiffView.SIDE_BY_SIDE.name());
    diffView.addItem(com.google.gerrit.client.changes.Util.C.unifiedDiff(), AccountGeneralPreferencesInfo.DiffView.UNIFIED_DIFF.name());
    Date now = new Date();
    dateFormat = new ListBox();
    for (AccountGeneralPreferencesInfo.DateFormat fmt : AccountGeneralPreferencesInfo.DateFormat.values()) {
        StringBuilder r = new StringBuilder();
        r.append(DateTimeFormat.getFormat(fmt.getShortFormat()).format(now));
        r.append(" ; ");
        r.append(DateTimeFormat.getFormat(fmt.getLongFormat()).format(now));
        dateFormat.addItem(r.toString(), fmt.name());
    }
    timeFormat = new ListBox();
    for (AccountGeneralPreferencesInfo.TimeFormat fmt : AccountGeneralPreferencesInfo.TimeFormat.values()) {
        StringBuilder r = new StringBuilder();
        r.append(DateTimeFormat.getFormat(fmt.getFormat()).format(now));
        timeFormat.addItem(r.toString(), fmt.name());
    }
    FlowPanel dateTimePanel = new FlowPanel();
    final int labelIdx;
    final int fieldIdx;
    if (LocaleInfo.getCurrentLocale().isRTL()) {
        labelIdx = 1;
        fieldIdx = 0;
        dateTimePanel.add(timeFormat);
        dateTimePanel.add(dateFormat);
    } else {
        labelIdx = 0;
        fieldIdx = 1;
        dateTimePanel.add(dateFormat);
        dateTimePanel.add(timeFormat);
    }
    relativeDateInChangeTable = new CheckBox(Util.C.showRelativeDateInChangeTable());
    sizeBarInChangeTable = new CheckBox(Util.C.showSizeBarInChangeTable());
    legacycidInChangeTable = new CheckBox(Util.C.showLegacycidInChangeTable());
    muteCommonPathPrefixes = new CheckBox(Util.C.muteCommonPathPrefixes());
    boolean flashClippy = !UserAgent.hasJavaScriptClipboard() && UserAgent.Flash.isInstalled();
    final Grid formGrid = new Grid(11 + (flashClippy ? 1 : 0), 2);
    int row = 0;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, showSiteHeader);
    row++;
    if (flashClippy) {
        formGrid.setText(row, labelIdx, "");
        formGrid.setWidget(row, fieldIdx, useFlashClipboard);
        row++;
    }
    formGrid.setText(row, labelIdx, Util.C.reviewCategoryLabel());
    formGrid.setWidget(row, fieldIdx, reviewCategoryStrategy);
    row++;
    formGrid.setText(row, labelIdx, Util.C.maximumPageSizeFieldLabel());
    formGrid.setWidget(row, fieldIdx, maximumPageSize);
    row++;
    formGrid.setText(row, labelIdx, Util.C.dateFormatLabel());
    formGrid.setWidget(row, fieldIdx, dateTimePanel);
    row++;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, relativeDateInChangeTable);
    row++;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, sizeBarInChangeTable);
    row++;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, legacycidInChangeTable);
    row++;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, muteCommonPathPrefixes);
    row++;
    formGrid.setText(row, labelIdx, Util.C.emailFieldLabel());
    formGrid.setWidget(row, fieldIdx, emailStrategy);
    row++;
    formGrid.setText(row, labelIdx, Util.C.diffViewLabel());
    formGrid.setWidget(row, fieldIdx, diffView);
    add(formGrid);
    save = new Button(Util.C.buttonSaveChanges());
    save.setEnabled(false);
    save.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doSave();
        }
    });
    myMenus = new MyMenuPanel(save);
    add(myMenus);
    add(save);
    final OnEditEnabler e = new OnEditEnabler(save);
    e.listenTo(showSiteHeader);
    e.listenTo(useFlashClipboard);
    e.listenTo(maximumPageSize);
    e.listenTo(dateFormat);
    e.listenTo(timeFormat);
    e.listenTo(relativeDateInChangeTable);
    e.listenTo(sizeBarInChangeTable);
    e.listenTo(legacycidInChangeTable);
    e.listenTo(muteCommonPathPrefixes);
    e.listenTo(diffView);
    e.listenTo(reviewCategoryStrategy);
    e.listenTo(emailStrategy);
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    showSiteHeader = new CheckBox(Util.C.showSiteHeader());
    useFlashClipboard = new CheckBox(Util.C.useFlashClipboard());
    maximumPageSize = new ListBox();
    for (final int v : PAGESIZE_CHOICES) {
        maximumPageSize.addItem(Util.M.rowsPerPage(v), String.valueOf(v));
    }
    reviewCategoryStrategy = new ListBox();
    reviewCategoryStrategy.addItem(Util.C.messageShowInReviewCategoryNone(), GeneralPreferencesInfo.ReviewCategoryStrategy.NONE.name());
    reviewCategoryStrategy.addItem(Util.C.messageShowInReviewCategoryName(), GeneralPreferencesInfo.ReviewCategoryStrategy.NAME.name());
    reviewCategoryStrategy.addItem(Util.C.messageShowInReviewCategoryEmail(), GeneralPreferencesInfo.ReviewCategoryStrategy.EMAIL.name());
    reviewCategoryStrategy.addItem(Util.C.messageShowInReviewCategoryUsername(), GeneralPreferencesInfo.ReviewCategoryStrategy.USERNAME.name());
    reviewCategoryStrategy.addItem(Util.C.messageShowInReviewCategoryAbbrev(), GeneralPreferencesInfo.ReviewCategoryStrategy.ABBREV.name());
    emailStrategy = new ListBox();
    emailStrategy.addItem(Util.C.messageEnabled(), GeneralPreferencesInfo.EmailStrategy.ENABLED.name());
    emailStrategy.addItem(Util.C.messageCCMeOnMyComments(), GeneralPreferencesInfo.EmailStrategy.CC_ON_OWN_COMMENTS.name());
    emailStrategy.addItem(Util.C.messageDisabled(), GeneralPreferencesInfo.EmailStrategy.DISABLED.name());
    diffView = new ListBox();
    diffView.addItem(com.google.gerrit.client.changes.Util.C.sideBySide(), GeneralPreferencesInfo.DiffView.SIDE_BY_SIDE.name());
    diffView.addItem(com.google.gerrit.client.changes.Util.C.unifiedDiff(), GeneralPreferencesInfo.DiffView.UNIFIED_DIFF.name());
    Date now = new Date();
    dateFormat = new ListBox();
    for (GeneralPreferencesInfo.DateFormat fmt : GeneralPreferencesInfo.DateFormat.values()) {
        StringBuilder r = new StringBuilder();
        r.append(DateTimeFormat.getFormat(fmt.getShortFormat()).format(now));
        r.append(" ; ");
        r.append(DateTimeFormat.getFormat(fmt.getLongFormat()).format(now));
        dateFormat.addItem(r.toString(), fmt.name());
    }
    timeFormat = new ListBox();
    for (GeneralPreferencesInfo.TimeFormat fmt : GeneralPreferencesInfo.TimeFormat.values()) {
        StringBuilder r = new StringBuilder();
        r.append(DateTimeFormat.getFormat(fmt.getFormat()).format(now));
        timeFormat.addItem(r.toString(), fmt.name());
    }
    FlowPanel dateTimePanel = new FlowPanel();
    final int labelIdx;
    final int fieldIdx;
    if (LocaleInfo.getCurrentLocale().isRTL()) {
        labelIdx = 1;
        fieldIdx = 0;
        dateTimePanel.add(timeFormat);
        dateTimePanel.add(dateFormat);
    } else {
        labelIdx = 0;
        fieldIdx = 1;
        dateTimePanel.add(dateFormat);
        dateTimePanel.add(timeFormat);
    }
    relativeDateInChangeTable = new CheckBox(Util.C.showRelativeDateInChangeTable());
    sizeBarInChangeTable = new CheckBox(Util.C.showSizeBarInChangeTable());
    legacycidInChangeTable = new CheckBox(Util.C.showLegacycidInChangeTable());
    muteCommonPathPrefixes = new CheckBox(Util.C.muteCommonPathPrefixes());
    boolean flashClippy = !UserAgent.hasJavaScriptClipboard() && UserAgent.Flash.isInstalled();
    final Grid formGrid = new Grid(11 + (flashClippy ? 1 : 0), 2);
    int row = 0;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, showSiteHeader);
    row++;
    if (flashClippy) {
        formGrid.setText(row, labelIdx, "");
        formGrid.setWidget(row, fieldIdx, useFlashClipboard);
        row++;
    }
    formGrid.setText(row, labelIdx, Util.C.reviewCategoryLabel());
    formGrid.setWidget(row, fieldIdx, reviewCategoryStrategy);
    row++;
    formGrid.setText(row, labelIdx, Util.C.maximumPageSizeFieldLabel());
    formGrid.setWidget(row, fieldIdx, maximumPageSize);
    row++;
    formGrid.setText(row, labelIdx, Util.C.dateFormatLabel());
    formGrid.setWidget(row, fieldIdx, dateTimePanel);
    row++;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, relativeDateInChangeTable);
    row++;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, sizeBarInChangeTable);
    row++;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, legacycidInChangeTable);
    row++;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, muteCommonPathPrefixes);
    row++;
    formGrid.setText(row, labelIdx, Util.C.emailFieldLabel());
    formGrid.setWidget(row, fieldIdx, emailStrategy);
    row++;
    formGrid.setText(row, labelIdx, Util.C.diffViewLabel());
    formGrid.setWidget(row, fieldIdx, diffView);
    add(formGrid);
    save = new Button(Util.C.buttonSaveChanges());
    save.setEnabled(false);
    save.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doSave();
        }
    });
    myMenus = new MyMenuPanel(save);
    add(myMenus);
    add(save);
    final OnEditEnabler e = new OnEditEnabler(save);
    e.listenTo(showSiteHeader);
    e.listenTo(useFlashClipboard);
    e.listenTo(maximumPageSize);
    e.listenTo(dateFormat);
    e.listenTo(timeFormat);
    e.listenTo(relativeDateInChangeTable);
    e.listenTo(sizeBarInChangeTable);
    e.listenTo(legacycidInChangeTable);
    e.listenTo(muteCommonPathPrefixes);
    e.listenTo(diffView);
    e.listenTo(reviewCategoryStrategy);
    e.listenTo(emailStrategy);
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    ExtensionPanel extensionPanel = createExtensionPoint(GerritUiExtensionPoint.PREFERENCES_SCREEN_BOTTOM);
    extensionPanel.addStyleName(Gerrit.RESOURCES.css().extensionPanel());
    add(extensionPanel);
    AccountApi.self().view("preferences").get(new ScreenLoadCallback<AccountPreferencesInfo>(this) {

        @Override
        public void preDisplay(AccountPreferencesInfo prefs) {
            display(prefs);
        }
    });
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    ExtensionPanel extensionPanel = createExtensionPoint(GerritUiExtensionPoint.PREFERENCES_SCREEN_BOTTOM);
    extensionPanel.addStyleName(Gerrit.RESOURCES.css().extensionPanel());
    add(extensionPanel);
    AccountApi.self().view("preferences").get(new ScreenLoadCallback<GeneralPreferences>(this) {

        @Override
        public void preDisplay(GeneralPreferences prefs) {
            display(prefs);
        }
    });
}
#end_block

#method_before
private void display(JsArray<TopMenuItem> items) {
    List<List<String>> values = new ArrayList<>();
    for (TopMenuItem item : Natives.asList(items)) {
        values.add(Arrays.asList(item.getName(), item.getUrl()));
    }
    myMenus.display(values);
}
#method_after
private void display(GeneralPreferences p) {
    showSiteHeader.setValue(p.showSiteHeader());
    useFlashClipboard.setValue(p.useFlashClipboard());
    setListBox(maximumPageSize, DEFAULT_PAGESIZE, p.changesPerPage());
    setListBox(// 
    dateFormat, // 
    GeneralPreferencesInfo.DateFormat.STD, p.dateFormat());
    setListBox(// 
    timeFormat, // 
    GeneralPreferencesInfo.TimeFormat.HHMM_12, p.timeFormat());
    relativeDateInChangeTable.setValue(p.relativeDateInChangeTable());
    sizeBarInChangeTable.setValue(p.sizeBarInChangeTable());
    legacycidInChangeTable.setValue(p.legacycidInChangeTable());
    muteCommonPathPrefixes.setValue(p.muteCommonPathPrefixes());
    setListBox(reviewCategoryStrategy, GeneralPreferencesInfo.ReviewCategoryStrategy.NONE, p.reviewCategoryStrategy());
    setListBox(diffView, GeneralPreferencesInfo.DiffView.SIDE_BY_SIDE, p.diffView());
    setListBox(emailStrategy, GeneralPreferencesInfo.EmailStrategy.ENABLED, p.emailStrategy());
    display(p.my());
}
#end_block

#method_before
private void doSave() {
    AccountPreferencesInfo p = AccountPreferencesInfo.create();
    p.showSiteHeader(showSiteHeader.getValue());
    p.useFlashClipboard(useFlashClipboard.getValue());
    p.changesPerPage(getListBox(maximumPageSize, DEFAULT_PAGESIZE));
    p.dateFormat(getListBox(dateFormat, AccountGeneralPreferencesInfo.DateFormat.STD, AccountGeneralPreferencesInfo.DateFormat.values()));
    p.timeFormat(getListBox(timeFormat, AccountGeneralPreferencesInfo.TimeFormat.HHMM_12, AccountGeneralPreferencesInfo.TimeFormat.values()));
    p.relativeDateInChangeTable(relativeDateInChangeTable.getValue());
    p.sizeBarInChangeTable(sizeBarInChangeTable.getValue());
    p.legacycidInChangeTable(legacycidInChangeTable.getValue());
    p.muteCommonPathPrefixes(muteCommonPathPrefixes.getValue());
    p.reviewCategoryStrategy(getListBox(reviewCategoryStrategy, ReviewCategoryStrategy.NONE, ReviewCategoryStrategy.values()));
    p.diffView(getListBox(diffView, AccountGeneralPreferencesInfo.DiffView.SIDE_BY_SIDE, AccountGeneralPreferencesInfo.DiffView.values()));
    p.emailStrategy(getListBox(emailStrategy, AccountGeneralPreferencesInfo.EmailStrategy.ENABLED, AccountGeneralPreferencesInfo.EmailStrategy.values()));
    List<TopMenuItem> items = new ArrayList<>();
    for (List<String> v : myMenus.getValues()) {
        items.add(TopMenuItem.create(v.get(0), v.get(1)));
    }
    p.setMyMenus(items);
    enable(false);
    save.setEnabled(false);
    AccountApi.self().view("preferences").put(p, new GerritCallback<AccountPreferencesInfo>() {

        @Override
        public void onSuccess(AccountPreferencesInfo prefs) {
            Gerrit.setUserPreferences(prefs);
            enable(true);
            display(prefs);
        }

        @Override
        public void onFailure(Throwable caught) {
            enable(true);
            save.setEnabled(true);
            super.onFailure(caught);
        }
    });
}
#method_after
private void doSave() {
    GeneralPreferences p = GeneralPreferences.create();
    p.showSiteHeader(showSiteHeader.getValue());
    p.useFlashClipboard(useFlashClipboard.getValue());
    p.changesPerPage(getListBox(maximumPageSize, DEFAULT_PAGESIZE));
    p.dateFormat(getListBox(dateFormat, GeneralPreferencesInfo.DateFormat.STD, GeneralPreferencesInfo.DateFormat.values()));
    p.timeFormat(getListBox(timeFormat, GeneralPreferencesInfo.TimeFormat.HHMM_12, GeneralPreferencesInfo.TimeFormat.values()));
    p.relativeDateInChangeTable(relativeDateInChangeTable.getValue());
    p.sizeBarInChangeTable(sizeBarInChangeTable.getValue());
    p.legacycidInChangeTable(legacycidInChangeTable.getValue());
    p.muteCommonPathPrefixes(muteCommonPathPrefixes.getValue());
    p.reviewCategoryStrategy(getListBox(reviewCategoryStrategy, ReviewCategoryStrategy.NONE, ReviewCategoryStrategy.values()));
    p.diffView(getListBox(diffView, GeneralPreferencesInfo.DiffView.SIDE_BY_SIDE, GeneralPreferencesInfo.DiffView.values()));
    p.emailStrategy(getListBox(emailStrategy, GeneralPreferencesInfo.EmailStrategy.ENABLED, GeneralPreferencesInfo.EmailStrategy.values()));
    List<TopMenuItem> items = new ArrayList<>();
    for (List<String> v : myMenus.getValues()) {
        items.add(TopMenuItem.create(v.get(0), v.get(1)));
    }
    p.setMyMenus(items);
    enable(false);
    save.setEnabled(false);
    AccountApi.self().view("preferences").put(p, new GerritCallback<GeneralPreferences>() {

        @Override
        public void onSuccess(GeneralPreferences prefs) {
            Gerrit.setUserPreferences(prefs);
            enable(true);
            display(prefs);
        }

        @Override
        public void onFailure(Throwable caught) {
            enable(true);
            save.setEnabled(true);
            super.onFailure(caught);
        }
    });
}
#end_block

#method_before
@Override
public AccountGeneralPreferencesInfo apply(AccountResource rsrc, AccountGeneralPreferencesInfo i) throws AuthException, ResourceNotFoundException, BadRequestException, OrmException, IOException, ConfigInvalidException {
    if (self.get() != rsrc.getUser() && !self.get().getCapabilities().canModifyAccount()) {
        throw new AuthException("restricted to members of Modify Accounts");
    }
    checkDownloadScheme(i);
    Account.Id id = rsrc.getUser().getAccountId();
    AccountGeneralPreferencesInfo n = readFromGit ? readFromGit(id, gitMgr, allUsersName, i) : merge(initFromDb(db.get().accounts().get(id).getGeneralPreferences()), i);
    n.my = i.my;
    n.urlAliases = i.urlAliases;
    writeToGit(id, n);
    writeToDb(id, n);
    return GetPreferences.readFromGit(id, gitMgr, allUsersName, null);
}
#method_after
@Override
public GeneralPreferencesInfo apply(AccountResource rsrc, GeneralPreferencesInfo i) throws AuthException, ResourceNotFoundException, BadRequestException, OrmException, IOException, ConfigInvalidException {
    if (self.get() != rsrc.getUser() && !self.get().getCapabilities().canModifyAccount()) {
        throw new AuthException("restricted to members of Modify Accounts");
    }
    checkDownloadScheme(i.downloadScheme);
    Account.Id id = rsrc.getUser().getAccountId();
    GeneralPreferencesInfo n = readFromGit ? readFromGit(id, gitMgr, allUsersName, i) : merge(initFromDb(db.get().accounts().get(id).getGeneralPreferences()), i);
    n.my = i.my;
    n.urlAliases = i.urlAliases;
    writeToGit(id, n);
    writeToDb(id, n);
    cache.evict(id);
    return GetPreferences.readFromGit(id, gitMgr, allUsersName, null);
}
#end_block

#method_before
private void writeToGit(Account.Id id, AccountGeneralPreferencesInfo i) throws RepositoryNotFoundException, IOException, ConfigInvalidException {
    VersionedAccountPreferences prefs;
    try (MetaDataUpdate md = metaDataUpdateFactory.get().create(allUsersName)) {
        prefs = VersionedAccountPreferences.forUser(id);
        prefs.load(md);
        storeSection(prefs.getConfig(), UserConfigSections.GENERAL, null, i, AccountGeneralPreferencesInfo.defaults());
        storeMyMenus(prefs, i.my);
        storeUrlAliases(prefs, i.urlAliases);
        prefs.commit(md);
        cache.evict(id);
    }
}
#method_after
private void writeToGit(Account.Id id, GeneralPreferencesInfo i) throws RepositoryNotFoundException, IOException, ConfigInvalidException {
    VersionedAccountPreferences prefs;
    try (MetaDataUpdate md = metaDataUpdateFactory.get().create(allUsersName)) {
        prefs = VersionedAccountPreferences.forUser(id);
        prefs.load(md);
        storeSection(prefs.getConfig(), UserConfigSections.GENERAL, null, i, GeneralPreferencesInfo.defaults());
        storeMyMenus(prefs, i.my);
        storeUrlAliases(prefs, i.urlAliases);
        prefs.commit(md);
    }
}
#end_block

#method_before
private void writeToDb(Account.Id id, AccountGeneralPreferencesInfo i) throws RepositoryNotFoundException, IOException, OrmException, ConfigInvalidException {
    VersionedAccountPreferences versionedPrefs;
    MetaDataUpdate md = metaDataUpdateFactory.get().create(allUsersName);
    db.get().accounts().beginTransaction(id);
    try {
        Account a = db.get().accounts().get(id);
        versionedPrefs = VersionedAccountPreferences.forUser(id);
        versionedPrefs.load(md);
        AccountGeneralPreferences p = a.getGeneralPreferences();
        if (p == null) {
            p = new AccountGeneralPreferences();
            a.setGeneralPreferences(p);
        }
        p = initAccountGeneralPreferences(p, i);
        db.get().accounts().update(Collections.singleton(a));
        db.get().commit();
        storeMyMenus(versionedPrefs, i.my);
        storeUrlAliases(versionedPrefs, i.urlAliases);
        versionedPrefs.commit(md);
        cache.evict(id);
    } finally {
        db.get().rollback();
    }
}
#method_after
private void writeToDb(Account.Id id, GeneralPreferencesInfo i) throws RepositoryNotFoundException, IOException, OrmException, ConfigInvalidException {
    MetaDataUpdate md = metaDataUpdateFactory.get().create(allUsersName);
    db.get().accounts().beginTransaction(id);
    try {
        Account a = db.get().accounts().get(id);
        VersionedAccountPreferences versionedPrefs = VersionedAccountPreferences.forUser(id);
        versionedPrefs.load(md);
        AccountGeneralPreferences p = a.getGeneralPreferences();
        if (p == null) {
            p = new AccountGeneralPreferences();
            a.setGeneralPreferences(p);
        }
        initAccountGeneralPreferences(p, i);
        db.get().accounts().update(Collections.singleton(a));
        db.get().commit();
        storeMyMenus(versionedPrefs, i.my);
        storeUrlAliases(versionedPrefs, i.urlAliases);
        versionedPrefs.commit(md);
    } finally {
        db.get().rollback();
    }
}
#end_block

#method_before
private void checkDownloadScheme(AccountGeneralPreferencesInfo p) throws BadRequestException {
    if (Strings.isNullOrEmpty(p.downloadScheme)) {
        return;
    }
    for (DynamicMap.Entry<DownloadScheme> e : downloadSchemes) {
        if (e.getExportName().equals(p.downloadScheme) && e.getProvider().get().isEnabled()) {
            return;
        }
    }
    throw new BadRequestException("Unsupported download scheme: " + p.downloadScheme);
}
#method_after
private void checkDownloadScheme(String downloadScheme) throws BadRequestException {
    if (Strings.isNullOrEmpty(downloadScheme)) {
        return;
    }
    for (DynamicMap.Entry<DownloadScheme> e : downloadSchemes) {
        if (e.getExportName().equals(downloadScheme) && e.getProvider().get().isEnabled()) {
            return;
        }
    }
    throw new BadRequestException("Unsupported download scheme: " + downloadScheme);
}
#end_block

#method_before
private AccountGeneralPreferencesInfo merge(AccountGeneralPreferencesInfo p, AccountGeneralPreferencesInfo i) {
    if (i.changesPerPage != null) {
        p.changesPerPage = i.changesPerPage;
    }
    if (i.showSiteHeader != null) {
        p.showSiteHeader = i.showSiteHeader;
    }
    if (i.useFlashClipboard != null) {
        p.useFlashClipboard = i.useFlashClipboard;
    }
    if (i.downloadScheme != null) {
        p.downloadScheme = i.downloadScheme;
    }
    if (i.downloadCommand != null) {
        p.downloadCommand = i.downloadCommand;
    }
    if (i.dateFormat != null) {
        p.dateFormat = i.dateFormat;
    }
    if (i.timeFormat != null) {
        p.timeFormat = i.timeFormat;
    }
    if (i.relativeDateInChangeTable != null) {
        p.relativeDateInChangeTable = i.relativeDateInChangeTable;
    }
    if (i.sizeBarInChangeTable != null) {
        p.sizeBarInChangeTable = i.sizeBarInChangeTable;
    }
    if (i.legacycidInChangeTable != null) {
        p.legacycidInChangeTable = i.legacycidInChangeTable;
    }
    if (i.muteCommonPathPrefixes != null) {
        p.muteCommonPathPrefixes = i.muteCommonPathPrefixes;
    }
    if (i.reviewCategoryStrategy != null) {
        p.reviewCategoryStrategy = i.reviewCategoryStrategy;
    }
    if (i.diffView != null) {
        p.diffView = i.diffView;
    }
    if (i.emailStrategy != null) {
        p.emailStrategy = i.emailStrategy;
    }
    return p;
}
#method_after
private GeneralPreferencesInfo merge(GeneralPreferencesInfo p, GeneralPreferencesInfo i) {
    if (i.changesPerPage != null) {
        p.changesPerPage = i.changesPerPage;
    }
    if (i.showSiteHeader != null) {
        p.showSiteHeader = i.showSiteHeader;
    }
    if (i.useFlashClipboard != null) {
        p.useFlashClipboard = i.useFlashClipboard;
    }
    if (i.downloadScheme != null) {
        p.downloadScheme = i.downloadScheme;
    }
    if (i.downloadCommand != null) {
        p.downloadCommand = i.downloadCommand;
    }
    if (i.dateFormat != null) {
        p.dateFormat = i.dateFormat;
    }
    if (i.timeFormat != null) {
        p.timeFormat = i.timeFormat;
    }
    if (i.relativeDateInChangeTable != null) {
        p.relativeDateInChangeTable = i.relativeDateInChangeTable;
    }
    if (i.sizeBarInChangeTable != null) {
        p.sizeBarInChangeTable = i.sizeBarInChangeTable;
    }
    if (i.legacycidInChangeTable != null) {
        p.legacycidInChangeTable = i.legacycidInChangeTable;
    }
    if (i.muteCommonPathPrefixes != null) {
        p.muteCommonPathPrefixes = i.muteCommonPathPrefixes;
    }
    if (i.reviewCategoryStrategy != null) {
        p.reviewCategoryStrategy = i.reviewCategoryStrategy;
    }
    if (i.diffView != null) {
        p.diffView = i.diffView;
    }
    if (i.emailStrategy != null) {
        p.emailStrategy = i.emailStrategy;
    }
    return p;
}
#end_block

#method_before
private static AccountGeneralPreferences initAccountGeneralPreferences(AccountGeneralPreferences a, AccountGeneralPreferencesInfo i) {
    if (a == null) {
        a = AccountGeneralPreferences.createDefault();
    }
    a.setMaximumPageSize((short) (int) i.changesPerPage);
    a.setShowSiteHeader(b(i.showSiteHeader));
    a.setUseFlashClipboard(i.useFlashClipboard);
    a.setDownloadUrl(i.downloadScheme);
    if (i.downloadCommand != null) {
        a.setDownloadCommand(DownloadCommand.valueOf(i.downloadCommand.name()));
    }
    a.setEmailStrategy(EmailStrategy.valueOf(i.getEmailStrategy().name()));
    a.setDateFormat(DateFormat.valueOf(i.getDateFormat().name()));
    a.setTimeFormat(TimeFormat.valueOf(i.getTimeFormat().name()));
    a.setRelativeDateInChangeTable(b(i.relativeDateInChangeTable));
    a.setSizeBarInChangeTable(b(i.sizeBarInChangeTable));
    a.setLegacycidInChangeTable(b(i.legacycidInChangeTable));
    a.setMuteCommonPathPrefixes(b(i.muteCommonPathPrefixes));
    a.setReviewCategoryStrategy(ReviewCategoryStrategy.valueOf(i.getReviewCategoryStrategy().name()));
    a.setDiffView(DiffView.valueOf(i.getDiffView().name()));
    return a;
}
#method_after
private static void initAccountGeneralPreferences(AccountGeneralPreferences a, GeneralPreferencesInfo i) {
    if (a == null) {
        a = AccountGeneralPreferences.createDefault();
    }
    a.setMaximumPageSize((short) (int) i.changesPerPage);
    a.setShowSiteHeader(b(i.showSiteHeader));
    a.setUseFlashClipboard(b(i.useFlashClipboard));
    a.setDownloadUrl(i.downloadScheme);
    if (i.downloadCommand != null) {
        a.setDownloadCommand(DownloadCommand.valueOf(i.downloadCommand.name()));
    }
    a.setEmailStrategy(EmailStrategy.valueOf(i.getEmailStrategy().name()));
    a.setDateFormat(DateFormat.valueOf(i.getDateFormat().name()));
    a.setTimeFormat(TimeFormat.valueOf(i.getTimeFormat().name()));
    a.setRelativeDateInChangeTable(b(i.relativeDateInChangeTable));
    a.setSizeBarInChangeTable(b(i.sizeBarInChangeTable));
    a.setLegacycidInChangeTable(b(i.legacycidInChangeTable));
    a.setMuteCommonPathPrefixes(b(i.muteCommonPathPrefixes));
    a.setReviewCategoryStrategy(ReviewCategoryStrategy.valueOf(i.getReviewCategoryStrategy().name()));
    a.setDiffView(DiffView.valueOf(i.getDiffView().name()));
}
#end_block

#method_before
@Override
public AccountGeneralPreferencesInfo apply(ConfigResource rsrc) throws IOException, ConfigInvalidException {
    try (Repository git = gitMgr.openRepository(allUsersName)) {
        VersionedAccountPreferences p = VersionedAccountPreferences.forDefault();
        p.load(git);
        AccountGeneralPreferencesInfo a = new AccountGeneralPreferencesInfo();
        return loadFromAllUsers(a, p, git);
    }
}
#method_after
@Override
public GeneralPreferencesInfo apply(ConfigResource rsrc) throws IOException, ConfigInvalidException {
    try (Repository git = gitMgr.openRepository(allUsersName)) {
        VersionedAccountPreferences p = VersionedAccountPreferences.forDefault();
        p.load(git);
        GeneralPreferencesInfo a = new GeneralPreferencesInfo();
        return loadFromAllUsers(a, p, git);
    }
}
#end_block

#method_before
private static String status(Status status) {
    switch(status) {
        case ABANDONED:
            return "status:abandoned";
        case DRAFT:
            return "status:draft";
        case MERGED:
            return "status:merged";
        case NEW:
        default:
            return "status:open";
    }
}
#method_after
private static String status(Status status) {
    switch(status) {
        case ABANDONED:
            return "status:abandoned";
        case MERGED:
            return "status:merged";
        case DRAFT:
        case NEW:
        default:
            return "status:open";
    }
}
#end_block

#method_before
private void reportMessages() {
    Iterable<CreateRequest> created = Iterables.filter(newChanges, new Predicate<CreateRequest>() {

        @Override
        public boolean apply(CreateRequest input) {
            return input.created;
        }
    });
    if (!Iterables.isEmpty(created)) {
        addMessage("");
        addMessage("New Changes:");
        for (CreateRequest c : created) {
            addMessage(formatChangeUrl(canonicalWebUrl, c.change, false));
        }
        addMessage("");
    }
    List<ReplaceRequest> updated = FluentIterable.from(replaceByChange.values()).filter(new Predicate<ReplaceRequest>() {

        @Override
        public boolean apply(ReplaceRequest input) {
            return !input.skip && input.inputCommand.getResult() == OK;
        }
    }).toSortedList(Ordering.natural().onResultOf(new Function<ReplaceRequest, Integer>() {

        @Override
        public Integer apply(ReplaceRequest in) {
            return in.change.getId().get();
        }
    }));
    if (!updated.isEmpty()) {
        addMessage("");
        addMessage("Updated Changes:");
        boolean edit = magicBranch != null && magicBranch.edit;
        for (ReplaceRequest u : updated) {
            addMessage(formatChangeUrl(canonicalWebUrl, u.change, edit));
        }
        addMessage("");
    }
}
#method_after
private void reportMessages() {
    Iterable<CreateRequest> created = Iterables.filter(newChanges, new Predicate<CreateRequest>() {

        @Override
        public boolean apply(CreateRequest input) {
            return input.change != null;
        }
    });
    if (!Iterables.isEmpty(created)) {
        addMessage("");
        addMessage("New Changes:");
        for (CreateRequest c : created) {
            addMessage(formatChangeUrl(canonicalWebUrl, c.change, false));
        }
        addMessage("");
    }
    List<ReplaceRequest> updated = FluentIterable.from(replaceByChange.values()).filter(new Predicate<ReplaceRequest>() {

        @Override
        public boolean apply(ReplaceRequest input) {
            return !input.skip && input.inputCommand.getResult() == OK;
        }
    }).toSortedList(Ordering.natural().onResultOf(new Function<ReplaceRequest, Integer>() {

        @Override
        public Integer apply(ReplaceRequest in) {
            return in.change.getId().get();
        }
    }));
    if (!updated.isEmpty()) {
        addMessage("");
        addMessage("Updated Changes:");
        boolean edit = magicBranch != null && magicBranch.edit;
        for (ReplaceRequest u : updated) {
            addMessage(formatChangeUrl(canonicalWebUrl, u.change, edit));
        }
        addMessage("");
    }
}
#end_block

#method_before
private void selectNewAndReplacedChangesFromMagicBranch() {
    newChanges = Lists.newArrayList();
    SetMultimap<ObjectId, Ref> existing = changeRefsById();
    GroupCollector groupCollector = new GroupCollector(refsById, db);
    rp.getRevWalk().reset();
    rp.getRevWalk().sort(RevSort.TOPO);
    rp.getRevWalk().sort(RevSort.REVERSE, true);
    try {
        rp.getRevWalk().markStart(rp.getRevWalk().parseCommit(magicBranch.cmd.getNewId()));
        if (magicBranch.baseCommit != null) {
            for (RevCommit c : magicBranch.baseCommit) {
                rp.getRevWalk().markUninteresting(c);
            }
            Ref targetRef = allRefs.get(magicBranch.ctl.getRefName());
            if (targetRef != null) {
                rp.getRevWalk().markUninteresting(rp.getRevWalk().parseCommit(targetRef.getObjectId()));
            }
        } else {
            markHeadsAsUninteresting(rp.getRevWalk(), magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
        }
        List<ChangeLookup> pending = Lists.newArrayList();
        final Set<Change.Key> newChangeIds = new HashSet<>();
        final int maxBatchChanges = receiveConfig.getEffectiveMaxBatchChangesLimit(user);
        for (; ; ) {
            final RevCommit c = rp.getRevWalk().next();
            if (c == null) {
                break;
            }
            groupCollector.visit(c);
            Collection<Ref> existingRefs = existing.get(c);
            if (!existingRefs.isEmpty()) {
                // A's group.
                for (Ref ref : existingRefs) {
                    updateGroups.add(new UpdateGroupsRequest(ref, c));
                }
                continue;
            }
            if (!validCommit(magicBranch.ctl, magicBranch.cmd, c)) {
                // Not a change the user can propose? Abort as early as possible.
                newChanges = Collections.emptyList();
                return;
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
            }
            Change.Key changeKey = new Change.Key("I" + c.name());
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(magicBranch.ctl, c, changeKey));
                continue;
            }
            final String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                newChanges = Collections.emptyList();
                return;
            }
            changeKey = new Change.Key(idStr);
            pending.add(new ChangeLookup(c, changeKey));
            if (maxBatchChanges != 0 && pending.size() + newChanges.size() > maxBatchChanges) {
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                newChanges = Collections.emptyList();
                return;
            }
        }
        for (ChangeLookup p : pending) {
            if (newChangeIds.contains(p.changeKey)) {
                reject(magicBranch.cmd, "squash commits first");
                newChanges = Collections.emptyList();
                return;
            }
            List<ChangeData> changes = p.destChanges;
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 1) {
                // 
                if (requestReplace(magicBranch.cmd, false, changes.get(0).change(), p.commit)) {
                    continue;
                } else {
                    newChanges = Collections.emptyList();
                    return;
                }
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    newChanges = Collections.emptyList();
                    return;
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(magicBranch.ctl, p.commit, p.changeKey));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        newChanges = Collections.emptyList();
        return;
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        newChanges = Collections.emptyList();
        return;
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return;
    }
    if (!newChanges.isEmpty() && magicBranch.edit) {
        reject(magicBranch.cmd, "edit is not supported for new changes");
        return;
    }
    try {
        Multimap<ObjectId, String> groups = groupCollector.getGroups();
        for (CreateRequest create : newChanges) {
            batch.addCommand(create.cmd);
            create.groups = groups.get(create.commit);
        }
        for (ReplaceRequest replace : replaceByChange.values()) {
            replace.groups = groups.get(replace.newCommit);
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.groups = Sets.newHashSet(groups.get(update.commit));
        }
    } catch (OrmException e) {
        log.error("Error collecting groups for changes", e);
        reject(magicBranch.cmd, "internal server error");
        return;
    }
}
#method_after
private void selectNewAndReplacedChangesFromMagicBranch() {
    newChanges = Lists.newArrayList();
    SetMultimap<ObjectId, Ref> existing = changeRefsById();
    GroupCollector groupCollector = new GroupCollector(refsById, db);
    rp.getRevWalk().reset();
    rp.getRevWalk().sort(RevSort.TOPO);
    rp.getRevWalk().sort(RevSort.REVERSE, true);
    try {
        rp.getRevWalk().markStart(rp.getRevWalk().parseCommit(magicBranch.cmd.getNewId()));
        if (magicBranch.baseCommit != null) {
            for (RevCommit c : magicBranch.baseCommit) {
                rp.getRevWalk().markUninteresting(c);
            }
            Ref targetRef = allRefs.get(magicBranch.ctl.getRefName());
            if (targetRef != null) {
                rp.getRevWalk().markUninteresting(rp.getRevWalk().parseCommit(targetRef.getObjectId()));
            }
        } else {
            markHeadsAsUninteresting(rp.getRevWalk(), magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
        }
        List<ChangeLookup> pending = Lists.newArrayList();
        final Set<Change.Key> newChangeIds = new HashSet<>();
        final int maxBatchChanges = receiveConfig.getEffectiveMaxBatchChangesLimit(user);
        for (; ; ) {
            final RevCommit c = rp.getRevWalk().next();
            if (c == null) {
                break;
            }
            groupCollector.visit(c);
            Collection<Ref> existingRefs = existing.get(c);
            if (!existingRefs.isEmpty()) {
                // A's group.
                for (Ref ref : existingRefs) {
                    updateGroups.add(new UpdateGroupsRequest(ref, c));
                }
                continue;
            }
            if (!validCommit(magicBranch.ctl, magicBranch.cmd, c)) {
                // Not a change the user can propose? Abort as early as possible.
                newChanges = Collections.emptyList();
                return;
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
            }
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(c, magicBranch.dest.get()));
                continue;
            }
            final String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                newChanges = Collections.emptyList();
                return;
            }
            pending.add(new ChangeLookup(c, new Change.Key(idStr)));
            if (maxBatchChanges != 0 && pending.size() + newChanges.size() > maxBatchChanges) {
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                newChanges = Collections.emptyList();
                return;
            }
        }
        for (ChangeLookup p : pending) {
            if (newChangeIds.contains(p.changeKey)) {
                reject(magicBranch.cmd, "squash commits first");
                newChanges = Collections.emptyList();
                return;
            }
            List<ChangeData> changes = p.destChanges;
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 1) {
                // 
                if (requestReplace(magicBranch.cmd, false, changes.get(0).change(), p.commit)) {
                    continue;
                } else {
                    newChanges = Collections.emptyList();
                    return;
                }
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    newChanges = Collections.emptyList();
                    return;
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(p.commit, magicBranch.dest.get()));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        newChanges = Collections.emptyList();
        return;
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        newChanges = Collections.emptyList();
        return;
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return;
    }
    if (!newChanges.isEmpty() && magicBranch.edit) {
        reject(magicBranch.cmd, "edit is not supported for new changes");
        return;
    }
    try {
        Multimap<ObjectId, String> groups = groupCollector.getGroups();
        for (CreateRequest create : newChanges) {
            batch.addCommand(create.cmd);
            create.groups = groups.get(create.commit);
        }
        for (ReplaceRequest replace : replaceByChange.values()) {
            replace.groups = groups.get(replace.newCommit);
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.groups = Sets.newHashSet(groups.get(update.commit));
        }
    } catch (OrmException e) {
        log.error("Error collecting groups for changes", e);
        reject(magicBranch.cmd, "internal server error");
        return;
    }
}
#end_block

#method_before
private void insertChange(ReviewDb threadLocalDb) throws OrmException, RestApiException, UpdateException {
    final PatchSet ps = ins.setGroups(groups).getPatchSet();
    final Account.Id me = user.getAccountId();
    final List<FooterLine> footerLines = commit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    Map<String, Short> approvals = new HashMap<>();
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.labels;
    }
    recipients.add(getRecipientsFromFooters(accountResolver, ps, footerLines));
    recipients.remove(me);
    String msg = renderMessageWithApprovals(ps.getPatchSetId(), null, approvals, Collections.<String, PatchSetApproval>emptyMap());
    try (ObjectInserter oi = repo.newObjectInserter();
        BatchUpdate bu = batchUpdateFactory.create(threadLocalDb, change.getProject(), user, change.getCreatedOn())) {
        bu.setRepository(repo, rp.getRevWalk(), oi);
        bu.insertChange(ins.setReviewers(recipients.getReviewers()).setExtraCC(recipients.getCcOnly()).setApprovals(approvals).setMessage(msg).setRequestScopePropagator(requestScopePropagator).setSendMail(true).setUpdateRef(false));
        if (magicBranch != null) {
            bu.addOp(ins.getChange().getId(), hashtagsFactory.create(new HashtagsInput(magicBranch.hashtags)).setRunHooks(false));
            if (!Strings.isNullOrEmpty(magicBranch.topic)) {
                bu.addOp(ins.getChange().getId(), new BatchUpdate.Op() {

                    @Override
                    public void updateChange(ChangeContext ctx) throws Exception {
                        ctx.getUpdate(ps.getId()).setTopic(magicBranch.topic);
                    }
                });
            }
        }
        bu.execute();
    }
    created = true;
    change = ins.getChange();
    if (magicBranch != null && magicBranch.submit) {
        submit(projectControl.controlFor(change), ps);
    }
}
#method_after
private void insertChange(ReviewDb threadLocalDb) throws OrmException, RestApiException, UpdateException {
    final PatchSet.Id psId = ins.setGroups(groups).getPatchSetId();
    final Account.Id me = user.getAccountId();
    final List<FooterLine> footerLines = commit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    Map<String, Short> approvals = new HashMap<>();
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.labels;
    }
    recipients.add(getRecipientsFromFooters(accountResolver, magicBranch.draft, footerLines));
    recipients.remove(me);
    String msg = renderMessageWithApprovals(psId.get(), null, approvals, Collections.<String, PatchSetApproval>emptyMap());
    try (ObjectInserter oi = repo.newObjectInserter();
        BatchUpdate bu = batchUpdateFactory.create(threadLocalDb, magicBranch.dest.getParentKey(), user, TimeUtil.nowTs())) {
        bu.setRepository(repo, rp.getRevWalk(), oi);
        bu.insertChange(ins.setReviewers(recipients.getReviewers()).setExtraCC(recipients.getCcOnly()).setApprovals(approvals).setMessage(msg).setRequestScopePropagator(requestScopePropagator).setSendMail(true).setUpdateRef(false));
        if (magicBranch != null) {
            bu.addOp(changeId, hashtagsFactory.create(new HashtagsInput(magicBranch.hashtags)).setRunHooks(false));
            if (!Strings.isNullOrEmpty(magicBranch.topic)) {
                bu.addOp(changeId, new BatchUpdate.Op() {

                    @Override
                    public boolean updateChange(ChangeContext ctx) {
                        ctx.getUpdate(psId).setTopic(magicBranch.topic);
                        return true;
                    }
                });
            }
        }
        bu.execute();
    }
    change = ins.getChange();
    if (magicBranch != null && magicBranch.submit) {
        submit(projectControl.controlFor(change), ins.getPatchSet());
    }
}
#end_block

#method_before
private void submit(ChangeControl changeCtl, PatchSet ps) throws OrmException, ResourceConflictException {
    Submit submit = submitProvider.get();
    RevisionResource rsrc = new RevisionResource(changes.parse(changeCtl), ps);
    try (MergeOp op = mergeOpProvider.get()) {
        op.merge(db, rsrc.getChange(), changeCtl.getUser().asIdentifiedUser(), false);
    }
    addMessage("");
    Change c = db.changes().get(rsrc.getChange().getId());
    switch(c.getStatus()) {
        case MERGED:
            addMessage("Change " + c.getChangeId() + " merged.");
            break;
        case NEW:
            ChangeMessage msg = submit.getConflictMessage(rsrc);
            if (msg != null) {
                addMessage("Change " + c.getChangeId() + ": " + msg.getMessage());
                break;
            }
        // $FALL-THROUGH$
        case ABANDONED:
        case DRAFT:
        default:
            addMessage("change " + c.getChangeId() + " is " + c.getStatus().name().toLowerCase());
    }
}
#method_after
private void submit(ChangeControl changeCtl, PatchSet ps) throws OrmException, RestApiException {
    Submit submit = submitProvider.get();
    RevisionResource rsrc = new RevisionResource(changes.parse(changeCtl), ps);
    try (MergeOp op = mergeOpProvider.get()) {
        op.merge(db, rsrc.getChange(), changeCtl.getUser().asIdentifiedUser(), false);
    }
    addMessage("");
    Change c = db.changes().get(rsrc.getChange().getId());
    switch(c.getStatus()) {
        case MERGED:
            addMessage("Change " + c.getChangeId() + " merged.");
            break;
        case NEW:
            ChangeMessage msg = submit.getConflictMessage(rsrc);
            if (msg != null) {
                addMessage("Change " + c.getChangeId() + ": " + msg.getMessage());
                break;
            }
        // $FALL-THROUGH$
        case ABANDONED:
        case DRAFT:
        default:
            addMessage("change " + c.getChangeId() + " is " + c.getStatus().name().toLowerCase());
    }
}
#end_block

#method_before
private boolean newEdit() {
    newPatchSet = new PatchSet(change.currentPatchSetId());
    Optional<ChangeEdit> edit = null;
    try {
        edit = editUtil.byChange(change, user);
    } catch (IOException e) {
        log.error("Cannt retrieve edit", e);
        return false;
    }
    if (edit.isPresent()) {
        if (edit.get().getBasePatchSet().getId().equals(newPatchSet.getId())) {
            // replace edit
            cmd = new ReceiveCommand(edit.get().getRef().getObjectId(), newCommit, edit.get().getRefName());
        } else {
            // delete old edit ref on rebase
            prev = new ReceiveCommand(edit.get().getRef().getObjectId(), ObjectId.zeroId(), edit.get().getRefName());
            createEditCommand();
        }
    } else {
        createEditCommand();
    }
    return true;
}
#method_after
private boolean newEdit() {
    psId = change.currentPatchSetId();
    Optional<ChangeEdit> edit = null;
    try {
        edit = editUtil.byChange(changeCtl);
    } catch (AuthException | IOException e) {
        log.error("Cannt retrieve edit", e);
        return false;
    }
    if (edit.isPresent()) {
        if (edit.get().getBasePatchSet().getId().equals(psId)) {
            // replace edit
            cmd = new ReceiveCommand(edit.get().getRef().getObjectId(), newCommit, edit.get().getRefName());
        } else {
            // delete old edit ref on rebase
            prev = new ReceiveCommand(edit.get().getRef().getObjectId(), ObjectId.zeroId(), edit.get().getRefName());
            createEditCommand();
        }
    } else {
        createEditCommand();
    }
    return true;
}
#end_block

#method_before
private void createEditCommand() {
    // create new edit
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommit, RefNames.refsEdit(user.getAccountId(), change.getId(), newPatchSet.getId()));
}
#method_after
private void createEditCommand() {
    // create new edit
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommit, RefNames.refsEdit(user.getAccountId(), change.getId(), psId));
}
#end_block

#method_before
private void newPatchSet() throws IOException {
    PatchSet.Id id = ChangeUtil.nextPatchSetId(allRefs, change.currentPatchSetId());
    newPatchSet = new PatchSet(id);
    newPatchSet.setCreatedOn(TimeUtil.nowTs());
    newPatchSet.setUploader(user.getAccountId());
    newPatchSet.setRevision(toRevId(newCommit));
    newPatchSet.setGroups(groups);
    if (rp.getPushCertificate() != null) {
        newPatchSet.setPushCertificate(rp.getPushCertificate().toTextWithSignature());
    }
    if (magicBranch != null && magicBranch.draft) {
        newPatchSet.setDraft(true);
    }
    info = patchSetInfoFactory.get(rp.getRevWalk(), newCommit, newPatchSet.getId());
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommit, newPatchSet.getRefName());
}
#method_after
private void newPatchSet() throws IOException {
    psId = ChangeUtil.nextPatchSetId(allRefs, change.currentPatchSetId());
    info = patchSetInfoFactory.get(rp.getRevWalk(), newCommit, psId);
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommit, psId.toRefName());
}
#end_block

#method_before
CheckedFuture<PatchSet.Id, RestApiException> insertPatchSet() throws IOException {
    rp.getRevWalk().parseBody(newCommit);
    final Thread caller = Thread.currentThread();
    ListenableFuture<PatchSet.Id> future = changeUpdateExector.submit(requestScopePropagator.wrap(new Callable<PatchSet.Id>() {

        @Override
        public PatchSet.Id call() throws OrmException, IOException, NoSuchChangeException, ResourceConflictException {
            try {
                if (magicBranch != null && magicBranch.edit) {
                    return upsertEdit();
                } else if (caller == Thread.currentThread()) {
                    return insertPatchSet(db);
                } else {
                    try (ReviewDb db = schemaFactory.open()) {
                        return insertPatchSet(db);
                    }
                }
            } finally {
                synchronizedIncrement(replaceProgress);
            }
        }
    }));
    return Futures.makeChecked(future, INSERT_EXCEPTION);
}
#method_after
CheckedFuture<PatchSet.Id, RestApiException> insertPatchSet() throws IOException {
    rp.getRevWalk().parseBody(newCommit);
    final Thread caller = Thread.currentThread();
    ListenableFuture<PatchSet.Id> future = changeUpdateExector.submit(requestScopePropagator.wrap(new Callable<PatchSet.Id>() {

        @Override
        public PatchSet.Id call() throws OrmException, IOException, RestApiException {
            try {
                if (magicBranch != null && magicBranch.edit) {
                    return upsertEdit();
                } else if (caller == Thread.currentThread()) {
                    return insertPatchSet(db);
                } else {
                    try (ReviewDb db = schemaFactory.open()) {
                        return insertPatchSet(db);
                    }
                }
            } finally {
                synchronizedIncrement(replaceProgress);
            }
        }
    }));
    return Futures.makeChecked(future, INSERT_EXCEPTION);
}
#end_block

#method_before
private ChangeMessage newChangeMessage(ReviewDb db, ChangeKind changeKind, Map<String, Short> approvals) throws OrmException {
    msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), user.getAccountId(), newPatchSet.getCreatedOn(), newPatchSet.getId());
    msg.setMessage(renderMessageWithApprovals(newPatchSet.getPatchSetId(), changeKindMessage(changeKind), approvals, scanLabels(db, approvals)));
    return msg;
}
#method_after
private ChangeMessage newChangeMessage(ReviewDb db, ChangeKind changeKind, Map<String, Short> approvals) throws OrmException {
    msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), user.getAccountId(), createdOn, psId);
    msg.setMessage(renderMessageWithApprovals(psId.get(), changeKindMessage(changeKind), approvals, scanLabels(db, approvals)));
    return msg;
}
#end_block

#method_before
PatchSet.Id upsertEdit() {
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    return newPatchSet.getId();
}
#method_after
PatchSet.Id upsertEdit() {
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    return psId;
}
#end_block

#method_before
PatchSet.Id insertPatchSet(ReviewDb db) throws OrmException, IOException, ResourceConflictException {
    final Account.Id me = user.getAccountId();
    final List<FooterLine> footerLines = newCommit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    Map<String, Short> approvals = new HashMap<>();
    ChangeUpdate update = updateFactory.create(changeCtl, newPatchSet.getCreatedOn());
    update.setPatchSetId(newPatchSet.getId());
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.labels;
        Set<String> hashtags = magicBranch.hashtags;
        ChangeNotes notes = changeCtl.getNotes().load();
        if (!hashtags.isEmpty()) {
            hashtags.addAll(notes.getHashtags());
            update.setHashtags(hashtags);
        }
        if (magicBranch.topic != null && !magicBranch.topic.equals(notes.getChange().getTopic())) {
            update.setTopic(magicBranch.topic);
        }
    }
    recipients.add(getRecipientsFromFooters(accountResolver, newPatchSet, footerLines));
    recipients.remove(me);
    db.changes().beginTransaction(change.getId());
    ChangeKind changeKind = ChangeKind.REWORK;
    try {
        change = db.changes().get(change.getId());
        if (change == null || change.getStatus().isClosed()) {
            reject(inputCommand, "change is closed");
            return null;
        }
        if (newPatchSet.getGroups() == null) {
            newPatchSet.setGroups(GroupCollector.getCurrentGroups(db, change));
        }
        db.patchSets().insert(Collections.singleton(newPatchSet));
        if (checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), newCommit);
            mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        ChangeData cd = changeDataFactory.create(db, changeCtl);
        MailRecipients oldRecipients = getRecipientsFromReviewers(cd.reviewers());
        approvalCopier.copy(db, changeCtl, newPatchSet);
        approvalsUtil.addReviewers(db, update, labelTypes, change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
        approvalsUtil.addApprovals(db, update, labelTypes, newPatchSet, changeCtl, approvals);
        recipients.add(oldRecipients);
        RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
        changeKind = changeKindCache.getChangeKind(projectControl.getProjectState(), repo, priorCommit, newCommit);
        cmUtil.addChangeMessage(db, update, newChangeMessage(db, changeKind, approvals));
        if (mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isClosed()) {
                        return null;
                    }
                    if (!change.currentPatchSetId().equals(priorPatchSet)) {
                        return change;
                    }
                    if (magicBranch != null && magicBranch.topic != null) {
                        change.setTopic(magicBranch.topic);
                    }
                    if (change.getStatus() == Change.Status.DRAFT && newPatchSet.isDraft()) {
                    // Leave in draft status.
                    } else {
                        change.setStatus(Change.Status.NEW);
                    }
                    change.setCurrentPatchSet(info);
                    final List<String> idList = newCommit.getFooterLines(CHANGE_ID);
                    if (idList.isEmpty()) {
                        change.setKey(new Change.Key("I" + newCommit.name()));
                    } else {
                        change.setKey(new Change.Key(idList.get(idList.size() - 1).trim()));
                    }
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(newPatchSet));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(inputCommand, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    if (mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, this, changeCtl);
    }
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    indexer.index(db, change);
    if (changeKind != ChangeKind.TRIVIAL_REBASE) {
        workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

            @Override
            public void run() {
                try {
                    ReplacePatchSetSender cm = replacePatchSetFactory.create(change.getId());
                    cm.setFrom(me);
                    cm.setPatchSet(newPatchSet, info);
                    cm.setChangeMessage(msg);
                    cm.addReviewers(recipients.getReviewers());
                    cm.addExtraCC(recipients.getCcOnly());
                    cm.send();
                } catch (Exception e) {
                    log.error("Cannot send email for new patch set " + newPatchSet.getId(), e);
                }
                if (mergedIntoRef != null) {
                    sendMergedEmail(ReplaceRequest.this);
                }
            }

            @Override
            public String toString() {
                return "send-email newpatchset";
            }
        }));
    }
    gitRefUpdated.fire(project.getNameKey(), newPatchSet.getRefName(), ObjectId.zeroId(), newCommit);
    hooks.doPatchsetCreatedHook(change, newPatchSet, db);
    if (mergedIntoRef != null) {
        hooks.doChangeMergedHook(change, user.getAccount(), newPatchSet, db, newCommit.getName());
    }
    if (!approvals.isEmpty()) {
        hooks.doCommentAddedHook(change, user.getAccount(), newPatchSet, null, approvals, db);
    }
    if (magicBranch != null && magicBranch.submit) {
        submit(changeCtl, newPatchSet);
    }
    return newPatchSet.getId();
}
#method_after
PatchSet.Id insertPatchSet(ReviewDb db) throws OrmException, IOException, RestApiException {
    final Account.Id me = user.getAccountId();
    final List<FooterLine> footerLines = newCommit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    final PatchSet newPatchSet;
    Map<String, Short> approvals = new HashMap<>();
    ChangeUpdate update = updateFactory.create(changeCtl, createdOn);
    update.setSubject("Create patch set " + psId.get());
    update.setPatchSetId(psId);
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.labels;
        Set<String> hashtags = magicBranch.hashtags;
        ChangeNotes notes = changeCtl.getNotes().load();
        if (!hashtags.isEmpty()) {
            hashtags.addAll(notes.getHashtags());
            update.setHashtags(hashtags);
        }
        if (magicBranch.topic != null && !magicBranch.topic.equals(notes.getChange().getTopic())) {
            update.setTopic(magicBranch.topic);
        }
    }
    db.changes().beginTransaction(change.getId());
    ChangeKind changeKind = ChangeKind.REWORK;
    try {
        change = db.changes().get(change.getId());
        if (change == null || change.getStatus().isClosed()) {
            reject(inputCommand, "change is closed");
            return null;
        }
        Iterable<String> newGroups = groups;
        if (newGroups == null) {
            PatchSet prevPs = psUtil.current(db, update.getChangeNotes());
            newGroups = prevPs != null ? prevPs.getGroups() : null;
        }
        boolean draft = magicBranch != null && magicBranch.draft;
        newPatchSet = psUtil.insert(db, update, psId, newCommit, draft, newGroups, rp.getPushCertificate() != null ? rp.getPushCertificate().toTextWithSignature() : null);
        if (checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), newCommit);
            mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        recipients.add(getRecipientsFromFooters(accountResolver, draft, footerLines));
        recipients.remove(me);
        ChangeData cd = changeDataFactory.create(db, changeCtl);
        MailRecipients oldRecipients = getRecipientsFromReviewers(cd.reviewers());
        approvalCopier.copy(db, changeCtl, newPatchSet);
        approvalsUtil.addReviewers(db, update, labelTypes, change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
        approvalsUtil.addApprovals(db, update, labelTypes, newPatchSet, changeCtl, approvals);
        recipients.add(oldRecipients);
        RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
        changeKind = changeKindCache.getChangeKind(projectControl.getProjectState(), repo, priorCommit, newCommit);
        cmUtil.addChangeMessage(db, update, newChangeMessage(db, changeKind, approvals));
        if (mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isClosed()) {
                        return null;
                    }
                    if (!change.currentPatchSetId().equals(priorPatchSet)) {
                        return change;
                    }
                    if (magicBranch != null && magicBranch.topic != null) {
                        change.setTopic(magicBranch.topic);
                    }
                    if (change.getStatus() == Change.Status.DRAFT && newPatchSet.isDraft()) {
                    // Leave in draft status.
                    } else {
                        change.setStatus(Change.Status.NEW);
                    }
                    change.setCurrentPatchSet(info);
                    final List<String> idList = newCommit.getFooterLines(CHANGE_ID);
                    if (idList.isEmpty()) {
                        change.setKey(new Change.Key("I" + newCommit.name()));
                    } else {
                        change.setKey(new Change.Key(idList.get(idList.size() - 1).trim()));
                    }
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(newPatchSet));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(inputCommand, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    if (mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, info, mergedIntoRef, changeCtl);
    }
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    indexer.index(db, change);
    if (changeKind != ChangeKind.TRIVIAL_REBASE) {
        sendEmailExecutor.submit(requestScopePropagator.wrap(new Runnable() {

            @Override
            public void run() {
                try {
                    ReplacePatchSetSender cm = replacePatchSetFactory.create(change.getId());
                    cm.setFrom(me);
                    cm.setPatchSet(newPatchSet, info);
                    cm.setChangeMessage(msg);
                    cm.addReviewers(recipients.getReviewers());
                    cm.addExtraCC(recipients.getCcOnly());
                    cm.send();
                } catch (Exception e) {
                    log.error("Cannot send email for new patch set " + newPatchSet.getId(), e);
                }
                if (mergedIntoRef != null) {
                    sendMergedEmail(newPatchSet, info);
                }
            }

            @Override
            public String toString() {
                return "send-email newpatchset";
            }
        }));
    }
    gitRefUpdated.fire(project.getNameKey(), newPatchSet.getRefName(), ObjectId.zeroId(), newCommit);
    hooks.doPatchsetCreatedHook(change, newPatchSet, db);
    if (mergedIntoRef != null) {
        hooks.doChangeMergedHook(change, user.getAccount(), newPatchSet, db, newCommit.getName());
    }
    if (!approvals.isEmpty()) {
        hooks.doCommentAddedHook(change, user.getAccount(), newPatchSet, null, approvals, db);
    }
    if (magicBranch != null && magicBranch.submit) {
        submit(changeCtl, newPatchSet);
    }
    return newPatchSet.getId();
}
#end_block

#method_before
private Change.Key closeChange(final ReceiveCommand cmd, final PatchSet.Id psi, final RevCommit commit) throws OrmException, IOException {
    final String refName = cmd.getRefName();
    final Change.Id cid = psi.getParentKey();
    final Change change = db.changes().get(cid);
    final PatchSet ps = db.patchSets().get(psi);
    if (change == null || ps == null) {
        log.warn(project.getName() + " " + psi + " is missing");
        return null;
    }
    if (change.getStatus() == Change.Status.MERGED || change.getStatus() == Change.Status.ABANDONED || !change.getDest().get().equals(refName)) {
        // 
        return null;
    }
    ReplaceRequest result = new ReplaceRequest(cid, commit, cmd, false);
    result.change = change;
    result.changeCtl = projectControl.controlFor(change);
    result.newPatchSet = ps;
    result.info = patchSetInfoFactory.get(rp.getRevWalk(), commit, psi);
    result.mergedIntoRef = refName;
    markChangeMergedByPush(db, result, result.changeCtl);
    hooks.doChangeMergedHook(change, user.getAccount(), result.newPatchSet, db, commit.getName());
    sendMergedEmail(result);
    return change.getKey();
}
#method_after
private Change.Key closeChange(ReceiveCommand cmd, PatchSet.Id psi, RevCommit commit) throws OrmException, IOException {
    String refName = cmd.getRefName();
    Change.Id cid = psi.getParentKey();
    Change change = db.changes().get(cid);
    ChangeControl ctl = projectControl.controlFor(change);
    PatchSet ps = psUtil.get(db, ctl.getNotes(), psi);
    if (change == null || ps == null) {
        log.warn(project.getName() + " " + psi + " is missing");
        return null;
    }
    if (change.getStatus() == Change.Status.MERGED || change.getStatus() == Change.Status.ABANDONED || !change.getDest().get().equals(refName)) {
        // 
        return null;
    }
    PatchSetInfo info = patchSetInfoFactory.get(rp.getRevWalk(), commit, psi);
    markChangeMergedByPush(db, info, refName, ctl);
    hooks.doChangeMergedHook(change, user.getAccount(), ps, db, commit.getName());
    sendMergedEmail(ps, info);
    return change.getKey();
}
#end_block

#method_before
private void markChangeMergedByPush(ReviewDb db, final ReplaceRequest result, ChangeControl control) throws OrmException, IOException {
    Change.Id id = result.change.getId();
    db.changes().beginTransaction(id);
    Change change;
    ChangeUpdate update;
    try {
        change = db.changes().atomicUpdate(id, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.setCurrentPatchSet(result.info);
                    change.setStatus(Change.Status.MERGED);
                    ChangeUtil.updated(change);
                }
                return change;
            }
        });
        String mergedIntoRef = result.mergedIntoRef;
        StringBuilder msgBuf = new StringBuilder();
        msgBuf.append("Change has been successfully pushed");
        if (!mergedIntoRef.equals(change.getDest().get())) {
            msgBuf.append(" into ");
            if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
                msgBuf.append("branch ");
                msgBuf.append(Repository.shortenRefName(mergedIntoRef));
            } else {
                msgBuf.append(mergedIntoRef);
            }
        }
        msgBuf.append(".");
        ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(id, ChangeUtil.messageUUID(db)), user.getAccountId(), change.getLastUpdatedOn(), result.info.getKey());
        msg.setMessage(msgBuf.toString());
        update = updateFactory.create(control, change.getLastUpdatedOn());
        cmUtil.addChangeMessage(db, update, msg);
        db.commit();
    } finally {
        db.rollback();
    }
    indexer.index(db, change);
    update.commit();
}
#method_after
private void markChangeMergedByPush(ReviewDb db, final PatchSetInfo info, String mergedIntoRef, ChangeControl control) throws OrmException, IOException {
    Change.Id id = info.getKey().getParentKey();
    db.changes().beginTransaction(id);
    Change change;
    ChangeUpdate update;
    try {
        change = db.changes().atomicUpdate(id, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.setCurrentPatchSet(info);
                    change.setStatus(Change.Status.MERGED);
                    ChangeUtil.updated(change);
                }
                return change;
            }
        });
        StringBuilder msgBuf = new StringBuilder();
        msgBuf.append("Change has been successfully pushed");
        if (!mergedIntoRef.equals(change.getDest().get())) {
            msgBuf.append(" into ");
            if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
                msgBuf.append("branch ");
                msgBuf.append(Repository.shortenRefName(mergedIntoRef));
            } else {
                msgBuf.append(mergedIntoRef);
            }
        }
        msgBuf.append(".");
        ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(id, ChangeUtil.messageUUID(db)), user.getAccountId(), change.getLastUpdatedOn(), info.getKey());
        msg.setMessage(msgBuf.toString());
        update = updateFactory.create(control, change.getLastUpdatedOn());
        cmUtil.addChangeMessage(db, update, msg);
        db.commit();
    } finally {
        db.rollback();
    }
    indexer.index(db, change);
    update.commit();
}
#end_block

#method_before
private void sendMergedEmail(final ReplaceRequest result) {
    final Change.Id id = result.change.getId();
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                final MergedSender cm = mergedSenderFactory.create(id);
                cm.setFrom(user.getAccountId());
                cm.setPatchSet(result.newPatchSet, result.info);
                cm.send();
            } catch (Exception e) {
                final PatchSet.Id psi = result.newPatchSet.getId();
                log.error("Cannot send email for submitted patch set " + psi, e);
            }
        }

        @Override
        public String toString() {
            return "send-email merged";
        }
    }));
}
#method_after
private void sendMergedEmail(final PatchSet ps, final PatchSetInfo info) {
    sendEmailExecutor.submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                MergedSender cm = mergedSenderFactory.create(ps.getId().getParentKey());
                cm.setFrom(user.getAccountId());
                cm.setPatchSet(ps, info);
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for submitted patch set " + ps.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send-email merged";
        }
    }));
}
#end_block

#method_before
public Optional<ChangeEdit> byChange(Change change) throws AuthException, IOException {
    CurrentUser currentUser = user.get();
    if (!currentUser.isIdentifiedUser()) {
        throw new AuthException("Authentication required");
    }
    return byChange(change, currentUser.asIdentifiedUser());
}
#method_after
public Optional<ChangeEdit> byChange(Change change) throws AuthException, IOException {
    try {
        return byChange(changeControlFactory.controlFor(change, user.get()));
    } catch (NoSuchChangeException e) {
        throw new IOException(e);
    }
}
#end_block

#method_before
public Optional<ChangeEdit> byChange(Change change, IdentifiedUser user) throws IOException {
    try (Repository repo = gitManager.openRepository(change.getProject())) {
        int n = change.currentPatchSetId().get();
        String[] refNames = new String[n];
        for (int i = n; i > 0; i--) {
            refNames[i - 1] = RefNames.refsEdit(user.getAccountId(), change.getId(), new PatchSet.Id(change.getId(), i));
        }
        Ref ref = repo.getRefDatabase().firstExactRef(refNames);
        if (ref == null) {
            return Optional.absent();
        }
        try (RevWalk rw = new RevWalk(repo)) {
            RevCommit commit = rw.parseCommit(ref.getObjectId());
            PatchSet basePs = getBasePatchSet(change, ref);
            return Optional.of(new ChangeEdit(user, change, ref, commit, basePs));
        }
    }
}
#method_after
public Optional<ChangeEdit> byChange(ChangeControl ctl) throws AuthException, IOException {
    if (!ctl.getUser().isIdentifiedUser()) {
        throw new AuthException("Authentication required");
    }
    IdentifiedUser u = ctl.getUser().asIdentifiedUser();
    Change change = ctl.getChange();
    try (Repository repo = gitManager.openRepository(change.getProject())) {
        int n = change.currentPatchSetId().get();
        String[] refNames = new String[n];
        for (int i = n; i > 0; i--) {
            refNames[i - 1] = RefNames.refsEdit(u.getAccountId(), change.getId(), new PatchSet.Id(change.getId(), i));
        }
        Ref ref = repo.getRefDatabase().firstExactRef(refNames);
        if (ref == null) {
            return Optional.absent();
        }
        try (RevWalk rw = new RevWalk(repo)) {
            RevCommit commit = rw.parseCommit(ref.getObjectId());
            PatchSet basePs = getBasePatchSet(ctl, ref);
            return Optional.of(new ChangeEdit(u, change, ref, commit, basePs));
        }
    }
}
#end_block

#method_before
private PatchSet getBasePatchSet(Change change, Ref ref) throws IOException {
    try {
        int pos = ref.getName().lastIndexOf("/");
        checkArgument(pos > 0, "invalid edit ref: %s", ref.getName());
        String psId = ref.getName().substring(pos + 1);
        return db.get().patchSets().get(new PatchSet.Id(change.getId(), Integer.parseInt(psId)));
    } catch (OrmException | NumberFormatException e) {
        throw new IOException(e);
    }
}
#method_after
private PatchSet getBasePatchSet(ChangeControl ctl, Ref ref) throws IOException {
    try {
        int pos = ref.getName().lastIndexOf("/");
        checkArgument(pos > 0, "invalid edit ref: %s", ref.getName());
        String psId = ref.getName().substring(pos + 1);
        return psUtil.get(db.get(), ctl.getNotes(), new PatchSet.Id(ctl.getId(), Integer.parseInt(psId)));
    } catch (OrmException | NumberFormatException e) {
        throw new IOException(e);
    }
}
#end_block

#method_before
private void checkExpectMergedAs() {
    ObjectId objId = parseObjectId(fix.expectMergedAs, "expected merged commit");
    RevCommit commit = parseCommit(objId, "expected merged commit");
    if (commit == null) {
        return;
    }
    if (Objects.equals(commit, currPsCommit)) {
        // Caller gave us latest patch set SHA-1; verified in checkPatchSets.
        return;
    }
    try {
        if (!rw.isMergedInto(commit, tip)) {
            problem(String.format("Expected merged commit %s is not merged into" + " destination ref %s (%s)", commit.name(), change.getDest().get(), tip.name()));
            return;
        }
        RevId revId = new RevId(commit.name());
        List<PatchSet> patchSets = FluentIterable.from(db.get().patchSets().byRevision(revId)).filter(new Predicate<PatchSet>() {

            @Override
            public boolean apply(PatchSet ps) {
                try {
                    Change c = db.get().changes().get(ps.getId().getParentKey());
                    return c != null && c.getDest().equals(change.getDest());
                } catch (OrmException e) {
                    warn(e);
                    // Should cause an error below, that's good.
                    return true;
                }
            }
        }).toSortedList(ChangeUtil.PS_ID_ORDER);
        switch(patchSets.size()) {
            case 0:
                // No patch set for this commit; insert one.
                rw.parseBody(commit);
                String changeId = Iterables.getFirst(commit.getFooterLines(FooterConstants.CHANGE_ID), null);
                // Missing Change-Id footer is ok, but mismatched is not.
                if (changeId != null && !changeId.equals(change.getKey().get())) {
                    problem(String.format("Expected merged commit %s has Change-Id: %s," + " but expected %s", commit.name(), changeId, change.getKey().get()));
                    return;
                }
                PatchSet.Id psId = insertPatchSet(commit);
                if (psId != null) {
                    checkMergedBitMatchesStatus(psId, commit, true);
                }
                break;
            case 1:
                // Existing patch set of this commit; check that it is the current
                // patch set.
                // TODO(dborowitz): This could be fixed if it's an older patch set of
                // the current change.
                PatchSet.Id id = patchSets.get(0).getId();
                if (!id.equals(change.currentPatchSetId())) {
                    problem(String.format("Expected merged commit %s corresponds to" + " patch set %s, which is not the current patch set %s", commit.name(), id, change.currentPatchSetId()));
                }
                break;
            default:
                problem(String.format("Multiple patch sets for expected merged commit %s: %s", commit.name(), patchSets));
                break;
        }
    } catch (OrmException | IOException e) {
        error("Error looking up expected merged commit " + fix.expectMergedAs, e);
    }
}
#method_after
private void checkExpectMergedAs() {
    ObjectId objId = parseObjectId(fix.expectMergedAs, "expected merged commit");
    RevCommit commit = parseCommit(objId, "expected merged commit");
    if (commit == null) {
        return;
    }
    if (Objects.equals(commit, currPsCommit)) {
        // Caller gave us latest patch set SHA-1; verified in checkPatchSets.
        return;
    }
    try {
        if (!rw.isMergedInto(commit, tip)) {
            problem(String.format("Expected merged commit %s is not merged into" + " destination ref %s (%s)", commit.name(), change.getDest().get(), tip.name()));
            return;
        }
        List<PatchSet.Id> psIds = new ArrayList<>();
        for (Ref ref : repo.getRefDatabase().getRefs(REFS_CHANGES).values()) {
            if (!ref.getObjectId().equals(commit)) {
                continue;
            }
            PatchSet.Id psId = PatchSet.Id.fromRef(ref.getName());
            if (psId == null) {
                continue;
            }
            try {
                Change c = db.get().changes().get(psId.getParentKey());
                if (c == null || !c.getDest().equals(change.getDest())) {
                    continue;
                }
            } catch (OrmException e) {
                warn(e);
            // Include this patch set; should cause an error below, which is good.
            }
            psIds.add(psId);
        }
        switch(psIds.size()) {
            case 0:
                // No patch set for this commit; insert one.
                rw.parseBody(commit);
                String changeId = Iterables.getFirst(commit.getFooterLines(FooterConstants.CHANGE_ID), null);
                // Missing Change-Id footer is ok, but mismatched is not.
                if (changeId != null && !changeId.equals(change.getKey().get())) {
                    problem(String.format("Expected merged commit %s has Change-Id: %s," + " but expected %s", commit.name(), changeId, change.getKey().get()));
                    return;
                }
                PatchSet.Id psId = insertPatchSet(commit);
                if (psId != null) {
                    checkMergedBitMatchesStatus(psId, commit, true);
                }
                break;
            case 1:
                // Existing patch set of this commit; check that it is the current
                // patch set.
                // TODO(dborowitz): This could be fixed if it's an older patch set of
                // the current change.
                PatchSet.Id id = psIds.get(0);
                if (!id.equals(change.currentPatchSetId())) {
                    problem(String.format("Expected merged commit %s corresponds to" + " patch set %s, which is not the current patch set %s", commit.name(), id, change.currentPatchSetId()));
                }
                break;
            default:
                problem(String.format("Multiple patch sets for expected merged commit %s: %s", commit.name(), intKeyOrdering().sortedCopy(psIds)));
                break;
        }
    } catch (IOException e) {
        error("Error looking up expected merged commit " + fix.expectMergedAs, e);
    }
}
#end_block

#method_before
private PatchSet.Id insertPatchSet(RevCommit commit) {
    ProblemInfo p = problem("No patch set found for merged commit " + commit.name());
    if (!user.get().isIdentifiedUser()) {
        p.status = Status.FIX_FAILED;
        p.outcome = "Must be called by an identified user to insert new patch set";
        return null;
    }
    try {
        RefControl ctl = projectControlFactory.controlFor(change.getProject(), user.get()).controlForRef(change.getDest());
        PatchSet.Id psId = ChangeUtil.nextPatchSetId(repo, change.currentPatchSetId());
        PatchSetInserter inserter = patchSetInserterFactory.create(ctl, psId, commit);
        try (BatchUpdate bu = updateFactory.create(db.get(), change.getProject(), ctl.getUser(), TimeUtil.nowTs());
            ObjectInserter oi = repo.newObjectInserter()) {
            bu.setRepository(repo, rw, oi);
            bu.addOp(change.getId(), inserter.setValidatePolicy(CommitValidators.Policy.NONE).setRunHooks(false).setSendMail(false).setAllowClosed(true).setUploader(user.get().getAccountId()).setMessage("Patch set for merged commit inserted by consistency checker"));
            bu.execute();
        }
        change = inserter.getChange();
        p.status = Status.FIXED;
        p.outcome = "Inserted as patch set " + psId.get();
        return psId;
    } catch (IOException | NoSuchProjectException | UpdateException | RestApiException e) {
        warn(e);
        p.status = Status.FIX_FAILED;
        p.outcome = "Error inserting new patch set";
        return null;
    }
}
#method_after
private PatchSet.Id insertPatchSet(RevCommit commit) {
    ProblemInfo p = problem("No patch set found for merged commit " + commit.name());
    if (!user.get().isIdentifiedUser()) {
        p.status = Status.FIX_FAILED;
        p.outcome = "Must be called by an identified user to insert new patch set";
        return null;
    }
    try {
        RefControl ctl = projectControlFactory.controlFor(change.getProject(), user.get()).controlForRef(change.getDest());
        PatchSet.Id psId = ChangeUtil.nextPatchSetId(repo, change.currentPatchSetId());
        PatchSetInserter inserter = patchSetInserterFactory.create(ctl, psId, commit);
        try (BatchUpdate bu = updateFactory.create(db.get(), change.getProject(), ctl.getUser(), TimeUtil.nowTs());
            ObjectInserter oi = repo.newObjectInserter()) {
            bu.setRepository(repo, rw, oi);
            bu.addOp(change.getId(), inserter.setValidatePolicy(CommitValidators.Policy.NONE).setRunHooks(false).setSendMail(false).setAllowClosed(true).setMessage("Patch set for merged commit inserted by consistency checker"));
            bu.execute();
        }
        change = inserter.getChange();
        p.status = Status.FIXED;
        p.outcome = "Inserted as patch set " + psId.get();
        return psId;
    } catch (IOException | NoSuchProjectException | UpdateException | RestApiException e) {
        warn(e);
        p.status = Status.FIX_FAILED;
        p.outcome = "Error inserting new patch set";
        return null;
    }
}
#end_block

#method_before
private void deletePatchSet(ProblemInfo p, PatchSet.Id psId) {
    ReviewDb db = this.db.get();
    Change.Id cid = psId.getParentKey();
    try {
        db.changes().beginTransaction(cid);
        try {
            Change c = db.changes().get(cid);
            if (c == null) {
                throw new OrmException("Change missing: " + cid);
            }
            if (psId.equals(c.currentPatchSetId())) {
                List<PatchSet> all = Lists.newArrayList(db.patchSets().byChange(cid));
                if (all.size() == 1 && all.get(0).getId().equals(psId)) {
                    p.status = Status.FIX_FAILED;
                    p.outcome = "Cannot delete patch set; no patch sets would remain";
                    return;
                }
                // If there were multiple missing patch sets, assumes deletePatchSet
                // has been called in decreasing order, so the max remaining PatchSet
                // is the effective current patch set.
                Collections.sort(all, PS_ID_ORDER.reverse());
                PatchSet.Id latest = null;
                for (PatchSet ps : all) {
                    latest = ps.getId();
                    if (!ps.getId().equals(psId)) {
                        break;
                    }
                }
                c.setCurrentPatchSet(patchSetInfoFactory.get(db, latest));
                db.changes().update(Collections.singleton(c));
            }
            // Delete dangling primary key references. Don't delete ChangeMessages,
            // which don't use patch sets as a primary key, and may provide useful
            // historical information.
            db.accountPatchReviews().delete(db.accountPatchReviews().byPatchSet(psId));
            db.patchSetApprovals().delete(db.patchSetApprovals().byPatchSet(psId));
            db.patchComments().delete(db.patchComments().byPatchSet(psId));
            db.patchSets().deleteKeys(Collections.singleton(psId));
            db.commit();
            p.status = Status.FIXED;
            p.outcome = "Deleted patch set";
        } finally {
            db.rollback();
        }
    } catch (PatchSetInfoNotAvailableException | OrmException e) {
        String msg = "Error deleting patch set";
        log.warn(msg + ' ' + psId, e);
        p.status = Status.FIX_FAILED;
        p.outcome = msg;
    }
}
#method_after
private void deletePatchSet(ProblemInfo p, PatchSet.Id psId) {
    ReviewDb db = this.db.get();
    Change.Id cid = psId.getParentKey();
    try {
        db.changes().beginTransaction(cid);
        try {
            Change c = db.changes().get(cid);
            if (c == null) {
                throw new OrmException("Change missing: " + cid);
            }
            ChangeNotes notes = notesFactory.create(c);
            if (psId.equals(c.currentPatchSetId())) {
                List<PatchSet> all = Lists.newArrayList(db.patchSets().byChange(cid));
                if (all.size() == 1 && all.get(0).getId().equals(psId)) {
                    p.status = Status.FIX_FAILED;
                    p.outcome = "Cannot delete patch set; no patch sets would remain";
                    return;
                }
                // If there were multiple missing patch sets, assumes deletePatchSet
                // has been called in decreasing order, so the max remaining PatchSet
                // is the effective current patch set.
                Collections.sort(all, PS_ID_ORDER.reverse());
                PatchSet.Id latest = null;
                for (PatchSet ps : all) {
                    latest = ps.getId();
                    if (!ps.getId().equals(psId)) {
                        break;
                    }
                }
                c.setCurrentPatchSet(patchSetInfoFactory.get(db, notes, latest));
                db.changes().update(Collections.singleton(c));
            }
            // Delete dangling primary key references. Don't delete ChangeMessages,
            // which don't use patch sets as a primary key, and may provide useful
            // historical information.
            db.accountPatchReviews().delete(db.accountPatchReviews().byPatchSet(psId));
            db.patchSetApprovals().delete(db.patchSetApprovals().byPatchSet(psId));
            db.patchComments().delete(db.patchComments().byPatchSet(psId));
            db.patchSets().deleteKeys(Collections.singleton(psId));
            db.commit();
            p.status = Status.FIXED;
            p.outcome = "Deleted patch set";
        } finally {
            db.rollback();
        }
    } catch (PatchSetInfoNotAvailableException | OrmException e) {
        String msg = "Error deleting patch set";
        log.warn(msg + ' ' + psId, e);
        p.status = Status.FIX_FAILED;
        p.outcome = msg;
    }
}
#end_block

#method_before
@Override
public Output apply(RevisionResource rsrc, SubmitInput input) throws AuthException, ResourceConflictException, RepositoryNotFoundException, IOException, OrmException, UnprocessableEntityException {
    input.onBehalfOf = Strings.emptyToNull(input.onBehalfOf);
    if (input.onBehalfOf != null) {
        rsrc = onBehalfOf(rsrc, input);
    }
    ChangeControl control = rsrc.getControl();
    IdentifiedUser caller = control.getUser().asIdentifiedUser();
    Change change = rsrc.getChange();
    if (input.onBehalfOf == null && !control.canSubmit()) {
        throw new AuthException("submit not permitted");
    } else if (!change.getStatus().isOpen()) {
        throw new ResourceConflictException("change is " + status(change));
    } else if (!ProjectUtil.branchExists(repoManager, change.getDest())) {
        throw new ResourceConflictException(String.format("destination branch \"%s\" not found.", change.getDest().get()));
    } else if (!rsrc.getPatchSet().getId().equals(change.currentPatchSetId())) {
        // TODO Allow submitting non-current revision by changing the current.
        throw new ResourceConflictException(String.format("revision %s is not current revision", rsrc.getPatchSet().getRevision().get()));
    }
    try (MergeOp op = mergeOpProvider.get()) {
        ReviewDb db = dbProvider.get();
        op.merge(db, change, caller, true);
        change = db.changes().get(change.getId());
    }
    if (change == null) {
        throw new ResourceConflictException("change is deleted");
    }
    switch(change.getStatus()) {
        case MERGED:
            return new Output(change);
        case NEW:
            ChangeMessage msg = getConflictMessage(rsrc);
            if (msg != null) {
                throw new ResourceConflictException(msg.getMessage());
            }
        // $FALL-THROUGH$
        case ABANDONED:
        case DRAFT:
        default:
            throw new ResourceConflictException("change is " + status(change));
    }
}
#method_after
@Override
public Output apply(RevisionResource rsrc, SubmitInput input) throws RestApiException, RepositoryNotFoundException, IOException, OrmException {
    input.onBehalfOf = Strings.emptyToNull(input.onBehalfOf);
    if (input.onBehalfOf != null) {
        rsrc = onBehalfOf(rsrc, input);
    }
    ChangeControl control = rsrc.getControl();
    IdentifiedUser caller = control.getUser().asIdentifiedUser();
    Change change = rsrc.getChange();
    if (input.onBehalfOf == null && !control.canSubmit()) {
        throw new AuthException("submit not permitted");
    } else if (!change.getStatus().isOpen()) {
        throw new ResourceConflictException("change is " + status(change));
    } else if (!ProjectUtil.branchExists(repoManager, change.getDest())) {
        throw new ResourceConflictException(String.format("destination branch \"%s\" not found.", change.getDest().get()));
    } else if (!rsrc.getPatchSet().getId().equals(change.currentPatchSetId())) {
        // TODO Allow submitting non-current revision by changing the current.
        throw new ResourceConflictException(String.format("revision %s is not current revision", rsrc.getPatchSet().getRevision().get()));
    }
    try (MergeOp op = mergeOpProvider.get()) {
        ReviewDb db = dbProvider.get();
        op.merge(db, change, caller, true);
        change = db.changes().get(change.getId());
    }
    if (change == null) {
        throw new ResourceConflictException("change is deleted");
    }
    switch(change.getStatus()) {
        case MERGED:
            return new Output(change);
        case NEW:
            ChangeMessage msg = getConflictMessage(rsrc);
            if (msg != null) {
                throw new ResourceConflictException(msg.getMessage());
            }
        // $FALL-THROUGH$
        case ABANDONED:
        case DRAFT:
        default:
            throw new ResourceConflictException("change is " + status(change));
    }
}
#end_block

#method_before
@Override
public ChangeInfo apply(ChangeResource rsrc, SubmitInput input) throws AuthException, ResourceConflictException, RepositoryNotFoundException, IOException, OrmException, UnprocessableEntityException {
    PatchSet ps = dbProvider.get().patchSets().get(rsrc.getChange().currentPatchSetId());
    if (ps == null) {
        throw new ResourceConflictException("current revision is missing");
    } else if (!rsrc.getControl().isPatchVisible(ps, dbProvider.get())) {
        throw new AuthException("current revision not accessible");
    }
    Output out = submit.apply(new RevisionResource(rsrc, ps), input);
    return json.create(ChangeJson.NO_OPTIONS).format(out.change);
}
#method_after
@Override
public ChangeInfo apply(ChangeResource rsrc, SubmitInput input) throws RestApiException, RepositoryNotFoundException, IOException, OrmException {
    PatchSet ps = dbProvider.get().patchSets().get(rsrc.getChange().currentPatchSetId());
    if (ps == null) {
        throw new ResourceConflictException("current revision is missing");
    } else if (!rsrc.getControl().isPatchVisible(ps, dbProvider.get())) {
        throw new AuthException("current revision not accessible");
    }
    Output out = submit.apply(new RevisionResource(rsrc, ps), input);
    return json.create(ChangeJson.NO_OPTIONS).format(out.change);
}
#end_block

#method_before
@Override
public List<EmailInfo> apply(AccountResource rsrc) throws AuthException, OrmException {
    if (self.get() != rsrc.getUser() && self.get().getUserName() != rsrc.getUser().getUserName() && !self.get().getCapabilities().canViewAllAccounts()) {
        throw new AuthException("not allowed to list email addresses");
    }
    List<EmailInfo> emails = Lists.newArrayList();
    for (String email : rsrc.getUser().getEmailAddresses()) {
        if (email != null) {
            EmailInfo e = new EmailInfo();
            e.email = email;
            e.preferred(rsrc.getUser().getAccount().getPreferredEmail());
            emails.add(e);
        }
    }
    Collections.sort(emails, new Comparator<EmailInfo>() {

        @Override
        public int compare(EmailInfo a, EmailInfo b) {
            return a.email.compareTo(b.email);
        }
    });
    return emails;
}
#method_after
@Override
public List<EmailInfo> apply(AccountResource rsrc) {
    List<EmailInfo> emails = Lists.newArrayList();
    for (String email : rsrc.getUser().getEmailAddresses()) {
        if (email != null) {
            EmailInfo e = new EmailInfo();
            e.email = email;
            e.preferred(rsrc.getUser().getAccount().getPreferredEmail());
            emails.add(e);
        }
    }
    Collections.sort(emails, new Comparator<EmailInfo>() {

        @Override
        public int compare(EmailInfo a, EmailInfo b) {
            return a.email.compareTo(b.email);
        }
    });
    return emails;
}
#end_block

#method_before
private void integrateIntoHistory(ChangeSet cs, IdentifiedUser caller) throws IntegrationException, NoSuchChangeException, ResourceConflictException {
    logDebug("Beginning merge attempt on {}", cs);
    Map<Branch.NameKey, BranchBatch> toSubmit = new HashMap<>();
    logDebug("Perform the merges");
    try {
        Multimap<Project.NameKey, Branch.NameKey> br = cs.branchesByProject();
        Multimap<Branch.NameKey, ChangeData> cbb = cs.changesByBranch();
        for (Project.NameKey project : br.keySet()) {
            OpenRepo or = openRepo(project);
            for (Branch.NameKey branch : br.get(project)) {
                setDestProject(branch);
                BranchBatch submitting = validateChangeList(or, cbb.get(branch));
                toSubmit.put(branch, submitting);
                OpenBranch ob = or.getBranch(branch);
                SubmitStrategy strategy = createStrategy(or, branch, submitting.submitType(), ob.oldTip, caller);
                ob.mergeTip = preMerge(strategy, submitting.changes(), ob.oldTip);
                updateChangeStatus(ob, submitting.changes(), true, caller);
                or.ins.flush();
            }
        }
        Set<Branch.NameKey> done = Sets.newHashSetWithExpectedSize(cbb.keySet().size());
        logDebug("Write out the new branch tips");
        SubmoduleOp subOp = subOpProvider.get();
        for (Project.NameKey project : br.keySet()) {
            OpenRepo or = openRepo(project);
            for (Branch.NameKey branch : br.get(project)) {
                OpenBranch ob = or.getBranch(branch);
                boolean updated = updateBranch(or, branch, caller);
                setDestProject(branch);
                BranchBatch submitting = toSubmit.get(branch);
                updateChangeStatus(ob, submitting.changes(), false, caller);
                updateSubmoduleSubscriptions(ob, subOp);
                if (updated) {
                    fireRefUpdated(ob);
                }
                done.add(branch);
            }
        }
        updateSuperProjects(subOp, br.values());
        checkState(done.equals(cbb.keySet()), "programmer error: did not process " + " all branches in input set.\nExpected: %s\nActual: %s", done, cbb.keySet());
    } catch (NoSuchProjectException noProject) {
        logWarn("Project " + noProject.project() + " no longer exists, " + "abandoning open changes");
        abandonAllOpenChanges(noProject.project());
    } catch (OrmException e) {
        throw new IntegrationException("Cannot query the database", e);
    } catch (IOException e) {
        throw new IntegrationException("Cannot query the database", e);
    }
}
#method_after
private void integrateIntoHistory(ChangeSet cs, IdentifiedUser caller) throws IntegrationException, NoSuchChangeException, ResourceConflictException {
    logDebug("Beginning merge attempt on {}", cs);
    Map<Branch.NameKey, BranchBatch> toSubmit = new HashMap<>();
    logDebug("Perform the merges");
    try {
        Multimap<Project.NameKey, Branch.NameKey> br = cs.branchesByProject();
        Multimap<Branch.NameKey, ChangeData> cbb = cs.changesByBranch();
        for (Project.NameKey project : br.keySet()) {
            OpenRepo or = openRepo(project);
            for (Branch.NameKey branch : br.get(project)) {
                setDestProject(branch);
                BranchBatch submitting = validateChangeList(or, cbb.get(branch));
                toSubmit.put(branch, submitting);
                OpenBranch ob = or.getBranch(branch);
                SubmitStrategy strategy = createStrategy(or, branch, submitting.submitType(), ob.oldTip, caller);
                ob.mergeTip = preMerge(strategy, submitting.changes(), ob.oldTip);
                updateChangeStatus(ob, submitting.changes(), true, caller);
                or.ins.flush();
            }
        }
        Set<Branch.NameKey> done = Sets.newHashSetWithExpectedSize(cbb.keySet().size());
        logDebug("Write out the new branch tips");
        SubmoduleOp subOp = subOpProvider.get();
        for (Project.NameKey project : br.keySet()) {
            OpenRepo or = openRepo(project);
            for (Branch.NameKey branch : br.get(project)) {
                OpenBranch ob = or.getBranch(branch);
                boolean updated = updateBranch(or, branch, caller);
                setDestProject(branch);
                BranchBatch submitting = toSubmit.get(branch);
                updateChangeStatus(ob, submitting.changes(), false, caller);
                updateSubmoduleSubscriptions(ob, subOp);
                if (updated) {
                    fireRefUpdated(ob);
                }
                done.add(branch);
            }
        }
        updateSuperProjects(subOp, br.values());
        checkState(done.equals(cbb.keySet()), "programmer error: did not process" + " all branches in input set.\nExpected: %s\nActual: %s", done, cbb.keySet());
    } catch (NoSuchProjectException noProject) {
        logWarn("Project " + noProject.project() + " no longer exists, " + "abandoning open changes");
        abandonAllOpenChanges(noProject.project());
    } catch (OrmException e) {
        throw new IntegrationException("Cannot query the database", e);
    } catch (IOException e) {
        throw new IntegrationException("Cannot query the database", e);
    }
}
#end_block

#method_before
private static Optional<SubmitRecord> findOkRecord(Collection<SubmitRecord> in) {
    return Iterables.tryFind(in, new Predicate<SubmitRecord>() {

        @Override
        public boolean apply(SubmitRecord input) {
            return input.status == SubmitRecord.Status.OK;
        }
    });
}
#method_after
private static Optional<SubmitRecord> findOkRecord(Collection<SubmitRecord> in) {
    if (in == null) {
        return Optional.absent();
    }
    return Iterables.tryFind(in, new Predicate<SubmitRecord>() {

        @Override
        public boolean apply(SubmitRecord input) {
            return input.status == SubmitRecord.Status.OK;
        }
    });
}
#end_block

#method_before
public static void checkSubmitRule(ChangeData cd) throws ResourceConflictException, OrmException {
    PatchSet patchSet = cd.currentPatchSet();
    if (patchSet == null) {
        throw new ResourceConflictException("missing current patch set for change " + cd.getId());
    }
    List<SubmitRecord> results = cd.getSubmitRecords();
    if (results == null) {
        results = new SubmitRuleEvaluator(cd).setPatchSet(patchSet).evaluate();
        cd.setSubmitRecords(results);
    }
    if (findOkRecord(results).isPresent()) {
        // Rules supplied a valid solution.
        return;
    } else if (results.isEmpty()) {
        throw new IllegalStateException(String.format("SubmitRuleEvaluator.evaluate for change %s " + "returned empty list for %s in %s", cd.getId(), patchSet.getId(), cd.change().getProject().get()));
    }
    for (SubmitRecord record : results) {
        switch(record.status) {
            case CLOSED:
                throw new ResourceConflictException(String.format("change %s is closed", cd.getId()));
            case RULE_ERROR:
                throw new ResourceConflictException(String.format("rule error for change %s: %s", cd.getId(), record.errorMessage));
            case NOT_READY:
                StringBuilder msg = new StringBuilder();
                msg.append(cd.getId() + ":");
                for (SubmitRecord.Label lbl : record.labels) {
                    switch(lbl.status) {
                        case OK:
                        case MAY:
                            continue;
                        case REJECT:
                            msg.append(" blocked by ").append(lbl.label);
                            msg.append(";");
                            continue;
                        case NEED:
                            msg.append(" needs ").append(lbl.label);
                            msg.append(";");
                            continue;
                        case IMPOSSIBLE:
                            msg.append(" needs ").append(lbl.label).append(" (check project access)");
                            msg.append(";");
                            continue;
                        default:
                            throw new IllegalStateException(String.format("Unsupported SubmitRecord.Label %s for %s in %s in %s", lbl.toString(), patchSet.getId(), cd.getId(), cd.change().getProject().get()));
                    }
                }
                throw new ResourceConflictException(msg.toString());
            default:
                throw new IllegalStateException(String.format("Unsupported SubmitRecord %s for %s in %s", record, patchSet.getId().getId(), cd.change().getProject().get()));
        }
    }
    throw new IllegalStateException();
}
#method_after
public static void checkSubmitRule(ChangeData cd) throws ResourceConflictException, OrmException {
    PatchSet patchSet = cd.currentPatchSet();
    if (patchSet == null) {
        throw new ResourceConflictException("missing current patch set for change " + cd.getId());
    }
    List<SubmitRecord> results = cd.getSubmitRecords();
    if (results == null) {
        results = new SubmitRuleEvaluator(cd).setPatchSet(patchSet).evaluate();
        cd.setSubmitRecords(results);
    }
    if (findOkRecord(results).isPresent()) {
        // Rules supplied a valid solution.
        return;
    } else if (results.isEmpty()) {
        throw new IllegalStateException(String.format("SubmitRuleEvaluator.evaluate for change %s " + "returned empty list for %s in %s", cd.getId(), patchSet.getId(), cd.change().getProject().get()));
    }
    for (SubmitRecord record : results) {
        switch(record.status) {
            case CLOSED:
                throw new ResourceConflictException("change is closed");
            case RULE_ERROR:
                throw new ResourceConflictException("submit rule error: " + record.errorMessage);
            case NOT_READY:
                throw new ResourceConflictException(describeLabels(cd, record.labels));
            default:
                throw new IllegalStateException(String.format("Unsupported SubmitRecord %s for %s in %s", record, patchSet.getId().getId(), cd.change().getProject().get()));
        }
    }
    throw new IllegalStateException();
}
#end_block

#method_before
public void merge(ReviewDb db, Change change, IdentifiedUser caller, boolean checkSubmitRules) throws NoSuchChangeException, OrmException, ResourceConflictException {
    updateSubmissionId(change);
    this.db = db;
    logDebug("Beginning integration of {}", change);
    try {
        ChangeSet cs = mergeSuperSet.completeChangeSet(db, change);
        reloadChanges(cs);
        logDebug("Calculated to merge {}", cs);
        if (checkSubmitRules) {
            logDebug("Checking submit rules and state");
            checkSubmitRulesAndState(cs);
            failFast(cs);
        }
        try {
            integrateIntoHistory(cs, caller);
        } catch (IntegrationException e) {
            logError("Merge Conflict", e);
            throw new ResourceConflictException("Merge Conflict", e);
        }
    } catch (IOException e) {
        // Anything before the merge attempt is an error
        throw new OrmException(e);
    }
}
#method_after
public void merge(ReviewDb db, Change change, IdentifiedUser caller, boolean checkSubmitRules) throws NoSuchChangeException, OrmException, ResourceConflictException {
    updateSubmissionId(change);
    this.db = db;
    logDebug("Beginning integration of {}", change);
    try {
        ChangeSet cs = mergeSuperSet.completeChangeSet(db, change);
        reloadChanges(cs);
        logDebug("Calculated to merge {}", cs);
        if (checkSubmitRules) {
            logDebug("Checking submit rules and state");
            checkSubmitRulesAndState(cs);
            // Done checks that don't involve opening repo.
            failFast(cs);
        }
        try {
            integrateIntoHistory(cs, caller);
        } catch (IntegrationException e) {
            logError("Merge Conflict", e);
            throw new ResourceConflictException("Merge Conflict", e);
        }
    } catch (IOException e) {
        // Anything before the merge attempt is an error
        throw new OrmException(e);
    }
}
#end_block

#method_before
private void integrateIntoHistory(ChangeSet cs, IdentifiedUser caller) throws IntegrationException, NoSuchChangeException, ResourceConflictException {
    logDebug("Beginning merge attempt on {}", cs);
    Map<Branch.NameKey, BranchBatch> toSubmit = new HashMap<>();
    logDebug("Perform the merges");
    try {
        Multimap<Project.NameKey, Branch.NameKey> br = cs.branchesByProject();
        Multimap<Branch.NameKey, ChangeData> cbb = cs.changesByBranch();
        for (Branch.NameKey branch : cbb.keySet()) {
            OpenRepo or = openRepo(branch.getParentKey());
            toSubmit.put(branch, validateChangeList(or, cbb.get(branch)));
        }
        failFast(cs);
        for (Project.NameKey project : br.keySet()) {
            OpenRepo or = openRepo(project);
            for (Branch.NameKey branch : br.get(project)) {
                OpenBranch ob = or.getBranch(branch);
                BranchBatch submitting = toSubmit.get(branch);
                SubmitStrategy strategy = createStrategy(or, branch, submitting.submitType(), ob.oldTip, caller);
                ob.mergeTip = preMerge(strategy, submitting.changes(), ob.oldTip);
                updateChangeStatus(ob, submitting.changes(), true, caller);
                or.ins.flush();
            }
        }
        Set<Branch.NameKey> done = Sets.newHashSetWithExpectedSize(cbb.keySet().size());
        logDebug("Write out the new branch tips");
        SubmoduleOp subOp = subOpProvider.get();
        for (Project.NameKey project : br.keySet()) {
            OpenRepo or = openRepo(project);
            for (Branch.NameKey branch : br.get(project)) {
                OpenBranch ob = or.getBranch(branch);
                boolean updated = updateBranch(or, branch, caller);
                BranchBatch submitting = toSubmit.get(branch);
                updateChangeStatus(ob, submitting.changes(), false, caller);
                updateSubmoduleSubscriptions(ob, subOp);
                if (updated) {
                    fireRefUpdated(ob);
                }
                done.add(branch);
            }
        }
        updateSuperProjects(subOp, br.values());
        checkState(done.equals(cbb.keySet()), "programmer error: did not process " + " all branches in input set.\nExpected: %s\nActual: %s", done, cbb.keySet());
    } catch (NoSuchProjectException noProject) {
        logWarn("Project " + noProject.project() + " no longer exists, " + "abandoning open changes");
        abandonAllOpenChanges(noProject.project());
    } catch (OrmException e) {
        throw new IntegrationException("Cannot query the database", e);
    } catch (IOException e) {
        throw new IntegrationException("Cannot query the database", e);
    }
}
#method_after
private void integrateIntoHistory(ChangeSet cs, IdentifiedUser caller) throws IntegrationException, NoSuchChangeException, ResourceConflictException {
    logDebug("Beginning merge attempt on {}", cs);
    Map<Branch.NameKey, BranchBatch> toSubmit = new HashMap<>();
    logDebug("Perform the merges");
    try {
        Multimap<Project.NameKey, Branch.NameKey> br = cs.branchesByProject();
        Multimap<Branch.NameKey, ChangeData> cbb = cs.changesByBranch();
        for (Branch.NameKey branch : cbb.keySet()) {
            OpenRepo or = openRepo(branch.getParentKey());
            toSubmit.put(branch, validateChangeList(or, cbb.get(branch)));
        }
        // Done checks that don't involve running submit strategies.
        failFast(cs);
        for (Project.NameKey project : br.keySet()) {
            OpenRepo or = openRepo(project);
            for (Branch.NameKey branch : br.get(project)) {
                OpenBranch ob = or.getBranch(branch);
                BranchBatch submitting = toSubmit.get(branch);
                SubmitStrategy strategy = createStrategy(or, branch, submitting.submitType(), ob.oldTip, caller);
                ob.mergeTip = preMerge(strategy, submitting.changes(), ob.oldTip);
                updateChangeStatus(ob, submitting.changes(), true, caller);
                or.ins.flush();
            }
        }
        Set<Branch.NameKey> done = Sets.newHashSetWithExpectedSize(cbb.keySet().size());
        logDebug("Write out the new branch tips");
        SubmoduleOp subOp = subOpProvider.get();
        for (Project.NameKey project : br.keySet()) {
            OpenRepo or = openRepo(project);
            for (Branch.NameKey branch : br.get(project)) {
                OpenBranch ob = or.getBranch(branch);
                boolean updated = updateBranch(or, branch, caller);
                BranchBatch submitting = toSubmit.get(branch);
                updateChangeStatus(ob, submitting.changes(), false, caller);
                updateSubmoduleSubscriptions(ob, subOp);
                if (updated) {
                    fireRefUpdated(ob);
                }
                done.add(branch);
            }
        }
        updateSuperProjects(subOp, br.values());
        checkState(done.equals(cbb.keySet()), "programmer error: did not process" + " all branches in input set.\nExpected: %s\nActual: %s", done, cbb.keySet());
    } catch (NoSuchProjectException noProject) {
        logWarn("Project " + noProject.project() + " no longer exists, " + "abandoning open changes");
        abandonAllOpenChanges(noProject.project());
    } catch (OrmException e) {
        throw new IntegrationException("Cannot query the database", e);
    } catch (IOException e) {
        throw new IntegrationException("Cannot query the database", e);
    }
}
#end_block

#method_before
@Override
public Boolean call() throws NoSuchProjectException, IntegrationException, IOException {
    if (key.into.equals(ObjectId.zeroId())) {
        // Assume yes on new branch.
        return true;
    }
    try (CodeReviewRevWalk rw = CodeReviewCommit.newRevWalk(repo)) {
        Set<RevCommit> accepted = SubmitDryRun.getAlreadyAccepted(repo, rw);
        RevCommit c = rw.parseCommit(key.commit);
        accepted.addAll(Arrays.asList(c.getParents()));
        return submitDryRun.dryRun(key.submitType, repo, rw, dest, key.into, key.commit, accepted);
    }
}
#method_after
@Override
public Boolean call() throws NoSuchProjectException, IntegrationException, IOException {
    if (key.into.equals(ObjectId.zeroId())) {
        // Assume yes on new branch.
        return true;
    }
    try (CodeReviewRevWalk rw = CodeReviewCommit.newRevWalk(repo)) {
        Set<RevCommit> accepted = SubmitDryRun.getAlreadyAccepted(repo, rw);
        accepted.add(rw.parseCommit(key.into));
        accepted.addAll(Arrays.asList(rw.parseCommit(key.commit).getParents()));
        return submitDryRun.run(key.submitType, repo, rw, dest, key.into, key.commit, accepted);
    }
}
#end_block

#method_before
private static List<Predicate<ChangeData>> predicates(final Arguments args, String value, List<Change> changes) throws OrmException {
    List<Predicate<ChangeData>> changePredicates = Lists.newArrayListWithCapacity(changes.size());
    final Provider<ReviewDb> db = args.db;
    for (final Change c : changes) {
        final ChangeDataCache changeDataCache = new ChangeDataCache(c, db, args.changeDataFactory, args.projectCache);
        List<String> files = listFiles(c, args, changeDataCache);
        List<Predicate<ChangeData>> filePredicates = Lists.newArrayListWithCapacity(files.size());
        for (String file : files) {
            filePredicates.add(new EqualsPathPredicate(ChangeQueryBuilder.FIELD_PATH, file));
        }
        List<Predicate<ChangeData>> predicatesForOneChange = Lists.newArrayListWithCapacity(5);
        predicatesForOneChange.add(not(new LegacyChangeIdPredicate(args.getSchema(), c.getId())));
        predicatesForOneChange.add(new ProjectPredicate(c.getProject().get()));
        predicatesForOneChange.add(new RefPredicate(c.getDest().get()));
        predicatesForOneChange.add(or(or(filePredicates), new IsMergePredicate(args, value)));
        predicatesForOneChange.add(new OperatorPredicate<ChangeData>(ChangeQueryBuilder.FIELD_CONFLICTS, value) {

            @Override
            public boolean match(ChangeData object) throws OrmException {
                Change otherChange = object.change();
                if (otherChange == null) {
                    return false;
                }
                if (!otherChange.getDest().equals(c.getDest())) {
                    return false;
                }
                SubmitType submitType = getSubmitType(object);
                if (submitType == null) {
                    return false;
                }
                ObjectId other = ObjectId.fromString(object.currentPatchSet().getRevision().get());
                ConflictKey conflictsKey = new ConflictKey(changeDataCache.getTestAgainst(), other, submitType, changeDataCache.getProjectState().isUseContentMerge());
                Boolean conflicts = args.conflictsCache.getIfPresent(conflictsKey);
                if (conflicts != null) {
                    return conflicts;
                }
                try (Repository repo = args.repoManager.openRepository(otherChange.getProject());
                    CodeReviewRevWalk rw = CodeReviewCommit.newRevWalk(repo)) {
                    conflicts = !args.submitDryRun.dryRun(submitType, repo, rw, otherChange.getDest(), changeDataCache.getTestAgainst(), other, getAlreadyAccepted(repo, rw));
                    args.conflictsCache.put(conflictsKey, conflicts);
                    return conflicts;
                } catch (IntegrationException | NoSuchProjectException | IOException e) {
                    throw new IllegalStateException(e);
                }
            }

            @Override
            public int getCost() {
                return 5;
            }

            private SubmitType getSubmitType(ChangeData cd) throws OrmException {
                SubmitTypeRecord r = new SubmitRuleEvaluator(cd).getSubmitType();
                if (r.status != SubmitTypeRecord.Status.OK) {
                    return null;
                }
                return r.type;
            }

            private Set<RevCommit> getAlreadyAccepted(Repository repo, RevWalk rw) throws IntegrationException {
                try {
                    Set<RevCommit> accepted = new HashSet<>();
                    SubmitDryRun.addCommits(changeDataCache.getAlreadyAccepted(repo), rw, accepted);
                    ObjectId tip = changeDataCache.getTestAgainst();
                    if (tip != null) {
                        accepted.add(rw.parseCommit(tip));
                    }
                    return accepted;
                } catch (OrmException | IOException e) {
                    throw new IntegrationException("Failed to determine already accepted commits.", e);
                }
            }
        });
        changePredicates.add(and(predicatesForOneChange));
    }
    return changePredicates;
}
#method_after
private static List<Predicate<ChangeData>> predicates(final Arguments args, String value, List<Change> changes) throws OrmException {
    List<Predicate<ChangeData>> changePredicates = Lists.newArrayListWithCapacity(changes.size());
    final Provider<ReviewDb> db = args.db;
    for (final Change c : changes) {
        final ChangeDataCache changeDataCache = new ChangeDataCache(c, db, args.changeDataFactory, args.projectCache);
        List<String> files = listFiles(c, args, changeDataCache);
        List<Predicate<ChangeData>> filePredicates = Lists.newArrayListWithCapacity(files.size());
        for (String file : files) {
            filePredicates.add(new EqualsPathPredicate(ChangeQueryBuilder.FIELD_PATH, file));
        }
        List<Predicate<ChangeData>> predicatesForOneChange = Lists.newArrayListWithCapacity(5);
        predicatesForOneChange.add(not(new LegacyChangeIdPredicate(args.getSchema(), c.getId())));
        predicatesForOneChange.add(new ProjectPredicate(c.getProject().get()));
        predicatesForOneChange.add(new RefPredicate(c.getDest().get()));
        predicatesForOneChange.add(or(or(filePredicates), new IsMergePredicate(args, value)));
        predicatesForOneChange.add(new OperatorPredicate<ChangeData>(ChangeQueryBuilder.FIELD_CONFLICTS, value) {

            @Override
            public boolean match(ChangeData object) throws OrmException {
                Change otherChange = object.change();
                if (otherChange == null) {
                    return false;
                }
                if (!otherChange.getDest().equals(c.getDest())) {
                    return false;
                }
                SubmitType submitType = getSubmitType(object);
                if (submitType == null) {
                    return false;
                }
                ObjectId other = ObjectId.fromString(object.currentPatchSet().getRevision().get());
                ConflictKey conflictsKey = new ConflictKey(changeDataCache.getTestAgainst(), other, submitType, changeDataCache.getProjectState().isUseContentMerge());
                Boolean conflicts = args.conflictsCache.getIfPresent(conflictsKey);
                if (conflicts != null) {
                    return conflicts;
                }
                try (Repository repo = args.repoManager.openRepository(otherChange.getProject());
                    CodeReviewRevWalk rw = CodeReviewCommit.newRevWalk(repo)) {
                    conflicts = !args.submitDryRun.run(submitType, repo, rw, otherChange.getDest(), changeDataCache.getTestAgainst(), other, getAlreadyAccepted(repo, rw));
                    args.conflictsCache.put(conflictsKey, conflicts);
                    return conflicts;
                } catch (IntegrationException | NoSuchProjectException | IOException e) {
                    throw new IllegalStateException(e);
                }
            }

            @Override
            public int getCost() {
                return 5;
            }

            private SubmitType getSubmitType(ChangeData cd) throws OrmException {
                SubmitTypeRecord r = new SubmitRuleEvaluator(cd).getSubmitType();
                if (r.status != SubmitTypeRecord.Status.OK) {
                    return null;
                }
                return r.type;
            }

            private Set<RevCommit> getAlreadyAccepted(Repository repo, RevWalk rw) throws IntegrationException {
                try {
                    Set<RevCommit> accepted = new HashSet<>();
                    SubmitDryRun.addCommits(changeDataCache.getAlreadyAccepted(repo), rw, accepted);
                    ObjectId tip = changeDataCache.getTestAgainst();
                    if (tip != null) {
                        accepted.add(rw.parseCommit(tip));
                    }
                    return accepted;
                } catch (OrmException | IOException e) {
                    throw new IntegrationException("Failed to determine already accepted commits.", e);
                }
            }
        });
        changePredicates.add(and(predicatesForOneChange));
    }
    return changePredicates;
}
#end_block

#method_before
ImmutableListMultimap<PatchSet.Id, PatchSetApproval> buildApprovals() {
    Multimap<PatchSet.Id, PatchSetApproval> result = ArrayListMultimap.create(approvals.keySet().size(), 3);
    for (Table<?, ?, Optional<PatchSetApproval>> curr : approvals.values()) {
        for (PatchSetApproval psa : Optional.presentInstances(curr.values())) {
            result.put(psa.getPatchSetId(), psa);
        }
    }
    for (Collection<PatchSetApproval> v : result.asMap().values()) {
        Collections.sort((List<PatchSetApproval>) v, ChangeNotes.PSA_BY_TIME);
    }
    return ImmutableListMultimap.copyOf(result);
}
#method_after
ImmutableListMultimap<PatchSet.Id, PatchSetApproval> buildApprovals() {
    Multimap<PatchSet.Id, PatchSetApproval> result = ArrayListMultimap.create(approvals.keySet().size(), 3);
    for (Table<?, ?, PatchSetApproval> curr : approvals.values()) {
        for (PatchSetApproval psa : curr.values()) {
            result.put(psa.getPatchSetId(), psa);
        }
    }
    for (Collection<PatchSetApproval> v : result.asMap().values()) {
        Collections.sort((List<PatchSetApproval>) v, ChangeNotes.PSA_BY_TIME);
    }
    return ImmutableListMultimap.copyOf(result);
}
#end_block

#method_before
private void parseApproval(PatchSet.Id psId, Account.Id accountId, RevCommit commit, String line) throws ConfigInvalidException {
    Table<Account.Id, String, Optional<PatchSetApproval>> curr = approvals.get(psId);
    if (line.startsWith("-")) {
        String label = line.substring(1);
        if (curr == null || !curr.contains(accountId, label)) {
            parseRemoveApproval(psId, accountId, label);
        }
        return;
    }
    if (curr == null) {
        curr = Tables.newCustomTable(Maps.<Account.Id, Map<String, Optional<PatchSetApproval>>>newHashMapWithExpectedSize(2), new Supplier<Map<String, Optional<PatchSetApproval>>>() {

            @Override
            public Map<String, Optional<PatchSetApproval>> get() {
                return Maps.newLinkedHashMap();
            }
        });
        approvals.put(psId, curr);
    }
    LabelVote l;
    try {
        l = LabelVote.parseWithEquals(line);
    } catch (IllegalArgumentException e) {
        ConfigInvalidException pe = parseException("invalid %s: %s", FOOTER_LABEL, line);
        pe.initCause(e);
        throw pe;
    }
    if (!curr.contains(accountId, l.label()) && !isApprovalRemoved(psId, accountId, l.label())) {
        curr.put(accountId, l.label(), Optional.of(new PatchSetApproval(new PatchSetApproval.Key(psId, accountId, new LabelId(l.label())), l.value(), new Timestamp(commit.getCommitterIdent().getWhen().getTime()))));
    }
}
#method_after
private void parseApproval(PatchSet.Id psId, Account.Id accountId, RevCommit commit, String line) throws ConfigInvalidException {
    if (line.startsWith("-")) {
        parseRemoveApproval(psId, accountId, line);
    } else {
        parseAddApproval(psId, accountId, commit, line);
    }
}
#end_block

#method_before
private void parseRemoveApproval(PatchSet.Id psId, Account.Id accountId, String line) throws ConfigInvalidException {
    Multimap<Account.Id, String> curr = removedApprovals.get(psId);
    if (curr == null) {
        curr = HashMultimap.create(1, 1);
        removedApprovals.put(psId, curr);
    }
    String label;
    Account.Id removedAccountId;
    int s = line.indexOf(' ');
    if (s > 0) {
        // Leading '-' already trimmed by caller.
        label = line.substring(0, s);
        PersonIdent ident = RawParseUtils.parsePersonIdent(line.substring(s + 1));
        checkFooter(ident != null, FOOTER_LABEL, line);
        removedAccountId = parseIdent(ident);
    } else {
        label = line;
        removedAccountId = accountId;
    }
    curr.put(removedAccountId, label);
}
#method_after
private void parseRemoveApproval(PatchSet.Id psId, Account.Id accountId, String line) throws ConfigInvalidException {
    Multimap<Account.Id, String> curr = removedApprovals.get(psId);
    if (curr == null) {
        curr = HashMultimap.create(1, 1);
        removedApprovals.put(psId, curr);
    }
    String label;
    Account.Id removedAccountId;
    line = line.substring(1);
    int s = line.indexOf(' ');
    if (s > 0) {
        label = line.substring(0, s);
        PersonIdent ident = RawParseUtils.parsePersonIdent(line.substring(s + 1));
        checkFooter(ident != null, FOOTER_LABEL, line);
        removedAccountId = parseIdent(ident);
    } else {
        label = line;
        removedAccountId = accountId;
    }
    Table<Account.Id, String, PatchSetApproval> added = approvals.get(psId);
    if (added != null && added.contains(accountId, label)) {
        return;
    }
    try {
        curr.put(removedAccountId, LabelType.checkNameInternal(label));
    } catch (IllegalArgumentException e) {
        ConfigInvalidException pe = parseException("invalid %s: %s", FOOTER_LABEL, line);
        pe.initCause(e);
        throw pe;
    }
}
#end_block

#method_before
@Test
public void parseApproval() throws Exception {
    assertParseSucceeds("Update change\n" + "\n" + "Patch-Set: 1\n" + "Label: Label1=+1\n" + "Label: Label2=1\n" + "Label: Label3=0\n" + "Label: Label4=-1\n");
    assertParseSucceeds("Update change\n" + "\n" + "Patch-Set: 1\n" + "Label: -Label1\n" + "Label: -Label1 Other Account <2@gerrit>\n");
    assertParseFails("Update change\n" + "\n" + "Patch-Set: 1\n" + "Label: Label1=X\n");
    assertParseFails("Update change\n" + "\n" + "Patch-Set: 1\n" + "Label: Label1 = 1\n");
    assertParseFails("Update change\n" + "\n" + "Patch-Set: 1\n" + "Label: X+Y\n");
    assertParseFails("Update change\n" + "\n" + "Patch-Set: 1\n" + "Label: Label1 Other Account <2@gerrit>\n");
}
#method_after
@Test
public void parseApproval() throws Exception {
    assertParseSucceeds("Update change\n" + "\n" + "Patch-Set: 1\n" + "Label: Label1=+1\n" + "Label: Label2=1\n" + "Label: Label3=0\n" + "Label: Label4=-1\n");
    assertParseSucceeds("Update change\n" + "\n" + "Patch-Set: 1\n" + "Label: -Label1\n" + "Label: -Label1 Other Account <2@gerrit>\n");
    assertParseFails("Update change\n" + "\n" + "Patch-Set: 1\n" + "Label: Label1=X\n");
    assertParseFails("Update change\n" + "\n" + "Patch-Set: 1\n" + "Label: Label1 = 1\n");
    assertParseFails("Update change\n" + "\n" + "Patch-Set: 1\n" + "Label: X+Y\n");
    assertParseFails("Update change\n" + "\n" + "Patch-Set: 1\n" + "Label: Label1 Other Account <2@gerrit>\n");
    assertParseFails("Update change\n" + "\n" + "Patch-Set: 1\n" + "Label: -Label!1\n");
    assertParseFails("Update change\n" + "\n" + "Patch-Set: 1\n" + "Label: -Label!1 Other Account <2@gerrit>\n");
}
#end_block

#method_before
@Override
public boolean match(final ChangeData object) throws OrmException {
    try {
        return object.getAuthor().getEmailAddress().equalsIgnoreCase(getValue());
    } catch (IOException e) {
        return false;
    }
}
#method_after
@Override
public boolean match(ChangeData object) throws OrmException {
    return ChangeField.getAuthorParts(object).contains(getValue().toLowerCase());
}
#end_block

#method_before
@Test
public void byAuthor() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    Change change1 = newChange(repo, null, null, userId.get(), null).insert();
    assertQuery("author:jauthor@example.com", change1);
    assertQuery("author:user@example.com");
}
#method_after
@Test
public void byAuthor() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    Change change1 = newChange(repo, null, null, userId.get(), null).insert();
    // By exact email address
    assertQuery("author:jauthor@example.com", change1);
    // By email address part
    assertQuery("author:jauthor", change1);
    assertQuery("author:example", change1);
    assertQuery("author:example.com", change1);
    // By name part
    assertQuery("author:Author", change1);
    // By non-existing email address / name / part
    assertQuery("author:jcommitter@example.com");
    assertQuery("author:somewhere.com");
    assertQuery("author:jcommitter");
    assertQuery("author:Committer");
}
#end_block

#method_before
@Test
public void bySize() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    // added = 3, deleted = 0, delta = 3
    RevCommit commit1 = repo.parseBody(repo.commit().add("file1", "foo\n\foo\nfoo").create());
    // added = 0, deleted = 2, delta = 2
    RevCommit commit2 = repo.parseBody(repo.commit().parent(commit1).add("file1", "foo").create());
    Change change1 = newChange(repo, commit1, null, null, null).insert();
    Change change2 = newChange(repo, commit2, null, null, null).insert();
    assertQuery("added:>4");
    assertQuery("added:3", change1);
    assertQuery("added:>2", change1);
    assertQuery("added:>=3", change1);
    assertQuery("added:<1", change2);
    assertQuery("added:<=0", change2);
    assertQuery("deleted:>3");
    assertQuery("deleted:2", change2);
    assertQuery("deleted:>1", change2);
    assertQuery("deleted:>=2", change2);
    assertQuery("deleted:<1", change1);
    assertQuery("deleted:<=0", change1);
    for (String str : Lists.newArrayList("delta", "size")) {
        assertQuery(str + ":<2");
        assertQuery(str + ":3", change1);
        assertQuery(str + ":>2", change1);
        assertQuery(str + ":>=3", change1);
        assertQuery(str + ":<3", change2);
        assertQuery(str + ":<=2", change2);
    }
}
#method_after
@Test
public void bySize() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    // added = 3, deleted = 0, delta = 3
    RevCommit commit1 = repo.parseBody(repo.commit().add("file1", "foo\n\foo\nfoo").create());
    // added = 0, deleted = 2, delta = 2
    RevCommit commit2 = repo.parseBody(repo.commit().parent(commit1).add("file1", "foo").create());
    Change change1 = newChange(repo, commit1, null, null, null).insert();
    Change change2 = newChange(repo, commit2, null, null, null).insert();
    assertQuery("added:>4");
    assertQuery("-added:<=4");
    assertQuery("added:3", change1);
    assertQuery("-(added:<3 OR added>3)", change1);
    assertQuery("added:>2", change1);
    assertQuery("-added:<=2", change1);
    assertQuery("added:>=3", change1);
    assertQuery("-added:<3", change1);
    assertQuery("added:<1", change2);
    assertQuery("-added:>=1", change2);
    assertQuery("added:<=0", change2);
    assertQuery("-added:>0", change2);
    assertQuery("deleted:>3");
    assertQuery("-deleted:<=3");
    assertQuery("deleted:2", change2);
    assertQuery("-(deleted:<2 OR deleted>2)", change2);
    assertQuery("deleted:>1", change2);
    assertQuery("-deleted:<=1", change2);
    assertQuery("deleted:>=2", change2);
    assertQuery("-deleted:<2", change2);
    assertQuery("deleted:<1", change1);
    assertQuery("-deleted:>=1", change1);
    assertQuery("deleted:<=0", change1);
    for (String str : Lists.newArrayList("delta", "size")) {
        assertQuery(str + ":<2");
        assertQuery(str + ":3", change1);
        assertQuery(str + ":>2", change1);
        assertQuery(str + ":>=3", change1);
        assertQuery(str + ":<3", change2);
        assertQuery(str + ":<=2", change2);
    }
}
#end_block

#method_before
@Test
public void byCommitsOnBranchNotMerged() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    int n = 10;
    List<String> shas = new ArrayList<>(n);
    List<Integer> expectedIds = new ArrayList<>(n);
    Branch.NameKey dest = null;
    for (int i = 0; i < n; i++) {
        ChangeInserter ins = newChange(repo, null, null, null, null);
        ins.insert();
        if (dest == null) {
            dest = ins.getChange().getDest();
        }
        shas.add(ins.getPatchSet().getRevision().get());
        expectedIds.add(ins.getChange().getId().get());
    }
    for (int i = 1; i <= 11; i++) {
        Iterable<ChangeData> cds = internalChangeQuery.byCommitsOnBranchNotMerged(dest, shas, i);
        Iterable<Integer> ids = FluentIterable.from(cds).transform(new Function<ChangeData, Integer>() {

            @Override
            public Integer apply(ChangeData in) {
                return in.getId().get();
            }
        });
        String name = "batch size " + i;
        assertThat(ids).named(name).hasSize(n);
        assertThat(ids).named(name).containsExactlyElementsIn(expectedIds);
    }
}
#method_after
@Test
public void byCommitsOnBranchNotMerged() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    int n = 10;
    List<String> shas = new ArrayList<>(n);
    List<Integer> expectedIds = new ArrayList<>(n);
    Branch.NameKey dest = null;
    for (int i = 0; i < n; i++) {
        ChangeInserter ins = newChange(repo, null, null, null, null);
        ins.insert();
        if (dest == null) {
            dest = ins.getChange().getDest();
        }
        shas.add(ins.getPatchSet().getRevision().get());
        expectedIds.add(ins.getChange().getId().get());
    }
    for (int i = 1; i <= 11; i++) {
        Iterable<ChangeData> cds = internalChangeQuery.byCommitsOnBranchNotMerged(indexes.getSearchIndex().getSchema(), dest, shas, i);
        Iterable<Integer> ids = FluentIterable.from(cds).transform(new Function<ChangeData, Integer>() {

            @Override
            public Integer apply(ChangeData in) {
                return in.getId().get();
            }
        });
        String name = "batch size " + i;
        assertThat(ids).named(name).hasSize(n);
        assertThat(ids).named(name).containsExactlyElementsIn(expectedIds);
    }
}
#end_block

#method_before
private boolean loadCommitData() throws OrmException, RepositoryNotFoundException, IOException, MissingObjectException, IncorrectObjectTypeException {
    PatchSet ps = currentPatchSet();
    if (ps == null) {
        return false;
    }
    String sha1 = ps.getRevision().get();
    try (Repository repo = repoManager.openRepository(change().getProject());
        RevWalk walk = new RevWalk(repo)) {
        RevCommit c = walk.parseCommit(ObjectId.fromString(sha1));
        commitMessage = c.getFullMessage();
        commitFooters = c.getFooterLines();
        author = c.getAuthorIdent();
    }
    return true;
}
#method_after
private boolean loadCommitData() throws OrmException, RepositoryNotFoundException, IOException, MissingObjectException, IncorrectObjectTypeException {
    PatchSet ps = currentPatchSet();
    if (ps == null) {
        return false;
    }
    String sha1 = ps.getRevision().get();
    try (Repository repo = repoManager.openRepository(change().getProject());
        RevWalk walk = new RevWalk(repo)) {
        RevCommit c = walk.parseCommit(ObjectId.fromString(sha1));
        commitMessage = c.getFullMessage();
        commitFooters = c.getFooterLines();
        author = c.getAuthorIdent();
        committer = c.getCommitterIdent();
    }
    return true;
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> change(String query) throws QueryParseException {
    if (PAT_LEGACY_ID.matcher(query).matches()) {
        return new LegacyChangeIdPredicate(Change.Id.parse(query));
    } else if (PAT_CHANGE_ID.matcher(query).matches()) {
        return new ChangeIdPredicate(parseChangeId(query));
    }
    Optional<ChangeTriplet> triplet = ChangeTriplet.parse(query);
    if (triplet.isPresent()) {
        return Predicate.and(project(triplet.get().project().get()), branch(triplet.get().branch().get()), new ChangeIdPredicate(parseChangeId(triplet.get().id().get())));
    }
    throw new QueryParseException("Invalid change format");
}
#method_after
@Operator
public Predicate<ChangeData> change(String query) throws QueryParseException {
    if (PAT_LEGACY_ID.matcher(query).matches()) {
        return new LegacyChangeIdPredicate(args.getSchema(), Change.Id.parse(query));
    } else if (PAT_CHANGE_ID.matcher(query).matches()) {
        return new ChangeIdPredicate(parseChangeId(query));
    }
    Optional<ChangeTriplet> triplet = ChangeTriplet.parse(query);
    if (triplet.isPresent()) {
        return Predicate.and(project(triplet.get().project().get()), branch(triplet.get().branch().get()), new ChangeIdPredicate(parseChangeId(triplet.get().id().get())));
    }
    throw new QueryParseException("Invalid change format");
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> commit(String id) {
    if (id.length() == Constants.OBJECT_ID_STRING_LENGTH) {
        return new ExactCommitPredicate(id);
    }
    return new CommitPrefixPredicate(id);
}
#method_after
@Operator
public Predicate<ChangeData> commit(String id) {
    return new CommitPredicate(args.getSchema(), id);
}
#end_block

#method_before
@Override
public void init(FilterConfig config) {
}
#method_after
@Override
public void init(FilterConfig config) throws ServletException {
    if (Strings.isNullOrEmpty(gitOAuthProvider)) {
        pickOnlyProvider();
    } else {
        pickConfiguredProvider();
    }
}
#end_block

#method_before
private boolean verify(HttpServletRequest req, Response rsp) throws IOException {
    String hdr = req.getHeader(AUTHORIZATION);
    if (hdr == null || !hdr.startsWith(LIT_BASIC)) {
        // session cookie instead of basic authentication.
        return true;
    }
    byte[] decoded = Base64.decodeBase64(hdr.substring(LIT_BASIC.length()));
    String usernamePassword = new String(decoded, encoding(req));
    int splitPos = usernamePassword.indexOf(':');
    if (splitPos < 1) {
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
    String username = usernamePassword.substring(0, splitPos);
    String tokenOrPassword = usernamePassword.substring(splitPos + 1);
    if (Strings.isNullOrEmpty(tokenOrPassword)) {
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
    if (authConfig.isUserNameToLowerCase()) {
        username = username.toLowerCase(Locale.US);
    }
    AccountState who = accountCache.getByUsername(username);
    if (who == null || !who.getAccount().isActive()) {
        log.warn("Authentication failed for " + username + ": account inactive or not provisioned in Gerrit");
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
    AuthRequest authRequest = AuthRequest.forExternalUser(username);
    authRequest.setEmailAddress(who.getAccount().getPreferredEmail());
    authRequest.setDisplayName(who.getAccount().getFullName());
    authRequest.setPassword(tokenOrPassword);
    try {
        AuthResult authResult = accountManager.authenticate(authRequest);
        WebSession ws = session.get();
        ws.setUserAccountId(authResult.getAccountId());
        ws.setAccessPathOk(AccessPath.GIT, true);
        ws.setAccessPathOk(AccessPath.REST_API, true);
        return true;
    } catch (AccountException e) {
        log.warn("Authentication failed for " + username, e);
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
}
#method_after
private boolean verify(HttpServletRequest req, Response rsp) throws IOException {
    String hdr = req.getHeader(AUTHORIZATION);
    if (hdr == null || !hdr.startsWith(BASIC)) {
        // session cookie instead of basic authentication.
        return true;
    }
    byte[] decoded = Base64.decodeBase64(hdr.substring(BASIC.length()));
    String usernamePassword = new String(decoded, encoding(req));
    int splitPos = usernamePassword.indexOf(':');
    if (splitPos < 1) {
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
    AuthInfo authInfo = new AuthInfo(usernamePassword.substring(0, splitPos), usernamePassword.substring(splitPos + 1), defaultAuthPlugin, defaultAuthProvider);
    if (Strings.isNullOrEmpty(authInfo.tokenOrSecret)) {
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
    AccountState who = accountCache.getByUsername(authInfo.username);
    if (who == null || !who.getAccount().isActive()) {
        log.warn("Authentication failed for " + authInfo.username + ": account inactive or not provisioned in Gerrit");
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
    AuthRequest authRequest = AuthRequest.forExternalUser(authInfo.username);
    authRequest.setEmailAddress(who.getAccount().getPreferredEmail());
    authRequest.setDisplayName(who.getAccount().getFullName());
    authRequest.setPassword(authInfo.tokenOrSecret);
    authRequest.setAuthPlugin(authInfo.pluginName);
    authRequest.setAuthProvider(authInfo.exportName);
    try {
        AuthResult authResult = accountManager.authenticate(authRequest);
        WebSession ws = session.get();
        ws.setUserAccountId(authResult.getAccountId());
        ws.setAccessPathOk(AccessPath.GIT, true);
        ws.setAccessPathOk(AccessPath.REST_API, true);
        return true;
    } catch (AccountException e) {
        log.warn("Authentication failed for " + authInfo.username, e);
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
}
#end_block

#method_before
private String encoding(HttpServletRequest req) {
    return MoreObjects.firstNonNull(req.getCharacterEncoding(), "UTF-8");
}
#method_after
private static String encoding(HttpServletRequest req) {
    return MoreObjects.firstNonNull(req.getCharacterEncoding(), UTF_8.name());
}
#end_block

#method_before
private void status(int sc) {
    if (sc == SC_UNAUTHORIZED) {
        StringBuilder v = new StringBuilder();
        v.append(LIT_BASIC);
        v.append("realm=\"").append(REALM_NAME).append("\"");
        setHeader(WWW_AUTHENTICATE, v.toString());
    } else if (containsHeader(WWW_AUTHENTICATE)) {
        setHeader(WWW_AUTHENTICATE, null);
    }
}
#method_after
private void status(int sc) {
    if (sc == SC_UNAUTHORIZED) {
        StringBuilder v = new StringBuilder();
        v.append(BASIC);
        v.append("realm=\"").append(REALM_NAME).append("\"");
        setHeader(WWW_AUTHENTICATE, v.toString());
    } else if (containsHeader(WWW_AUTHENTICATE)) {
        setHeader(WWW_AUTHENTICATE, null);
    }
}
#end_block

#method_before
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(ChangeKindCacheImpl.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(MergeabilityCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new GitModule());
    install(new GroupModule());
    install(new NoteDbModule());
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(AddKeySender.Factory.class);
    factory(BatchUpdate.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeData.Factory.class);
    factory(ChangeJson.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(EmailMerge.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    factory(ProjectOwnerGroupsProvider.Factory.class);
    bind(RepositoryConfig.class);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(GitwebConfig.class);
    bind(GcConfig.class);
    bind(ChangeCleanupConfig.class);
    bind(ApprovalsUtil.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(Boolean.class).annotatedWith(DisableReverseDnsLookup.class).toProvider(DisableReverseDnsLookupProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), ReceivePackInitializer.class);
    DynamicSet.setOf(binder(), PostReceiveHook.class);
    DynamicSet.setOf(binder(), PreUploadHook.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), GarbageCollectorListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.setOf(binder(), UsageDataPublishedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ReindexAfterUpdate.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ProjectConfigEntry.UpdateChecker.class);
    DynamicSet.setOf(binder(), EventListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), RefOperationValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicSet.setOf(binder(), ProjectCreationValidationListener.class);
    DynamicSet.setOf(binder(), GroupCreationValidationListener.class);
    DynamicSet.setOf(binder(), HashtagValidationListener.class);
    DynamicSet.setOf(binder(), OutgoingEmailValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), CloneCommand.class);
    DynamicMap.mapOf(binder(), ExternalIncludedIn.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    DynamicSet.setOf(binder(), PatchSetWebLink.class);
    DynamicSet.setOf(binder(), FileWebLink.class);
    DynamicSet.setOf(binder(), FileHistoryWebLink.class);
    DynamicSet.setOf(binder(), DiffWebLink.class);
    DynamicSet.setOf(binder(), ProjectWebLink.class);
    DynamicSet.setOf(binder(), BranchWebLink.class);
    DynamicItem.itemOf(binder(), OAuthLoginService.class);
    factory(UploadValidators.Factory.class);
    DynamicSet.setOf(binder(), UploadValidationListener.class);
    bind(AnonymousUser.class);
    factory(CommitValidators.Factory.class);
    factory(RefOperationValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    factory(SubmoduleSectionParser.Factory.class);
    bind(AccountManager.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#method_after
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(ChangeKindCacheImpl.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(MergeabilityCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new GitModule());
    install(new GroupModule());
    install(new NoteDbModule());
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(AddKeySender.Factory.class);
    factory(BatchUpdate.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeData.Factory.class);
    factory(ChangeJson.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(EmailMerge.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    factory(ProjectOwnerGroupsProvider.Factory.class);
    bind(RepositoryConfig.class);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(GitwebConfig.class);
    bind(GcConfig.class);
    bind(ChangeCleanupConfig.class);
    bind(ApprovalsUtil.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(Boolean.class).annotatedWith(DisableReverseDnsLookup.class).toProvider(DisableReverseDnsLookupProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), ReceivePackInitializer.class);
    DynamicSet.setOf(binder(), PostReceiveHook.class);
    DynamicSet.setOf(binder(), PreUploadHook.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), GarbageCollectorListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.setOf(binder(), UsageDataPublishedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ReindexAfterUpdate.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ProjectConfigEntry.UpdateChecker.class);
    DynamicSet.bind(binder(), EventListener.class).to(EventsMetrics.class);
    DynamicSet.setOf(binder(), EventListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), RefOperationValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicSet.setOf(binder(), ProjectCreationValidationListener.class);
    DynamicSet.setOf(binder(), GroupCreationValidationListener.class);
    DynamicSet.setOf(binder(), HashtagValidationListener.class);
    DynamicSet.setOf(binder(), OutgoingEmailValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), CloneCommand.class);
    DynamicMap.mapOf(binder(), ExternalIncludedIn.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    DynamicSet.setOf(binder(), PatchSetWebLink.class);
    DynamicSet.setOf(binder(), FileWebLink.class);
    DynamicSet.setOf(binder(), FileHistoryWebLink.class);
    DynamicSet.setOf(binder(), DiffWebLink.class);
    DynamicSet.setOf(binder(), ProjectWebLink.class);
    DynamicSet.setOf(binder(), BranchWebLink.class);
    DynamicMap.mapOf(binder(), OAuthLoginProvider.class);
    factory(UploadValidators.Factory.class);
    DynamicSet.setOf(binder(), UploadValidationListener.class);
    DynamicMap.mapOf(binder(), ChangeQueryBuilder.ChangeOperatorFactory.class);
    bind(AnonymousUser.class);
    factory(CommitValidators.Factory.class);
    factory(RefOperationValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    factory(SubmoduleSectionParser.Factory.class);
    bind(AccountManager.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#end_block

#method_before
@Override
public AuthRequest authenticate(AuthRequest who) throws AccountException {
    if (who.getPassword() == null && who.getEmailAddress() != null) {
        return who;
    }
    if (loginService.get() == null) {
        log.warn("no implementation of OAuthLoginService available");
        return who;
    }
    OAuthUserInfo userInfo = loginService.get().login(who.getUserName(), who.getPassword());
    if (userInfo.getEmailAddress() != null) {
        who.setEmailAddress(userInfo.getEmailAddress());
    }
    if (userInfo.getDisplayName() != null) {
        who.setDisplayName(userInfo.getDisplayName());
    }
    return who;
}
#method_after
@Override
public AuthRequest authenticate(AuthRequest who) throws AccountException {
    if (Strings.isNullOrEmpty(who.getPassword()) && !Strings.isNullOrEmpty(who.getEmailAddress())) {
        return who;
    }
    if (Strings.isNullOrEmpty(who.getAuthPlugin()) || Strings.isNullOrEmpty(who.getAuthProvider())) {
        throw new AccountException("Cannot authenticate");
    }
    OAuthLoginProvider loginProvider = loginProviders.get(who.getAuthPlugin(), who.getAuthProvider());
    if (loginProvider == null) {
        throw new AccountException("Cannot authenticate");
    }
    OAuthUserInfo userInfo;
    try {
        userInfo = loginProvider.login(who.getUserName(), who.getPassword());
    } catch (IOException e) {
        throw new AccountException("Cannot authenticate", e);
    }
    if (userInfo == null) {
        throw new AccountException("Cannot authenticate");
    }
    if (!Strings.isNullOrEmpty(userInfo.getEmailAddress())) {
        who.setEmailAddress(userInfo.getEmailAddress());
    }
    if (!Strings.isNullOrEmpty(userInfo.getDisplayName())) {
        who.setDisplayName(userInfo.getDisplayName());
    }
    return who;
}
#end_block

#method_before
@Override
public AuthRequest link(ReviewDb db, Id to, AuthRequest who) {
    return who;
}
#method_after
@Override
public AuthRequest link(ReviewDb db, Account.Id to, AuthRequest who) {
    return who;
}
#end_block

#method_before
@Override
public AuthRequest unlink(ReviewDb db, Id to, AuthRequest who) throws AccountException {
    return who;
}
#method_after
@Override
public AuthRequest unlink(ReviewDb db, Account.Id to, AuthRequest who) throws AccountException {
    return who;
}
#end_block

#method_before
@Override
public Id lookup(String accountName) {
    return null;
}
#method_after
@Override
public Account.Id lookup(String accountName) {
    return null;
}
#end_block

#method_before
public DownloadScheme getDownloadUrl() {
    if (downloadUrl == null) {
        return null;
    }
    return DownloadScheme.valueOf(downloadUrl);
}
#method_after
public String getDownloadUrl() {
    // if accompanied by a 2-phase schema upgrade.)
    if (downloadUrl != null) {
        switch(downloadUrl) {
            case "ANON_GIT":
                return CoreDownloadSchemes.ANON_GIT;
            case "ANON_HTTP":
                return CoreDownloadSchemes.ANON_HTTP;
            case "HTTP":
                return CoreDownloadSchemes.HTTP;
            case "SSH":
                return CoreDownloadSchemes.SSH;
            case "REPO_DOWNLOAD":
                return CoreDownloadSchemes.REPO_DOWNLOAD;
        }
    }
    return downloadUrl;
}
#end_block

#method_before
public void setDownloadUrl(DownloadScheme url) {
    if (url != null) {
        downloadUrl = url.name();
    } else {
        downloadUrl = null;
    }
}
#method_after
public void setDownloadUrl(String url) {
    // if accompanied by a 2-phase schema upgrade.)
    if (downloadUrl != null) {
        switch(url) {
            case CoreDownloadSchemes.ANON_GIT:
                url = "ANON_GIT";
                break;
            case CoreDownloadSchemes.ANON_HTTP:
                url = "ANON_HTTP";
                break;
            case CoreDownloadSchemes.HTTP:
                url = "HTTP";
                break;
            case CoreDownloadSchemes.SSH:
                url = "SSH";
                break;
            case CoreDownloadSchemes.REPO_DOWNLOAD:
                url = "REPO_DOWNLOAD";
                break;
        }
    }
    downloadUrl = url;
}
#end_block

#method_before
public void resetToDefaults() {
    maximumPageSize = DEFAULT_PAGESIZE;
    showSiteHeader = true;
    useFlashClipboard = true;
    reversePatchSetOrder = false;
    reviewCategoryStrategy = null;
    downloadUrl = null;
    downloadCommand = null;
    dateFormat = null;
    timeFormat = null;
    relativeDateInChangeTable = false;
    commentVisibilityStrategy = null;
    diffView = null;
    changeScreen = null;
    sizeBarInChangeTable = true;
    legacycidInChangeTable = false;
    emailingOptionsStrategy = null;
}
#method_after
public void resetToDefaults() {
    maximumPageSize = DEFAULT_PAGESIZE;
    showSiteHeader = true;
    useFlashClipboard = true;
    reviewCategoryStrategy = null;
    downloadUrl = null;
    downloadCommand = null;
    dateFormat = null;
    timeFormat = null;
    relativeDateInChangeTable = false;
    diffView = null;
    sizeBarInChangeTable = true;
    legacycidInChangeTable = false;
    muteCommonPathPrefixes = true;
    emailStrategy = null;
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    showSiteHeader = new CheckBox(Util.C.showSiteHeader());
    useFlashClipboard = new CheckBox(Util.C.useFlashClipboard());
    reversePatchSetOrder = new CheckBox(Util.C.reversePatchSetOrder());
    maximumPageSize = new ListBox();
    for (final short v : PAGESIZE_CHOICES) {
        maximumPageSize.addItem(Util.M.rowsPerPage(v), String.valueOf(v));
    }
    reviewCategoryStrategy = new ListBox();
    reviewCategoryStrategy.addItem(Util.C.messageShowInReviewCategoryNone(), AccountGeneralPreferences.ReviewCategoryStrategy.NONE.name());
    reviewCategoryStrategy.addItem(Util.C.messageShowInReviewCategoryName(), AccountGeneralPreferences.ReviewCategoryStrategy.NAME.name());
    reviewCategoryStrategy.addItem(Util.C.messageShowInReviewCategoryEmail(), AccountGeneralPreferences.ReviewCategoryStrategy.EMAIL.name());
    reviewCategoryStrategy.addItem(Util.C.messageShowInReviewCategoryAbbrev(), AccountGeneralPreferences.ReviewCategoryStrategy.ABBREV.name());
    commentVisibilityStrategy = new ListBox();
    commentVisibilityStrategy.addItem(com.google.gerrit.client.changes.Util.C.messageCollapseAll(), AccountGeneralPreferences.CommentVisibilityStrategy.COLLAPSE_ALL.name());
    commentVisibilityStrategy.addItem(com.google.gerrit.client.changes.Util.C.messageExpandMostRecent(), AccountGeneralPreferences.CommentVisibilityStrategy.EXPAND_MOST_RECENT.name());
    commentVisibilityStrategy.addItem(com.google.gerrit.client.changes.Util.C.messageExpandRecent(), AccountGeneralPreferences.CommentVisibilityStrategy.EXPAND_RECENT.name());
    commentVisibilityStrategy.addItem(com.google.gerrit.client.changes.Util.C.messageExpandAll(), AccountGeneralPreferences.CommentVisibilityStrategy.EXPAND_ALL.name());
    emailingOptionsStrategy = new ListBox();
    emailingOptionsStrategy.addItem(com.google.gerrit.client.changes.Util.C.messageDefaultNone(), AccountGeneralPreferences.EmailingOptionsStrategy.NONE.name());
    emailingOptionsStrategy.addItem(com.google.gerrit.client.changes.Util.C.messageCCMeOnMyComments(), AccountGeneralPreferences.EmailingOptionsStrategy.CC_ME_ON_COMMENTS_I_WRITE.name());
    emailingOptionsStrategy.addItem(com.google.gerrit.client.changes.Util.C.messageDisableEmailNotifications(), AccountGeneralPreferences.EmailingOptionsStrategy.DISABLE_EMAIL_NOTIFICATIONS.name());
    changeScreen = new ListBox();
    changeScreen.addItem(Util.M.changeScreenServerDefault(getLabel(Gerrit.getConfig().getChangeScreen())), "");
    changeScreen.addItem(Util.C.changeScreenOldUi(), AccountGeneralPreferences.ChangeScreen.OLD_UI.name());
    changeScreen.addItem(Util.C.changeScreenNewUi(), AccountGeneralPreferences.ChangeScreen.CHANGE_SCREEN2.name());
    diffView = new ListBox();
    diffView.addItem(com.google.gerrit.client.changes.Util.C.sideBySide(), AccountGeneralPreferences.DiffView.SIDE_BY_SIDE.name());
    diffView.addItem(com.google.gerrit.client.changes.Util.C.unifiedDiff(), AccountGeneralPreferences.DiffView.UNIFIED_DIFF.name());
    Date now = new Date();
    dateFormat = new ListBox();
    for (AccountGeneralPreferences.DateFormat fmt : AccountGeneralPreferences.DateFormat.values()) {
        StringBuilder r = new StringBuilder();
        r.append(DateTimeFormat.getFormat(fmt.getShortFormat()).format(now));
        r.append(" ; ");
        r.append(DateTimeFormat.getFormat(fmt.getLongFormat()).format(now));
        dateFormat.addItem(r.toString(), fmt.name());
    }
    timeFormat = new ListBox();
    for (AccountGeneralPreferences.TimeFormat fmt : AccountGeneralPreferences.TimeFormat.values()) {
        StringBuilder r = new StringBuilder();
        r.append(DateTimeFormat.getFormat(fmt.getFormat()).format(now));
        timeFormat.addItem(r.toString(), fmt.name());
    }
    FlowPanel dateTimePanel = new FlowPanel();
    final int labelIdx, fieldIdx;
    if (LocaleInfo.getCurrentLocale().isRTL()) {
        labelIdx = 1;
        fieldIdx = 0;
        dateTimePanel.add(timeFormat);
        dateTimePanel.add(dateFormat);
    } else {
        labelIdx = 0;
        fieldIdx = 1;
        dateTimePanel.add(dateFormat);
        dateTimePanel.add(timeFormat);
    }
    relativeDateInChangeTable = new CheckBox(Util.C.showRelativeDateInChangeTable());
    sizeBarInChangeTable = new CheckBox(Util.C.showSizeBarInChangeTable());
    legacycidInChangeTable = new CheckBox(Util.C.showLegacycidInChangeTable());
    final Grid formGrid = new Grid(13, 2);
    int row = 0;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, showSiteHeader);
    row++;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, useFlashClipboard);
    row++;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, reversePatchSetOrder);
    row++;
    formGrid.setText(row, labelIdx, Util.C.reviewCategoryLabel());
    formGrid.setWidget(row, fieldIdx, reviewCategoryStrategy);
    row++;
    formGrid.setText(row, labelIdx, Util.C.maximumPageSizeFieldLabel());
    formGrid.setWidget(row, fieldIdx, maximumPageSize);
    row++;
    formGrid.setText(row, labelIdx, Util.C.dateFormatLabel());
    formGrid.setWidget(row, fieldIdx, dateTimePanel);
    row++;
    if (Gerrit.getConfig().getNewFeatures()) {
        formGrid.setText(row, labelIdx, "");
        formGrid.setWidget(row, fieldIdx, relativeDateInChangeTable);
        row++;
        formGrid.setText(row, labelIdx, "");
        formGrid.setWidget(row, fieldIdx, sizeBarInChangeTable);
        row++;
        formGrid.setText(row, labelIdx, "");
        formGrid.setWidget(row, fieldIdx, legacycidInChangeTable);
        row++;
    }
    formGrid.setText(row, labelIdx, Util.C.commentVisibilityLabel());
    formGrid.setWidget(row, fieldIdx, commentVisibilityStrategy);
    row++;
    formGrid.setText(row, labelIdx, Util.C.emailingOptionsFieldLabel());
    formGrid.setWidget(row, fieldIdx, emailingOptionsStrategy);
    row++;
    if (Gerrit.getConfig().getNewFeatures()) {
        formGrid.setText(row, labelIdx, Util.C.changeScreenLabel());
        formGrid.setWidget(row, fieldIdx, changeScreen);
        row++;
        formGrid.setText(row, labelIdx, Util.C.diffViewLabel());
        formGrid.setWidget(row, fieldIdx, diffView);
    }
    add(formGrid);
    save = new Button(Util.C.buttonSaveChanges());
    save.setEnabled(false);
    save.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doSave();
        }
    });
    myMenus = new MyMenuPanel(save);
    add(myMenus);
    add(save);
    final OnEditEnabler e = new OnEditEnabler(save);
    e.listenTo(showSiteHeader);
    e.listenTo(useFlashClipboard);
    e.listenTo(reversePatchSetOrder);
    e.listenTo(maximumPageSize);
    e.listenTo(dateFormat);
    e.listenTo(timeFormat);
    e.listenTo(relativeDateInChangeTable);
    e.listenTo(sizeBarInChangeTable);
    e.listenTo(legacycidInChangeTable);
    e.listenTo(reviewCategoryStrategy);
    e.listenTo(commentVisibilityStrategy);
    e.listenTo(changeScreen);
    e.listenTo(diffView);
    e.listenTo(emailingOptionsStrategy);
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    showSiteHeader = new CheckBox(Util.C.showSiteHeader());
    useFlashClipboard = new CheckBox(Util.C.useFlashClipboard());
    maximumPageSize = new ListBox();
    for (final short v : PAGESIZE_CHOICES) {
        maximumPageSize.addItem(Util.M.rowsPerPage(v), String.valueOf(v));
    }
    reviewCategoryStrategy = new ListBox();
    reviewCategoryStrategy.addItem(Util.C.messageShowInReviewCategoryNone(), AccountGeneralPreferences.ReviewCategoryStrategy.NONE.name());
    reviewCategoryStrategy.addItem(Util.C.messageShowInReviewCategoryName(), AccountGeneralPreferences.ReviewCategoryStrategy.NAME.name());
    reviewCategoryStrategy.addItem(Util.C.messageShowInReviewCategoryEmail(), AccountGeneralPreferences.ReviewCategoryStrategy.EMAIL.name());
    reviewCategoryStrategy.addItem(Util.C.messageShowInReviewCategoryUsername(), AccountGeneralPreferences.ReviewCategoryStrategy.USERNAME.name());
    reviewCategoryStrategy.addItem(Util.C.messageShowInReviewCategoryAbbrev(), AccountGeneralPreferences.ReviewCategoryStrategy.ABBREV.name());
    emailStrategy = new ListBox();
    emailStrategy.addItem(Util.C.messageEnabled(), AccountGeneralPreferences.EmailStrategy.ENABLED.name());
    emailStrategy.addItem(Util.C.messageCCMeOnMyComments(), AccountGeneralPreferences.EmailStrategy.CC_ON_OWN_COMMENTS.name());
    emailStrategy.addItem(Util.C.messageDisabled(), AccountGeneralPreferences.EmailStrategy.DISABLED.name());
    diffView = new ListBox();
    diffView.addItem(com.google.gerrit.client.changes.Util.C.sideBySide(), AccountGeneralPreferences.DiffView.SIDE_BY_SIDE.name());
    diffView.addItem(com.google.gerrit.client.changes.Util.C.unifiedDiff(), AccountGeneralPreferences.DiffView.UNIFIED_DIFF.name());
    Date now = new Date();
    dateFormat = new ListBox();
    for (AccountGeneralPreferences.DateFormat fmt : AccountGeneralPreferences.DateFormat.values()) {
        StringBuilder r = new StringBuilder();
        r.append(DateTimeFormat.getFormat(fmt.getShortFormat()).format(now));
        r.append(" ; ");
        r.append(DateTimeFormat.getFormat(fmt.getLongFormat()).format(now));
        dateFormat.addItem(r.toString(), fmt.name());
    }
    timeFormat = new ListBox();
    for (AccountGeneralPreferences.TimeFormat fmt : AccountGeneralPreferences.TimeFormat.values()) {
        StringBuilder r = new StringBuilder();
        r.append(DateTimeFormat.getFormat(fmt.getFormat()).format(now));
        timeFormat.addItem(r.toString(), fmt.name());
    }
    FlowPanel dateTimePanel = new FlowPanel();
    final int labelIdx;
    final int fieldIdx;
    if (LocaleInfo.getCurrentLocale().isRTL()) {
        labelIdx = 1;
        fieldIdx = 0;
        dateTimePanel.add(timeFormat);
        dateTimePanel.add(dateFormat);
    } else {
        labelIdx = 0;
        fieldIdx = 1;
        dateTimePanel.add(dateFormat);
        dateTimePanel.add(timeFormat);
    }
    relativeDateInChangeTable = new CheckBox(Util.C.showRelativeDateInChangeTable());
    sizeBarInChangeTable = new CheckBox(Util.C.showSizeBarInChangeTable());
    legacycidInChangeTable = new CheckBox(Util.C.showLegacycidInChangeTable());
    muteCommonPathPrefixes = new CheckBox(Util.C.muteCommonPathPrefixes());
    boolean flashClippy = !UserAgent.hasJavaScriptClipboard() && UserAgent.Flash.isInstalled();
    final Grid formGrid = new Grid(11 + (flashClippy ? 1 : 0), 2);
    int row = 0;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, showSiteHeader);
    row++;
    if (flashClippy) {
        formGrid.setText(row, labelIdx, "");
        formGrid.setWidget(row, fieldIdx, useFlashClipboard);
        row++;
    }
    formGrid.setText(row, labelIdx, Util.C.reviewCategoryLabel());
    formGrid.setWidget(row, fieldIdx, reviewCategoryStrategy);
    row++;
    formGrid.setText(row, labelIdx, Util.C.maximumPageSizeFieldLabel());
    formGrid.setWidget(row, fieldIdx, maximumPageSize);
    row++;
    formGrid.setText(row, labelIdx, Util.C.dateFormatLabel());
    formGrid.setWidget(row, fieldIdx, dateTimePanel);
    row++;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, relativeDateInChangeTable);
    row++;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, sizeBarInChangeTable);
    row++;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, legacycidInChangeTable);
    row++;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, muteCommonPathPrefixes);
    row++;
    formGrid.setText(row, labelIdx, Util.C.emailFieldLabel());
    formGrid.setWidget(row, fieldIdx, emailStrategy);
    row++;
    formGrid.setText(row, labelIdx, Util.C.diffViewLabel());
    formGrid.setWidget(row, fieldIdx, diffView);
    add(formGrid);
    save = new Button(Util.C.buttonSaveChanges());
    save.setEnabled(false);
    save.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doSave();
        }
    });
    myMenus = new MyMenuPanel(save);
    add(myMenus);
    add(save);
    final OnEditEnabler e = new OnEditEnabler(save);
    e.listenTo(showSiteHeader);
    e.listenTo(useFlashClipboard);
    e.listenTo(maximumPageSize);
    e.listenTo(dateFormat);
    e.listenTo(timeFormat);
    e.listenTo(relativeDateInChangeTable);
    e.listenTo(sizeBarInChangeTable);
    e.listenTo(legacycidInChangeTable);
    e.listenTo(muteCommonPathPrefixes);
    e.listenTo(diffView);
    e.listenTo(reviewCategoryStrategy);
    e.listenTo(emailStrategy);
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    AccountApi.self().view("preferences").get(new ScreenLoadCallback<Preferences>(this) {

        @Override
        public void preDisplay(Preferences prefs) {
            display(prefs);
        }
    });
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    ExtensionPanel extensionPanel = createExtensionPoint(GerritUiExtensionPoint.PREFERENCES_SCREEN_BOTTOM);
    extensionPanel.addStyleName(Gerrit.RESOURCES.css().extensionPanel());
    add(extensionPanel);
    AccountApi.self().view("preferences").get(new ScreenLoadCallback<AccountPreferencesInfo>(this) {

        @Override
        public void preDisplay(AccountPreferencesInfo prefs) {
            display(prefs);
        }
    });
}
#end_block

#method_before
private void enable(final boolean on) {
    showSiteHeader.setEnabled(on);
    useFlashClipboard.setEnabled(on);
    reversePatchSetOrder.setEnabled(on);
    maximumPageSize.setEnabled(on);
    dateFormat.setEnabled(on);
    timeFormat.setEnabled(on);
    relativeDateInChangeTable.setEnabled(on);
    sizeBarInChangeTable.setEnabled(on);
    legacycidInChangeTable.setEnabled(on);
    reviewCategoryStrategy.setEnabled(on);
    commentVisibilityStrategy.setEnabled(on);
    changeScreen.setEnabled(on);
    diffView.setEnabled(on);
    emailingOptionsStrategy.setEnabled(on);
}
#method_after
private void enable(final boolean on) {
    showSiteHeader.setEnabled(on);
    useFlashClipboard.setEnabled(on);
    maximumPageSize.setEnabled(on);
    dateFormat.setEnabled(on);
    timeFormat.setEnabled(on);
    relativeDateInChangeTable.setEnabled(on);
    sizeBarInChangeTable.setEnabled(on);
    legacycidInChangeTable.setEnabled(on);
    muteCommonPathPrefixes.setEnabled(on);
    reviewCategoryStrategy.setEnabled(on);
    diffView.setEnabled(on);
    emailStrategy.setEnabled(on);
}
#end_block

#method_before
private void display(JsArray<TopMenuItem> items) {
    List<List<String>> values = new ArrayList<>();
    for (TopMenuItem item : Natives.asList(items)) {
        values.add(Arrays.asList(item.getName(), item.getUrl()));
    }
    myMenus.display(values);
}
#method_after
private void display(AccountPreferencesInfo p) {
    showSiteHeader.setValue(p.showSiteHeader());
    useFlashClipboard.setValue(p.useFlashClipboard());
    setListBox(maximumPageSize, DEFAULT_PAGESIZE, p.changesPerPage());
    setListBox(// 
    dateFormat, // 
    AccountGeneralPreferences.DateFormat.STD, p.dateFormat());
    setListBox(// 
    timeFormat, // 
    AccountGeneralPreferences.TimeFormat.HHMM_12, p.timeFormat());
    relativeDateInChangeTable.setValue(p.relativeDateInChangeTable());
    sizeBarInChangeTable.setValue(p.sizeBarInChangeTable());
    legacycidInChangeTable.setValue(p.legacycidInChangeTable());
    muteCommonPathPrefixes.setValue(p.muteCommonPathPrefixes());
    setListBox(reviewCategoryStrategy, AccountGeneralPreferences.ReviewCategoryStrategy.NONE, p.reviewCategoryStrategy());
    setListBox(diffView, AccountGeneralPreferences.DiffView.SIDE_BY_SIDE, p.diffView());
    setListBox(emailStrategy, AccountGeneralPreferences.EmailStrategy.ENABLED, p.emailStrategy());
    display(p.my());
}
#end_block

#method_before
private void doSave() {
    final AccountGeneralPreferences p = new AccountGeneralPreferences();
    p.setShowSiteHeader(showSiteHeader.getValue());
    p.setUseFlashClipboard(useFlashClipboard.getValue());
    p.setReversePatchSetOrder(reversePatchSetOrder.getValue());
    p.setMaximumPageSize(getListBox(maximumPageSize, DEFAULT_PAGESIZE));
    p.setDateFormat(getListBox(dateFormat, AccountGeneralPreferences.DateFormat.STD, AccountGeneralPreferences.DateFormat.values()));
    p.setTimeFormat(getListBox(timeFormat, AccountGeneralPreferences.TimeFormat.HHMM_12, AccountGeneralPreferences.TimeFormat.values()));
    p.setRelativeDateInChangeTable(relativeDateInChangeTable.getValue());
    p.setSizeBarInChangeTable(sizeBarInChangeTable.getValue());
    p.setLegacycidInChangeTable(legacycidInChangeTable.getValue());
    p.setReviewCategoryStrategy(getListBox(reviewCategoryStrategy, ReviewCategoryStrategy.NONE, ReviewCategoryStrategy.values()));
    p.setCommentVisibilityStrategy(getListBox(commentVisibilityStrategy, CommentVisibilityStrategy.EXPAND_RECENT, CommentVisibilityStrategy.values()));
    p.setDiffView(getListBox(diffView, AccountGeneralPreferences.DiffView.SIDE_BY_SIDE, AccountGeneralPreferences.DiffView.values()));
    p.setEmailingOptionsStrategy(getListBox(emailingOptionsStrategy, EmailingOptionsStrategy.NONE, EmailingOptionsStrategy.values()));
    p.setChangeScreen(getListBox(changeScreen, null, AccountGeneralPreferences.ChangeScreen.values()));
    enable(false);
    save.setEnabled(false);
    List<TopMenuItem> items = new ArrayList<>();
    for (List<String> v : myMenus.getValues()) {
        items.add(TopMenuItem.create(v.get(0), v.get(1)));
    }
    AccountApi.self().view("preferences").post(Preferences.create(p, items), new GerritCallback<Preferences>() {

        @Override
        public void onSuccess(Preferences prefs) {
            Gerrit.getUserAccount().setGeneralPreferences(p);
            Gerrit.applyUserPreferences();
            Dispatcher.changeScreen2 = false;
            enable(true);
            display(prefs);
            Gerrit.refreshMenuBar();
        }

        @Override
        public void onFailure(Throwable caught) {
            enable(true);
            save.setEnabled(true);
            super.onFailure(caught);
        }
    });
}
#method_after
private void doSave() {
    AccountPreferencesInfo p = AccountPreferencesInfo.create();
    p.showSiteHeader(showSiteHeader.getValue());
    p.useFlashClipboard(useFlashClipboard.getValue());
    p.changesPerPage(getListBox(maximumPageSize, DEFAULT_PAGESIZE));
    p.dateFormat(getListBox(dateFormat, AccountGeneralPreferences.DateFormat.STD, AccountGeneralPreferences.DateFormat.values()));
    p.timeFormat(getListBox(timeFormat, AccountGeneralPreferences.TimeFormat.HHMM_12, AccountGeneralPreferences.TimeFormat.values()));
    p.relativeDateInChangeTable(relativeDateInChangeTable.getValue());
    p.sizeBarInChangeTable(sizeBarInChangeTable.getValue());
    p.legacycidInChangeTable(legacycidInChangeTable.getValue());
    p.muteCommonPathPrefixes(muteCommonPathPrefixes.getValue());
    p.reviewCategoryStrategy(getListBox(reviewCategoryStrategy, ReviewCategoryStrategy.NONE, ReviewCategoryStrategy.values()));
    p.diffView(getListBox(diffView, AccountGeneralPreferences.DiffView.SIDE_BY_SIDE, AccountGeneralPreferences.DiffView.values()));
    p.emailStrategy(getListBox(emailStrategy, EmailStrategy.ENABLED, EmailStrategy.values()));
    List<TopMenuItem> items = new ArrayList<>();
    for (List<String> v : myMenus.getValues()) {
        items.add(TopMenuItem.create(v.get(0), v.get(1)));
    }
    p.setMyMenus(items);
    enable(false);
    save.setEnabled(false);
    AccountApi.self().view("preferences").put(p, new GerritCallback<AccountPreferencesInfo>() {

        @Override
        public void onSuccess(AccountPreferencesInfo prefs) {
            Gerrit.setUserPreferences(prefs);
            enable(true);
            display(prefs);
        }

        @Override
        public void onFailure(Throwable caught) {
            enable(true);
            save.setEnabled(true);
            super.onFailure(caught);
        }
    });
}
#end_block

#method_before
@Override
public GetPreferences.PreferenceInfo apply(AccountResource rsrc, Input i) throws AuthException, ResourceNotFoundException, OrmException, IOException, ConfigInvalidException {
    if (self.get() != rsrc.getUser() && !self.get().getCapabilities().canAdministrateServer()) {
        throw new AuthException("restricted to administrator");
    }
    if (i == null) {
        i = new Input();
    }
    Account.Id accountId = rsrc.getUser().getAccountId();
    AccountGeneralPreferences p;
    VersionedAccountPreferences versionedPrefs;
    MetaDataUpdate md = metaDataUpdateFactory.create(allUsersName);
    db.get().accounts().beginTransaction(accountId);
    try {
        Account a = db.get().accounts().get(accountId);
        if (a == null) {
            throw new ResourceNotFoundException();
        }
        versionedPrefs = VersionedAccountPreferences.forUser(accountId);
        versionedPrefs.load(md);
        p = a.getGeneralPreferences();
        if (p == null) {
            p = new AccountGeneralPreferences();
            a.setGeneralPreferences(p);
        }
        if (i.changesPerPage != null) {
            p.setMaximumPageSize(i.changesPerPage);
        }
        if (i.showSiteHeader != null) {
            p.setShowSiteHeader(i.showSiteHeader);
        }
        if (i.useFlashClipboard != null) {
            p.setUseFlashClipboard(i.useFlashClipboard);
        }
        if (i.downloadScheme != null) {
            p.setDownloadUrl(i.downloadScheme);
        }
        if (i.downloadCommand != null) {
            p.setDownloadCommand(i.downloadCommand);
        }
        if (i.dateFormat != null) {
            p.setDateFormat(i.dateFormat);
        }
        if (i.timeFormat != null) {
            p.setTimeFormat(i.timeFormat);
        }
        if (i.reversePatchSetOrder != null) {
            p.setReversePatchSetOrder(i.reversePatchSetOrder);
        }
        if (i.relativeDateInChangeTable != null) {
            p.setRelativeDateInChangeTable(i.relativeDateInChangeTable);
        }
        if (i.sizeBarInChangeTable != null) {
            p.setSizeBarInChangeTable(i.sizeBarInChangeTable);
        }
        if (i.legacycidInChangeTable != null) {
            p.setLegacycidInChangeTable(i.legacycidInChangeTable);
        }
        if (i.reviewCategoryStrategy != null) {
            p.setReviewCategoryStrategy(i.reviewCategoryStrategy);
        }
        if (i.commentVisibilityStrategy != null) {
            p.setCommentVisibilityStrategy(i.commentVisibilityStrategy);
        }
        if (i.diffView != null) {
            p.setDiffView(i.diffView);
        }
        if (i.emailingOptionsStrategy != null) {
            p.setEmailingOptionsStrategy(i.emailingOptionsStrategy);
        }
        if (i.changeScreen != null) {
            p.setChangeScreen(i.changeScreen);
        }
        db.get().accounts().update(Collections.singleton(a));
        db.get().commit();
        storeMyMenus(versionedPrefs, i.my);
        versionedPrefs.commit(md);
        cache.evict(accountId);
        return new GetPreferences.PreferenceInfo(p, versionedPrefs, md.getRepository());
    } finally {
        md.close();
        db.get().rollback();
    }
}
#method_after
@Override
public GetPreferences.PreferenceInfo apply(AccountResource rsrc, Input i) throws AuthException, ResourceNotFoundException, BadRequestException, OrmException, IOException, ConfigInvalidException {
    if (self.get() != rsrc.getUser() && !self.get().getCapabilities().canModifyAccount()) {
        throw new AuthException("restricted to members of Modify Accounts");
    }
    if (i == null) {
        i = new Input();
    }
    Account.Id accountId = rsrc.getUser().getAccountId();
    AccountGeneralPreferences p;
    VersionedAccountPreferences versionedPrefs;
    MetaDataUpdate md = metaDataUpdateFactory.get().create(allUsersName);
    db.get().accounts().beginTransaction(accountId);
    try {
        Account a = db.get().accounts().get(accountId);
        if (a == null) {
            throw new ResourceNotFoundException();
        }
        versionedPrefs = VersionedAccountPreferences.forUser(accountId);
        versionedPrefs.load(md);
        p = a.getGeneralPreferences();
        if (p == null) {
            p = new AccountGeneralPreferences();
            a.setGeneralPreferences(p);
        }
        if (i.changesPerPage != null) {
            p.setMaximumPageSize(i.changesPerPage);
        }
        if (i.showSiteHeader != null) {
            p.setShowSiteHeader(i.showSiteHeader);
        }
        if (i.useFlashClipboard != null) {
            p.setUseFlashClipboard(i.useFlashClipboard);
        }
        if (i.downloadScheme != null) {
            setDownloadScheme(p, i.downloadScheme);
        }
        if (i.downloadCommand != null) {
            p.setDownloadCommand(i.downloadCommand);
        }
        if (i.dateFormat != null) {
            p.setDateFormat(i.dateFormat);
        }
        if (i.timeFormat != null) {
            p.setTimeFormat(i.timeFormat);
        }
        if (i.relativeDateInChangeTable != null) {
            p.setRelativeDateInChangeTable(i.relativeDateInChangeTable);
        }
        if (i.sizeBarInChangeTable != null) {
            p.setSizeBarInChangeTable(i.sizeBarInChangeTable);
        }
        if (i.legacycidInChangeTable != null) {
            p.setLegacycidInChangeTable(i.legacycidInChangeTable);
        }
        if (i.muteCommonPathPrefixes != null) {
            p.setMuteCommonPathPrefixes(i.muteCommonPathPrefixes);
        }
        if (i.reviewCategoryStrategy != null) {
            p.setReviewCategoryStrategy(i.reviewCategoryStrategy);
        }
        if (i.diffView != null) {
            p.setDiffView(i.diffView);
        }
        if (i.emailStrategy != null) {
            p.setEmailStrategy(i.emailStrategy);
        }
        db.get().accounts().update(Collections.singleton(a));
        db.get().commit();
        storeMyMenus(versionedPrefs, i.my);
        storeUrlAliases(versionedPrefs, i.urlAliases);
        versionedPrefs.commit(md);
        cache.evict(accountId);
        return new GetPreferences.PreferenceInfo(p, versionedPrefs, md.getRepository());
    } finally {
        md.close();
        db.get().rollback();
    }
}
#end_block

#method_before
public static void storeMyMenus(VersionedAccountPreferences prefs, List<TopMenu.MenuItem> my) {
    Config cfg = prefs.getConfig();
    if (my != null) {
        unsetSection(cfg, MY);
        for (TopMenu.MenuItem item : my) {
            set(cfg, item.name, KEY_URL, item.url);
            set(cfg, item.name, KEY_TARGET, item.target);
            set(cfg, item.name, KEY_ID, item.id);
        }
    }
}
#method_after
public static void storeMyMenus(VersionedAccountPreferences prefs, List<TopMenu.MenuItem> my) {
    Config cfg = prefs.getConfig();
    if (my != null) {
        unsetSection(cfg, UserConfigSections.MY);
        for (TopMenu.MenuItem item : my) {
            set(cfg, item.name, KEY_URL, item.url);
            set(cfg, item.name, KEY_TARGET, item.target);
            set(cfg, item.name, KEY_ID, item.id);
        }
    }
}
#end_block

#method_before
private static void set(Config cfg, String section, String key, String val) {
    if (Strings.isNullOrEmpty(val)) {
        cfg.unset(MY, section, key);
    } else {
        cfg.setString(MY, section, key, val);
    }
}
#method_after
private static void set(Config cfg, String section, String key, String val) {
    if (Strings.isNullOrEmpty(val)) {
        cfg.unset(UserConfigSections.MY, section, key);
    } else {
        cfg.setString(UserConfigSections.MY, section, key, val);
    }
}
#end_block

#method_before
public void send() throws EmailException {
    if (!args.emailSender.isEnabled()) {
        // 
        return;
    }
    init();
    format();
    appendText(velocifyFile("Footer.vm"));
    if (shouldSendMessage()) {
        if (fromId != null) {
            final Account fromUser = args.accountCache.get(fromId).getAccount();
            EmailingOptionsStrategy selectedEmailOption = fromUser.getGeneralPreferences().getEmailingOptionsStrategy();
            if (selectedEmailOption.equals(EmailingOptionsStrategy.CC_ME_ON_COMMENTS_I_WRITE)) {
                // If we are impersonating a user, make sure they receive a CC of
                // this message so they can always review and audit what we sent
                // on their behalf to others.
                // 
                add(RecipientType.CC, fromId);
            } else if (selectedEmailOption.equals(EmailingOptionsStrategy.DISABLE_EMAIL_NOTIFICATIONS) || rcptTo.remove(fromId)) {
                // If they don't want a copy, but we queued one up anyway,
                // drop them from the recipient lists.
                // 
                final String fromEmail = fromUser.getPreferredEmail();
                for (Iterator<Address> i = smtpRcptTo.iterator(); i.hasNext(); ) {
                    if (i.next().email.equals(fromEmail)) {
                        i.remove();
                    }
                }
                for (EmailHeader hdr : headers.values()) {
                    if (hdr instanceof AddressList) {
                        ((AddressList) hdr).remove(fromEmail);
                    }
                }
            }
            // his email notifications then drop him from recipients' list
            for (Iterator<Account.Id> i = rcptTo.iterator(); i.hasNext(); ) {
                Account.Id id = i.next();
                Account thisUser = args.accountCache.get(id).getAccount();
                if (thisUser.getGeneralPreferences().getEmailingOptionsStrategy().equals(EmailingOptionsStrategy.DISABLE_EMAIL_NOTIFICATIONS)) {
                    final String fromEmail = thisUser.getPreferredEmail();
                    for (Iterator<Address> j = smtpRcptTo.iterator(); j.hasNext(); ) {
                        if (j.next().email.equals(fromEmail)) {
                            j.remove();
                        }
                    }
                }
                if (smtpRcptTo.isEmpty()) {
                    return;
                }
            }
        }
        args.emailSender.send(smtpFromAddress, smtpRcptTo, headers, body.toString());
    }
}
#method_after
public void send() throws EmailException {
    if (!args.emailSender.isEnabled()) {
        // 
        return;
    }
    init();
    format();
    appendText(velocifyFile("Footer.vm"));
    if (shouldSendMessage()) {
        if (fromId != null) {
            final Account fromUser = args.accountCache.get(fromId).getAccount();
            EmailStrategy strategy = fromUser.getGeneralPreferences().getEmailStrategy();
            if (strategy == EmailStrategy.CC_ON_OWN_COMMENTS) {
                // If we are impersonating a user, make sure they receive a CC of
                // this message so they can always review and audit what we sent
                // on their behalf to others.
                // 
                add(RecipientType.CC, fromId);
            } else if (rcptTo.remove(fromId)) {
                // If they don't want a copy, but we queued one up anyway,
                // drop them from the recipient lists.
                // 
                removeUser(fromUser);
            }
            // his email notifications then drop him from recipients' list
            for (Account.Id id : rcptTo) {
                Account thisUser = args.accountCache.get(id).getAccount();
                if (thisUser.getGeneralPreferences().getEmailStrategy() == EmailStrategy.DISABLED) {
                    removeUser(thisUser);
                }
                if (smtpRcptTo.isEmpty()) {
                    return;
                }
            }
        }
        OutgoingEmailValidationListener.Args va = new OutgoingEmailValidationListener.Args();
        va.messageClass = messageClass;
        va.smtpFromAddress = smtpFromAddress;
        va.smtpRcptTo = smtpRcptTo;
        va.headers = headers;
        va.body = body.toString();
        for (OutgoingEmailValidationListener validator : args.outgoingEmailValidationListeners) {
            try {
                validator.validateOutgoingEmail(va);
            } catch (ValidationException e) {
                return;
            }
        }
        args.emailSender.send(va.smtpFromAddress, va.smtpRcptTo, va.headers, va.body);
    }
}
#end_block

#method_before
protected String getNameFor(final Account.Id accountId) {
    if (accountId == null) {
        return args.anonymousCowardName;
    }
    final Account userAccount = args.accountCache.get(accountId).getAccount();
    String name = userAccount.getFullName();
    if (name == null) {
        name = userAccount.getPreferredEmail();
    }
    if (name == null) {
        name = args.anonymousCowardName + " #" + accountId;
    }
    return name;
}
#method_after
protected String getNameFor(final Account.Id accountId) {
    if (accountId == null) {
        return args.gerritPersonIdent.getName();
    }
    final Account userAccount = args.accountCache.get(accountId).getAccount();
    String name = userAccount.getFullName();
    if (name == null) {
        name = userAccount.getPreferredEmail();
    }
    if (name == null) {
        name = args.anonymousCowardName + " #" + accountId;
    }
    return name;
}
#end_block

#method_before
protected String velocifyFile(String name) throws EmailException {
    try {
        RuntimeInstance runtime = args.velocityRuntime;
        if (runtime.getLoaderNameForResource(name) == null) {
            name = "com/google/gerrit/server/mail/" + name;
        }
        Template template = runtime.getTemplate(name, "UTF-8");
        StringWriter w = new StringWriter();
        template.merge(velocityContext, w);
        return w.toString();
    } catch (Exception e) {
        throw new EmailException("Cannot format velocity template " + name, e);
    }
}
#method_after
protected String velocifyFile(String name) throws EmailException {
    try {
        RuntimeInstance runtime = args.velocityRuntime;
        if (runtime.getLoaderNameForResource(name) == null) {
            name = "com/google/gerrit/server/mail/" + name;
        }
        Template template = runtime.getTemplate(name, UTF_8.name());
        StringWriter w = new StringWriter();
        template.merge(velocityContext, w);
        return w.toString();
    } catch (Exception e) {
        throw new EmailException("Cannot format velocity template " + name, e);
    }
}
#end_block

#method_before
@Override
public PreferenceInfo apply(AccountResource rsrc) throws AuthException, ResourceNotFoundException, OrmException, IOException, ConfigInvalidException {
    if (self.get() != rsrc.getUser() && !self.get().getCapabilities().canAdministrateServer()) {
        throw new AuthException("restricted to administrator");
    }
    Account a = db.get().accounts().get(rsrc.getUser().getAccountId());
    if (a == null) {
        throw new ResourceNotFoundException();
    }
    Repository git = gitMgr.openRepository(allUsersName);
    try {
        VersionedAccountPreferences p = VersionedAccountPreferences.forUser(rsrc.getUser().getAccountId());
        p.load(git);
        return new PreferenceInfo(a.getGeneralPreferences(), p, git);
    } finally {
        git.close();
    }
}
#method_after
@Override
public PreferenceInfo apply(AccountResource rsrc) throws AuthException, ResourceNotFoundException, OrmException, IOException, ConfigInvalidException {
    if (self.get() != rsrc.getUser() && !self.get().getCapabilities().canAdministrateServer()) {
        throw new AuthException("restricted to administrator");
    }
    Account a = db.get().accounts().get(rsrc.getUser().getAccountId());
    if (a == null) {
        throw new ResourceNotFoundException();
    }
    try (Repository git = gitMgr.openRepository(allUsersName)) {
        VersionedAccountPreferences p = VersionedAccountPreferences.forUser(rsrc.getUser().getAccountId());
        p.load(git);
        return new PreferenceInfo(a.getGeneralPreferences(), p, git);
    }
}
#end_block

#method_before
private List<TopMenu.MenuItem> my(VersionedAccountPreferences v) {
    List<TopMenu.MenuItem> my = new ArrayList<>();
    Config cfg = v.getConfig();
    for (String subsection : cfg.getSubsections(MY)) {
        String url = my(cfg, subsection, KEY_URL, "#/");
        String target = my(cfg, subsection, KEY_TARGET, url.startsWith("#") ? null : "_blank");
        my.add(new TopMenu.MenuItem(subsection, url, target, my(cfg, subsection, KEY_ID, null)));
    }
    return my;
}
#method_after
private List<TopMenu.MenuItem> my(VersionedAccountPreferences v) {
    List<TopMenu.MenuItem> my = new ArrayList<>();
    Config cfg = v.getConfig();
    for (String subsection : cfg.getSubsections(UserConfigSections.MY)) {
        String url = my(cfg, subsection, KEY_URL, "#/");
        String target = my(cfg, subsection, KEY_TARGET, url.startsWith("#") ? null : "_blank");
        my.add(new TopMenu.MenuItem(subsection, url, target, my(cfg, subsection, KEY_ID, null)));
    }
    return my;
}
#end_block

#method_before
private static String my(Config cfg, String subsection, String key, String defaultValue) {
    String val = cfg.getString(MY, subsection, key);
    return !Strings.isNullOrEmpty(val) ? val : defaultValue;
}
#method_after
private static String my(Config cfg, String subsection, String key, String defaultValue) {
    String val = cfg.getString(UserConfigSections.MY, subsection, key);
    return !Strings.isNullOrEmpty(val) ? val : defaultValue;
}
#end_block

#method_before
@Override
public Object apply(ConfigResource rsrc, Input i) throws BadRequestException, IOException, ConfigInvalidException {
    if (i.changesPerPage != null || i.showSiteHeader != null || i.useFlashClipboard != null || i.downloadScheme != null || i.downloadCommand != null || i.dateFormat != null || i.timeFormat != null || i.reversePatchSetOrder != null || i.relativeDateInChangeTable != null || i.sizeBarInChangeTable != null || i.legacycidInChangeTable != null || i.reviewCategoryStrategy != null || i.commentVisibilityStrategy != null || i.diffView != null || i.emailingOptionsStrategy != null || i.changeScreen != null) {
        throw new BadRequestException("unsupported option");
    }
    VersionedAccountPreferences p;
    MetaDataUpdate md = metaDataUpdateFactory.create(allUsersName);
    try {
        p = VersionedAccountPreferences.forDefault();
        p.load(md);
        com.google.gerrit.server.account.SetPreferences.storeMyMenus(p, i.my);
        p.commit(md);
        return new PreferenceInfo(null, p, md.getRepository());
    } finally {
        md.close();
    }
}
#method_after
@Override
public Object apply(ConfigResource rsrc, Input i) throws BadRequestException, IOException, ConfigInvalidException {
    if (i.changesPerPage != null || i.showSiteHeader != null || i.useFlashClipboard != null || i.downloadScheme != null || i.downloadCommand != null || i.dateFormat != null || i.timeFormat != null || i.relativeDateInChangeTable != null || i.sizeBarInChangeTable != null || i.legacycidInChangeTable != null || i.muteCommonPathPrefixes != null || i.reviewCategoryStrategy != null || i.emailStrategy != null) {
        throw new BadRequestException("unsupported option");
    }
    VersionedAccountPreferences p;
    MetaDataUpdate md = metaDataUpdateFactory.get().create(allUsersName);
    try {
        p = VersionedAccountPreferences.forDefault();
        p.load(md);
        com.google.gerrit.server.account.SetPreferences.storeMyMenus(p, i.my);
        p.commit(md);
        return new PreferenceInfo(null, p, md.getRepository());
    } finally {
        md.close();
    }
}
#end_block

#method_before
private void doSearch() {
    final String query = searchBox.getText().trim();
    if ("".equals(query)) {
        return;
    }
    searchBox.setFocus(false);
    switch(dropdown.getSelectedIndex()) {
        case 0:
            // changes
            if (query.matches("^[1-9][0-9]*$")) {
                Gerrit.display(PageLinks.toChange(Change.Id.parse(query)));
            } else {
                Gerrit.display(PageLinks.toChangeQuery(query), QueryScreen.forQuery(query));
            }
            break;
        case 1:
            // doc
            Gerrit.display(PageLinks.toDocumentationQuery(query));
            break;
    }
}
#method_after
private void doSearch() {
    final String query = searchBox.getText().trim();
    if ("".equals(query)) {
        return;
    }
    searchBox.setFocus(false);
    if (dropdown != null && dropdown.getSelectedValue().equals(Gerrit.C.searchDropdownDoc())) {
        // doc
        Gerrit.display(PageLinks.toDocumentationQuery(query));
    } else {
        // changes
        if (query.matches("^[1-9][0-9]*$")) {
            Gerrit.display(PageLinks.toChange(Change.Id.parse(query)));
        } else {
            Gerrit.display(PageLinks.toChangeQuery(query), QueryScreen.forQuery(query));
        }
    }
}
#end_block

#method_before
@Override
public void deleteVote(String vote) throws RestApiException {
    try {
        deleteVote.apply(new VoteResource(reviewer, vote), null);
    } catch (OrmException | IOException e) {
        throw new RestApiException("Cannot delete vote", e);
    }
}
#method_after
@Override
public void deleteVote(String label) throws RestApiException {
    try {
        deleteVote.apply(new VoteResource(reviewer, label), null);
    } catch (UpdateException e) {
        throw new RestApiException("Cannot delete vote", e);
    }
}
#end_block

#method_before
@Override
public Map<String, Short> apply(ReviewerResource rsrc) throws OrmException {
    Map<String, Short> votes = new TreeMap<>();
    for (PatchSetApproval psa : approvalsUtil.byChangeUser(db.get(), rsrc.getNotes(), rsrc.getUser().getAccountId())) {
        votes.put(psa.getLabel(), psa.getValue());
    }
    return votes;
}
#method_after
@Override
public Map<String, Short> apply(ReviewerResource rsrc) throws OrmException {
    Map<String, Short> votes = new TreeMap<>();
    Iterable<PatchSetApproval> byPatchSetUser = approvalsUtil.byPatchSetUser(db.get(), rsrc.getControl(), rsrc.getChange().currentPatchSetId(), rsrc.getUser().getAccountId());
    for (PatchSetApproval psa : byPatchSetUser) {
        votes.put(psa.getLabel(), psa.getValue());
    }
    return votes;
}
#end_block

#method_before
@Override
public String id() {
    return Integer.toString(change.getChange().getId().get());
}
#method_after
@Override
public String id() {
    return Integer.toString(change.getId().get());
}
#end_block

#method_before
@Override
public RevisionApi revision(String id) throws RestApiException {
    try {
        return revisionApi.create(revisions.parse(change, IdString.fromDecoded(id)));
    } catch (OrmException e) {
        throw new RestApiException("Cannot parse revision", e);
    }
}
#method_after
@Override
public RevisionApi revision(String id) throws RestApiException {
    try {
        return revisionApi.create(revisions.parse(change, IdString.fromDecoded(id)));
    } catch (OrmException | IOException e) {
        throw new RestApiException("Cannot parse revision", e);
    }
}
#end_block

#method_before
@Override
public void abandon(AbandonInput in) throws RestApiException {
    try {
        abandon.apply(change, in);
    } catch (OrmException | IOException e) {
        throw new RestApiException("Cannot abandon change", e);
    }
}
#method_after
@Override
public void abandon(AbandonInput in) throws RestApiException {
    try {
        abandon.apply(change, in);
    } catch (OrmException | UpdateException e) {
        throw new RestApiException("Cannot abandon change", e);
    }
}
#end_block

#method_before
@Override
public void restore(RestoreInput in) throws RestApiException {
    try {
        restore.apply(change, in);
    } catch (OrmException | IOException e) {
        throw new RestApiException("Cannot restore change", e);
    }
}
#method_after
@Override
public void restore(RestoreInput in) throws RestApiException {
    try {
        restore.apply(change, in);
    } catch (OrmException | UpdateException e) {
        throw new RestApiException("Cannot restore change", e);
    }
}
#end_block

#method_before
@Override
public ChangeApi revert(RevertInput in) throws RestApiException {
    try {
        return changeApi.id(revert.apply(change, in)._number);
    } catch (OrmException | EmailException | IOException e) {
        throw new RestApiException("Cannot revert change", e);
    }
}
#method_after
@Override
public ChangeApi revert(RevertInput in) throws RestApiException {
    try {
        return changeApi.id(revert.apply(change, in)._number);
    } catch (OrmException | IOException | UpdateException e) {
        throw new RestApiException("Cannot revert change", e);
    }
}
#end_block

#method_before
@Override
public void topic(String topic) throws RestApiException {
    PutTopic.Input in = new PutTopic.Input();
    in.topic = topic;
    try {
        putTopic.apply(change, in);
    } catch (OrmException | IOException e) {
        throw new RestApiException("Cannot set topic", e);
    }
}
#method_after
@Override
public void topic(String topic) throws RestApiException {
    PutTopic.Input in = new PutTopic.Input();
    in.topic = topic;
    try {
        putTopic.apply(change, in);
    } catch (UpdateException e) {
        throw new RestApiException("Cannot set topic", e);
    }
}
#end_block

#method_before
@Override
public void addReviewer(AddReviewerInput in) throws RestApiException {
    try {
        postReviewers.apply(change, in);
    } catch (OrmException | EmailException | IOException e) {
        throw new RestApiException("Cannot add change reviewer", e);
    }
}
#method_after
@Override
public void addReviewer(AddReviewerInput in) throws RestApiException {
    try {
        postReviewers.apply(change, in);
    } catch (OrmException | IOException e) {
        throw new RestApiException("Cannot add change reviewer", e);
    }
}
#end_block

#method_before
@Override
public ChangeInfo get(EnumSet<ListChangesOption> s) throws RestApiException {
    try {
        return changeJson.get().addOptions(s).format(change);
    } catch (OrmException e) {
        throw new RestApiException("Cannot retrieve change", e);
    }
}
#method_after
@Override
public ChangeInfo get(EnumSet<ListChangesOption> s) throws RestApiException {
    try {
        CurrentUser u = user.get();
        if (u.isIdentifiedUser()) {
            u.asIdentifiedUser().clearStarredChanges();
        }
        return changeJson.create(s).format(change);
    } catch (OrmException e) {
        throw new RestApiException("Cannot retrieve change", e);
    }
}
#end_block

#method_before
@Override
public void setHashtags(HashtagsInput input) throws RestApiException {
    try {
        postHashtags.apply(change, input);
    } catch (IOException | OrmException e) {
        throw new RestApiException("Cannot post hashtags", e);
    }
}
#method_after
@Override
public void setHashtags(HashtagsInput input) throws RestApiException {
    try {
        postHashtags.apply(change, input);
    } catch (RestApiException | UpdateException e) {
        throw new RestApiException("Cannot post hashtags", e);
    }
}
#end_block

#method_before
@Override
protected void configure() {
    bind(Changes.class).to(ChangesImpl.class);
    factory(ChangeApiImpl.Factory.class);
    factory(RevisionApiImpl.Factory.class);
    factory(ReviewerApiImpl.Factory.class);
}
#method_after
@Override
protected void configure() {
    bind(Changes.class).to(ChangesImpl.class);
    factory(ChangeApiImpl.Factory.class);
    factory(CommentApiImpl.Factory.class);
    factory(DraftApiImpl.Factory.class);
    factory(RevisionApiImpl.Factory.class);
    factory(FileApiImpl.Factory.class);
    factory(ReviewerApiImpl.Factory.class);
}
#end_block

#method_before
@Test
public void get() throws Exception {
    PushOneCommit.Result r = createChange();
    String triplet = "p~master~" + r.getChangeId();
    ChangeInfo c = info(triplet);
    assertThat(c.id).isEqualTo(triplet);
    assertThat(c.project).isEqualTo("p");
    assertThat(c.branch).isEqualTo("master");
    assertThat(c.status).isEqualTo(ChangeStatus.NEW);
    assertThat(c.subject).isEqualTo("test commit");
    assertThat(c.mergeable).isTrue();
    assertThat(c.changeId).isEqualTo(r.getChangeId());
    assertThat(c.created).isEqualTo(c.updated);
    assertThat(c._number).is(1);
    assertThat(c.owner._accountId).is(admin.getId().get());
    assertThat(c.owner.name).isNull();
    assertThat(c.owner.email).isNull();
    assertThat(c.owner.username).isNull();
    assertThat(c.owner.avatars).isNull();
}
#method_after
@Test
public void get() throws Exception {
    PushOneCommit.Result r = createChange();
    String triplet = project.get() + "~master~" + r.getChangeId();
    ChangeInfo c = info(triplet);
    assertThat(c.id).isEqualTo(triplet);
    assertThat(c.project).isEqualTo(project.get());
    assertThat(c.branch).isEqualTo("master");
    assertThat(c.status).isEqualTo(ChangeStatus.NEW);
    assertThat(c.subject).isEqualTo("test commit");
    assertThat(c.mergeable).isTrue();
    assertThat(c.changeId).isEqualTo(r.getChangeId());
    assertThat(c.created).isEqualTo(c.updated);
    assertThat(c._number).isEqualTo(r.getChange().getId().get());
    assertThat(c.owner._accountId).isEqualTo(admin.getId().get());
    assertThat(c.owner.name).isNull();
    assertThat(c.owner.email).isNull();
    assertThat(c.owner.username).isNull();
    assertThat(c.owner.avatars).isNull();
}
#end_block

#method_before
@Test
public void abandon() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).abandon();
}
#method_after
@Test
public void abandon() throws Exception {
    PushOneCommit.Result r = createChange();
    assertThat(info(r.getChangeId()).status).isEqualTo(ChangeStatus.NEW);
    gApi.changes().id(r.getChangeId()).abandon();
    ChangeInfo info = get(r.getChangeId());
    assertThat(info.status).isEqualTo(ChangeStatus.ABANDONED);
    assertThat(Iterables.getLast(info.messages).message.toLowerCase()).contains("abandoned");
}
#end_block

#method_before
@Test
public void restore() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).abandon();
    gApi.changes().id(r.getChangeId()).restore();
}
#method_after
@Test
public void restore() throws Exception {
    PushOneCommit.Result r = createChange();
    assertThat(info(r.getChangeId()).status).isEqualTo(ChangeStatus.NEW);
    gApi.changes().id(r.getChangeId()).abandon();
    assertThat(info(r.getChangeId()).status).isEqualTo(ChangeStatus.ABANDONED);
    gApi.changes().id(r.getChangeId()).restore();
    ChangeInfo info = get(r.getChangeId());
    assertThat(info.status).isEqualTo(ChangeStatus.NEW);
    assertThat(Iterables.getLast(info.messages).message.toLowerCase()).contains("restored");
}
#end_block

#method_before
@Test
public void revert() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.approve());
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).submit();
    gApi.changes().id(r.getChangeId()).revert();
}
#method_after
@Test
public void revert() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.approve());
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).submit();
    ChangeInfo revertChange = gApi.changes().id(r.getChangeId()).revert().get();
    // expected messages on source change:
    // 1. Uploaded patch set 1.
    // 2. Patch Set 1: Code-Review+2
    // 3. Change has been successfully merged by Administrator
    // 4. Patch Set 1: Reverted
    List<ChangeMessageInfo> sourceMessages = new ArrayList<>(gApi.changes().id(r.getChangeId()).get().messages);
    assertThat(sourceMessages).hasSize(4);
    String expectedMessage = String.format("Patch Set 1: Reverted\n\n" + "This patchset was reverted in change: %s", revertChange.changeId);
    assertThat(sourceMessages.get(3).message).isEqualTo(expectedMessage);
    assertThat(revertChange.messages).hasSize(1);
    assertThat(revertChange.messages.iterator().next().message).isEqualTo("Uploaded patch set 1.");
}
#end_block

#method_before
@Test(expected = ResourceConflictException.class)
public void rebase() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).rebase();
}
#method_after
@Test
public void rebase() throws Exception {
    // Create two changes both with the same parent
    PushOneCommit.Result r = createChange();
    testRepo.reset("HEAD~1");
    PushOneCommit.Result r2 = createChange();
    // Approve and submit the first change
    RevisionApi revision = gApi.changes().id(r.getChangeId()).current();
    revision.review(ReviewInput.approve());
    revision.submit();
    // Rebase the second change
    gApi.changes().id(r2.getChangeId()).current().rebase();
    // Second change should have 2 patch sets
    assertThat(r2.getPatchSetId().get()).isEqualTo(2);
    // ...and the committer should be correct
    ChangeInfo info = gApi.changes().id(r2.getChangeId()).get(EnumSet.of(ListChangesOption.CURRENT_REVISION, ListChangesOption.CURRENT_COMMIT));
    GitPerson committer = info.revisions.get(info.currentRevision).commit.committer;
    assertThat(committer.name).isEqualTo(admin.fullName);
    assertThat(committer.email).isEqualTo(admin.email);
}
#end_block

#method_before
@Test
public void addReviewer() throws Exception {
    PushOneCommit.Result r = createChange();
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    gApi.changes().id(r.getChangeId()).addReviewer(in);
    assertThat(getReviewers(r.getChangeId())).containsExactlyElementsIn(ImmutableSet.of(user.id));
}
#method_after
@Test
public void addReviewer() throws Exception {
    PushOneCommit.Result r = createChange();
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    gApi.changes().id(r.getChangeId()).addReviewer(in);
    ChangeInfo c = gApi.changes().id(r.getChangeId()).get();
    // When notedb is enabled adding a reviewer records that user as reviewer
    // in notedb. When notedb is disabled adding a reviewer results in a dummy 0
    // approval on the change which is treated as CC when the ChangeInfo is
    // created.
    Collection<AccountInfo> reviewers = isNoteDbTestEnabled() ? c.reviewers.get(REVIEWER) : c.reviewers.get(CC);
    assertThat(reviewers).hasSize(1);
    assertThat(reviewers.iterator().next()._accountId).isEqualTo(user.getId().get());
}
#end_block

#method_before
@Test
public void addReviewerToClosedChange() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.approve());
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).submit();
    assertThat(getReviewers(r.getChangeId())).containsExactlyElementsIn(ImmutableSet.of(admin.getId()));
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    gApi.changes().id(r.getChangeId()).addReviewer(in);
    assertThat(getReviewers(r.getChangeId())).containsExactlyElementsIn(ImmutableSet.of(admin.getId(), user.id));
}
#method_after
@Test
public void addReviewerToClosedChange() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.approve());
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).submit();
    ChangeInfo c = gApi.changes().id(r.getChangeId()).get();
    Collection<AccountInfo> reviewers = c.reviewers.get(REVIEWER);
    assertThat(reviewers).hasSize(1);
    assertThat(reviewers.iterator().next()._accountId).isEqualTo(admin.getId().get());
    assertThat(c.reviewers).doesNotContainKey(CC);
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    gApi.changes().id(r.getChangeId()).addReviewer(in);
    c = gApi.changes().id(r.getChangeId()).get();
    reviewers = c.reviewers.get(REVIEWER);
    if (isNoteDbTestEnabled()) {
        // When notedb is enabled adding a reviewer records that user as reviewer
        // in notedb.
        assertThat(reviewers).hasSize(2);
        Iterator<AccountInfo> reviewerIt = reviewers.iterator();
        assertThat(reviewerIt.next()._accountId).isEqualTo(admin.getId().get());
        assertThat(reviewerIt.next()._accountId).isEqualTo(user.getId().get());
        assertThat(c.reviewers).doesNotContainKey(CC);
    } else {
        // When notedb is disabled adding a reviewer results in a dummy 0 approval
        // on the change which is treated as CC when the ChangeInfo is created.
        assertThat(reviewers).hasSize(1);
        assertThat(reviewers.iterator().next()._accountId).isEqualTo(admin.getId().get());
        Collection<AccountInfo> ccs = c.reviewers.get(CC);
        assertThat(ccs).hasSize(1);
        assertThat(ccs.iterator().next()._accountId).isEqualTo(user.getId().get());
    }
}
#end_block

#method_before
@Test
public void deleteVote() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.approve());
    Map<String, Short> m = gApi.changes().id(r.getChangeId()).reviewer(admin.getId().toString()).votes();
    assertThat(m).containsEntry("Code-Review", new Short((short) 2));
    setApiUser(user);
    try {
        gApi.changes().id(r.getChangeId()).reviewer(admin.getId().toString()).deleteVote("Code-Review+2");
        fail("AuthException (delete not permitted) expected");
    } catch (AuthException e) {
        assertThat(e.getMessage()).isEqualTo("delete not permitted");
    }
    setApiUser(admin);
    gApi.changes().id(r.getChangeId()).reviewer(admin.getId().toString()).deleteVote("Code-Review+2");
    m = gApi.changes().id(r.getChangeId()).reviewer(admin.getId().toString()).votes();
    assertThat(m).containsEntry("Code-Review", new Short((short) 0));
    assertThat(getReviewers(r.getChangeId())).containsExactlyElementsIn(ImmutableSet.of(admin.getId()));
}
#method_after
@Test
public void deleteVote() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.approve());
    setApiUser(user);
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.recommend());
    setApiUser(admin);
    gApi.changes().id(r.getChangeId()).reviewer(admin.getId().toString()).deleteVote("Code-Review");
    Map<String, Short> m = gApi.changes().id(r.getChangeId()).reviewer(admin.getId().toString()).votes();
    if (isNoteDbTestEnabled()) {
        // When notedb is enabled each reviewer is explicitly recorded in the
        // notedb and this record stays even when all votes of that user have been
        // deleted, hence there is no dummy 0 approval left when a vote is
        // deleted.
        assertThat(m).isEmpty();
    } else {
        // When notedb is disabled there is a dummy 0 approval on the change so
        // that the user is still returned as CC when all votes of that user have
        // been deleted.
        assertThat(m).containsEntry("Code-Review", new Short((short) 0));
    }
    ChangeInfo c = gApi.changes().id(r.getChangeId()).get();
    assertThat(Iterables.getLast(c.messages).message).isEqualTo("Removed Code-Review+2 by Administrator <admin@example.com>\n");
    if (isNoteDbTestEnabled()) {
        // When notedb is enabled each reviewer is explicitly recorded in the
        // notedb and this record stays even when all votes of that user have been
        // deleted.
        assertThat(getReviewers(c.reviewers.get(REVIEWER))).containsExactlyElementsIn(ImmutableSet.of(admin.getId(), user.getId()));
    } else {
        // When notedb is disabled users that have only dummy 0 approvals on the
        // change are returned as CC and not as REVIEWER.
        assertThat(getReviewers(c.reviewers.get(REVIEWER))).containsExactlyElementsIn(ImmutableSet.of(user.getId()));
        assertThat(getReviewers(c.reviewers.get(CC))).containsExactlyElementsIn(ImmutableSet.of(admin.getId()));
    }
}
#end_block

#method_before
@Test
public void createEmptyChange() throws Exception {
    ChangeInfo in = new ChangeInfo();
    in.branch = Constants.MASTER;
    in.subject = "Create a change from the API";
    in.project = project.get();
    ChangeInfo info = gApi.changes().create(in).get();
    assertThat(info.project).isEqualTo(in.project);
    assertThat(info.branch).isEqualTo(in.branch);
    assertThat(info.subject).isEqualTo(in.subject);
}
#method_after
@Test
public void createEmptyChange() throws Exception {
    ChangeInfo in = new ChangeInfo();
    in.branch = Constants.MASTER;
    in.subject = "Create a change from the API";
    in.project = project.get();
    ChangeInfo info = gApi.changes().create(in).get();
    assertThat(info.project).isEqualTo(in.project);
    assertThat(info.branch).isEqualTo(in.branch);
    assertThat(info.subject).isEqualTo(in.subject);
    assertThat(Iterables.getOnlyElement(info.messages).message).isEqualTo("Uploaded patch set 1.");
}
#end_block

#method_before
@Test
public void queryChangesNoQuery() throws Exception {
    PushOneCommit.Result r1 = createChange();
    PushOneCommit.Result r2 = createChange();
    List<ChangeInfo> results = gApi.changes().query().get();
    assertThat(results).hasSize(2);
    assertThat(results.get(0).changeId).isEqualTo(r2.getChangeId());
    assertThat(results.get(1).changeId).isEqualTo(r1.getChangeId());
}
#method_after
@Test
public void queryChangesNoQuery() throws Exception {
    PushOneCommit.Result r = createChange();
    List<ChangeInfo> results = gApi.changes().query().get();
    assertThat(results.size()).isAtLeast(1);
    List<Integer> ids = new ArrayList<>(results.size());
    for (int i = 0; i < results.size(); i++) {
        ChangeInfo info = results.get(i);
        if (i == 0) {
            assertThat(info._number).isEqualTo(r.getChange().getId().get());
        }
        assertThat(Change.Status.forChangeStatus(info.status).isOpen()).isTrue();
        ids.add(info._number);
    }
    assertThat(ids).contains(r.getChange().getId().get());
}
#end_block

#method_before
@Test
public void queryChangesNoResults() throws Exception {
    createChange();
    List<ChangeInfo> results = query("status:open");
    assertThat(results).hasSize(1);
    results = query("status:closed");
    assertThat(results).isEmpty();
}
#method_after
@Test
public void queryChangesNoResults() throws Exception {
    createChange();
    assertThat(query("message:test")).isNotEmpty();
    assertThat(query("message:{" + getClass().getName() + "fhqwhgads}")).isEmpty();
}
#end_block

#method_before
@Test
public void queryChangesStart() throws Exception {
    PushOneCommit.Result r1 = createChange();
    createChange();
    List<ChangeInfo> results = gApi.changes().query().withStart(1).get();
    assertThat(Iterables.getOnlyElement(results).changeId).isEqualTo(r1.getChangeId());
}
#method_after
@Test
public void queryChangesStart() throws Exception {
    PushOneCommit.Result r1 = createChange();
    createChange();
    List<ChangeInfo> results = gApi.changes().query("project:{" + project.get() + "}").withStart(1).get();
    assertThat(Iterables.getOnlyElement(results).changeId).isEqualTo(r1.getChangeId());
}
#end_block

#method_before
@Test
public void queryChangesOptions() throws Exception {
    PushOneCommit.Result r = createChange();
    ChangeInfo result = Iterables.getOnlyElement(gApi.changes().query(r.getChangeId()).withOptions(EnumSet.allOf(ListChangesOption.class)).get());
    assertThat(Iterables.getOnlyElement(result.labels.keySet())).isEqualTo("Code-Review");
    assertThat(result.messages).hasSize(1);
    assertThat(result.actions).isNotEmpty();
    RevisionInfo rev = Iterables.getOnlyElement(result.revisions.values());
    assertThat(rev._number).isEqualTo(r.getPatchSetId().get());
    assertThat(rev.ref).isEqualTo(r.getPatchSetId().toRefName());
    assertThat(rev.actions).isNotEmpty();
}
#method_after
@Test
public void queryChangesOptions() throws Exception {
    PushOneCommit.Result r = createChange();
    ChangeInfo result = Iterables.getOnlyElement(gApi.changes().query(r.getChangeId()).withOptions(EnumSet.allOf(ListChangesOption.class)).get());
    assertThat(Iterables.getOnlyElement(result.labels.keySet())).isEqualTo("Code-Review");
    assertThat(result.messages).hasSize(1);
    assertThat(result.actions).isNotEmpty();
    RevisionInfo rev = Iterables.getOnlyElement(result.revisions.values());
    assertThat(rev._number).isEqualTo(r.getPatchSetId().get());
    assertThat(rev.created).isNotNull();
    assertThat(rev.uploader._accountId).isEqualTo(admin.getId().get());
    assertThat(rev.ref).isEqualTo(r.getPatchSetId().toRefName());
    assertThat(rev.actions).isNotEmpty();
}
#end_block

#method_before
@Test
public void queryChangesOwnerWithDifferentUsers() throws Exception {
    PushOneCommit.Result r = createChange();
    assertThat(Iterables.getOnlyElement(query("owner:self")).changeId).isEqualTo(r.getChangeId());
    setApiUser(user);
    assertThat(query("owner:self")).isEmpty();
}
#method_after
@Test
public void queryChangesOwnerWithDifferentUsers() throws Exception {
    PushOneCommit.Result r = createChange();
    assertThat(Iterables.getOnlyElement(query("project:{" + project.get() + "} owner:self")).changeId).isEqualTo(r.getChangeId());
    setApiUser(user);
    assertThat(query("owner:self")).isEmpty();
}
#end_block

#method_before
private Set<Account.Id> getReviewers(String changeId) throws Exception {
    ChangeInfo ci = gApi.changes().id(changeId).get();
    Set<Account.Id> result = Sets.newHashSet();
    for (LabelInfo li : ci.labels.values()) {
        for (ApprovalInfo ai : li.all) {
            result.add(new Account.Id(ai._accountId));
        }
    }
    return result;
}
#method_after
private static Iterable<Account.Id> getReviewers(Collection<AccountInfo> r) {
    return Iterables.transform(r, new Function<AccountInfo, Account.Id>() {

        @Override
        public Account.Id apply(AccountInfo account) {
            return new Account.Id(account._accountId);
        }
    });
}
#end_block

#method_before
private static void onRemoveReviewer(NativeEvent event) {
    Integer user = getDataId(event);
    if (user != null) {
        final ChangeScreen2 screen = ChangeScreen2.get(event);
        ChangeApi.reviewer(screen.getChangeId().get(), user).delete(new GerritCallback<JavaScriptObject>() {

            @Override
            public void onSuccess(JavaScriptObject result) {
                if (screen.isCurrentView()) {
                    Gerrit.display(PageLinks.toChange(screen.getChangeId()));
                }
            }
        });
    }
}
#method_after
private static void onRemoveReviewer(NativeEvent event) {
    Integer user = getDataId(event);
    if (user != null) {
        final ChangeScreen screen = ChangeScreen.get(event);
        ChangeApi.reviewer(screen.getChangeId().get(), user).delete(new GerritCallback<JavaScriptObject>() {

            @Override
            public void onSuccess(JavaScriptObject result) {
                if (screen.isCurrentView()) {
                    Gerrit.display(PageLinks.toChange(screen.getChangeId()));
                }
            }
        });
    }
}
#end_block

#method_before
private static void onRemoveVote(NativeEvent event) {
    Integer user = getDataId(event);
    String vote = getVoteId(event);
    if (user != null && vote != null) {
        final ChangeScreen2 screen = ChangeScreen2.get(event);
        ChangeApi.vote(screen.getChangeId().get(), user, vote).delete(new GerritCallback<JavaScriptObject>() {

            @Override
            public void onSuccess(JavaScriptObject result) {
                if (screen.isCurrentView()) {
                    Gerrit.display(PageLinks.toChange(screen.getChangeId()));
                }
            }
        });
    }
}
#method_after
private static void onRemoveVote(NativeEvent event) {
    Integer user = getDataId(event);
    String vote = getVoteId(event);
    if (user != null && vote != null) {
        final ChangeScreen screen = ChangeScreen.get(event);
        ChangeApi.vote(screen.getChangeId().get(), user, vote).delete(new GerritCallback<JavaScriptObject>() {

            @Override
            public void onSuccess(JavaScriptObject result) {
                if (screen.isCurrentView()) {
                    Gerrit.display(PageLinks.toChange(screen.getChangeId()));
                }
            }
        });
    }
}
#end_block

#method_before
private static String getVoteId(NativeEvent event) {
    Element e = event.getEventTarget().cast();
    while (e != null) {
        String v = e.getAttribute(VOTE_ID);
        if (!v.isEmpty()) {
            return v;
        }
        e = e.getParentElement();
    }
    return null;
}
#method_after
private static String getVoteId(NativeEvent event) {
    Element e = event.getEventTarget().cast();
    while (e != null) {
        String v = e.getAttribute(DATA_VOTE);
        if (!v.isEmpty()) {
            return v;
        }
        e = e.getParentElement();
    }
    return null;
}
#end_block

#method_before
void set(ChangeInfo info) {
    List<String> names = new ArrayList<>(info.labels());
    Set<Integer> removable = info.removable();
    Collections.sort(names);
    resize(names.size(), 2);
    for (int row = 0; row < names.size(); row++) {
        String name = names.get(row);
        LabelInfo label = info.label(name);
        setText(row, 0, name);
        if (label.all() != null) {
            setWidget(row, 1, renderUsers(label, removable));
        }
        getCellFormatter().setStyleName(row, 0, style.labelName());
        getCellFormatter().addStyleName(row, 0, getStyleForLabel(label));
    }
}
#method_after
void set(ChangeInfo info) {
    List<String> names = new ArrayList<>(info.labels());
    Set<Integer> removable = info.removableReviewerIds();
    Collections.sort(names);
    resize(names.size(), 2);
    for (int row = 0; row < names.size(); row++) {
        String name = names.get(row);
        LabelInfo label = info.label(name);
        setText(row, 0, name);
        if (label.all() != null) {
            setWidget(row, 1, renderUsers(label, removable));
        }
        getCellFormatter().setStyleName(row, 0, style.labelName());
        getCellFormatter().addStyleName(row, 0, getStyleForLabel(label));
    }
}
#end_block

#method_before
private Widget renderUsers(LabelInfo label, Set<Integer> removable) {
    Map<Integer, List<ApprovalInfo>> m = new HashMap<>(4);
    int approved = 0, rejected = 0;
    for (ApprovalInfo ai : Natives.asList(label.all())) {
        if (ai.value() != 0) {
            List<ApprovalInfo> l = m.get(Integer.valueOf(ai.value()));
            if (l == null) {
                l = new ArrayList<>(label.all().length());
                m.put(Integer.valueOf(ai.value()), l);
            }
            l.add(ai);
            if (isRejected(label, ai)) {
                rejected = ai.value();
            } else if (isApproved(label, ai)) {
                approved = ai.value();
            }
        }
    }
    SafeHtmlBuilder html = new SafeHtmlBuilder();
    for (Integer v : sort(m.keySet(), approved, rejected)) {
        if (!html.isEmpty()) {
            html.br();
        }
        String val = LabelValue.formatValue(v.shortValue());
        html.openSpan();
        html.setAttribute("title", label.value_text(val));
        if (v.intValue() == approved) {
            html.setStyleName(style.label_ok());
        } else if (v.intValue() == rejected) {
            html.setStyleName(style.label_reject());
        }
        html.append(val).append(" ");
        html.append(formatUserList(style, m.get(v), removable, label.name() + val, null));
        html.closeSpan();
    }
    return html.toBlockWidget();
}
#method_after
private Widget renderUsers(LabelInfo label, Set<Integer> removable) {
    Map<Integer, List<ApprovalInfo>> m = new HashMap<>(4);
    int approved = 0;
    int rejected = 0;
    for (ApprovalInfo ai : Natives.asList(label.all())) {
        if (ai.value() != 0) {
            List<ApprovalInfo> l = m.get(Integer.valueOf(ai.value()));
            if (l == null) {
                l = new ArrayList<>(label.all().length());
                m.put(Integer.valueOf(ai.value()), l);
            }
            l.add(ai);
            if (isRejected(label, ai)) {
                rejected = ai.value();
            } else if (isApproved(label, ai)) {
                approved = ai.value();
            }
        }
    }
    SafeHtmlBuilder html = new SafeHtmlBuilder();
    for (Integer v : sort(m.keySet(), approved, rejected)) {
        if (!html.isEmpty()) {
            html.br();
        }
        String val = LabelValue.formatValue(v.shortValue());
        html.openSpan();
        html.setAttribute("title", label.valueText(val));
        if (v.intValue() == approved) {
            html.setStyleName(style.label_ok());
        } else if (v.intValue() == rejected) {
            html.setStyleName(style.label_reject());
        }
        html.append(val).append(" ");
        html.append(formatUserList(style, m.get(v), removable, label.name(), null));
        html.closeSpan();
    }
    return html.toBlockWidget();
}
#end_block

#method_before
private static boolean isApproved(LabelInfo label, ApprovalInfo ai) {
    return label.approved() != null && label.approved()._account_id() == ai._account_id();
}
#method_after
private static boolean isApproved(LabelInfo label, ApprovalInfo ai) {
    return label.approved() != null && label.approved()._accountId() == ai._accountId();
}
#end_block

#method_before
private static boolean isRejected(LabelInfo label, ApprovalInfo ai) {
    return label.rejected() != null && label.rejected()._account_id() == ai._account_id();
}
#method_after
private static boolean isRejected(LabelInfo label, ApprovalInfo ai) {
    return label.rejected() != null && label.rejected()._accountId() == ai._accountId();
}
#end_block

#method_before
static SafeHtml formatUserList(ChangeScreen2.Style style, Collection<? extends AccountInfo> in, Set<Integer> removable, String labelVote, Map<Integer, VotableInfo> votable) {
    List<AccountInfo> users = new ArrayList<>(in);
    Collections.sort(users, new Comparator<AccountInfo>() {

        @Override
        public int compare(AccountInfo a, AccountInfo b) {
            String as = name(a);
            String bs = name(b);
            if (as.isEmpty()) {
                return 1;
            } else if (bs.isEmpty()) {
                return -1;
            }
            return as.compareTo(bs);
        }

        private String name(AccountInfo a) {
            if (a.name() != null) {
                return a.name();
            } else if (a.email() != null) {
                return a.email();
            }
            return "";
        }
    });
    SafeHtmlBuilder html = new SafeHtmlBuilder();
    Iterator<? extends AccountInfo> itr = users.iterator();
    while (itr.hasNext()) {
        AccountInfo ai = itr.next();
        AvatarInfo img = ai.avatar(AvatarInfo.DEFAULT_SIZE);
        String name;
        if (ai.name() != null) {
            name = ai.name();
        } else if (ai.email() != null) {
            name = ai.email();
        } else {
            name = Integer.toString(ai._account_id());
        }
        String votableCategories = "";
        if (votable != null) {
            Set<String> s = votable.get(ai._account_id()).votableLabels();
            if (!s.isEmpty()) {
                StringBuilder sb = new StringBuilder(Util.C.votable());
                sb.append(" ");
                for (Iterator<String> it = s.iterator(); it.hasNext(); ) {
                    sb.append(it.next());
                    if (it.hasNext()) {
                        sb.append(", ");
                    }
                }
                votableCategories = sb.toString();
            }
        }
        html.openSpan().setAttribute("role", "listitem").setAttribute(DATA_ID, ai._account_id()).setAttribute("title", getTitle(ai, votableCategories)).setStyleName(style.label_user());
        if (labelVote != null) {
            html.setAttribute(VOTE_ID, labelVote);
        }
        if (img != null) {
            html.openElement("img").setStyleName(style.avatar()).setAttribute("src", img.url());
            if (img.width() > 0) {
                html.setAttribute("width", img.width());
            }
            if (img.height() > 0) {
                html.setAttribute("height", img.height());
            }
            html.closeSelf();
        }
        html.append(name);
        if (removable.contains(ai._account_id())) {
            html.openElement("button");
            if (labelVote != null) {
                html.setAttribute("title", Util.M.removeVote(labelVote)).setAttribute("onclick", REMOVE_VOTE + "(event)");
            } else {
                html.setAttribute("title", Util.M.removeReviewer(name)).setAttribute("onclick", REMOVE_REVIEWER + "(event)");
            }
            html.append(new ImageResourceRenderer().render(Gerrit.RESOURCES.removeReviewer())).closeElement("button");
        }
        html.closeSpan();
        if (itr.hasNext()) {
            html.append(' ');
        }
    }
    return html;
}
#method_after
static SafeHtml formatUserList(ChangeScreen.Style style, Collection<? extends AccountInfo> in, Set<Integer> removable, String label, Map<Integer, VotableInfo> votable) {
    List<AccountInfo> users = new ArrayList<>(in);
    Collections.sort(users, new Comparator<AccountInfo>() {

        @Override
        public int compare(AccountInfo a, AccountInfo b) {
            String as = name(a);
            String bs = name(b);
            if (as.isEmpty()) {
                return 1;
            } else if (bs.isEmpty()) {
                return -1;
            }
            return as.compareTo(bs);
        }

        private String name(AccountInfo a) {
            if (a.name() != null) {
                return a.name();
            } else if (a.email() != null) {
                return a.email();
            }
            return "";
        }
    });
    SafeHtmlBuilder html = new SafeHtmlBuilder();
    Iterator<? extends AccountInfo> itr = users.iterator();
    while (itr.hasNext()) {
        AccountInfo ai = itr.next();
        AvatarInfo img = ai.avatar(AvatarInfo.DEFAULT_SIZE);
        String name;
        if (ai.name() != null) {
            name = ai.name();
        } else if (ai.email() != null) {
            name = ai.email();
        } else {
            name = Integer.toString(ai._accountId());
        }
        String votableCategories = "";
        if (votable != null) {
            Set<String> s = votable.get(ai._accountId()).votableLabels();
            if (!s.isEmpty()) {
                StringBuilder sb = new StringBuilder(Util.C.votable());
                sb.append(" ");
                for (Iterator<String> it = s.iterator(); it.hasNext(); ) {
                    sb.append(it.next());
                    if (it.hasNext()) {
                        sb.append(", ");
                    }
                }
                votableCategories = sb.toString();
            }
        }
        html.openSpan().setAttribute("role", "listitem").setAttribute(DATA_ID, ai._accountId()).setAttribute("title", getTitle(ai, votableCategories)).setStyleName(style.label_user());
        if (label != null) {
            html.setAttribute(DATA_VOTE, label);
        }
        if (img != null) {
            html.openElement("img").setStyleName(style.avatar()).setAttribute("src", img.url());
            if (img.width() > 0) {
                html.setAttribute("width", img.width());
            }
            if (img.height() > 0) {
                html.setAttribute("height", img.height());
            }
            html.closeSelf();
        }
        html.append(name);
        if (removable.contains(ai._accountId())) {
            html.openElement("button");
            if (label != null) {
                html.setAttribute("title", Util.M.removeVote(label)).setAttribute("onclick", REMOVE_VOTE + "(event)");
            } else {
                html.setAttribute("title", Util.M.removeReviewer(name)).setAttribute("onclick", REMOVE_REVIEWER + "(event)");
            }
            html.append("×").closeElement("button");
        }
        html.closeSpan();
        if (itr.hasNext()) {
            html.append(' ');
        }
    }
    return html;
}
#end_block

#method_before
void init(ChangeScreen2.Style style, Element ccText) {
    this.style = style;
    this.ccText = ccText;
}
#method_after
void init(ChangeScreen.Style style, Element ccText) {
    this.style = style;
    this.ccText = ccText;
}
#end_block

#method_before
void set(ChangeInfo info) {
    this.changeId = info.legacy_id();
    display(info);
    reviewerSuggestOracle.setChange(changeId);
    openForm.setVisible(Gerrit.isSignedIn());
}
#method_after
void set(ChangeInfo info) {
    this.changeId = info.legacyId();
    display(info);
    reviewerSuggestOracle.setChange(changeId);
    openForm.setVisible(Gerrit.isSignedIn());
}
#end_block

#method_before
@UiHandler("add")
void onAdd(@SuppressWarnings("unused") ClickEvent e) {
    String reviewer = suggestBox.getText();
    if (!reviewer.isEmpty()) {
        addReviewer(reviewer, false);
    }
}
#method_after
@UiHandler("add")
void onAdd(@SuppressWarnings("unused") ClickEvent e) {
    addReviewer(suggestBox.getText(), false);
}
#end_block

#method_before
@UiHandler("addMe")
void onAddMe(@SuppressWarnings("unused") ClickEvent e) {
    String accountId = String.valueOf(Gerrit.getUserAccountInfo()._account_id());
    addReviewer(accountId, false);
}
#method_after
@UiHandler("addMe")
void onAddMe(@SuppressWarnings("unused") ClickEvent e) {
    String accountId = String.valueOf(Gerrit.getUserAccount()._accountId());
    addReviewer(accountId, false);
}
#end_block

#method_before
private void addReviewer(final String reviewer, boolean confirmed) {
    ChangeApi.reviewers(changeId.get()).post(PostInput.create(reviewer, confirmed), new GerritCallback<PostResult>() {

        @Override
        public void onSuccess(PostResult result) {
            nameTxtBox.setEnabled(true);
            if (result.confirm()) {
                askForConfirmation(result.error());
            } else if (result.error() != null) {
                UIObject.setVisible(error, true);
                error.setInnerText(result.error());
            } else {
                UIObject.setVisible(error, false);
                error.setInnerText("");
                nameTxtBox.setText("");
                if (result.reviewers() != null && result.reviewers().length() > 0) {
                    updateReviewerList();
                }
            }
        }

        private void askForConfirmation(String text) {
            new ConfirmationDialog(Util.C.approvalTableAddManyReviewersConfirmationDialogTitle(), new SafeHtmlBuilder().append(text), new ConfirmationCallback() {

                @Override
                public void onOk() {
                    addReviewer(reviewer, true);
                }
            }).center();
        }

        @Override
        public void onFailure(Throwable err) {
            UIObject.setVisible(error, true);
            error.setInnerText(err instanceof StatusCodeException ? ((StatusCodeException) err).getEncodedResponse() : err.getMessage());
            nameTxtBox.setEnabled(true);
        }
    });
}
#method_after
private void addReviewer(final String reviewer, boolean confirmed) {
    if (reviewer.isEmpty()) {
        return;
    }
    ChangeApi.reviewers(changeId.get()).post(PostInput.create(reviewer, confirmed), new GerritCallback<PostResult>() {

        @Override
        public void onSuccess(PostResult result) {
            if (result.confirm()) {
                askForConfirmation(result.error());
            } else if (result.error() != null) {
                UIObject.setVisible(error, true);
                error.setInnerText(result.error());
            } else {
                UIObject.setVisible(error, false);
                error.setInnerText("");
                suggestBox.setText("");
                if (result.reviewers() != null && result.reviewers().length() > 0) {
                    updateReviewerList();
                }
            }
        }

        private void askForConfirmation(String text) {
            new ConfirmationDialog(Util.C.approvalTableAddManyReviewersConfirmationDialogTitle(), new SafeHtmlBuilder().append(text), new ConfirmationCallback() {

                @Override
                public void onOk() {
                    addReviewer(reviewer, true);
                }
            }).center();
        }

        @Override
        public void onFailure(Throwable err) {
            if (isSigninFailure(err)) {
                new NotSignedInDialog().center();
            } else {
                UIObject.setVisible(error, true);
                error.setInnerText(err instanceof StatusCodeException ? ((StatusCodeException) err).getEncodedResponse() : err.getMessage());
            }
        }
    });
}
#end_block

#method_before
private void display(ChangeInfo info) {
    Map<Integer, AccountInfo> r = new HashMap<>();
    Map<Integer, AccountInfo> cc = new HashMap<>();
    for (LabelInfo label : Natives.asList(info.all_labels().values())) {
        if (label.all() != null) {
            for (ApprovalInfo ai : Natives.asList(label.all())) {
                (ai.value() != 0 ? r : cc).put(ai._account_id(), ai);
            }
        }
    }
    for (Integer i : r.keySet()) {
        cc.remove(i);
    }
    cc.remove(info.owner()._account_id());
    Set<Integer> removable = info.removable();
    Map<Integer, VotableInfo> votable = votable(info);
    SafeHtml rHtml = Labels.formatUserList(style, r.values(), removable, null, votable);
    SafeHtml ccHtml = Labels.formatUserList(style, cc.values(), removable, null, votable);
    reviewersText.setInnerSafeHtml(rHtml);
    ccText.setInnerSafeHtml(ccHtml);
    if (Gerrit.isSignedIn()) {
        int currentUser = Gerrit.getUserAccountInfo()._account_id();
        boolean showAddMeButton = info.owner()._account_id() != currentUser && !cc.containsKey(currentUser) && !r.containsKey(currentUser);
        addMe.setVisible(showAddMeButton);
    }
}
#method_after
private void display(ChangeInfo info) {
    Map<Integer, AccountInfo> r = new HashMap<>();
    Map<Integer, AccountInfo> cc = new HashMap<>();
    for (LabelInfo label : Natives.asList(info.allLabels().values())) {
        if (label.all() != null) {
            for (ApprovalInfo ai : Natives.asList(label.all())) {
                (ai.value() != 0 ? r : cc).put(ai._accountId(), ai);
            }
        }
    }
    for (Integer i : r.keySet()) {
        cc.remove(i);
    }
    cc.remove(info.owner()._accountId());
    Set<Integer> removable = info.removableReviewerIds();
    Map<Integer, VotableInfo> votable = votable(info);
    SafeHtml rHtml = Labels.formatUserList(style, r.values(), removable, null, votable);
    SafeHtml ccHtml = Labels.formatUserList(style, cc.values(), removable, null, votable);
    reviewersText.setInnerSafeHtml(rHtml);
    ccText.setInnerSafeHtml(ccHtml);
    if (Gerrit.isSignedIn()) {
        int currentUser = Gerrit.getUserAccount()._accountId();
        boolean showAddMeButton = info.owner()._accountId() != currentUser && !cc.containsKey(currentUser) && !r.containsKey(currentUser);
        addMe.setVisible(showAddMeButton);
    }
}
#end_block

#method_before
private static Map<Integer, VotableInfo> votable(ChangeInfo change) {
    Map<Integer, VotableInfo> d = new HashMap<>();
    for (String name : change.labels()) {
        LabelInfo label = change.label(name);
        if (label.all() != null) {
            for (ApprovalInfo ai : Natives.asList(label.all())) {
                int id = ai._account_id();
                VotableInfo ad = d.get(id);
                if (ad == null) {
                    ad = new VotableInfo();
                    d.put(id, ad);
                }
                if (ai.has_value()) {
                    ad.votable(name);
                }
            }
        }
    }
    return d;
}
#method_after
private static Map<Integer, VotableInfo> votable(ChangeInfo change) {
    Map<Integer, VotableInfo> d = new HashMap<>();
    for (String name : change.labels()) {
        LabelInfo label = change.label(name);
        if (label.all() != null) {
            for (ApprovalInfo ai : Natives.asList(label.all())) {
                int id = ai._accountId();
                VotableInfo ad = d.get(id);
                if (ad == null) {
                    ad = new VotableInfo();
                    d.put(id, ad);
                }
                if (ai.hasValue()) {
                    ad.votable(name);
                }
            }
        }
    }
    return d;
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ChangesCollection.class);
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(Drafts.class);
    bind(Comments.class);
    bind(Files.class);
    bind(Votes.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), DRAFT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    DynamicMap.mapOf(binder(), CHANGE_EDIT_KIND);
    DynamicMap.mapOf(binder(), VOTE_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    get(CHANGE_KIND, "in").to(IncludedIn.class);
    get(CHANGE_KIND, "hashtags").to(GetHashtags.class);
    get(CHANGE_KIND, "check").to(Check.class);
    post(CHANGE_KIND, "check").to(Check.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND).to(DeleteDraftChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "hashtags").to(PostHashtags.class);
    post(CHANGE_KIND, "publish").to(Publish.CurrentRevision.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "index").to(Index.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    get(CHANGE_KIND, "suggest_reviewers").to(SuggestReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    child(REVIEWER_KIND, "votes").to(Votes.class);
    delete(VOTE_KIND).to(DeleteVote.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    delete(REVISION_KIND).to(DeleteDraftPatchSet.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    post(REVISION_KIND, "publish").to(Publish.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    post(REVISION_KIND, "message").to(EditMessage.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    get(REVISION_KIND, "archive").to(GetArchive.class);
    child(REVISION_KIND, "drafts").to(Drafts.class);
    put(REVISION_KIND, "drafts").to(CreateDraft.class);
    get(DRAFT_KIND).to(GetDraft.class);
    put(DRAFT_KIND).to(PutDraft.class);
    delete(DRAFT_KIND).to(DeleteDraft.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "type").to(GetContentType.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    child(CHANGE_KIND, "edit").to(ChangeEdits.class);
    delete(CHANGE_KIND, "edit").to(DeleteChangeEdit.class);
    child(CHANGE_KIND, "edit:publish").to(PublishChangeEdit.class);
    child(CHANGE_KIND, "edit:rebase").to(RebaseChangeEdit.class);
    put(CHANGE_KIND, "edit:message").to(ChangeEdits.EditMessage.class);
    get(CHANGE_KIND, "edit:message").to(ChangeEdits.GetMessage.class);
    put(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Put.class);
    delete(CHANGE_EDIT_KIND).to(ChangeEdits.DeleteContent.class);
    get(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Get.class);
    get(CHANGE_EDIT_KIND, "type").to(ChangeEdits.GetType.class);
    install(new FactoryModule() {

        @Override
        protected void configure() {
            factory(ReviewerResource.Factory.class);
            factory(AccountLoader.Factory.class);
            factory(EmailReviewComments.Factory.class);
            factory(ChangeInserter.Factory.class);
            factory(PatchSetInserter.Factory.class);
            factory(ChangeEdits.Create.Factory.class);
            factory(ChangeEdits.DeleteFile.Factory.class);
        }
    });
}
#method_after
@Override
protected void configure() {
    bind(ChangesCollection.class);
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(DraftComments.class);
    bind(Comments.class);
    bind(Files.class);
    bind(Votes.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), DRAFT_COMMENT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    DynamicMap.mapOf(binder(), CHANGE_EDIT_KIND);
    DynamicMap.mapOf(binder(), VOTE_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    get(CHANGE_KIND, "in").to(IncludedIn.class);
    get(CHANGE_KIND, "hashtags").to(GetHashtags.class);
    get(CHANGE_KIND, "comments").to(ListChangeComments.class);
    get(CHANGE_KIND, "drafts").to(ListChangeDrafts.class);
    get(CHANGE_KIND, "check").to(Check.class);
    post(CHANGE_KIND, "check").to(Check.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND).to(DeleteDraftChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "hashtags").to(PostHashtags.class);
    post(CHANGE_KIND, "publish").to(PublishDraftPatchSet.CurrentRevision.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    get(CHANGE_KIND, "submitted_together").to(SubmittedTogether.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "index").to(Index.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    get(CHANGE_KIND, "suggest_reviewers").to(SuggestReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    child(REVIEWER_KIND, "votes").to(Votes.class);
    delete(VOTE_KIND).to(DeleteVote.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    get(REVISION_KIND, "actions").to(GetRevisionActions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    delete(REVISION_KIND).to(DeleteDraftPatchSet.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    post(REVISION_KIND, "publish").to(PublishDraftPatchSet.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    get(REVISION_KIND, "archive").to(GetArchive.class);
    child(REVISION_KIND, "drafts").to(DraftComments.class);
    put(REVISION_KIND, "drafts").to(CreateDraftComment.class);
    get(DRAFT_COMMENT_KIND).to(GetDraftComment.class);
    put(DRAFT_COMMENT_KIND).to(PutDraftComment.class);
    delete(DRAFT_COMMENT_KIND).to(DeleteDraftComment.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "download").to(DownloadContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    child(CHANGE_KIND, "edit").to(ChangeEdits.class);
    delete(CHANGE_KIND, "edit").to(DeleteChangeEdit.class);
    child(CHANGE_KIND, "edit:publish").to(PublishChangeEdit.class);
    child(CHANGE_KIND, "edit:rebase").to(RebaseChangeEdit.class);
    put(CHANGE_KIND, "edit:message").to(ChangeEdits.EditMessage.class);
    get(CHANGE_KIND, "edit:message").to(ChangeEdits.GetMessage.class);
    put(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Put.class);
    delete(CHANGE_EDIT_KIND).to(ChangeEdits.DeleteContent.class);
    get(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Get.class);
    get(CHANGE_EDIT_KIND, "meta").to(ChangeEdits.GetMeta.class);
    factory(AccountLoader.Factory.class);
    factory(ChangeEdits.Create.Factory.class);
    factory(ChangeEdits.DeleteFile.Factory.class);
    factory(ChangeInserter.Factory.class);
    factory(EmailReviewComments.Factory.class);
    factory(PatchSetInserter.Factory.class);
    factory(RebaseChangeOp.Factory.class);
    factory(ReviewerResource.Factory.class);
    factory(SetHashtagsOp.Factory.class);
}
#end_block

#method_before
public static void createChange(String project, String branch, String subject, String base, AsyncCallback<ChangeInfo> cb) {
    CreateChangeInput input = CreateChangeInput.create();
    input.project(emptyToNull(project));
    input.branch(emptyToNull(branch));
    input.subject(emptyToNull(subject));
    input.base_change(emptyToNull(base));
    new RestApi("/changes/").post(input, cb);
}
#method_after
public static void createChange(String project, String branch, String topic, String subject, String base, AsyncCallback<ChangeInfo> cb) {
    CreateChangeInput input = CreateChangeInput.create();
    input.project(emptyToNull(project));
    input.branch(emptyToNull(branch));
    input.topic(emptyToNull(topic));
    input.subject(emptyToNull(subject));
    input.baseChange(emptyToNull(base));
    if (Gerrit.info().change().allowDrafts()) {
        input.status(Change.Status.DRAFT.toString());
    }
    new RestApi("/changes/").post(input, cb);
}
#end_block

#method_before
public static void editWithFiles(int id, AsyncCallback<EditInfo> cb) {
    edit(id).addParameter("list", true).get(cb);
}
#method_after
public static void editWithFiles(int id, AsyncCallback<EditInfo> cb) {
    edit(id).addParameterTrue("list").get(cb);
}
#end_block

#method_before
public static RestApi editWithCommands(int id) {
    return edit(id).addParameter("download-commands", true);
}
#method_after
public static RestApi editWithCommands(int id) {
    return edit(id).addParameterTrue("download-commands");
}
#end_block

#method_before
public static void submit(int id, String commit, AsyncCallback<SubmitInfo> cb) {
    SubmitInput in = SubmitInput.create();
    in.wait_for_merge(true);
    call(id, commit, "submit").post(in, cb);
}
#method_after
public static void submit(int id, String commit, AsyncCallback<SubmitInfo> cb) {
    SubmitInput in = SubmitInput.create();
    in.waitForMerge(true);
    call(id, commit, "submit").post(in, cb);
}
#end_block

#method_before
public static void rebase(int id, String commit, AsyncCallback<ChangeInfo> cb) {
    JavaScriptObject in = JavaScriptObject.createObject();
    call(id, commit, "rebase").post(in, cb);
}
#method_after
public static void rebase(int id, String commit, String base, AsyncCallback<ChangeInfo> cb) {
    RebaseInput rebaseInput = RebaseInput.create();
    rebaseInput.setBase(base);
    call(id, commit, "rebase").post(rebaseInput, cb);
}
#end_block

#method_before
@Override
public Response<?> apply(VoteResource rsrc, Input input) throws AuthException, ResourceNotFoundException, OrmException, IOException {
    ChangeControl control = rsrc.getReviewer().getControl();
    Change change = rsrc.getReviewer().getChange();
    Change.Id changeId = change.getId();
    ReviewDb db = dbProvider.get();
    ChangeUpdate update = updateFactory.create(control);
    LabelVote labelVote = rsrc.getVote();
    Account.Id accountId = rsrc.getReviewer().getUser().getAccountId();
    StringBuilder msg = new StringBuilder();
    db.changes().beginTransaction(changeId);
    try {
        PatchSetApproval psa = null;
        for (PatchSetApproval a : approvalsUtil.byChangeUser(db, update.getChangeNotes(), accountId)) {
            // implementing ctl.canRemoveVote(v) method.
            if (control.canRemoveReviewer(a)) {
                if (a.getLabel().equals(labelVote.getLabel()) && a.getValue() == rsrc.getVote().getValue()) {
                    msg.append("Removed the following vote:\n\n");
                    msg.append("* ").append(a.getLabel()).append(formatLabelValue(a.getValue())).append(" by ").append(userFactory.create(accountId).getNameEmail()).append("\n");
                    psa = a;
                    a.setValue((short) 0);
                    break;
                }
            } else {
                throw new AuthException("delete not permitted");
            }
        }
        if (psa == null) {
            throw new ResourceNotFoundException();
        }
        ChangeUtil.bumpRowVersionNotLastUpdatedOn(changeId, db);
        db.patchSetApprovals().update(Collections.singleton(psa));
        if (msg.length() > 0) {
            ChangeMessage changeMessage = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), ((IdentifiedUser) control.getCurrentUser()).getAccountId(), TimeUtil.nowTs(), change.currentPatchSetId());
            changeMessage.setMessage(msg.toString());
            cmUtil.addChangeMessage(db, update, changeMessage);
        }
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    indexer.index(db, change);
    return Response.none();
}
#method_after
@Override
public Response<?> apply(VoteResource rsrc, Input input) throws RestApiException, UpdateException {
    ReviewerResource r = rsrc.getReviewer();
    ChangeControl ctl = r.getControl();
    Change change = r.getChange();
    try (BatchUpdate bu = batchUpdateFactory.create(db.get(), change.getProject(), ctl.getUser().asIdentifiedUser(), TimeUtil.nowTs())) {
        bu.addOp(change.getId(), new Op(r.getUser().getAccountId(), rsrc.getLabel()));
        bu.execute();
    }
    return Response.none();
}
#end_block

#method_before
@Override
public List<Change> load(Project.NameKey key) throws Exception {
    Repository repo = repoManager.openRepository(key);
    try (ManualRequestContext ctx = requestContext.open()) {
        return scan(repo, ctx.getReviewDbProvider().get());
    } finally {
        repo.close();
    }
}
#method_after
@Override
public List<Change> load(Project.NameKey key) throws Exception {
    try (Repository repo = repoManager.openRepository(key);
        ManualRequestContext ctx = requestContext.open()) {
        return scan(repo, ctx.getReviewDbProvider().get());
    }
}
#end_block

#method_before
void setEdit(boolean edit) {
    UIObject.setVisible(summary, false);
    UIObject.setVisible(p_view, !edit);
    UIObject.setVisible(p_edit, edit);
    setRangeHighlight(edit);
    if (edit) {
        String replyMessage = Cookies.getCookie(getCookieName());
        if (comment.inReplyTo() != null && replyMessage != null) {
            comment.message(replyMessage);
            Cookies.removeCookie(getCookieName());
        }
        String msg = comment.message() != null ? comment.message().trim() : "";
        editArea.setValue(msg);
        cancel.setVisible(!isNew());
        expandText();
        editAreaHeight = editArea.getOffsetHeight();
        final int len = msg.length();
        Scheduler.get().scheduleDeferred(new ScheduledCommand() {

            @Override
            public void execute() {
                editArea.setFocus(true);
                if (len > 0) {
                    editArea.setCursorPos(len);
                }
            }
        });
    } else {
        expandTimer.cancel();
        resizeTimer.cancel();
    }
    getCommentManager().setUnsaved(this, edit);
    getCommentGroup().resize();
}
#method_after
void setEdit(boolean edit) {
    UIObject.setVisible(summary, false);
    UIObject.setVisible(p_view, !edit);
    UIObject.setVisible(p_edit, edit);
    setRangeHighlight(edit);
    if (edit) {
        String msg = comment.message() != null ? comment.message().trim() : "";
        editArea.setValue(msg);
        cancel.setVisible(!isNew());
        expandText();
        editAreaHeight = editArea.getOffsetHeight();
        final int len = msg.length();
        Scheduler.get().scheduleDeferred(new ScheduledCommand() {

            @Override
            public void execute() {
                editArea.setFocus(true);
                if (len > 0) {
                    editArea.setCursorPos(len);
                }
            }
        });
    } else {
        expandTimer.cancel();
        resizeTimer.cancel();
    }
    getCommentManager().setUnsaved(this, edit);
    getCommentGroup().resize();
}
#end_block

#method_before
void save(CallbackGroup group) {
    if (pendingGroup != null) {
        pendingGroup.addListener(group);
        return;
    }
    String message = editArea.getValue().trim();
    if (message.length() == 0) {
        return;
    }
    CommentInfo input = CommentInfo.copy(comment);
    input.message(message);
    enableEdit(false);
    pendingGroup = group;
    GerritCallback<CommentInfo> cb = new GerritCallback<CommentInfo>() {

        @Override
        public void onSuccess(CommentInfo result) {
            enableEdit(true);
            pendingGroup = null;
            set(result);
            setEdit(false);
            if (autoClosed) {
                setOpen(false);
            }
            getCommentManager().setUnsaved(DraftBox.this, false);
        }

        @Override
        public void onFailure(Throwable e) {
            enableEdit(true);
            pendingGroup = null;
            if (RestApi.isNotSignedIn(e)) {
                Cookies.setCookie(getCookieName(), editArea.getValue().trim());
            }
            super.onFailure(e);
        }
    };
    if (input.id() == null) {
        CommentApi.createDraft(psId, input, group.add(cb));
    } else {
        CommentApi.updateDraft(psId, input.id(), input, group.add(cb));
    }
    CodeMirror cm = getCm();
    cm.vim().handleKey("<Esc>");
    cm.focus();
}
#method_after
void save(CallbackGroup group) {
    if (pendingGroup != null) {
        pendingGroup.addListener(group);
        return;
    }
    String message = editArea.getValue().trim();
    if (message.length() == 0) {
        return;
    }
    CommentInfo input = CommentInfo.copy(comment);
    input.message(message);
    enableEdit(false);
    pendingGroup = group;
    final LocalComments lc = new LocalComments(psId);
    GerritCallback<CommentInfo> cb = new GerritCallback<CommentInfo>() {

        @Override
        public void onSuccess(CommentInfo result) {
            enableEdit(true);
            pendingGroup = null;
            set(result);
            setEdit(false);
            if (autoClosed) {
                setOpen(false);
            }
            getCommentManager().setUnsaved(DraftBox.this, false);
        }

        @Override
        public void onFailure(Throwable e) {
            enableEdit(true);
            pendingGroup = null;
            if (RestApi.isNotSignedIn(e)) {
                CommentInfo saved = CommentInfo.copy(comment);
                saved.message(editArea.getValue().trim());
                lc.setInlineComment(saved);
            }
            super.onFailure(e);
        }
    };
    if (input.id() == null) {
        CommentApi.createDraft(psId, input, group.add(cb));
    } else {
        CommentApi.updateDraft(psId, input.id(), input, group.add(cb));
    }
    CodeMirror cm = getCm();
    cm.vim().handleKey("<Esc>");
    cm.focus();
}
#end_block

#method_before
@Override
protected void onLoad() {
    commentsPanel.setVisible(false);
    post.setEnabled(false);
    String savedMessage = Cookies.getCookie(getCookieName());
    if (savedMessage != null) {
        message.setText(savedMessage);
        Cookies.removeCookie(getCookieName());
    }
    ChangeApi.drafts(psId.getParentKey().get()).get(new AsyncCallback<NativeMap<JsArray<CommentInfo>>>() {

        @Override
        public void onSuccess(NativeMap<JsArray<CommentInfo>> result) {
            displayComments(result);
            post.setEnabled(true);
        }

        @Override
        public void onFailure(Throwable caught) {
            post.setEnabled(true);
        }
    });
    Scheduler.get().scheduleDeferred(new ScheduledCommand() {

        @Override
        public void execute() {
            message.setFocus(true);
        }
    });
    Scheduler.get().scheduleFixedDelay(new RepeatingCommand() {

        @Override
        public boolean execute() {
            String t = message.getText();
            if (t != null) {
                message.setCursorPos(t.length());
            }
            return false;
        }
    }, 0);
}
#method_after
@Override
protected void onLoad() {
    commentsPanel.setVisible(false);
    post.setEnabled(false);
    if (lc.hasReplyComment()) {
        message.setText(lc.getReplyComment());
        lc.removeReplyComment();
    }
    ChangeApi.drafts(psId.getParentKey().get()).get(new AsyncCallback<NativeMap<JsArray<CommentInfo>>>() {

        @Override
        public void onSuccess(NativeMap<JsArray<CommentInfo>> result) {
            displayComments(result);
            post.setEnabled(true);
        }

        @Override
        public void onFailure(Throwable caught) {
            post.setEnabled(true);
        }
    });
    Scheduler.get().scheduleDeferred(new ScheduledCommand() {

        @Override
        public void execute() {
            message.setFocus(true);
        }
    });
    Scheduler.get().scheduleFixedDelay(new RepeatingCommand() {

        @Override
        public boolean execute() {
            String t = message.getText();
            if (t != null) {
                message.setCursorPos(t.length());
            }
            return false;
        }
    }, 0);
}
#end_block

#method_before
private void postReview() {
    in.message(message.getText().trim());
    // Don't send any comments in the request; just publish everything, even if
    // e.g. a draft was modified in another tab since we last looked it up.
    in.drafts(DraftHandling.PUBLISH_ALL_REVISIONS);
    in.prePost();
    ChangeApi.revision(psId.getParentKey().get(), revision).view("review").post(in, new GerritCallback<ReviewInput>() {

        @Override
        public void onSuccess(ReviewInput result) {
            Gerrit.display(PageLinks.toChange(psId.getParentKey(), String.valueOf(psId.get())));
        }

        @Override
        public void onFailure(final Throwable caught) {
            if (RestApi.isNotSignedIn(caught)) {
                Cookies.setCookie(getCookieName(), message.getText().trim());
            }
            super.onFailure(caught);
        }
    });
    hide();
}
#method_after
private void postReview() {
    in.message(message.getText().trim());
    // Don't send any comments in the request; just publish everything, even if
    // e.g. a draft was modified in another tab since we last looked it up.
    in.drafts(DraftHandling.PUBLISH_ALL_REVISIONS);
    in.prePost();
    ChangeApi.revision(psId.getParentKey().get(), revision).view("review").post(in, new GerritCallback<ReviewInput>() {

        @Override
        public void onSuccess(ReviewInput result) {
            Gerrit.display(PageLinks.toChange(psId.getParentKey(), String.valueOf(psId.get())));
        }

        @Override
        public void onFailure(final Throwable caught) {
            if (RestApi.isNotSignedIn(caught)) {
                lc.setReplyComment(message.getText());
            }
            super.onFailure(caught);
        }
    });
    hide();
}
#end_block

#method_before
private void onSave(final AsyncCallback<VoidResult> onSave) {
    expandTimer.cancel();
    final String txt = text.getText().trim();
    if ("".equals(txt)) {
        return;
    }
    comment.setMessage(txt);
    text.setFocus(false);
    text.setReadOnly(true);
    save.setEnabled(false);
    cancel.setEnabled(false);
    discard.setEnabled(false);
    final PatchSet.Id psId = comment.getKey().getParentKey().getParentKey();
    final boolean wasNew = isNew();
    GerritCallback<CommentInfo> cb = new GerritCallback<CommentInfo>() {

        @Override
        public void onSuccess(CommentInfo result) {
            notifyDraftDelta(wasNew ? 1 : 0);
            comment = toComment(psId, comment.getKey().getParentKey().get(), result);
            text.setReadOnly(false);
            save.setEnabled(true);
            cancel.setEnabled(true);
            discard.setEnabled(true);
            render();
            onSave.onSuccess(VoidResult.INSTANCE);
        }

        @Override
        public void onFailure(final Throwable caught) {
            text.setReadOnly(false);
            text.setFocus(true);
            save.setEnabled(true);
            cancel.setEnabled(true);
            discard.setEnabled(true);
            Cookies.setCookie("patchComment-" + psId.getParentKey().toString() + "-" + psId.getId() + "-" + btoa(comment.getKey().getParentKey().get()) + "-" + comment.getSide() + "-" + comment.getLine(), comment.getMessage());
            super.onFailure(caught);
            onSave.onFailure(caught);
        }
    };
    CommentInfo input = toInput(comment);
    if (wasNew) {
        CommentApi.createDraft(psId, input, cb);
    } else {
        CommentApi.updateDraft(psId, input.id(), input, cb);
    }
}
#method_after
private void onSave(final AsyncCallback<VoidResult> onSave) {
    expandTimer.cancel();
    final String txt = text.getText().trim();
    if ("".equals(txt)) {
        return;
    }
    comment.setMessage(txt);
    text.setFocus(false);
    text.setReadOnly(true);
    save.setEnabled(false);
    cancel.setEnabled(false);
    discard.setEnabled(false);
    final PatchSet.Id psId = comment.getKey().getParentKey().getParentKey();
    final LocalComments lc = new LocalComments(psId);
    final boolean wasNew = isNew();
    GerritCallback<CommentInfo> cb = new GerritCallback<CommentInfo>() {

        @Override
        public void onSuccess(CommentInfo result) {
            notifyDraftDelta(wasNew ? 1 : 0);
            comment = toComment(psId, comment.getKey().getParentKey().get(), result);
            text.setReadOnly(false);
            save.setEnabled(true);
            cancel.setEnabled(true);
            discard.setEnabled(true);
            render();
            onSave.onSuccess(VoidResult.INSTANCE);
        }

        @Override
        public void onFailure(final Throwable caught) {
            text.setReadOnly(false);
            text.setFocus(true);
            save.setEnabled(true);
            cancel.setEnabled(true);
            discard.setEnabled(true);
            lc.setInlineComment(toInput(comment));
            super.onFailure(caught);
            onSave.onFailure(caught);
        }
    };
    CommentInfo input = toInput(comment);
    if (wasNew) {
        CommentApi.createDraft(psId, input, cb);
    } else {
        CommentApi.updateDraft(psId, input.id(), input, cb);
    }
}
#end_block

#method_before
private Collection<AccountInfo> toAccountInfo(Collection<Account.Id> accounts) {
    return FluentIterable.from(accounts).transform(new Function<Account.Id, AccountInfo>() {

        @Override
        public AccountInfo apply(Account.Id id) {
            return accountLoader.get(id);
        }
    }).toSortedList(new AccountInfoComparator());
}
#method_after
private Collection<AccountInfo> toAccountInfo(Collection<Account.Id> accounts) {
    return FluentIterable.from(accounts).transform(new Function<Account.Id, AccountInfo>() {

        @Override
        public AccountInfo apply(Account.Id id) {
            return accountLoader.get(id);
        }
    }).toSortedList(AccountInfoComparator.ORDER_NULLS_FIRST);
}
#end_block

#method_before
public List<AccountInfo> apply(AccountGroup.UUID groupId) throws OrmException {
    final Map<Account.Id, AccountInfo> members = getMembers(groupId, new HashSet<AccountGroup.UUID>());
    final List<AccountInfo> memberInfos = Lists.newArrayList(members.values());
    Collections.sort(memberInfos, new AccountInfoComparator());
    return memberInfos;
}
#method_after
public List<AccountInfo> apply(AccountGroup.UUID groupId) throws OrmException {
    final Map<Account.Id, AccountInfo> members = getMembers(groupId, new HashSet<AccountGroup.UUID>());
    final List<AccountInfo> memberInfos = Lists.newArrayList(members.values());
    Collections.sort(memberInfos, AccountInfoComparator.ORDER_NULLS_FIRST);
    return memberInfos;
}
#end_block

#method_before
@Override
public List<AccountInfo> apply(TopLevelResource rsrc) throws OrmException, BadRequestException {
    if (Strings.isNullOrEmpty(query)) {
        throw new BadRequestException("missing query field");
    }
    if (!suggest || query.length() < suggestFrom) {
        return Collections.emptyList();
    }
    String a = query;
    String b = a + MAX_SUFFIX;
    Map<Account.Id, AccountInfo> matches = new LinkedHashMap<>();
    Map<Account.Id, String> queryEmail = new HashMap<>();
    for (Account p : db.accounts().suggestByFullName(a, b, limit)) {
        addSuggestion(matches, p);
    }
    if (matches.size() < limit) {
        for (Account p : db.accounts().suggestByPreferredEmail(a, b, limit - matches.size())) {
            addSuggestion(matches, p);
        }
    }
    if (matches.size() < limit) {
        for (AccountExternalId e : db.accountExternalIds().suggestByEmailAddress(a, b, limit - matches.size())) {
            if (addSuggestion(matches, e.getAccountId())) {
                queryEmail.put(e.getAccountId(), e.getEmailAddress());
            }
        }
    }
    accountLoader.fill();
    for (Map.Entry<Account.Id, String> p : queryEmail.entrySet()) {
        AccountInfo info = matches.get(p.getKey());
        if (info != null) {
            info.email = p.getValue();
        }
    }
    List<AccountInfo> m = new ArrayList<>(matches.values());
    Collections.sort(m, new AccountInfoComparator());
    return m;
}
#method_after
@Override
public List<AccountInfo> apply(TopLevelResource rsrc) throws OrmException, BadRequestException {
    if (Strings.isNullOrEmpty(query)) {
        throw new BadRequestException("missing query field");
    }
    if (!suggest || query.length() < suggestFrom) {
        return Collections.emptyList();
    }
    String a = query;
    String b = a + MAX_SUFFIX;
    Map<Account.Id, AccountInfo> matches = new LinkedHashMap<>();
    Map<Account.Id, String> queryEmail = new HashMap<>();
    for (Account p : db.accounts().suggestByFullName(a, b, limit)) {
        addSuggestion(matches, p);
    }
    if (matches.size() < limit) {
        for (Account p : db.accounts().suggestByPreferredEmail(a, b, limit - matches.size())) {
            addSuggestion(matches, p);
        }
    }
    if (matches.size() < limit) {
        for (AccountExternalId e : db.accountExternalIds().suggestByEmailAddress(a, b, limit - matches.size())) {
            if (addSuggestion(matches, e.getAccountId())) {
                queryEmail.put(e.getAccountId(), e.getEmailAddress());
            }
        }
    }
    accountLoader.fill();
    for (Map.Entry<Account.Id, String> p : queryEmail.entrySet()) {
        AccountInfo info = matches.get(p.getKey());
        if (info != null) {
            info.email = p.getValue();
        }
    }
    List<AccountInfo> m = new ArrayList<>(matches.values());
    Collections.sort(m, AccountInfoComparator.ORDER_NULLS_LAST);
    return m;
}
#end_block

#method_before
@Override
public int compare(AccountInfo a, AccountInfo b) {
    return ComparisonChain.start().compare(a.name, b.name, Ordering.natural().nullsFirst()).compare(a.email, b.email, Ordering.natural().nullsFirst()).compare(a._accountId, b._accountId, Ordering.natural().nullsFirst()).result();
}
#method_after
@Override
public int compare(AccountInfo a, AccountInfo b) {
    return ComparisonChain.start().compare(a.name, b.name, createOrdering()).compare(a.email, b.email, createOrdering()).compare(a._accountId, b._accountId, createOrdering()).result();
}
#end_block

#method_before
private void initPageHeader() {
    parseToken();
    HorizontalPanel hp = new HorizontalPanel();
    hp.setStyleName(Gerrit.RESOURCES.css().projectFilterPanel());
    Label filterLabel = new Label(Util.C.projectFilter());
    filterLabel.setStyleName(Gerrit.RESOURCES.css().projectFilterLabel());
    hp.add(filterLabel);
    filterTxt = new NpTextBox();
    filterTxt.setValue(match);
    filterTxt.addKeyUpHandler(new KeyUpHandler() {

        @Override
        public void onKeyUp(KeyUpEvent event) {
            Query q = new Query(filterTxt.getValue());
            if (match.equals(q.qMatch)) {
                q.start(start);
            }
            if (!match.equals(q.qMatch)) {
                if (query == null) {
                    q.run();
                }
                query = q;
            }
        }
    });
    hp.add(filterTxt);
    add(hp);
}
#method_after
private void initPageHeader() {
    parseToken();
    HorizontalPanel hp = new HorizontalPanel();
    hp.setStyleName(Gerrit.RESOURCES.css().projectFilterPanel());
    Label filterLabel = new Label(Util.C.projectFilter());
    filterLabel.setStyleName(Gerrit.RESOURCES.css().projectFilterLabel());
    hp.add(filterLabel);
    filterTxt = new NpTextBox();
    filterTxt.setValue(match);
    filterTxt.addKeyUpHandler(new KeyUpHandler() {

        @Override
        public void onKeyUp(KeyUpEvent event) {
            Query q = new Query(filterTxt.getValue());
            if (match.equals(q.qMatch)) {
                q.start(start);
            } else {
                if (query == null) {
                    q.run();
                }
                query = q;
            }
        }
    });
    hp.add(filterTxt);
    add(hp);
}
#end_block

#method_before
private void update(ReviewDb db, AuthRequest who, AccountExternalId extId) throws OrmException {
    IdentifiedUser user = userFactory.create(extId.getAccountId());
    Account toUpdate = null;
    // If the email address was modified by the authentication provider,
    // update our records to match the changed email.
    // 
    String newEmail = who.getEmailAddress();
    String oldEmail = extId.getEmailAddress();
    if (newEmail != null && !newEmail.equals(oldEmail)) {
        if (oldEmail != null && oldEmail.equals(user.getAccount().getPreferredEmail())) {
            toUpdate = load(toUpdate, user.getAccountId(), db);
            toUpdate.setPreferredEmail(newEmail);
        }
        extId.setEmailAddress(newEmail);
        db.accountExternalIds().update(Collections.singleton(extId));
    }
    if (!realm.allowsEdit(Account.FieldName.FULL_NAME) && who.getDisplayName() != null && !eq(user.getAccount().getFullName(), who.getDisplayName())) {
        toUpdate = load(toUpdate, user.getAccountId(), db);
        toUpdate.setFullName(who.getDisplayName());
    }
    if (!realm.allowsEdit(Account.FieldName.USER_NAME) && !eq(user.getUserName(), who.getUserName())) {
        changeUserNameFactory.create(db, user, who.getUserName());
    }
    if (toUpdate != null) {
        db.accounts().update(Collections.singleton(toUpdate));
    }
    if (newEmail != null && !newEmail.equals(oldEmail)) {
        byEmailCache.evict(oldEmail);
        byEmailCache.evict(newEmail);
    }
    if (toUpdate != null) {
        byIdCache.evict(toUpdate.getId());
    }
}
#method_after
private void update(ReviewDb db, AuthRequest who, AccountExternalId extId) throws OrmException {
    IdentifiedUser user = userFactory.create(extId.getAccountId());
    Account toUpdate = null;
    // If the email address was modified by the authentication provider,
    // update our records to match the changed email.
    // 
    String newEmail = who.getEmailAddress();
    String oldEmail = extId.getEmailAddress();
    if (newEmail != null && !newEmail.equals(oldEmail)) {
        if (oldEmail != null && oldEmail.equals(user.getAccount().getPreferredEmail())) {
            toUpdate = load(toUpdate, user.getAccountId(), db);
            toUpdate.setPreferredEmail(newEmail);
        }
        extId.setEmailAddress(newEmail);
        db.accountExternalIds().update(Collections.singleton(extId));
    }
    if (!realm.allowsEdit(Account.FieldName.FULL_NAME) && !Strings.isNullOrEmpty(who.getDisplayName()) && !eq(user.getAccount().getFullName(), who.getDisplayName())) {
        toUpdate = load(toUpdate, user.getAccountId(), db);
        toUpdate.setFullName(who.getDisplayName());
    }
    if (!realm.allowsEdit(Account.FieldName.USER_NAME) && !eq(user.getUserName(), who.getUserName())) {
        changeUserNameFactory.create(db, user, who.getUserName());
    }
    if (toUpdate != null) {
        db.accounts().update(Collections.singleton(toUpdate));
    }
    if (newEmail != null && !newEmail.equals(oldEmail)) {
        byEmailCache.evict(oldEmail);
        byEmailCache.evict(newEmail);
    }
    if (toUpdate != null) {
        byIdCache.evict(toUpdate.getId());
    }
}
#end_block

#method_before
public ChangeControl forUser(final CurrentUser who) {
    if (getUser().equals(who)) {
        return this;
    }
    return new ChangeControl(changeDataFactory, getRefControl().forUser(who), notes);
}
#method_after
public ChangeControl forUser(final CurrentUser who) {
    if (getUser().equals(who)) {
        return this;
    }
    return new ChangeControl(changeDataFactory, approvalsUtil, getRefControl().forUser(who), notes);
}
#end_block

#method_before
public boolean canAbandon(ReviewDb db) throws OrmException {
    if (isPatchSetLocked(db)) {
        return false;
    }
    return // owner (aka creator) of the change can abandon
    isOwner() || // branch owner can abandon
    getRefControl().isOwner() || // project owner can abandon
    getProjectControl().isOwner() || // site administers are god
    getUser().getCapabilities().canAdministrateServer() || // user can abandon a specific ref
    getRefControl().canAbandon();
}
#method_after
public boolean canAbandon(ReviewDb db) throws OrmException {
    return (// owner (aka creator) of the change can abandon
    isOwner() || // branch owner can abandon
    getRefControl().isOwner() || // project owner can abandon
    getProjectControl().isOwner() || // site administers are god
    getUser().getCapabilities().canAdministrateServer() || // user can abandon a specific ref
    getRefControl().canAbandon()) && !isPatchSetLocked(db);
}
#end_block

#method_before
public boolean isPatchSetLocked(ReviewDb db) throws OrmException {
    if (getChange().getStatus() == Change.Status.MERGED) {
        return false;
    }
    final List<PatchSetApproval> psApprovals = db.patchSetApprovals().byPatchSet(getChange().currentPatchSetId()).toList();
    for (final PatchSetApproval ap : psApprovals) {
        LabelType type = getLabelTypes().byLabel(ap.getLabel());
        if (type != null) {
            if (type.getFunctionName().equalsIgnoreCase("PatchSetLock") && ap.getValue() == 1) {
                return true;
            }
        }
    }
    return false;
}
#method_after
public boolean isPatchSetLocked(ReviewDb db) throws OrmException {
    if (getChange().getStatus() == Change.Status.MERGED) {
        return false;
    }
    for (PatchSetApproval ap : approvalsUtil.byPatchSet(db, this, getChange().currentPatchSetId())) {
        LabelType type = getLabelTypes().byLabel(ap.getLabel());
        if (type != null && ap.getValue() == 1 && type.getFunctionName().equalsIgnoreCase("PatchSetLock")) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
@Override
public void commit() {
    throw new AssertionError(MESSAGE);
}
#method_after
@Override
public void commit() {
    throw new Disabled();
}
#end_block

#method_before
@Override
public void rollback() {
    throw new AssertionError(MESSAGE);
}
#method_after
@Override
public void rollback() {
    throw new Disabled();
}
#end_block

#method_before
@Override
public void updateSchema(StatementExecutor e) {
    throw new AssertionError(MESSAGE);
}
#method_after
@Override
public void updateSchema(StatementExecutor e) {
    throw new Disabled();
}
#end_block

#method_before
@Override
public void pruneSchema(StatementExecutor e) {
    throw new AssertionError(MESSAGE);
}
#method_after
@Override
public void pruneSchema(StatementExecutor e) {
    throw new Disabled();
}
#end_block

#method_before
@Override
public Access<?, ?>[] allRelations() {
    throw new AssertionError(MESSAGE);
}
#method_after
@Override
public Access<?, ?>[] allRelations() {
    throw new Disabled();
}
#end_block

#method_before
@Override
public SchemaVersionAccess schemaVersion() {
    throw new AssertionError(MESSAGE);
}
#method_after
@Override
public SchemaVersionAccess schemaVersion() {
    throw new Disabled();
}
#end_block

#method_before
@Override
public SystemConfigAccess systemConfig() {
    throw new AssertionError(MESSAGE);
}
#method_after
@Override
public SystemConfigAccess systemConfig() {
    throw new Disabled();
}
#end_block

#method_before
@Override
public AccountAccess accounts() {
    throw new AssertionError(MESSAGE);
}
#method_after
@Override
public AccountAccess accounts() {
    throw new Disabled();
}
#end_block

#method_before
@Override
public AccountExternalIdAccess accountExternalIds() {
    throw new AssertionError(MESSAGE);
}
#method_after
@Override
public AccountExternalIdAccess accountExternalIds() {
    throw new Disabled();
}
#end_block

#method_before
@Override
public AccountSshKeyAccess accountSshKeys() {
    throw new AssertionError(MESSAGE);
}
#method_after
@Override
public AccountSshKeyAccess accountSshKeys() {
    throw new Disabled();
}
#end_block

#method_before
@Override
public AccountGroupAccess accountGroups() {
    throw new AssertionError(MESSAGE);
}
#method_after
@Override
public AccountGroupAccess accountGroups() {
    throw new Disabled();
}
#end_block

#method_before
@Override
public AccountGroupNameAccess accountGroupNames() {
    throw new AssertionError(MESSAGE);
}
#method_after
@Override
public AccountGroupNameAccess accountGroupNames() {
    throw new Disabled();
}
#end_block

#method_before
@Override
public AccountGroupMemberAccess accountGroupMembers() {
    throw new AssertionError(MESSAGE);
}
#method_after
@Override
public AccountGroupMemberAccess accountGroupMembers() {
    throw new Disabled();
}
#end_block

#method_before
@Override
public AccountGroupMemberAuditAccess accountGroupMembersAudit() {
    throw new AssertionError(MESSAGE);
}
#method_after
@Override
public AccountGroupMemberAuditAccess accountGroupMembersAudit() {
    throw new Disabled();
}
#end_block

#method_before
@Override
public StarredChangeAccess starredChanges() {
    throw new AssertionError(MESSAGE);
}
#method_after
@Override
public StarredChangeAccess starredChanges() {
    throw new Disabled();
}
#end_block

#method_before
@Override
public AccountProjectWatchAccess accountProjectWatches() {
    throw new AssertionError(MESSAGE);
}
#method_after
@Override
public AccountProjectWatchAccess accountProjectWatches() {
    throw new Disabled();
}
#end_block

#method_before
@Override
public AccountPatchReviewAccess accountPatchReviews() {
    throw new AssertionError(MESSAGE);
}
#method_after
@Override
public AccountPatchReviewAccess accountPatchReviews() {
    throw new Disabled();
}
#end_block

#method_before
@Override
public ChangeAccess changes() {
    throw new AssertionError(MESSAGE);
}
#method_after
@Override
public ChangeAccess changes() {
    throw new Disabled();
}
#end_block

#method_before
@Override
public PatchSetApprovalAccess patchSetApprovals() {
    throw new AssertionError(MESSAGE);
}
#method_after
@Override
public PatchSetApprovalAccess patchSetApprovals() {
    throw new Disabled();
}
#end_block

#method_before
@Override
public ChangeMessageAccess changeMessages() {
    throw new AssertionError(MESSAGE);
}
#method_after
@Override
public ChangeMessageAccess changeMessages() {
    throw new Disabled();
}
#end_block

#method_before
@Override
public PatchSetAccess patchSets() {
    throw new AssertionError(MESSAGE);
}
#method_after
@Override
public PatchSetAccess patchSets() {
    throw new Disabled();
}
#end_block

#method_before
@Override
public PatchLineCommentAccess patchComments() {
    throw new AssertionError(MESSAGE);
}
#method_after
@Override
public PatchLineCommentAccess patchComments() {
    throw new Disabled();
}
#end_block

#method_before
@Override
public SubmoduleSubscriptionAccess submoduleSubscriptions() {
    throw new AssertionError(MESSAGE);
}
#method_after
@Override
public SubmoduleSubscriptionAccess submoduleSubscriptions() {
    throw new Disabled();
}
#end_block

#method_before
@Override
public AccountGroupByIdAccess accountGroupById() {
    throw new AssertionError(MESSAGE);
}
#method_after
@Override
public AccountGroupByIdAccess accountGroupById() {
    throw new Disabled();
}
#end_block

#method_before
@Override
public AccountGroupByIdAudAccess accountGroupByIdAud() {
    throw new AssertionError(MESSAGE);
}
#method_after
@Override
public AccountGroupByIdAudAccess accountGroupByIdAud() {
    throw new Disabled();
}
#end_block

#method_before
@Override
public int nextAccountId() {
    throw new AssertionError(MESSAGE);
}
#method_after
@Override
public int nextAccountId() {
    throw new Disabled();
}
#end_block

#method_before
@Override
public int nextAccountGroupId() {
    throw new AssertionError(MESSAGE);
}
#method_after
@Override
public int nextAccountGroupId() {
    throw new Disabled();
}
#end_block

#method_before
@Override
public int nextChangeId() {
    throw new AssertionError(MESSAGE);
}
#method_after
@Override
public int nextChangeId() {
    throw new Disabled();
}
#end_block

#method_before
@Override
public int nextChangeMessageId() {
    throw new AssertionError(MESSAGE);
}
#method_after
@Override
public int nextChangeMessageId() {
    throw new Disabled();
}
#end_block

#method_before
private static int getPluginsLoadTimeout(final Config cfg) {
    long cfgValue = ConfigUtil.getTimeUnit(cfg, "plugins", null, "jsLoadTimeout", DEFAULT_JS_LOAD_TIMEOUT, TimeUnit.MILLISECONDS);
    if (cfgValue < 0) {
        return 0;
    }
    return (int) cfgValue;
}
#method_after
private static int getPluginsLoadTimeout(Config cfg) {
    long cfgValue = ConfigUtil.getTimeUnit(cfg, "plugins", null, "jsLoadTimeout", DEFAULT_JS_LOAD_TIMEOUT, TimeUnit.MILLISECONDS);
    if (cfgValue < 0) {
        return 0;
    }
    return (int) cfgValue;
}
#end_block

#method_before
private void json(final Object data, final StringWriter w) {
    JsonServlet.defaultGsonBuilder().create().toJson(data, w);
}
#method_after
private void json(Object data, StringWriter w) {
    JsonServlet.defaultGsonBuilder().create().toJson(data, w);
}
#end_block

#method_before
@Override
protected void doGet(final HttpServletRequest req, final HttpServletResponse rsp) throws IOException {
    final Page.Content page = select(req);
    final StringWriter w = new StringWriter();
    final CurrentUser user = currentUser.get();
    if (user.isIdentifiedUser()) {
        w.write(HPD_ID + ".xGerritAuth=");
        json(session.get().getXGerritAuth(), w);
        w.write(";");
        w.write(HPD_ID + ".accountDiffPref=");
        json(getDiffPreferences((IdentifiedUser) user), w);
        w.write(";");
        w.write(HPD_ID + ".theme=");
        json(signedInTheme, w);
        w.write(";");
    } else {
        w.write(HPD_ID + ".theme=");
        json(signedOutTheme, w);
        w.write(";");
    }
    plugins(w);
    messages(w);
    final byte[] hpd = w.toString().getBytes("UTF-8");
    final byte[] raw = Bytes.concat(page.part1, hpd, page.part2);
    final byte[] tosend;
    if (RPCServletUtils.acceptsGzipEncoding(req)) {
        rsp.setHeader("Content-Encoding", "gzip");
        tosend = HtmlDomUtil.compress(raw);
    } else {
        tosend = raw;
    }
    CacheHeaders.setNotCacheable(rsp);
    rsp.setContentType("text/html");
    rsp.setCharacterEncoding(HtmlDomUtil.ENC.name());
    rsp.setContentLength(tosend.length);
    try (OutputStream out = rsp.getOutputStream()) {
        out.write(tosend);
    }
}
#method_after
@Override
protected void doGet(HttpServletRequest req, HttpServletResponse rsp) throws IOException {
    Page.Content page = select(req);
    StringWriter w = new StringWriter();
    CurrentUser user = currentUser.get();
    if (user.isIdentifiedUser()) {
        setXGerritAuthCookie(req, rsp, session.get());
        w.write(HPD_ID + ".accountDiffPref=");
        json(getDiffPreferences(user.asIdentifiedUser()), w);
        w.write(";");
        w.write(HPD_ID + ".theme=");
        json(signedInTheme, w);
        w.write(";");
    } else {
        setXGerritAuthCookie(req, rsp, null);
        w.write(HPD_ID + ".theme=");
        json(signedOutTheme, w);
        w.write(";");
    }
    plugins(w);
    messages(w);
    byte[] hpd = w.toString().getBytes(UTF_8);
    byte[] raw = Bytes.concat(page.part1, hpd, page.part2);
    byte[] tosend;
    if (RPCServletUtils.acceptsGzipEncoding(req)) {
        rsp.setHeader("Content-Encoding", "gzip");
        tosend = HtmlDomUtil.compress(raw);
    } else {
        tosend = raw;
    }
    CacheHeaders.setNotCacheable(rsp);
    rsp.setContentType("text/html");
    rsp.setCharacterEncoding(HtmlDomUtil.ENC.name());
    rsp.setContentLength(tosend.length);
    try (OutputStream out = rsp.getOutputStream()) {
        out.write(tosend);
    }
}
#end_block

#method_before
private void asScript(final Element scriptNode) {
    scriptNode.setAttribute("type", "text/javascript");
    scriptNode.setAttribute("language", "javascript");
}
#method_after
private void asScript(Element scriptNode) {
    scriptNode.setAttribute("type", "text/javascript");
    scriptNode.setAttribute("language", "javascript");
}
#end_block

#method_before
private FileInfo injectCssFile(Document hostDoc, String id, Path src) throws IOException {
    final FileInfo info = new FileInfo(src);
    final Element banner = HtmlDomUtil.find(hostDoc, id);
    if (banner == null) {
        return info;
    }
    while (banner.getFirstChild() != null) {
        banner.removeChild(banner.getFirstChild());
    }
    String css = HtmlDomUtil.readFile(src.getParent(), src.getFileName().toString());
    if (css == null) {
        return info;
    }
    banner.appendChild(hostDoc.createCDATASection("\n" + css + "\n"));
    return info;
}
#method_after
private FileInfo injectCssFile(Document hostDoc, String id, Path src) throws IOException {
    FileInfo info = new FileInfo(src);
    Element banner = HtmlDomUtil.find(hostDoc, id);
    if (banner == null) {
        return info;
    }
    while (banner.getFirstChild() != null) {
        banner.removeChild(banner.getFirstChild());
    }
    String css = HtmlDomUtil.readFile(src.getParent(), src.getFileName().toString());
    if (css == null) {
        return info;
    }
    banner.appendChild(hostDoc.createCDATASection("\n" + css + "\n"));
    return info;
}
#end_block

#method_before
private FileInfo injectXmlFile(Document hostDoc, String id, Path src) throws IOException {
    final FileInfo info = new FileInfo(src);
    final Element banner = HtmlDomUtil.find(hostDoc, id);
    if (banner == null) {
        return info;
    }
    while (banner.getFirstChild() != null) {
        banner.removeChild(banner.getFirstChild());
    }
    Document html = HtmlDomUtil.parseFile(src);
    if (html == null) {
        return info;
    }
    Element content = html.getDocumentElement();
    insertETags(content);
    banner.appendChild(hostDoc.importNode(content, true));
    return info;
}
#method_after
private FileInfo injectXmlFile(Document hostDoc, String id, Path src) throws IOException {
    FileInfo info = new FileInfo(src);
    Element banner = HtmlDomUtil.find(hostDoc, id);
    if (banner == null) {
        return info;
    }
    while (banner.getFirstChild() != null) {
        banner.removeChild(banner.getFirstChild());
    }
    Document html = HtmlDomUtil.parseFile(src);
    if (html == null) {
        return info;
    }
    Element content = html.getDocumentElement();
    insertETags(content);
    banner.appendChild(hostDoc.importNode(content, true));
    return info;
}
#end_block

#method_before
@Override
public DiffPreferencesInfo apply(AccountResource rsrc) throws AuthException, ConfigInvalidException, IOException {
    if (self.get() != rsrc.getUser() && !self.get().getCapabilities().canAdministrateServer()) {
        throw new AuthException("restricted to administrator");
    }
    try (Repository git = gitMgr.openRepository(allUsersName.get())) {
        VersionedAccountPreferences p = VersionedAccountPreferences.forUser(rsrc.getUser().getAccountId());
        p.load(git);
        DiffPreferencesInfo prefs = new DiffPreferencesInfo();
        loadSection(p.getConfig(), UserConfigSections.DIFF, null, prefs, DiffPreferencesInfo.defaults());
        // Reset the migrated flag to prevent it from being sent over the wire.
        prefs.migrated = null;
        return prefs;
    }
}
#method_after
@Override
public DiffPreferencesInfo apply(AccountResource rsrc) throws AuthException, ConfigInvalidException, IOException {
    if (self.get() != rsrc.getUser() && !self.get().getCapabilities().canAdministrateServer()) {
        throw new AuthException("restricted to administrator");
    }
    Account.Id id = rsrc.getUser().getAccountId();
    return readFromGit(id, gitMgr, allUsersName.get(), null);
}
#end_block

#method_before
@Nullable
private GroupBackend backend(AccountGroup.UUID uuid) {
    for (GroupBackend g : backends) {
        if (g.handles(uuid)) {
            return g;
        }
    }
    return null;
}
#method_after
@Nullable
private GroupBackend backend(AccountGroup.UUID uuid) {
    if (uuid != null) {
        for (GroupBackend g : backends) {
            if (g.handles(uuid)) {
                return g;
            }
        }
    }
    return null;
}
#end_block

#method_before
@Override
public ExtGroup get(AccountGroup.UUID uuid) {
    return requireBackend(uuid).get(uuid);
}
#method_after
@Override
public GroupDescription.Basic get(AccountGroup.UUID uuid) {
    GroupBackend b = backend(uuid);
    if (b == null) {
        log.warn("Unknown GroupBackend for UUID: " + uuid);
        return null;
    }
    return b.get(uuid);
}
#end_block

#method_before
@Override
public GroupMembership membershipsOf(AccountState user) {
    return new UniversalGroupMembership(user);
}
#method_after
@Override
public GroupMembership membershipsOf(IdentifiedUser user) {
    return new UniversalGroupMembership(user);
}
#end_block

#method_before
@Nullable
private GroupMembership membership(AccountGroup.UUID uuid) {
    for (Map.Entry<GroupBackend, GroupMembership> m : memberships.entrySet()) {
        if (m.getKey().handles(uuid)) {
            return m.getValue();
        }
    }
    return null;
}
#method_after
@Nullable
private GroupMembership membership(AccountGroup.UUID uuid) {
    if (uuid != null) {
        for (Map.Entry<GroupBackend, GroupMembership> m : memberships.entrySet()) {
            if (m.getKey().handles(uuid)) {
                return m.getValue();
            }
        }
    }
    return null;
}
#end_block

#method_before
@Override
public boolean contains(AccountGroup.UUID uuid) {
    return requireMembership(uuid).contains(uuid);
}
#method_after
@Override
public boolean contains(AccountGroup.UUID uuid) {
    GroupMembership m = membership(uuid);
    if (m == null) {
        log.warn("Unknown GroupMembership for UUID: " + uuid);
        return false;
    }
    return m.contains(uuid);
}
#end_block

#method_before
@Override
public boolean containsAnyOf(Iterable<AccountGroup.UUID> uuids) {
    Multimap<GroupMembership, AccountGroup.UUID> lookups = ArrayListMultimap.create();
    for (AccountGroup.UUID uuid : uuids) {
        lookups.put(requireMembership(uuid), uuid);
    }
    for (Map.Entry<GroupMembership, Collection<AccountGroup.UUID>> entry : lookups.asMap().entrySet()) {
        if (entry.getKey().containsAnyOf(entry.getValue())) {
            return true;
        }
    }
    return false;
}
#method_after
@Override
public boolean containsAnyOf(Iterable<AccountGroup.UUID> uuids) {
    Multimap<GroupMembership, AccountGroup.UUID> lookups = ArrayListMultimap.create();
    for (AccountGroup.UUID uuid : uuids) {
        GroupMembership m = membership(uuid);
        if (m == null) {
            log.warn("Unknown GroupMembership for UUID: " + uuid);
            continue;
        }
        lookups.put(m, uuid);
    }
    for (Map.Entry<GroupMembership, Collection<AccountGroup.UUID>> entry : lookups.asMap().entrySet()) {
        if (entry.getKey().containsAnyOf(entry.getValue())) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
public GroupControl controlFor(final AccountGroup.Id groupId) throws NoSuchGroupException {
    final AccountGroup group = groupCache.get(groupId);
    if (group == null) {
        throw new NoSuchGroupException(groupId);
    }
    return new GroupControl(groupCache, user.get(), group);
}
#method_after
public GroupControl controlFor(final AccountGroup.Id groupId) throws NoSuchGroupException {
    final AccountGroup group = groupCache.get(groupId);
    if (group == null) {
        throw new NoSuchGroupException(groupId);
    }
    return new GroupControl(user.get(), group);
}
#end_block

#method_before
public GroupControl controlFor(final AccountGroup.UUID groupId) throws NoSuchGroupException {
    final ExtGroup group = groupBackend.get(groupId);
    if (group == null) {
        throw new NoSuchGroupException(groupId);
    }
    return new GroupControl(groupCache, user.get(), group);
}
#method_after
public GroupControl controlFor(final AccountGroup.UUID groupId) throws NoSuchGroupException {
    final GroupDescription.Basic group = groupBackend.get(groupId);
    if (group == null) {
        throw new NoSuchGroupException(groupId);
    }
    return new GroupControl(user.get(), group);
}
#end_block

#method_before
public GroupControl controlFor(final AccountGroup group) {
    return new GroupControl(groupCache, user.get(), group);
}
#method_after
public GroupControl controlFor(final AccountGroup group) {
    return new GroupControl(user.get(), group);
}
#end_block

#method_before
public boolean isOwner() {
    if (!group.hasOwnerGroupId()) {
        isOwner = false;
    } else if (isOwner == null) {
        AccountGroup g = groupCache.get(group.getOwnerGroupId());
        AccountGroup.UUID ownerUUID = g != null ? g.getGroupUUID() : null;
        isOwner = getCurrentUser().getEffectiveGroups().contains(ownerUUID) || getCurrentUser().getCapabilities().canAdministrateServer();
    }
    return isOwner;
}
#method_after
public boolean isOwner() {
    AccountGroup accountGroup = GroupDescriptions.toAccountGroup(group);
    if (accountGroup == null) {
        isOwner = false;
    } else if (isOwner == null) {
        AccountGroup.UUID ownerUUID = accountGroup.getOwnerGroupUUID();
        isOwner = getCurrentUser().getEffectiveGroups().contains(ownerUUID) || getCurrentUser().getCapabilities().canAdministrateServer();
    }
    return isOwner;
}
#end_block

#method_before
@Override
protected void configure() {
    switch(loginType) {
        case HTTP_LDAP:
        case LDAP:
        case LDAP_BIND:
        case CLIENT_SSL_CERT_LDAP:
            install(new LdapModule());
            break;
        case CUSTOM_EXTENSION:
            break;
        default:
            bind(Realm.class).to(DefaultRealm.class);
            Multibinder.newSetBinder(binder(), GroupBackend.class).addBinding().to(InternalGroupBackend.class);
            break;
    }
    bind(ApprovalTypes.class).toProvider(ApprovalTypesProvider.class).in(SINGLETON);
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(new AccessControlModule());
    install(new GitModule());
    install(new PrologModule());
    factory(AccountInfoCacheFactory.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    factory(IncludingGroupMembership.Factory.class);
    bind(InternalGroupBackend.class).in(SINGLETON);
    bind(GroupBackend.class).to(UniversalGroupBackend.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    factory(SecureCredentialsProvider.Factory.class);
    factory(PushAllProjectsOp.Factory.class);
    bind(ChangeMergeQueue.class).in(SINGLETON);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    factory(ReloadSubmitQueueOp.Factory.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    factory(FunctionState.Factory.class);
    factory(ReplicationUser.Factory.class);
}
#method_after
@Override
protected void configure() {
    switch(loginType) {
        case HTTP_LDAP:
        case LDAP:
        case LDAP_BIND:
        case CLIENT_SSL_CERT_LDAP:
            install(new LdapModule());
            break;
        case CUSTOM_EXTENSION:
            break;
        default:
            bind(Realm.class).to(DefaultRealm.class);
            break;
    }
    bind(ApprovalTypes.class).toProvider(ApprovalTypesProvider.class).in(SINGLETON);
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(new AccessControlModule());
    install(new GitModule());
    install(new PrologModule());
    install(ThreadLocalRequestContext.module());
    factory(AccountInfoCacheFactory.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(InternalUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    factory(IncludingGroupMembership.Factory.class);
    bind(InternalGroupBackend.class).in(SINGLETON);
    bind(GroupBackend.class).to(UniversalGroupBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), GroupBackend.class);
    DynamicSet.bind(binder(), GroupBackend.class).to(InternalGroupBackend.class);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(ChangeMergeQueue.class).in(SINGLETON);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    factory(ReloadSubmitQueueOp.Factory.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    factory(FunctionState.Factory.class);
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    bind(AnonymousUser.class);
}
#end_block

#method_before
@Override
public void suggestChangeReviewer(final Change.Id change, final String query, final int limit, final AsyncCallback<List<ReviewerInfo>> callback) {
    run(callback, new Action<List<ReviewerInfo>>() {

        public List<ReviewerInfo> run(final ReviewDb db) throws OrmException {
            final ChangeControl changeControl;
            try {
                changeControl = changeControlFactory.controlFor(change);
            } catch (NoSuchChangeException e) {
                return Collections.emptyList();
            }
            VisibilityControl visibilityControl = new VisibilityControl() {

                @Override
                public boolean isVisible(Account account) throws OrmException {
                    IdentifiedUser who = identifiedUserFactory.create(reviewDbProvider, account.getId());
                    return changeControl.forUser(who).isVisible(reviewDbProvider.get());
                }
            };
            final List<AccountInfo> suggestedAccounts = suggestAccount(db, query, Boolean.TRUE, limit, visibilityControl);
            final List<ReviewerInfo> reviewer = new ArrayList<ReviewerInfo>(suggestedAccounts.size());
            for (final AccountInfo a : suggestedAccounts) {
                reviewer.add(new ReviewerInfo(a));
            }
            final List<GroupReference> suggestedAccountGroups = suggestAccountGroup(query, limit);
            for (final GroupReference g : suggestedAccountGroups) {
                if (suggestGroupAsReviewer(changeControl.getProject().getNameKey(), g)) {
                    reviewer.add(new ReviewerInfo(g));
                }
            }
            Collections.sort(reviewer);
            if (reviewer.size() <= limit) {
                return reviewer;
            } else {
                return reviewer.subList(0, limit);
            }
        }
    });
}
#method_after
@Override
public void suggestChangeReviewer(final Change.Id change, final String query, final int limit, final AsyncCallback<List<ReviewerInfo>> callback) {
    run(callback, new Action<List<ReviewerInfo>>() {

        public List<ReviewerInfo> run(final ReviewDb db) throws OrmException {
            final ChangeControl changeControl;
            try {
                changeControl = changeControlFactory.controlFor(change);
            } catch (NoSuchChangeException e) {
                return Collections.emptyList();
            }
            VisibilityControl visibilityControl = new VisibilityControl() {

                @Override
                public boolean isVisible(Account account) throws OrmException {
                    IdentifiedUser who = identifiedUserFactory.create(reviewDbProvider, account.getId());
                    // to drafts
                    return changeControl.forUser(who).isRefVisible();
                }
            };
            final List<AccountInfo> suggestedAccounts = suggestAccount(db, query, Boolean.TRUE, limit, visibilityControl);
            final List<ReviewerInfo> reviewer = new ArrayList<ReviewerInfo>(suggestedAccounts.size());
            for (final AccountInfo a : suggestedAccounts) {
                reviewer.add(new ReviewerInfo(a));
            }
            final List<GroupReference> suggestedAccountGroups = suggestAccountGroup(query, limit);
            for (final GroupReference g : suggestedAccountGroups) {
                if (suggestGroupAsReviewer(changeControl.getProject().getNameKey(), g)) {
                    reviewer.add(new ReviewerInfo(g));
                }
            }
            Collections.sort(reviewer);
            if (reviewer.size() <= limit) {
                return reviewer;
            } else {
                return reviewer.subList(0, limit);
            }
        }
    });
}
#end_block

#method_before
private GroupReference groupReference(LdapQuery.Result res) throws NamingException {
    String name = Objects.firstNonNull(res.get("cn"), res.getDN());
    return new GroupReference(new AccountGroup.UUID(LDAP_UUID + res.getDN()), LDAP_NAME + name);
}
#method_after
private static GroupReference groupReference(LdapQuery.Result res) throws NamingException {
    return new GroupReference(new AccountGroup.UUID(LDAP_UUID + res.getDN()), LDAP_NAME + cnFor(res.getDN()));
}
#end_block

#method_before
@Override
public boolean handles(AccountGroup.UUID uuid) {
    return internalBackend.handles(uuid) || isLdapUUID(uuid);
}
#method_after
@Override
public boolean handles(AccountGroup.UUID uuid) {
    return isLdapUUID(uuid);
}
#end_block

#method_before
@Override
public ExtGroup get(AccountGroup.UUID uuid) {
    if (isLdapUUID(uuid)) {
        // First see if there is a legacy LDAP UUID stored in the database.
        AccountGroup.ExternalNameKey ext = externalNameKey(uuid);
        for (AccountGroup g : groupCache.get(ext)) {
            if (g.getGroupUUID() != null) {
                return ExtGroups.forAccountGroup(g);
            }
        }
        // Otherwise generate a GroupReference if the name is valid.
        return lookup(ext);
    } else {
        return internalBackend.get(uuid);
    }
}
#method_after
@Override
public GroupDescription.Basic get(final AccountGroup.UUID uuid) {
    if (!handles(uuid)) {
        return null;
    }
    String groupDn = uuid.get().substring(LDAP_UUID.length());
    CurrentUser user = userProvider.get();
    if (!(user instanceof IdentifiedUser) || !membershipsOf((IdentifiedUser) user).contains(uuid)) {
        try {
            if (!existsCache.get(groupDn)) {
                return null;
            }
        } catch (ExecutionException e) {
            log.warn(String.format("Cannot lookup group %s in LDAP", groupDn), e);
            return null;
        }
    }
    final String name = LDAP_NAME + cnFor(groupDn);
    return new GroupDescription.Basic() {

        @Override
        public AccountGroup.UUID getGroupUUID() {
            return uuid;
        }

        @Override
        public String getName() {
            return name;
        }

        @Override
        public boolean isVisibleToAll() {
            return true;
        }
    };
}
#end_block

#method_before
@Override
public Collection<GroupReference> suggest(String name) {
    AccountGroup.UUID uuid = new AccountGroup.UUID(name);
    if (isLdapUUID(uuid)) {
        ExtGroup g = get(uuid);
        if (g == null) {
            return Collections.emptySet();
        }
        return Collections.singleton(GroupReference.forGroup(g));
    } else if (name.startsWith(LDAP_NAME)) {
        return suggestLdap(name.substring(LDAP_NAME.length()));
    }
    return internalBackend.suggest(name);
}
#method_after
@Override
public Collection<GroupReference> suggest(String name) {
    AccountGroup.UUID uuid = new AccountGroup.UUID(name);
    if (isLdapUUID(uuid)) {
        GroupDescription.Basic g = get(uuid);
        if (g == null) {
            return Collections.emptySet();
        }
        return Collections.singleton(GroupReference.forGroup(g));
    } else if (name.startsWith(LDAP_NAME)) {
        return suggestLdap(name.substring(LDAP_NAME.length()));
    }
    return Collections.emptySet();
}
#end_block

#method_before
@Override
public GroupMembership membershipsOf(AccountState user) {
    // TODO(cranger): update to support ldapgroup UUID
    return groupMembershipFactory.create(Iterables.concat(membershipCache.get(findId(user.getExternalIds())), user.getInternalGroups()));
}
#method_after
@Override
public GroupMembership membershipsOf(IdentifiedUser user) {
    String id = findId(user.state().getExternalIds());
    if (id == null) {
        return GroupMembership.EMPTY;
    }
    try {
        return new ListGroupMembership(membershipCache.get(id));
    } catch (ExecutionException e) {
        log.warn(String.format("Cannot lookup membershipsOf %s in LDAP", id), e);
        return GroupMembership.EMPTY;
    }
}
#end_block

#method_before
private Set<GroupReference> suggestLdap(String name) {
    Set<GroupReference> out = Sets.newTreeSet(GROUP_REF_NAME_COMPARATOR);
    try {
        final DirContext ctx = helper.open();
        try {
            final LdapSchema schema = helper.getSchema(ctx);
            final ParameterizedString filter = ParameterizedString.asis(schema.groupPattern.replace(GROUPNAME, name).toString());
            final Set<String> returnAttrs = Collections.<String>emptySet();
            final Map<String, String> params = Collections.emptyMap();
            for (String groupBase : schema.groupBases) {
                LdapQuery query = new LdapQuery(groupBase, schema.groupScope, filter, returnAttrs);
                for (LdapQuery.Result res : query.query(ctx, params)) {
                    out.add(groupReference(res));
                }
            }
        } finally {
            try {
                ctx.close();
            } catch (NamingException e) {
                log.warn("Cannot close LDAP query handle", e);
            }
        }
    } catch (NamingException e) {
        log.warn("Cannot query LDAP for groups matching requested name", e);
    }
    return out;
}
#method_after
private Set<GroupReference> suggestLdap(String name) {
    if (name.isEmpty()) {
        return Collections.emptySet();
    }
    Set<GroupReference> out = Sets.newTreeSet(GROUP_REF_NAME_COMPARATOR);
    try {
        DirContext ctx = helper.open();
        try {
            // Do exact lookups until there are at least 3 characters.
            name = Rdn.escapeValue(name) + ((name.length() >= 3) ? "*" : "");
            LdapSchema schema = helper.getSchema(ctx);
            ParameterizedString filter = ParameterizedString.asis(schema.groupPattern.replace(GROUPNAME, name).toString());
            Set<String> returnAttrs = Collections.<String>emptySet();
            Map<String, String> params = Collections.emptyMap();
            for (String groupBase : schema.groupBases) {
                LdapQuery query = new LdapQuery(groupBase, schema.groupScope, filter, returnAttrs);
                for (LdapQuery.Result res : query.query(ctx, params)) {
                    out.add(groupReference(res));
                }
            }
        } finally {
            try {
                ctx.close();
            } catch (NamingException e) {
                log.warn("Cannot close LDAP query handle", e);
            }
        }
    } catch (NamingException e) {
        log.warn("Cannot query LDAP for groups matching requested name", e);
    }
    return out;
}
#end_block

#method_before
@Nullable
public static GroupReference findBestSuggestion(GroupBackend groupBackend, String name) {
    Collection<GroupReference> refs = groupBackend.suggest(name);
    if (refs.size() == 1) {
        return refs.iterator().next();
    }
    for (GroupReference ref : refs) {
        if (ref.getName().equals(name) || ref.getUUID().get().equals(name)) {
            return ref;
        }
    }
    return null;
}
#method_after
@Nullable
public static GroupReference findBestSuggestion(GroupBackend groupBackend, String name) {
    Collection<GroupReference> refs = groupBackend.suggest(name);
    if (refs.size() == 1) {
        return Iterables.getOnlyElement(refs);
    }
    for (GroupReference ref : refs) {
        if (isExactSuggestion(ref, name)) {
            return ref;
        }
    }
    return null;
}
#end_block

#method_before
@Override
public boolean handles(AccountGroup.UUID uuid) {
    return uuid.get().startsWith("global:") || uuid.get().indexOf(':') < 0;
}
#method_after
@Override
public boolean handles(AccountGroup.UUID uuid) {
    return uuid.get().startsWith("global:") || uuid.get().matches("[0-9a-f]{40}");
}
#end_block

#method_before
@Override
public ExtGroup get(AccountGroup.UUID uuid) {
    checkArgument(handles(uuid), "internal groups system does not handle UUID: %s", uuid);
    AccountGroup g = groupCache.get(uuid);
    if (g == null) {
        return null;
    }
    return ExtGroups.forAccountGroup(g);
}
#method_after
@Override
public GroupDescription.Internal get(AccountGroup.UUID uuid) {
    if (!handles(uuid)) {
        return null;
    }
    AccountGroup g = groupCache.get(uuid);
    if (g == null) {
        return null;
    }
    return GroupDescriptions.forAccountGroup(g);
}
#end_block

#method_before
@Override
public Collection<GroupReference> suggest(final String name) {
    Iterable<AccountGroup> filtered = Iterables.filter(groupCache.all(), new Predicate<AccountGroup>() {

        @Override
        public boolean apply(AccountGroup group) {
            return group.getName().startsWith(name);
        }
    });
    return Lists.newArrayList(Iterables.transform(filtered, ACT_GROUP_TO_GROUP_REF));
}
#method_after
@Override
public Collection<GroupReference> suggest(final String name) {
    Iterable<AccountGroup> filtered = Iterables.filter(groupCache.all(), new Predicate<AccountGroup>() {

        @Override
        public boolean apply(AccountGroup group) {
            // startsWithIgnoreCase
            return group.getName().regionMatches(true, 0, name, 0, name.length());
        }
    });
    return Lists.newArrayList(Iterables.transform(filtered, ACT_GROUP_TO_GROUP_REF));
}
#end_block

#method_before
@Override
public GroupMembership membershipsOf(AccountState user) {
    return groupMembershipFactory.create(user.getInternalGroups());
}
#method_after
@Override
public GroupMembership membershipsOf(IdentifiedUser user) {
    return groupMembershipFactory.create(user.state().getInternalGroups());
}
#end_block

#method_before
@Override
protected void configure() {
    final TypeLiteral<Cache<String, Set<AccountGroup.UUID>>> groups = new TypeLiteral<Cache<String, Set<AccountGroup.UUID>>>() {
    };
    // 
    core(groups, GROUP_CACHE).maxAge(1, HOURS).populateWith(LdapRealm.MemberLoader.class);
    final TypeLiteral<Cache<String, Account.Id>> usernames = new TypeLiteral<Cache<String, Account.Id>>() {
    };
    // 
    core(usernames, USERNAME_CACHE).populateWith(LdapRealm.UserLoader.class);
    bind(Realm.class).to(LdapRealm.class).in(Scopes.SINGLETON);
    bind(Helper.class);
    Multibinder.newSetBinder(binder(), GroupBackend.class).addBinding().to(LdapGroupBackend.class);
}
#method_after
@Override
protected void configure() {
    cache(GROUP_CACHE, String.class, new TypeLiteral<Set<AccountGroup.UUID>>() {
    }).expireAfterWrite(1, HOURS).loader(LdapRealm.MemberLoader.class);
    cache(USERNAME_CACHE, String.class, new TypeLiteral<Optional<Account.Id>>() {
    }).loader(LdapRealm.UserLoader.class);
    cache(GROUP_EXIST_CACHE, String.class, new TypeLiteral<Boolean>() {
    }).expireAfterWrite(1, HOURS).loader(LdapRealm.ExistenceLoader.class);
    bind(Realm.class).to(LdapRealm.class).in(Scopes.SINGLETON);
    bind(Helper.class);
    DynamicSet.bind(binder(), GroupBackend.class).to(LdapGroupBackend.class);
}
#end_block

#method_before
@Override
public ProjectAccess call() throws NoSuchProjectException, IOException, ConfigInvalidException {
    pc = open();
    // Load the current configuration from the repository, ensuring its the most
    // recent version available. If it differs from what was in the project
    // state, force a cache flush now.
    // 
    ProjectConfig config;
    MetaDataUpdate md = metaDataUpdateFactory.create(projectName);
    try {
        config = ProjectConfig.read(md);
        if (config.updateGroupNames(groupBackend)) {
            md.setMessage("Update group names\n");
            if (config.commit(md)) {
                projectCache.evict(config.getProject());
                pc = open();
            }
        } else if (config.getRevision() != null && !config.getRevision().equals(pc.getProjectState().getConfig().getRevision())) {
            projectCache.evict(config.getProject());
            pc = open();
        }
    } finally {
        md.close();
    }
    List<AccessSection> local = new ArrayList<AccessSection>();
    Set<String> ownerOf = new HashSet<String>();
    Map<AccountGroup.UUID, Boolean> visibleGroups = new HashMap<AccountGroup.UUID, Boolean>();
    for (AccessSection section : config.getAccessSections()) {
        String name = section.getName();
        if (AccessSection.GLOBAL_CAPABILITIES.equals(name)) {
            if (pc.isOwner()) {
                local.add(section);
                ownerOf.add(name);
            }
        } else if (RefConfigSection.isValid(name)) {
            RefControl rc = pc.controlForRef(name);
            if (rc.isOwner()) {
                local.add(section);
                ownerOf.add(name);
            } else if (rc.isVisible()) {
                // Filter the section to only add rules describing groups that
                // are visible to the current-user. This includes any group the
                // user is a member of, as well as groups they own or that
                // are visible to all users.
                AccessSection dst = null;
                for (Permission srcPerm : section.getPermissions()) {
                    Permission dstPerm = null;
                    for (PermissionRule srcRule : srcPerm.getRules()) {
                        AccountGroup.UUID group = srcRule.getGroup().getUUID();
                        if (group == null) {
                            continue;
                        }
                        Boolean canSeeGroup = visibleGroups.get(group);
                        if (canSeeGroup == null) {
                            try {
                                canSeeGroup = groupControlFactory.controlFor(group).isVisible();
                            } catch (NoSuchGroupException e) {
                                canSeeGroup = Boolean.FALSE;
                            }
                            visibleGroups.put(group, canSeeGroup);
                        }
                        if (canSeeGroup) {
                            if (dstPerm == null) {
                                if (dst == null) {
                                    dst = new AccessSection(name);
                                    local.add(dst);
                                }
                                dstPerm = dst.getPermission(srcPerm.getName(), true);
                            }
                            dstPerm.add(srcRule);
                        }
                    }
                }
            }
        }
    }
    if (ownerOf.isEmpty() && pc.isOwnerAnyRef()) {
        // Special case: If the section list is empty, this project has no current
        // access control information. Rely on what ProjectControl determines
        // is ownership, which probably means falling back to site administrators.
        ownerOf.add(AccessSection.ALL);
    }
    final ProjectAccess detail = new ProjectAccess();
    detail.setProjectName(projectName);
    if (config.getRevision() != null) {
        detail.setRevision(config.getRevision().name());
    }
    detail.setInheritsFrom(config.getProject().getParent(allProjectsName));
    if (projectName.equals(allProjectsName)) {
        if (pc.isOwner()) {
            ownerOf.add(AccessSection.GLOBAL_CAPABILITIES);
        }
    }
    detail.setLocal(local);
    detail.setOwnerOf(ownerOf);
    detail.setConfigVisible(pc.isOwner() || pc.controlForRef(GitRepositoryManager.REF_CONFIG).isVisible());
    return detail;
}
#method_after
@Override
public ProjectAccess call() throws NoSuchProjectException, IOException, ConfigInvalidException {
    pc = open();
    // Load the current configuration from the repository, ensuring its the most
    // recent version available. If it differs from what was in the project
    // state, force a cache flush now.
    // 
    ProjectConfig config;
    MetaDataUpdate md = metaDataUpdateFactory.create(projectName);
    try {
        config = ProjectConfig.read(md);
        if (config.updateGroupNames(groupBackend)) {
            md.setMessage("Update group names\n");
            if (config.commit(md)) {
                projectCache.evict(config.getProject());
                pc = open();
            }
        } else if (config.getRevision() != null && !config.getRevision().equals(pc.getProjectState().getConfig().getRevision())) {
            projectCache.evict(config.getProject());
            pc = open();
        }
    } finally {
        md.close();
    }
    final RefControl metaConfigControl = pc.controlForRef(GitRepositoryManager.REF_CONFIG);
    List<AccessSection> local = new ArrayList<AccessSection>();
    Set<String> ownerOf = new HashSet<String>();
    Map<AccountGroup.UUID, Boolean> visibleGroups = new HashMap<AccountGroup.UUID, Boolean>();
    for (AccessSection section : config.getAccessSections()) {
        String name = section.getName();
        if (AccessSection.GLOBAL_CAPABILITIES.equals(name)) {
            if (pc.isOwner()) {
                local.add(section);
                ownerOf.add(name);
            }
        } else if (RefConfigSection.isValid(name)) {
            RefControl rc = pc.controlForRef(name);
            if (rc.isOwner() || metaConfigControl.isVisible()) {
                local.add(section);
                ownerOf.add(name);
            } else if (rc.isVisible()) {
                // Filter the section to only add rules describing groups that
                // are visible to the current-user. This includes any group the
                // user is a member of, as well as groups they own or that
                // are visible to all users.
                AccessSection dst = null;
                for (Permission srcPerm : section.getPermissions()) {
                    Permission dstPerm = null;
                    for (PermissionRule srcRule : srcPerm.getRules()) {
                        AccountGroup.UUID group = srcRule.getGroup().getUUID();
                        if (group == null) {
                            continue;
                        }
                        Boolean canSeeGroup = visibleGroups.get(group);
                        if (canSeeGroup == null) {
                            try {
                                canSeeGroup = groupControlFactory.controlFor(group).isVisible();
                            } catch (NoSuchGroupException e) {
                                canSeeGroup = Boolean.FALSE;
                            }
                            visibleGroups.put(group, canSeeGroup);
                        }
                        if (canSeeGroup) {
                            if (dstPerm == null) {
                                if (dst == null) {
                                    dst = new AccessSection(name);
                                    local.add(dst);
                                }
                                dstPerm = dst.getPermission(srcPerm.getName(), true);
                            }
                            dstPerm.add(srcRule);
                        }
                    }
                }
            }
        }
    }
    if (ownerOf.isEmpty() && pc.isOwnerAnyRef()) {
        // Special case: If the section list is empty, this project has no current
        // access control information. Rely on what ProjectControl determines
        // is ownership, which probably means falling back to site administrators.
        ownerOf.add(AccessSection.ALL);
    }
    final ProjectAccess detail = new ProjectAccess();
    detail.setProjectName(projectName);
    if (config.getRevision() != null) {
        detail.setRevision(config.getRevision().name());
    }
    detail.setInheritsFrom(config.getProject().getParent(allProjectsName));
    if (projectName.equals(allProjectsName)) {
        if (pc.isOwner()) {
            ownerOf.add(AccessSection.GLOBAL_CAPABILITIES);
        }
    }
    detail.setLocal(local);
    detail.setOwnerOf(ownerOf);
    detail.setConfigVisible(pc.isOwner() || metaConfigControl.isVisible());
    return detail;
}
#end_block

#method_before
public void createProject() throws ProjectCreationFailedException {
    validateParameters();
    final Project.NameKey nameKey = createProjectArgs.getProject();
    try {
        final String head = createProjectArgs.permissionsOnly ? GitRepositoryManager.REF_CONFIG : createProjectArgs.branch;
        final Repository repo = repoManager.createRepository(nameKey);
        try {
            replication.replicateNewProject(nameKey, head);
            final RefUpdate u = repo.updateRef(Constants.HEAD);
            u.disableRefLog();
            u.link(head);
            createProjectConfig();
            if (!createProjectArgs.permissionsOnly && createProjectArgs.createEmptyCommit) {
                createEmptyCommit(repo, nameKey, createProjectArgs.branch);
            }
        } finally {
            repo.close();
        }
    } catch (RepositoryCaseMismatchException e) {
        throw new ProjectCreationFailedException("Cannot create " + nameKey.get() + " because the name is already occupied by another project." + " The other project has the same name, only spelled in a" + " different case.", e);
    } catch (RepositoryNotFoundException badName) {
        throw new ProjectCreationFailedException("Cannot create " + nameKey, badName);
    } catch (IllegalStateException err) {
        try {
            final Repository repo = repoManager.openRepository(nameKey);
            try {
                if (repo.getObjectDatabase().exists()) {
                    throw new ProjectCreationFailedException("project \"" + nameKey + "\" exists");
                }
            } finally {
                repo.close();
            }
        } catch (RepositoryNotFoundException doesNotExist) {
            final String msg = "Cannot create " + nameKey;
            log.error(msg, err);
            throw new ProjectCreationFailedException(msg, err);
        }
    } catch (Exception e) {
        final String msg = "Cannot create " + nameKey;
        log.error(msg, e);
        throw new ProjectCreationFailedException(msg, e);
    }
}
#method_after
public void createProject() throws ProjectCreationFailedException {
    validateParameters();
    final Project.NameKey nameKey = createProjectArgs.getProject();
    try {
        final String head = createProjectArgs.permissionsOnly ? GitRepositoryManager.REF_CONFIG : createProjectArgs.branch.get(0);
        final Repository repo = repoManager.createRepository(nameKey);
        try {
            NewProjectCreatedListener.Event event = new NewProjectCreatedListener.Event() {

                @Override
                public String getProjectName() {
                    return nameKey.get();
                }

                @Override
                public String getHeadName() {
                    return head;
                }
            };
            for (NewProjectCreatedListener l : createdListener) {
                l.onNewProjectCreated(event);
            }
            final RefUpdate u = repo.updateRef(Constants.HEAD);
            u.disableRefLog();
            u.link(head);
            createProjectConfig();
            if (!createProjectArgs.permissionsOnly && createProjectArgs.createEmptyCommit) {
                createEmptyCommits(repo, nameKey, createProjectArgs.branch);
            }
        } finally {
            repo.close();
        }
    } catch (RepositoryCaseMismatchException e) {
        throw new ProjectCreationFailedException("Cannot create " + nameKey.get() + " because the name is already occupied by another project." + " The other project has the same name, only spelled in a" + " different case.", e);
    } catch (RepositoryNotFoundException badName) {
        throw new ProjectCreationFailedException("Cannot create " + nameKey, badName);
    } catch (IllegalStateException err) {
        try {
            final Repository repo = repoManager.openRepository(nameKey);
            try {
                if (repo.getObjectDatabase().exists()) {
                    throw new ProjectCreationFailedException("project \"" + nameKey + "\" exists");
                }
            } finally {
                repo.close();
            }
        } catch (IOException ioErr) {
            final String msg = "Cannot create " + nameKey;
            log.error(msg, err);
            throw new ProjectCreationFailedException(msg, ioErr);
        }
    } catch (Exception e) {
        final String msg = "Cannot create " + nameKey;
        log.error(msg, e);
        throw new ProjectCreationFailedException(msg, e);
    }
}
#end_block

#method_before
private void createProjectConfig() throws IOException, ConfigInvalidException {
    final MetaDataUpdate md = metaDataUpdateFactory.create(createProjectArgs.getProject());
    try {
        final ProjectConfig config = ProjectConfig.read(md);
        config.load(md);
        Project newProject = config.getProject();
        newProject.setDescription(createProjectArgs.projectDescription);
        newProject.setSubmitType(createProjectArgs.submitType);
        newProject.setUseContributorAgreements(createProjectArgs.contributorAgreements);
        newProject.setUseSignedOffBy(createProjectArgs.signedOffBy);
        newProject.setUseContentMerge(createProjectArgs.contentMerge);
        newProject.setRequireChangeID(createProjectArgs.changeIdRequired);
        if (createProjectArgs.newParent != null) {
            newProject.setParentName(createProjectArgs.newParent.getProject().getNameKey());
        }
        if (!createProjectArgs.ownerIds.isEmpty()) {
            final AccessSection all = config.getAccessSection(AccessSection.ALL, true);
            for (AccountGroup.UUID ownerId : createProjectArgs.ownerIds) {
                ExtGroup g = groupBackend.get(ownerId);
                if (g != null) {
                    GroupReference group = config.resolve(GroupReference.forGroup(g));
                    all.getPermission(Permission.OWNER, true).add(new PermissionRule(group));
                }
            }
        }
        md.setMessage("Created project\n");
        if (!config.commit(md)) {
            throw new IOException("Cannot create " + createProjectArgs.getProjectName());
        }
    } finally {
        md.close();
    }
    projectCache.onCreateProject(createProjectArgs.getProject());
    repoManager.setProjectDescription(createProjectArgs.getProject(), createProjectArgs.projectDescription);
    replication.scheduleUpdate(createProjectArgs.getProject(), GitRepositoryManager.REF_CONFIG);
}
#method_after
private void createProjectConfig() throws IOException, ConfigInvalidException {
    final MetaDataUpdate md = metaDataUpdateFactory.create(createProjectArgs.getProject());
    try {
        final ProjectConfig config = ProjectConfig.read(md);
        config.load(md);
        Project newProject = config.getProject();
        newProject.setDescription(createProjectArgs.projectDescription);
        newProject.setSubmitType(createProjectArgs.submitType);
        newProject.setUseContributorAgreements(createProjectArgs.contributorAgreements);
        newProject.setUseSignedOffBy(createProjectArgs.signedOffBy);
        newProject.setUseContentMerge(createProjectArgs.contentMerge);
        newProject.setRequireChangeID(createProjectArgs.changeIdRequired);
        if (createProjectArgs.newParent != null) {
            newProject.setParentName(createProjectArgs.newParent.getProject().getNameKey());
        }
        if (!createProjectArgs.ownerIds.isEmpty()) {
            final AccessSection all = config.getAccessSection(AccessSection.ALL, true);
            for (AccountGroup.UUID ownerId : createProjectArgs.ownerIds) {
                GroupDescription.Basic g = groupBackend.get(ownerId);
                if (g != null) {
                    GroupReference group = config.resolve(GroupReference.forGroup(g));
                    all.getPermission(Permission.OWNER, true).add(new PermissionRule(group));
                }
            }
        }
        md.setMessage("Created project\n");
        if (!config.commit(md)) {
            throw new IOException("Cannot create " + createProjectArgs.getProjectName());
        }
    } finally {
        md.close();
    }
    projectCache.onCreateProject(createProjectArgs.getProject());
    repoManager.setProjectDescription(createProjectArgs.getProject(), createProjectArgs.projectDescription);
    referenceUpdated.fire(createProjectArgs.getProject(), GitRepositoryManager.REF_CONFIG);
}
#end_block

#method_before
private void validateParameters() throws ProjectCreationFailedException {
    if (createProjectArgs.getProjectName() == null || createProjectArgs.getProjectName().isEmpty()) {
        throw new ProjectCreationFailedException("Project name is required");
    }
    if (createProjectArgs.getProjectName().endsWith(Constants.DOT_GIT_EXT)) {
        createProjectArgs.setProjectName(createProjectArgs.getProjectName().substring(0, createProjectArgs.getProjectName().length() - Constants.DOT_GIT_EXT.length()));
    }
    if (!currentUser.getCapabilities().canCreateProject()) {
        throw new ProjectCreationFailedException(String.format("%s does not have \"Create Project\" capability.", currentUser.getUserName()));
    }
    if (createProjectArgs.ownerIds == null || createProjectArgs.ownerIds.isEmpty()) {
        createProjectArgs.ownerIds = new ArrayList<AccountGroup.UUID>(projectOwnerGroups);
    }
    while (createProjectArgs.branch.startsWith("/")) {
        createProjectArgs.branch = createProjectArgs.branch.substring(1);
    }
    if (!createProjectArgs.branch.startsWith(Constants.R_HEADS)) {
        createProjectArgs.branch = Constants.R_HEADS + createProjectArgs.branch;
    }
    if (!Repository.isValidRefName(createProjectArgs.branch)) {
        throw new ProjectCreationFailedException(String.format("Branch \"%s\" is not a valid name.", createProjectArgs.branch));
    }
}
#method_after
private void validateParameters() throws ProjectCreationFailedException {
    if (createProjectArgs.getProjectName() == null || createProjectArgs.getProjectName().isEmpty()) {
        throw new ProjectCreationFailedException("Project name is required");
    }
    if (createProjectArgs.getProjectName().endsWith(Constants.DOT_GIT_EXT)) {
        createProjectArgs.setProjectName(createProjectArgs.getProjectName().substring(0, createProjectArgs.getProjectName().length() - Constants.DOT_GIT_EXT.length()));
    }
    if (!currentUser.getCapabilities().canCreateProject()) {
        throw new ProjectCreationFailedException(String.format("%s does not have \"Create Project\" capability.", currentUser.getUserName()));
    }
    if (createProjectArgs.ownerIds == null || createProjectArgs.ownerIds.isEmpty()) {
        createProjectArgs.ownerIds = new ArrayList<AccountGroup.UUID>(projectOwnerGroups);
    }
    List<String> transformedBranches = new ArrayList<String>();
    if (createProjectArgs.branch == null || createProjectArgs.branch.isEmpty()) {
        createProjectArgs.branch = Collections.singletonList(Constants.MASTER);
    }
    for (String branch : createProjectArgs.branch) {
        while (branch.startsWith("/")) {
            branch = branch.substring(1);
        }
        if (!branch.startsWith(Constants.R_HEADS)) {
            branch = Constants.R_HEADS + branch;
        }
        if (!Repository.isValidRefName(branch)) {
            throw new ProjectCreationFailedException(String.format("Branch \"%s\" is not a valid name.", branch));
        }
        if (!transformedBranches.contains(branch)) {
            transformedBranches.add(branch);
        }
    }
    createProjectArgs.branch = transformedBranches;
}
#end_block

#method_before
private AccountState state() {
    if (state == null) {
        state = accountCache.get(getAccountId());
    }
    return state;
}
#method_after
public AccountState state() {
    if (state == null) {
        state = accountCache.get(getAccountId());
    }
    return state;
}
#end_block

#method_before
@Override
public GroupMembership getEffectiveGroups() {
    if (effectiveGroups == null) {
        if (authConfig.isIdentityTrustable(state().getExternalIds())) {
            effectiveGroups = groupBackend.membershipsOf(state());
        } else {
            effectiveGroups = registeredGroups;
        }
    }
    return effectiveGroups;
}
#method_after
@Override
public GroupMembership getEffectiveGroups() {
    if (effectiveGroups == null) {
        if (authConfig.isIdentityTrustable(state().getExternalIds())) {
            effectiveGroups = groupBackend.membershipsOf(this);
        } else {
            effectiveGroups = registeredGroups;
        }
    }
    return effectiveGroups;
}
#end_block

#method_before
@Override
public GroupDetail call() throws OrmException, NoSuchGroupException {
    control = groupControl.validateFor(groupId);
    final AccountGroup group = groupCache.get(groupId);
    final GroupDetail detail = new GroupDetail();
    detail.setGroup(group);
    detail.setOwnerGroup(groupCache.get(group.getOwnerGroupId()));
    switch(group.getType()) {
        case INTERNAL:
            detail.setMembers(loadMembers());
            detail.setIncludes(loadIncludes());
            break;
    }
    detail.setAccounts(aic.create());
    detail.setCanModify(control.isOwner());
    detail.setGroups(gic.create());
    return detail;
}
#method_after
@Override
public GroupDetail call() throws OrmException, NoSuchGroupException {
    control = groupControl.validateFor(groupId);
    final AccountGroup group = groupCache.get(groupId);
    final GroupDetail detail = new GroupDetail();
    detail.setGroup(group);
    GroupDescription.Basic ownerGroup = groupBackend.get(group.getOwnerGroupUUID());
    if (ownerGroup != null) {
        detail.setOwnerGroup(GroupReference.forGroup(ownerGroup));
    }
    switch(group.getType()) {
        case INTERNAL:
            detail.setMembers(loadMembers());
            detail.setIncludes(loadIncludes());
            break;
    }
    detail.setAccounts(aic.create());
    detail.setCanModify(control.isOwner());
    detail.setGroups(gic.create());
    return detail;
}
#end_block

#method_before
public void changeGroupOwner(final AccountGroup.Id groupId, final String newOwnerName, final AsyncCallback<VoidResult> callback) {
    run(callback, new Action<VoidResult>() {

        public VoidResult run(final ReviewDb db) throws OrmException, Failure {
            final AccountGroup group = db.accountGroups().get(groupId);
            assertAmGroupOwner(db, group);
            final AccountGroup owner = groupCache.get(new AccountGroup.NameKey(newOwnerName));
            if (owner == null) {
                throw new Failure(new NoSuchEntityException());
            }
            group.setOwnerGroupId(owner.getId());
            db.accountGroups().update(Collections.singleton(group));
            groupCache.evict(group);
            return VoidResult.INSTANCE;
        }
    });
}
#method_after
public void changeGroupOwner(final AccountGroup.Id groupId, final String newOwnerName, final AsyncCallback<VoidResult> callback) {
    run(callback, new Action<VoidResult>() {

        public VoidResult run(final ReviewDb db) throws OrmException, Failure {
            final AccountGroup group = db.accountGroups().get(groupId);
            assertAmGroupOwner(db, group);
            GroupReference owner = GroupBackends.findExactSuggestion(groupBackend, newOwnerName);
            if (owner == null) {
                throw new Failure(new NoSuchEntityException());
            }
            group.setOwnerGroupUUID(owner.getUUID());
            db.accountGroups().update(Collections.singleton(group));
            groupCache.evict(group);
            return VoidResult.INSTANCE;
        }
    });
}
#end_block

#method_before
public boolean updateGroupNames(GroupBackend groupBackend) {
    boolean dirty = false;
    for (GroupReference ref : groupsByUUID.values()) {
        ExtGroup g = groupBackend.get(ref.getUUID());
        if (g != null && !g.getName().equals(ref.getName())) {
            dirty = true;
            ref.setName(g.getName());
        }
    }
    return dirty;
}
#method_after
public boolean updateGroupNames(GroupBackend groupBackend) {
    boolean dirty = false;
    for (GroupReference ref : groupsByUUID.values()) {
        GroupDescription.Basic g = groupBackend.get(ref.getUUID());
        if (g != null && !g.getName().equals(ref.getName())) {
            dirty = true;
            ref.setName(g.getName());
        }
    }
    return dirty;
}
#end_block

#method_before
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    Map<String, GroupReference> groupsByName = readGroupList();
    rulesId = getObjectId("rules.pl");
    Config rc = readConfig(PROJECT_CONFIG);
    project = new Project(projectName);
    Project p = project;
    p.setDescription(rc.getString(PROJECT, null, KEY_DESCRIPTION));
    if (p.getDescription() == null) {
        p.setDescription("");
    }
    p.setParentName(rc.getString(ACCESS, null, KEY_INHERIT_FROM));
    p.setUseContributorAgreements(getBoolean(rc, RECEIVE, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, false));
    p.setUseSignedOffBy(getBoolean(rc, RECEIVE, KEY_REQUIRE_SIGNED_OFF_BY, false));
    p.setRequireChangeID(getBoolean(rc, RECEIVE, KEY_REQUIRE_CHANGE_ID, false));
    p.setSubmitType(getEnum(rc, SUBMIT, null, KEY_ACTION, defaultSubmitAction));
    p.setUseContentMerge(getBoolean(rc, SUBMIT, KEY_MERGE_CONTENT, false));
    p.setState(getEnum(rc, PROJECT, null, KEY_STATE, defaultStateValue));
    loadAccountsSection(rc, groupsByName);
    loadContributorAgreements(rc, groupsByName);
    loadAccessSections(rc, groupsByName);
}
#method_after
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    Map<String, GroupReference> groupsByName = readGroupList();
    rulesId = getObjectId("rules.pl");
    Config rc = readConfig(PROJECT_CONFIG);
    project = new Project(projectName);
    Project p = project;
    p.setDescription(rc.getString(PROJECT, null, KEY_DESCRIPTION));
    if (p.getDescription() == null) {
        p.setDescription("");
    }
    p.setParentName(rc.getString(ACCESS, null, KEY_INHERIT_FROM));
    p.setUseContributorAgreements(getBoolean(rc, RECEIVE, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, false));
    p.setUseSignedOffBy(getBoolean(rc, RECEIVE, KEY_REQUIRE_SIGNED_OFF_BY, false));
    p.setRequireChangeID(getBoolean(rc, RECEIVE, KEY_REQUIRE_CHANGE_ID, false));
    p.setSubmitType(getEnum(rc, SUBMIT, null, KEY_ACTION, defaultSubmitAction));
    p.setUseContentMerge(getBoolean(rc, SUBMIT, KEY_MERGE_CONTENT, false));
    p.setState(getEnum(rc, PROJECT, null, KEY_STATE, defaultStateValue));
    loadAccountsSection(rc, groupsByName);
    loadContributorAgreements(rc, groupsByName);
    loadAccessSections(rc, groupsByName);
    loadNotifySections(rc, groupsByName);
}
#end_block

#method_before
@Override
protected void onSave(CommitBuilder commit) throws IOException, ConfigInvalidException {
    if (commit.getMessage() == null || "".equals(commit.getMessage())) {
        commit.setMessage("Updated project configuration\n");
    }
    Config rc = readConfig(PROJECT_CONFIG);
    Project p = project;
    if (p.getDescription() != null && !p.getDescription().isEmpty()) {
        rc.setString(PROJECT, null, KEY_DESCRIPTION, p.getDescription());
    } else {
        rc.unset(PROJECT, null, KEY_DESCRIPTION);
    }
    set(rc, ACCESS, null, KEY_INHERIT_FROM, p.getParentName());
    set(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, p.isUseContributorAgreements());
    set(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, p.isUseSignedOffBy());
    set(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, p.isRequireChangeID());
    set(rc, SUBMIT, null, KEY_ACTION, p.getSubmitType(), defaultSubmitAction);
    set(rc, SUBMIT, null, KEY_MERGE_CONTENT, p.isUseContentMerge());
    set(rc, PROJECT, null, KEY_STATE, p.getState(), null);
    Set<AccountGroup.UUID> keepGroups = new HashSet<AccountGroup.UUID>();
    saveAccountsSection(rc, keepGroups);
    saveContributorAgreements(rc, keepGroups);
    saveAccessSections(rc, keepGroups);
    groupsByUUID.keySet().retainAll(keepGroups);
    saveConfig(PROJECT_CONFIG, rc);
    saveGroupList();
}
#method_after
@Override
protected void onSave(CommitBuilder commit) throws IOException, ConfigInvalidException {
    if (commit.getMessage() == null || "".equals(commit.getMessage())) {
        commit.setMessage("Updated project configuration\n");
    }
    Config rc = readConfig(PROJECT_CONFIG);
    Project p = project;
    if (p.getDescription() != null && !p.getDescription().isEmpty()) {
        rc.setString(PROJECT, null, KEY_DESCRIPTION, p.getDescription());
    } else {
        rc.unset(PROJECT, null, KEY_DESCRIPTION);
    }
    set(rc, ACCESS, null, KEY_INHERIT_FROM, p.getParentName());
    set(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, p.isUseContributorAgreements());
    set(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, p.isUseSignedOffBy());
    set(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, p.isRequireChangeID());
    set(rc, SUBMIT, null, KEY_ACTION, p.getSubmitType(), defaultSubmitAction);
    set(rc, SUBMIT, null, KEY_MERGE_CONTENT, p.isUseContentMerge());
    set(rc, PROJECT, null, KEY_STATE, p.getState(), null);
    Set<AccountGroup.UUID> keepGroups = new HashSet<AccountGroup.UUID>();
    saveAccountsSection(rc, keepGroups);
    saveContributorAgreements(rc, keepGroups);
    saveAccessSections(rc, keepGroups);
    saveNotifySections(rc, keepGroups);
    groupsByUUID.keySet().retainAll(keepGroups);
    saveConfig(PROJECT_CONFIG, rc);
    saveGroupList();
}
#end_block

#method_before
@Override
public void onCreateAccount(final AuthRequest who, final Account account) {
    usernameCache.put(who.getLocalUser(), account.getId());
}
#method_after
@Override
public void onCreateAccount(final AuthRequest who, final Account account) {
    usernameCache.put(who.getLocalUser(), Optional.of(account.getId()));
}
#end_block

#method_before
@Override
public Account.Id lookup(final String accountName) {
    return usernameCache.get(accountName);
}
#method_after
@Override
public Account.Id lookup(String accountName) {
    if (Strings.isNullOrEmpty(accountName)) {
        return null;
    }
    try {
        Optional<Account.Id> id = usernameCache.get(accountName);
        return id != null ? id.orNull() : null;
    } catch (ExecutionException e) {
        log.warn(String.format("Cannot lookup account %s in LDAP", accountName), e);
        return null;
    }
}
#end_block

#method_before
public static GroupReference forGroup(ExtGroup group) {
    return new GroupReference(group.getGroupUUID(), group.getName());
}
#method_after
public static GroupReference forGroup(GroupDescription.Basic group) {
    return new GroupReference(group.getGroupUUID(), group.getName());
}
#end_block

#method_before
@Override
protected MergeTip _run(final CodeReviewCommit branchTip, final Collection<CodeReviewCommit> toMerge) throws MergeException {
    MergeTip mergeTip = new MergeTip(branchTip, toMerge);
    List<CodeReviewCommit> sorted = sort(toMerge);
    while (!sorted.isEmpty()) {
        CodeReviewCommit n = sorted.remove(0);
        if (mergeTip.getCurrentTip() == null) {
            // The branch is unborn. Take a fast-forward resolution to
            // create the branch.
            // 
            n.setStatusCode(CommitMergeStatus.CLEAN_MERGE);
            mergeTip.moveTipTo(n, n);
        } else if (n.getParentCount() == 0) {
            // Refuse to merge a root commit into an existing branch,
            // we cannot obtain a delta for the rebase to apply.
            // 
            n.setStatusCode(CommitMergeStatus.CANNOT_REBASE_ROOT);
        } else if (n.getParentCount() == 1) {
            if (args.mergeUtil.canFastForward(args.mergeSorter, mergeTip.getCurrentTip(), args.rw, n)) {
                n.setStatusCode(CommitMergeStatus.CLEAN_MERGE);
                mergeTip.moveTipTo(n, n);
            } else {
                try {
                    PatchSet newPatchSet = rebase(n, mergeTip);
                    List<PatchSetApproval> approvals = Lists.newArrayList();
                    for (PatchSetApproval a : args.approvalsUtil.byPatchSet(args.db, n.getControl(), n.getPatchsetId())) {
                        approvals.add(new PatchSetApproval(newPatchSet.getId(), a));
                    }
                    // rebaseChange.rebase() may already have copied some approvals,
                    // use upsert, not insert, to avoid constraint violation on database
                    args.db.patchSetApprovals().upsert(approvals);
                    CodeReviewCommit newTip = args.rw.parseCommit(ObjectId.fromString(newPatchSet.getRevision().get()));
                    mergeTip.moveTipTo(newTip, newTip);
                    n.change().setCurrentPatchSet(patchSetInfoFactory.get(args.rw, mergeTip.getCurrentTip(), newPatchSet.getId()));
                    mergeTip.getCurrentTip().copyFrom(n);
                    mergeTip.getCurrentTip().setControl(args.changeControlFactory.controlFor(n.change(), args.caller));
                    mergeTip.getCurrentTip().setPatchsetId(newPatchSet.getId());
                    mergeTip.getCurrentTip().setStatusCode(CommitMergeStatus.CLEAN_REBASE);
                    newCommits.put(newPatchSet.getId().getParentKey(), mergeTip.getCurrentTip());
                    setRefLogIdent();
                } catch (MergeConflictException e) {
                    n.setStatusCode(CommitMergeStatus.REBASE_MERGE_CONFLICT);
                    throw new MergeException("Cannot rebase " + n.name(), e);
                } catch (NoSuchChangeException | OrmException | IOException | RestApiException | UpdateException e) {
                    // so it can turn into a 409.
                    throw new MergeException("Cannot rebase " + n.name(), e);
                }
            }
        } else if (n.getParentCount() > 1) {
            // 
            try {
                if (args.rw.isMergedInto(mergeTip.getCurrentTip(), n)) {
                    mergeTip.moveTipTo(n, n);
                } else {
                    PersonIdent myIdent = args.serverIdent.get();
                    mergeTip.moveTipTo(args.mergeUtil.mergeOneCommit(myIdent, myIdent, args.repo, args.rw, args.inserter, args.canMergeFlag, args.destBranch, mergeTip.getCurrentTip(), n), n);
                }
                args.mergeUtil.markCleanMerges(args.rw, args.canMergeFlag, mergeTip.getCurrentTip(), args.alreadyAccepted);
                setRefLogIdent();
            } catch (IOException e) {
                throw new MergeException("Cannot merge " + n.name(), e);
            }
        }
        args.alreadyAccepted.add(mergeTip.getCurrentTip());
    }
    return mergeTip;
}
#method_after
@Override
protected MergeTip _run(final CodeReviewCommit branchTip, final Collection<CodeReviewCommit> toMerge) throws MergeException {
    MergeTip mergeTip = new MergeTip(branchTip, toMerge);
    List<CodeReviewCommit> sorted = sort(toMerge);
    while (!sorted.isEmpty()) {
        CodeReviewCommit n = sorted.remove(0);
        if (mergeTip.getCurrentTip() == null) {
            // The branch is unborn. Take a fast-forward resolution to
            // create the branch.
            // 
            n.setStatusCode(CommitMergeStatus.CLEAN_MERGE);
            mergeTip.moveTipTo(n, n);
        } else if (n.getParentCount() == 0) {
            // Refuse to merge a root commit into an existing branch,
            // we cannot obtain a delta for the rebase to apply.
            // 
            n.setStatusCode(CommitMergeStatus.CANNOT_REBASE_ROOT);
        } else if (n.getParentCount() == 1) {
            if (args.mergeUtil.canFastForward(args.mergeSorter, mergeTip.getCurrentTip(), args.rw, n)) {
                n.setStatusCode(CommitMergeStatus.CLEAN_MERGE);
                mergeTip.moveTipTo(n, n);
            } else {
                try {
                    PatchSet newPatchSet = rebase(n, mergeTip);
                    List<PatchSetApproval> approvals = Lists.newArrayList();
                    for (PatchSetApproval a : args.approvalsUtil.byPatchSet(args.db, n.getControl(), n.getPatchsetId())) {
                        approvals.add(new PatchSetApproval(newPatchSet.getId(), a));
                    }
                    // rebaseChange.rebase() may already have copied some approvals,
                    // use upsert, not insert, to avoid constraint violation on database
                    args.db.patchSetApprovals().upsert(approvals);
                    CodeReviewCommit newTip = args.rw.parseCommit(ObjectId.fromString(newPatchSet.getRevision().get()));
                    mergeTip.moveTipTo(newTip, newTip);
                    n.change().setCurrentPatchSet(patchSetInfoFactory.get(args.rw, mergeTip.getCurrentTip(), newPatchSet.getId()));
                    mergeTip.getCurrentTip().copyFrom(n);
                    mergeTip.getCurrentTip().setControl(args.changeControlFactory.controlFor(n.change(), args.caller));
                    mergeTip.getCurrentTip().setPatchsetId(newPatchSet.getId());
                    mergeTip.getCurrentTip().setStatusCode(CommitMergeStatus.CLEAN_REBASE);
                    newCommits.put(newPatchSet.getId().getParentKey(), mergeTip.getCurrentTip());
                    setRefLogIdent();
                } catch (MergeConflictException e) {
                    n.setStatusCode(CommitMergeStatus.REBASE_MERGE_CONFLICT);
                    throw new MergeException("Cannot rebase " + n.name() + ": " + e.getMessage(), e);
                } catch (NoSuchChangeException | OrmException | IOException | RestApiException | UpdateException e) {
                    throw new MergeException("Cannot rebase " + n.name(), e);
                }
            }
        } else if (n.getParentCount() > 1) {
            // 
            try {
                if (args.rw.isMergedInto(mergeTip.getCurrentTip(), n)) {
                    mergeTip.moveTipTo(n, n);
                } else {
                    PersonIdent myIdent = args.serverIdent.get();
                    mergeTip.moveTipTo(args.mergeUtil.mergeOneCommit(myIdent, myIdent, args.repo, args.rw, args.inserter, args.canMergeFlag, args.destBranch, mergeTip.getCurrentTip(), n), n);
                }
                args.mergeUtil.markCleanMerges(args.rw, args.canMergeFlag, mergeTip.getCurrentTip(), args.alreadyAccepted);
                setRefLogIdent();
            } catch (IOException e) {
                throw new MergeException("Cannot merge " + n.name(), e);
            }
        }
        args.alreadyAccepted.add(mergeTip.getCurrentTip());
    }
    return mergeTip;
}
#end_block

#method_before
@Override
public Output apply(RevisionResource revision, ReviewInput input) throws AuthException, BadRequestException, ResourceConflictException, UnprocessableEntityException, OrmException, IOException {
    return apply(revision, input, TimeUtil.nowTs());
}
#method_after
@Override
public Output apply(RevisionResource revision, ReviewInput input) throws RestApiException, UpdateException, OrmException {
    return apply(revision, input, TimeUtil.nowTs());
}
#end_block

#method_before
public Output apply(RevisionResource revision, ReviewInput input, Timestamp ts) throws AuthException, BadRequestException, ResourceConflictException, UnprocessableEntityException, OrmException, IOException {
    timestamp = ts;
    if (revision.getEdit().isPresent()) {
        throw new ResourceConflictException("cannot post review on edit");
    }
    if (input.onBehalfOf != null) {
        revision = onBehalfOf(revision, input);
    }
    if (input.labels != null) {
        checkLabels(revision, input.strictLabels, input.labels);
    }
    if (input.comments != null) {
        checkComments(revision, input.comments);
    }
    if (input.notify == null) {
        log.warn("notify = null; assuming notify = NONE");
        input.notify = NotifyHandling.NONE;
    }
    db.get().changes().beginTransaction(revision.getChange().getId());
    boolean dirty = false;
    try {
        change = db.get().changes().get(revision.getChange().getId());
        if (change.getLastUpdatedOn().before(timestamp)) {
            change.setLastUpdatedOn(timestamp);
        }
        ChangeUpdate update = updateFactory.create(revision.getControl(), timestamp);
        update.setPatchSetId(revision.getPatchSet().getId());
        dirty |= insertComments(revision, update, input.comments, input.drafts, input.omitDuplicateComments);
        dirty |= updateLabels(revision, update, input.labels);
        dirty |= insertMessage(revision, input.message, update);
        if (dirty) {
            db.get().changes().update(Collections.singleton(change));
            db.get().commit();
        }
        update.commit();
    } finally {
        db.get().rollback();
    }
    if (dirty) {
        indexer.index(db.get(), change);
    }
    if (message != null && input.notify.compareTo(NotifyHandling.NONE) > 0) {
        email.create(input.notify, change, revision.getPatchSet(), revision.getAccountId(), message, comments).sendAsync();
    }
    Output output = new Output();
    output.labels = input.labels;
    if (message != null) {
        fireCommentAddedHook(revision);
    }
    return output;
}
#method_after
public Output apply(RevisionResource revision, ReviewInput input, Timestamp ts) throws RestApiException, UpdateException, OrmException {
    if (revision.getEdit().isPresent()) {
        throw new ResourceConflictException("cannot post review on edit");
    }
    if (input.onBehalfOf != null) {
        revision = onBehalfOf(revision, input);
    }
    if (input.labels != null) {
        checkLabels(revision, input.strictLabels, input.labels);
    }
    if (input.comments != null) {
        checkComments(revision, input.comments);
    }
    if (input.notify == null) {
        log.warn("notify = null; assuming notify = NONE");
        input.notify = NotifyHandling.NONE;
    }
    try (BatchUpdate bu = batchUpdateFactory.create(db.get(), revision.getChange().getProject(), revision.getUser(), ts)) {
        bu.addOp(revision.getChange().getId(), new Op(revision.getPatchSet().getId(), input));
        bu.execute();
    }
    Output output = new Output();
    output.labels = input.labels;
    return output;
}
#end_block

#method_before
public final CheckResult check(PGPPublicKey key) {
    if (store == null && trusted != null) {
        throw new IllegalStateException("PublicKeyStore is required");
    } else if (store != null && trusted == null) {
        throw new IllegalStateException("at least one trusted key is required");
    }
    return check(key, 0, true, store != null ? new HashSet<Fingerprint>() : null);
}
#method_after
public final CheckResult check(PGPPublicKey key) {
    if (store == null && trusted != null) {
        throw new IllegalStateException("PublicKeyStore is required");
    }
    return check(key, 0, true, trusted != null ? new HashSet<Fingerprint>() : null);
}
#end_block

#method_before
private CheckResult checkWebOfTrust(PGPPublicKey key, PublicKeyStore store, int depth, Set<Fingerprint> seen) {
    if (store == null) {
        // Trust checking not configured, server trusts all OK keys.
        return CheckResult.trusted();
    }
    Fingerprint fp = new Fingerprint(key.getFingerprint());
    if (seen.contains(fp)) {
        return CheckResult.ok("Key is trusted in a cycle");
    }
    seen.add(fp);
    Fingerprint trustedFp = trusted.get(key.getKeyID());
    if (trustedFp != null && trustedFp.equals(fp)) {
        // Directly trusted.
        return CheckResult.trusted();
    } else if (depth >= maxTrustDepth) {
        return CheckResult.ok("No path of depth <= " + maxTrustDepth + " to a trusted key");
    }
    List<CheckResult> signerResults = new ArrayList<>();
    @SuppressWarnings("unchecked")
    Iterator<String> userIds = key.getUserIDs();
    while (userIds.hasNext()) {
        String userId = userIds.next();
        @SuppressWarnings("unchecked")
        Iterator<PGPSignature> sigs = key.getSignaturesForID(userId);
        while (sigs.hasNext()) {
            PGPSignature sig = sigs.next();
            // TODO(dborowitz): Handle CERTIFICATION_REVOCATION.
            if (sig.getSignatureType() != PGPSignature.DEFAULT_CERTIFICATION && sig.getSignatureType() != PGPSignature.POSITIVE_CERTIFICATION) {
                // Not a certification.
                continue;
            }
            PGPPublicKey signer = getSigner(store, sig, userId, key, signerResults);
            // TODO(dborowitz): Require self certification.
            if (signer == null || Arrays.equals(signer.getFingerprint(), key.getFingerprint())) {
                continue;
            }
            String subpacketProblem = checkTrustSubpacket(sig, depth);
            if (subpacketProblem == null) {
                CheckResult signerResult = check(signer, depth + 1, false, seen);
                if (signerResult.isTrusted()) {
                    return CheckResult.trusted();
                }
            }
            signerResults.add(CheckResult.ok("Certification by " + keyToString(signer) + " is valid, but key is not trusted"));
        }
    }
    List<String> problems = new ArrayList<>();
    problems.add("No path to a trusted key");
    for (CheckResult signerResult : signerResults) {
        problems.addAll(signerResult.getProblems());
    }
    return CheckResult.create(OK, problems);
}
#method_after
private CheckResult checkWebOfTrust(PGPPublicKey key, PublicKeyStore store, int depth, Set<Fingerprint> seen) {
    if (trusted == null) {
        // Trust checking not configured, server trusts all OK keys.
        return CheckResult.trusted();
    }
    Fingerprint fp = new Fingerprint(key.getFingerprint());
    if (seen.contains(fp)) {
        return CheckResult.ok("Key is trusted in a cycle");
    }
    seen.add(fp);
    Fingerprint trustedFp = trusted.get(key.getKeyID());
    if (trustedFp != null && trustedFp.equals(fp)) {
        // Directly trusted.
        return CheckResult.trusted();
    } else if (depth >= maxTrustDepth) {
        return CheckResult.ok("No path of depth <= " + maxTrustDepth + " to a trusted key");
    }
    List<CheckResult> signerResults = new ArrayList<>();
    @SuppressWarnings("unchecked")
    Iterator<String> userIds = key.getUserIDs();
    while (userIds.hasNext()) {
        String userId = userIds.next();
        @SuppressWarnings("unchecked")
        Iterator<PGPSignature> sigs = key.getSignaturesForID(userId);
        while (sigs.hasNext()) {
            PGPSignature sig = sigs.next();
            // TODO(dborowitz): Handle CERTIFICATION_REVOCATION.
            if (sig.getSignatureType() != PGPSignature.DEFAULT_CERTIFICATION && sig.getSignatureType() != PGPSignature.POSITIVE_CERTIFICATION) {
                // Not a certification.
                continue;
            }
            PGPPublicKey signer = getSigner(store, sig, userId, key, signerResults);
            // TODO(dborowitz): Require self certification.
            if (signer == null || Arrays.equals(signer.getFingerprint(), key.getFingerprint())) {
                continue;
            }
            String subpacketProblem = checkTrustSubpacket(sig, depth);
            if (subpacketProblem == null) {
                CheckResult signerResult = check(signer, depth + 1, false, seen);
                if (signerResult.isTrusted()) {
                    return CheckResult.trusted();
                }
            }
            signerResults.add(CheckResult.ok("Certification by " + keyToString(signer) + " is valid, but key is not trusted"));
        }
    }
    List<String> problems = new ArrayList<>();
    problems.add("No path to a trusted key");
    for (CheckResult signerResult : signerResults) {
        problems.addAll(signerResult.getProblems());
    }
    return CheckResult.create(OK, problems);
}
#end_block

#method_before
private Project fetchGerritProject(ProjectCache projectCache, String organisation, String repoName) {
    NameKey projectNameKey = Project.NameKey.parse(organisation + "/" + repoName);
    ProjectState projectState = projectCache.get(projectNameKey);
    return projectState.getProject();
}
#method_after
private Project fetchGerritProject(ProjectCache projectCache, String fetchOrganisation, String fetchRepoName) {
    NameKey projectNameKey = Project.NameKey.parse(fetchOrganisation + "/" + fetchRepoName);
    ProjectState projectState = projectCache.get(projectNameKey);
    return projectState.getProject();
}
#end_block

#method_before
private List<Id> addPullRequestToChange(ReviewDb db, GHPullRequest pr, Repository gitRepo) throws Exception {
    String destinationBranch = REFS_HEADS + pr.getBase().getRef();
    List<Id> prChanges = Lists.newArrayList();
    ObjectId baseObjectId = ObjectId.fromString(pr.getBase().getSha());
    ObjectId prHeadObjectId = ObjectId.fromString(pr.getHead().getSha());
    try (RevWalk walk = new RevWalk(gitRepo)) {
        walk.markUninteresting(walk.lookupCommit(baseObjectId));
        walk.markStart(walk.lookupCommit(prHeadObjectId));
        walk.sort(RevSort.REVERSE);
        int patchNr = 1;
        for (GHPullRequestCommitDetail ghCommitDetail : pr.listCommits()) {
            status.update(Code.SYNC, "Patch #" + patchNr, "Patch#" + patchNr + ": Inserting PullRequest into Gerrit");
            RevCommit revCommit = walk.parseCommit(ObjectId.fromString(ghCommitDetail.getSha()));
            GHUser prUser = pr.getUser();
            GitUser commitAuthor = ghCommitDetail.getCommit().getAuthor();
            GitHubUser gitHubUser = GitHubUser.from(prUser, commitAuthor);
            Account.Id pullRequestOwner = getOrRegisterAccount(db, gitHubUser);
            Id changeId = createChange.addCommitToChange(db, project, gitRepo, destinationBranch, pullRequestOwner, revCommit, getChangeMessage(pr), String.format(TOPIC_FORMAT, pr.getNumber()));
            if (changeId != null) {
                prChanges.add(changeId);
            }
        }
        return prChanges;
    }
}
#method_after
private List<Id> addPullRequestToChange(ReviewDb db, GHPullRequest pr, Repository gitRepo) throws Exception {
    String destinationBranch = REFS_HEADS + pr.getBase().getRef();
    List<Id> prChanges = Lists.newArrayList();
    ObjectId baseObjectId = ObjectId.fromString(pr.getBase().getSha());
    ObjectId prHeadObjectId = ObjectId.fromString(pr.getHead().getSha());
    try (RevWalk walk = new RevWalk(gitRepo)) {
        walk.markUninteresting(walk.lookupCommit(baseObjectId));
        walk.markStart(walk.lookupCommit(prHeadObjectId));
        walk.sort(RevSort.REVERSE);
        int patchNr = 1;
        for (GHPullRequestCommitDetail ghCommitDetail : pr.listCommits()) {
            status.update(Code.SYNC, "Patch #" + patchNr, "Patch#" + patchNr + ": Inserting PullRequest into Gerrit");
            RevCommit revCommit = walk.parseCommit(ObjectId.fromString(ghCommitDetail.getSha()));
            GHUser prUser = pr.getUser();
            GitUser commitAuthor = ghCommitDetail.getCommit().getAuthor();
            GitHubUser gitHubUser = GitHubUser.from(prUser, commitAuthor);
            Account.Id pullRequestOwner = getOrRegisterAccount(db, gitHubUser);
            Id changeId = createChange.addCommitToChange(db, project, gitRepo, destinationBranch, pullRequestOwner, revCommit, getChangeMessage(pr), String.format(TOPIC_FORMAT, new Integer(pr.getNumber())));
            if (changeId != null) {
                prChanges.add(changeId);
            }
        }
        return prChanges;
    }
}
#end_block

#method_before
private com.google.gerrit.reviewdb.client.Account.Id getOrRegisterAccount(ReviewDb db, String login, String name, String email) throws OrmException, BadRequestException, ResourceConflictException, UnprocessableEntityException, IOException {
    AccountExternalId.Key userExtKey = new AccountExternalId.Key(AccountExternalId.SCHEME_USERNAME, login);
    AccountExternalIdAccess gerritExtIds = db.accountExternalIds();
    AccountExternalId userExtId = gerritExtIds.get(userExtKey);
    if (userExtId == null) {
        return accountImporter.importAccount(login, name, email);
    } else {
        return userExtId.getAccountId();
    }
}
#method_after
private com.google.gerrit.reviewdb.client.Account.Id getOrRegisterAccount(ReviewDb db, String login, String name, String email) throws OrmException, BadRequestException, ResourceConflictException, UnprocessableEntityException, IOException {
    AccountExternalId.Key userExtKey = new AccountExternalId.Key(AccountExternalId.SCHEME_USERNAME, login);
    AccountExternalIdAccess gerritExtIds = db.accountExternalIds();
    AccountExternalId userExtId = gerritExtIds.get(userExtKey);
    if (userExtId == null) {
        return accountImporter.importAccount(login, name, email);
    }
    return userExtId.getAccountId();
}
#end_block

#method_before
public GHRepository getGHRepository() throws IOException {
    if (ghLogin.getMyself().getLogin().equals(organisation)) {
        return ghLogin.getMyself().getRepository(repoName);
    } else {
        return ghLogin.getHub().getOrganization(organisation).getRepository(repoName);
    }
}
#method_after
public GHRepository getGHRepository() throws IOException {
    if (ghLogin.getMyself().getLogin().equals(organisation)) {
        return ghLogin.getMyself().getRepository(repoName);
    }
    return ghLogin.getHub().getOrganization(organisation).getRepository(repoName);
}
#end_block

#method_before
public CredentialsProvider getCredentialsProvider() {
    return new CredentialsProvider() {

        @Override
        public boolean supports(CredentialItem... items) {
            for (CredentialItem i : items) {
                if (i instanceof CredentialItem.Username) {
                    continue;
                } else if (i instanceof CredentialItem.Password) {
                    continue;
                } else {
                    return false;
                }
            }
            return true;
        }

        @Override
        public boolean isInteractive() {
            return false;
        }

        @Override
        public boolean get(URIish uri, CredentialItem... items) throws UnsupportedCredentialItem {
            String _username = uri.getUser();
            if (_username == null) {
                _username = GitHubRepository.this.username;
            }
            if (_username == null) {
                return false;
            }
            String _password = GitHubRepository.this.password;
            if (password == null) {
                return false;
            }
            for (CredentialItem i : items) {
                if (i instanceof CredentialItem.Username) {
                    ((CredentialItem.Username) i).setValue(_username);
                } else if (i instanceof CredentialItem.Password) {
                    ((CredentialItem.Password) i).setValue(_password.toCharArray());
                } else {
                    throw new UnsupportedCredentialItem(uri, i.getPromptText());
                }
            }
            return true;
        }
    };
}
#method_after
public CredentialsProvider getCredentialsProvider() {
    return new CredentialsProvider() {

        @Override
        public boolean supports(CredentialItem... items) {
            for (CredentialItem i : items) {
                if (i instanceof CredentialItem.Username) {
                    continue;
                } else if (i instanceof CredentialItem.Password) {
                    continue;
                } else {
                    return false;
                }
            }
            return true;
        }

        @Override
        public boolean isInteractive() {
            return false;
        }

        @Override
        public boolean get(URIish uri, CredentialItem... items) throws UnsupportedCredentialItem {
            String user = uri.getUser();
            if (user == null) {
                user = GitHubRepository.this.username;
            }
            if (user == null) {
                return false;
            }
            String passwd = GitHubRepository.this.password;
            if (passwd == null) {
                return false;
            }
            for (CredentialItem i : items) {
                if (i instanceof CredentialItem.Username) {
                    ((CredentialItem.Username) i).setValue(user);
                } else if (i instanceof CredentialItem.Password) {
                    ((CredentialItem.Password) i).setValue(passwd.toCharArray());
                } else {
                    throw new UnsupportedCredentialItem(uri, i.getPromptText());
                }
            }
            return true;
        }
    };
}
#end_block

#method_before
private List<Destination> getDestinations(Path cfgPath) throws ConfigInvalidException, IOException {
    if (!Files.exists(cfgPath) || Files.size(cfgPath) == 0) {
        return Collections.emptyList();
    }
    FileBasedConfig cfg = new FileBasedConfig(cfgPath.toFile(), FS.DETECTED);
    try {
        cfg.load();
    } catch (ConfigInvalidException e) {
        throw new ConfigInvalidException(String.format("Config file %s is invalid: %s", cfg.getFile(), e.getMessage()), e);
    } catch (IOException e) {
        throw new IOException(String.format("Cannot read %s: %s", cfg.getFile(), e.getMessage()), e);
    }
    ImmutableList.Builder<Destination> dest = ImmutableList.builder();
    for (RemoteConfig c : allRemotes(cfg)) {
        if (c.getURIs().isEmpty()) {
            continue;
        }
        for (URIish u : c.getURIs()) {
            if (u.getPath() == null || !u.getPath().contains("${name}")) {
                throw new ConfigInvalidException(String.format("remote.%s.url \"%s\" lacks ${name} placeholder in %s", c.getName(), u, cfg.getFile()));
            }
        }
        // If destination for push is not set assume equal to source.
        for (RefSpec ref : c.getPushRefSpecs()) {
            if (ref.getDestination() == null) {
                ref.setDestination(ref.getSource());
            }
        }
        if (c.getPushRefSpecs().isEmpty()) {
            c.addPushRefSpec(new RefSpec().setSourceDestination("refs/*", "refs/*").setForceUpdate(true));
        }
        dest.add(new Destination(injector, c, cfg, database, replicationUserFactory, pluginUser, gitRepositoryManager, groupBackend));
    }
    return dest.build();
}
#method_after
private List<Destination> getDestinations(Path cfgPath) throws ConfigInvalidException, IOException {
    if (!Files.exists(cfgPath) || Files.size(cfgPath) == 0) {
        return Collections.emptyList();
    }
    FileBasedConfig cfg = new FileBasedConfig(cfgPath.toFile(), FS.DETECTED);
    try {
        cfg.load();
    } catch (ConfigInvalidException e) {
        throw new ConfigInvalidException(String.format("Config file %s is invalid: %s", cfg.getFile(), e.getMessage()), e);
    } catch (IOException e) {
        throw new IOException(String.format("Cannot read %s: %s", cfg.getFile(), e.getMessage()), e);
    }
    ImmutableList.Builder<Destination> dest = ImmutableList.builder();
    for (RemoteConfig c : allRemotes(cfg)) {
        if (c.getURIs().isEmpty()) {
            continue;
        }
        for (URIish u : c.getURIs()) {
            if (u.getPath() == null || !u.getPath().contains("${name}")) {
                throw new ConfigInvalidException(String.format("remote.%s.url \"%s\" lacks ${name} placeholder in %s", c.getName(), u, cfg.getFile()));
            }
        }
        // If destination for push is not set assume equal to source.
        for (RefSpec ref : c.getPushRefSpecs()) {
            if (ref.getDestination() == null) {
                ref.setDestination(ref.getSource());
            }
        }
        if (c.getPushRefSpecs().isEmpty()) {
            c.addPushRefSpec(new RefSpec().setSourceDestination("refs/*", "refs/*").setForceUpdate(true));
        }
        dest.add(new Destination(injector, c, cfg, replicationUserFactory, pluginUser, groupBackend));
    }
    return dest.build();
}
#end_block

#method_before
private List<Id> addPullRequestToChange(ReviewDb db, GHPullRequest pr, Repository gitRepo) throws Exception {
    String destinationBranch = REFS_HEADS + pr.getBase().getRef();
    List<Id> prChanges = Lists.newArrayList();
    ObjectId baseObjectId = ObjectId.fromString(pr.getBase().getSha());
    ObjectId prHeadObjectId = ObjectId.fromString(pr.getHead().getSha());
    try (RevWalk walk = new RevWalk(gitRepo)) {
        walk.markUninteresting(walk.lookupCommit(baseObjectId));
        walk.markStart(walk.lookupCommit(prHeadObjectId));
        walk.sort(RevSort.REVERSE);
        int patchNr = 1;
        for (GHPullRequestCommitDetail ghCommitDetail : pr.listCommits()) {
            status.update(Code.SYNC, "Patch #" + patchNr, "Patch#" + patchNr + ": Inserting PullRequest into Gerrit");
            RevCommit revCommit = walk.parseCommit(ObjectId.fromString(ghCommitDetail.getSha()));
            GHUser prUser = pr.getUser();
            GitUser commitAuthor = ghCommitDetail.getCommit().getAuthor();
            GitHubUser gitHubUser = GitHubUser.from(prUser, commitAuthor);
            Account.Id pullRequestOwner = getOrRegisterAccount(db, gitHubUser);
            Id changeId = createChange.addCommitToChange(db, project, gitRepo, destinationBranch, pullRequestOwner, revCommit, getChangeMessage(pr), String.format(TOPIC_FORMAT, pr.getNumber()));
            if (changeId != null) {
                prChanges.add(changeId);
            }
        }
        return prChanges;
    }
}
#method_after
private List<Id> addPullRequestToChange(ReviewDb db, GHPullRequest pr, Repository gitRepo) throws Exception {
    String destinationBranch = REFS_HEADS + pr.getBase().getRef();
    List<Id> prChanges = Lists.newArrayList();
    ObjectId baseObjectId = ObjectId.fromString(pr.getBase().getSha());
    ObjectId prHeadObjectId = ObjectId.fromString(pr.getHead().getSha());
    try (RevWalk walk = new RevWalk(gitRepo)) {
        walk.markUninteresting(walk.lookupCommit(baseObjectId));
        walk.markStart(walk.lookupCommit(prHeadObjectId));
        walk.sort(RevSort.REVERSE);
        int patchNr = 1;
        for (GHPullRequestCommitDetail ghCommitDetail : pr.listCommits()) {
            status.update(Code.SYNC, "Patch #" + patchNr, "Patch#" + patchNr + ": Inserting PullRequest into Gerrit");
            RevCommit revCommit = walk.parseCommit(ObjectId.fromString(ghCommitDetail.getSha()));
            GHUser prUser = pr.getUser();
            GitUser commitAuthor = ghCommitDetail.getCommit().getAuthor();
            GitHubUser gitHubUser = GitHubUser.from(prUser, commitAuthor);
            Account.Id pullRequestOwner = getOrRegisterAccount(db, gitHubUser);
            Id changeId = createChange.addCommitToChange(db, project, gitRepo, destinationBranch, pullRequestOwner, revCommit, getChangeMessage(pr), String.format(TOPIC_FORMAT, new Integer(pr.getNumber())));
            if (changeId != null) {
                prChanges.add(changeId);
            }
        }
        return prChanges;
    }
}
#end_block

#method_before
@Override
public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
    HttpServletRequest httpRequest = (HttpServletRequest) request;
    HttpServletResponse httpResponse = (HttpServletResponse) response;
    log.debug("OAuthWebFilter(" + httpRequest.getRequestURL() + ") code=" + request.getParameter("code"));
    Cookie gerritCookie = getGerritCookie(httpRequest);
    try {
        GitHubLogin ghLogin = loginProvider.get(httpRequest);
        if (OAuthProtocol.isOAuthRequest(httpRequest)) {
            login(request, httpRequest, httpResponse, ghLogin);
        } else {
            if (OAuthProtocol.isOAuthLogout(httpRequest)) {
                response = logout(request, response, chain, httpRequest);
            }
            if (ghLogin != null && ghLogin.isLoggedIn()) {
                httpRequest = new AuthenticatedHttpRequest(httpRequest, config.httpHeader, ghLogin.getMyself().getLogin(), config.oauthHttpHeader, GITHUB_EXT_ID + ghLogin.getToken().accessToken);
            }
            chain.doFilter(httpRequest, response);
        }
    } finally {
        HttpSession httpSession = httpRequest.getSession();
        if (gerritCookie != null && httpSession != null) {
            String gerritCookieValue = gerritCookie.getValue();
            String gerritSessionValue = (String) httpSession.getAttribute("GerritAccount");
            if (gerritSessionValue == null) {
                httpSession.setAttribute("GerritAccount", gerritCookieValue);
            } else if (!gerritSessionValue.equals(gerritCookieValue)) {
                httpSession.invalidate();
            }
        }
    }
}
#method_after
@Override
public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
    HttpServletRequest httpRequest = (HttpServletRequest) request;
    HttpServletResponse httpResponse = (HttpServletResponse) response;
    log.debug("OAuthWebFilter(" + httpRequest.getRequestURL() + ") code=" + request.getParameter("code"));
    Cookie gerritCookie = getGerritCookie(httpRequest);
    try {
        GitHubLogin ghLogin = loginProvider.get(httpRequest);
        if (OAuthProtocol.isOAuthRequest(httpRequest)) {
            login(request, httpRequest, httpResponse, ghLogin);
        } else {
            if (OAuthProtocol.isOAuthLogout(httpRequest)) {
                httpResponse = (HttpServletResponse) logout(request, httpResponse, chain, httpRequest);
            }
            if (ghLogin != null && ghLogin.isLoggedIn()) {
                httpRequest = new AuthenticatedHttpRequest(httpRequest, config.httpHeader, ghLogin.getMyself().getLogin(), config.oauthHttpHeader, GITHUB_EXT_ID + ghLogin.getToken().accessToken);
            }
            chain.doFilter(httpRequest, httpResponse);
        }
    } finally {
        HttpSession httpSession = httpRequest.getSession();
        if (gerritCookie != null && httpSession != null) {
            String gerritCookieValue = gerritCookie.getValue();
            String gerritSessionValue = (String) httpSession.getAttribute("GerritAccount");
            if (gerritSessionValue == null) {
                httpSession.setAttribute("GerritAccount", gerritCookieValue);
            } else if (!gerritSessionValue.equals(gerritCookieValue)) {
                httpSession.invalidate();
            }
        }
    }
}
#end_block

#method_before
private ServletResponse logout(ServletRequest request, ServletResponse response, FilterChain chain, HttpServletRequest httpRequest) throws IOException, ServletException {
    getGitHubLogin(request).logout();
    return new GitHubLogoutServletResponse((HttpServletResponse) response, config.logoutRedirectUrl);
}
#method_after
private ServletResponse logout(ServletRequest request, ServletResponse response, FilterChain chain, HttpServletRequest httpRequest) {
    getGitHubLogin(request).logout();
    return new GitHubLogoutServletResponse((HttpServletResponse) response, config.logoutRedirectUrl);
}
#end_block

#method_before
@Override
public Multimap<String, String> load(String username) throws Exception {
    Multimap<String, String> orgsTeams = HashMultimap.create();
    GitHubLogin ghLogin = ghLoginProvider.get(username);
    if (ghLogin == null) {
        log.warn("Cannot login to GitHub on behalf of '{}'", username);
        return orgsTeams;
    }
    try {
        loadOrganisationsAndTeams(username, orgsTeams, ghLogin);
    } catch (FileNotFoundException teamsNotFound) {
        log.info("Cannot access teams for user '{}': falling back to list of public organisations", username);
        loadOrganisations(username, orgsTeams, ghLogin);
    }
    log.debug("GitHub user '{}' belongs to: {}", username, orgsTeams);
    return orgsTeams;
}
#method_after
@Override
public Multimap<String, String> load(String username) throws Exception {
    Multimap<String, String> orgsTeams = HashMultimap.create();
    GitHubLogin ghLogin = ghLoginProvider.get(username);
    if (ghLogin == null) {
        logger.warn("Cannot login to GitHub on behalf of '{}'", username);
        return orgsTeams;
    }
    try {
        loadOrganisationsAndTeams(username, orgsTeams, ghLogin);
    } catch (FileNotFoundException teamsNotFound) {
        logger.info("Cannot access teams for user '{}': falling back to list of public organisations", username);
        loadOrganisations(username, orgsTeams, ghLogin);
    }
    logger.debug("GitHub user '{}' belongs to: {}", username, orgsTeams);
    return orgsTeams;
}
#end_block

#method_before
private void loadOrganisationsAndTeams(String username, Multimap<String, String> orgsTeams, GitHubLogin ghLogin) throws IOException {
    log.debug("Getting list of organisations/teams for user '{}'", username);
    Map<String, Set<GHTeam>> myOrganisationsLogins = ghLogin.getHub().getMyTeams();
    for (Entry<String, Set<GHTeam>> teamsOrg : myOrganisationsLogins.entrySet()) {
        orgsTeams.put(teamsOrg.getKey(), EVERYONE_TEAM_NAME);
        for (GHTeam team : teamsOrg.getValue()) {
            orgsTeams.put(teamsOrg.getKey(), team.getName());
        }
    }
}
#method_after
private void loadOrganisationsAndTeams(String username, Multimap<String, String> orgsTeams, GitHubLogin ghLogin) throws IOException {
    logger.debug("Getting list of organisations/teams for user '{}'", username);
    Map<String, Set<GHTeam>> myOrganisationsLogins = ghLogin.getHub().getMyTeams();
    for (Entry<String, Set<GHTeam>> teamsOrg : myOrganisationsLogins.entrySet()) {
        orgsTeams.put(teamsOrg.getKey(), EVERYONE_TEAM_NAME);
        for (GHTeam team : teamsOrg.getValue()) {
            orgsTeams.put(teamsOrg.getKey(), team.getName());
        }
    }
}
#end_block

#method_before
private void loadOrganisations(String username, Multimap<String, String> orgsTeams, GitHubLogin ghLogin) throws IOException {
    log.debug("Getting list of public organisations for user '{}'", username);
    Set<String> organisations = ghLogin.getMyOrganisationsLogins();
    for (String org : organisations) {
        orgsTeams.put(org, EVERYONE_TEAM_NAME);
    }
}
#method_after
private void loadOrganisations(String username, Multimap<String, String> orgsTeams, GitHubLogin ghLogin) throws IOException {
    logger.debug("Getting list of public organisations for user '{}'", username);
    Set<String> organisations = ghLogin.getMyOrganisationsLogins();
    for (String org : organisations) {
        orgsTeams.put(org, EVERYONE_TEAM_NAME);
    }
}
#end_block

#method_before
private Runnable save() {
    return new Runnable() {

        @Override
        public void run() {
            if (!cm.isClean(generation)) {
                close.setEnabled(false);
                String text = cm.getValue();
                if (Patch.COMMIT_MSG.equals(path)) {
                    String newText = text.trim();
                    if (!newText.equals(text)) {
                        text = newText;
                        cm.setValue(text);
                    }
                }
                final int g = cm.changeGeneration(false);
                ChangeEditApi.put(revision.getParentKey().get(), path, text, new GerritCallback<VoidResult>() {

                    @Override
                    public void onSuccess(VoidResult result) {
                        generation = g;
                        setClean(cm.isClean(g));
                    }

                    @Override
                    public void onFailure(final Throwable caught) {
                        close.setEnabled(true);
                    }
                });
            }
        }
    };
}
#method_after
private Runnable save() {
    return new Runnable() {

        @Override
        public void run() {
            if (!cm.isClean(generation)) {
                close.setEnabled(false);
                String text = cm.getValue();
                if (Patch.COMMIT_MSG.equals(path)) {
                    String trimmed = text.trim() + "\r";
                    if (!trimmed.equals(text)) {
                        text = trimmed;
                        cm.setValue(text);
                    }
                }
                final int g = cm.changeGeneration(false);
                ChangeEditApi.put(revision.getParentKey().get(), path, text, new GerritCallback<VoidResult>() {

                    @Override
                    public void onSuccess(VoidResult result) {
                        generation = g;
                        setClean(cm.isClean(g));
                    }

                    @Override
                    public void onFailure(final Throwable caught) {
                        close.setEnabled(true);
                    }
                });
            }
        }
    };
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    db = DriverManager.getConnection("jdbc:derby:memory:DialectDerbyTest;create=true");
    executor = new JdbcExecutor(db);
    dialect = new DialectDerby().refine(db);
    final Properties p = new Properties();
    p.setProperty("driver", org.apache.derby.jdbc.EmbeddedDriver.class.getName());
    p.setProperty("url", db.getMetaData().getURL());
    phoneBook = new Database<>(new SimpleDataSource(p), PhoneBookDb.class);
    phoneBook2 = new Database<>(new SimpleDataSource(p), PhoneBookDb2.class);
}
#method_after
@Before
public void setUp() throws Exception {
    db = DriverManager.getConnection(CONNECT + ";create=true");
    executor = new JdbcExecutor(db);
    dialect = new DialectDerby().refine(db);
    final Properties p = new Properties();
    p.setProperty("driver", org.apache.derby.jdbc.EmbeddedDriver.class.getName());
    p.setProperty("url", db.getMetaData().getURL());
    phoneBook = new Database<>(new SimpleDataSource(p), PhoneBookDb.class);
    phoneBook2 = new Database<>(new SimpleDataSource(p), PhoneBookDb2.class);
}
#end_block

#method_before
@After
public void tearDown() {
    try {
        DriverManager.getConnection("jdbc:derby:memory:DialectDerbyTest;drop=true");
    } catch (SQLException e) {
    }
    if (executor != null) {
        executor.close();
    }
    executor = null;
    if (db != null) {
        try {
            db.close();
        } catch (SQLException e) {
            throw new RuntimeException("Cannot close database", e);
        }
    }
    db = null;
}
#method_after
@After
public void tearDown() {
    try {
        DriverManager.getConnection(CONNECT + ";drop=true");
    } catch (SQLException e) {
    /* as stated in the derby reference manual,
       * section "Setting attributes for the database connection URL"
       * https://db.apache.org/derby/docs/10.11/ref/rrefattribdrop.html
       * "The attribute generates the SQLException 08006 if successful.
       *  If the database does not exist, it generates an error
       *  reporting that the database could not be found."
       *  So we can safely ignore this SQLException here.
       */
    }
    if (executor != null) {
        executor.close();
    }
    executor = null;
    if (db != null) {
        try {
            db.close();
        } catch (SQLException e) {
            throw new RuntimeException("Cannot close database", e);
        }
    }
    db = null;
}
#end_block

#method_before
@Test
public void testUpgradeSchema() throws SQLException, OrmException {
    final PhoneBookDb p = phoneBook.open();
    try {
        p.updateSchema(executor);
        execute("CREATE SEQUENCE cnt");
        execute("CREATE TABLE foo (cnt INT)");
        execute("ALTER TABLE people ADD COLUMN fake_name VARCHAR(20)");
        execute("ALTER TABLE people DROP COLUMN registered");
        Set<String> sequences, tables;
        p.updateSchema(executor);
        sequences = dialect.listSequences(db);
        tables = dialect.listTables(db);
        assertTrue(sequences.contains("cnt"));
        assertTrue(tables.contains("foo"));
        assertTrue(sequences.contains("address_id"));
        assertTrue(tables.contains("addresses"));
        p.pruneSchema(executor);
        sequences = dialect.listSequences(db);
        tables = dialect.listTables(db);
        assertFalse(sequences.contains("cnt"));
        assertFalse(tables.contains("foo"));
        final Person.Key pk = new Person.Key("Bob");
        final Person bob = new Person(pk, p.nextAddressId());
        p.people().insert(Collections.singleton(bob));
        final Address addr = new Address(new Address.Key(pk, "home"), "some place");
        p.addresses().insert(Collections.singleton(addr));
    } finally {
        p.close();
    }
// constraint violation for rename column :-(
// final PhoneBookDb2 p2 = phoneBook2.open();
// try {
// ((JdbcSchema) p2).renameField(executor, "people", "registered",
// "isRegistered");
// } finally {
// p2.close();
// }
}
#method_after
@Test
public void testUpgradeSchema() throws SQLException, OrmException {
    final PhoneBookDb p = phoneBook.open();
    try {
        p.updateSchema(executor);
        execute("CREATE SEQUENCE cnt");
        execute("CREATE TABLE foo (cnt INT)");
        execute("ALTER TABLE people ADD COLUMN fake_name VARCHAR(20)");
        execute("ALTER TABLE people DROP COLUMN registered");
        Set<String> sequences, tables;
        p.updateSchema(executor);
        sequences = dialect.listSequences(db);
        tables = dialect.listTables(db);
        assertTrue(sequences.contains("cnt"));
        assertTrue(tables.contains("foo"));
        assertTrue(sequences.contains("address_id"));
        assertTrue(tables.contains("addresses"));
        p.pruneSchema(executor);
        sequences = dialect.listSequences(db);
        tables = dialect.listTables(db);
        assertFalse(sequences.contains("cnt"));
        assertFalse(tables.contains("foo"));
        final Person.Key pk = new Person.Key("Bob");
        final Person bob = new Person(pk, p.nextAddressId());
        p.people().insert(Collections.singleton(bob));
        final Address addr = new Address(new Address.Key(pk, "home"), "some place");
        p.addresses().insert(Collections.singleton(addr));
    } finally {
        p.close();
    }
    /* rename a column in an existing table to match the new schema */
    final PhoneBookDb2 p2 = phoneBook2.open();
    /* As Apache Derby doesn't support renaming a column as long as a constraint
     * exists on the column, we need to drop the constraint manually.
     * Currently a CHECK constraint is created by gwtorm for all fields with
     * type SqlBooleanTypeInfo.
     * See also https://db.apache.org/derby/docs/10.11/ref/rrefsqljrenamecolumnstatement.html
     * for more information about the restriction of the RENAME COLUMN command.
     */
    String sqlCatalog = "select c.constraintname, ch.checkdefinition" + " from sys.sysconstraints c, sys.systables t, sys.syschecks ch" + " WHERE c.tableid = t.tableid" + "   and t.tablename = ?" + "   and c.constraintid = ch.constraintid";
    PreparedStatement ps = db.prepareStatement(sqlCatalog);
    String tableName = "PEOPLE";
    ps.setString(1, tableName);
    try {
        ResultSet rs = ps.executeQuery();
        List<String> constraintNames = new ArrayList<>();
        List<String> checkDefs = new ArrayList<>();
        while (rs.next()) {
            if (rs.getString(2).contains("registered")) {
                constraintNames.add(rs.getString(1));
                checkDefs.add(rs.getString(2).replace("registered", "is_registered"));
                break;
            }
        }
        rs.close();
        ps.close();
        if (constraintNames.isEmpty()) {
            fail("Constraint not found");
        }
        for (String c : constraintNames) {
            execute("alter table " + tableName + " drop check " + c);
        }
        ((JdbcSchema) p2).renameField(executor, "people", "registered", "isRegistered");
        for (String cd : checkDefs) {
            execute("alter table " + tableName + " add check " + cd);
        }
    } catch (OrmException e) {
        fail(e.getMessage());
    } finally {
        p2.close();
    }
}
#end_block

#method_before
public String getCreateSequenceSql(final SequenceModel seq) {
    final Sequence s = seq.getSequence();
    final StringBuilder r = new StringBuilder();
    r.append("CREATE SEQUENCE ");
    r.append(seq.getSequenceName());
    if (s.startWith() > 0) {
        r.append(" START WITH ");
        r.append(s.startWith());
    }
    if (s.cache() > 0) {
        r.append(" CACHE ");
        r.append(s.cache());
    }
    return r.toString();
}
#method_after
public String getCreateSequenceSql(final SequenceModel seq) {
    final Sequence s = seq.getSequence();
    final StringBuilder r = new StringBuilder();
    r.append("CREATE SEQUENCE ");
    r.append(seq.getSequenceName());
    /*
     * Some gwtorm users seems to imply a start of 1, enforce this constraint
     * here explicitly
     */
    r.append(" START WITH ");
    r.append(s.startWith() > 0 ? s.startWith() : 1);
    if (s.cache() > 0) {
        r.append(" CACHE ");
        r.append(s.cache());
    }
    return r.toString();
}
#end_block

#method_before
private PatchList readPatchList(final PatchListKey key, final Repository repo) throws IOException, PatchListNotAvailableException {
    final RawTextComparator cmp = comparatorFor(key.getWhitespace());
    try (ObjectReader reader = repo.newObjectReader();
        RevWalk rw = new RevWalk(reader);
        DiffFormatter df = new DiffFormatter(DisabledOutputStream.INSTANCE)) {
        final RevCommit b = rw.parseCommit(key.getNewId());
        final RevObject a = aFor(key, repo, rw, b);
        if (a == null) {
            // TODO(sop) Remove this case.
            // This is a merge commit, compared to its ancestor.
            // 
            final PatchListEntry[] entries = new PatchListEntry[1];
            entries[0] = newCommitMessage(cmp, reader, null, b);
            return new PatchList(a, b, true, entries);
        }
        final boolean againstParent = b.getParentCount() > 0 && b.getParent(0) == a;
        RevCommit aCommit = a instanceof RevCommit ? (RevCommit) a : null;
        RevTree aTree = rw.parseTree(a);
        RevTree bTree = b.getTree();
        df.setRepository(repo);
        df.setDiffComparator(cmp);
        df.setDetectRenames(true);
        List<DiffEntry> diffEntries = df.scan(aTree, bTree);
        Set<String> paths = null;
        if (key.getOldId() != null) {
            PatchListKey newKey = new PatchListKey(null, key.getNewId(), key.getWhitespace());
            PatchListKey oldKey = new PatchListKey(null, key.getOldId(), key.getWhitespace());
            paths = FluentIterable.from(patchListCache.get(newKey, project).getPatches()).append(patchListCache.get(oldKey, project).getPatches()).transform(new Function<PatchListEntry, String>() {

                @Override
                public String apply(PatchListEntry entry) {
                    return entry.getNewName();
                }
            }).toSet();
        }
        int cnt = diffEntries.size();
        List<PatchListEntry> entries = new ArrayList<>();
        entries.add(newCommitMessage(cmp, reader, againstParent ? null : aCommit, b));
        for (int i = 0; i < cnt; i++) {
            DiffEntry diffEntry = diffEntries.get(i);
            if (paths == null || paths.contains(diffEntry.getNewPath()) || paths.contains(diffEntry.getOldPath())) {
                FileHeader fh = toFileHeader(key, df, diffEntry);
                PatchListEntry e = newEntry(aTree, fh);
                if (com.google.gerrit.reviewdb.client.Patch.PatchType.BINARY.equals(e.getPatchType())) {
                    e.setSizeDelta(getFileSize(repo, reader, diffEntry.getNewPath(), bTree) - getFileSize(repo, reader, diffEntry.getOldPath(), aTree));
                }
                entries.add(e);
            }
        }
        return new PatchList(a, b, againstParent, entries.toArray(new PatchListEntry[entries.size()]));
    }
}
#method_after
private PatchList readPatchList(final PatchListKey key, final Repository repo) throws IOException, PatchListNotAvailableException {
    final RawTextComparator cmp = comparatorFor(key.getWhitespace());
    try (ObjectReader reader = repo.newObjectReader();
        RevWalk rw = new RevWalk(reader);
        DiffFormatter df = new DiffFormatter(DisabledOutputStream.INSTANCE)) {
        final RevCommit b = rw.parseCommit(key.getNewId());
        final RevObject a = aFor(key, repo, rw, b);
        if (a == null) {
            // TODO(sop) Remove this case.
            // This is a merge commit, compared to its ancestor.
            // 
            final PatchListEntry[] entries = new PatchListEntry[1];
            entries[0] = newCommitMessage(cmp, reader, null, b);
            return new PatchList(a, b, true, entries);
        }
        final boolean againstParent = b.getParentCount() > 0 && b.getParent(0) == a;
        RevCommit aCommit = a instanceof RevCommit ? (RevCommit) a : null;
        RevTree aTree = rw.parseTree(a);
        RevTree bTree = b.getTree();
        df.setRepository(repo);
        df.setDiffComparator(cmp);
        df.setDetectRenames(true);
        List<DiffEntry> diffEntries = df.scan(aTree, bTree);
        Set<String> paths = null;
        if (key.getOldId() != null) {
            PatchListKey newKey = new PatchListKey(null, key.getNewId(), key.getWhitespace());
            PatchListKey oldKey = new PatchListKey(null, key.getOldId(), key.getWhitespace());
            paths = FluentIterable.from(patchListCache.get(newKey, project).getPatches()).append(patchListCache.get(oldKey, project).getPatches()).transform(new Function<PatchListEntry, String>() {

                @Override
                public String apply(PatchListEntry entry) {
                    return entry.getNewName();
                }
            }).toSet();
        }
        int cnt = diffEntries.size();
        List<PatchListEntry> entries = new ArrayList<>();
        entries.add(newCommitMessage(cmp, reader, againstParent ? null : aCommit, b));
        for (int i = 0; i < cnt; i++) {
            DiffEntry diffEntry = diffEntries.get(i);
            if (paths == null || paths.contains(diffEntry.getNewPath()) || paths.contains(diffEntry.getOldPath())) {
                FileHeader fh = toFileHeader(key, df, diffEntry);
                long sizeDelta = getFileSize(repo, reader, diffEntry.getNewPath(), bTree) - getFileSize(repo, reader, diffEntry.getOldPath(), aTree);
                entries.add(newEntry(aTree, fh, sizeDelta));
            }
        }
        return new PatchList(a, b, againstParent, entries.toArray(new PatchListEntry[entries.size()]));
    }
}
#end_block

#method_before
private PatchListEntry newCommitMessage(final RawTextComparator cmp, final ObjectReader reader, final RevCommit aCommit, final RevCommit bCommit) throws IOException {
    StringBuilder hdr = new StringBuilder();
    hdr.append("diff --git");
    if (aCommit != null) {
        hdr.append(" a/").append(Patch.COMMIT_MSG);
    } else {
        hdr.append(" ").append(FileHeader.DEV_NULL);
    }
    hdr.append(" b/").append(Patch.COMMIT_MSG);
    hdr.append("\n");
    if (aCommit != null) {
        hdr.append("--- a/").append(Patch.COMMIT_MSG).append("\n");
    } else {
        hdr.append("--- ").append(FileHeader.DEV_NULL).append("\n");
    }
    hdr.append("+++ b/").append(Patch.COMMIT_MSG).append("\n");
    Text aText = aCommit != null ? Text.forCommit(reader, aCommit) : Text.EMPTY;
    Text bText = Text.forCommit(reader, bCommit);
    byte[] rawHdr = hdr.toString().getBytes("UTF-8");
    RawText aRawText = new RawText(aText.getContent());
    RawText bRawText = new RawText(bText.getContent());
    EditList edits = new HistogramDiff().diff(cmp, aRawText, bRawText);
    FileHeader fh = new FileHeader(rawHdr, edits, PatchType.UNIFIED);
    return new PatchListEntry(fh, edits);
}
#method_after
private PatchListEntry newCommitMessage(final RawTextComparator cmp, final ObjectReader reader, final RevCommit aCommit, final RevCommit bCommit) throws IOException {
    StringBuilder hdr = new StringBuilder();
    hdr.append("diff --git");
    if (aCommit != null) {
        hdr.append(" a/").append(Patch.COMMIT_MSG);
    } else {
        hdr.append(" ").append(FileHeader.DEV_NULL);
    }
    hdr.append(" b/").append(Patch.COMMIT_MSG);
    hdr.append("\n");
    if (aCommit != null) {
        hdr.append("--- a/").append(Patch.COMMIT_MSG).append("\n");
    } else {
        hdr.append("--- ").append(FileHeader.DEV_NULL).append("\n");
    }
    hdr.append("+++ b/").append(Patch.COMMIT_MSG).append("\n");
    Text aText = aCommit != null ? Text.forCommit(reader, aCommit) : Text.EMPTY;
    Text bText = Text.forCommit(reader, bCommit);
    byte[] rawHdr = hdr.toString().getBytes("UTF-8");
    byte[] aContent = aText.getContent();
    byte[] bContent = bText.getContent();
    long sizeDelta = bContent.length - aContent.length;
    RawText aRawText = new RawText(aContent);
    RawText bRawText = new RawText(bContent);
    EditList edits = new HistogramDiff().diff(cmp, aRawText, bRawText);
    FileHeader fh = new FileHeader(rawHdr, edits, PatchType.UNIFIED);
    return new PatchListEntry(fh, edits, sizeDelta);
}
#end_block

#method_before
private PatchListEntry newEntry(RevTree aTree, FileHeader fileHeader) {
    final FileMode oldMode = fileHeader.getOldMode();
    final FileMode newMode = fileHeader.getNewMode();
    if (oldMode == FileMode.GITLINK || newMode == FileMode.GITLINK) {
        return new PatchListEntry(fileHeader, Collections.<Edit>emptyList());
    }
    if (// want combined diff
    aTree == null || fileHeader.getPatchType() != PatchType.UNIFIED || fileHeader.getHunks().isEmpty()) {
        return new PatchListEntry(fileHeader, Collections.<Edit>emptyList());
    }
    List<Edit> edits = fileHeader.toEditList();
    if (edits.isEmpty()) {
        return new PatchListEntry(fileHeader, Collections.<Edit>emptyList());
    } else {
        return new PatchListEntry(fileHeader, edits);
    }
}
#method_after
private PatchListEntry newEntry(RevTree aTree, FileHeader fileHeader, long sizeDelta) {
    final FileMode oldMode = fileHeader.getOldMode();
    final FileMode newMode = fileHeader.getNewMode();
    if (oldMode == FileMode.GITLINK || newMode == FileMode.GITLINK) {
        return new PatchListEntry(fileHeader, Collections.<Edit>emptyList(), sizeDelta);
    }
    if (// want combined diff
    aTree == null || fileHeader.getPatchType() != PatchType.UNIFIED || fileHeader.getHunks().isEmpty()) {
        return new PatchListEntry(fileHeader, Collections.<Edit>emptyList(), sizeDelta);
    }
    List<Edit> edits = fileHeader.toEditList();
    if (edits.isEmpty()) {
        return new PatchListEntry(fileHeader, Collections.<Edit>emptyList(), sizeDelta);
    } else {
        return new PatchListEntry(fileHeader, edits, sizeDelta);
    }
}
#end_block

#method_before
Map<String, FileInfo> toFileInfoMap(Change change, RevId revision, @Nullable PatchSet base) throws PatchListNotAvailableException {
    ObjectId a = (base == null) ? null : ObjectId.fromString(base.getRevision().get());
    ObjectId b = ObjectId.fromString(revision.get());
    PatchList list = patchListCache.get(new PatchListKey(a, b, Whitespace.IGNORE_NONE), change.getProject());
    Map<String, FileInfo> files = Maps.newTreeMap();
    for (PatchListEntry e : list.getPatches()) {
        FileInfo d = new FileInfo();
        d.status = e.getChangeType() != Patch.ChangeType.MODIFIED ? e.getChangeType().getCode() : null;
        d.oldPath = e.getOldName();
        if (e.getPatchType() == Patch.PatchType.BINARY) {
            d.binary = true;
            d.sizeDelta = e.getSizeDelta() != null ? e.getSizeDelta() : null;
        } else {
            d.linesInserted = e.getInsertions() > 0 ? e.getInsertions() : null;
            d.linesDeleted = e.getDeletions() > 0 ? e.getDeletions() : null;
        }
        FileInfo o = files.put(e.getNewName(), d);
        if (o != null) {
            // This should only happen on a delete-add break created by JGit
            // when the file was rewritten and too little content survived. Write
            // a single record with data from both sides.
            d.status = Patch.ChangeType.REWRITE.getCode();
            if (o.binary != null && o.binary) {
                d.binary = true;
                d.sizeDelta = o.sizeDelta;
            }
            if (o.linesInserted != null) {
                d.linesInserted = o.linesInserted;
            }
            if (o.linesDeleted != null) {
                d.linesDeleted = o.linesDeleted;
            }
        }
    }
    return files;
}
#method_after
Map<String, FileInfo> toFileInfoMap(Change change, RevId revision, @Nullable PatchSet base) throws PatchListNotAvailableException {
    ObjectId a = (base == null) ? null : ObjectId.fromString(base.getRevision().get());
    ObjectId b = ObjectId.fromString(revision.get());
    PatchList list = patchListCache.get(new PatchListKey(a, b, Whitespace.IGNORE_NONE), change.getProject());
    Map<String, FileInfo> files = Maps.newTreeMap();
    for (PatchListEntry e : list.getPatches()) {
        FileInfo d = new FileInfo();
        d.status = e.getChangeType() != Patch.ChangeType.MODIFIED ? e.getChangeType().getCode() : null;
        d.oldPath = e.getOldName();
        d.sizeDelta = e.getSizeDelta();
        if (e.getPatchType() == Patch.PatchType.BINARY) {
            d.binary = true;
        } else {
            d.linesInserted = e.getInsertions() > 0 ? e.getInsertions() : null;
            d.linesDeleted = e.getDeletions() > 0 ? e.getDeletions() : null;
        }
        FileInfo o = files.put(e.getNewName(), d);
        if (o != null) {
            // This should only happen on a delete-add break created by JGit
            // when the file was rewritten and too little content survived. Write
            // a single record with data from both sides.
            d.status = Patch.ChangeType.REWRITE.getCode();
            d.sizeDelta = o.sizeDelta;
            if (o.binary != null && o.binary) {
                d.binary = true;
            }
            if (o.linesInserted != null) {
                d.linesInserted = o.linesInserted;
            }
            if (o.linesDeleted != null) {
                d.linesDeleted = o.linesDeleted;
            }
        }
    }
    return files;
}
#end_block

#method_before
static PatchListEntry empty(final String fileName) {
    return new PatchListEntry(ChangeType.MODIFIED, PatchType.UNIFIED, null, fileName, EMPTY_HEADER, Collections.<Edit>emptyList(), 0, 0);
}
#method_after
static PatchListEntry empty(final String fileName) {
    return new PatchListEntry(ChangeType.MODIFIED, PatchType.UNIFIED, null, fileName, EMPTY_HEADER, Collections.<Edit>emptyList(), 0, 0, 0);
}
#end_block

#method_before
public Long getSizeDelta() {
    return sizeDelta;
}
#method_after
public long getSizeDelta() {
    return sizeDelta;
}
#end_block

#method_before
void writeTo(final OutputStream out) throws IOException {
    writeEnum(out, changeType);
    writeEnum(out, patchType);
    writeString(out, oldName);
    writeString(out, newName);
    writeBytes(out, header);
    writeVarInt32(out, insertions);
    writeVarInt32(out, deletions);
    writeVarInt32(out, edits.size());
    for (final Edit e : edits) {
        writeVarInt32(out, e.getBeginA());
        writeVarInt32(out, e.getEndA());
        writeVarInt32(out, e.getBeginB());
        writeVarInt32(out, e.getEndB());
    }
}
#method_after
void writeTo(OutputStream out) throws IOException {
    writeEnum(out, changeType);
    writeEnum(out, patchType);
    writeString(out, oldName);
    writeString(out, newName);
    writeBytes(out, header);
    writeVarInt32(out, insertions);
    writeVarInt32(out, deletions);
    writeFixInt64(out, sizeDelta);
    writeVarInt32(out, edits.size());
    for (final Edit e : edits) {
        writeVarInt32(out, e.getBeginA());
        writeVarInt32(out, e.getEndA());
        writeVarInt32(out, e.getBeginB());
        writeVarInt32(out, e.getEndB());
    }
}
#end_block

#method_before
static PatchListEntry readFrom(final InputStream in) throws IOException {
    final ChangeType changeType = readEnum(in, ChangeType.values());
    final PatchType patchType = readEnum(in, PatchType.values());
    final String oldName = readString(in);
    final String newName = readString(in);
    final byte[] hdr = readBytes(in);
    final int ins = readVarInt32(in);
    final int del = readVarInt32(in);
    final int editCount = readVarInt32(in);
    final Edit[] editArray = new Edit[editCount];
    for (int i = 0; i < editCount; i++) {
        int beginA = readVarInt32(in);
        int endA = readVarInt32(in);
        int beginB = readVarInt32(in);
        int endB = readVarInt32(in);
        editArray[i] = new Edit(beginA, endA, beginB, endB);
    }
    return new PatchListEntry(changeType, patchType, oldName, newName, hdr, toList(editArray), ins, del);
}
#method_after
static PatchListEntry readFrom(InputStream in) throws IOException {
    ChangeType changeType = readEnum(in, ChangeType.values());
    PatchType patchType = readEnum(in, PatchType.values());
    String oldName = readString(in);
    String newName = readString(in);
    byte[] hdr = readBytes(in);
    int ins = readVarInt32(in);
    int del = readVarInt32(in);
    long sizeDelta = readFixInt64(in);
    int editCount = readVarInt32(in);
    Edit[] editArray = new Edit[editCount];
    for (int i = 0; i < editCount; i++) {
        int beginA = readVarInt32(in);
        int endA = readVarInt32(in);
        int beginB = readVarInt32(in);
        int endB = readVarInt32(in);
        editArray[i] = new Edit(beginA, endA, beginB, endB);
    }
    return new PatchListEntry(changeType, patchType, oldName, newName, hdr, toList(editArray), ins, del, sizeDelta);
}
#end_block

#method_before
private void columnDelta1(SafeHtmlBuilder sb, FileInfo info) {
    sb.openTd().setStyleName(R.css().deltaColumn1());
    if (!Patch.COMMIT_MSG.equals(info.path()) && !info.binary()) {
        if (showChangeSizeBars) {
            sb.append(info.linesInserted() + info.linesDeleted());
        } else if (!ChangeType.DELETED.matches(info.status())) {
            if (ChangeType.ADDED.matches(info.status())) {
                sb.append(info.linesInserted()).append(" lines");
            } else {
                sb.append("+").append(info.linesInserted()).append(", -").append(info.linesDeleted());
            }
        }
    } else if (info.binary()) {
        sb.append(formatBytes(info.sizeDelta()));
    }
    sb.closeTd();
}
#method_after
private void columnDelta1(SafeHtmlBuilder sb, FileInfo info) {
    sb.openTd().setStyleName(R.css().deltaColumn1());
    if (!Patch.COMMIT_MSG.equals(info.path()) && !info.binary()) {
        if (showChangeSizeBars) {
            sb.append(info.linesInserted() + info.linesDeleted());
        } else if (!ChangeType.DELETED.matches(info.status())) {
            if (ChangeType.ADDED.matches(info.status())) {
                sb.append(info.linesInserted()).append(" lines");
            } else {
                sb.append("+").append(info.linesInserted()).append(", -").append(info.linesDeleted());
            }
        }
    } else if (info.binary()) {
        sb.append(FormatUtil.formatBytes(info.sizeDelta()));
    }
    sb.closeTd();
}
#end_block

#method_before
public final long sizeDelta() {
    return (long) _sizeDelta();
}
#method_after
// JSNI methods cannot have 'long' as a parameter type or a return type and
// it's suggested to use double in this case:
public final long sizeDelta() {
    return (long) _sizeDelta();
}
#end_block

#method_before
@Override
protected void doPost(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
    req.setCharacterEncoding("UTF-8");
    String username = Strings.nullToEmpty(req.getParameter("username")).trim();
    String password = Strings.nullToEmpty(req.getParameter("password"));
    String remember = Strings.nullToEmpty(req.getParameter("rememberme"));
    if (username.isEmpty() || password.isEmpty()) {
        sendForm(req, res, "Invalid username or password.");
        return;
    }
    AuthRequest areq = AuthRequest.forUser(username);
    areq.setPassword(password);
    AuthResult ares;
    try {
        ares = accountManager.authenticate(areq);
    } catch (AccountUserNameException e) {
        sendForm(req, res, e.getMessage());
        return;
    } catch (AuthenticationUnavailableException e) {
        sendForm(req, res, "Authentication unavailable at this time.");
        return;
    } catch (AccountException e) {
        log.info(String.format("'%s' failed to sign in: %s", username, e.getMessage()));
        sendForm(req, res, "Invalid username or password.");
        return;
    } catch (RuntimeException e) {
        log.error("LDAP authentication failed", e);
        sendForm(req, res, "Authentication unavailable at this time.");
        return;
    }
    StringBuilder dest = new StringBuilder();
    dest.append(urlProvider.get(req));
    dest.append(LoginUrlToken.getToken(req));
    CacheHeaders.setNotCacheable(res);
    webSession.get().login(ares, "1".equals(remember));
    res.sendRedirect(dest.toString());
}
#method_after
@Override
protected void doPost(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
    req.setCharacterEncoding(UTF_8.name());
    String username = Strings.nullToEmpty(req.getParameter("username")).trim();
    String password = Strings.nullToEmpty(req.getParameter("password"));
    String remember = Strings.nullToEmpty(req.getParameter("rememberme"));
    if (username.isEmpty() || password.isEmpty()) {
        sendForm(req, res, "Invalid username or password.");
        return;
    }
    AuthRequest areq = AuthRequest.forUser(username);
    areq.setPassword(password);
    AuthResult ares;
    try {
        ares = accountManager.authenticate(areq);
    } catch (AccountUserNameException e) {
        sendForm(req, res, e.getMessage());
        return;
    } catch (AuthenticationUnavailableException e) {
        sendForm(req, res, "Authentication unavailable at this time.");
        return;
    } catch (AccountException e) {
        log.info(String.format("'%s' failed to sign in: %s", username, e.getMessage()));
        sendForm(req, res, "Invalid username or password.");
        return;
    } catch (RuntimeException e) {
        log.error("LDAP authentication failed", e);
        sendForm(req, res, "Authentication unavailable at this time.");
        return;
    }
    StringBuilder dest = new StringBuilder();
    dest.append(urlProvider.get(req));
    dest.append(LoginUrlToken.getToken(req));
    CacheHeaders.setNotCacheable(res);
    webSession.get().login(ares, "1".equals(remember));
    res.sendRedirect(dest.toString());
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    AccountGroup.UUID anonymousUsers = SystemGroupBackend.getGroup(ANONYMOUS_USERS).getUUID();
    Util.allow(cfg, Permission.forLabel(label.getName()), -1, 1, anonymousUsers, "refs/heads/*");
    Util.allow(cfg, Permission.forLabel(P.getName()), 0, 1, anonymousUsers, "refs/heads/*");
}
#method_after
@Before
public void setUp() throws Exception {
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    AccountGroup.UUID anonymousUsers = SystemGroupBackend.getGroup(ANONYMOUS_USERS).getUUID();
    Util.allow(cfg, Permission.forLabel(label.getName()), -1, 1, anonymousUsers, "refs/heads/*");
    Util.allow(cfg, Permission.forLabel(P.getName()), 0, 1, anonymousUsers, "refs/heads/*");
    saveProjectConfig(project, cfg);
}
#end_block

#method_before
@Override
protected void configure() {
    bind(AccountsCollection.class);
    bind(Capabilities.class);
    DynamicMap.mapOf(binder(), ACCOUNT_KIND);
    DynamicMap.mapOf(binder(), CAPABILITY_KIND);
    DynamicMap.mapOf(binder(), EMAIL_KIND);
    DynamicMap.mapOf(binder(), SSH_KEY_KIND);
    DynamicMap.mapOf(binder(), STARRED_CHANGE_KIND);
    put(ACCOUNT_KIND).to(PutAccount.class);
    get(ACCOUNT_KIND).to(GetAccount.class);
    get(ACCOUNT_KIND, "name").to(GetName.class);
    put(ACCOUNT_KIND, "name").to(PutName.class);
    delete(ACCOUNT_KIND, "name").to(PutName.class);
    get(ACCOUNT_KIND, "username").to(GetUsername.class);
    get(ACCOUNT_KIND, "active").to(GetActive.class);
    put(ACCOUNT_KIND, "active").to(PutActive.class);
    delete(ACCOUNT_KIND, "active").to(DeleteActive.class);
    child(ACCOUNT_KIND, "emails").to(Emails.class);
    get(EMAIL_KIND).to(GetEmail.class);
    put(EMAIL_KIND).to(PutEmail.class);
    delete(EMAIL_KIND).to(DeleteEmail.class);
    put(EMAIL_KIND, "preferred").to(PutPreferred.class);
    get(ACCOUNT_KIND, "password.http").to(GetHttpPassword.class);
    put(ACCOUNT_KIND, "password.http").to(PutHttpPassword.class);
    delete(ACCOUNT_KIND, "password.http").to(PutHttpPassword.class);
    child(ACCOUNT_KIND, "sshkeys").to(SshKeys.class);
    post(ACCOUNT_KIND, "sshkeys").to(AddSshKey.class);
    get(SSH_KEY_KIND).to(GetSshKey.class);
    delete(SSH_KEY_KIND).to(DeleteSshKey.class);
    get(ACCOUNT_KIND, "avatar").to(GetAvatar.class);
    get(ACCOUNT_KIND, "avatar.change.url").to(GetAvatarChangeUrl.class);
    child(ACCOUNT_KIND, "capabilities").to(Capabilities.class);
    get(ACCOUNT_KIND, "groups").to(GetGroups.class);
    get(ACCOUNT_KIND, "preferences").to(GetPreferences.class);
    post(ACCOUNT_KIND, "preferences").to(SetPreferences.class);
    get(ACCOUNT_KIND, "preferences.diff").to(GetDiffPreferences.class);
    put(ACCOUNT_KIND, "preferences.diff").to(SetDiffPreferences.class);
    get(ACCOUNT_KIND, "preferences.user").to(GetUserPreferences.class);
    put(ACCOUNT_KIND, "preferences.user").to(SetUserPreferences.class);
    get(CAPABILITY_KIND).to(GetCapabilities.CheckOne.class);
    child(ACCOUNT_KIND, "starred.changes").to(StarredChanges.class);
    put(STARRED_CHANGE_KIND).to(StarredChanges.Put.class);
    delete(STARRED_CHANGE_KIND).to(StarredChanges.Delete.class);
    bind(StarredChanges.Create.class);
    install(new FactoryModuleBuilder().build(CreateAccount.Factory.class));
    install(new FactoryModuleBuilder().build(CreateEmail.Factory.class));
}
#method_after
@Override
protected void configure() {
    bind(AccountsCollection.class);
    bind(Capabilities.class);
    DynamicMap.mapOf(binder(), ACCOUNT_KIND);
    DynamicMap.mapOf(binder(), CAPABILITY_KIND);
    DynamicMap.mapOf(binder(), EMAIL_KIND);
    DynamicMap.mapOf(binder(), SSH_KEY_KIND);
    DynamicMap.mapOf(binder(), STARRED_CHANGE_KIND);
    put(ACCOUNT_KIND).to(PutAccount.class);
    get(ACCOUNT_KIND).to(GetAccount.class);
    get(ACCOUNT_KIND, "detail").to(GetDetail.class);
    get(ACCOUNT_KIND, "name").to(GetName.class);
    put(ACCOUNT_KIND, "name").to(PutName.class);
    delete(ACCOUNT_KIND, "name").to(PutName.class);
    get(ACCOUNT_KIND, "username").to(GetUsername.class);
    put(ACCOUNT_KIND, "username").to(PutUsername.class);
    get(ACCOUNT_KIND, "active").to(GetActive.class);
    put(ACCOUNT_KIND, "active").to(PutActive.class);
    delete(ACCOUNT_KIND, "active").to(DeleteActive.class);
    child(ACCOUNT_KIND, "emails").to(Emails.class);
    get(EMAIL_KIND).to(GetEmail.class);
    put(EMAIL_KIND).to(PutEmail.class);
    delete(EMAIL_KIND).to(DeleteEmail.class);
    put(EMAIL_KIND, "preferred").to(PutPreferred.class);
    get(ACCOUNT_KIND, "password.http").to(GetHttpPassword.class);
    put(ACCOUNT_KIND, "password.http").to(PutHttpPassword.class);
    delete(ACCOUNT_KIND, "password.http").to(PutHttpPassword.class);
    child(ACCOUNT_KIND, "sshkeys").to(SshKeys.class);
    post(ACCOUNT_KIND, "sshkeys").to(AddSshKey.class);
    get(SSH_KEY_KIND).to(GetSshKey.class);
    delete(SSH_KEY_KIND).to(DeleteSshKey.class);
    get(ACCOUNT_KIND, "avatar").to(GetAvatar.class);
    get(ACCOUNT_KIND, "avatar.change.url").to(GetAvatarChangeUrl.class);
    child(ACCOUNT_KIND, "capabilities").to(Capabilities.class);
    get(ACCOUNT_KIND, "groups").to(GetGroups.class);
    get(ACCOUNT_KIND, "preferences").to(GetPreferences.class);
    put(ACCOUNT_KIND, "preferences").to(SetPreferences.class);
    get(ACCOUNT_KIND, "preferences.diff").to(GetDiffPreferences.class);
    put(ACCOUNT_KIND, "preferences.diff").to(SetDiffPreferences.class);
    get(ACCOUNT_KIND, "preferences.edit").to(GetEditPreferences.class);
    put(ACCOUNT_KIND, "preferences.edit").to(SetEditPreferences.class);
    get(CAPABILITY_KIND).to(GetCapabilities.CheckOne.class);
    child(ACCOUNT_KIND, "starred.changes").to(StarredChanges.class);
    put(STARRED_CHANGE_KIND).to(StarredChanges.Put.class);
    delete(STARRED_CHANGE_KIND).to(StarredChanges.Delete.class);
    bind(StarredChanges.Create.class);
    factory(CreateAccount.Factory.class);
    factory(CreateEmail.Factory.class);
}
#end_block

#method_before
private void onLoad2() {
    CallbackGroup group1 = new CallbackGroup();
    final CallbackGroup group2 = new CallbackGroup();
    final CallbackGroup group3 = new CallbackGroup();
    CodeMirror.initLibrary(group1.add(new AsyncCallback<Void>() {

        final AsyncCallback<Void> themeCallback = group3.addEmpty();

        @Override
        public void onSuccess(Void result) {
            // Load theme after CM library to ensure theme can override CSS.
            ThemeLoader.loadTheme(prefs.theme(), themeCallback);
            group2.done();
            group3.done();
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
    ChangeApi.detail(revision.getParentKey().get(), group1.add(new AsyncCallback<ChangeInfo>() {

        @Override
        public void onSuccess(ChangeInfo c) {
            project.setInnerText(c.project());
            SafeHtml.setInnerHTML(filePath, Header.formatPath(path, null, null));
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
    if (revision.get() == 0) {
        ChangeEditApi.getMeta(revision, path, group1.add(new AsyncCallback<EditFileInfo>() {

            @Override
            public void onSuccess(EditFileInfo editInfo) {
                editFileInfo = editInfo;
            }

            @Override
            public void onFailure(Throwable e) {
            }
        }));
    } else {
        // TODO(davido): We probably want to create dedicated GET EditScreenMeta
        // REST endpoint. Abuse GET diff for now, as it retrieves links we need.
        DiffApi.diff(revision, path).base(base).webLinksOnly().get(group1.add(new AsyncCallback<DiffInfo>() {

            @Override
            public void onSuccess(DiffInfo diffInfo) {
                diffLinks = diffInfo.web_links();
            }

            @Override
            public void onFailure(Throwable e) {
            }
        }));
    }
    ChangeEditApi.get(revision, path, group2.add(new HttpCallback<NativeString>() {

        final AsyncCallback<Void> modeCallback = group3.addEmpty();

        @Override
        public void onSuccess(HttpResponse<NativeString> fc) {
            content = fc;
            if (prefs.syntaxHighlighting()) {
                injectMode(fc.getContentType(), modeCallback);
            } else {
                modeCallback.onSuccess(null);
            }
        }

        @Override
        public void onFailure(Throwable e) {
            // "Not Found" means it's a new file.
            if (RestApi.isNotFound(e)) {
                content = null;
                modeCallback.onSuccess(null);
            } else {
                GerritCallback.showFailure(e);
            }
        }
    }));
    group3.addListener(new ScreenLoadCallback<Void>(this) {

        @Override
        protected void preDisplay(Void result) {
            initEditor(content);
            renderLinks(editFileInfo, diffLinks);
            editFileInfo = null;
            diffLinks = null;
        }
    });
    group1.done();
}
#method_after
private void onLoad2() {
    CallbackGroup group1 = new CallbackGroup();
    final CallbackGroup group2 = new CallbackGroup();
    final CallbackGroup group3 = new CallbackGroup();
    CodeMirror.initLibrary(group1.add(new AsyncCallback<Void>() {

        final AsyncCallback<Void> themeCallback = group3.addEmpty();

        @Override
        public void onSuccess(Void result) {
            // Load theme after CM library to ensure theme can override CSS.
            ThemeLoader.loadTheme(prefs.theme(), themeCallback);
            group2.done();
            group3.done();
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
    ChangeApi.detail(revision.getParentKey().get(), group1.add(new AsyncCallback<ChangeInfo>() {

        @Override
        public void onSuccess(ChangeInfo c) {
            project.setInnerText(c.project());
            SafeHtml.setInnerHTML(filePath, Header.formatPath(path, null, null));
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
    if (revision.get() == 0) {
        ChangeEditApi.getMeta(revision, path, group1.add(new AsyncCallback<EditFileInfo>() {

            @Override
            public void onSuccess(EditFileInfo editInfo) {
                editFileInfo = editInfo;
            }

            @Override
            public void onFailure(Throwable e) {
            }
        }));
    } else {
        // TODO(davido): We probably want to create dedicated GET EditScreenMeta
        // REST endpoint. Abuse GET diff for now, as it retrieves links we need.
        DiffApi.diff(revision, path).base(base).webLinksOnly().get(group1.add(new AsyncCallback<DiffInfo>() {

            @Override
            public void onSuccess(DiffInfo diffInfo) {
                diffLinks = diffInfo.webLinks();
            }

            @Override
            public void onFailure(Throwable e) {
            }
        }));
    }
    ChangeEditApi.get(revision, path, group2.add(new HttpCallback<NativeString>() {

        final AsyncCallback<Void> modeCallback = group3.addEmpty();

        @Override
        public void onSuccess(HttpResponse<NativeString> fc) {
            content = fc;
            if (prefs.syntaxHighlighting()) {
                injectMode(fc.getContentType(), modeCallback);
            } else {
                modeCallback.onSuccess(null);
            }
        }

        @Override
        public void onFailure(Throwable e) {
            // "Not Found" means it's a new file.
            if (RestApi.isNotFound(e)) {
                content = null;
                modeCallback.onSuccess(null);
            } else {
                GerritCallback.showFailure(e);
            }
        }
    }));
    group3.addListener(new ScreenLoadCallback<Void>(this) {

        @Override
        protected void preDisplay(Void result) {
            initEditor(content);
            renderLinks(editFileInfo, diffLinks);
            editFileInfo = null;
            diffLinks = null;
        }
    });
    group1.done();
}
#end_block

#method_before
private void renderLinks(EditFileInfo editInfo, JsArray<DiffWebLinkInfo> diffLinks) {
    renderLinksToDiff();
    if (editInfo != null) {
        renderLinks(Natives.asList(editInfo.web_links()));
    } else if (diffLinks != null) {
        renderLinks(Natives.asList(diffLinks));
    }
}
#method_after
private void renderLinks(EditFileInfo editInfo, JsArray<DiffWebLinkInfo> diffLinks) {
    renderLinksToDiff();
    if (editInfo != null) {
        renderLinks(Natives.asList(editInfo.webLinks()));
    } else if (diffLinks != null) {
        renderLinks(Natives.asList(diffLinks));
    }
}
#end_block

#method_before
public Response<SshKeyInfo> apply(IdentifiedUser user, Input input) throws BadRequestException, OrmException, IOException {
    if (input == null) {
        input = new Input();
    }
    if (input.raw == null) {
        throw new BadRequestException("SSH public key missing");
    }
    ResultSet<AccountSshKey> byAccountLast = dbProvider.get().accountSshKeys().byAccountLast(user.getAccountId());
    AccountSshKey last = Iterables.getOnlyElement(byAccountLast, null);
    int max = last == null ? 0 : last.getKey().get();
    final RawInput rawKey = input.raw;
    String sshPublicKey = new ByteSource() {

        @Override
        public InputStream openStream() throws IOException {
            return rawKey.getInputStream();
        }
    }.asCharSource(UTF_8).read();
    try {
        AccountSshKey sshKey = sshKeyCache.create(new AccountSshKey.Id(user.getAccountId(), max + 1), sshPublicKey);
        dbProvider.get().accountSshKeys().insert(Collections.singleton(sshKey));
        try {
            addSshKeyFactory.create(user, sshKey).send();
        } catch (EmailException | RuntimeException e) {
            log.error("Cannot send SSH key added message to " + email, e);
        }
        sshKeyCache.evict(user.getUserName());
        return Response.<SshKeyInfo>created(new SshKeyInfo(sshKey));
    } catch (InvalidSshKeyException e) {
        throw new BadRequestException(e.getMessage());
    }
}
#method_after
public Response<SshKeyInfo> apply(IdentifiedUser user, Input input) throws BadRequestException, OrmException, IOException {
    if (input == null) {
        input = new Input();
    }
    if (input.raw == null) {
        throw new BadRequestException("SSH public key missing");
    }
    ResultSet<AccountSshKey> byAccountLast = dbProvider.get().accountSshKeys().byAccountLast(user.getAccountId());
    AccountSshKey last = Iterables.getOnlyElement(byAccountLast, null);
    int max = last == null ? 0 : last.getKey().get();
    final RawInput rawKey = input.raw;
    String sshPublicKey = new ByteSource() {

        @Override
        public InputStream openStream() throws IOException {
            return rawKey.getInputStream();
        }
    }.asCharSource(UTF_8).read();
    try {
        AccountSshKey sshKey = sshKeyCache.create(new AccountSshKey.Id(user.getAccountId(), max + 1), sshPublicKey);
        dbProvider.get().accountSshKeys().insert(Collections.singleton(sshKey));
        try {
            addKeyFactory.create(user, sshKey).send();
        } catch (EmailException e) {
            log.error("Cannot send SSH key added message to " + user.getAccount().getPreferredEmail(), e);
        }
        sshKeyCache.evict(user.getUserName());
        return Response.<SshKeyInfo>created(new SshKeyInfo(sshKey));
    } catch (InvalidSshKeyException e) {
        throw new BadRequestException(e.getMessage());
    }
}
#end_block

#method_before
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(ChangeKindCacheImpl.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(MergeabilityCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new GitModule());
    install(new GroupModule());
    install(new NoteDbModule());
    install(new PrologModule());
    install(new SshAddressesModule());
    install(new SignedPushModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(AddSshKeySender.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeData.Factory.class);
    factory(ChangeJson.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(EmailMerge.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    factory(ProjectOwnerGroupsProvider.Factory.class);
    bind(RepositoryConfig.class);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(GitwebConfig.class);
    bind(GcConfig.class);
    bind(ChangeCleanupConfig.class);
    bind(ApprovalsUtil.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(Boolean.class).annotatedWith(DisableReverseDnsLookup.class).toProvider(DisableReverseDnsLookupProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), ReceivePackInitializer.class);
    DynamicSet.setOf(binder(), PostReceiveHook.class);
    DynamicSet.setOf(binder(), PreUploadHook.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), GarbageCollectorListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.setOf(binder(), UsageDataPublishedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ReindexAfterUpdate.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ProjectConfigEntry.UpdateChecker.class);
    DynamicSet.setOf(binder(), EventListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), RefOperationValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicSet.setOf(binder(), ProjectCreationValidationListener.class);
    DynamicSet.setOf(binder(), GroupCreationValidationListener.class);
    DynamicSet.setOf(binder(), HashtagValidationListener.class);
    DynamicSet.setOf(binder(), OutgoingEmailValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), CloneCommand.class);
    DynamicMap.mapOf(binder(), ExternalIncludedIn.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    DynamicSet.setOf(binder(), PatchSetWebLink.class);
    DynamicSet.setOf(binder(), FileWebLink.class);
    DynamicSet.setOf(binder(), DiffWebLink.class);
    DynamicSet.setOf(binder(), ProjectWebLink.class);
    DynamicSet.setOf(binder(), BranchWebLink.class);
    factory(UploadValidators.Factory.class);
    DynamicSet.setOf(binder(), UploadValidationListener.class);
    bind(AnonymousUser.class);
    factory(CommitValidators.Factory.class);
    factory(RefOperationValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    factory(SubmoduleSectionParser.Factory.class);
    bind(AccountManager.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#method_after
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(ChangeKindCacheImpl.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(MergeabilityCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new GitModule());
    install(new GroupModule());
    install(new NoteDbModule());
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(AddKeySender.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeData.Factory.class);
    factory(ChangeJson.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(EmailMerge.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    factory(ProjectOwnerGroupsProvider.Factory.class);
    bind(RepositoryConfig.class);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(GitwebConfig.class);
    bind(GcConfig.class);
    bind(ChangeCleanupConfig.class);
    bind(ApprovalsUtil.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(Boolean.class).annotatedWith(DisableReverseDnsLookup.class).toProvider(DisableReverseDnsLookupProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), ReceivePackInitializer.class);
    DynamicSet.setOf(binder(), PostReceiveHook.class);
    DynamicSet.setOf(binder(), PreUploadHook.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), GarbageCollectorListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.setOf(binder(), UsageDataPublishedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ReindexAfterUpdate.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ProjectConfigEntry.UpdateChecker.class);
    DynamicSet.setOf(binder(), EventListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), RefOperationValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicSet.setOf(binder(), ProjectCreationValidationListener.class);
    DynamicSet.setOf(binder(), GroupCreationValidationListener.class);
    DynamicSet.setOf(binder(), HashtagValidationListener.class);
    DynamicSet.setOf(binder(), OutgoingEmailValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), CloneCommand.class);
    DynamicMap.mapOf(binder(), ExternalIncludedIn.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    DynamicSet.setOf(binder(), PatchSetWebLink.class);
    DynamicSet.setOf(binder(), FileWebLink.class);
    DynamicSet.setOf(binder(), FileHistoryWebLink.class);
    DynamicSet.setOf(binder(), DiffWebLink.class);
    DynamicSet.setOf(binder(), ProjectWebLink.class);
    DynamicSet.setOf(binder(), BranchWebLink.class);
    factory(UploadValidators.Factory.class);
    DynamicSet.setOf(binder(), UploadValidationListener.class);
    bind(AnonymousUser.class);
    factory(CommitValidators.Factory.class);
    factory(RefOperationValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    factory(SubmoduleSectionParser.Factory.class);
    bind(AccountManager.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#end_block

#method_before
@Test
public void testParseSimple() throws Exception {
    DestinationList dl = new DestinationList();
    dl.parseLabel(LABEL, F_SIMPLE, null);
    Set<Branch.NameKey> branches = dl.getDestinations(LABEL);
    assertThat(D_SIMPLE).containsExactlyElementsIn(branches);
}
#method_after
@Test
public void testParseSimple() throws Exception {
    DestinationList dl = new DestinationList();
    dl.parseLabel(LABEL, F_SIMPLE, null);
    Set<Branch.NameKey> branches = dl.getDestinations(LABEL);
    assertThat(branches).containsExactlyElementsIn(D_SIMPLE);
}
#end_block

#method_before
@Test
public void testParseWHeader() throws Exception {
    DestinationList dl = new DestinationList();
    dl.parseLabel(LABEL, HEADER + F_SIMPLE, null);
    Set<Branch.NameKey> branches = dl.getDestinations(LABEL);
    assertThat(D_SIMPLE).containsExactlyElementsIn(branches);
}
#method_after
@Test
public void testParseWHeader() throws Exception {
    DestinationList dl = new DestinationList();
    dl.parseLabel(LABEL, HEADER + F_SIMPLE, null);
    Set<Branch.NameKey> branches = dl.getDestinations(LABEL);
    assertThat(branches).containsExactlyElementsIn(D_SIMPLE);
}
#end_block

#method_before
@Test
public void testParseWComments() throws Exception {
    DestinationList dl = new DestinationList();
    dl.parseLabel(LABEL, C1 + F_SIMPLE + C2, null);
    Set<Branch.NameKey> branches = dl.getDestinations(LABEL);
    assertThat(D_SIMPLE).containsExactlyElementsIn(branches);
}
#method_after
@Test
public void testParseWComments() throws Exception {
    DestinationList dl = new DestinationList();
    dl.parseLabel(LABEL, C1 + F_SIMPLE + C2, null);
    Set<Branch.NameKey> branches = dl.getDestinations(LABEL);
    assertThat(branches).containsExactlyElementsIn(D_SIMPLE);
}
#end_block

#method_before
@Test
public void testParsePaddedFronts() throws Exception {
    DestinationList dl = new DestinationList();
    dl.parseLabel(LABEL, F_PAD_F, null);
    Set<Branch.NameKey> branches = dl.getDestinations(LABEL);
    assertThat(D_SIMPLE).containsExactlyElementsIn(branches);
}
#method_after
@Test
public void testParsePaddedFronts() throws Exception {
    DestinationList dl = new DestinationList();
    dl.parseLabel(LABEL, F_PAD_F, null);
    Set<Branch.NameKey> branches = dl.getDestinations(LABEL);
    assertThat(branches).containsExactlyElementsIn(D_SIMPLE);
}
#end_block

#method_before
@Test
public void testParsePaddedEnds() throws Exception {
    DestinationList dl = new DestinationList();
    dl.parseLabel(LABEL, F_PAD_E, null);
    Set<Branch.NameKey> branches = dl.getDestinations(LABEL);
    assertThat(D_SIMPLE).containsExactlyElementsIn(branches);
}
#method_after
@Test
public void testParsePaddedEnds() throws Exception {
    DestinationList dl = new DestinationList();
    dl.parseLabel(LABEL, F_PAD_E, null);
    Set<Branch.NameKey> branches = dl.getDestinations(LABEL);
    assertThat(branches).containsExactlyElementsIn(D_SIMPLE);
}
#end_block

#method_before
@Test
public void testParse2Labels() throws Exception {
    DestinationList dl = new DestinationList();
    dl.parseLabel(LABEL, F_SIMPLE, null);
    Set<Branch.NameKey> branches = dl.getDestinations(LABEL);
    assertThat(D_SIMPLE).containsExactlyElementsIn(branches);
    dl.parseLabel(LABEL2, L_COMPLEX, null);
    branches = dl.getDestinations(LABEL);
    assertThat(D_SIMPLE).containsExactlyElementsIn(branches);
    branches = dl.getDestinations(LABEL2);
    assertThat(branches).contains(B_COMPLEX);
}
#method_after
@Test
public void testParse2Labels() throws Exception {
    DestinationList dl = new DestinationList();
    dl.parseLabel(LABEL, F_SIMPLE, null);
    Set<Branch.NameKey> branches = dl.getDestinations(LABEL);
    assertThat(branches).containsExactlyElementsIn(D_SIMPLE);
    dl.parseLabel(LABEL2, L_COMPLEX, null);
    branches = dl.getDestinations(LABEL);
    assertThat(branches).containsExactlyElementsIn(D_SIMPLE);
    branches = dl.getDestinations(LABEL2);
    assertThat(branches).contains(B_COMPLEX);
}
#end_block

#method_before
@Test
public void testAsText() throws Exception {
    String text = HEADER_PROPER + "#\n" + F_PROPER;
    DestinationList dl = new DestinationList();
    dl.parseLabel(LABEL, F_SIMPLE, null);
    String asText = dl.asText(LABEL);
    assertThat(text).isEqualTo(asText);
    dl.parseLabel(LABEL2, asText, null);
    String asText2 = dl.asText(LABEL2);
    assertThat(text).isEqualTo(asText2);
}
#method_after
@Test
public void testAsText() throws Exception {
    String text = HEADER_PROPER + "#\n" + F_PROPER;
    DestinationList dl = new DestinationList();
    dl.parseLabel(LABEL, F_SIMPLE, null);
    String asText = dl.asText(LABEL);
    assertThat(text).isEqualTo(asText);
    dl.parseLabel(LABEL2, asText, null);
    assertThat(text).isEqualTo(dl.asText(LABEL2));
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> destination(String name) throws QueryParseException, OrmException {
    AllUsersName allUsers = args.allUsersName.get();
    try (Repository git = args.repoManager.openRepository(allUsers)) {
        VersionedAccountDestinations d = VersionedAccountDestinations.forUser(self());
        d.load(git);
        Set<Branch.NameKey> destinations = d.getDestinationList().getDestinations(name);
        if (destinations != null) {
            return new DestinationPredicate(destinations, name);
        }
    } catch (RepositoryNotFoundException e) {
        throw new QueryParseException("Unknown named destination (no " + allUsers.get() + " repo): " + name, e);
    } catch (IOException | ConfigInvalidException e) {
        throw new QueryParseException("Error parsing named destination: " + name, e);
    }
    throw new QueryParseException("Unknown named destination: " + name);
}
#method_after
@Operator
public Predicate<ChangeData> destination(String name) throws QueryParseException {
    AllUsersName allUsers = args.allUsersName.get();
    try (Repository git = args.repoManager.openRepository(allUsers)) {
        VersionedAccountDestinations d = VersionedAccountDestinations.forUser(self());
        d.load(git);
        Set<Branch.NameKey> destinations = d.getDestinationList().getDestinations(name);
        if (destinations != null) {
            return new DestinationPredicate(destinations, name);
        }
    } catch (RepositoryNotFoundException e) {
        throw new QueryParseException("Unknown named destination (no " + allUsers.get() + " repo): " + name, e);
    } catch (IOException | ConfigInvalidException e) {
        throw new QueryParseException("Error parsing named destination: " + name, e);
    }
    throw new QueryParseException("Unknown named destination: " + name);
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
protected Predicate<ChangeData> defaultField(String query) throws QueryParseException {
    if (query.startsWith("refs/")) {
        return ref(query);
    } else if (DEF_CHANGE.matcher(query).matches()) {
        try {
            return change(query);
        } catch (QueryParseException e) {
        // Skip.
        }
    }
    List<Predicate<ChangeData>> predicates = Lists.newArrayListWithCapacity(9);
    try {
        predicates.add(commit(query));
    } catch (IllegalArgumentException e) {
    // Skip.
    }
    try {
        predicates.add(owner(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    try {
        predicates.add(reviewer(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    predicates.add(file(query));
    try {
        predicates.add(label(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    predicates.add(message(query));
    predicates.add(comment(query));
    predicates.add(projects(query));
    predicates.add(ref(query));
    predicates.add(branch(query));
    predicates.add(topic(query));
    return Predicate.or(predicates);
}
#method_after
@Override
protected Predicate<ChangeData> defaultField(String query) throws QueryParseException {
    if (query.startsWith("refs/")) {
        return ref(query);
    } else if (DEF_CHANGE.matcher(query).matches()) {
        try {
            return change(query);
        } catch (QueryParseException e) {
        // Skip.
        }
    }
    List<Predicate<ChangeData>> predicates = Lists.newArrayListWithCapacity(9);
    try {
        predicates.add(commit(query));
    } catch (IllegalArgumentException e) {
    // Skip.
    }
    try {
        predicates.add(owner(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    try {
        predicates.add(reviewer(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    predicates.add(file(query));
    try {
        predicates.add(label(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    predicates.add(message(query));
    predicates.add(comment(query));
    predicates.add(projects(query));
    predicates.add(ref(query));
    predicates.add(branch(query));
    predicates.add(topic(query));
    return Predicate.or(predicates);
}
#end_block

#method_before
public void parseLabel(String label, String text, ValidationError.Sink errors) throws IOException {
    destinations.put(label, toSet(parse(text, DIR_NAME + label, TRIM, null, errors)));
}
#method_after
public void parseLabel(String label, String text, ValidationError.Sink errors) throws IOException {
    destinations.replaceValues(label, toSet(parse(text, DIR_NAME + label, TRIM, null, errors)));
}
#end_block

#method_before
public BinaryResult getContent(ProjectState project, ObjectId revstr, String path) throws ResourceNotFoundException, IOException {
    try (Repository repo = openRepository(project);
        RevWalk rw = new RevWalk(repo)) {
        RevCommit commit = rw.parseCommit(revstr);
        ObjectReader reader = rw.getObjectReader();
        TreeWalk tw = TreeWalk.forPath(reader, path, commit.getTree());
        if (tw == null) {
            throw new ResourceNotFoundException();
        }
        org.eclipse.jgit.lib.FileMode mode = tw.getFileMode(0);
        ObjectId id = tw.getObjectId(0);
        if (mode == org.eclipse.jgit.lib.FileMode.GITLINK) {
            return BinaryResult.create(id.name()).setContentType(X_GIT_GITLINK).base64();
        }
        final ObjectLoader obj = repo.open(id, OBJ_BLOB);
        byte[] raw;
        try {
            raw = obj.getCachedBytes(MAX_SIZE);
        } catch (LargeObjectException e) {
            raw = null;
        }
        String type;
        if (mode == org.eclipse.jgit.lib.FileMode.SYMLINK) {
            type = X_GIT_SYMLINK;
        } else {
            type = registry.getMimeType(path, raw).toString();
            type = resolveContentType(project, path, FileMode.FILE, type);
        }
        return asBinaryResult(raw, obj).setContentType(type).base64();
    }
}
#method_after
public BinaryResult getContent(ProjectState project, ObjectId revstr, String path) throws ResourceNotFoundException, IOException {
    try (Repository repo = openRepository(project);
        RevWalk rw = new RevWalk(repo)) {
        RevCommit commit = rw.parseCommit(revstr);
        ObjectReader reader = rw.getObjectReader();
        TreeWalk tw = TreeWalk.forPath(reader, path, commit.getTree());
        if (tw == null) {
            throw new ResourceNotFoundException();
        }
        org.eclipse.jgit.lib.FileMode mode = tw.getFileMode(0);
        ObjectId id = tw.getObjectId(0);
        if (mode == org.eclipse.jgit.lib.FileMode.GITLINK) {
            return BinaryResult.create(id.name()).setContentType(X_GIT_GITLINK).base64();
        }
        ObjectLoader obj = repo.open(id, OBJ_BLOB);
        byte[] raw;
        try {
            raw = obj.getCachedBytes(MAX_SIZE);
        } catch (LargeObjectException e) {
            raw = null;
        }
        String type;
        if (mode == org.eclipse.jgit.lib.FileMode.SYMLINK) {
            type = X_GIT_SYMLINK;
        } else {
            type = registry.getMimeType(path, raw).toString();
            type = resolveContentType(project, path, FileMode.FILE, type);
        }
        return asBinaryResult(raw, obj).setContentType(type).base64();
    }
}
#end_block

#method_before
private BinaryResult wrapBlob(ProjectState project, String path, final ObjectLoader obj, byte[] raw, MimeType contentType, @Nullable String side) {
    BinaryResult result;
    if (raw != null) {
        result = BinaryResult.create(raw);
    } else {
        result = new BinaryResult() {

            @Override
            public void writeTo(OutputStream os) throws IOException {
                obj.copyTo(os);
            }
        };
        result.setContentLength(obj.getSize());
    }
    result.setContentType(resolveContentType(project, path, FileMode.FILE, contentType.toString())).setAttachmentName(safeFileName(path, side));
    return result;
}
#method_after
private BinaryResult wrapBlob(ProjectState project, String path, final ObjectLoader obj, byte[] raw, MimeType contentType, @Nullable String suffix) {
    return asBinaryResult(raw, obj).setContentType(contentType.toString()).setAttachmentName(safeFileName(path, suffix));
}
#end_block

#method_before
private BinaryResult zipBlob(final String path, final ObjectLoader obj, final String commitName, final long when, @Nullable final String side) {
    BinaryResult result = new BinaryResult() {

        @Override
        public void writeTo(OutputStream os) throws IOException {
            ZipOutputStream zipOut = new ZipOutputStream(os);
            String suffix = side != null ? side + '-' + randSuffix() : randSuffix();
            ZipEntry e = new ZipEntry(safeFileName(path, suffix));
            e.setComment(commitName + ":" + path);
            e.setSize(obj.getSize());
            e.setTime(when);
            zipOut.putNextEntry(e);
            obj.copyTo(zipOut);
            zipOut.closeEntry();
            zipOut.close();
        }
    };
    result.setContentType(ZIP.toString()).setAttachmentName(safeFileName(path, side) + ".zip").setContentLength(// it is not practical to determine this
    -1).disableGzip();
    return result;
}
#method_after
private BinaryResult zipBlob(final String path, final ObjectLoader obj, RevCommit commit, @Nullable final String suffix) {
    final String commitName = commit.getName();
    final long when = commit.getCommitTime() * 1000L;
    return new BinaryResult() {

        @Override
        public void writeTo(OutputStream os) throws IOException {
            try (ZipOutputStream zipOut = new ZipOutputStream(os)) {
                String decoration = randSuffix();
                if (!Strings.isNullOrEmpty(suffix)) {
                    decoration = suffix + '-' + decoration;
                }
                ZipEntry e = new ZipEntry(safeFileName(path, decoration));
                e.setComment(commitName + ":" + path);
                e.setSize(obj.getSize());
                e.setTime(when);
                zipOut.putNextEntry(e);
                obj.copyTo(zipOut);
                zipOut.closeEntry();
            }
        }
    }.setContentType(ZIP_TYPE).setAttachmentName(safeFileName(path, suffix) + ".zip").disableGzip();
}
#end_block

#method_before
private static String safeFileName(String fileName, @Nullable String suffix) {
    // Convert a file path (e.g. "src/Init.c") to a safe file name with
    // no meta-characters that might be unsafe on any given platform.
    // 
    final int slash = fileName.lastIndexOf('/');
    fileName = fileName.substring(slash + 1);
    if (slash >= 0) {
    }
    final StringBuilder r = new StringBuilder(fileName.length());
    for (int i = 0; i < fileName.length(); i++) {
        final char c = fileName.charAt(i);
        if (c == '_' || c == '-' || c == '.' || c == '@') {
            r.append(c);
        } else if ('0' <= c && c <= '9') {
            r.append(c);
        } else if ('A' <= c && c <= 'Z') {
            r.append(c);
        } else if ('a' <= c && c <= 'z') {
            r.append(c);
        } else if (c == ' ' || c == '\n' || c == '\r' || c == '\t') {
            r.append('-');
        } else {
            r.append('_');
        }
    }
    fileName = r.toString();
    final int ext = fileName.lastIndexOf('.');
    if (suffix == null) {
        return fileName;
    } else if (ext <= 0) {
        return fileName + "_" + suffix;
    } else {
        return fileName.substring(0, ext) + "_" + suffix + fileName.substring(ext);
    }
}
#method_after
private static String safeFileName(String fileName, @Nullable String suffix) {
    // Convert a file path (e.g. "src/Init.c") to a safe file name with
    // no meta-characters that might be unsafe on any given platform.
    // 
    int slash = fileName.lastIndexOf('/');
    if (slash >= 0) {
        fileName = fileName.substring(slash + 1);
    }
    StringBuilder r = new StringBuilder(fileName.length());
    for (int i = 0; i < fileName.length(); i++) {
        final char c = fileName.charAt(i);
        if (c == '_' || c == '-' || c == '.' || c == '@') {
            r.append(c);
        } else if ('0' <= c && c <= '9') {
            r.append(c);
        } else if ('A' <= c && c <= 'Z') {
            r.append(c);
        } else if ('a' <= c && c <= 'z') {
            r.append(c);
        } else if (c == ' ' || c == '\n' || c == '\r' || c == '\t') {
            r.append('-');
        } else {
            r.append('_');
        }
    }
    fileName = r.toString();
    int ext = fileName.lastIndexOf('.');
    if (suffix == null) {
        return fileName;
    } else if (ext <= 0) {
        return fileName + "_" + suffix;
    } else {
        return fileName.substring(0, ext) + "_" + suffix + fileName.substring(ext);
    }
}
#end_block

#method_before
private static String randSuffix() {
    // Produce a random suffix that is difficult (or nearly impossible)
    // for an attacker to guess in advance. This reduces the risk that
    // an attacker could upload a *.class file and have us send a ZIP
    // that can be invoked through an applet tag in the victim's browser.
    // 
    final MessageDigest md = Constants.newMessageDigest();
    final byte[] buf = new byte[8];
    NB.encodeInt64(buf, 0, TimeUtil.nowMs());
    md.update(buf, 0, 8);
    rng.nextBytes(buf);
    md.update(buf, 0, 8);
    return ObjectId.fromRaw(md.digest()).name();
}
#method_after
private static String randSuffix() {
    // Produce a random suffix that is difficult (or nearly impossible)
    // for an attacker to guess in advance. This reduces the risk that
    // an attacker could upload a *.class file and have us send a ZIP
    // that can be invoked through an applet tag in the victim's browser.
    // 
    Hasher h = Hashing.md5().newHasher();
    byte[] buf = new byte[8];
    NB.encodeInt64(buf, 0, TimeUtil.nowMs());
    h.putBytes(buf);
    rng.nextBytes(buf);
    h.putBytes(buf);
    return h.hash().toString();
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ChangesCollection.class);
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(DraftComments.class);
    bind(Comments.class);
    bind(Files.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), DRAFT_COMMENT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    DynamicMap.mapOf(binder(), CHANGE_EDIT_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    get(CHANGE_KIND, "in").to(IncludedIn.class);
    get(CHANGE_KIND, "hashtags").to(GetHashtags.class);
    get(CHANGE_KIND, "comments").to(ListChangeComments.class);
    get(CHANGE_KIND, "drafts").to(ListChangeDrafts.class);
    get(CHANGE_KIND, "check").to(Check.class);
    post(CHANGE_KIND, "check").to(Check.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND).to(DeleteDraftChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "hashtags").to(PostHashtags.class);
    post(CHANGE_KIND, "publish").to(PublishDraftPatchSet.CurrentRevision.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    get(CHANGE_KIND, "submitted_together").to(SubmittedTogether.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "index").to(Index.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    get(CHANGE_KIND, "suggest_reviewers").to(SuggestReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    get(REVISION_KIND, "actions").to(GetRevisionActions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    delete(REVISION_KIND).to(DeleteDraftPatchSet.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    post(REVISION_KIND, "publish").to(PublishDraftPatchSet.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    get(REVISION_KIND, "archive").to(GetArchive.class);
    child(REVISION_KIND, "drafts").to(DraftComments.class);
    put(REVISION_KIND, "drafts").to(CreateDraftComment.class);
    get(DRAFT_COMMENT_KIND).to(GetDraftComment.class);
    put(DRAFT_COMMENT_KIND).to(PutDraftComment.class);
    delete(DRAFT_COMMENT_KIND).to(DeleteDraftComment.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "safe_content").to(GetSafeContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    child(CHANGE_KIND, "edit").to(ChangeEdits.class);
    delete(CHANGE_KIND, "edit").to(DeleteChangeEdit.class);
    child(CHANGE_KIND, "edit:publish").to(PublishChangeEdit.class);
    child(CHANGE_KIND, "edit:rebase").to(RebaseChangeEdit.class);
    put(CHANGE_KIND, "edit:message").to(ChangeEdits.EditMessage.class);
    get(CHANGE_KIND, "edit:message").to(ChangeEdits.GetMessage.class);
    put(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Put.class);
    delete(CHANGE_EDIT_KIND).to(ChangeEdits.DeleteContent.class);
    get(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Get.class);
    get(CHANGE_EDIT_KIND, "meta").to(ChangeEdits.GetMeta.class);
    factory(ReviewerResource.Factory.class);
    factory(AccountLoader.Factory.class);
    factory(EmailReviewComments.Factory.class);
    factory(ChangeInserter.Factory.class);
    factory(PatchSetInserter.Factory.class);
    factory(ChangeEdits.Create.Factory.class);
    factory(ChangeEdits.DeleteFile.Factory.class);
}
#method_after
@Override
protected void configure() {
    bind(ChangesCollection.class);
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(DraftComments.class);
    bind(Comments.class);
    bind(Files.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), DRAFT_COMMENT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    DynamicMap.mapOf(binder(), CHANGE_EDIT_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    get(CHANGE_KIND, "in").to(IncludedIn.class);
    get(CHANGE_KIND, "hashtags").to(GetHashtags.class);
    get(CHANGE_KIND, "comments").to(ListChangeComments.class);
    get(CHANGE_KIND, "drafts").to(ListChangeDrafts.class);
    get(CHANGE_KIND, "check").to(Check.class);
    post(CHANGE_KIND, "check").to(Check.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND).to(DeleteDraftChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "hashtags").to(PostHashtags.class);
    post(CHANGE_KIND, "publish").to(PublishDraftPatchSet.CurrentRevision.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    get(CHANGE_KIND, "submitted_together").to(SubmittedTogether.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "index").to(Index.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    get(CHANGE_KIND, "suggest_reviewers").to(SuggestReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    get(REVISION_KIND, "actions").to(GetRevisionActions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    delete(REVISION_KIND).to(DeleteDraftPatchSet.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    post(REVISION_KIND, "publish").to(PublishDraftPatchSet.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    get(REVISION_KIND, "archive").to(GetArchive.class);
    child(REVISION_KIND, "drafts").to(DraftComments.class);
    put(REVISION_KIND, "drafts").to(CreateDraftComment.class);
    get(DRAFT_COMMENT_KIND).to(GetDraftComment.class);
    put(DRAFT_COMMENT_KIND).to(PutDraftComment.class);
    delete(DRAFT_COMMENT_KIND).to(DeleteDraftComment.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "download").to(DownloadContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    child(CHANGE_KIND, "edit").to(ChangeEdits.class);
    delete(CHANGE_KIND, "edit").to(DeleteChangeEdit.class);
    child(CHANGE_KIND, "edit:publish").to(PublishChangeEdit.class);
    child(CHANGE_KIND, "edit:rebase").to(RebaseChangeEdit.class);
    put(CHANGE_KIND, "edit:message").to(ChangeEdits.EditMessage.class);
    get(CHANGE_KIND, "edit:message").to(ChangeEdits.GetMessage.class);
    put(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Put.class);
    delete(CHANGE_EDIT_KIND).to(ChangeEdits.DeleteContent.class);
    get(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Get.class);
    get(CHANGE_EDIT_KIND, "meta").to(ChangeEdits.GetMeta.class);
    factory(ReviewerResource.Factory.class);
    factory(AccountLoader.Factory.class);
    factory(EmailReviewComments.Factory.class);
    factory(ChangeInserter.Factory.class);
    factory(PatchSetInserter.Factory.class);
    factory(ChangeEdits.Create.Factory.class);
    factory(ChangeEdits.DeleteFile.Factory.class);
}
#end_block

#method_before
public static ServletModule module() {
    return new ServletModule() {

        @Override
        protected void configureServlets() {
            DynamicSet.setOf(binder(), AllRequestFilter.class);
            filter("/*").through(FilterProxy.class);
        }
    };
}
#method_after
public static ServletModule module() {
    return new ServletModule() {

        @Override
        protected void configureServlets() {
            DynamicSet.setOf(binder(), AllRequestFilter.class);
            filter("/*").through(FilterProxy.class);
            bind(StopPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(FilterProxy.class);
        }
    };
}
#end_block

#method_before
@Override
public void doFilter(ServletRequest req, ServletResponse res, final FilterChain last) throws IOException, ServletException {
    final Iterator<AllRequestFilter> itr = filters.iterator();
    new FilterChain() {

        @Override
        public void doFilter(ServletRequest req, ServletResponse res) throws IOException, ServletException {
            if (itr.hasNext()) {
                AllRequestFilter filter = itr.next();
                if (!initializedFilters.contains(filter)) {
                    initFilter(filter);
                }
                filter.doFilter(req, res, this);
            } else {
                last.doFilter(req, res);
            }
        }
    }.doFilter(req, res);
}
#method_after
@Override
public void doFilter(ServletRequest req, ServletResponse res, final FilterChain last) throws IOException, ServletException {
    final Iterator<AllRequestFilter> itr = filters.iterator();
    new FilterChain() {

        @Override
        public void doFilter(ServletRequest req, ServletResponse res) throws IOException, ServletException {
            while (itr.hasNext()) {
                AllRequestFilter filter = itr.next();
                // webrequests.
                if (initializedFilters.contains(filter) || initFilterIfNeeded(filter)) {
                    filter.doFilter(req, res, this);
                    return;
                }
            }
            last.doFilter(req, res);
        }
    }.doFilter(req, res);
}
#end_block

#method_before
@Override
public void init(FilterConfig config) throws ServletException {
    // Plugins that provide AllRequestFilters might get loaded later at
    // runtime, long after this init method had been called. To allow to
    // correctly init such plugins' AllRequestFilters, we keep the
    // FilterConfig around, and reuse it to lazy init the AllRequestFilters.
    filterConfig = config;
    for (AllRequestFilter f : filters) {
        initFilter(f);
    }
}
#method_after
@Override
public void init(FilterConfig config) throws ServletException {
    // Plugins that provide AllRequestFilters might get loaded later at
    // runtime, long after this init method had been called. To allow to
    // correctly init such plugins' AllRequestFilters, we keep the
    // FilterConfig around, and reuse it to lazy init the AllRequestFilters.
    filterConfig = config;
    for (AllRequestFilter f : filters) {
        initFilterIfNeeded(f);
    }
}
#end_block

#method_before
@Override
public void destroy() {
    for (AllRequestFilter f : filters) {
        f.destroy();
    }
}
#method_after
@Override
public synchronized void destroy() {
    Iterable<AllRequestFilter> filtersToDestroy = initializedFilters;
    initializedFilters = new DynamicSet<>();
    for (AllRequestFilter filter : filtersToDestroy) {
        filter.destroy();
    }
}
#end_block

#method_before
private void addFilter(final AllRequestFilter filter) {
    filters.add(filter);
}
#method_after
private ReloadableRegistrationHandle<AllRequestFilter> addFilter(final AllRequestFilter filter) {
    Key<AllRequestFilter> key = Key.get(AllRequestFilter.class);
    return filters.add(key, Providers.of(filter));
}
#end_block

#method_before
// Plugin enablement --------------------------------------------------------
public boolean isEnabled(Event event) {
    if (event instanceof PatchSetCreatedEvent) {
        PatchSetCreatedEvent e = (PatchSetCreatedEvent) event;
        return isEnabled(e.change.project, e.getRefName());
    } else if (event instanceof CommentAddedEvent) {
        CommentAddedEvent e = (CommentAddedEvent) event;
        return isEnabled(e.change.project, e.getRefName());
    } else if (event instanceof ChangeMergedEvent) {
        ChangeMergedEvent e = (ChangeMergedEvent) event;
        return isEnabled(e.change.project, e.getRefName());
    } else if (event instanceof ChangeAbandonedEvent) {
        ChangeAbandonedEvent e = (ChangeAbandonedEvent) event;
        return isEnabled(e.change.project, e.getRefName());
    } else if (event instanceof ChangeRestoredEvent) {
        ChangeRestoredEvent e = (ChangeRestoredEvent) event;
        return isEnabled(e.change.project, e.getRefName());
    } else if (event instanceof DraftPublishedEvent) {
        DraftPublishedEvent e = (DraftPublishedEvent) event;
        return isEnabled(e.change.project, e.getRefName());
    } else if (event instanceof RefUpdatedEvent) {
        RefUpdatedEvent e = (RefUpdatedEvent) event;
        return isEnabled(e.refUpdate.project, e.refUpdate.refName);
    } else {
        log.debug("Event " + event.getType() + " not recognised and ignored");
        return false;
    }
}
#method_after
// Plugin enablement --------------------------------------------------------
public boolean isEnabled(Event event) {
    if (event instanceof PatchSetCreatedEvent) {
        PatchSetCreatedEvent e = (PatchSetCreatedEvent) event;
        return isEnabled(e.change.project, e.getRefName());
    } else if (event instanceof CommentAddedEvent) {
        CommentAddedEvent e = (CommentAddedEvent) event;
        return isEnabled(e.change.project, e.getRefName());
    } else if (event instanceof ChangeMergedEvent) {
        ChangeMergedEvent e = (ChangeMergedEvent) event;
        return isEnabled(e.change.project, e.getRefName());
    } else if (event instanceof ChangeAbandonedEvent) {
        ChangeAbandonedEvent e = (ChangeAbandonedEvent) event;
        return isEnabled(e.change.project, e.getRefName());
    } else if (event instanceof ChangeRestoredEvent) {
        ChangeRestoredEvent e = (ChangeRestoredEvent) event;
        return isEnabled(e.change.project, e.getRefName());
    } else if (event instanceof DraftPublishedEvent) {
        DraftPublishedEvent e = (DraftPublishedEvent) event;
        return isEnabled(e.change.project, e.getRefName());
    } else if (event instanceof RefUpdatedEvent) {
        RefUpdatedEvent e = (RefUpdatedEvent) event;
        return isEnabled(e.refUpdate.project, e.refUpdate.refName);
    } else {
        log.debug("Event " + event + " not recognised and ignored");
        return false;
    }
}
#end_block

#method_before
public void testIsIgnoredTopicChangedEvent() {
    TopicChangedEvent event = new TopicChangedEvent();
    ItsConfig itsConfig = createItsConfig();
    replayMocks();
    assertFalse(itsConfig.isEnabled(event));
    assertLogMessageContains("Event " + event.getType() + " not recognised and ignored");
}
#method_after
public void testIsIgnoredTopicChangedEvent() {
    TopicChangedEvent event = new TopicChangedEvent();
    ItsConfig itsConfig = createItsConfig();
    replayMocks();
    assertFalse(itsConfig.isEnabled(event));
    assertLogMessageContains("not recognised and ignored");
}
#end_block

#method_before
@Test
public void constructorCreateDir() throws IOException {
    Path testtDir = Paths.get("tmp");
    flatFileWebSessionCache = new FlatFileWebSessionCache(testtDir);
    assertThat(Files.exists(testtDir)).isTrue();
    Files.deleteIfExists(testtDir);
}
#method_after
@Test
public void constructorCreateDir() throws IOException {
    Path testDir = Paths.get("tmp");
    flatFileWebSessionCache = new FlatFileWebSessionCache(testDir);
    assertThat(Files.exists(testDir)).isTrue();
    Files.deleteIfExists(testDir);
}
#end_block

#method_before
@Test
public void invalidateTest() throws Exception {
    Path fileToDelete = Files.createFile(dir.resolve(key));
    assertThat(Files.exists(fileToDelete));
    flatFileWebSessionCache.invalidate(key);
    assertThat(Files.notExists(fileToDelete));
}
#method_after
@Test
public void invalidateTest() throws Exception {
    Path fileToDelete = Files.createFile(dir.resolve(key));
    assertThat(Files.exists(fileToDelete)).isTrue();
    flatFileWebSessionCache.invalidate(key);
    assertThat(Files.exists(fileToDelete)).isFalse();
}
#end_block

#method_before
@Test
public void invalidateTestObjectNotString() throws Exception {
    flatFileWebSessionCache.invalidate(new Object());
}
#method_after
@Test
public void invalidateTestObjectNotString() throws Exception {
    createKeysCollection();
    assertThat(flatFileWebSessionCache.size()).isEqualTo(DEFAULT_KEYS_SIZE);
    flatFileWebSessionCache.invalidate(new Object());
    assertThat(flatFileWebSessionCache.size()).isEqualTo(DEFAULT_KEYS_SIZE);
}
#end_block

#method_before
@Test
public void putAllTest() throws Exception {
    loadExistingKeyToCacheDir();
    Val val = flatFileWebSessionCache.getIfPresent(existingKey);
    String newKey = "abcde12345";
    Map<String, Val> sessions = new HashMap<>();
    sessions.put(newKey, val);
    flatFileWebSessionCache.putAll(sessions);
    assertThat(flatFileWebSessionCache.asMap()).containsKey(newKey);
}
#method_after
@Test
public void putAllTest() throws Exception {
    loadExistingKeyToCacheDir();
    Val val = flatFileWebSessionCache.getIfPresent(existingKey);
    String newKey = "abcde12345";
    Map<String, Val> sessions = ImmutableMap.of(newKey, val);
    flatFileWebSessionCache.putAll(sessions);
    assertThat(flatFileWebSessionCache.asMap()).containsKey(newKey);
}
#end_block

#method_before
private InputStream loadFile(String file) {
    return ClassLoader.getSystemResourceAsStream(file);
}
#method_after
private InputStream loadFile(String file) {
    return this.getClass().getResourceAsStream("/" + file);
}
#end_block

#method_before
public static Term idTerm(Change.Id id) {
    return intTerm(ID_FIELD, id.get());
}
#method_after
public static Term idTerm(Schema<ChangeData> schema, ChangeData cd) {
    return intTerm(idField(schema).getName(), cd.getId().get());
}
#end_block

#method_before
private SearcherFactory newSearcherFactory() {
    if (useDocValuesForSorting) {
        return new SearcherFactory();
    }
    final Map<String, UninvertingReader.Type> mapping = ImmutableMap.of(ChangeField.LEGACY_ID2.getName(), UninvertingReader.Type.INTEGER, ChangeField.UPDATED.getName(), UninvertingReader.Type.LONG);
    return new SearcherFactory() {

        @Override
        public IndexSearcher newSearcher(IndexReader reader, IndexReader previousReader) throws IOException {
            checkState(reader instanceof DirectoryReader, "expected DirectoryReader, found %s", reader.getClass().getName());
            return new IndexSearcher(UninvertingReader.wrap((DirectoryReader) reader, mapping));
        }
    };
}
#method_after
private SearcherFactory newSearcherFactory() {
    if (useDocValuesForSorting) {
        return new SearcherFactory();
    }
    @SuppressWarnings("deprecation")
    final Map<String, UninvertingReader.Type> mapping = ImmutableMap.of(ChangeField.LEGACY_ID.getName(), UninvertingReader.Type.INTEGER, ChangeField.UPDATED.getName(), UninvertingReader.Type.LONG);
    return new SearcherFactory() {

        @Override
        public IndexSearcher newSearcher(IndexReader reader, IndexReader previousReader) throws IOException {
            checkState(reader instanceof DirectoryReader, "expected DirectoryReader, found %s", reader.getClass().getName());
            return new IndexSearcher(UninvertingReader.wrap((DirectoryReader) reader, mapping));
        }
    };
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public void replace(ChangeData cd) throws IOException {
    Term id = QueryBuilder.idTerm(cd);
    Document doc = toDocument(cd);
    try {
        if (cd.change().getStatus().isOpen()) {
            Futures.allAsList(closedIndex.delete(id), openIndex.replace(id, doc)).get();
        } else {
            Futures.allAsList(openIndex.delete(id), closedIndex.replace(id, doc)).get();
        }
    } catch (OrmException | ExecutionException | InterruptedException e) {
        throw new IOException(e);
    }
}
#method_after
@Override
public void replace(ChangeData cd) throws IOException {
    Term id = QueryBuilder.idTerm(schema, cd);
    Document doc = toDocument(cd);
    try {
        if (cd.change().getStatus().isOpen()) {
            Futures.allAsList(closedIndex.delete(id), openIndex.replace(id, doc)).get();
        } else {
            Futures.allAsList(openIndex.delete(id), closedIndex.replace(id, doc)).get();
        }
    } catch (OrmException | ExecutionException | InterruptedException e) {
        throw new IOException(e);
    }
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public void delete(Change.Id id) throws IOException {
    Term idTerm = QueryBuilder.idTerm(id);
    try {
        Futures.allAsList(openIndex.delete(idTerm), closedIndex.delete(idTerm)).get();
    } catch (ExecutionException | InterruptedException e) {
        throw new IOException(e);
    }
}
#method_after
@Override
public void delete(Change.Id id) throws IOException {
    Term idTerm = QueryBuilder.idTerm(schema, id);
    try {
        Futures.allAsList(openIndex.delete(idTerm), closedIndex.delete(idTerm)).get();
    } catch (ExecutionException | InterruptedException e) {
        throw new IOException(e);
    }
}
#end_block

#method_before
private Sort getSort() {
    if (useDocValuesForSorting) {
        return new Sort(new SortField(UPDATED_SORT_FIELD, SortField.Type.LONG, true), new SortField(ID_SORT_FIELD, SortField.Type.LONG, true));
    } else {
        return new Sort(new SortField(ChangeField.UPDATED.getName(), SortField.Type.LONG, true), new SortField(ChangeField.LEGACY_ID2.getName(), SortField.Type.INT, true));
    }
}
#method_after
@SuppressWarnings("deprecation")
private Sort getSort() {
    if (useDocValuesForSorting) {
        return new Sort(new SortField(UPDATED_SORT_FIELD, SortField.Type.LONG, true), new SortField(idSortField, SortField.Type.LONG, true));
    } else {
        return new Sort(new SortField(ChangeField.UPDATED.getName(), SortField.Type.LONG, true), new SortField(ChangeField.LEGACY_ID.getName(), SortField.Type.INT, true));
    }
}
#end_block

#method_before
private void add(Document doc, Values<ChangeData> values) {
    String name = values.getField().getName();
    FieldType<?> type = values.getField().getType();
    Store store = store(values.getField());
    if (useDocValuesForSorting) {
        if (values.getField() == ChangeField.LEGACY_ID2) {
            int v = (Integer) getOnlyElement(values.getValues());
            doc.add(new NumericDocValuesField(ID_SORT_FIELD, v));
        } else if (values.getField() == ChangeField.UPDATED) {
            long t = ((Timestamp) getOnlyElement(values.getValues())).getTime();
            doc.add(new NumericDocValuesField(UPDATED_SORT_FIELD, t));
        }
    }
    if (type == FieldType.INTEGER || type == FieldType.INTEGER_RANGE) {
        for (Object value : values.getValues()) {
            doc.add(new IntField(name, (Integer) value, store));
        }
    } else if (type == FieldType.LONG) {
        for (Object value : values.getValues()) {
            doc.add(new LongField(name, (Long) value, store));
        }
    } else if (type == FieldType.TIMESTAMP) {
        for (Object value : values.getValues()) {
            doc.add(new LongField(name, ((Timestamp) value).getTime(), store));
        }
    } else if (type == FieldType.EXACT || type == FieldType.PREFIX) {
        for (Object value : values.getValues()) {
            doc.add(new StringField(name, (String) value, store));
        }
    } else if (type == FieldType.FULL_TEXT) {
        for (Object value : values.getValues()) {
            doc.add(new TextField(name, (String) value, store));
        }
    } else if (type == FieldType.STORED_ONLY) {
        for (Object value : values.getValues()) {
            doc.add(new StoredField(name, (byte[]) value));
        }
    } else {
        throw FieldType.badFieldType(type);
    }
}
#method_after
@SuppressWarnings("deprecation")
private void add(Document doc, Values<ChangeData> values) {
    String name = values.getField().getName();
    FieldType<?> type = values.getField().getType();
    Store store = store(values.getField());
    if (useDocValuesForSorting) {
        FieldDef<ChangeData, ?> f = values.getField();
        if (f == ChangeField.LEGACY_ID || f == ChangeField.LEGACY_ID2) {
            int v = (Integer) getOnlyElement(values.getValues());
            doc.add(new NumericDocValuesField(sortFieldName(f), v));
        } else if (f == ChangeField.UPDATED) {
            long t = ((Timestamp) getOnlyElement(values.getValues())).getTime();
            doc.add(new NumericDocValuesField(UPDATED_SORT_FIELD, t));
        }
    }
    if (type == FieldType.INTEGER || type == FieldType.INTEGER_RANGE) {
        for (Object value : values.getValues()) {
            doc.add(new IntField(name, (Integer) value, store));
        }
    } else if (type == FieldType.LONG) {
        for (Object value : values.getValues()) {
            doc.add(new LongField(name, (Long) value, store));
        }
    } else if (type == FieldType.TIMESTAMP) {
        for (Object value : values.getValues()) {
            doc.add(new LongField(name, ((Timestamp) value).getTime(), store));
        }
    } else if (type == FieldType.EXACT || type == FieldType.PREFIX) {
        for (Object value : values.getValues()) {
            doc.add(new StringField(name, (String) value, store));
        }
    } else if (type == FieldType.FULL_TEXT) {
        for (Object value : values.getValues()) {
            doc.add(new TextField(name, (String) value, store));
        }
    } else if (type == FieldType.STORED_ONLY) {
        for (Object value : values.getValues()) {
            doc.add(new StoredField(name, (byte[]) value));
        }
    } else {
        throw FieldType.badFieldType(type);
    }
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    showSiteHeader = new CheckBox(Util.C.showSiteHeader());
    copySelfOnEmails = new CheckBox(Util.C.copySelfOnEmails());
    maximumPageSize = new ListBox();
    for (final short v : PAGESIZE_CHOICES) {
        maximumPageSize.addItem(Util.M.rowsPerPage(v), String.valueOf(v));
    }
    reviewCategoryStrategy = new ListBox();
    reviewCategoryStrategy.addItem(Util.C.messageShowInReviewCategoryNone(), AccountGeneralPreferences.ReviewCategoryStrategy.NONE.name());
    reviewCategoryStrategy.addItem(Util.C.messageShowInReviewCategoryName(), AccountGeneralPreferences.ReviewCategoryStrategy.NAME.name());
    reviewCategoryStrategy.addItem(Util.C.messageShowInReviewCategoryEmail(), AccountGeneralPreferences.ReviewCategoryStrategy.EMAIL.name());
    reviewCategoryStrategy.addItem(Util.C.messageShowInReviewCategoryUsername(), AccountGeneralPreferences.ReviewCategoryStrategy.USERNAME.name());
    reviewCategoryStrategy.addItem(Util.C.messageShowInReviewCategoryAbbrev(), AccountGeneralPreferences.ReviewCategoryStrategy.ABBREV.name());
    diffView = new ListBox();
    diffView.addItem(com.google.gerrit.client.changes.Util.C.sideBySide(), AccountGeneralPreferences.DiffView.SIDE_BY_SIDE.name());
    diffView.addItem(com.google.gerrit.client.changes.Util.C.unifiedDiff(), AccountGeneralPreferences.DiffView.UNIFIED_DIFF.name());
    Date now = new Date();
    dateFormat = new ListBox();
    for (AccountGeneralPreferences.DateFormat fmt : AccountGeneralPreferences.DateFormat.values()) {
        StringBuilder r = new StringBuilder();
        r.append(DateTimeFormat.getFormat(fmt.getShortFormat()).format(now));
        r.append(" ; ");
        r.append(DateTimeFormat.getFormat(fmt.getLongFormat()).format(now));
        dateFormat.addItem(r.toString(), fmt.name());
    }
    timeFormat = new ListBox();
    for (AccountGeneralPreferences.TimeFormat fmt : AccountGeneralPreferences.TimeFormat.values()) {
        StringBuilder r = new StringBuilder();
        r.append(DateTimeFormat.getFormat(fmt.getFormat()).format(now));
        timeFormat.addItem(r.toString(), fmt.name());
    }
    FlowPanel dateTimePanel = new FlowPanel();
    final int labelIdx;
    final int fieldIdx;
    if (LocaleInfo.getCurrentLocale().isRTL()) {
        labelIdx = 1;
        fieldIdx = 0;
        dateTimePanel.add(timeFormat);
        dateTimePanel.add(dateFormat);
    } else {
        labelIdx = 0;
        fieldIdx = 1;
        dateTimePanel.add(dateFormat);
        dateTimePanel.add(timeFormat);
    }
    relativeDateInChangeTable = new CheckBox(Util.C.showRelativeDateInChangeTable());
    sizeBarInChangeTable = new CheckBox(Util.C.showSizeBarInChangeTable());
    legacycidInChangeTable = new CheckBox(Util.C.showLegacycidInChangeTable());
    muteCommonPathPrefixes = new CheckBox(Util.C.muteCommonPathPrefixes());
    final Grid formGrid = new Grid(11, 2);
    int row = 0;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, showSiteHeader);
    row++;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, copySelfOnEmails);
    row++;
    formGrid.setText(row, labelIdx, Util.C.reviewCategoryLabel());
    formGrid.setWidget(row, fieldIdx, reviewCategoryStrategy);
    row++;
    formGrid.setText(row, labelIdx, Util.C.maximumPageSizeFieldLabel());
    formGrid.setWidget(row, fieldIdx, maximumPageSize);
    row++;
    formGrid.setText(row, labelIdx, Util.C.dateFormatLabel());
    formGrid.setWidget(row, fieldIdx, dateTimePanel);
    row++;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, relativeDateInChangeTable);
    row++;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, sizeBarInChangeTable);
    row++;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, legacycidInChangeTable);
    row++;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, muteCommonPathPrefixes);
    row++;
    formGrid.setText(row, labelIdx, Util.C.diffViewLabel());
    formGrid.setWidget(row, fieldIdx, diffView);
    add(formGrid);
    save = new Button(Util.C.buttonSaveChanges());
    save.setEnabled(false);
    save.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doSave();
        }
    });
    myMenus = new MyMenuPanel(save);
    add(myMenus);
    add(save);
    final OnEditEnabler e = new OnEditEnabler(save);
    e.listenTo(showSiteHeader);
    e.listenTo(copySelfOnEmails);
    e.listenTo(maximumPageSize);
    e.listenTo(dateFormat);
    e.listenTo(timeFormat);
    e.listenTo(relativeDateInChangeTable);
    e.listenTo(sizeBarInChangeTable);
    e.listenTo(legacycidInChangeTable);
    e.listenTo(muteCommonPathPrefixes);
    e.listenTo(diffView);
    e.listenTo(reviewCategoryStrategy);
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    showSiteHeader = new CheckBox(Util.C.showSiteHeader());
    useFlashClipboard = new CheckBox(Util.C.useFlashClipboard());
    copySelfOnEmails = new CheckBox(Util.C.copySelfOnEmails());
    maximumPageSize = new ListBox();
    for (final short v : PAGESIZE_CHOICES) {
        maximumPageSize.addItem(Util.M.rowsPerPage(v), String.valueOf(v));
    }
    reviewCategoryStrategy = new ListBox();
    reviewCategoryStrategy.addItem(Util.C.messageShowInReviewCategoryNone(), AccountGeneralPreferences.ReviewCategoryStrategy.NONE.name());
    reviewCategoryStrategy.addItem(Util.C.messageShowInReviewCategoryName(), AccountGeneralPreferences.ReviewCategoryStrategy.NAME.name());
    reviewCategoryStrategy.addItem(Util.C.messageShowInReviewCategoryEmail(), AccountGeneralPreferences.ReviewCategoryStrategy.EMAIL.name());
    reviewCategoryStrategy.addItem(Util.C.messageShowInReviewCategoryUsername(), AccountGeneralPreferences.ReviewCategoryStrategy.USERNAME.name());
    reviewCategoryStrategy.addItem(Util.C.messageShowInReviewCategoryAbbrev(), AccountGeneralPreferences.ReviewCategoryStrategy.ABBREV.name());
    diffView = new ListBox();
    diffView.addItem(com.google.gerrit.client.changes.Util.C.sideBySide(), AccountGeneralPreferences.DiffView.SIDE_BY_SIDE.name());
    diffView.addItem(com.google.gerrit.client.changes.Util.C.unifiedDiff(), AccountGeneralPreferences.DiffView.UNIFIED_DIFF.name());
    Date now = new Date();
    dateFormat = new ListBox();
    for (AccountGeneralPreferences.DateFormat fmt : AccountGeneralPreferences.DateFormat.values()) {
        StringBuilder r = new StringBuilder();
        r.append(DateTimeFormat.getFormat(fmt.getShortFormat()).format(now));
        r.append(" ; ");
        r.append(DateTimeFormat.getFormat(fmt.getLongFormat()).format(now));
        dateFormat.addItem(r.toString(), fmt.name());
    }
    timeFormat = new ListBox();
    for (AccountGeneralPreferences.TimeFormat fmt : AccountGeneralPreferences.TimeFormat.values()) {
        StringBuilder r = new StringBuilder();
        r.append(DateTimeFormat.getFormat(fmt.getFormat()).format(now));
        timeFormat.addItem(r.toString(), fmt.name());
    }
    FlowPanel dateTimePanel = new FlowPanel();
    final int labelIdx;
    final int fieldIdx;
    if (LocaleInfo.getCurrentLocale().isRTL()) {
        labelIdx = 1;
        fieldIdx = 0;
        dateTimePanel.add(timeFormat);
        dateTimePanel.add(dateFormat);
    } else {
        labelIdx = 0;
        fieldIdx = 1;
        dateTimePanel.add(dateFormat);
        dateTimePanel.add(timeFormat);
    }
    relativeDateInChangeTable = new CheckBox(Util.C.showRelativeDateInChangeTable());
    sizeBarInChangeTable = new CheckBox(Util.C.showSizeBarInChangeTable());
    legacycidInChangeTable = new CheckBox(Util.C.showLegacycidInChangeTable());
    muteCommonPathPrefixes = new CheckBox(Util.C.muteCommonPathPrefixes());
    boolean flashClippy = !UserAgent.hasJavaScriptClipboard() && UserAgent.Flash.isInstalled();
    final Grid formGrid = new Grid(10 + (flashClippy ? 1 : 0), 2);
    int row = 0;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, showSiteHeader);
    row++;
    if (flashClippy) {
        formGrid.setText(row, labelIdx, "");
        formGrid.setWidget(row, fieldIdx, useFlashClipboard);
        row++;
    }
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, copySelfOnEmails);
    row++;
    formGrid.setText(row, labelIdx, Util.C.reviewCategoryLabel());
    formGrid.setWidget(row, fieldIdx, reviewCategoryStrategy);
    row++;
    formGrid.setText(row, labelIdx, Util.C.maximumPageSizeFieldLabel());
    formGrid.setWidget(row, fieldIdx, maximumPageSize);
    row++;
    formGrid.setText(row, labelIdx, Util.C.dateFormatLabel());
    formGrid.setWidget(row, fieldIdx, dateTimePanel);
    row++;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, relativeDateInChangeTable);
    row++;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, sizeBarInChangeTable);
    row++;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, legacycidInChangeTable);
    row++;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, muteCommonPathPrefixes);
    row++;
    formGrid.setText(row, labelIdx, Util.C.diffViewLabel());
    formGrid.setWidget(row, fieldIdx, diffView);
    add(formGrid);
    save = new Button(Util.C.buttonSaveChanges());
    save.setEnabled(false);
    save.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doSave();
        }
    });
    myMenus = new MyMenuPanel(save);
    add(myMenus);
    add(save);
    final OnEditEnabler e = new OnEditEnabler(save);
    e.listenTo(showSiteHeader);
    e.listenTo(useFlashClipboard);
    e.listenTo(copySelfOnEmails);
    e.listenTo(maximumPageSize);
    e.listenTo(dateFormat);
    e.listenTo(timeFormat);
    e.listenTo(relativeDateInChangeTable);
    e.listenTo(sizeBarInChangeTable);
    e.listenTo(legacycidInChangeTable);
    e.listenTo(muteCommonPathPrefixes);
    e.listenTo(diffView);
    e.listenTo(reviewCategoryStrategy);
}
#end_block

#method_before
private void enable(final boolean on) {
    showSiteHeader.setEnabled(on);
    copySelfOnEmails.setEnabled(on);
    maximumPageSize.setEnabled(on);
    dateFormat.setEnabled(on);
    timeFormat.setEnabled(on);
    relativeDateInChangeTable.setEnabled(on);
    sizeBarInChangeTable.setEnabled(on);
    legacycidInChangeTable.setEnabled(on);
    muteCommonPathPrefixes.setEnabled(on);
    reviewCategoryStrategy.setEnabled(on);
    diffView.setEnabled(on);
}
#method_after
private void enable(final boolean on) {
    showSiteHeader.setEnabled(on);
    useFlashClipboard.setEnabled(on);
    copySelfOnEmails.setEnabled(on);
    maximumPageSize.setEnabled(on);
    dateFormat.setEnabled(on);
    timeFormat.setEnabled(on);
    relativeDateInChangeTable.setEnabled(on);
    sizeBarInChangeTable.setEnabled(on);
    legacycidInChangeTable.setEnabled(on);
    muteCommonPathPrefixes.setEnabled(on);
    reviewCategoryStrategy.setEnabled(on);
    diffView.setEnabled(on);
}
#end_block

#method_before
private void display(Preferences p) {
    showSiteHeader.setValue(p.showSiteHeader());
    copySelfOnEmails.setValue(p.copySelfOnEmail());
    setListBox(maximumPageSize, DEFAULT_PAGESIZE, p.changesPerPage());
    setListBox(// 
    dateFormat, // 
    AccountGeneralPreferences.DateFormat.STD, p.dateFormat());
    setListBox(// 
    timeFormat, // 
    AccountGeneralPreferences.TimeFormat.HHMM_12, p.timeFormat());
    relativeDateInChangeTable.setValue(p.relativeDateInChangeTable());
    sizeBarInChangeTable.setValue(p.sizeBarInChangeTable());
    legacycidInChangeTable.setValue(p.legacycidInChangeTable());
    muteCommonPathPrefixes.setValue(p.muteCommonPathPrefixes());
    setListBox(reviewCategoryStrategy, AccountGeneralPreferences.ReviewCategoryStrategy.NONE, p.reviewCategoryStrategy());
    setListBox(diffView, AccountGeneralPreferences.DiffView.SIDE_BY_SIDE, p.diffView());
    display(p.my());
}
#method_after
private void display(Preferences p) {
    showSiteHeader.setValue(p.showSiteHeader());
    useFlashClipboard.setValue(p.useFlashClipboard());
    copySelfOnEmails.setValue(p.copySelfOnEmail());
    setListBox(maximumPageSize, DEFAULT_PAGESIZE, p.changesPerPage());
    setListBox(// 
    dateFormat, // 
    AccountGeneralPreferences.DateFormat.STD, p.dateFormat());
    setListBox(// 
    timeFormat, // 
    AccountGeneralPreferences.TimeFormat.HHMM_12, p.timeFormat());
    relativeDateInChangeTable.setValue(p.relativeDateInChangeTable());
    sizeBarInChangeTable.setValue(p.sizeBarInChangeTable());
    legacycidInChangeTable.setValue(p.legacycidInChangeTable());
    muteCommonPathPrefixes.setValue(p.muteCommonPathPrefixes());
    setListBox(reviewCategoryStrategy, AccountGeneralPreferences.ReviewCategoryStrategy.NONE, p.reviewCategoryStrategy());
    setListBox(diffView, AccountGeneralPreferences.DiffView.SIDE_BY_SIDE, p.diffView());
    display(p.my());
}
#end_block

#method_before
private void doSave() {
    final AccountGeneralPreferences p = new AccountGeneralPreferences();
    p.setShowSiteHeader(showSiteHeader.getValue());
    p.setCopySelfOnEmails(copySelfOnEmails.getValue());
    p.setMaximumPageSize(getListBox(maximumPageSize, DEFAULT_PAGESIZE));
    p.setDateFormat(getListBox(dateFormat, AccountGeneralPreferences.DateFormat.STD, AccountGeneralPreferences.DateFormat.values()));
    p.setTimeFormat(getListBox(timeFormat, AccountGeneralPreferences.TimeFormat.HHMM_12, AccountGeneralPreferences.TimeFormat.values()));
    p.setRelativeDateInChangeTable(relativeDateInChangeTable.getValue());
    p.setSizeBarInChangeTable(sizeBarInChangeTable.getValue());
    p.setLegacycidInChangeTable(legacycidInChangeTable.getValue());
    p.setMuteCommonPathPrefixes(muteCommonPathPrefixes.getValue());
    p.setReviewCategoryStrategy(getListBox(reviewCategoryStrategy, ReviewCategoryStrategy.NONE, ReviewCategoryStrategy.values()));
    p.setDiffView(getListBox(diffView, AccountGeneralPreferences.DiffView.SIDE_BY_SIDE, AccountGeneralPreferences.DiffView.values()));
    enable(false);
    save.setEnabled(false);
    List<TopMenuItem> items = new ArrayList<>();
    for (List<String> v : myMenus.getValues()) {
        items.add(TopMenuItem.create(v.get(0), v.get(1)));
    }
    AccountApi.self().view("preferences").put(Preferences.create(p, items), new GerritCallback<Preferences>() {

        @Override
        public void onSuccess(Preferences prefs) {
            Gerrit.getUserAccount().setGeneralPreferences(p);
            Gerrit.applyUserPreferences();
            enable(true);
            display(prefs);
            Gerrit.refreshMenuBar();
        }

        @Override
        public void onFailure(Throwable caught) {
            enable(true);
            save.setEnabled(true);
            super.onFailure(caught);
        }
    });
}
#method_after
private void doSave() {
    final AccountGeneralPreferences p = new AccountGeneralPreferences();
    p.setShowSiteHeader(showSiteHeader.getValue());
    p.setUseFlashClipboard(useFlashClipboard.getValue());
    p.setCopySelfOnEmails(copySelfOnEmails.getValue());
    p.setMaximumPageSize(getListBox(maximumPageSize, DEFAULT_PAGESIZE));
    p.setDateFormat(getListBox(dateFormat, AccountGeneralPreferences.DateFormat.STD, AccountGeneralPreferences.DateFormat.values()));
    p.setTimeFormat(getListBox(timeFormat, AccountGeneralPreferences.TimeFormat.HHMM_12, AccountGeneralPreferences.TimeFormat.values()));
    p.setRelativeDateInChangeTable(relativeDateInChangeTable.getValue());
    p.setSizeBarInChangeTable(sizeBarInChangeTable.getValue());
    p.setLegacycidInChangeTable(legacycidInChangeTable.getValue());
    p.setMuteCommonPathPrefixes(muteCommonPathPrefixes.getValue());
    p.setReviewCategoryStrategy(getListBox(reviewCategoryStrategy, ReviewCategoryStrategy.NONE, ReviewCategoryStrategy.values()));
    p.setDiffView(getListBox(diffView, AccountGeneralPreferences.DiffView.SIDE_BY_SIDE, AccountGeneralPreferences.DiffView.values()));
    enable(false);
    save.setEnabled(false);
    List<TopMenuItem> items = new ArrayList<>();
    for (List<String> v : myMenus.getValues()) {
        items.add(TopMenuItem.create(v.get(0), v.get(1)));
    }
    AccountApi.self().view("preferences").put(Preferences.create(p, items), new GerritCallback<Preferences>() {

        @Override
        public void onSuccess(Preferences prefs) {
            Gerrit.getUserAccount().setGeneralPreferences(p);
            Gerrit.applyUserPreferences();
            enable(true);
            display(prefs);
            Gerrit.refreshMenuBar();
        }

        @Override
        public void onFailure(Throwable caught) {
            enable(true);
            save.setEnabled(true);
            super.onFailure(caught);
        }
    });
}
#end_block

#method_before
public void merge(ReviewDb db, ChangeSet changes, IdentifiedUser caller, boolean checkPermissions) throws NoSuchChangeException, OrmException, ResourceConflictException {
    logPrefix = String.format("[%s]: ", String.valueOf(changes.hashCode()));
    this.db = db;
    logDebug("Beginning merge of {}", changes);
    try {
        ChangeSet cs = mergeSuperSet.completeChangeSet(db, changes);
        logDebug("Calculated to merge {}", cs);
        if (checkPermissions) {
            logDebug("Checking permissions");
            checkPermissions(cs);
        }
        try {
            integrateIntoHistory(cs, caller);
        } catch (MergeException e) {
            logError("Merge Conflict", e);
            throw new ResourceConflictException("Merge Conflict", e);
        }
    } catch (IOException e) {
        // Anything before the merge attempt is an error
        throw new OrmException(e);
    }
}
#method_after
public void merge(ReviewDb db, ChangeSet changes, IdentifiedUser caller, boolean checkSubmitRules) throws NoSuchChangeException, OrmException, ResourceConflictException {
    logPrefix = String.format("[%s]: ", String.valueOf(changes.hashCode()));
    this.db = db;
    logDebug("Beginning merge of {}", changes);
    try {
        ChangeSet cs = mergeSuperSet.completeChangeSet(db, changes);
        logDebug("Calculated to merge {}", cs);
        if (checkSubmitRules) {
            logDebug("Checking submit rules and state");
            checkSubmitRulesAndState(cs);
        }
        try {
            integrateIntoHistory(cs, caller);
        } catch (MergeException e) {
            logError("Merge Conflict", e);
            throw new ResourceConflictException("Merge Conflict", e);
        }
    } catch (IOException e) {
        // Anything before the merge attempt is an error
        throw new OrmException(e);
    }
}
#end_block

#method_before
private void setMerged(Change c, ChangeMessage msg, ObjectId mergeResultRev) throws OrmException, IOException {
    logDebug("Setting change {} merged", c.getId());
    ChangeUpdate update = null;
    final PatchSetApproval submitter;
    PatchSet merged;
    try {
        db.changes().beginTransaction(c.getId());
        // We must pull the patchset out of commits, because the patchset ID is
        // modified when using the cherry-pick merge strategy.
        CodeReviewCommit commit = commits.get(c.getId());
        PatchSet.Id mergedId = commit.change().currentPatchSetId();
        merged = db.patchSets().get(mergedId);
        c = setMergedPatchSet(c.getId(), mergedId);
        submitter = approvalsUtil.getSubmitter(db, commit.notes(), mergedId);
        ChangeControl control = commit.getControl();
        update = updateFactory.create(control, c.getLastUpdatedOn());
        // did this in the past.
        if (msg != null) {
            cmUtil.addChangeMessage(db, update, msg);
        }
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    final Change change = c;
    try {
        threadScoper.scope(new Callable<Void>() {

            @Override
            public Void call() throws Exception {
                sendMergedEmail(change, submitter);
                return null;
            }
        }).call();
    } catch (Exception e) {
        logError("internal server error", e);
    }
    indexer.index(db, c);
    if (submitter != null && mergeResultRev != null) {
        try {
            hooks.doChangeMergedHook(c, accountCache.get(submitter.getAccountId()).getAccount(), merged, db, mergeResultRev.name());
        } catch (OrmException ex) {
            logError("Cannot run hook for submitted patch set " + c.getId(), ex);
        }
    }
}
#method_after
private void setMerged(Change c, ChangeMessage msg, ObjectId mergeResultRev) throws OrmException, IOException {
    logDebug("Setting change {} merged", c.getId());
    ChangeUpdate update = null;
    final PatchSetApproval submitter;
    PatchSet merged;
    try {
        db.changes().beginTransaction(c.getId());
        // We must pull the patchset out of commits, because the patchset ID is
        // modified when using the cherry-pick merge strategy.
        CodeReviewCommit commit = commits.get(c.getId());
        PatchSet.Id mergedId = commit.change().currentPatchSetId();
        merged = db.patchSets().get(mergedId);
        c = setMergedPatchSet(c.getId(), mergedId);
        submitter = approvalsUtil.getSubmitter(db, commit.notes(), mergedId);
        ChangeControl control = commit.getControl();
        update = updateFactory.create(control, c.getLastUpdatedOn());
        // did this in the past.
        if (msg != null) {
            cmUtil.addChangeMessage(db, update, msg);
        }
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    indexer.index(db, c);
    try {
        mergedSenderFactory.create(c.getId(), submitter != null ? submitter.getAccountId() : null).sendAsync();
    } catch (Exception e) {
        log.error("Cannot email merged notification for " + c.getId(), e);
    }
    if (submitter != null && mergeResultRev != null) {
        try {
            hooks.doChangeMergedHook(c, accountCache.get(submitter.getAccountId()).getAccount(), merged, db, mergeResultRev.name());
        } catch (OrmException ex) {
            logError("Cannot run hook for submitted patch set " + c.getId(), ex);
        }
    }
}
#end_block

#method_before
public static final Set<String> plugins() {
    return Natives.keys(screens());
}
#method_after
public static final Set<String> plugins() {
    return Natives.keys(settingsScreens());
}
#end_block

#method_before
private static void admin(String token) {
    GWT.runAsync(new AsyncSplit(token) {

        @Override
        public void onSuccess() {
            if (matchExact(ADMIN_GROUPS, token) || matchExact("/admin/groups", token)) {
                Gerrit.display(token, new GroupListScreen());
            } else if (matchPrefix(ADMIN_GROUPS, token)) {
                String rest = skip(token);
                if (rest.startsWith("?")) {
                    Gerrit.display(token, new GroupListScreen(rest.substring(1)));
                } else {
                    group();
                }
            } else if (matchPrefix("/admin/groups", token)) {
                String rest = skip(token);
                if (rest.startsWith("?")) {
                    Gerrit.display(token, new GroupListScreen(rest.substring(1)));
                }
            } else if (matchExact(ADMIN_PROJECTS, token) || matchExact("/admin/projects", token)) {
                Gerrit.display(token, new ProjectListScreen());
            } else if (matchPrefix(ADMIN_PROJECTS, token)) {
                String rest = skip(token);
                if (rest.startsWith("?")) {
                    Gerrit.display(token, new ProjectListScreen(rest.substring(1)));
                } else {
                    Gerrit.display(token, selectProject());
                }
            } else if (matchPrefix("/admin/projects", token)) {
                String rest = skip(token);
                if (rest.startsWith("?")) {
                    Gerrit.display(token, new ProjectListScreen(rest.substring(1)));
                }
            } else if (matchPrefix(ADMIN_PLUGINS, token) || matchExact("/admin/plugins", token)) {
                Gerrit.display(token, new PluginListScreen());
            } else if (matchExact(ADMIN_CREATE_PROJECT, token) || matchExact("/admin/create-project", token)) {
                Gerrit.display(token, new CreateProjectScreen());
            } else if (matchExact(ADMIN_CREATE_GROUP, token) || matchExact("/admin/create-group", token)) {
                Gerrit.display(token, new CreateGroupScreen());
            } else {
                Gerrit.display(token, new NotFoundScreen());
            }
        }

        private void group() {
            final String panel;
            final String group;
            if (matchPrefix("/admin/groups/uuid-", token)) {
                String p = skip(token);
                int c = p.indexOf(',');
                if (c < 0) {
                    group = p;
                    panel = null;
                } else {
                    group = p.substring(0, c);
                    panel = p.substring(c + 1);
                }
            } else if (matchPrefix(ADMIN_GROUPS, token)) {
                String p = skip(token);
                int c = p.indexOf(',');
                if (c < 0) {
                    group = p;
                    panel = null;
                } else {
                    group = p.substring(0, c);
                    panel = p.substring(c + 1);
                }
            } else {
                Gerrit.display(token, new NotFoundScreen());
                return;
            }
            GroupApi.getGroupDetail(group, new GerritCallback<GroupInfo>() {

                @Override
                public void onSuccess(GroupInfo group) {
                    if (panel == null || panel.isEmpty()) {
                        // 
                        if (AccountGroup.isInternalGroup(group.getGroupUUID())) {
                            Gerrit.display(toGroup(group.getGroupId(), AccountGroupScreen.MEMBERS), new AccountGroupMembersScreen(group, token));
                        } else {
                            Gerrit.display(toGroup(group.getGroupId(), AccountGroupScreen.INFO), new AccountGroupInfoScreen(group, token));
                        }
                    } else if (AccountGroupScreen.INFO.equals(panel)) {
                        Gerrit.display(token, new AccountGroupInfoScreen(group, token));
                    } else if (AccountGroupScreen.MEMBERS.equals(panel)) {
                        Gerrit.display(token, new AccountGroupMembersScreen(group, token));
                    } else {
                        Gerrit.display(token, new NotFoundScreen());
                    }
                }
            });
        }

        private Screen selectProject() {
            if (matchPrefix(ADMIN_PROJECTS, token)) {
                String rest = skip(token);
                int c = rest.lastIndexOf(',');
                if (c < 0) {
                    return new ProjectInfoScreen(Project.NameKey.parse(rest));
                } else if (c == 0) {
                    return new NotFoundScreen();
                }
                int q = rest.lastIndexOf('?');
                if (q > 0 && rest.lastIndexOf(',', q) > 0) {
                    c = rest.substring(0, q - 1).lastIndexOf(',');
                }
                Project.NameKey k = Project.NameKey.parse(rest.substring(0, c));
                String panel = rest.substring(c + 1);
                if (ProjectScreen.INFO.equals(panel)) {
                    return new ProjectInfoScreen(k);
                }
                if (ProjectScreen.BRANCH.equals(panel) || matchPrefix(ProjectScreen.BRANCH, panel)) {
                    return new ProjectBranchesScreen(k);
                }
                if (ProjectScreen.ACCESS.equals(panel)) {
                    return new ProjectAccessScreen(k);
                }
                if (ProjectScreen.DASHBOARDS.equals(panel)) {
                    return new ProjectDashboardsScreen(k);
                }
            }
            return new NotFoundScreen();
        }
    });
}
#method_after
private static void admin(String token) {
    GWT.runAsync(new AsyncSplit(token) {

        @Override
        public void onSuccess() {
            if (matchExact(ADMIN_GROUPS, token) || matchExact("/admin/groups", token)) {
                Gerrit.display(token, new GroupListScreen());
            } else if (matchPrefix(ADMIN_GROUPS, token)) {
                String rest = skip(token);
                if (rest.startsWith("?")) {
                    Gerrit.display(token, new GroupListScreen(rest.substring(1)));
                } else {
                    group();
                }
            } else if (matchPrefix("/admin/groups", token)) {
                String rest = skip(token);
                if (rest.startsWith("?")) {
                    Gerrit.display(token, new GroupListScreen(rest.substring(1)));
                }
            } else if (matchExact(ADMIN_PROJECTS, token) || matchExact("/admin/projects", token)) {
                Gerrit.display(token, new ProjectListScreen());
            } else if (matchPrefix(ADMIN_PROJECTS, token)) {
                String rest = skip(token);
                if (rest.startsWith("?")) {
                    Gerrit.display(token, new ProjectListScreen(rest.substring(1)));
                } else {
                    Gerrit.display(token, selectProject());
                }
            } else if (matchPrefix("/admin/projects", token)) {
                String rest = skip(token);
                if (rest.startsWith("?")) {
                    Gerrit.display(token, new ProjectListScreen(rest.substring(1)));
                }
            } else if (matchPrefix(ADMIN_PLUGINS, token) || matchExact("/admin/plugins", token)) {
                Gerrit.display(token, new PluginListScreen());
            } else if (matchExact(ADMIN_CREATE_PROJECT, token) || matchExact("/admin/create-project", token)) {
                Gerrit.display(token, new CreateProjectScreen());
            } else if (matchExact(ADMIN_CREATE_GROUP, token) || matchExact("/admin/create-group", token)) {
                Gerrit.display(token, new CreateGroupScreen());
            } else {
                Gerrit.display(token, new NotFoundScreen());
            }
        }

        private void group() {
            final String panel;
            final String group;
            if (matchPrefix("/admin/groups/uuid-", token)) {
                String p = skip(token);
                int c = p.indexOf(',');
                if (c < 0) {
                    group = p;
                    panel = null;
                } else {
                    group = p.substring(0, c);
                    panel = p.substring(c + 1);
                }
            } else if (matchPrefix(ADMIN_GROUPS, token)) {
                String p = skip(token);
                int c = p.indexOf(',');
                if (c < 0) {
                    group = p;
                    panel = null;
                } else {
                    group = p.substring(0, c);
                    panel = p.substring(c + 1);
                }
            } else {
                Gerrit.display(token, new NotFoundScreen());
                return;
            }
            GroupApi.getGroupDetail(group, new GerritCallback<GroupInfo>() {

                @Override
                public void onSuccess(GroupInfo group) {
                    if (panel == null || panel.isEmpty()) {
                        // 
                        if (AccountGroup.isInternalGroup(group.getGroupUUID())) {
                            Gerrit.display(toGroup(group.getGroupId(), AccountGroupScreen.MEMBERS), new AccountGroupMembersScreen(group, token));
                        } else {
                            Gerrit.display(toGroup(group.getGroupId(), AccountGroupScreen.INFO), new AccountGroupInfoScreen(group, token));
                        }
                    } else if (AccountGroupScreen.INFO.equals(panel)) {
                        Gerrit.display(token, new AccountGroupInfoScreen(group, token));
                    } else if (AccountGroupScreen.MEMBERS.equals(panel)) {
                        Gerrit.display(token, new AccountGroupMembersScreen(group, token));
                    } else if (AccountGroupScreen.AUDIT_LOG.equals(panel)) {
                        Gerrit.display(token, new AccountGroupAuditLogScreen(group, token));
                    } else {
                        Gerrit.display(token, new NotFoundScreen());
                    }
                }
            });
        }

        private Screen selectProject() {
            if (matchPrefix(ADMIN_PROJECTS, token)) {
                String rest = skip(token);
                int c = rest.lastIndexOf(',');
                if (c < 0) {
                    return new ProjectInfoScreen(Project.NameKey.parse(rest));
                } else if (c == 0) {
                    return new NotFoundScreen();
                }
                int q = rest.lastIndexOf('?');
                if (q > 0 && rest.lastIndexOf(',', q) > 0) {
                    c = rest.substring(0, q - 1).lastIndexOf(',');
                }
                Project.NameKey k = Project.NameKey.parse(rest.substring(0, c));
                String panel = rest.substring(c + 1);
                if (ProjectScreen.INFO.equals(panel)) {
                    return new ProjectInfoScreen(k);
                }
                if (ProjectScreen.BRANCH.equals(panel) || matchPrefix(ProjectScreen.BRANCH, panel)) {
                    return new ProjectBranchesScreen(k);
                }
                if (ProjectScreen.ACCESS.equals(panel)) {
                    return new ProjectAccessScreen(k);
                }
                if (ProjectScreen.DASHBOARDS.equals(panel)) {
                    return new ProjectDashboardsScreen(k);
                }
            }
            return new NotFoundScreen();
        }
    });
}
#end_block

#method_before
public static void init() {
    init0();
    ActionContext.init();
    HtmlTemplate.init();
    Plugin.init();
    addHistoryHook();
}
#method_after
public static void init() {
    init0();
    ActionContext.init();
    HtmlTemplate.init();
    Plugin.init();
}
#end_block

#method_before
@Override
public final String getCommand(DownloadScheme scheme, String project, String ref) {
    if (commandAllowed && isRecognizedScheme(scheme)) {
        String url = scheme.getUrl(project);
        if (url != null && isValidUrl(url)) {
            return getCommand(url, resolveRef(project, ref));
        }
    }
    return null;
}
#method_after
@Override
public final String getCommand(DownloadScheme scheme, String project, String ref) {
    if (commandAllowed && isRecognizedScheme(scheme)) {
        String url = scheme.getUrl(project);
        if (url != null && isValidUrl(url)) {
            if (checkForHiddenChangeRefs) {
                ref = resolveRef(project, ref);
            }
            if (ref != null) {
                return getCommand(url, ref);
            }
        }
    }
    return null;
}
#end_block

#method_before
private String resolveRef(String project, String ref) {
    try (Repository repo = repoManager.openRepository(new Project.NameKey(project))) {
        Config cfg = repo.getConfig();
        if (cfg.getBoolean(UPLOADPACK, KEY_ALLOW_TIP_SHA1_IN_WANT, false) && Arrays.asList(cfg.getStringList(UPLOADPACK, null, KEY_HIDE_REFS)).contains(RefNames.REFS_CHANGES)) {
            ObjectId id = repo.resolve(ref);
            if (id != null) {
                return id.name();
            } else {
                log.error(String.format("Cannot resolve ref %s in project %s.", ref, project));
            }
        }
    } catch (IOException e) {
        log.error(String.format("Missing project: %s", project), e);
    }
    return ref;
}
#method_after
private String resolveRef(String project, String ref) {
    if (project.startsWith("$") || ref.startsWith("$")) {
        // No real value but placeholders are being used.
        return ref;
    }
    try (Repository repo = repoManager.openRepository(new Project.NameKey(project))) {
        Config cfg = repo.getConfig();
        if (cfg.getBoolean(UPLOADPACK, KEY_ALLOW_TIP_SHA1_IN_WANT, false) && Arrays.asList(cfg.getStringList(UPLOADPACK, null, KEY_HIDE_REFS)).contains(RefNames.REFS_CHANGES)) {
            ObjectId id = repo.resolve(ref);
            if (id != null) {
                return id.name();
            } else {
                log.error(String.format("Cannot resolve ref %s in project %s.", ref, project));
                return null;
            }
        } else {
            return ref;
        }
    } catch (RepositoryNotFoundException e) {
        log.error(String.format("Missing project: %s", project), e);
        return null;
    } catch (IOException e) {
        log.error(String.format("Failed to lookup project %s from cache.", project), e);
        return null;
    }
}
#end_block

#method_before
void set(CommentLinkProcessor commentLinkProcessor, ChangeInfo change, String revision) {
    RevisionInfo revInfo = change.revision(revision);
    CommitInfo commit = revInfo.commit();
    commitName.setText(revision);
    idText.setText("Change-Id: " + change.change_id());
    idText.setPreviewText(change.change_id());
    formatLink(commit.author(), authorPanel, authorNameEmail, authorDate, change);
    formatLink(commit.committer(), committerPanel, committerNameEmail, committerDate, change);
    text.setHTML(commentLinkProcessor.apply(new SafeHtmlBuilder().append(commit.message()).linkify()));
    setWebLinks(change, revision, revInfo);
    if (revInfo.commit().parents().length() > 1) {
        mergeCommit.setVisible(true);
    }
    setParents(change.project(), revInfo.commit().parents());
    // display the orange ball i parent has moved on (not current)
    boolean parentNotCurrent = false;
    if (revInfo.has_actions()) {
        NativeMap<ActionInfo> actions = revInfo.actions();
        if (actions.containsKey("rebase")) {
            parentNotCurrent = actions.get("rebase").enabled();
        }
    }
    UIObject.setVisible(parentNotCurrentText, parentNotCurrent);
    parentNotCurrentText.setInnerText(parentNotCurrent ? "\u25CF" : "");
}
#method_after
void set(CommentLinkProcessor commentLinkProcessor, ChangeInfo change, String revision) {
    RevisionInfo revInfo = change.revision(revision);
    CommitInfo commit = revInfo.commit();
    commitName.setText(revision);
    idText.setText("Change-Id: " + change.change_id());
    idText.setPreviewText(change.change_id());
    formatLink(commit.author(), authorPanel, authorNameEmail, authorDate, change);
    formatLink(commit.committer(), committerPanel, committerNameEmail, committerDate, change);
    text.setHTML(commentLinkProcessor.apply(new SafeHtmlBuilder().append(commit.message()).linkify()));
    setWebLinks(change, revision, revInfo);
    if (revInfo.commit().parents().length() > 1) {
        mergeCommit.setVisible(true);
    }
    setParents(change.project(), revInfo.commit().parents());
    // display the orange ball if parent has moved on (not current)
    boolean parentNotCurrent = false;
    if (revInfo.has_actions()) {
        NativeMap<ActionInfo> actions = revInfo.actions();
        if (actions.containsKey("rebase")) {
            parentNotCurrent = actions.get("rebase").enabled();
        }
    }
    UIObject.setVisible(parentNotCurrentText, parentNotCurrent);
    parentNotCurrentText.setInnerText(parentNotCurrent ? "\u25CF" : "");
}
#end_block

#method_before
@Override
protected void configure() {
    final CommandName git = Commands.named("git");
    final CommandName gerrit = Commands.named("gerrit");
    final CommandName logging = Commands.named(gerrit, "logging");
    final CommandName plugin = Commands.named(gerrit, "plugin");
    final CommandName testSubmit = Commands.named(gerrit, "test-submit");
    command(gerrit).toProvider(new DispatchCommandProvider(gerrit));
    command(gerrit, AproposCommand.class);
    command(gerrit, BanCommitCommand.class);
    command(gerrit, CloseConnection.class);
    command(gerrit, FlushCaches.class);
    command(gerrit, ListProjectsCommand.class);
    command(gerrit, ListMembersCommand.class);
    command(gerrit, ListGroupsCommand.class);
    command(gerrit, LsUserRefs.class);
    command(gerrit, Query.class);
    command(gerrit, ShowCaches.class);
    command(gerrit, ShowConnections.class);
    command(gerrit, ShowQueue.class);
    command(gerrit, StreamEvents.class);
    command(gerrit, VersionCommand.class);
    command(gerrit, GarbageCollectionCommand.class);
    command(gerrit, StartIndexer.class);
    command(gerrit, ActivateIndex.class);
    command(gerrit, "plugin").toProvider(new DispatchCommandProvider(plugin));
    command(plugin, PluginLsCommand.class);
    command(plugin, PluginEnableCommand.class);
    command(plugin, PluginInstallCommand.class);
    command(plugin, PluginReloadCommand.class);
    command(plugin, PluginRemoveCommand.class);
    alias(plugin, "add", PluginInstallCommand.class);
    alias(plugin, "rm", PluginRemoveCommand.class);
    command(git).toProvider(new DispatchCommandProvider(git));
    command("ps").to(ShowQueue.class);
    command("kill").to(KillCommand.class);
    command("scp").to(ScpCommand.class);
    // Honor the legacy hyphenated forms as aliases for the non-hyphenated forms
    command("git-upload-pack").to(Commands.key(git, "upload-pack"));
    command(git, "upload-pack").to(Upload.class);
    command("suexec").to(SuExec.class);
    listener().to(ShowCaches.StartupListener.class);
    // The following commands can only be ran on a server in Master mode
    command(gerrit, CreateAccountCommand.class);
    command(gerrit, CreateGroupCommand.class);
    command(gerrit, CreateProjectCommand.class);
    command(gerrit, AdminQueryShell.class);
    if (!slaveMode) {
        command("git-receive-pack").to(Commands.key(git, "receive-pack"));
        command("gerrit-receive-pack").to(Commands.key(git, "receive-pack"));
        command(git, "receive-pack").to(Commands.key(gerrit, "receive-pack"));
        command(gerrit, "test-submit").toProvider(new DispatchCommandProvider(testSubmit));
    }
    command(gerrit, Receive.class);
    command(gerrit, RenameGroupCommand.class);
    command(gerrit, ReviewCommand.class);
    command(gerrit, SetProjectCommand.class);
    command(gerrit, SetReviewersCommand.class);
    command(gerrit, SetMembersCommand.class);
    command(gerrit, CreateBranchCommand.class);
    command(gerrit, SetAccountCommand.class);
    command(gerrit, AdminSetParent.class);
    command(gerrit, CreateAccountCommand.class);
    command(testSubmit, TestSubmitRuleCommand.class);
    command(testSubmit, TestSubmitTypeCommand.class);
    command(logging).toProvider(new DispatchCommandProvider(logging));
    command(logging, SetLoggingLevelCommand.class);
    command(logging, ListLoggingLevelCommand.class);
    alias(logging, "ls", ListLoggingLevelCommand.class);
    alias(logging, "set", SetLoggingLevelCommand.class);
}
#method_after
@Override
protected void configure() {
    final CommandName git = Commands.named("git");
    final CommandName gerrit = Commands.named("gerrit");
    CommandName index = Commands.named(gerrit, "index");
    final CommandName logging = Commands.named(gerrit, "logging");
    final CommandName plugin = Commands.named(gerrit, "plugin");
    final CommandName testSubmit = Commands.named(gerrit, "test-submit");
    command(gerrit).toProvider(new DispatchCommandProvider(gerrit));
    command(gerrit, AproposCommand.class);
    command(gerrit, BanCommitCommand.class);
    command(gerrit, CloseConnection.class);
    command(gerrit, FlushCaches.class);
    command(gerrit, ListProjectsCommand.class);
    command(gerrit, ListMembersCommand.class);
    command(gerrit, ListGroupsCommand.class);
    command(gerrit, LsUserRefs.class);
    command(gerrit, Query.class);
    command(gerrit, ShowCaches.class);
    command(gerrit, ShowConnections.class);
    command(gerrit, ShowQueue.class);
    command(gerrit, StreamEvents.class);
    command(gerrit, VersionCommand.class);
    command(gerrit, GarbageCollectionCommand.class);
    command(index).toProvider(new DispatchCommandProvider(index));
    command(index, IndexActivateCommand.class);
    command(index, IndexStartCommand.class);
    command(gerrit, "plugin").toProvider(new DispatchCommandProvider(plugin));
    command(plugin, PluginLsCommand.class);
    command(plugin, PluginEnableCommand.class);
    command(plugin, PluginInstallCommand.class);
    command(plugin, PluginReloadCommand.class);
    command(plugin, PluginRemoveCommand.class);
    alias(plugin, "add", PluginInstallCommand.class);
    alias(plugin, "rm", PluginRemoveCommand.class);
    command(git).toProvider(new DispatchCommandProvider(git));
    command("ps").to(ShowQueue.class);
    command("kill").to(KillCommand.class);
    command("scp").to(ScpCommand.class);
    // Honor the legacy hyphenated forms as aliases for the non-hyphenated forms
    if (sshEnabled()) {
        command("git-upload-pack").to(Commands.key(git, "upload-pack"));
        command(git, "upload-pack").to(Upload.class);
    }
    command("suexec").to(SuExec.class);
    listener().to(ShowCaches.StartupListener.class);
    // The following commands can only be ran on a server in Master mode
    command(gerrit, CreateAccountCommand.class);
    command(gerrit, CreateGroupCommand.class);
    command(gerrit, CreateProjectCommand.class);
    command(gerrit, AdminQueryShell.class);
    if (!slaveMode) {
        if (sshEnabled()) {
            command("git-receive-pack").to(Commands.key(git, "receive-pack"));
            command("gerrit-receive-pack").to(Commands.key(git, "receive-pack"));
            command(git, "receive-pack").to(Commands.key(gerrit, "receive-pack"));
        }
        command(gerrit, "test-submit").toProvider(new DispatchCommandProvider(testSubmit));
    }
    command(gerrit, Receive.class);
    command(gerrit, RenameGroupCommand.class);
    command(gerrit, ReviewCommand.class);
    command(gerrit, SetProjectCommand.class);
    command(gerrit, SetReviewersCommand.class);
    command(gerrit, SetMembersCommand.class);
    command(gerrit, CreateBranchCommand.class);
    command(gerrit, SetAccountCommand.class);
    command(gerrit, AdminSetParent.class);
    command(gerrit, CreateAccountCommand.class);
    command(testSubmit, TestSubmitRuleCommand.class);
    command(testSubmit, TestSubmitTypeCommand.class);
    command(logging).toProvider(new DispatchCommandProvider(logging));
    command(logging, SetLoggingLevelCommand.class);
    command(logging, ListLoggingLevelCommand.class);
    alias(logging, "ls", ListLoggingLevelCommand.class);
    alias(logging, "set", SetLoggingLevelCommand.class);
}
#end_block

#method_before
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException {
    ui.message("Listing all changes ...");
    SetMultimap<Project.NameKey, Change.Id> openByProject = getOpenChangesByProject(db);
    ui.message("done");
    ui.message("Setting all submitted changes back to new ...");
    int i = 0;
    for (Map.Entry<Project.NameKey, Collection<Change.Id>> e : openByProject.asMap().entrySet()) {
        updateOpenChanges(db, (Set<Change.Id>) e.getValue());
        if (++i % 100 == 0) {
            ui.message("  done " + i + " projects ...");
        }
    }
    ui.message("done");
}
#method_after
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException {
    String cmd = "UPDATE changes SET status = 'n' WHERE status = 's';";
    ui.message("Running " + cmd);
    try (StatementExecutor e = newExecutor(db)) {
        e.execute(cmd);
    }
    ui.message("done");
}
#end_block

#method_before
@Test
public void submitWithMergeIfFastForwardPossible() throws Exception {
    RevCommit oldHead = getRemoteHead();
    PushOneCommit.Result change = createChange();
    submit(change.getChangeId());
    RevCommit head = getRemoteHead();
    assertThat(head.getParentCount()).isEqualTo(2);
    assertThat(head.getParent(0)).isEqualTo(oldHead);
    assertThat(head.getParent(1)).isEqualTo(change.getCommitId());
    assertSubmitter(change.getChangeId(), 1);
}
#method_after
@Test
public void submitWithMergeIfFastForwardPossible() throws Exception {
    RevCommit oldHead = getRemoteHead();
    PushOneCommit.Result change = createChange();
    submit(change.getChangeId());
    RevCommit head = getRemoteHead();
    assertThat(head.getParentCount()).isEqualTo(2);
    assertThat(head.getParent(0)).isEqualTo(oldHead);
    assertThat(head.getParent(1)).isEqualTo(change.getCommitId());
    assertSubmitter(change.getChangeId(), 1);
    assertPersonEquals(admin.getIdent(), head.getAuthorIdent());
    assertPersonEquals(serverIdent.get(), head.getCommitterIdent());
}
#end_block

#method_before
@Test
public void submitMultipleChanges() throws Exception {
    RevCommit initialHead = getRemoteHead();
    testRepo.reset(initialHead);
    PushOneCommit.Result change2 = createChange("Change 2", "b", "b");
    testRepo.reset(initialHead);
    PushOneCommit.Result change3 = createChange("Change 3", "c", "c");
    testRepo.reset(initialHead);
    PushOneCommit.Result change4 = createChange("Change 4", "d", "d");
    approve(change2.getChangeId());
    approve(change3.getChangeId());
    submit(change4.getChangeId());
    List<RevCommit> log = getRemoteLog();
    RevCommit tip = log.get(0);
    assertThat(tip.getParent(1).getShortMessage()).isEqualTo(change4.getCommit().getShortMessage());
    assertThat(tip.getParent(0).getShortMessage()).isEqualTo(initialHead.getShortMessage());
    assertThat(tip.getParent(0).getId()).isEqualTo(initialHead.getId());
    assertNew(change2.getChangeId());
    assertNew(change3.getChangeId());
}
#method_after
@Test
public void submitMultipleChanges() throws Exception {
    RevCommit initialHead = getRemoteHead();
    testRepo.reset(initialHead);
    PushOneCommit.Result change2 = createChange("Change 2", "b", "b");
    testRepo.reset(initialHead);
    PushOneCommit.Result change3 = createChange("Change 3", "c", "c");
    testRepo.reset(initialHead);
    PushOneCommit.Result change4 = createChange("Change 4", "d", "d");
    approve(change2.getChangeId());
    approve(change3.getChangeId());
    submit(change4.getChangeId());
    List<RevCommit> log = getRemoteLog();
    RevCommit tip = log.get(0);
    assertThat(tip.getParent(1).getShortMessage()).isEqualTo(change4.getCommit().getShortMessage());
    assertThat(tip.getParent(0).getShortMessage()).isEqualTo(initialHead.getShortMessage());
    assertThat(tip.getParent(0).getId()).isEqualTo(initialHead.getId());
    assertPersonEquals(admin.getIdent(), tip.getAuthorIdent());
    assertPersonEquals(serverIdent.get(), tip.getCommitterIdent());
    assertNew(change2.getChangeId());
    assertNew(change3.getChangeId());
}
#end_block

#method_before
@Test
public void submitWithFastForward() throws Exception {
    RevCommit oldHead = getRemoteHead();
    PushOneCommit.Result change = createChange();
    submit(change.getChangeId());
    RevCommit head = getRemoteHead();
    assertThat(head.getId()).isEqualTo(change.getCommitId());
    assertThat(head.getParent(0)).isEqualTo(oldHead);
    assertSubmitter(change.getChangeId(), 1);
}
#method_after
@Test
public void submitWithFastForward() throws Exception {
    RevCommit oldHead = getRemoteHead();
    PushOneCommit.Result change = createChange();
    submit(change.getChangeId());
    RevCommit head = getRemoteHead();
    assertThat(head.getId()).isEqualTo(change.getCommitId());
    assertThat(head.getParent(0)).isEqualTo(oldHead);
    assertSubmitter(change.getChangeId(), 1);
    assertPersonEquals(admin.getIdent(), head.getAuthorIdent());
    assertPersonEquals(admin.getIdent(), head.getCommitterIdent());
}
#end_block

#method_before
@Test
public void submitMultipleChanges() throws Exception {
    RevCommit initialHead = getRemoteHead();
    testRepo.reset(initialHead);
    PushOneCommit.Result change2 = createChange("Change 2", "b", "b");
    testRepo.reset(initialHead);
    PushOneCommit.Result change3 = createChange("Change 3", "c", "c");
    testRepo.reset(initialHead);
    PushOneCommit.Result change4 = createChange("Change 4", "d", "d");
    approve(change2.getChangeId());
    approve(change3.getChangeId());
    submit(change4.getChangeId());
    RevCommit tip = getRemoteLog().get(0);
    assertThat(tip.getShortMessage()).isEqualTo(change4.getCommit().getShortMessage());
    assertThat(tip.getParent(0).getId()).isEqualTo(initialHead.getId());
    assertNew(change2.getChangeId());
    assertNew(change3.getChangeId());
}
#method_after
@Test
public void submitMultipleChanges() throws Exception {
    RevCommit initialHead = getRemoteHead();
    testRepo.reset(initialHead);
    PushOneCommit.Result change2 = createChange("Change 2", "b", "b");
    testRepo.reset(initialHead);
    PushOneCommit.Result change3 = createChange("Change 3", "c", "c");
    testRepo.reset(initialHead);
    PushOneCommit.Result change4 = createChange("Change 4", "d", "d");
    // Change 2 stays untouched.
    approve(change2.getChangeId());
    // Change 3 is a fast-forward, no need to merge.
    submit(change3.getChangeId());
    RevCommit tip = getRemoteLog().get(0);
    assertThat(tip.getShortMessage()).isEqualTo(change3.getCommit().getShortMessage());
    assertThat(tip.getParent(0).getId()).isEqualTo(initialHead.getId());
    assertPersonEquals(admin.getIdent(), tip.getAuthorIdent());
    assertPersonEquals(admin.getIdent(), tip.getCommitterIdent());
    // We need to merge change 4.
    submit(change4.getChangeId());
    tip = getRemoteLog().get(0);
    assertThat(tip.getParent(1).getShortMessage()).isEqualTo(change4.getCommit().getShortMessage());
    assertThat(tip.getParent(0).getShortMessage()).isEqualTo(change3.getCommit().getShortMessage());
    assertPersonEquals(admin.getIdent(), tip.getAuthorIdent());
    assertPersonEquals(serverIdent.get(), tip.getCommitterIdent());
    assertNew(change2.getChangeId());
}
#end_block

#method_before
@Test
public void submitChangesAcrossReposBlocked() throws Exception {
    Project.NameKey p1 = createProject("project-where-we-submit");
    Project.NameKey p2 = createProject("project-impacted-via-topic");
    Project.NameKey p3 = createProject("project-impacted-indirectly-via-topic");
    TestRepository<?> repo1 = cloneProject(p1);
    TestRepository<?> repo2 = cloneProject(p2);
    TestRepository<?> repo3 = cloneProject(p3);
    RevCommit initialHead1 = getRemoteHead(p1, "master");
    RevCommit initialHead2 = getRemoteHead(p2, "master");
    RevCommit initialHead3 = getRemoteHead(p3, "master");
    PushOneCommit.Result change1a = createChange(repo1, "master", "An ancestor of the change we want to submit", "a.txt", "1", "dependent-topic");
    PushOneCommit.Result change1b = createChange(repo1, "master", "we're interested to submit this change", "a.txt", "2", "topic-to-submit");
    PushOneCommit.Result change2a = createChange(repo2, "master", "indirection level 2a", "a.txt", "1", "topic-indirect");
    PushOneCommit.Result change2b = createChange(repo2, "master", "should go in with first change", "a.txt", "2", "dependent-topic");
    PushOneCommit.Result change3 = createChange(repo3, "master", "indirection level 2b", "a.txt", "1", "topic-indirect");
    // Create a merge conflict for change3 which is only indirectly related
    // via topics.
    repo3.reset(initialHead3);
    PushOneCommit.Result change3Conflict = createChange(repo3, "master", "conflicting change", "a.txt", "2\n2", "conflicting-topic");
    submit(change3Conflict.getChangeId());
    RevCommit tipConflict = getRemoteLog(p3, "master").get(0);
    assertThat(tipConflict.getShortMessage()).isEqualTo(change3Conflict.getCommit().getShortMessage());
    approve(change1a.getChangeId());
    approve(change2a.getChangeId());
    approve(change2b.getChangeId());
    approve(change3.getChangeId());
    if (isSubmitWholeTopicEnabled()) {
        submitWithConflict(change1b.getChangeId());
    } else {
        submit(change1b.getChangeId());
    }
    RevCommit tip1 = getRemoteLog(p1, "master").get(0);
    RevCommit tip2 = getRemoteLog(p2, "master").get(0);
    RevCommit tip3 = getRemoteLog(p3, "master").get(0);
    if (isSubmitWholeTopicEnabled()) {
        assertThat(tip1.getShortMessage()).isEqualTo(initialHead1.getShortMessage());
        assertThat(tip2.getShortMessage()).isEqualTo(initialHead2.getShortMessage());
        assertThat(tip3.getShortMessage()).isEqualTo(change3Conflict.getCommit().getShortMessage());
    } else {
        assertThat(tip1.getShortMessage()).isEqualTo(change1b.getCommit().getShortMessage());
        assertThat(tip2.getShortMessage()).isEqualTo(initialHead2.getShortMessage());
        assertThat(tip3.getShortMessage()).isEqualTo(change3Conflict.getCommit().getShortMessage());
    }
}
#method_after
@Test
public void submitChangesAcrossReposBlocked() throws Exception {
    Project.NameKey p1 = createProject("project-where-we-submit");
    Project.NameKey p2 = createProject("project-impacted-via-topic");
    Project.NameKey p3 = createProject("project-impacted-indirectly-via-topic");
    TestRepository<?> repo1 = cloneProject(p1);
    TestRepository<?> repo2 = cloneProject(p2);
    TestRepository<?> repo3 = cloneProject(p3);
    RevCommit initialHead1 = getRemoteHead(p1, "master");
    RevCommit initialHead2 = getRemoteHead(p2, "master");
    RevCommit initialHead3 = getRemoteHead(p3, "master");
    PushOneCommit.Result change1a = createChange(repo1, "master", "An ancestor of the change we want to submit", "a.txt", "1", "dependent-topic");
    PushOneCommit.Result change1b = createChange(repo1, "master", "we're interested to submit this change", "a.txt", "2", "topic-to-submit");
    PushOneCommit.Result change2a = createChange(repo2, "master", "indirection level 2a", "a.txt", "1", "topic-indirect");
    PushOneCommit.Result change2b = createChange(repo2, "master", "should go in with first change", "a.txt", "2", "dependent-topic");
    PushOneCommit.Result change3 = createChange(repo3, "master", "indirection level 2b", "a.txt", "1", "topic-indirect");
    // Create a merge conflict for change3 which is only indirectly related
    // via topics.
    repo3.reset(initialHead3);
    PushOneCommit.Result change3Conflict = createChange(repo3, "master", "conflicting change", "a.txt", "2\n2", "conflicting-topic");
    submit(change3Conflict.getChangeId());
    RevCommit tipConflict = getRemoteLog(p3, "master").get(0);
    assertThat(tipConflict.getShortMessage()).isEqualTo(change3Conflict.getCommit().getShortMessage());
    approve(change1a.getChangeId());
    approve(change2a.getChangeId());
    approve(change2b.getChangeId());
    approve(change3.getChangeId());
    if (isSubmitWholeTopicEnabled()) {
        submitWithConflict(change1b.getChangeId());
    } else {
        submit(change1b.getChangeId());
    }
    RevCommit tip1 = getRemoteLog(p1, "master").get(0);
    RevCommit tip2 = getRemoteLog(p2, "master").get(0);
    RevCommit tip3 = getRemoteLog(p3, "master").get(0);
    if (isSubmitWholeTopicEnabled()) {
        assertThat(tip1.getShortMessage()).isEqualTo(initialHead1.getShortMessage());
        assertThat(tip2.getShortMessage()).isEqualTo(initialHead2.getShortMessage());
        assertThat(tip3.getShortMessage()).isEqualTo(change3Conflict.getCommit().getShortMessage());
        assertNoSubmitter(change1a.getChangeId(), 1);
        assertNoSubmitter(change2a.getChangeId(), 1);
        assertNoSubmitter(change2b.getChangeId(), 1);
        assertNoSubmitter(change3.getChangeId(), 1);
    } else {
        assertThat(tip1.getShortMessage()).isEqualTo(change1b.getCommit().getShortMessage());
        assertThat(tip2.getShortMessage()).isEqualTo(initialHead2.getShortMessage());
        assertThat(tip3.getShortMessage()).isEqualTo(change3Conflict.getCommit().getShortMessage());
        assertNoSubmitter(change2a.getChangeId(), 1);
        assertNoSubmitter(change2b.getChangeId(), 1);
        assertNoSubmitter(change3.getChangeId(), 1);
    }
}
#end_block

#method_before
@Test
public void submitWholeTopic() throws Exception {
    assume().that(isSubmitWholeTopicEnabled()).isTrue();
    PushOneCommit.Result change1 = createChange("Change 1", "a.txt", "content", "test-topic");
    PushOneCommit.Result change2 = createChange("Change 2", "b.txt", "content", "test-topic");
    PushOneCommit.Result change3 = createChange("Change 3", "c.txt", "content", "test-topic");
    approve(change1.getChangeId());
    approve(change2.getChangeId());
    approve(change3.getChangeId());
    submit(change3.getChangeId());
    change1.assertChange(Change.Status.MERGED, "test-topic", admin);
    change2.assertChange(Change.Status.MERGED, "test-topic", admin);
    change3.assertChange(Change.Status.MERGED, "test-topic", admin);
    assertSubmitter(change1);
    assertSubmitter(change2);
    assertSubmitter(change3);
}
#method_after
@Test
public void submitWholeTopic() throws Exception {
    assume().that(isSubmitWholeTopicEnabled()).isTrue();
    PushOneCommit.Result change1 = createChange("Change 1", "a.txt", "content", "test-topic");
    PushOneCommit.Result change2 = createChange("Change 2", "b.txt", "content", "test-topic");
    PushOneCommit.Result change3 = createChange("Change 3", "c.txt", "content", "test-topic");
    approve(change1.getChangeId());
    approve(change2.getChangeId());
    approve(change3.getChangeId());
    submit(change3.getChangeId());
    change1.assertChange(Change.Status.MERGED, "test-topic", admin);
    change2.assertChange(Change.Status.MERGED, "test-topic", admin);
    change3.assertChange(Change.Status.MERGED, "test-topic", admin);
    // Check for the exact change to have the correct submitter.
    assertSubmitter(change3);
    // Also check submitters for changes submitted via the topic relationship.
    assertSubmitter(change1);
    assertSubmitter(change2);
}
#end_block

#method_before
protected void assertNew(String changeId) throws Exception {
    ChangeInfo c = get(changeId);
    assertThat(c.status).isEqualTo(ChangeStatus.NEW);
}
#method_after
protected void assertNew(String changeId) throws Exception {
    assertThat(get(changeId).status).isEqualTo(ChangeStatus.NEW);
}
#end_block

#method_before
@Override
public Output apply(RevisionResource rsrc, SubmitInput input) throws AuthException, ResourceConflictException, RepositoryNotFoundException, IOException, OrmException, UnprocessableEntityException {
    input.onBehalfOf = Strings.emptyToNull(input.onBehalfOf);
    if (input.onBehalfOf != null) {
        rsrc = onBehalfOf(rsrc, input);
    }
    ChangeControl control = rsrc.getControl();
    IdentifiedUser caller = (IdentifiedUser) control.getCurrentUser();
    Change change = rsrc.getChange();
    if (input.onBehalfOf == null && !control.canSubmit()) {
        throw new AuthException("submit not permitted");
    } else if (!change.getStatus().isOpen()) {
        throw new ResourceConflictException("change is " + status(change));
    } else if (!ProjectUtil.branchExists(repoManager, change.getDest())) {
        throw new ResourceConflictException(String.format("destination branch \"%s\" not found.", change.getDest().get()));
    } else if (!rsrc.getPatchSet().getId().equals(change.currentPatchSetId())) {
        // TODO Allow submitting non-current revision by changing the current.
        throw new ResourceConflictException(String.format("revision %s is not current revision", rsrc.getPatchSet().getRevision().get()));
    }
    ChangeSet submittedChanges = ChangeSet.create(submit(rsrc, caller, false));
    try {
        mergeOpFactory.create(submittedChanges, caller).merge(true);
        change = dbProvider.get().changes().get(change.getId());
    } catch (NoSuchChangeException e) {
        throw new OrmException("Submission failed", e);
    }
    if (change == null) {
        throw new ResourceConflictException("change is deleted");
    }
    switch(change.getStatus()) {
        case SUBMITTED:
            return new Output(Status.SUBMITTED, change);
        case MERGED:
            return new Output(Status.MERGED, change);
        case NEW:
            ChangeMessage msg = getConflictMessage(rsrc);
            if (msg != null) {
                throw new ResourceConflictException(msg.getMessage());
            }
        // $FALL-THROUGH$
        default:
            throw new ResourceConflictException("change is " + status(change));
    }
}
#method_after
@Override
public Output apply(RevisionResource rsrc, SubmitInput input) throws AuthException, ResourceConflictException, RepositoryNotFoundException, IOException, OrmException, UnprocessableEntityException {
    input.onBehalfOf = Strings.emptyToNull(input.onBehalfOf);
    if (input.onBehalfOf != null) {
        rsrc = onBehalfOf(rsrc, input);
    }
    ChangeControl control = rsrc.getControl();
    IdentifiedUser caller = (IdentifiedUser) control.getCurrentUser();
    Change change = rsrc.getChange();
    if (input.onBehalfOf == null && !control.canSubmit()) {
        throw new AuthException("submit not permitted");
    } else if (!change.getStatus().isOpen()) {
        throw new ResourceConflictException("change is " + status(change));
    } else if (!ProjectUtil.branchExists(repoManager, change.getDest())) {
        throw new ResourceConflictException(String.format("destination branch \"%s\" not found.", change.getDest().get()));
    } else if (!rsrc.getPatchSet().getId().equals(change.currentPatchSetId())) {
        // TODO Allow submitting non-current revision by changing the current.
        throw new ResourceConflictException(String.format("revision %s is not current revision", rsrc.getPatchSet().getRevision().get()));
    }
    List<Change> changes;
    if (submitWholeTopic && !Strings.isNullOrEmpty(change.getTopic())) {
        changes = new ArrayList<>();
        for (ChangeData cd : getChangesByTopic(change.getTopic())) {
            changes.add(cd.change());
        }
    } else {
        changes = Arrays.asList(change);
    }
    ChangeSet submittedChanges = ChangeSet.create(changes);
    try {
        mergeOpProvider.get().merge(submittedChanges, caller, true);
        change = dbProvider.get().changes().get(change.getId());
    } catch (NoSuchChangeException e) {
        throw new OrmException("Submission failed", e);
    }
    if (change == null) {
        throw new ResourceConflictException("change is deleted");
    }
    switch(change.getStatus()) {
        case SUBMITTED:
            return new Output(Status.SUBMITTED, change);
        case MERGED:
            return new Output(Status.MERGED, change);
        case NEW:
            ChangeMessage msg = getConflictMessage(rsrc);
            if (msg != null) {
                throw new ResourceConflictException(msg.getMessage());
            }
        // $FALL-THROUGH$
        default:
            throw new ResourceConflictException("change is " + status(change));
    }
}
#end_block

#method_before
private void checkPermissions(ChangeSet cs) throws ResourceConflictException, OrmException {
    for (Change.Id id : cs.ids()) {
        ChangeData cd = changeDataFactory.create(db, id);
        if (cd.change().getStatus() != Change.Status.NEW && cd.change().getStatus() != Change.Status.SUBMITTED) {
            throw new OrmException("Change " + cd.change().getChangeId() + " is in state " + cd.change().getStatus());
        } else {
            checkSubmitRule(cd);
        }
    }
}
#method_after
private void checkPermissions(ChangeSet cs) throws ResourceConflictException, OrmException {
    for (Change.Id id : cs.ids()) {
        ChangeData cd = changeDataFactory.create(db, id);
        if (cd.change().getStatus() != Change.Status.NEW && cd.change().getStatus() != Change.Status.SUBMITTED) {
            throw new OrmException("Change " + cd.change().getChangeId() + " is in state " + cd.change().getStatus());
        } else {
            records.put(cd.change().getId(), checkSubmitRule(cd));
        }
    }
}
#end_block

#method_before
public void merge(boolean checkPermissions) throws NoSuchChangeException, OrmException, ResourceConflictException {
    logDebug("Beginning merge of {}", changes);
    try {
        openSchema();
        ChangeSet cs = mergeSuperSet.completeChangeSet(db, changes);
        logDebug("Calculated to merge {}", cs);
        if (checkPermissions) {
            logDebug("Submitting all calculated changes while " + "enforcing submit rules");
            submitAllChanges(cs, false);
            logDebug("Checking permissions");
            checkPermissions(cs);
        } else {
            logDebug("Submitting all calculated changes ignoring submit rules");
            submitAllChanges(cs, true);
        }
        try {
            integrateIntoHistory(cs);
        } catch (MergeException e) {
            logError("Merge Conflict", e);
            throw new ResourceConflictException("Merge Conflict", e);
        }
    } catch (IOException e) {
        // Anything before the merge attempt is an error
        throw new OrmException(e);
    } finally {
        if (db != null) {
            db.close();
        }
    }
}
#method_after
public void merge(ChangeSet changes, IdentifiedUser caller, boolean checkPermissions) throws NoSuchChangeException, OrmException, ResourceConflictException {
    logPrefix = String.format("[%s]: ", String.valueOf(changes.hashCode()));
    logDebug("Beginning merge of {}", changes);
    try {
        openSchema();
        ChangeSet cs = mergeSuperSet.completeChangeSet(db, changes);
        logDebug("Calculated to merge {}", cs);
        if (checkPermissions) {
            logDebug("Checking permissions");
            checkPermissions(cs);
        }
        try {
            integrateIntoHistory(cs, caller);
        } catch (MergeException e) {
            logError("Merge Conflict", e);
            throw new ResourceConflictException("Merge Conflict", e);
        }
    } catch (IOException e) {
        // Anything before the merge attempt is an error
        throw new OrmException(e);
    } finally {
        if (db != null) {
            db.close();
        }
    }
}
#end_block

#method_before
private void integrateIntoHistory(ChangeSet cs) throws MergeException, NoSuchChangeException, ResourceConflictException {
    logDebug("Beginning merge attempt on {}", changes);
    Map<Branch.NameKey, ListMultimap<SubmitType, Change>> toSubmit = new HashMap<>();
    try {
        openSchema();
        logDebug("Perform the merges");
        for (Project.NameKey project : cs.projects()) {
            openRepository(project);
            for (Branch.NameKey branch : cs.branchesByProject().get(project)) {
                setDestProject(branch);
                List<ChangeData> cds = new ArrayList<>();
                for (Change.Id id : cs.changesByBranch().get(branch)) {
                    cds.add(changeDataFactory.create(db, id));
                }
                ListMultimap<SubmitType, Change> submitting = validateChangeList(cds);
                toSubmit.put(branch, submitting);
                Set<SubmitType> submitTypes = new HashSet<>(submitting.keySet());
                for (SubmitType submitType : submitTypes) {
                    SubmitStrategy strategy = createStrategy(branch, submitType, getBranchTip(branch));
                    MergeTip mergeTip = preMerge(strategy, submitting.get(submitType), getBranchTip(branch));
                    mergeTips.put(branch, mergeTip);
                    if (submitType != SubmitType.CHERRY_PICK) {
                        // For cherry picking we have relaxed atomic guarantees
                        // as traditionally Gerrit kept going cherry picking if one
                        // failed. We want to keep it for now.
                        updateChangeStatus(submitting.get(submitType), branch, true);
                    }
                }
                inserter.flush();
            }
            closeRepository();
        }
        logDebug("Write out the new branch tips");
        for (Project.NameKey project : cs.projects()) {
            openRepository(project);
            for (Branch.NameKey branch : cs.branchesByProject().get(project)) {
                RefUpdate update = updateBranch(branch);
                pendingRefUpdates.remove(branch);
                setDestProject(branch);
                ListMultimap<SubmitType, Change> submitting = toSubmit.get(branch);
                for (SubmitType submitType : submitting.keySet()) {
                    updateChangeStatus(submitting.get(submitType), branch, false);
                    updateSubscriptions(branch, submitting.get(submitType), getBranchTip(branch));
                }
                if (update != null) {
                    fireRefUpdated(branch, update);
                }
            }
            closeRepository();
        }
        checkState(pendingRefUpdates.isEmpty(), "programmer error: " + "pending ref update list not emptied");
    } catch (NoSuchProjectException noProject) {
        logWarn("Project " + noProject.project() + " no longer exists, " + "abandoning open changes");
        abandonAllOpenChanges(noProject.project());
    } catch (OrmException e) {
        throw new MergeException("Cannot query the database", e);
    } catch (IOException e) {
        throw new MergeException("Cannot query the database", e);
    } finally {
        closeRepository();
    }
}
#method_after
private void integrateIntoHistory(ChangeSet cs, IdentifiedUser caller) throws MergeException, NoSuchChangeException, ResourceConflictException {
    logDebug("Beginning merge attempt on {}", cs);
    Map<Branch.NameKey, ListMultimap<SubmitType, ChangeData>> toSubmit = new HashMap<>();
    try {
        openSchema();
        logDebug("Perform the merges");
        for (Project.NameKey project : cs.projects()) {
            openRepository(project);
            for (Branch.NameKey branch : cs.branchesByProject().get(project)) {
                setDestProject(branch);
                List<ChangeData> cds = new ArrayList<>();
                for (Change.Id id : cs.changesByBranch().get(branch)) {
                    cds.add(changeDataFactory.create(db, id));
                }
                ListMultimap<SubmitType, ChangeData> submitting = validateChangeList(cds);
                toSubmit.put(branch, submitting);
                Set<SubmitType> submitTypes = new HashSet<>(submitting.keySet());
                for (SubmitType submitType : submitTypes) {
                    SubmitStrategy strategy = createStrategy(branch, submitType, getBranchTip(branch), caller);
                    MergeTip mergeTip = preMerge(strategy, submitting.get(submitType), getBranchTip(branch));
                    mergeTips.put(branch, mergeTip);
                    updateChangeStatus(submitting.get(submitType), branch, true, caller);
                }
                inserter.flush();
            }
            closeRepository();
        }
        logDebug("Write out the new branch tips");
        SubmoduleOp subOp = subOpProvider.get();
        for (Project.NameKey project : cs.projects()) {
            openRepository(project);
            for (Branch.NameKey branch : cs.branchesByProject().get(project)) {
                RefUpdate update = updateBranch(branch);
                pendingRefUpdates.remove(branch);
                setDestProject(branch);
                ListMultimap<SubmitType, ChangeData> submitting = toSubmit.get(branch);
                for (SubmitType submitType : submitting.keySet()) {
                    updateChangeStatus(submitting.get(submitType), branch, false, caller);
                    updateSubmoduleSubscriptions(subOp, branch, getBranchTip(branch));
                }
                if (update != null) {
                    fireRefUpdated(branch, update);
                }
            }
            closeRepository();
        }
        updateSuperProjects(subOp, cs.branches());
        checkState(pendingRefUpdates.isEmpty(), "programmer error: " + "pending ref update list not emptied");
    } catch (NoSuchProjectException noProject) {
        logWarn("Project " + noProject.project() + " no longer exists, " + "abandoning open changes");
        abandonAllOpenChanges(noProject.project());
    } catch (OrmException e) {
        throw new MergeException("Cannot query the database", e);
    } catch (IOException e) {
        throw new MergeException("Cannot query the database", e);
    } finally {
        closeRepository();
    }
}
#end_block

#method_before
private MergeTip preMerge(SubmitStrategy strategy, List<Change> submitted, CodeReviewCommit branchTip) throws MergeException {
    logDebug("Running submit strategy {} for {} commits {}", strategy.getClass().getSimpleName(), submitted.size(), submitted);
    List<CodeReviewCommit> toMerge = new ArrayList<>(submitted.size());
    for (Change c : submitted) {
        CodeReviewCommit commit = commits.get(c.getId());
        checkState(commit != null, "commit for %s not found by validateChangeList", c.getId());
        toMerge.add(commit);
    }
    MergeTip mergeTip = strategy.run(branchTip, toMerge);
    refLogIdent = strategy.getRefLogIdent();
    logDebug("Produced {} new commits", strategy.getNewCommits().size());
    commits.putAll(strategy.getNewCommits());
    return mergeTip;
}
#method_after
private MergeTip preMerge(SubmitStrategy strategy, List<ChangeData> submitted, CodeReviewCommit branchTip) throws MergeException, OrmException {
    logDebug("Running submit strategy {} for {} commits {}", strategy.getClass().getSimpleName(), submitted.size(), submitted);
    List<CodeReviewCommit> toMerge = new ArrayList<>(submitted.size());
    for (ChangeData cd : submitted) {
        CodeReviewCommit commit = commits.get(cd.change().getId());
        checkState(commit != null, "commit for %s not found by validateChangeList", cd.change().getId());
        toMerge.add(commit);
    }
    MergeTip mergeTip = strategy.run(branchTip, toMerge);
    refLogIdent = strategy.getRefLogIdent();
    logDebug("Produced {} new commits", strategy.getNewCommits().size());
    commits.putAll(strategy.getNewCommits());
    return mergeTip;
}
#end_block

#method_before
private SubmitStrategy createStrategy(Branch.NameKey destBranch, SubmitType submitType, CodeReviewCommit branchTip) throws MergeException, NoSuchProjectException {
    return submitStrategyFactory.create(submitType, db, repo, rw, inserter, canMergeFlag, getAlreadyAccepted(branchTip), destBranch);
}
#method_after
private SubmitStrategy createStrategy(Branch.NameKey destBranch, SubmitType submitType, CodeReviewCommit branchTip, IdentifiedUser caller) throws MergeException, NoSuchProjectException {
    return submitStrategyFactory.create(submitType, db, repo, rw, inserter, canMergeFlag, getAlreadyAccepted(branchTip), destBranch, caller);
}
#end_block

#method_before
private ListMultimap<SubmitType, Change> validateChangeList(List<ChangeData> submitted) throws MergeException {
    logDebug("Validating {} changes", submitted.size());
    ListMultimap<SubmitType, Change> toSubmit = ArrayListMultimap.create();
    Map<String, Ref> allRefs;
    try {
        allRefs = repo.getRefDatabase().getRefs(ALL);
    } catch (IOException e) {
        throw new MergeException(e.getMessage(), e);
    }
    Set<ObjectId> tips = new HashSet<>();
    for (Ref r : allRefs.values()) {
        tips.add(r.getObjectId());
    }
    for (ChangeData cd : submitted) {
        ChangeControl ctl;
        Change chg;
        try {
            ctl = cd.changeControl();
            // Reload change in case index was stale.
            chg = cd.reloadChange();
        } catch (OrmException e) {
            throw new MergeException("Failed to validate changes", e);
        }
        Change.Id changeId = cd.getId();
        if (chg.getStatus() != Change.Status.SUBMITTED && chg.getStatus() != Change.Status.NEW) {
            logDebug("Change {} is not new or submitted: {}", changeId, chg.getStatus());
            continue;
        }
        if (chg.currentPatchSetId() == null) {
            logError("Missing current patch set on change " + changeId);
            commits.put(changeId, CodeReviewCommit.noPatchSet(ctl));
            toUpdate.add(chg);
            continue;
        }
        PatchSet ps;
        Branch.NameKey destBranch = chg.getDest();
        try {
            ps = cd.currentPatchSet();
        } catch (OrmException e) {
            throw new MergeException("Cannot query the database", e);
        }
        if (ps == null || ps.getRevision() == null || ps.getRevision().get() == null) {
            logError("Missing patch set or revision on change " + changeId);
            commits.put(changeId, CodeReviewCommit.noPatchSet(ctl));
            toUpdate.add(chg);
            continue;
        }
        String idstr = ps.getRevision().get();
        ObjectId id;
        try {
            id = ObjectId.fromString(idstr);
        } catch (IllegalArgumentException iae) {
            logError("Invalid revision on patch set " + ps.getId());
            commits.put(changeId, CodeReviewCommit.noPatchSet(ctl));
            toUpdate.add(chg);
            continue;
        }
        if (!tips.contains(id)) {
            // TODO Technically the proper way to do this test is to use a
            // RevWalk on "$id --not --all" and test for an empty set. But
            // that is way slower than looking for a ref directly pointing
            // at the desired tip. We should always have a ref available.
            // 
            // TODO this is actually an error, the branch is gone but we
            // want to merge the issue. We can't safely do that if the
            // tip is not reachable.
            // 
            logError("Revision " + idstr + " of patch set " + ps.getId() + " is not contained in any ref");
            commits.put(changeId, CodeReviewCommit.revisionGone(ctl));
            toUpdate.add(chg);
            continue;
        }
        CodeReviewCommit commit;
        try {
            commit = (CodeReviewCommit) rw.parseCommit(id);
        } catch (IOException e) {
            logError("Invalid commit " + idstr + " on patch set " + ps.getId(), e);
            commits.put(changeId, CodeReviewCommit.revisionGone(ctl));
            toUpdate.add(chg);
            continue;
        }
        // TODO(dborowitz): Consider putting ChangeData in CodeReviewCommit.
        commit.setControl(ctl);
        commit.setPatchsetId(ps.getId());
        commits.put(changeId, commit);
        MergeValidators mergeValidators = mergeValidatorsFactory.create();
        try {
            mergeValidators.validatePreMerge(repo, commit, destProject, destBranch, ps.getId());
        } catch (MergeValidationException mve) {
            logDebug("Revision {} of patch set {} failed validation: {}", idstr, ps.getId(), mve.getStatus());
            commit.setStatusCode(mve.getStatus());
            toUpdate.add(chg);
            continue;
        }
        SubmitType submitType;
        submitType = getSubmitType(commit.getControl(), ps);
        if (submitType == null) {
            logError("No submit type for revision " + idstr + " of patch set " + ps.getId());
            commit.setStatusCode(CommitMergeStatus.NO_SUBMIT_TYPE);
            toUpdate.add(chg);
            continue;
        }
        commit.add(canMergeFlag);
        toSubmit.put(submitType, chg);
    }
    logDebug("Submitting on this run: {}", toSubmit);
    return toSubmit;
}
#method_after
private ListMultimap<SubmitType, ChangeData> validateChangeList(List<ChangeData> submitted) throws MergeException {
    logDebug("Validating {} changes", submitted.size());
    ListMultimap<SubmitType, ChangeData> toSubmit = ArrayListMultimap.create();
    Map<String, Ref> allRefs;
    try {
        allRefs = repo.getRefDatabase().getRefs(ALL);
    } catch (IOException e) {
        throw new MergeException(e.getMessage(), e);
    }
    Set<ObjectId> tips = new HashSet<>();
    for (Ref r : allRefs.values()) {
        tips.add(r.getObjectId());
    }
    for (ChangeData cd : submitted) {
        ChangeControl ctl;
        Change chg;
        try {
            ctl = cd.changeControl();
            // Reload change in case index was stale.
            chg = cd.reloadChange();
        } catch (OrmException e) {
            throw new MergeException("Failed to validate changes", e);
        }
        Change.Id changeId = cd.getId();
        if (chg.getStatus() != Change.Status.SUBMITTED && chg.getStatus() != Change.Status.NEW) {
            logDebug("Change {} is not new or submitted: {}", changeId, chg.getStatus());
            continue;
        }
        if (chg.currentPatchSetId() == null) {
            logError("Missing current patch set on change " + changeId);
            commits.put(changeId, CodeReviewCommit.noPatchSet(ctl));
            continue;
        }
        PatchSet ps;
        Branch.NameKey destBranch = chg.getDest();
        try {
            ps = cd.currentPatchSet();
        } catch (OrmException e) {
            throw new MergeException("Cannot query the database", e);
        }
        if (ps == null || ps.getRevision() == null || ps.getRevision().get() == null) {
            logError("Missing patch set or revision on change " + changeId);
            commits.put(changeId, CodeReviewCommit.noPatchSet(ctl));
            continue;
        }
        String idstr = ps.getRevision().get();
        ObjectId id;
        try {
            id = ObjectId.fromString(idstr);
        } catch (IllegalArgumentException iae) {
            logError("Invalid revision on patch set " + ps.getId());
            commits.put(changeId, CodeReviewCommit.noPatchSet(ctl));
            continue;
        }
        if (!tips.contains(id)) {
            // TODO Technically the proper way to do this test is to use a
            // RevWalk on "$id --not --all" and test for an empty set. But
            // that is way slower than looking for a ref directly pointing
            // at the desired tip. We should always have a ref available.
            // 
            // TODO this is actually an error, the branch is gone but we
            // want to merge the issue. We can't safely do that if the
            // tip is not reachable.
            // 
            logError("Revision " + idstr + " of patch set " + ps.getId() + " is not contained in any ref");
            commits.put(changeId, CodeReviewCommit.revisionGone(ctl));
            continue;
        }
        CodeReviewCommit commit;
        try {
            commit = (CodeReviewCommit) rw.parseCommit(id);
        } catch (IOException e) {
            logError("Invalid commit " + idstr + " on patch set " + ps.getId(), e);
            commits.put(changeId, CodeReviewCommit.revisionGone(ctl));
            continue;
        }
        // TODO(dborowitz): Consider putting ChangeData in CodeReviewCommit.
        commit.setControl(ctl);
        commit.setPatchsetId(ps.getId());
        commits.put(changeId, commit);
        MergeValidators mergeValidators = mergeValidatorsFactory.create();
        try {
            mergeValidators.validatePreMerge(repo, commit, destProject, destBranch, ps.getId());
        } catch (MergeValidationException mve) {
            logDebug("Revision {} of patch set {} failed validation: {}", idstr, ps.getId(), mve.getStatus());
            commit.setStatusCode(mve.getStatus());
            continue;
        }
        SubmitType submitType;
        submitType = getSubmitType(commit.getControl(), ps);
        if (submitType == null) {
            logError("No submit type for revision " + idstr + " of patch set " + ps.getId());
            commit.setStatusCode(CommitMergeStatus.NO_SUBMIT_TYPE);
            continue;
        }
        commit.add(canMergeFlag);
        toSubmit.put(submitType, cd);
    }
    logDebug("Submitting on this run: {}", toSubmit);
    return toSubmit;
}
#end_block

#method_before
private void updateChangeStatus(List<Change> submitted, Branch.NameKey destBranch, boolean dryRun) throws NoSuchChangeException, MergeException, ResourceConflictException {
    if (!dryRun) {
        logDebug("Updating change status for {} changes", submitted.size());
    } else {
        logDebug("Checking change state for {} changes in a dry run", submitted.size());
    }
    MergeTip mergeTip = mergeTips.get(destBranch);
    for (Change c : submitted) {
        CodeReviewCommit commit = commits.get(c.getId());
        CommitMergeStatus s = commit != null ? commit.getStatusCode() : null;
        if (s == null) {
            // Shouldn't ever happen, but leave the change alone. We'll pick
            // it up on the next pass.
            // 
            logDebug("Submitted change {} did not appear in set of new commits" + " produced by merge strategy", c.getId());
            continue;
        }
        String txt = s.getMessage();
        logDebug("Status of change {} ({}) on {}: {}", c.getId(), commit.name(), c.getDest(), s);
        // If mergeTip is null merge failed and mergeResultRev will not be read.
        ObjectId mergeResultRev = mergeTip != null ? mergeTip.getMergeResults().get(commit) : null;
        try {
            ChangeMessage msg;
            switch(s) {
                case CLEAN_MERGE:
                    if (!dryRun) {
                        setMerged(c, message(c, txt + getByAccountName(commit)), mergeResultRev);
                    }
                    break;
                case CLEAN_REBASE:
                case CLEAN_PICK:
                    if (!dryRun) {
                        setMerged(c, message(c, txt + " as " + commit.name() + getByAccountName(commit)), mergeResultRev);
                    }
                    break;
                case ALREADY_MERGED:
                    if (!dryRun) {
                        setMerged(c, null, mergeResultRev);
                    }
                    break;
                case PATH_CONFLICT:
                case MANUAL_RECURSIVE_MERGE:
                case CANNOT_CHERRY_PICK_ROOT:
                case NOT_FAST_FORWARD:
                case INVALID_PROJECT_CONFIGURATION:
                case INVALID_PROJECT_CONFIGURATION_PLUGIN_VALUE_NOT_PERMITTED:
                case INVALID_PROJECT_CONFIGURATION_PLUGIN_VALUE_NOT_EDITABLE:
                case INVALID_PROJECT_CONFIGURATION_PARENT_PROJECT_NOT_FOUND:
                case INVALID_PROJECT_CONFIGURATION_ROOT_PROJECT_CANNOT_HAVE_PARENT:
                case SETTING_PARENT_PROJECT_ONLY_ALLOWED_BY_ADMIN:
                    setNew(commit.notes(), message(c, txt));
                    throw new ResourceConflictException("Cannot merge " + commit.name() + "\n" + s.getMessage());
                case MISSING_DEPENDENCY:
                    logDebug("Change {} is missing dependency", c.getId());
                    throw new MergeException("Cannot merge " + commit.name() + "\n" + s.getMessage());
                case REVISION_GONE:
                    logDebug("Commit not found for change {}", c.getId());
                    msg = new ChangeMessage(new ChangeMessage.Key(c.getId(), ChangeUtil.messageUUID(db)), null, TimeUtil.nowTs(), c.currentPatchSetId());
                    msg.setMessage("Failed to read commit for this patch set");
                    setNew(commit.notes(), msg);
                    throw new MergeException(msg.getMessage());
                default:
                    msg = message(c, "Unspecified merge failure: " + s.name());
                    setNew(commit.notes(), msg);
                    throw new MergeException(msg.getMessage());
            }
        } catch (OrmException | IOException err) {
            logWarn("Error updating change status for " + c.getId(), err);
        }
    }
}
#method_after
private void updateChangeStatus(List<ChangeData> submitted, Branch.NameKey destBranch, boolean dryRun, IdentifiedUser caller) throws NoSuchChangeException, MergeException, ResourceConflictException, OrmException {
    if (!dryRun) {
        logDebug("Updating change status for {} changes", submitted.size());
    } else {
        logDebug("Checking change state for {} changes in a dry run", submitted.size());
    }
    MergeTip mergeTip = mergeTips.get(destBranch);
    for (ChangeData cd : submitted) {
        Change c = cd.change();
        CodeReviewCommit commit = commits.get(c.getId());
        CommitMergeStatus s = commit != null ? commit.getStatusCode() : null;
        if (s == null) {
            // Shouldn't ever happen, but leave the change alone. We'll pick
            // it up on the next pass.
            // 
            logDebug("Submitted change {} did not appear in set of new commits" + " produced by merge strategy", c.getId());
            continue;
        }
        if (!dryRun) {
            try {
                setApproval(cd, caller);
            } catch (IOException e) {
                throw new OrmException(e);
            }
        }
        String txt = s.getMessage();
        logDebug("Status of change {} ({}) on {}: {}", c.getId(), commit.name(), c.getDest(), s);
        // If mergeTip is null merge failed and mergeResultRev will not be read.
        ObjectId mergeResultRev = mergeTip != null ? mergeTip.getMergeResults().get(commit) : null;
        try {
            ChangeMessage msg;
            switch(s) {
                case CLEAN_MERGE:
                    if (!dryRun) {
                        setMerged(c, message(c, txt + getByAccountName(commit)), mergeResultRev);
                    }
                    break;
                case CLEAN_REBASE:
                case CLEAN_PICK:
                    if (!dryRun) {
                        setMerged(c, message(c, txt + " as " + commit.name() + getByAccountName(commit)), mergeResultRev);
                    }
                    break;
                case ALREADY_MERGED:
                    if (!dryRun) {
                        setMerged(c, null, mergeResultRev);
                    }
                    break;
                case PATH_CONFLICT:
                case MANUAL_RECURSIVE_MERGE:
                case CANNOT_CHERRY_PICK_ROOT:
                case NOT_FAST_FORWARD:
                case INVALID_PROJECT_CONFIGURATION:
                case INVALID_PROJECT_CONFIGURATION_PLUGIN_VALUE_NOT_PERMITTED:
                case INVALID_PROJECT_CONFIGURATION_PLUGIN_VALUE_NOT_EDITABLE:
                case INVALID_PROJECT_CONFIGURATION_PARENT_PROJECT_NOT_FOUND:
                case INVALID_PROJECT_CONFIGURATION_ROOT_PROJECT_CANNOT_HAVE_PARENT:
                case SETTING_PARENT_PROJECT_ONLY_ALLOWED_BY_ADMIN:
                    setNew(commit.notes(), message(c, txt));
                    throw new ResourceConflictException("Cannot merge " + commit.name() + "\n" + s.getMessage());
                case MISSING_DEPENDENCY:
                    logDebug("Change {} is missing dependency", c.getId());
                    throw new MergeException("Cannot merge " + commit.name() + "\n" + s.getMessage());
                case REVISION_GONE:
                    logDebug("Commit not found for change {}", c.getId());
                    msg = new ChangeMessage(new ChangeMessage.Key(c.getId(), ChangeUtil.messageUUID(db)), null, TimeUtil.nowTs(), c.currentPatchSetId());
                    msg.setMessage("Failed to read commit for this patch set");
                    setNew(commit.notes(), msg);
                    throw new MergeException(msg.getMessage());
                default:
                    msg = message(c, "Unspecified merge failure: " + s.name());
                    setNew(commit.notes(), msg);
                    throw new MergeException(msg.getMessage());
            }
        } catch (OrmException | IOException err) {
            logWarn("Error updating change status for " + c.getId(), err);
        }
    }
}
#end_block

#method_before
private void sendMergedEmail(final Change c, final PatchSetApproval from) {
    workQueue.getDefaultQueue().submit(new Runnable() {

        @Override
        public void run() {
            PatchSet patchSet;
            try {
                ReviewDb reviewDb = schemaFactory.open();
                try {
                    patchSet = reviewDb.patchSets().get(c.currentPatchSetId());
                } finally {
                    reviewDb.close();
                }
            } catch (Exception e) {
                logError("Cannot send email for submitted patch set " + c.getId(), e);
                return;
            }
            try {
                MergedSender cm = mergedSenderFactory.create(c.getId());
                if (from != null) {
                    cm.setFrom(from.getAccountId());
                }
                cm.setPatchSet(patchSet);
                cm.send();
            } catch (Exception e) {
                logError("Cannot send email for submitted patch set " + c.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send-email merged";
        }
    });
}
#method_after
private void sendMergedEmail(final Change c, final PatchSetApproval from) {
    workQueue.getDefaultQueue().submit(new Runnable() {

        @Override
        public void run() {
            PatchSet patchSet;
            try (ReviewDb reviewDb = schemaFactory.open()) {
                patchSet = reviewDb.patchSets().get(c.currentPatchSetId());
            } catch (Exception e) {
                logError("Cannot send email for submitted patch set " + c.getId(), e);
                return;
            }
            try {
                MergedSender cm = mergedSenderFactory.create(c.getId());
                if (from != null) {
                    cm.setFrom(from.getAccountId());
                }
                cm.setPatchSet(patchSet);
                cm.send();
            } catch (Exception e) {
                logError("Cannot send email for submitted patch set " + c.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send-email merged";
        }
    });
}
#end_block

#method_before
private void abandonAllOpenChanges(Project.NameKey destProject) throws NoSuchChangeException {
    try {
        openSchema();
        for (ChangeData cd : queryProvider.get().byProjectOpen(destProject)) {
            abandonOneChange(cd.change());
        }
        db.close();
        db = null;
    } catch (IOException | OrmException e) {
        logWarn("Cannot abandon changes for deleted project ", e);
    }
}
#method_after
private void abandonAllOpenChanges(Project.NameKey destProject) throws NoSuchChangeException {
    try {
        openSchema();
        for (ChangeData cd : internalChangeQuery.byProjectOpen(destProject)) {
            abandonOneChange(cd.change());
        }
        db.close();
        db = null;
    } catch (IOException | OrmException e) {
        logWarn("Cannot abandon changes for deleted project ", e);
    }
}
#end_block

#method_before
@Test
public void submitWithCherryPick() throws Exception {
    RevCommit initialHead = getRemoteHead();
    PushOneCommit.Result change = createChange("Change 1", "a.txt", "content");
    submit(change.getChangeId());
    RevCommit oldHead = getRemoteHead();
    testRepo.reset(initialHead);
    PushOneCommit.Result change2 = createChange("Change 2", "b.txt", "other content");
    submit(change2.getChangeId());
    assertCherryPick(testRepo, false);
    RevCommit newHead = getRemoteHead();
    assertThat(newHead.getParentCount()).isEqualTo(1);
    assertThat(newHead.getParent(0)).isEqualTo(oldHead);
    assertCurrentRevision(change2.getChangeId(), 2, newHead);
    assertSubmitter(change2.getChangeId(), 1);
    assertSubmitter(change2.getChangeId(), 2);
}
#method_after
@Test
public void submitWithCherryPick() throws Exception {
    RevCommit initialHead = getRemoteHead();
    PushOneCommit.Result change = createChange("Change 1", "a.txt", "content");
    submit(change.getChangeId());
    RevCommit oldHead = getRemoteHead();
    testRepo.reset(initialHead);
    PushOneCommit.Result change2 = createChange("Change 2", "b.txt", "other content");
    submit(change2.getChangeId());
    assertCherryPick(testRepo, false);
    RevCommit newHead = getRemoteHead();
    assertThat(newHead.getParentCount()).isEqualTo(1);
    assertThat(newHead.getParent(0)).isEqualTo(oldHead);
    assertCurrentRevision(change2.getChangeId(), 2, newHead);
    assertSubmitter(change2.getChangeId(), 1);
    assertSubmitter(change2.getChangeId(), 2);
    assertPersonEquals(admin.getIdent(), newHead.getAuthorIdent());
    assertPersonEquals(admin.getIdent(), newHead.getCommitterIdent());
}
#end_block

#method_before
@Test
@TestProjectInput(useContentMerge = InheritableBoolean.TRUE)
public void submitWithContentMerge_Conflict() throws Exception {
    RevCommit initialHead = getRemoteHead();
    PushOneCommit.Result change = createChange("Change 1", "a.txt", "content");
    submit(change.getChangeId());
    RevCommit oldHead = getRemoteHead();
    testRepo.reset(initialHead);
    PushOneCommit.Result change2 = createChange("Change 2", "a.txt", "other content");
    submitWithConflict(change2.getChangeId());
    assertThat(getRemoteHead()).isEqualTo(oldHead);
    assertCurrentRevision(change2.getChangeId(), 1, change2.getCommitId());
    assertSubmitter(change2.getChangeId(), 1);
}
#method_after
@Test
@TestProjectInput(useContentMerge = InheritableBoolean.TRUE)
public void submitWithContentMerge_Conflict() throws Exception {
    RevCommit initialHead = getRemoteHead();
    PushOneCommit.Result change = createChange("Change 1", "a.txt", "content");
    submit(change.getChangeId());
    RevCommit oldHead = getRemoteHead();
    testRepo.reset(initialHead);
    PushOneCommit.Result change2 = createChange("Change 2", "a.txt", "other content");
    submitWithConflict(change2.getChangeId());
    assertThat(getRemoteHead()).isEqualTo(oldHead);
    assertCurrentRevision(change2.getChangeId(), 1, change2.getCommitId());
    assertNoSubmitter(change2.getChangeId(), 1);
}
#end_block

#method_before
@Test
public void submitOutOfOrder_Conflict() throws Exception {
    RevCommit initialHead = getRemoteHead();
    PushOneCommit.Result change = createChange("Change 1", "a.txt", "content");
    submit(change.getChangeId());
    RevCommit oldHead = getRemoteHead();
    testRepo.reset(initialHead);
    createChange("Change 2", "b.txt", "other content");
    PushOneCommit.Result change3 = createChange("Change 3", "b.txt", "different content");
    submitWithConflict(change3.getChangeId());
    assertThat(getRemoteHead()).isEqualTo(oldHead);
    assertCurrentRevision(change3.getChangeId(), 1, change3.getCommitId());
    assertSubmitter(change3.getChangeId(), 1);
}
#method_after
@Test
public void submitOutOfOrder_Conflict() throws Exception {
    RevCommit initialHead = getRemoteHead();
    PushOneCommit.Result change = createChange("Change 1", "a.txt", "content");
    submit(change.getChangeId());
    RevCommit oldHead = getRemoteHead();
    testRepo.reset(initialHead);
    createChange("Change 2", "b.txt", "other content");
    PushOneCommit.Result change3 = createChange("Change 3", "b.txt", "different content");
    submitWithConflict(change3.getChangeId());
    assertThat(getRemoteHead()).isEqualTo(oldHead);
    assertCurrentRevision(change3.getChangeId(), 1, change3.getCommitId());
    assertNoSubmitter(change3.getChangeId(), 1);
}
#end_block

#method_before
@Test
public void submitDependentConflictingChangesOutOfOrder() throws Exception {
    RevCommit initialHead = getRemoteHead();
    testRepo.reset(initialHead);
    PushOneCommit.Result change2 = createChange("Change 2", "b", "b1");
    PushOneCommit.Result change3 = createChange("Change 3", "b", "b2");
    assertThat(change3.getCommit().getParent(0)).isEqualTo(change2.getCommit());
    // Submit fails; change3 contains the delta "b1" -> "b2", which cannot be
    // applied against tip.
    submitWithConflict(change3.getChangeId());
    ChangeInfo info3 = get(change3.getChangeId(), ListChangesOption.MESSAGES);
    assertThat(info3.status).isEqualTo(ChangeStatus.NEW);
    assertThat(Iterables.getLast(info3.messages).message.toLowerCase()).contains("path conflict");
    // Tip has not changed.
    List<RevCommit> log = getRemoteLog();
    assertThat(log.get(0)).isEqualTo(initialHead.getId());
}
#method_after
@Test
public void submitDependentConflictingChangesOutOfOrder() throws Exception {
    RevCommit initialHead = getRemoteHead();
    testRepo.reset(initialHead);
    PushOneCommit.Result change2 = createChange("Change 2", "b", "b1");
    PushOneCommit.Result change3 = createChange("Change 3", "b", "b2");
    assertThat(change3.getCommit().getParent(0)).isEqualTo(change2.getCommit());
    // Submit fails; change3 contains the delta "b1" -> "b2", which cannot be
    // applied against tip.
    submitWithConflict(change3.getChangeId());
    ChangeInfo info3 = get(change3.getChangeId(), ListChangesOption.MESSAGES);
    assertThat(info3.status).isEqualTo(ChangeStatus.NEW);
    assertThat(Iterables.getLast(info3.messages).message.toLowerCase()).contains("path conflict");
    // Tip has not changed.
    List<RevCommit> log = getRemoteLog();
    assertThat(log.get(0)).isEqualTo(initialHead.getId());
    assertNoSubmitter(change3.getChangeId(), 1);
}
#end_block

#method_before
@Test
public void submitTwoChangesWithFastForward() throws Exception {
    PushOneCommit.Result change = createChange();
    PushOneCommit.Result change2 = createChange();
    approve(change.getChangeId());
    submit(change2.getChangeId());
    RevCommit head = getRemoteHead();
    assertThat(head.getId()).isEqualTo(change2.getCommitId());
    assertThat(head.getParent(0).getId()).isEqualTo(change.getCommitId());
    assertSubmitter(change.getChangeId(), 1);
    assertSubmitter(change2.getChangeId(), 1);
    assertAuthor(head, admin.getIdent());
    assertCommitter(head, admin.getIdent());
}
#method_after
@Test
public void submitTwoChangesWithFastForward() throws Exception {
    PushOneCommit.Result change = createChange();
    PushOneCommit.Result change2 = createChange();
    approve(change.getChangeId());
    submit(change2.getChangeId());
    RevCommit head = getRemoteHead();
    assertThat(head.getId()).isEqualTo(change2.getCommitId());
    assertThat(head.getParent(0).getId()).isEqualTo(change.getCommitId());
    assertSubmitter(change.getChangeId(), 1);
    assertSubmitter(change2.getChangeId(), 1);
    assertPersonEquals(admin.getIdent(), head.getAuthorIdent());
    assertPersonEquals(admin.getIdent(), head.getCommitterIdent());
}
#end_block

#method_before
@Test
public void submitWithCherryPick() throws Exception {
    RevCommit initialHead = getRemoteHead();
    PushOneCommit.Result change = createChange("Change 1", "a.txt", "content");
    submit(change.getChangeId());
    RevCommit oldHead = getRemoteHead();
    testRepo.reset(initialHead);
    PushOneCommit.Result change2 = createChange("Change 2", "b.txt", "other content");
    submit(change2.getChangeId());
    assertCherryPick(testRepo, false);
    RevCommit newHead = getRemoteHead();
    assertThat(newHead.getParentCount()).isEqualTo(1);
    assertThat(newHead.getParent(0)).isEqualTo(oldHead);
    assertCurrentRevision(change2.getChangeId(), 2, newHead);
    assertSubmitter(change2.getChangeId(), 1);
    assertSubmitter(change2.getChangeId(), 2);
    assertAuthor(newHead, admin.getIdent());
// TODO:  "Administrator" != "admin" ?
// assertCommitter(newHead, admin.getIdent());
}
#method_after
@Test
public void submitWithCherryPick() throws Exception {
    RevCommit initialHead = getRemoteHead();
    PushOneCommit.Result change = createChange("Change 1", "a.txt", "content");
    submit(change.getChangeId());
    RevCommit oldHead = getRemoteHead();
    testRepo.reset(initialHead);
    PushOneCommit.Result change2 = createChange("Change 2", "b.txt", "other content");
    submit(change2.getChangeId());
    assertCherryPick(testRepo, false);
    RevCommit newHead = getRemoteHead();
    assertThat(newHead.getParentCount()).isEqualTo(1);
    assertThat(newHead.getParent(0)).isEqualTo(oldHead);
    assertCurrentRevision(change2.getChangeId(), 2, newHead);
    assertSubmitter(change2.getChangeId(), 1);
    assertSubmitter(change2.getChangeId(), 2);
    assertPersonEquals(admin.getIdent(), newHead.getAuthorIdent());
// TODO:  Check the committer, too.
// assertPersonEquals(admin.getIdent(), newHead.getCommitterIdent());
}
#end_block

#method_before
@Test
public void submitWithFastForward() throws Exception {
    RevCommit oldHead = getRemoteHead();
    PushOneCommit.Result change = createChange();
    submit(change.getChangeId());
    RevCommit head = getRemoteHead();
    assertThat(head.getId()).isEqualTo(change.getCommitId());
    assertThat(head.getParent(0)).isEqualTo(oldHead);
    assertSubmitter(change.getChangeId(), 1);
    assertAuthor(head, admin.getIdent());
    assertCommitter(head, admin.getIdent());
}
#method_after
@Test
public void submitWithFastForward() throws Exception {
    RevCommit oldHead = getRemoteHead();
    PushOneCommit.Result change = createChange();
    submit(change.getChangeId());
    RevCommit head = getRemoteHead();
    assertThat(head.getId()).isEqualTo(change.getCommitId());
    assertThat(head.getParent(0)).isEqualTo(oldHead);
    assertSubmitter(change.getChangeId(), 1);
    assertPersonEquals(admin.getIdent(), head.getAuthorIdent());
    assertPersonEquals(admin.getIdent(), head.getCommitterIdent());
}
#end_block

#method_before
@Test
public void submitMultipleChanges() throws Exception {
    RevCommit initialHead = getRemoteHead();
    testRepo.reset(initialHead);
    PushOneCommit.Result change2 = createChange("Change 2", "b", "b");
    testRepo.reset(initialHead);
    PushOneCommit.Result change3 = createChange("Change 3", "c", "c");
    testRepo.reset(initialHead);
    PushOneCommit.Result change4 = createChange("Change 4", "d", "d");
    submitStatusOnly(change2.getChangeId());
    submitStatusOnly(change3.getChangeId());
    submit(change4.getChangeId());
    RevCommit tip = getRemoteLog().get(0);
    assertThat(tip.getParent(1).getShortMessage()).isEqualTo(change4.getCommit().getShortMessage());
    tip = tip.getParent(0);
    assertThat(tip.getParent(1).getShortMessage()).isEqualTo(change3.getCommit().getShortMessage());
    tip = tip.getParent(0);
    assertThat(tip.getShortMessage()).isEqualTo(change2.getCommit().getShortMessage());
    assertThat(tip.getParent(0).getId()).isEqualTo(initialHead.getId());
    RevCommit head = getRemoteHead();
    assertAuthor(head, admin.getIdent());
    assertCommitter(head, serverIdent.get());
}
#method_after
@Test
public void submitMultipleChanges() throws Exception {
    RevCommit initialHead = getRemoteHead();
    testRepo.reset(initialHead);
    PushOneCommit.Result change2 = createChange("Change 2", "b", "b");
    testRepo.reset(initialHead);
    PushOneCommit.Result change3 = createChange("Change 3", "c", "c");
    testRepo.reset(initialHead);
    PushOneCommit.Result change4 = createChange("Change 4", "d", "d");
    submitStatusOnly(change2.getChangeId());
    submitStatusOnly(change3.getChangeId());
    submit(change4.getChangeId());
    RevCommit tip = getRemoteLog().get(0);
    assertThat(tip.getParent(1).getShortMessage()).isEqualTo(change4.getCommit().getShortMessage());
    tip = tip.getParent(0);
    assertThat(tip.getParent(1).getShortMessage()).isEqualTo(change3.getCommit().getShortMessage());
    tip = tip.getParent(0);
    assertThat(tip.getShortMessage()).isEqualTo(change2.getCommit().getShortMessage());
    assertThat(tip.getParent(0).getId()).isEqualTo(initialHead.getId());
    assertPersonEquals(admin.getIdent(), tip.getAuthorIdent());
    assertPersonEquals(admin.getIdent(), tip.getCommitterIdent());
}
#end_block

#method_before
@Test
public void submitWithMergeIfFastForwardPossible() throws Exception {
    RevCommit oldHead = getRemoteHead();
    PushOneCommit.Result change = createChange();
    submit(change.getChangeId());
    RevCommit head = getRemoteHead();
    assertThat(head.getParentCount()).isEqualTo(2);
    assertThat(head.getParent(0)).isEqualTo(oldHead);
    assertThat(head.getParent(1)).isEqualTo(change.getCommitId());
    assertSubmitter(change.getChangeId(), 1);
    assertAuthor(head, admin.getIdent());
    assertCommitter(head, serverIdent.get());
}
#method_after
@Test
public void submitWithMergeIfFastForwardPossible() throws Exception {
    RevCommit oldHead = getRemoteHead();
    PushOneCommit.Result change = createChange();
    submit(change.getChangeId());
    RevCommit head = getRemoteHead();
    assertThat(head.getParentCount()).isEqualTo(2);
    assertThat(head.getParent(0)).isEqualTo(oldHead);
    assertThat(head.getParent(1)).isEqualTo(change.getCommitId());
    assertSubmitter(change.getChangeId(), 1);
    assertPersonEquals(admin.getIdent(), head.getAuthorIdent());
    assertPersonEquals(serverIdent.get(), head.getCommitterIdent());
}
#end_block

#method_before
private void assertMergeCommit(String branch, String subject) throws IOException {
    try (Repository r = repoManager.openRepository(project);
        RevWalk rw = new RevWalk(r)) {
        RevCommit c = rw.parseCommit(r.getRef(branch).getObjectId());
        assertThat(c.getParentCount()).isEqualTo(2);
        assertThat(c.getShortMessage()).isEqualTo("Merge \"" + subject + "\"");
        assertThat(c.getAuthorIdent().getEmailAddress()).isEqualTo(admin.email);
        assertThat(c.getCommitterIdent().getEmailAddress()).isEqualTo(serverIdent.getEmailAddress());
    }
}
#method_after
private void assertMergeCommit(String branch, String subject) throws IOException {
    try (Repository r = repoManager.openRepository(project);
        RevWalk rw = new RevWalk(r)) {
        RevCommit c = rw.parseCommit(r.getRef(branch).getObjectId());
        assertThat(c.getParentCount()).isEqualTo(2);
        assertThat(c.getShortMessage()).isEqualTo("Merge \"" + subject + "\"");
        assertThat(c.getAuthorIdent().getEmailAddress()).isEqualTo(admin.email);
        assertThat(c.getCommitterIdent().getEmailAddress()).isEqualTo(serverIdent.get().getEmailAddress());
    }
}
#end_block

#method_before
@Test
@TestProjectInput(useContentMerge = InheritableBoolean.TRUE)
public void submitWithFastForward() throws Exception {
    RevCommit oldHead = getRemoteHead();
    PushOneCommit.Result change = createChange();
    submit(change.getChangeId());
    RevCommit head = getRemoteHead();
    assertThat(head.getId()).isEqualTo(change.getCommitId());
    assertThat(head.getParent(0)).isEqualTo(oldHead);
    assertApproved(change.getChangeId());
    assertCurrentRevision(change.getChangeId(), 1, head);
    assertSubmitter(change.getChangeId(), 1);
}
#method_after
@Test
@TestProjectInput(useContentMerge = InheritableBoolean.TRUE)
public void submitWithFastForward() throws Exception {
    RevCommit oldHead = getRemoteHead();
    PushOneCommit.Result change = createChange();
    submit(change.getChangeId());
    RevCommit head = getRemoteHead();
    assertThat(head.getId()).isEqualTo(change.getCommitId());
    assertThat(head.getParent(0)).isEqualTo(oldHead);
    assertApproved(change.getChangeId());
    assertCurrentRevision(change.getChangeId(), 1, head);
    assertSubmitter(change.getChangeId(), 1);
    assertPersonEquals(admin.getIdent(), head.getAuthorIdent());
    assertPersonEquals(admin.getIdent(), head.getCommitterIdent());
}
#end_block

#method_before
@Test
@TestProjectInput(useContentMerge = InheritableBoolean.TRUE)
public void submitWithRebase() throws Exception {
    RevCommit initialHead = getRemoteHead();
    PushOneCommit.Result change = createChange("Change 1", "a.txt", "content");
    submit(change.getChangeId());
    RevCommit oldHead = getRemoteHead();
    testRepo.reset(initialHead);
    PushOneCommit.Result change2 = createChange("Change 2", "b.txt", "other content");
    submit(change2.getChangeId());
    assertRebase(testRepo, false);
    RevCommit head = getRemoteHead();
    assertThat(head.getParent(0)).isEqualTo(oldHead);
    assertApproved(change2.getChangeId());
    assertCurrentRevision(change2.getChangeId(), 2, head);
    assertSubmitter(change2.getChangeId(), 1);
    assertSubmitter(change2.getChangeId(), 2);
    assertAuthor(head, admin.getIdent());
    assertCommitter(head, serverIdent.get());
}
#method_after
@Test
@TestProjectInput(useContentMerge = InheritableBoolean.TRUE)
public void submitWithRebase() throws Exception {
    RevCommit initialHead = getRemoteHead();
    PushOneCommit.Result change = createChange("Change 1", "a.txt", "content");
    submit(change.getChangeId());
    RevCommit oldHead = getRemoteHead();
    testRepo.reset(initialHead);
    PushOneCommit.Result change2 = createChange("Change 2", "b.txt", "other content");
    submit(change2.getChangeId());
    assertRebase(testRepo, false);
    RevCommit head = getRemoteHead();
    assertThat(head.getParent(0)).isEqualTo(oldHead);
    assertApproved(change2.getChangeId());
    assertCurrentRevision(change2.getChangeId(), 2, head);
    assertSubmitter(change2.getChangeId(), 1);
    assertSubmitter(change2.getChangeId(), 2);
    assertPersonEquals(admin.getIdent(), head.getAuthorIdent());
    assertPersonEquals(serverIdent.get(), head.getCommitterIdent());
}
#end_block

