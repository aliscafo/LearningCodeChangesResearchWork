1082
#method_before
private void resetState() {
    mAdapterState = AdapterState.IDLE;
    mScrollState = ViewPager2.ScrollState.IDLE;
    mScrollValues.reset();
    mInitialPosition = NO_TARGET;
    mTarget = NO_TARGET;
    mDispatchSelected = false;
    mScrollHappened = false;
}
#method_after
private void resetState() {
    mAdapterState = STATE_IDLE;
    mScrollState = SCROLL_STATE_IDLE;
    mScrollValues.reset();
    mDragStartPosition = NO_POSITION;
    mTarget = NO_POSITION;
    mDispatchSelected = false;
    mScrollHappened = false;
}
#end_block

#method_before
@Override
public void onScrollStateChanged(@NonNull RecyclerView recyclerView, int newState) {
    if (mAdapterState == AdapterState.IDLE && newState == RecyclerView.SCROLL_STATE_DRAGGING) {
        mAdapterState = AdapterState.IN_PROGRESS_MANUAL_DRAG;
        dispatchStateChanged(ViewPager2.ScrollState.DRAGGING);
        mInitialPosition = getPosition();
        return;
    }
    if (mAdapterState == AdapterState.IN_PROGRESS_MANUAL_DRAG && newState == RecyclerView.SCROLL_STATE_SETTLING) {
        if (!mScrollHappened) {
            // Special case of dragging before first (or beyond last) page
            dispatchScrolled(getPosition(), 0f, 0);
        } else {
            dispatchStateChanged(ViewPager2.ScrollState.SETTLING);
            mDispatchSelected = true;
        }
        return;
    }
    if (mAdapterState == AdapterState.IN_PROGRESS_MANUAL_DRAG && newState == RecyclerView.SCROLL_STATE_IDLE) {
        if (!mScrollHappened) {
            // Special case of dragging before first (or beyond last) page
            dispatchStateChanged(ViewPager2.ScrollState.IDLE);
            resetState();
        }
        return;
    }
}
#method_after
@Override
public void onScrollStateChanged(@NonNull RecyclerView recyclerView, int newState) {
    // User started a drag (not dragging -> dragging)
    if (mAdapterState != STATE_IN_PROGRESS_MANUAL_DRAG && newState == RecyclerView.SCROLL_STATE_DRAGGING) {
        // Remember we're performing a drag
        mAdapterState = STATE_IN_PROGRESS_MANUAL_DRAG;
        if (mTarget != NO_POSITION) {
            // Target was set means programmatic scroll was in progress
            // Update "drag start page" to reflect the page that ViewPager2 thinks it is at
            mDragStartPosition = mTarget;
            // Reset target because drags have no target until released
            mTarget = NO_POSITION;
        } else {
            // ViewPager2 was at rest, set "drag start page" to current page
            mDragStartPosition = getPosition();
        }
        dispatchStateChanged(SCROLL_STATE_DRAGGING);
        return;
    }
    // Note that mAdapterState is not updated, to remember we were dragging when settling
    if (mAdapterState == STATE_IN_PROGRESS_MANUAL_DRAG && newState == RecyclerView.SCROLL_STATE_SETTLING) {
        if (!mScrollHappened) {
            // Pages didn't move during drag, so must be at the start or end of the list
            // ViewPager's contract requires at least one scroll event though
            dispatchScrolled(getPosition(), 0f, 0);
        } else {
            dispatchStateChanged(SCROLL_STATE_SETTLING);
            // Determine target page and dispatch onPageSelected on next scroll event
            mDispatchSelected = true;
            // Reset value to recognise if onPageSelected has been fired when going to idle
            mScrollHappened = false;
        }
        return;
    }
    // Drag has settled (dragging && settling -> idle)
    if (mAdapterState == STATE_IN_PROGRESS_MANUAL_DRAG && newState == RecyclerView.SCROLL_STATE_IDLE) {
        if (!mScrollHappened) {
            // Happens if there was no velocity or if it was the first or last page
            if (mDispatchSelected) {
                // Fire onPageSelected when snapped page is different from initial position
                // E.g.: smooth scroll from 0 to 1, interrupt with drag at 0.5, release at 0
                updateScrollEventValues();
                if (mDragStartPosition != mScrollValues.mPosition) {
                    dispatchSelected(mScrollValues.mPosition);
                }
            }
            // Normally idle is fired in onScrolled, but scroll did not happen
            dispatchStateChanged(SCROLL_STATE_IDLE);
            resetState();
        }
        return;
    }
}
#end_block

#method_before
@Override
public void onScrolled(@NonNull RecyclerView recyclerView, int dx, int dy) {
    mScrollHappened = true;
    ScrollEventValues values = updateScrollEventValues();
    if (mDispatchSelected) {
        mDispatchSelected = false;
        mTarget = (dx + dy > 0) ? values.mPosition + 1 : values.mPosition;
        if (mInitialPosition != mTarget) {
            dispatchSelected(mTarget);
        }
    }
    dispatchScrolled(values.mPosition, values.mOffset, values.mOffsetPx);
    if ((values.mPosition == mTarget || mTarget == NO_TARGET) && values.mOffsetPx == 0) {
        dispatchStateChanged(ViewPager2.ScrollState.IDLE);
        resetState();
    }
}
#method_after
@Override
public void onScrolled(@NonNull RecyclerView recyclerView, int dx, int dy) {
    mScrollHappened = true;
    ScrollEventValues values = updateScrollEventValues();
    if (mDispatchSelected) {
        // Drag started settling, need to calculate target page and dispatch onPageSelected now
        mDispatchSelected = false;
        mTarget = (dy > 0 || (dy == 0 && dx < 0 == isLayoutRTL())) ? values.mPosition + 1 : values.mPosition;
        if (mDragStartPosition != mTarget) {
            dispatchSelected(mTarget);
        }
    }
    dispatchScrolled(values.mPosition, values.mOffset, values.mOffsetPx);
    if ((values.mPosition == mTarget || mTarget == NO_POSITION) && values.mOffsetPx == 0 && mScrollState != SCROLL_STATE_DRAGGING) {
        // When the target page is reached and the user is not dragging anymore, we're settled,
        // so go to idle.
        // Special case and a bit of a hack when there is no target: RecyclerView is being
        // initialized and fires a single scroll event. This flags mScrollHappened, so we need
        // to reset our state. However, we don't want to dispatch idle. But that won't happen;
        // because we were already idle.
        dispatchStateChanged(SCROLL_STATE_IDLE);
        resetState();
    }
}
#end_block

#method_before
private ScrollEventValues updateScrollEventValues() {
    ScrollEventValues values = mScrollValues;
    values.mPosition = mLayoutManager.findFirstVisibleItemPosition();
    if (values.mPosition == RecyclerView.NO_POSITION) {
        return values.reset();
    }
    View firstVisibleView = mLayoutManager.findViewByPosition(values.mPosition);
    if (firstVisibleView == null) {
        return values.reset();
    }
    boolean isHorizontal = mLayoutManager.getOrientation() == ViewPager2.Orientation.HORIZONTAL;
    int start, sizePx;
    if (isHorizontal) {
        sizePx = firstVisibleView.getWidth();
        if (!isLayoutRTL()) {
            start = firstVisibleView.getLeft();
        } else {
            start = sizePx - firstVisibleView.getRight();
        }
    } else {
        sizePx = firstVisibleView.getHeight();
        start = firstVisibleView.getTop();
    }
    values.mOffsetPx = -start;
    if (values.mOffsetPx < 0) {
        throw new IllegalStateException(String.format(Locale.US, "Page can only be offset by a " + "positive amount, not by %d", values.mOffsetPx));
    }
    values.mOffset = sizePx == 0 ? 0 : (float) values.mOffsetPx / sizePx;
    return values;
}
#method_after
private ScrollEventValues updateScrollEventValues() {
    ScrollEventValues values = mScrollValues;
    values.mPosition = mLayoutManager.findFirstVisibleItemPosition();
    if (values.mPosition == RecyclerView.NO_POSITION) {
        return values.reset();
    }
    View firstVisibleView = mLayoutManager.findViewByPosition(values.mPosition);
    if (firstVisibleView == null) {
        return values.reset();
    }
    boolean isHorizontal = mLayoutManager.getOrientation() == ORIENTATION_HORIZONTAL;
    int start, sizePx;
    if (isHorizontal) {
        sizePx = firstVisibleView.getWidth();
        if (!isLayoutRTL()) {
            start = firstVisibleView.getLeft();
        } else {
            start = sizePx - firstVisibleView.getRight();
        }
    } else {
        sizePx = firstVisibleView.getHeight();
        start = firstVisibleView.getTop();
    }
    values.mOffsetPx = -start;
    if (values.mOffsetPx < 0) {
        throw new IllegalStateException(String.format(Locale.US, "Page can only be offset by a " + "positive amount, not by %d", values.mOffsetPx));
    }
    values.mOffset = sizePx == 0 ? 0 : (float) values.mOffsetPx / sizePx;
    return values;
}
#end_block

#method_before
public void notifyProgrammaticScroll(int target, boolean smooth) {
    mAdapterState = smooth ? AdapterState.IN_PROGRESS_SMOOTH_SCROLL : AdapterState.IN_PROGRESS_IMMEDIATE_SCROLL;
    mTarget = target;
    dispatchStateChanged(ViewPager2.ScrollState.SETTLING);
    dispatchSelected(target);
}
#method_after
public void notifyProgrammaticScroll(int target, boolean smooth) {
    mAdapterState = smooth ? STATE_IN_PROGRESS_SMOOTH_SCROLL : STATE_IN_PROGRESS_IMMEDIATE_SCROLL;
    boolean hasNewTarget = mTarget != target;
    mTarget = target;
    dispatchStateChanged(SCROLL_STATE_SETTLING);
    if (hasNewTarget) {
        dispatchSelected(target);
    }
}
#end_block

#method_before
public boolean isIdle() {
    return mAdapterState == AdapterState.IDLE;
}
#method_after
public boolean isIdle() {
    return mAdapterState == STATE_IDLE;
}
#end_block

#method_before
private void dispatchStateChanged(@ViewPager2.ScrollState int state) {
    // simplifying the code of the class and enforcing the contract in one place.
    if (mAdapterState == AdapterState.IN_PROGRESS_IMMEDIATE_SCROLL && mScrollState == ViewPager2.ScrollState.IDLE) {
        return;
    }
    if (mScrollState == state) {
        return;
    }
    mScrollState = state;
    if (mListener != null) {
        mListener.onPageScrollStateChanged(state);
    }
}
#method_after
private void dispatchStateChanged(@ScrollState int state) {
    // simplifying the code of the class and enforcing the contract in one place.
    if (mAdapterState == STATE_IN_PROGRESS_IMMEDIATE_SCROLL && mScrollState == SCROLL_STATE_IDLE) {
        return;
    }
    if (mScrollState == state) {
        return;
    }
    mScrollState = state;
    if (mListener != null) {
        mListener.onPageScrollStateChanged(state);
    }
}
#end_block

#method_before
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    logMetricsEvent(MetricsEvent.ACTION_CAPTIVE_PORTAL_LOGIN_ACTIVITY);
    mCm = ConnectivityManager.from(this);
    mNetwork = getIntent().getParcelableExtra(ConnectivityManager.EXTRA_NETWORK);
    mCaptivePortal = getIntent().getParcelableExtra(ConnectivityManager.EXTRA_CAPTIVE_PORTAL);
    mUserAgent = getIntent().getStringExtra(ConnectivityManager.EXTRA_CAPTIVE_PORTAL_USER_AGENT);
    mUrl = getUrl();
    if (mUrl == null) {
        // getUrl() failed to parse the url provided in the intent: bail out in a way that
        // at least provides network access.
        done(Result.WANTED_AS_IS);
        return;
    }
    if (DBG) {
        Log.d(TAG, String.format("onCreate for %s", mUrl.toString()));
    }
    // Also initializes proxy system properties.
    mCm.bindProcessToNetwork(mNetwork);
    // Proxy system properties must be initialized before setContentView is called because
    // setContentView initializes the WebView logic which in turn reads the system properties.
    setContentView(R.layout.activity_captive_portal_login);
    // Exit app if Network disappears.
    final NetworkCapabilities networkCapabilities = mCm.getNetworkCapabilities(mNetwork);
    if (networkCapabilities == null) {
        finishAndRemoveTask();
        return;
    }
    mNetworkCallback = new NetworkCallback() {

        @Override
        public void onLost(Network lostNetwork) {
            if (mNetwork.equals(lostNetwork))
                done(Result.UNWANTED);
        }
    };
    final NetworkRequest.Builder builder = new NetworkRequest.Builder();
    for (int transportType : networkCapabilities.getTransportTypes()) {
        builder.addTransportType(transportType);
    }
    mCm.registerNetworkCallback(builder.build(), mNetworkCallback);
    getActionBar().setDisplayShowHomeEnabled(false);
    // remove shadow
    getActionBar().setElevation(0);
    getActionBar().setTitle(getHeaderTitle());
    getActionBar().setSubtitle("");
    final WebView webview = getWebview();
    webview.clearCache(true);
    WebSettings webSettings = webview.getSettings();
    webSettings.setJavaScriptEnabled(true);
    webSettings.setMixedContentMode(WebSettings.MIXED_CONTENT_COMPATIBILITY_MODE);
    webSettings.setUseWideViewPort(true);
    webSettings.setLoadWithOverviewMode(true);
    webSettings.setSupportZoom(true);
    webSettings.setBuiltInZoomControls(true);
    webSettings.setDisplayZoomControls(false);
    mWebViewClient = new MyWebViewClient();
    webview.setWebViewClient(mWebViewClient);
    webview.setWebChromeClient(new MyWebChromeClient());
    // Start initial page load so WebView finishes loading proxy settings.
    // Actual load of mUrl is initiated by MyWebViewClient.
    webview.loadData("", "text/html", null);
    mSwipeRefreshLayout = findViewById(R.id.swipe_refresh);
    mSwipeRefreshLayout.setOnRefreshListener(() -> {
        webview.reload();
        mSwipeRefreshLayout.setRefreshing(true);
    });
}
#method_after
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    logMetricsEvent(MetricsEvent.ACTION_CAPTIVE_PORTAL_LOGIN_ACTIVITY);
    mCm = ConnectivityManager.from(this);
    mNetwork = getIntent().getParcelableExtra(ConnectivityManager.EXTRA_NETWORK);
    mCaptivePortal = getIntent().getParcelableExtra(ConnectivityManager.EXTRA_CAPTIVE_PORTAL);
    mUserAgent = getIntent().getStringExtra(ConnectivityManager.EXTRA_CAPTIVE_PORTAL_USER_AGENT);
    mUrl = getUrl();
    if (mUrl == null) {
        // getUrl() failed to parse the url provided in the intent: bail out in a way that
        // at least provides network access.
        done(Result.WANTED_AS_IS);
        return;
    }
    if (DBG) {
        Log.d(TAG, String.format("onCreate for %s", mUrl.toString()));
    }
    final String spec = getIntent().getStringExtra(EXTRA_CAPTIVE_PORTAL_PROBE_SPEC);
    try {
        mProbeSpec = CaptivePortalProbeSpec.parseSpecOrNull(spec);
    } catch (Exception e) {
        // Make extra sure that invalid configurations do not cause crashes
        mProbeSpec = null;
    }
    mNetworkCallback = new NetworkCallback() {

        @Override
        public void onLost(Network lostNetwork) {
            // If the network disappears while the app is up, exit.
            if (mNetwork.equals(lostNetwork))
                done(Result.UNWANTED);
        }
    };
    mCm.registerNetworkCallback(new NetworkRequest.Builder().build(), mNetworkCallback);
    // If the network has disappeared, exit.
    final NetworkCapabilities networkCapabilities = mCm.getNetworkCapabilities(mNetwork);
    if (networkCapabilities == null) {
        finishAndRemoveTask();
        return;
    }
    // Also initializes proxy system properties.
    mNetwork = mNetwork.getPrivateDnsBypassingCopy();
    mCm.bindProcessToNetwork(mNetwork);
    mCm.setProcessDefaultNetworkForHostResolution(mNetwork);
    // Proxy system properties must be initialized before setContentView is called because
    // setContentView initializes the WebView logic which in turn reads the system properties.
    setContentView(R.layout.activity_captive_portal_login);
    getActionBar().setDisplayShowHomeEnabled(false);
    // remove shadow
    getActionBar().setElevation(0);
    getActionBar().setTitle(getHeaderTitle());
    getActionBar().setSubtitle("");
    final WebView webview = getWebview();
    webview.clearCache(true);
    CookieManager.getInstance().setAcceptThirdPartyCookies(webview, true);
    WebSettings webSettings = webview.getSettings();
    webSettings.setJavaScriptEnabled(true);
    webSettings.setMixedContentMode(WebSettings.MIXED_CONTENT_COMPATIBILITY_MODE);
    webSettings.setUseWideViewPort(true);
    webSettings.setLoadWithOverviewMode(true);
    webSettings.setSupportZoom(true);
    webSettings.setBuiltInZoomControls(true);
    webSettings.setDisplayZoomControls(false);
    mWebViewClient = new MyWebViewClient();
    webview.setWebViewClient(mWebViewClient);
    webview.setWebChromeClient(new MyWebChromeClient());
    // Start initial page load so WebView finishes loading proxy settings.
    // Actual load of mUrl is initiated by MyWebViewClient.
    webview.loadData("", "text/html", null);
    mSwipeRefreshLayout = findViewById(R.id.swipe_refresh);
    mSwipeRefreshLayout.setOnRefreshListener(() -> {
        webview.reload();
        mSwipeRefreshLayout.setRefreshing(true);
    });
}
#end_block

#method_before
private void done(Result result) {
    if (isDone.getAndSet(true)) {
        // isDone was already true: done() already called
        return;
    }
    if (DBG) {
        Log.d(TAG, String.format("Result %s for %s", result.name(), mUrl.toString()));
    }
    logMetricsEvent(result.metricsEvent);
    switch(result) {
        case DISMISSED:
            mCaptivePortal.reportCaptivePortalDismissed();
            moveTaskToBack(true);
            break;
        case UNWANTED:
            mCaptivePortal.ignoreNetwork();
            finishAndRemoveTask();
            break;
        case WANTED_AS_IS:
            mCaptivePortal.useNetwork();
            finishAndRemoveTask();
            break;
        default:
            finishAndRemoveTask();
    }
}
#method_after
private void done(Result result) {
    if (isDone.getAndSet(true)) {
        // isDone was already true: done() already called
        return;
    }
    if (DBG) {
        Log.d(TAG, String.format("Result %s for %s", result.name(), mUrl.toString()));
    }
    logMetricsEvent(result.metricsEvent);
    switch(result) {
        case DISMISSED:
            mCaptivePortal.reportCaptivePortalDismissed();
            break;
        case UNWANTED:
            mCaptivePortal.ignoreNetwork();
            break;
        case WANTED_AS_IS:
            mCaptivePortal.useNetwork();
            break;
    }
    finishAndRemoveTask();
}
#end_block

#method_before
@Override
public void onDestroy() {
    final WebView webview = (WebView) findViewById(R.id.webview);
    if (webview != null) {
        webview.stopLoading();
        webview.setWebViewClient(null);
        webview.setWebChromeClient(null);
        webview.destroy();
    }
    super.onDestroy();
    if (mNetworkCallback != null) {
        // mNetworkCallback is not null if mUrl is not null.
        mCm.unregisterNetworkCallback(mNetworkCallback);
    }
    if (mLaunchBrowser) {
        // Give time for this network to become default. After 500ms just proceed.
        for (int i = 0; i < 5; i++) {
            // TODO: This misses when mNetwork underlies a VPN.
            if (mNetwork.equals(mCm.getActiveNetwork()))
                break;
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
            }
        }
        final String url = mUrl.toString();
        if (DBG) {
            Log.d(TAG, "starting activity with intent ACTION_VIEW for " + url);
        }
        startActivity(new Intent(Intent.ACTION_VIEW, Uri.parse(url)));
    }
}
#method_after
@Override
public void onDestroy() {
    super.onDestroy();
    final WebView webview = (WebView) findViewById(R.id.webview);
    if (webview != null) {
        webview.stopLoading();
        webview.setWebViewClient(null);
        webview.setWebChromeClient(null);
        webview.destroy();
    }
    if (mNetworkCallback != null) {
        // mNetworkCallback is not null if mUrl is not null.
        mCm.unregisterNetworkCallback(mNetworkCallback);
    }
    if (mLaunchBrowser) {
        // Give time for this network to become default. After 500ms just proceed.
        for (int i = 0; i < 5; i++) {
            // TODO: This misses when mNetwork underlies a VPN.
            if (mNetwork.equals(mCm.getActiveNetwork()))
                break;
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
            }
        }
        final String url = mUrl.toString();
        if (DBG) {
            Log.d(TAG, "starting activity with intent ACTION_VIEW for " + url);
        }
        startActivity(new Intent(Intent.ACTION_VIEW, Uri.parse(url)));
    }
}
#end_block

#method_before
private void testForCaptivePortal() {
    // TODO: reuse NetworkMonitor facilities for consistent captive portal detection.
    new Thread(new Runnable() {

        public void run() {
            // Give time for captive portal to open.
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
            }
            HttpURLConnection urlConnection = null;
            int httpResponseCode = 500;
            try {
                urlConnection = (HttpURLConnection) mNetwork.openConnection(mUrl);
                urlConnection.setInstanceFollowRedirects(false);
                urlConnection.setConnectTimeout(SOCKET_TIMEOUT_MS);
                urlConnection.setReadTimeout(SOCKET_TIMEOUT_MS);
                urlConnection.setUseCaches(false);
                if (mUserAgent != null) {
                    urlConnection.setRequestProperty("User-Agent", mUserAgent);
                }
                // cannot read request header after connection
                String requestHeader = urlConnection.getRequestProperties().toString();
                urlConnection.getInputStream();
                httpResponseCode = urlConnection.getResponseCode();
                if (DBG) {
                    Log.d(TAG, "probe at " + mUrl + " ret=" + httpResponseCode + " request=" + requestHeader + " headers=" + urlConnection.getHeaderFields());
                }
            } catch (IOException e) {
            } finally {
                if (urlConnection != null)
                    urlConnection.disconnect();
            }
            if (httpResponseCode == 204) {
                done(Result.DISMISSED);
            }
        }
    }).start();
}
#method_after
private void testForCaptivePortal() {
    // TODO: reuse NetworkMonitor facilities for consistent captive portal detection.
    new Thread(new Runnable() {

        public void run() {
            // Give time for captive portal to open.
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
            }
            HttpURLConnection urlConnection = null;
            int httpResponseCode = 500;
            String locationHeader = null;
            try {
                urlConnection = (HttpURLConnection) mNetwork.openConnection(mUrl);
                urlConnection.setInstanceFollowRedirects(false);
                urlConnection.setConnectTimeout(SOCKET_TIMEOUT_MS);
                urlConnection.setReadTimeout(SOCKET_TIMEOUT_MS);
                urlConnection.setUseCaches(false);
                if (mUserAgent != null) {
                    urlConnection.setRequestProperty("User-Agent", mUserAgent);
                }
                // cannot read request header after connection
                String requestHeader = urlConnection.getRequestProperties().toString();
                urlConnection.getInputStream();
                httpResponseCode = urlConnection.getResponseCode();
                locationHeader = urlConnection.getHeaderField(HTTP_LOCATION_HEADER_NAME);
                if (DBG) {
                    Log.d(TAG, "probe at " + mUrl + " ret=" + httpResponseCode + " request=" + requestHeader + " headers=" + urlConnection.getHeaderFields());
                }
            } catch (IOException e) {
            } finally {
                if (urlConnection != null)
                    urlConnection.disconnect();
            }
            if (isDismissed(httpResponseCode, locationHeader, mProbeSpec)) {
                done(Result.DISMISSED);
            }
        }
    }).start();
}
#end_block

#method_before
// A web page consisting of a large broken lock icon to indicate SSL failure.
@Override
public void onReceivedSslError(WebView view, SslErrorHandler handler, SslError error) {
    mSslView = view;
    mSslHandler = handler;
    mSslError = error;
    mCertificateView = null;
    showSslAlertDialog();
}
#method_after
// A web page consisting of a large broken lock icon to indicate SSL failure.
@Override
public void onReceivedSslError(WebView view, SslErrorHandler handler, SslError error) {
    final URL url = makeURL(error.getUrl());
    final String host = host(url);
    Log.d(TAG, String.format("SSL error: %s, url: %s, certificate: %s", sslErrorName(error), sanitizeURL(url), error.getCertificate()));
    if (url == null || !Objects.equals(host, mHostname)) {
        // Ignore ssl errors for resources coming from a different hostname than the page
        // that we are currently loading, and only cancel the request.
        handler.cancel();
        return;
    }
    logMetricsEvent(MetricsEvent.CAPTIVE_PORTAL_LOGIN_ACTIVITY_SSL_ERROR);
    final String sslErrorPage = makeSslErrorPage();
    view.loadDataWithBaseURL(INTERNAL_ASSETS, sslErrorPage, "text/HTML", "UTF-8", null);
    mSslErrorTitle = view.getTitle() == null ? "" : view.getTitle();
    mSslErrorHandler = handler;
    mSslError = error;
}
#end_block

#method_before
private String makeSslErrorPage() {
    final String warningMsg = getString(R.string.ssl_error_warning);
    final String exampleMsg = getString(R.string.ssl_error_example);
    final String continueMsg = getString(R.string.ssl_error_continue);
    return String.join("\n", "<html>", "<head>", "  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">", "  <style>", "    body {", "      background-color:#fafafa;", "      margin:auto;", "      width:80%;", "      margin-top: 96px", "    }", "    img {", "      height:48px;", "      width:48px;", "    }", "    div.warn {", "      font-size:" + sp(16) + ";", "      line-height:1.28;", "      margin-top:16px;", "      opacity:0.87;", "    }", "    div.example {", "      font-size:" + sp(14) + ";", "      line-height:1.21905;", "      margin-top:16px;", "      opacity:0.54;", "    }", "    a {", "      color:#4285F4;", "      display:inline-block;", "      font-size:" + sp(14) + ";", "      font-weight:bold;", "      height:48px;", "      margin-top:24px;", "      text-decoration:none;", "      text-transform:uppercase;", "    }", "  </style>", "</head>", "<body>", "  <p><img src=quantum_ic_warning_amber_96.png><br>", "  <div class=warn>" + warningMsg + "</div>", "  <div class=example>" + exampleMsg + "</div>", "  <a href=" + mBrowserBailOutToken + ">" + continueMsg + "</a>", "</body>", "</html>");
}
#method_after
private String makeSslErrorPage() {
    final String warningMsg = getString(R.string.ssl_error_warning);
    final String exampleMsg = getString(R.string.ssl_error_example);
    final String continueMsg = getString(R.string.ssl_error_continue);
    final String certificateMsg = getString(R.string.ssl_error_view_certificate);
    return String.join("\n", "<html>", "<head>", "  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">", "  <style>", "    body {", "      background-color:#fafafa;", "      margin:auto;", "      width:80%;", "      margin-top: 96px", "    }", "    img {", "      height:48px;", "      width:48px;", "    }", "    div.warn {", "      font-size:" + sp(16) + ";", "      line-height:1.28;", "      margin-top:16px;", "      opacity:0.87;", "    }", "    div.example {", "      font-size:" + sp(14) + ";", "      line-height:1.21905;", "      margin-top:16px;", "      opacity:0.54;", "    }", "    a {", "      color:#4285F4;", "      display:inline-block;", "      font-size:" + sp(14) + ";", "      font-weight:bold;", "      height:48px;", "      margin-top:24px;", "      text-decoration:none;", "      text-transform:uppercase;", "    }", "    a.certificate {", "      margin-top:0px;", "    }", "  </style>", "</head>", "<body>", "  <p><img src=quantum_ic_warning_amber_96.png><br>", "  <div class=warn>" + warningMsg + "</div>", "  <div class=example>" + exampleMsg + "</div>", "  <a href=" + mBrowserBailOutToken + ">" + continueMsg + "</a><br>", "  <a class=certificate href=" + mCertificateOutToken + ">" + certificateMsg + "</a>", "</body>", "</html>");
}
#end_block

#method_before
@Override
public boolean shouldOverrideUrlLoading(WebView view, String url) {
    if (url.startsWith("tel:")) {
        startActivity(new Intent(Intent.ACTION_DIAL, Uri.parse(url)));
        return true;
    }
    return false;
}
#method_after
@Override
public boolean shouldOverrideUrlLoading(WebView view, String url) {
    if (url.startsWith("tel:")) {
        startActivity(new Intent(Intent.ACTION_DIAL, Uri.parse(url)));
        return true;
    }
    if (url.contains(mCertificateOutToken) && mSslError != null) {
        showSslAlertDialog(mSslErrorHandler, mSslError, mSslErrorTitle);
        return true;
    }
    return false;
}
#end_block

#method_before
private void showSslAlertDialog() {
    final LayoutInflater factory = LayoutInflater.from(CaptivePortalLoginActivity.this);
    final View sslWarningView = factory.inflate(R.layout.ssl_warning, null);
    // Set error message type
    setViewErrorMessageType(sslWarningView);
    // Set Security certificate
    setViewSecurityCertificate(sslWarningView);
    // Set Page info
    setViewPageInfo(mSslError.getUrl(), sslWarningView);
    AlertDialog sslAlertDialog = new AlertDialog.Builder(CaptivePortalLoginActivity.this).setTitle(R.string.security_warning).setView(sslWarningView).setPositiveButton(R.string.ok, new DialogInterface.OnClickListener() {

        public void onClick(DialogInterface dialog, int whichButton) {
            dialog.cancel();
        }
    }).setNegativeButton(R.string.cancel, new DialogInterface.OnClickListener() {

        @Override
        public void onClick(DialogInterface dialog, int whichButton) {
            finishAndRemoveTask();
        }
    }).setOnCancelListener(new DialogInterface.OnCancelListener() {

        @Override
        public void onCancel(DialogInterface dialog) {
            mSslHandler.cancel();
            final String html = makeSslErrorPage();
            mSslView.loadDataWithBaseURL(INTERNAL_ASSETS, html, "text/HTML", "UTF-8", null);
        }
    }).create();
    sslAlertDialog.show();
}
#method_after
private void showSslAlertDialog(SslErrorHandler handler, SslError error, String title) {
    final LayoutInflater factory = LayoutInflater.from(CaptivePortalLoginActivity.this);
    final View sslWarningView = factory.inflate(R.layout.ssl_warning, null);
    // Set Security certificate
    setViewSecurityCertificate(sslWarningView.findViewById(R.id.certificate_layout), error);
    ((TextView) sslWarningView.findViewById(R.id.ssl_error_type)).setText(sslErrorName(error));
    ((TextView) sslWarningView.findViewById(R.id.title)).setText(mSslErrorTitle);
    ((TextView) sslWarningView.findViewById(R.id.address)).setText(error.getUrl());
    AlertDialog sslAlertDialog = new AlertDialog.Builder(CaptivePortalLoginActivity.this).setTitle(R.string.ssl_security_warning_title).setView(sslWarningView).setPositiveButton(R.string.ok, (DialogInterface dialog, int whichButton) -> {
        // handler.cancel is called via OnCancelListener.
        dialog.cancel();
    }).setOnCancelListener((DialogInterface dialogInterface) -> handler.cancel()).create();
    sslAlertDialog.show();
}
#end_block

#method_before
private void setViewSecurityCertificate(View sslWarningView) {
    SslCertificate cert = mSslError.getCertificate();
    if (cert == null) {
        if (DBG)
            Log.e(TAG, "Certificate is null");
        return;
    }
    View certificateView = cert.inflateCertificateView(CaptivePortalLoginActivity.this);
    final LinearLayout placeholder = (LinearLayout) certificateView.findViewById(com.android.internal.R.id.placeholder);
    LayoutInflater factory = LayoutInflater.from(CaptivePortalLoginActivity.this);
    TextView textView = (TextView) factory.inflate(R.layout.ssl_error_msg, placeholder, false);
    textView.setText(sslErrorMessage(mSslError));
    placeholder.addView(textView);
    LinearLayout certificateLayout = sslWarningView.findViewById(R.id.certificate_layout);
    certificateView.setVisibility(View.GONE);
    certificateLayout.addView(certificateView);
    mCertificateView = certificateView;
}
#method_after
private void setViewSecurityCertificate(LinearLayout certificateLayout, SslError error) {
    SslCertificate cert = error.getCertificate();
    View certificateView = cert.inflateCertificateView(CaptivePortalLoginActivity.this);
    final LinearLayout placeholder = (LinearLayout) certificateView.findViewById(com.android.internal.R.id.placeholder);
    LayoutInflater factory = LayoutInflater.from(CaptivePortalLoginActivity.this);
    TextView textView = (TextView) factory.inflate(R.layout.ssl_error_msg, placeholder, false);
    textView.setText(sslErrorMessage(error));
    placeholder.addView(textView);
    certificateLayout.addView(certificateView);
}
#end_block

#method_before
private String getHeaderTitle() {
    NetworkInfo info = mCm.getNetworkInfo(mNetwork);
    if (info == null) {
        return getString(R.string.action_bar_label);
    }
    NetworkCapabilities nc = mCm.getNetworkCapabilities(mNetwork);
    if (!nc.hasTransport(NetworkCapabilities.TRANSPORT_WIFI)) {
        return getString(R.string.action_bar_label);
    }
    return getString(R.string.action_bar_title, info.getExtraInfo().replaceAll("^\"|\"$", ""));
}
#method_after
private String getHeaderTitle() {
    NetworkCapabilities nc = mCm.getNetworkCapabilities(mNetwork);
    if (nc == null || TextUtils.isEmpty(nc.getSSID()) || !nc.hasTransport(NetworkCapabilities.TRANSPORT_WIFI)) {
        return getString(R.string.action_bar_label);
    }
    return getString(R.string.action_bar_title, WifiInfo.removeDoubleQuotes(nc.getSSID()));
}
#end_block

#method_before
private static Integer sslErrorMessage(SslError error) {
    return SSL_ERROR_MSGS.get(error.getPrimaryError(), R.string.ssl_unknown);
}
#method_after
private static Integer sslErrorMessage(SslError error) {
    return SSL_ERROR_MSGS.get(error.getPrimaryError(), R.string.ssl_error_unknown);
}
#end_block

#method_before
@Override
public void onMeasureImpl(int widthMeasureSpec, int heightMeasureSpec) {
    synchronized (mLock) {
        if (mIsMusicMediaType) {
            int currWidth = mInstance.getMeasuredWidth();
            if (mPrevWidth != currWidth) {
                Point screenSize = new Point();
                WindowManager winManager = (WindowManager) mInstance.getContext().getApplicationContext().getSystemService(Context.WINDOW_SERVICE);
                winManager.getDefaultDisplay().getSize(screenSize);
                int screenWidth = screenSize.x;
                if (currWidth == screenWidth) {
                    int orientation = retrieveOrientation();
                    if (orientation == ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE) {
                        updateCurrentMusicView(mMusicFullLandscapeView);
                    } else {
                        updateCurrentMusicView(mMusicFullPortraitView);
                    }
                    if (mSizeType != SIZE_TYPE_FULL) {
                        mSizeType = SIZE_TYPE_FULL;
                    }
                } else {
                    if (mSizeType != SIZE_TYPE_EMBEDDED) {
                        mSizeType = SIZE_TYPE_EMBEDDED;
                        updateCurrentMusicView(mMusicEmbeddedView);
                    }
                }
                mPrevWidth = currWidth;
            }
        }
    }
}
#method_after
@Override
public void onMeasureImpl(int widthMeasureSpec, int heightMeasureSpec) {
    synchronized (mLock) {
        if (mCurrentItemIsMusic) {
            int currWidth = mInstance.getMeasuredWidth();
            if (mPrevWidth != currWidth) {
                Point screenSize = new Point();
                WindowManager winManager = (WindowManager) mInstance.getContext().getApplicationContext().getSystemService(Context.WINDOW_SERVICE);
                winManager.getDefaultDisplay().getSize(screenSize);
                int screenWidth = screenSize.x;
                if (currWidth == screenWidth) {
                    int orientation = retrieveOrientation();
                    if (orientation == ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE) {
                        updateCurrentMusicView(mMusicFullLandscapeView);
                    } else {
                        updateCurrentMusicView(mMusicFullPortraitView);
                    }
                    if (mSizeType != SIZE_TYPE_FULL) {
                        mSizeType = SIZE_TYPE_FULL;
                    }
                } else {
                    if (mSizeType != SIZE_TYPE_EMBEDDED) {
                        mSizeType = SIZE_TYPE_EMBEDDED;
                        updateCurrentMusicView(mMusicEmbeddedView);
                    }
                }
                mPrevWidth = currWidth;
            }
        }
    }
}
#end_block

#method_before
Bundle extractTrackInfoData() {
    List<MediaPlayer.TrackInfo> trackInfos = mMediaPlayer.getTrackInfo();
    mVideoTrackIndices = new ArrayList<>();
    mAudioTrackIndices = new ArrayList<>();
    mSubtitleTracks = new SparseArray<>();
    ArrayList<String> subtitleTracksLanguageList = new ArrayList<>();
    mSubtitleController.reset();
    for (int i = 0; i < trackInfos.size(); ++i) {
        int trackType = trackInfos.get(i).getTrackType();
        if (trackType == MediaPlayer2.TrackInfo.MEDIA_TRACK_TYPE_VIDEO) {
            mVideoTrackIndices.add(i);
        } else if (trackType == MediaPlayer2.TrackInfo.MEDIA_TRACK_TYPE_AUDIO) {
            mAudioTrackIndices.add(i);
        } else if (trackType == MediaPlayer2.TrackInfo.MEDIA_TRACK_TYPE_SUBTITLE) {
            SubtitleTrack track = mSubtitleController.addTrack(trackInfos.get(i).getFormat());
            if (track != null) {
                mSubtitleTracks.put(i, track);
                String language = (trackInfos.get(i).getLanguage().equals(SUBTITLE_TRACK_LANG_UNDEFINED)) ? "" : trackInfos.get(i).getLanguage();
                subtitleTracksLanguageList.add(language);
            }
        }
    }
    // Select first tracks as default
    if (mAudioTrackIndices.size() > 0) {
        mSelectedAudioTrackIndex = 0;
    }
    if (mVideoTrackIndices.size() == 0 && mAudioTrackIndices.size() > 0) {
        synchronized (mLock) {
            mIsMusicMediaType = true;
        }
    }
    Bundle data = new Bundle();
    data.putInt(MediaControlView.KEY_VIDEO_TRACK_COUNT, mVideoTrackIndices.size());
    data.putInt(MediaControlView.KEY_AUDIO_TRACK_COUNT, mAudioTrackIndices.size());
    data.putInt(MediaControlView.KEY_SUBTITLE_TRACK_COUNT, mSubtitleTracks.size());
    data.putStringArrayList(MediaControlView.KEY_SUBTITLE_TRACK_LANGUAGE_LIST, subtitleTracksLanguageList);
    return data;
}
#method_after
Bundle extractTrackInfoData() {
    List<MediaPlayer.TrackInfo> trackInfos = mMediaPlayer.getTrackInfo();
    mVideoTrackIndices = new ArrayList<>();
    mAudioTrackIndices = new ArrayList<>();
    mSubtitleTracks = new SparseArray<>();
    ArrayList<String> subtitleTracksLanguageList = new ArrayList<>();
    mSubtitleController.reset();
    for (int i = 0; i < trackInfos.size(); ++i) {
        int trackType = trackInfos.get(i).getTrackType();
        if (trackType == MediaPlayer2.TrackInfo.MEDIA_TRACK_TYPE_VIDEO) {
            mVideoTrackIndices.add(i);
        } else if (trackType == MediaPlayer2.TrackInfo.MEDIA_TRACK_TYPE_AUDIO) {
            mAudioTrackIndices.add(i);
        } else if (trackType == MediaPlayer2.TrackInfo.MEDIA_TRACK_TYPE_SUBTITLE) {
            SubtitleTrack track = mSubtitleController.addTrack(trackInfos.get(i).getFormat());
            if (track != null) {
                mSubtitleTracks.put(i, track);
                String language = (trackInfos.get(i).getLanguage().equals(SUBTITLE_TRACK_LANG_UNDEFINED)) ? "" : trackInfos.get(i).getLanguage();
                subtitleTracksLanguageList.add(language);
            }
        }
    }
    // Select first tracks as default
    if (mAudioTrackIndices.size() > 0) {
        mSelectedAudioTrackIndex = 0;
    }
    synchronized (mLock) {
        mCurrentItemIsMusic = mVideoTrackIndices.size() == 0 && mAudioTrackIndices.size() > 0;
    }
    Bundle data = new Bundle();
    data.putInt(MediaControlView.KEY_VIDEO_TRACK_COUNT, mVideoTrackIndices.size());
    data.putInt(MediaControlView.KEY_AUDIO_TRACK_COUNT, mAudioTrackIndices.size());
    data.putInt(MediaControlView.KEY_SUBTITLE_TRACK_COUNT, mSubtitleTracks.size());
    data.putStringArrayList(MediaControlView.KEY_SUBTITLE_TRACK_LANGUAGE_LIST, subtitleTracksLanguageList);
    return data;
}
#end_block

#method_before
MediaMetadata extractMetadata() {
    MediaMetadataRetriever retriever = null;
    String path = "";
    try {
        if (mMediaItem == null) {
            return null;
        } else if (mMediaItem instanceof UriMediaItem) {
            Uri uri = ((UriMediaItem) mMediaItem).getUri();
            // Save file name as title since the file may not have a title Metadata.
            String scheme = uri.getScheme();
            if (scheme != null) {
                if (scheme.equals("file")) {
                    path = uri.getLastPathSegment();
                } else if (scheme.equals("http") || scheme.equals("https")) {
                    path = uri.getPath();
                }
            }
            retriever = new MediaMetadataRetriever();
            retriever.setDataSource(mInstance.getContext(), uri);
        } else if (mMediaItem instanceof FileMediaItem) {
            retriever = new MediaMetadataRetriever();
            retriever.setDataSource(((FileMediaItem) mMediaItem).getFileDescriptor(), ((FileMediaItem) mMediaItem).getFileDescriptorOffset(), ((FileMediaItem) mMediaItem).getFileDescriptorLength());
        }
    } catch (IllegalArgumentException e) {
        Log.v(TAG, "Cannot retrieve metadata for this media file.");
        retriever = null;
    }
    MediaMetadata metadata = mMediaItem.getMetadata();
    synchronized (mLock) {
        if (!mIsMusicMediaType) {
            mTitle = extractString(metadata, MediaMetadata.METADATA_KEY_TITLE, retriever, MediaMetadataRetriever.METADATA_KEY_TITLE, path);
        } else {
            Resources resources = mInstance.getResources();
            mTitle = extractString(metadata, MediaMetadata.METADATA_KEY_TITLE, retriever, MediaMetadataRetriever.METADATA_KEY_TITLE, resources.getString(R.string.mcv2_music_title_unknown_text));
            mMusicArtistText = extractString(metadata, MediaMetadata.METADATA_KEY_ARTIST, retriever, MediaMetadataRetriever.METADATA_KEY_ARTIST, resources.getString(R.string.mcv2_music_artist_unknown_text));
            mMusicAlbumDrawable = extractAlbumArt(metadata, retriever, resources.getDrawable(R.drawable.ic_default_album_image));
            // Update Music View to reflect the new metadata
            mInstance.removeView(mSurfaceView);
            mInstance.removeView(mTextureView);
            updateCurrentMusicView(mMusicEmbeddedView);
        }
        if (retriever != null) {
            retriever.release();
        }
        // Set duration and title values as MediaMetadata for MediaControlView
        MediaMetadata.Builder builder = new MediaMetadata.Builder();
        if (mIsMusicMediaType) {
            builder.putString(MediaMetadata.METADATA_KEY_ARTIST, mMusicArtistText);
        }
        builder.putString(MediaMetadata.METADATA_KEY_TITLE, mTitle);
        builder.putLong(MediaMetadata.METADATA_KEY_DURATION, mMediaSession.getPlayer().getDuration());
        builder.putString(MediaMetadata.METADATA_KEY_MEDIA_ID, mMediaItem.getMediaId());
        builder.putLong(MediaMetadata.METADATA_KEY_BROWSABLE, MediaMetadata.BROWSABLE_TYPE_NONE);
        builder.putLong(MediaMetadata.METADATA_KEY_PLAYABLE, 1);
        return builder.build();
    }
}
#method_after
MediaMetadata extractMetadata() {
    MediaMetadataRetriever retriever = null;
    String path = "";
    try {
        if (mMediaItem == null) {
            return null;
        } else if (mMediaItem instanceof UriMediaItem) {
            Uri uri = ((UriMediaItem) mMediaItem).getUri();
            // Save file name as title since the file may not have a title Metadata.
            String scheme = uri.getScheme();
            if (scheme != null) {
                if (scheme.equals("file")) {
                    path = uri.getLastPathSegment();
                } else if (scheme.equals("http") || scheme.equals("https")) {
                    path = uri.getPath();
                }
            }
            retriever = new MediaMetadataRetriever();
            retriever.setDataSource(mInstance.getContext(), uri);
        } else if (mMediaItem instanceof FileMediaItem) {
            retriever = new MediaMetadataRetriever();
            retriever.setDataSource(((FileMediaItem) mMediaItem).getFileDescriptor(), ((FileMediaItem) mMediaItem).getFileDescriptorOffset(), ((FileMediaItem) mMediaItem).getFileDescriptorLength());
        }
    } catch (IllegalArgumentException e) {
        Log.v(TAG, "Cannot retrieve metadata for this media file.");
        retriever = null;
    }
    MediaMetadata metadata = mMediaItem.getMetadata();
    synchronized (mLock) {
        if (!mCurrentItemIsMusic) {
            mTitle = extractString(metadata, MediaMetadata.METADATA_KEY_TITLE, retriever, MediaMetadataRetriever.METADATA_KEY_TITLE, path);
        } else {
            Resources resources = mInstance.getResources();
            mTitle = extractString(metadata, MediaMetadata.METADATA_KEY_TITLE, retriever, MediaMetadataRetriever.METADATA_KEY_TITLE, resources.getString(R.string.mcv2_music_title_unknown_text));
            mMusicArtistText = extractString(metadata, MediaMetadata.METADATA_KEY_ARTIST, retriever, MediaMetadataRetriever.METADATA_KEY_ARTIST, resources.getString(R.string.mcv2_music_artist_unknown_text));
            mMusicAlbumDrawable = extractAlbumArt(metadata, retriever, resources.getDrawable(R.drawable.ic_default_album_image));
            // Update Music View to reflect the new metadata
            mInstance.removeView(mSurfaceView);
            mInstance.removeView(mTextureView);
            updateCurrentMusicView(mMusicEmbeddedView);
        }
        if (retriever != null) {
            retriever.release();
        }
        // Set duration and title values as MediaMetadata for MediaControlView
        MediaMetadata.Builder builder = new MediaMetadata.Builder();
        if (mCurrentItemIsMusic) {
            builder.putString(MediaMetadata.METADATA_KEY_ARTIST, mMusicArtistText);
        }
        builder.putString(MediaMetadata.METADATA_KEY_TITLE, mTitle);
        builder.putLong(MediaMetadata.METADATA_KEY_DURATION, mMediaSession.getPlayer().getDuration());
        builder.putString(MediaMetadata.METADATA_KEY_MEDIA_ID, mMediaItem.getMediaId());
        builder.putLong(MediaMetadata.METADATA_KEY_BROWSABLE, MediaMetadata.BROWSABLE_TYPE_NONE);
        builder.putLong(MediaMetadata.METADATA_KEY_PLAYABLE, 1);
        return builder.build();
    }
}
#end_block

#method_before
@Override
public int onCommandRequest(@NonNull MediaSession session, @NonNull MediaSession.ControllerInfo controller, @NonNull SessionCommand command) {
    if (session != mMediaSession) {
        if (DEBUG) {
            Log.w(TAG, "onCommandRequest() is ignored. session is already gone.");
        }
    }
    switch(command.getCommandCode()) {
        case SessionCommand.COMMAND_CODE_PLAYER_PLAY:
            mTargetState = STATE_PLAYING;
            synchronized (mLock) {
                if (!mCurrentView.hasAvailableSurface() && !mIsMusicMediaType) {
                    Log.d(TAG, "surface is not available");
                    return RESULT_CODE_INVALID_STATE;
                }
            }
            break;
        case SessionCommand.COMMAND_CODE_PLAYER_PAUSE:
            mTargetState = STATE_PAUSED;
            break;
        case SessionCommand.COMMAND_CODE_PLAYER_SEEK_TO:
            mSeekWhenPrepared = 0;
            break;
    }
    return RESULT_CODE_SUCCESS;
}
#method_after
@Override
public int onCommandRequest(@NonNull MediaSession session, @NonNull MediaSession.ControllerInfo controller, @NonNull SessionCommand command) {
    if (session != mMediaSession) {
        if (DEBUG) {
            Log.w(TAG, "onCommandRequest() is ignored. session is already gone.");
        }
    }
    switch(command.getCommandCode()) {
        case SessionCommand.COMMAND_CODE_PLAYER_PLAY:
            mTargetState = STATE_PLAYING;
            synchronized (mLock) {
                if (!mCurrentView.hasAvailableSurface() && !mCurrentItemIsMusic) {
                    Log.d(TAG, "surface is not available");
                    return RESULT_CODE_INVALID_STATE;
                }
            }
            break;
        case SessionCommand.COMMAND_CODE_PLAYER_PAUSE:
            mTargetState = STATE_PAUSED;
            break;
        case SessionCommand.COMMAND_CODE_PLAYER_SEEK_TO:
            mSeekWhenPrepared = 0;
            break;
    }
    return RESULT_CODE_SUCCESS;
}
#end_block

#method_before
private void registerInputDevice(String registerCommand) {
    mDeviceAddedSignal = new CountDownLatch(1);
    writeHidCommands(registerCommand.getBytes());
    try {
        // Found that in kernel 3.10, the device registration takes a very long time
        // The wait can be decreased to 2 seconds after kernel 3.10 is no longer supported
        mDeviceAddedSignal.await(20L, TimeUnit.SECONDS);
        if (mDeviceAddedSignal.getCount() != 0) {
            throw new RuntimeException("Did not receive device added notification in time");
        }
    } catch (InterruptedException ex) {
        throw new RuntimeException("Unexpectedly interrupted while waiting for device added notification.");
    }
}
#method_after
private void registerInputDevice(String registerCommand) {
    mDeviceAddedSignal = new CountDownLatch(1);
    writeHidCommands(registerCommand.getBytes());
    try {
        // Found that in kernel 3.10, the device registration takes a very long time
        // The wait can be decreased to 2 seconds after kernel 3.10 is no longer supported
        mDeviceAddedSignal.await(20L, TimeUnit.SECONDS);
        if (mDeviceAddedSignal.getCount() != 0) {
            throw new RuntimeException("Did not receive device added notification in time");
        }
    } catch (InterruptedException ex) {
        throw new RuntimeException("Unexpectedly interrupted while waiting for device added notification.");
    }
    // Even though the device has been added, it still may not be ready to process the events
    // right away. This seems to be a kernel bug.
    // Add a small delay here to ensure device is "ready".
    SystemClock.sleep(500);
}
#end_block

#method_before
private KeyEvent parseKeyEvent(JSONObject entry) throws JSONException {
    int action = keyActionFromString(entry.getString("action"));
    int keyCode = KeyEvent.keyCodeFromString(entry.getString("keycode"));
    return new KeyEvent(action, keyCode);
}
#method_after
private KeyEvent parseKeyEvent(JSONObject entry) throws JSONException {
    int action = keyActionFromString(entry.getString("action"));
    String keyCodeStr = entry.getString("keycode");
    if (!keyCodeStr.startsWith("KEYCODE_")) {
        keyCodeStr = "KEYCODE_" + keyCodeStr;
    }
    int keyCode = KeyEvent.keyCodeFromString(keyCodeStr);
    return new KeyEvent(action, keyCode);
}
#end_block

#method_before
@Test
public void testBundle() {
    final TextLinks reference = new TextLinks.Builder(FULL_TEXT.toString()).addLink(0, 4, getEntityScores(0.f, 0.f, 1.f), BUNDLE).addLink(5, 12, getEntityScores(.8f, .1f, .5f)).setExtras(BUNDLE).build();
    // Serialize/deserialize.
    final TextLinks result = TextLinks.createFromBundle(reference.toBundle());
    assertTextLinks(result);
    assertEquals(BUNDLE_VALUE, result.getExtras().getString(BUNDLE_KEY));
    final List<TextLinks.TextLink> resultLinks = new ArrayList<>(result.getLinks());
    assertEquals(BUNDLE_VALUE, resultLinks.get(0).getExtras().getString(BUNDLE_KEY));
    assertNull(resultLinks.get(1).getExtras().getString(BUNDLE_KEY));
}
#method_after
@Test
public void testBundle() {
    final TextLinks reference = new TextLinks.Builder(FULL_TEXT.toString()).addLink(0, 4, getEntityScores(0.f, 0.f, 1.f)).addLink(5, 12, getEntityScores(.8f, .1f, .5f)).setExtras(BUNDLE).build();
    // Serialize/deserialize.
    final TextLinks result = TextLinks.createFromBundle(reference.toBundle());
    assertTextLinks(result);
    assertEquals(BUNDLE_VALUE, result.getExtras().getString(BUNDLE_KEY));
}
#end_block

#method_before
static Bundle deepCopy(Bundle bundle) {
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
        return bundle.deepCopy();
    } else {
        return (Bundle) bundle.clone();
    }
}
#method_after
static Bundle deepCopy(Bundle bundle) {
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
        return bundle.deepCopy();
    } else {
        // TODO: actually perform a deep copy.
        return (Bundle) bundle.clone();
    }
}
#end_block

#method_before
@NonNull
public Request build() {
    return new Request(mText, mStartIndex, mEndIndex, mDefaultLocales, mReferenceTime, mExtras == null ? Bundle.EMPTY : BundleUtils.deepCopy(mExtras));
}
#method_after
@NonNull
public TextClassification build() {
    return new TextClassification(mText, mActions, new EntityConfidence(mEntityConfidence), mId, mExtras == null ? Bundle.EMPTY : BundleUtils.deepCopy(mExtras));
}
#end_block

#method_before
private static void addLinks(TextLinks.Builder builder, String string, @EntityType String entityType) {
    final int linkifyMask = entityTypeToLinkifyMask(entityType);
    if (linkifyMask == NOT_LINKIFY) {
        return;
    }
    final Spannable spannable = new SpannableString(string);
    if (LinkifyCompat.addLinks(spannable, linkifyMask)) {
        final URLSpan[] spans = spannable.getSpans(0, spannable.length(), URLSpan.class);
        for (URLSpan urlSpan : spans) {
            builder.addLink(spannable.getSpanStart(urlSpan), spannable.getSpanEnd(urlSpan), Collections.singletonMap(entityType, 1.0f), Bundle.EMPTY, urlSpan);
        }
    }
}
#method_after
private static void addLinks(TextLinks.Builder builder, String string, @EntityType String entityType) {
    final int linkifyMask = entityTypeToLinkifyMask(entityType);
    if (linkifyMask == NOT_LINKIFY) {
        return;
    }
    final Spannable spannable = new SpannableString(string);
    if (LinkifyCompat.addLinks(spannable, linkifyMask)) {
        final URLSpan[] spans = spannable.getSpans(0, spannable.length(), URLSpan.class);
        for (URLSpan urlSpan : spans) {
            builder.addLink(spannable.getSpanStart(urlSpan), spannable.getSpanEnd(urlSpan), Collections.singletonMap(entityType, 1.0f));
        }
    }
}
#end_block

#method_before
@Override
@NonNull
public String toString() {
    return String.format(Locale.US, "TextLink{start=%s, end=%s, entityScores=%s, urlSpan=%s, extras=%s}", mStart, mEnd, mEntityScores, mUrlSpan, mExtras);
}
#method_after
@Override
@NonNull
public String toString() {
    return String.format(Locale.US, "TextLink{start=%s, end=%s, entityScores=%s}", mStart, mEnd, mEntityScores);
}
#end_block

#method_before
@NonNull
public Bundle toBundle() {
    final Bundle bundle = new Bundle();
    BundleUtils.putMap(bundle, EXTRA_ENTITY_SCORES, mEntityScores.getConfidenceMap());
    bundle.putInt(EXTRA_START, mStart);
    bundle.putInt(EXTRA_END, mEnd);
    bundle.putBundle(EXTRA_EXTRAS, mExtras);
    return bundle;
}
#method_after
@NonNull
public Bundle toBundle() {
    final Bundle bundle = new Bundle();
    BundleUtils.putMap(bundle, EXTRA_ENTITY_SCORES, mEntityScores.getConfidenceMap());
    bundle.putInt(EXTRA_START, mStart);
    bundle.putInt(EXTRA_END, mEnd);
    return bundle;
}
#end_block

#method_before
@NonNull
public static TextLink createFromBundle(@NonNull Bundle bundle) {
    Bundle extras = bundle.getBundle(EXTRA_EXTRAS);
    return new TextLink(bundle.getInt(EXTRA_START), bundle.getInt(EXTRA_END), BundleUtils.getFloatStringMapOrThrow(bundle, EXTRA_ENTITY_SCORES), extras == null ? Bundle.EMPTY : extras, null);
}
#method_after
@NonNull
public static TextLink createFromBundle(@NonNull Bundle bundle) {
    return new TextLink(bundle.getInt(EXTRA_START), bundle.getInt(EXTRA_END), BundleUtils.getFloatStringMapOrThrow(bundle, EXTRA_ENTITY_SCORES));
}
#end_block

#method_before
@NonNull
public TextLinks build() {
    return new TextLinks(mFullText, mLinks, mExtras == null ? Bundle.EMPTY : BundleUtils.deepCopy(mExtras));
}
#method_after
@NonNull
public Request build() {
    return new Request(mText, mDefaultLocales, mEntityConfig, mReferenceTime, mExtras == null ? Bundle.EMPTY : mExtras);
}
#end_block

#method_before
@NonNull
public Builder addLink(int start, int end, @NonNull Map<String, Float> entityScores) {
    mLinks.add(new TextLink(start, end, Preconditions.checkNotNull(entityScores), Bundle.EMPTY, null));
    return this;
}
#method_after
@NonNull
public Builder addLink(int start, int end, @NonNull Map<String, Float> entityScores) {
    mLinks.add(new TextLink(start, end, Preconditions.checkNotNull(entityScores)));
    return this;
}
#end_block

#method_before
@Before
public void setUp() {
    mContext = mActivityTestRule.getActivity();
    mReceiver = BlockingReceiver.registerForPendingIntent(mContext);
    final PendingIntent intent = mReceiver.getPendingIntent();
    mTextClassifier = new TextClassifier() {

        @Override
        public TextClassification classifyText(@NonNull TextClassification.Request r) {
            final RemoteActionCompat remoteAction = new RemoteActionCompat(ICON, ITEM, "desc", intent);
            remoteAction.setShouldShowIcon(false);
            return new TextClassification.Builder().addAction(remoteAction).build();
        }
    };
    final Map<String, Float> scores = new ArrayMap<>();
    scores.put(TextClassifier.TYPE_EMAIL, 1f);
    mTextLink = new TextLink(0, ENTITY.length(), scores, Bundle.EMPTY, null);
}
#method_after
@Before
public void setUp() {
    mContext = mActivityTestRule.getActivity();
    mReceiver = BlockingReceiver.registerForPendingIntent(mContext);
    final PendingIntent intent = mReceiver.getPendingIntent();
    mTextClassifier = new TextClassifier() {

        @Override
        public TextClassification classifyText(@NonNull TextClassification.Request r) {
            final RemoteActionCompat remoteAction = new RemoteActionCompat(ICON, ITEM, "desc", intent);
            remoteAction.setShouldShowIcon(false);
            return new TextClassification.Builder().addAction(remoteAction).build();
        }
    };
    final Map<String, Float> scores = new ArrayMap<>();
    scores.put(TextClassifier.TYPE_EMAIL, 1f);
    mTextLink = new TextLink(0, ENTITY.length(), scores);
}
#end_block

#method_before
@NonNull
public Request build() {
    return new Request(mText, mStartIndex, mEndIndex, mDefaultLocales, mExtras == null ? Bundle.EMPTY : BundleUtils.deepCopy(mExtras));
}
#method_after
@NonNull
public TextSelection build() {
    return new TextSelection(mStartIndex, mEndIndex, new EntityConfidence(mEntityConfidence), mId, mExtras == null ? Bundle.EMPTY : BundleUtils.deepCopy(mExtras));
}
#end_block

#method_before
private void resetIfReadyAndConnected() {
    Slog.d(TAG, "Thinking about reset, mSystemReady=" + mSystemReady + ", mDaemonConnected=" + mDaemonConnected);
    if (mSystemReady && mDaemonConnected) {
        final List<UserInfo> users = mContext.getSystemService(UserManager.class).getUsers();
        killMediaProvider(users);
        final int[] systemUnlockedUsers;
        synchronized (mLock) {
            systemUnlockedUsers = mSystemUnlockedUsers;
            mDisks.clear();
            mVolumes.clear();
            addInternalVolumeLocked();
        }
        try {
            mVold.reset();
            // Tell vold about all existing and started users
            for (UserInfo user : users) {
                mVold.onUserAdded(user.id, user.serialNumber);
            }
            for (int userId : systemUnlockedUsers) {
                mVold.onUserStarted(userId);
                mStoraged.onUserStarted(userId);
            }
            mVold.onSecureKeyguardStateChanged(mSecureKeyguardShowing);
        } catch (Exception e) {
            Slog.wtf(TAG, e);
        }
    }
}
#method_after
private void resetIfReadyAndConnected() {
    Slog.d(TAG, "Thinking about reset, mSystemReady=" + mSystemReady + ", mDaemonConnected=" + mDaemonConnected);
    if (mSystemReady && mDaemonConnected) {
        final List<UserInfo> users = mContext.getSystemService(UserManager.class).getUsers();
        killMediaProvider(users);
        final int[] systemUnlockedUsers;
        synchronized (mLock) {
            systemUnlockedUsers = mSystemUnlockedUsers;
            mDisks.clear();
            mVolumes.clear();
            addInternalVolumeLocked();
        }
        try {
            mVold.reset();
            // Tell vold about all existing and started users
            for (UserInfo user : users) {
                mVold.onUserAdded(user.id, user.serialNumber);
            }
            for (int userId : systemUnlockedUsers) {
                mVold.onUserStarted(userId);
                mStoraged.onUserStarted(userId);
            }
            mVold.onSecureKeyguardStateChanged(mSecureKeyguardShowing);
            mStorageManagerInternal.onReset(mVold);
        } catch (Exception e) {
            Slog.wtf(TAG, e);
        }
    }
}
#end_block

#method_before
@GuardedBy("mLock")
private void onVolumeCreatedLocked(VolumeInfo vol) {
    if (mPms.isOnlyCoreApps()) {
        Slog.d(TAG, "System booted in core-only mode; ignoring volume " + vol.getId());
        return;
    }
    if (vol.type == VolumeInfo.TYPE_EMULATED) {
        final StorageManager storage = mContext.getSystemService(StorageManager.class);
        final VolumeInfo privateVol = storage.findPrivateForEmulated(vol);
        if (Objects.equals(StorageManager.UUID_PRIVATE_INTERNAL, mPrimaryStorageUuid) && VolumeInfo.ID_PRIVATE_INTERNAL.equals(privateVol.id)) {
            Slog.v(TAG, "Found primary storage at " + vol);
            vol.mountFlags |= VolumeInfo.MOUNT_FLAG_PRIMARY;
            vol.mountFlags |= VolumeInfo.MOUNT_FLAG_VISIBLE;
            mHandler.obtainMessage(H_VOLUME_MOUNT, vol).sendToTarget();
        } else if (Objects.equals(privateVol.fsUuid, mPrimaryStorageUuid)) {
            Slog.v(TAG, "Found primary storage at " + vol);
            vol.mountFlags |= VolumeInfo.MOUNT_FLAG_PRIMARY;
            vol.mountFlags |= VolumeInfo.MOUNT_FLAG_VISIBLE;
            mHandler.obtainMessage(H_VOLUME_MOUNT, vol).sendToTarget();
        }
    } else if (vol.type == VolumeInfo.TYPE_PUBLIC) {
        // TODO: only look at first public partition
        if (Objects.equals(StorageManager.UUID_PRIMARY_PHYSICAL, mPrimaryStorageUuid) && vol.disk.isDefaultPrimary()) {
            Slog.v(TAG, "Found primary storage at " + vol);
            vol.mountFlags |= VolumeInfo.MOUNT_FLAG_PRIMARY;
            vol.mountFlags |= VolumeInfo.MOUNT_FLAG_VISIBLE;
        }
        // public API requirement of being in a stable location.
        if (vol.disk.isAdoptable()) {
            vol.mountFlags |= VolumeInfo.MOUNT_FLAG_VISIBLE;
        }
        vol.mountUserId = mCurrentUserId;
        mHandler.obtainMessage(H_VOLUME_MOUNT, vol).sendToTarget();
    } else if (vol.type == VolumeInfo.TYPE_PRIVATE) {
        mHandler.obtainMessage(H_VOLUME_MOUNT, vol).sendToTarget();
    } else {
        Slog.d(TAG, "Skipping automatic mounting of " + vol);
    }
}
#method_after
@GuardedBy("mLock")
private void onVolumeCreatedLocked(VolumeInfo vol) {
    if (mPms.isOnlyCoreApps()) {
        Slog.d(TAG, "System booted in core-only mode; ignoring volume " + vol.getId());
        return;
    }
    if (vol.type == VolumeInfo.TYPE_EMULATED) {
        final StorageManager storage = mContext.getSystemService(StorageManager.class);
        final VolumeInfo privateVol = storage.findPrivateForEmulated(vol);
        if (Objects.equals(StorageManager.UUID_PRIVATE_INTERNAL, mPrimaryStorageUuid) && VolumeInfo.ID_PRIVATE_INTERNAL.equals(privateVol.id)) {
            Slog.v(TAG, "Found primary storage at " + vol);
            vol.mountFlags |= VolumeInfo.MOUNT_FLAG_PRIMARY;
            vol.mountFlags |= VolumeInfo.MOUNT_FLAG_VISIBLE;
            mHandler.obtainMessage(H_VOLUME_MOUNT, vol).sendToTarget();
        } else if (Objects.equals(privateVol.fsUuid, mPrimaryStorageUuid)) {
            Slog.v(TAG, "Found primary storage at " + vol);
            vol.mountFlags |= VolumeInfo.MOUNT_FLAG_PRIMARY;
            vol.mountFlags |= VolumeInfo.MOUNT_FLAG_VISIBLE;
            mHandler.obtainMessage(H_VOLUME_MOUNT, vol).sendToTarget();
        }
    } else if (vol.type == VolumeInfo.TYPE_PUBLIC) {
        // TODO: only look at first public partition
        if (Objects.equals(StorageManager.UUID_PRIMARY_PHYSICAL, mPrimaryStorageUuid) && vol.disk.isDefaultPrimary()) {
            Slog.v(TAG, "Found primary storage at " + vol);
            vol.mountFlags |= VolumeInfo.MOUNT_FLAG_PRIMARY;
            vol.mountFlags |= VolumeInfo.MOUNT_FLAG_VISIBLE;
        }
        // public API requirement of being in a stable location.
        if (vol.disk.isAdoptable()) {
            vol.mountFlags |= VolumeInfo.MOUNT_FLAG_VISIBLE;
        }
        vol.mountUserId = mCurrentUserId;
        mHandler.obtainMessage(H_VOLUME_MOUNT, vol).sendToTarget();
    } else if (vol.type == VolumeInfo.TYPE_PRIVATE) {
        mHandler.obtainMessage(H_VOLUME_MOUNT, vol).sendToTarget();
    } else if (vol.type == VolumeInfo.TYPE_STUB) {
        vol.mountUserId = mCurrentUserId;
        mHandler.obtainMessage(H_VOLUME_MOUNT, vol).sendToTarget();
    } else {
        Slog.d(TAG, "Skipping automatic mounting of " + vol);
    }
}
#end_block

#method_before
private boolean isBroadcastWorthy(VolumeInfo vol) {
    switch(vol.getType()) {
        case VolumeInfo.TYPE_PRIVATE:
        case VolumeInfo.TYPE_PUBLIC:
        case VolumeInfo.TYPE_EMULATED:
            break;
        default:
            return false;
    }
    switch(vol.getState()) {
        case VolumeInfo.STATE_MOUNTED:
        case VolumeInfo.STATE_MOUNTED_READ_ONLY:
        case VolumeInfo.STATE_EJECTING:
        case VolumeInfo.STATE_UNMOUNTED:
        case VolumeInfo.STATE_UNMOUNTABLE:
        case VolumeInfo.STATE_BAD_REMOVAL:
            break;
        default:
            return false;
    }
    return true;
}
#method_after
private boolean isBroadcastWorthy(VolumeInfo vol) {
    switch(vol.getType()) {
        case VolumeInfo.TYPE_PRIVATE:
        case VolumeInfo.TYPE_PUBLIC:
        case VolumeInfo.TYPE_EMULATED:
        case VolumeInfo.TYPE_STUB:
            break;
        default:
            return false;
    }
    switch(vol.getState()) {
        case VolumeInfo.STATE_MOUNTED:
        case VolumeInfo.STATE_MOUNTED_READ_ONLY:
        case VolumeInfo.STATE_EJECTING:
        case VolumeInfo.STATE_UNMOUNTED:
        case VolumeInfo.STATE_UNMOUNTABLE:
        case VolumeInfo.STATE_BAD_REMOVAL:
            break;
        default:
            return false;
    }
    return true;
}
#end_block

#method_before
@GuardedBy("mLock")
private void onVolumeStateChangedLocked(VolumeInfo vol, int oldState, int newState) {
    // metadata, or so we can annoy them when a private volume is ejected
    if (vol.isMountedReadable() && !TextUtils.isEmpty(vol.fsUuid)) {
        VolumeRecord rec = mRecords.get(vol.fsUuid);
        if (rec == null) {
            rec = new VolumeRecord(vol.type, vol.fsUuid);
            rec.partGuid = vol.partGuid;
            rec.createdMillis = System.currentTimeMillis();
            if (vol.type == VolumeInfo.TYPE_PRIVATE) {
                rec.nickname = vol.disk.getDescription();
            }
            mRecords.put(rec.fsUuid, rec);
            writeSettingsLocked();
        } else {
            // Handle upgrade case where we didn't store partition GUID
            if (TextUtils.isEmpty(rec.partGuid)) {
                rec.partGuid = vol.partGuid;
                writeSettingsLocked();
            }
        }
    }
    mCallbacks.notifyVolumeStateChanged(vol, oldState, newState);
    // processes that receive the intent unnecessarily.
    if (mBootCompleted && isBroadcastWorthy(vol)) {
        final Intent intent = new Intent(VolumeInfo.ACTION_VOLUME_STATE_CHANGED);
        intent.putExtra(VolumeInfo.EXTRA_VOLUME_ID, vol.id);
        intent.putExtra(VolumeInfo.EXTRA_VOLUME_STATE, newState);
        intent.putExtra(VolumeRecord.EXTRA_FS_UUID, vol.fsUuid);
        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT | Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND);
        mHandler.obtainMessage(H_INTERNAL_BROADCAST, intent).sendToTarget();
    }
    final String oldStateEnv = VolumeInfo.getEnvironmentForState(oldState);
    final String newStateEnv = VolumeInfo.getEnvironmentForState(newState);
    if (!Objects.equals(oldStateEnv, newStateEnv)) {
        // user-specific broadcasts.
        for (int userId : mSystemUnlockedUsers) {
            if (vol.isVisibleForRead(userId)) {
                final StorageVolume userVol = vol.buildStorageVolume(mContext, userId, false);
                mHandler.obtainMessage(H_VOLUME_BROADCAST, userVol).sendToTarget();
                mCallbacks.notifyStorageStateChanged(userVol.getPath(), oldStateEnv, newStateEnv);
            }
        }
    }
    if (vol.type == VolumeInfo.TYPE_PUBLIC && vol.state == VolumeInfo.STATE_EJECTING) {
        // TODO: this should eventually be handled by new ObbVolume state changes
        /*
             * Some OBBs might have been unmounted when this volume was
             * unmounted, so send a message to the handler to let it know to
             * remove those from the list of mounted OBBS.
             */
        mObbActionHandler.sendMessage(mObbActionHandler.obtainMessage(OBB_FLUSH_MOUNT_STATE, vol.path));
    }
    maybeLogMediaMount(vol, newState);
}
#method_after
@GuardedBy("mLock")
private void onVolumeStateChangedLocked(VolumeInfo vol, int oldState, int newState) {
    // metadata, or so we can annoy them when a private volume is ejected
    if (vol.isMountedReadable() && !TextUtils.isEmpty(vol.fsUuid)) {
        VolumeRecord rec = mRecords.get(vol.fsUuid);
        if (rec == null) {
            rec = new VolumeRecord(vol.type, vol.fsUuid);
            rec.partGuid = vol.partGuid;
            rec.createdMillis = System.currentTimeMillis();
            if (vol.type == VolumeInfo.TYPE_PRIVATE) {
                rec.nickname = vol.disk.getDescription();
            }
            mRecords.put(rec.fsUuid, rec);
            writeSettingsLocked();
        } else {
            // Handle upgrade case where we didn't store partition GUID
            if (TextUtils.isEmpty(rec.partGuid)) {
                rec.partGuid = vol.partGuid;
                writeSettingsLocked();
            }
        }
    }
    mCallbacks.notifyVolumeStateChanged(vol, oldState, newState);
    // processes that receive the intent unnecessarily.
    if (mBootCompleted && isBroadcastWorthy(vol)) {
        final Intent intent = new Intent(VolumeInfo.ACTION_VOLUME_STATE_CHANGED);
        intent.putExtra(VolumeInfo.EXTRA_VOLUME_ID, vol.id);
        intent.putExtra(VolumeInfo.EXTRA_VOLUME_STATE, newState);
        intent.putExtra(VolumeRecord.EXTRA_FS_UUID, vol.fsUuid);
        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT | Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND);
        mHandler.obtainMessage(H_INTERNAL_BROADCAST, intent).sendToTarget();
    }
    final String oldStateEnv = VolumeInfo.getEnvironmentForState(oldState);
    final String newStateEnv = VolumeInfo.getEnvironmentForState(newState);
    if (!Objects.equals(oldStateEnv, newStateEnv)) {
        // user-specific broadcasts.
        for (int userId : mSystemUnlockedUsers) {
            if (vol.isVisibleForRead(userId)) {
                final StorageVolume userVol = vol.buildStorageVolume(mContext, userId, false);
                mHandler.obtainMessage(H_VOLUME_BROADCAST, userVol).sendToTarget();
                mCallbacks.notifyStorageStateChanged(userVol.getPath(), oldStateEnv, newStateEnv);
            }
        }
    }
    if ((vol.type == VolumeInfo.TYPE_PUBLIC || vol.type == VolumeInfo.TYPE_STUB) && vol.state == VolumeInfo.STATE_EJECTING) {
        // TODO: this should eventually be handled by new ObbVolume state changes
        /*
             * Some OBBs might have been unmounted when this volume was
             * unmounted, so send a message to the handler to let it know to
             * remove those from the list of mounted OBBS.
             */
        mObbActionHandler.sendMessage(mObbActionHandler.obtainMessage(OBB_FLUSH_MOUNT_STATE, vol.path));
    }
    maybeLogMediaMount(vol, newState);
}
#end_block

#method_before
private boolean isMountDisallowed(VolumeInfo vol) {
    UserManager userManager = mContext.getSystemService(UserManager.class);
    boolean isUsbRestricted = false;
    if (vol.disk != null && vol.disk.isUsb()) {
        isUsbRestricted = userManager.hasUserRestriction(UserManager.DISALLOW_USB_FILE_TRANSFER, Binder.getCallingUserHandle());
    }
    boolean isTypeRestricted = false;
    if (vol.type == VolumeInfo.TYPE_PUBLIC || vol.type == VolumeInfo.TYPE_PRIVATE) {
        isTypeRestricted = userManager.hasUserRestriction(UserManager.DISALLOW_MOUNT_PHYSICAL_MEDIA, Binder.getCallingUserHandle());
    }
    return isUsbRestricted || isTypeRestricted;
}
#method_after
private boolean isMountDisallowed(VolumeInfo vol) {
    UserManager userManager = mContext.getSystemService(UserManager.class);
    boolean isUsbRestricted = false;
    if (vol.disk != null && vol.disk.isUsb()) {
        isUsbRestricted = userManager.hasUserRestriction(UserManager.DISALLOW_USB_FILE_TRANSFER, Binder.getCallingUserHandle());
    }
    boolean isTypeRestricted = false;
    if (vol.type == VolumeInfo.TYPE_PUBLIC || vol.type == VolumeInfo.TYPE_PRIVATE || vol.type == VolumeInfo.TYPE_STUB) {
        isTypeRestricted = userManager.hasUserRestriction(UserManager.DISALLOW_MOUNT_PHYSICAL_MEDIA, Binder.getCallingUserHandle());
    }
    return isUsbRestricted || isTypeRestricted;
}
#end_block

#method_before
@Override
public StorageVolume[] getVolumeList(int uid, String packageName, int flags) {
    final int userId = UserHandle.getUserId(uid);
    final boolean forWrite = (flags & StorageManager.FLAG_FOR_WRITE) != 0;
    final boolean realState = (flags & StorageManager.FLAG_REAL_STATE) != 0;
    final boolean includeInvisible = (flags & StorageManager.FLAG_INCLUDE_INVISIBLE) != 0;
    final boolean userKeyUnlocked;
    final boolean storagePermission;
    final long token = Binder.clearCallingIdentity();
    try {
        userKeyUnlocked = isUserKeyUnlocked(userId);
        storagePermission = mStorageManagerInternal.hasExternalStorage(uid, packageName);
    } finally {
        Binder.restoreCallingIdentity(token);
    }
    boolean foundPrimary = false;
    final ArrayList<StorageVolume> res = new ArrayList<>();
    synchronized (mLock) {
        for (int i = 0; i < mVolumes.size(); i++) {
            final VolumeInfo vol = mVolumes.valueAt(i);
            switch(vol.getType()) {
                case VolumeInfo.TYPE_PUBLIC:
                case VolumeInfo.TYPE_EMULATED:
                    break;
                default:
                    continue;
            }
            boolean match = false;
            if (forWrite) {
                match = vol.isVisibleForWrite(userId);
            } else {
                match = vol.isVisibleForRead(userId) || (includeInvisible && vol.getPath() != null);
            }
            if (!match)
                continue;
            boolean reportUnmounted = false;
            if ((vol.getType() == VolumeInfo.TYPE_EMULATED) && !userKeyUnlocked) {
                reportUnmounted = true;
            } else if (!storagePermission && !realState) {
                reportUnmounted = true;
            }
            final StorageVolume userVol = vol.buildStorageVolume(mContext, userId, reportUnmounted);
            if (vol.isPrimary()) {
                res.add(0, userVol);
                foundPrimary = true;
            } else {
                res.add(userVol);
            }
        }
    }
    if (!foundPrimary) {
        Log.w(TAG, "No primary storage defined yet; hacking together a stub");
        final boolean primaryPhysical = SystemProperties.getBoolean(StorageManager.PROP_PRIMARY_PHYSICAL, false);
        final String id = "stub_primary";
        final File path = Environment.getLegacyExternalStorageDirectory();
        final String description = mContext.getString(android.R.string.unknownName);
        final boolean primary = true;
        final boolean removable = primaryPhysical;
        final boolean emulated = !primaryPhysical;
        final boolean allowMassStorage = false;
        final long maxFileSize = 0L;
        final UserHandle owner = new UserHandle(userId);
        final String uuid = null;
        final String state = Environment.MEDIA_REMOVED;
        res.add(0, new StorageVolume(id, path, path, description, primary, removable, emulated, allowMassStorage, maxFileSize, owner, uuid, state));
    }
    return res.toArray(new StorageVolume[res.size()]);
}
#method_after
@Override
public StorageVolume[] getVolumeList(int uid, String packageName, int flags) {
    final int userId = UserHandle.getUserId(uid);
    final boolean forWrite = (flags & StorageManager.FLAG_FOR_WRITE) != 0;
    final boolean realState = (flags & StorageManager.FLAG_REAL_STATE) != 0;
    final boolean includeInvisible = (flags & StorageManager.FLAG_INCLUDE_INVISIBLE) != 0;
    final boolean userKeyUnlocked;
    final boolean storagePermission;
    final long token = Binder.clearCallingIdentity();
    try {
        userKeyUnlocked = isUserKeyUnlocked(userId);
        storagePermission = mStorageManagerInternal.hasExternalStorage(uid, packageName);
    } finally {
        Binder.restoreCallingIdentity(token);
    }
    boolean foundPrimary = false;
    final ArrayList<StorageVolume> res = new ArrayList<>();
    synchronized (mLock) {
        for (int i = 0; i < mVolumes.size(); i++) {
            final VolumeInfo vol = mVolumes.valueAt(i);
            switch(vol.getType()) {
                case VolumeInfo.TYPE_PUBLIC:
                case VolumeInfo.TYPE_STUB:
                case VolumeInfo.TYPE_EMULATED:
                    break;
                default:
                    continue;
            }
            boolean match = false;
            if (forWrite) {
                match = vol.isVisibleForWrite(userId);
            } else {
                match = vol.isVisibleForRead(userId) || (includeInvisible && vol.getPath() != null);
            }
            if (!match)
                continue;
            boolean reportUnmounted = false;
            if ((vol.getType() == VolumeInfo.TYPE_EMULATED) && !userKeyUnlocked) {
                reportUnmounted = true;
            } else if (!storagePermission && !realState) {
                reportUnmounted = true;
            }
            final StorageVolume userVol = vol.buildStorageVolume(mContext, userId, reportUnmounted);
            if (vol.isPrimary()) {
                res.add(0, userVol);
                foundPrimary = true;
            } else {
                res.add(userVol);
            }
        }
    }
    if (!foundPrimary) {
        Log.w(TAG, "No primary storage defined yet; hacking together a stub");
        final boolean primaryPhysical = SystemProperties.getBoolean(StorageManager.PROP_PRIMARY_PHYSICAL, false);
        final String id = "stub_primary";
        final File path = Environment.getLegacyExternalStorageDirectory();
        final String description = mContext.getString(android.R.string.unknownName);
        final boolean primary = true;
        final boolean removable = primaryPhysical;
        final boolean emulated = !primaryPhysical;
        final boolean allowMassStorage = false;
        final long maxFileSize = 0L;
        final UserHandle owner = new UserHandle(userId);
        final String uuid = null;
        final String state = Environment.MEDIA_REMOVED;
        res.add(0, new StorageVolume(id, path, path, description, primary, removable, emulated, allowMassStorage, maxFileSize, owner, uuid, state));
    }
    return res.toArray(new StorageVolume[res.size()]);
}
#end_block

#method_before
public static List<EventMetricData> getEventMetricData(ITestDevice device, long configId) throws DeviceNotAvailableException {
    ConfigMetricsReportList reports = getReportList(device, configId);
    if (reports.getReportsList().size() == 0) {
        CLog.e("No stats report collected.");
        return new ArrayList<EventMetricData>();
    }
    ConfigMetricsReport report = reports.getReports(0);
    List<EventMetricData> data = new ArrayList<>();
    for (StatsLogReport metric : report.getMetricsList()) {
        data.addAll(metric.getEventMetrics().getDataList());
    }
    data.sort(Comparator.comparing(EventMetricData::getElapsedTimestampNanos));
    CLog.e("Get EventMetricDataList as following:\n");
    for (EventMetricData d : data) {
        CLog.e("Atom at " + d.getElapsedTimestampNanos() + ":\n" + d.getAtom().toString());
    }
    return data;
}
#method_after
public static List<EventMetricData> getEventMetricData(ITestDevice device, long configId) throws DeviceNotAvailableException {
    ConfigMetricsReportList reports = getReportList(device, configId);
    if (reports.getReportsList().isEmpty()) {
        CLog.i("No stats report collected.");
        return new ArrayList<EventMetricData>();
    }
    ConfigMetricsReport report = reports.getReports(0);
    List<EventMetricData> data = new ArrayList<>();
    for (StatsLogReport metric : report.getMetricsList()) {
        data.addAll(metric.getEventMetrics().getDataList());
    }
    data.sort(Comparator.comparing(EventMetricData::getElapsedTimestampNanos));
    CLog.i("Received EventMetricDataList as following:\n");
    for (EventMetricData d : data) {
        CLog.i("Atom at %d:\n%s", d.getElapsedTimestampNanos(), d.getAtom().toString());
    }
    return data;
}
#end_block

#method_before
@Test
public void testNonEmptyMetricReportList() throws DeviceNotAvailableException, IOException {
    byte[] sampleReportBytes = SAMPLE_REPORT_LIST_PROTO.toByteArray();
    // Mock executeShellCommand to supply the passed-in CollectingByteOutputReceiver with
    // SAMPLE_REPORT_LIST_PROTO.
    doAnswer(new Answer() {

        public Object answer(InvocationOnMock invocation) {
            ((CollectingByteOutputReceiver) invocation.getArguments()[1]).addOutput(sampleReportBytes, 0, sampleReportBytes.length);
            return null;
        }
    }).when(mTestDevice).executeShellCommand(matches(String.format(MetricUtil.DUMP_REPORT_CMD_TEMPLATE, String.valueOf(CONFIG_ID))), any(CollectingByteOutputReceiver.class));
    List<EventMetricData> data = MetricUtil.getEventMetricData(mTestDevice, CONFIG_ID);
    // Resulting list should have two metrics.
    assertThat(data.size()).comparesEqualTo(2);
    // The first metric should correspond to METRIC_2_* as its timestamp is earlier.
    assertThat(data.get(0).getElapsedTimestampNanos()).comparesEqualTo(METRIC_2_NANOS);
    assertThat(data.get(0).getAtom().hasBleScanResultReceived()).isTrue();
    // The second metric should correspond to METRIC_1_*.
    assertThat(data.get(1).getElapsedTimestampNanos()).comparesEqualTo(METRIC_1_NANOS);
    assertThat(data.get(1).getAtom().hasBleScanStateChanged()).isTrue();
}
#method_after
@Test
public void testNonEmptyMetricReportList() throws DeviceNotAvailableException, IOException {
    byte[] sampleReportBytes = SAMPLE_REPORT_LIST_PROTO.toByteArray();
    // Mock executeShellCommand to supply the passed-in CollectingByteOutputReceiver with
    // SAMPLE_REPORT_LIST_PROTO.
    doAnswer(new ExecuteShellCommandWithOutputAnswer(sampleReportBytes)).when(mTestDevice).executeShellCommand(matches(String.format(MetricUtil.DUMP_REPORT_CMD_TEMPLATE, String.valueOf(CONFIG_ID))), any(CollectingByteOutputReceiver.class));
    List<EventMetricData> data = MetricUtil.getEventMetricData(mTestDevice, CONFIG_ID);
    // Resulting list should have two metrics.
    assertThat(data.size()).comparesEqualTo(2);
    // The first metric should correspond to METRIC_2_* as its timestamp is earlier.
    assertThat(data.get(0).getElapsedTimestampNanos()).comparesEqualTo(METRIC_2_NANOS);
    assertThat(data.get(0).getAtom().hasBleScanResultReceived()).isTrue();
    // The second metric should correspond to METRIC_1_*.
    assertThat(data.get(1).getElapsedTimestampNanos()).comparesEqualTo(METRIC_1_NANOS);
    assertThat(data.get(1).getAtom().hasBleScanStateChanged()).isTrue();
}
#end_block

#method_before
@Test
public void testEmptyMetricReportList() throws DeviceNotAvailableException, IOException {
    byte[] emptyReportBytes = ConfigMetricsReport.newBuilder().build().toByteArray();
    // Mock executeShellCommand to supply the passed-in CollectingByteOutputReceiver with the
    // empty report list proto.
    doAnswer(new Answer() {

        public Object answer(InvocationOnMock invocation) {
            ((CollectingByteOutputReceiver) invocation.getArguments()[1]).addOutput(emptyReportBytes, 0, emptyReportBytes.length);
            return null;
        }
    }).when(mTestDevice).executeShellCommand(matches(String.format(MetricUtil.DUMP_REPORT_CMD_TEMPLATE, String.valueOf(CONFIG_ID))), any(CollectingByteOutputReceiver.class));
    List<EventMetricData> data = MetricUtil.getEventMetricData(mTestDevice, CONFIG_ID);
    // Resulting list should be empty.
    assertThat(data.size()).comparesEqualTo(0);
}
#method_after
@Test
public void testEmptyMetricReportList() throws DeviceNotAvailableException, IOException {
    byte[] emptyReportBytes = ConfigMetricsReport.newBuilder().build().toByteArray();
    // Mock executeShellCommand to supply the passed-in CollectingByteOutputReceiver with the
    // empty report list proto.
    doAnswer(new ExecuteShellCommandWithOutputAnswer(emptyReportBytes)).when(mTestDevice).executeShellCommand(matches(String.format(MetricUtil.DUMP_REPORT_CMD_TEMPLATE, String.valueOf(CONFIG_ID))), any(CollectingByteOutputReceiver.class));
    List<EventMetricData> data = MetricUtil.getEventMetricData(mTestDevice, CONFIG_ID);
    // Resulting list should be empty.
    assertThat(data.size()).comparesEqualTo(0);
}
#end_block

#method_before
@Test
public void testInvalidDumpedReportThrows() throws DeviceNotAvailableException, IOException {
    byte[] invalidProtoBytes = "not a proto".getBytes();
    // Mock executeShellCommand to supply the passed-in CollectingByteOutputReceiver with the
    // invalid proto bytes.
    doAnswer(new Answer() {

        public Object answer(InvocationOnMock invocation) {
            ((CollectingByteOutputReceiver) invocation.getArguments()[1]).addOutput(invalidProtoBytes, 0, invalidProtoBytes.length);
            return null;
        }
    }).when(mTestDevice).executeShellCommand(matches(String.format(MetricUtil.DUMP_REPORT_CMD_TEMPLATE, String.valueOf(CONFIG_ID))), any(CollectingByteOutputReceiver.class));
    try {
        List<EventMetricData> data = MetricUtil.getEventMetricData(mTestDevice, CONFIG_ID);
        fail("An exception should be thrown for the invalid proto data.");
    } catch (RuntimeException e) {
    // Expected behavior, no action required.
    }
}
#method_after
@Test
public void testInvalidDumpedReportThrows() throws DeviceNotAvailableException, IOException {
    byte[] invalidProtoBytes = "not a proto".getBytes();
    // Mock executeShellCommand to supply the passed-in CollectingByteOutputReceiver with the
    // invalid proto bytes.
    doAnswer(new ExecuteShellCommandWithOutputAnswer(invalidProtoBytes)).when(mTestDevice).executeShellCommand(matches(String.format(MetricUtil.DUMP_REPORT_CMD_TEMPLATE, String.valueOf(CONFIG_ID))), any(CollectingByteOutputReceiver.class));
    try {
        List<EventMetricData> data = MetricUtil.getEventMetricData(mTestDevice, CONFIG_ID);
        fail("An exception should be thrown for the invalid proto data.");
    } catch (RuntimeException e) {
    // Expected behavior, no action required.
    }
}
#end_block

#method_before
@Override
public void onTestStart(DataRecord testData, Description description) {
    // Increment method invocation count by 1 whenever there is a new invocation of the test
    // method.
    mTestIdInvocationCount.compute(getTestFullName(description), (key, value) -> (value == null) ? 1 : value + 1);
    Log.i(getTag(), "Starting perfetto before test started.");
    mPerfettoStartSuccess = mPerfettoHelper.startCollecting(mConfigFileName);
    if (!mPerfettoStartSuccess) {
        Log.e(getTag(), "Perfetto did not start successfully.");
    }
}
#method_after
@Override
public void onTestStart(DataRecord testData, Description description) {
    // Increment method invocation count by 1 whenever there is a new invocation of the test
    // method.
    mTestIdInvocationCount.compute(getTestFileName(description), (key, value) -> (value == null) ? 1 : value + 1);
    Log.i(getTag(), "Starting perfetto before test started.");
    mPerfettoStartSuccess = mPerfettoHelper.startCollecting(mConfigFileName);
    if (!mPerfettoStartSuccess) {
        Log.e(getTag(), "Perfetto did not start successfully.");
    }
}
#end_block

#method_before
@Override
public void onTestEnd(DataRecord testData, Description description) {
    if (mPerfettoStartSuccess) {
        Log.i(getTag(), "Stopping perfetto after test ended.");
        // Construct test output directory in the below format
        // <root_folder>/<test_display_name>/PerfettoListener/<test_display_name>-<count>.pb
        Path path = Paths.get(mTestOutputRoot, getTestFullName(description), this.getClass().getSimpleName(), String.format("%s-%d.pb", getTestFullName(description), mTestIdInvocationCount.get(getTestFullName(description))));
        Log.i(getTag(), "Full folder name" + path.toString());
        if (!mPerfettoHelper.stopCollecting(mWaitTimeInMs, path.toString())) {
            Log.e(getTag(), "Failed to collect the perfetto output.");
        }
    } else {
        Log.i(getTag(), "Skipping perfetto stop attempt because perfetto did not start successfully.");
    }
}
#method_after
@Override
public void onTestEnd(DataRecord testData, Description description) {
    if (mPerfettoStartSuccess) {
        Log.i(getTag(), "Stopping perfetto after test ended.");
        // Construct test output directory in the below format
        // <root_folder>/<test_display_name>/PerfettoListener/<test_display_name>-<count>.pb
        Path path = Paths.get(mTestOutputRoot, getTestFileName(description), this.getClass().getSimpleName(), String.format("%s-%d.pb", getTestFileName(description), mTestIdInvocationCount.get(getTestFileName(description))));
        Log.i(getTag(), "Full folder name" + path.toString());
        if (!mPerfettoHelper.stopCollecting(mWaitTimeInMs, path.toString())) {
            Log.e(getTag(), "Failed to collect the perfetto output.");
        }
    } else {
        Log.i(getTag(), "Skipping perfetto stop attempt because perfetto did not start successfully.");
    }
}
#end_block

#method_before
@Test
public void testPerfettoInvocationCount() throws Exception {
    Bundle b = new Bundle();
    mListener = initListener(b);
    doReturn(true).when(mPerfettoHelper).startCollecting(anyString());
    doReturn(true).when(mPerfettoHelper).stopCollecting(anyLong(), anyString());
    // Test run start behavior
    mListener.testRunStarted(mRunDesc);
    // Test1 invocation 1 start behavior
    mListener.testStarted(mTest1Desc);
    verify(mPerfettoHelper, times(1)).startCollecting(anyString());
    mListener.testFinished(mTest1Desc);
    verify(mPerfettoHelper, times(1)).stopCollecting(anyLong(), anyString());
    // Test1 invocation 2 start behaviour
    mListener.testStarted(mTest1Desc);
    verify(mPerfettoHelper, times(2)).startCollecting(anyString());
    mListener.testFinished(mTest1Desc);
    verify(mPerfettoHelper, times(2)).stopCollecting(anyLong(), anyString());
    // Test2 invocation 1 start behaviour
    mListener.testStarted(mTest2Desc);
    verify(mPerfettoHelper, times(3)).startCollecting(anyString());
    mListener.testFinished(mTest2Desc);
    verify(mPerfettoHelper, times(3)).stopCollecting(anyLong(), anyString());
    // Check if the the test count is incremented properly.
    assertEquals(2, (int) mInvocationCount.get(mListener.getTestFullName(mTest1Desc)));
    assertEquals(1, (int) mInvocationCount.get(mListener.getTestFullName(mTest2Desc)));
}
#method_after
@Test
public void testPerfettoInvocationCount() throws Exception {
    Bundle b = new Bundle();
    mListener = initListener(b);
    doReturn(true).when(mPerfettoHelper).startCollecting(anyString());
    doReturn(true).when(mPerfettoHelper).stopCollecting(anyLong(), anyString());
    // Test run start behavior
    mListener.testRunStarted(mRunDesc);
    // Test1 invocation 1 start behavior
    mListener.testStarted(mTest1Desc);
    verify(mPerfettoHelper, times(1)).startCollecting(anyString());
    mListener.testFinished(mTest1Desc);
    verify(mPerfettoHelper, times(1)).stopCollecting(anyLong(), anyString());
    // Test1 invocation 2 start behaviour
    mListener.testStarted(mTest1Desc);
    verify(mPerfettoHelper, times(2)).startCollecting(anyString());
    mListener.testFinished(mTest1Desc);
    verify(mPerfettoHelper, times(2)).stopCollecting(anyLong(), anyString());
    // Test2 invocation 1 start behaviour
    mListener.testStarted(mTest2Desc);
    verify(mPerfettoHelper, times(3)).startCollecting(anyString());
    mListener.testFinished(mTest2Desc);
    verify(mPerfettoHelper, times(3)).stopCollecting(anyLong(), anyString());
    // Check if the the test count is incremented properly.
    assertEquals(2, (int) mInvocationCount.get(mListener.getTestFileName(mTest1Desc)));
    assertEquals(1, (int) mInvocationCount.get(mListener.getTestFileName(mTest2Desc)));
}
#end_block

#method_before
// /////////////////////////////////////////////////
// Protected or private methods
private void attachMediaControlView() {
    // Get MediaController from MediaSession and set it inside MediaControlView
    mMediaControlView.setMediaSessionToken2(mMediaSession.getToken());
    LayoutParams params = new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT);
    mInstance.addView(mMediaControlView, params);
}
#method_after
// /////////////////////////////////////////////////
// Protected or private methods
private void attachMediaControlView() {
    // Get MediaController from MediaSession and set it inside MediaControlView
    mMediaControlView.setSessionToken(mMediaSession.getToken());
    LayoutParams params = new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT);
    mInstance.addView(mMediaControlView, params);
}
#end_block

#method_before
void ensureSessionWithPlayer(SessionPlayer2 player) {
    if (mMediaSession != null) {
        SessionPlayer2 oldPlayer = mMediaSession.getPlayer();
        if (oldPlayer == player) {
            return;
        }
        oldPlayer.unregisterPlayerCallback(mMediaPlayerCallback);
        mMediaSession.updatePlayer(player);
    } else {
        final Context context = mInstance.getContext();
        mMediaSession = new MediaSession2.Builder(context, player).setId("VideoView2_" + mInstance.toString()).setSessionCallback(mCallbackExecutor, new MediaSessionCallback()).build();
    }
    player.registerPlayerCallback(mCallbackExecutor, mMediaPlayerCallback);
}
#method_after
void ensureSessionWithPlayer(SessionPlayer player) {
    if (mMediaSession != null) {
        SessionPlayer oldPlayer = mMediaSession.getPlayer();
        if (oldPlayer == player) {
            return;
        }
        oldPlayer.unregisterPlayerCallback(mMediaPlayerCallback);
        mMediaSession.updatePlayer(player);
    } else {
        final Context context = mInstance.getContext();
        mMediaSession = new MediaSession.Builder(context, player).setId("VideoView2_" + mInstance.toString()).setSessionCallback(mCallbackExecutor, new MediaSessionCallback()).build();
    }
    player.registerPlayerCallback(mCallbackExecutor, mMediaPlayerCallback);
}
#end_block

#method_before
private boolean isMediaPrepared() {
    return mMediaSession != null && mMediaSession.getPlayer().getPlayerState() != SessionPlayer2.PLAYER_STATE_ERROR && mMediaSession.getPlayer().getPlayerState() != SessionPlayer2.PLAYER_STATE_IDLE;
}
#method_after
private boolean isMediaPrepared() {
    return mMediaSession != null && mMediaSession.getPlayer().getPlayerState() != SessionPlayer.PLAYER_STATE_ERROR && mMediaSession.getPlayer().getPlayerState() != SessionPlayer.PLAYER_STATE_IDLE;
}
#end_block

#method_before
boolean isRemotePlayback() {
    return mRoutePlayer != null && mMediaSession != null && (mMediaSession.getPlayer() instanceof RemoteSessionPlayer2);
}
#method_after
boolean isRemotePlayback() {
    return mRoutePlayer != null && mMediaSession != null && (mMediaSession.getPlayer() instanceof RemoteSessionPlayer);
}
#end_block

#method_before
void selectSubtitleTrack(int trackIndex) {
    if (!isMediaPrepared()) {
        return;
    }
    SubtitleTrack track = mSubtitleTracks.get(trackIndex);
    if (track != null) {
        mMediaPlayer.selectTrack(trackIndex);
        mSubtitleController.selectTrack(track);
        mSelectedSubtitleTrackIndex = trackIndex;
        mSubtitleAnchorView.setVisibility(View.VISIBLE);
        Bundle data = new Bundle();
        data.putInt(MediaControlView2.KEY_SELECTED_SUBTITLE_INDEX, mSubtitleTracks.indexOfKey(trackIndex));
        mMediaSession.broadcastCustomCommand(new SessionCommand2(MediaControlView2.EVENT_UPDATE_SUBTITLE_SELECTED, null), data);
    }
}
#method_after
void selectSubtitleTrack(int trackIndex) {
    if (!isMediaPrepared()) {
        return;
    }
    SubtitleTrack track = mSubtitleTracks.get(trackIndex);
    if (track != null) {
        mMediaPlayer.selectTrack(trackIndex);
        mSubtitleController.selectTrack(track);
        mSelectedSubtitleTrackIndex = trackIndex;
        mSubtitleAnchorView.setVisibility(View.VISIBLE);
        Bundle data = new Bundle();
        data.putInt(MediaControlView2.KEY_SELECTED_SUBTITLE_INDEX, mSubtitleTracks.indexOfKey(trackIndex));
        mMediaSession.broadcastCustomCommand(new SessionCommand(MediaControlView2.EVENT_UPDATE_SUBTITLE_SELECTED, null), data);
    }
}
#end_block

#method_before
void deselectSubtitleTrack() {
    if (!isMediaPrepared() || mSelectedSubtitleTrackIndex == INVALID_TRACK_INDEX) {
        return;
    }
    mMediaPlayer.deselectTrack(mSelectedSubtitleTrackIndex);
    mSelectedSubtitleTrackIndex = INVALID_TRACK_INDEX;
    mSubtitleAnchorView.setVisibility(View.GONE);
    mMediaSession.broadcastCustomCommand(new SessionCommand2(MediaControlView2.EVENT_UPDATE_SUBTITLE_DESELECTED, null), null);
}
#method_after
void deselectSubtitleTrack() {
    if (!isMediaPrepared() || mSelectedSubtitleTrackIndex == INVALID_TRACK_INDEX) {
        return;
    }
    mMediaPlayer.deselectTrack(mSelectedSubtitleTrackIndex);
    mSelectedSubtitleTrackIndex = INVALID_TRACK_INDEX;
    mSubtitleAnchorView.setVisibility(View.GONE);
    mMediaSession.broadcastCustomCommand(new SessionCommand(MediaControlView2.EVENT_UPDATE_SUBTITLE_DESELECTED, null), null);
}
#end_block

#method_before
MediaMetadata2 extractMetadata() {
    MediaMetadataRetriever retriever = null;
    String path = "";
    try {
        if (mMediaItem == null) {
            return null;
        } else if (mMediaItem instanceof UriMediaItem2) {
            Uri uri = ((UriMediaItem2) mMediaItem).getUri();
            // Save file name as title since the file may not have a title Metadata.
            String scheme = uri.getScheme();
            if (scheme != null) {
                if (scheme.equals("file")) {
                    path = uri.getLastPathSegment();
                } else if (scheme.equals("http") || scheme.equals("https")) {
                    path = uri.getPath();
                }
            }
            retriever = new MediaMetadataRetriever();
            retriever.setDataSource(mInstance.getContext(), uri);
        } else if (mMediaItem instanceof FileMediaItem2) {
            retriever = new MediaMetadataRetriever();
            retriever.setDataSource(((FileMediaItem2) mMediaItem).getFileDescriptor(), ((FileMediaItem2) mMediaItem).getFileDescriptorOffset(), ((FileMediaItem2) mMediaItem).getFileDescriptorLength());
        }
    } catch (IllegalArgumentException e) {
        Log.v(TAG, "Cannot retrieve metadata for this media file.");
        retriever = null;
    }
    MediaMetadata2 metadata = mMediaItem.getMetadata();
    if (!mIsMusicMediaType) {
        mTitle = extractString(metadata, MediaMetadata2.METADATA_KEY_TITLE, retriever, MediaMetadataRetriever.METADATA_KEY_TITLE, path);
    } else {
        Resources resources = mInstance.getResources();
        mManager = (WindowManager) mInstance.getContext().getApplicationContext().getSystemService(Context.WINDOW_SERVICE);
        mTitle = extractString(metadata, MediaMetadata2.METADATA_KEY_TITLE, retriever, MediaMetadataRetriever.METADATA_KEY_TITLE, resources.getString(R.string.mcv2_music_title_unknown_text));
        mMusicArtistText = extractString(metadata, MediaMetadata2.METADATA_KEY_ARTIST, retriever, MediaMetadataRetriever.METADATA_KEY_ARTIST, resources.getString(R.string.mcv2_music_artist_unknown_text));
        mMusicAlbumDrawable = extractAlbumArt(metadata, retriever, resources.getDrawable(R.drawable.ic_default_album_image));
    }
    if (retriever != null) {
        retriever.release();
    }
    // Update Music View to reflect the new metadata
    if (mIsMusicMediaType) {
        mInstance.removeView(mSurfaceView);
        mInstance.removeView(mTextureView);
        updateCurrentMusicView(mMusicEmbeddedView);
    }
    // Set duration and title values as MediaMetadata2 for MediaControlView2
    MediaMetadata2.Builder builder = new MediaMetadata2.Builder();
    if (mIsMusicMediaType) {
        builder.putString(MediaMetadata2.METADATA_KEY_ARTIST, mMusicArtistText);
    }
    builder.putString(MediaMetadata2.METADATA_KEY_TITLE, mTitle);
    builder.putLong(MediaMetadata2.METADATA_KEY_DURATION, mMediaSession.getPlayer().getDuration());
    builder.putString(MediaMetadata2.METADATA_KEY_MEDIA_ID, mMediaItem.getMediaId());
    builder.putLong(MediaMetadata2.METADATA_KEY_BROWSABLE, MediaMetadata2.BROWSABLE_TYPE_NONE);
    builder.putLong(MediaMetadata2.METADATA_KEY_PLAYABLE, 1);
    return builder.build();
}
#method_after
MediaMetadata extractMetadata() {
    MediaMetadataRetriever retriever = null;
    String path = "";
    try {
        if (mMediaItem == null) {
            return null;
        } else if (mMediaItem instanceof UriMediaItem) {
            Uri uri = ((UriMediaItem) mMediaItem).getUri();
            // Save file name as title since the file may not have a title Metadata.
            String scheme = uri.getScheme();
            if (scheme != null) {
                if (scheme.equals("file")) {
                    path = uri.getLastPathSegment();
                } else if (scheme.equals("http") || scheme.equals("https")) {
                    path = uri.getPath();
                }
            }
            retriever = new MediaMetadataRetriever();
            retriever.setDataSource(mInstance.getContext(), uri);
        } else if (mMediaItem instanceof FileMediaItem) {
            retriever = new MediaMetadataRetriever();
            retriever.setDataSource(((FileMediaItem) mMediaItem).getFileDescriptor(), ((FileMediaItem) mMediaItem).getFileDescriptorOffset(), ((FileMediaItem) mMediaItem).getFileDescriptorLength());
        }
    } catch (IllegalArgumentException e) {
        Log.v(TAG, "Cannot retrieve metadata for this media file.");
        retriever = null;
    }
    MediaMetadata metadata = mMediaItem.getMetadata();
    if (!mIsMusicMediaType) {
        mTitle = extractString(metadata, MediaMetadata.METADATA_KEY_TITLE, retriever, MediaMetadataRetriever.METADATA_KEY_TITLE, path);
    } else {
        Resources resources = mInstance.getResources();
        mManager = (WindowManager) mInstance.getContext().getApplicationContext().getSystemService(Context.WINDOW_SERVICE);
        mTitle = extractString(metadata, MediaMetadata.METADATA_KEY_TITLE, retriever, MediaMetadataRetriever.METADATA_KEY_TITLE, resources.getString(R.string.mcv2_music_title_unknown_text));
        mMusicArtistText = extractString(metadata, MediaMetadata.METADATA_KEY_ARTIST, retriever, MediaMetadataRetriever.METADATA_KEY_ARTIST, resources.getString(R.string.mcv2_music_artist_unknown_text));
        mMusicAlbumDrawable = extractAlbumArt(metadata, retriever, resources.getDrawable(R.drawable.ic_default_album_image));
    }
    if (retriever != null) {
        retriever.release();
    }
    // Update Music View to reflect the new metadata
    if (mIsMusicMediaType) {
        mInstance.removeView(mSurfaceView);
        mInstance.removeView(mTextureView);
        updateCurrentMusicView(mMusicEmbeddedView);
    }
    // Set duration and title values as MediaMetadata for MediaControlView2
    MediaMetadata.Builder builder = new MediaMetadata.Builder();
    if (mIsMusicMediaType) {
        builder.putString(MediaMetadata.METADATA_KEY_ARTIST, mMusicArtistText);
    }
    builder.putString(MediaMetadata.METADATA_KEY_TITLE, mTitle);
    builder.putLong(MediaMetadata.METADATA_KEY_DURATION, mMediaSession.getPlayer().getDuration());
    builder.putString(MediaMetadata.METADATA_KEY_MEDIA_ID, mMediaItem.getMediaId());
    builder.putLong(MediaMetadata.METADATA_KEY_BROWSABLE, MediaMetadata.BROWSABLE_TYPE_NONE);
    builder.putLong(MediaMetadata.METADATA_KEY_PLAYABLE, 1);
    return builder.build();
}
#end_block

#method_before
private String extractString(MediaMetadata2 metadata, String stringKey, MediaMetadataRetriever retriever, int intKey, String defaultValue) {
    String value = null;
    if (metadata != null) {
        value = metadata.getString(stringKey);
        if (value != null && !value.isEmpty()) {
            return value;
        }
    }
    if (retriever != null) {
        value = retriever.extractMetadata(intKey);
    }
    return value == null ? defaultValue : value;
}
#method_after
private String extractString(MediaMetadata metadata, String stringKey, MediaMetadataRetriever retriever, int intKey, String defaultValue) {
    String value = null;
    if (metadata != null) {
        value = metadata.getString(stringKey);
        if (value != null && !value.isEmpty()) {
            return value;
        }
    }
    if (retriever != null) {
        value = retriever.extractMetadata(intKey);
    }
    return value == null ? defaultValue : value;
}
#end_block

#method_before
private Drawable extractAlbumArt(MediaMetadata2 metadata, MediaMetadataRetriever retriever, Drawable defaultDrawable) {
    Bitmap bitmap = null;
    if (metadata != null && metadata.containsKey(MediaMetadata2.METADATA_KEY_ALBUM_ART)) {
        bitmap = metadata.getBitmap(MediaMetadata2.METADATA_KEY_ALBUM_ART);
    } else if (retriever != null) {
        byte[] album = retriever.getEmbeddedPicture();
        if (album != null) {
            bitmap = BitmapFactory.decodeByteArray(album, 0, album.length);
        }
    }
    if (bitmap != null) {
        Palette.Builder builder = Palette.from(bitmap);
        builder.generate(new Palette.PaletteAsyncListener() {

            @Override
            public void onGenerated(Palette palette) {
                mDominantColor = palette.getDominantColor(0);
                if (mCurrentMusicView != null) {
                    mCurrentMusicView.setBackgroundColor(mDominantColor);
                }
            }
        });
        return new BitmapDrawable(bitmap);
    }
    return defaultDrawable;
}
#method_after
private Drawable extractAlbumArt(MediaMetadata metadata, MediaMetadataRetriever retriever, Drawable defaultDrawable) {
    Bitmap bitmap = null;
    if (metadata != null && metadata.containsKey(MediaMetadata.METADATA_KEY_ALBUM_ART)) {
        bitmap = metadata.getBitmap(MediaMetadata.METADATA_KEY_ALBUM_ART);
    } else if (retriever != null) {
        byte[] album = retriever.getEmbeddedPicture();
        if (album != null) {
            bitmap = BitmapFactory.decodeByteArray(album, 0, album.length);
        }
    }
    if (bitmap != null) {
        Palette.Builder builder = Palette.from(bitmap);
        builder.generate(new Palette.PaletteAsyncListener() {

            @Override
            public void onGenerated(Palette palette) {
                mDominantColor = palette.getDominantColor(0);
                if (mCurrentMusicView != null) {
                    mCurrentMusicView.setBackgroundColor(mDominantColor);
                }
            }
        });
        return new BitmapDrawable(bitmap);
    }
    return defaultDrawable;
}
#end_block

#method_before
@Override
public SessionCommandGroup2 onConnect(@NonNull MediaSession2 session, @NonNull MediaSession2.ControllerInfo controller) {
    if (session != mMediaSession) {
        if (DEBUG) {
            Log.w(TAG, "onConnect() is ignored. session is already gone.");
        }
    }
    SessionCommandGroup2.Builder commandsBuilder = new SessionCommandGroup2.Builder().addCommand(SessionCommand2.COMMAND_CODE_PLAYER_PAUSE).addCommand(SessionCommand2.COMMAND_CODE_PLAYER_PLAY).addCommand(SessionCommand2.COMMAND_CODE_PLAYER_PREPARE).addCommand(SessionCommand2.COMMAND_CODE_PLAYER_SET_SPEED).addCommand(SessionCommand2.COMMAND_CODE_SESSION_FAST_FORWARD).addCommand(SessionCommand2.COMMAND_CODE_SESSION_REWIND).addCommand(SessionCommand2.COMMAND_CODE_PLAYER_SKIP_TO_NEXT_PLAYLIST_ITEM).addCommand(SessionCommand2.COMMAND_CODE_PLAYER_SKIP_TO_PREVIOUS_PLAYLIST_ITEM).addCommand(SessionCommand2.COMMAND_CODE_PLAYER_SEEK_TO).addCommand(SessionCommand2.COMMAND_CODE_VOLUME_SET_VOLUME).addCommand(SessionCommand2.COMMAND_CODE_VOLUME_ADJUST_VOLUME).addCommand(SessionCommand2.COMMAND_CODE_SESSION_PLAY_FROM_URI).addCommand(SessionCommand2.COMMAND_CODE_SESSION_PREPARE_FROM_URI).addCommand(SessionCommand2.COMMAND_CODE_SESSION_SELECT_ROUTE).addCommand(SessionCommand2.COMMAND_CODE_PLAYER_GET_PLAYLIST).addCommand(SessionCommand2.COMMAND_CODE_PLAYER_GET_PLAYLIST_METADATA).addCommand(new SessionCommand2(MediaControlView2.COMMAND_SELECT_AUDIO_TRACK, null)).addCommand(new SessionCommand2(MediaControlView2.COMMAND_SHOW_SUBTITLE, null)).addCommand(new SessionCommand2(MediaControlView2.COMMAND_HIDE_SUBTITLE, null));
    return commandsBuilder.build();
}
#method_after
@Override
public SessionCommandGroup onConnect(@NonNull MediaSession session, @NonNull MediaSession.ControllerInfo controller) {
    if (session != mMediaSession) {
        if (DEBUG) {
            Log.w(TAG, "onConnect() is ignored. session is already gone.");
        }
    }
    SessionCommandGroup.Builder commandsBuilder = new SessionCommandGroup.Builder().addCommand(SessionCommand.COMMAND_CODE_PLAYER_PAUSE).addCommand(SessionCommand.COMMAND_CODE_PLAYER_PLAY).addCommand(SessionCommand.COMMAND_CODE_PLAYER_PREPARE).addCommand(SessionCommand.COMMAND_CODE_PLAYER_SET_SPEED).addCommand(SessionCommand.COMMAND_CODE_SESSION_FAST_FORWARD).addCommand(SessionCommand.COMMAND_CODE_SESSION_REWIND).addCommand(SessionCommand.COMMAND_CODE_PLAYER_SEEK_TO).addCommand(SessionCommand.COMMAND_CODE_VOLUME_SET_VOLUME).addCommand(SessionCommand.COMMAND_CODE_VOLUME_ADJUST_VOLUME).addCommand(SessionCommand.COMMAND_CODE_SESSION_PLAY_FROM_URI).addCommand(SessionCommand.COMMAND_CODE_SESSION_PREPARE_FROM_URI).addCommand(SessionCommand.COMMAND_CODE_PLAYER_GET_PLAYLIST).addCommand(SessionCommand.COMMAND_CODE_PLAYER_GET_PLAYLIST_METADATA).addCommand(new SessionCommand(MediaControlView2.COMMAND_SELECT_AUDIO_TRACK, null)).addCommand(new SessionCommand(MediaControlView2.COMMAND_SHOW_SUBTITLE, null)).addCommand(new SessionCommand(MediaControlView2.COMMAND_HIDE_SUBTITLE, null));
    return commandsBuilder.build();
}
#end_block

#method_before
@Override
public MediaSession2.SessionResult onCustomCommand(@NonNull MediaSession2 session, @NonNull MediaSession2.ControllerInfo controller, @NonNull SessionCommand2 customCommand, @Nullable Bundle args) {
    if (session != mMediaSession) {
        if (DEBUG) {
            Log.w(TAG, "onCustomCommand() is ignored. session is already gone.");
        }
    }
    if (isRemotePlayback()) {
        // TODO: call mRoutePlayer.onCommand()
        return new MediaSession2.SessionResult(RESULT_CODE_SUCCESS, null);
    }
    switch(customCommand.getCustomCommand()) {
        case MediaControlView2.COMMAND_SHOW_SUBTITLE:
            int subtitleIndex = args != null ? args.getInt(MediaControlView2.KEY_SELECTED_SUBTITLE_INDEX, INVALID_TRACK_INDEX) : INVALID_TRACK_INDEX;
            if (subtitleIndex != INVALID_TRACK_INDEX) {
                int subtitleTrackIndex = mSubtitleTracks.keyAt(subtitleIndex);
                if (subtitleTrackIndex != mSelectedSubtitleTrackIndex) {
                    selectSubtitleTrack(subtitleTrackIndex);
                }
            }
            break;
        case MediaControlView2.COMMAND_HIDE_SUBTITLE:
            deselectSubtitleTrack();
            break;
        case MediaControlView2.COMMAND_SELECT_AUDIO_TRACK:
            int audioIndex = (args != null) ? args.getInt(MediaControlView2.KEY_SELECTED_AUDIO_INDEX, INVALID_TRACK_INDEX) : INVALID_TRACK_INDEX;
            if (audioIndex != INVALID_TRACK_INDEX) {
                int audioTrackIndex = mAudioTrackIndices.get(audioIndex);
                if (audioTrackIndex != mSelectedAudioTrackIndex) {
                    mSelectedAudioTrackIndex = audioTrackIndex;
                    mMediaPlayer.selectTrack(mSelectedAudioTrackIndex);
                }
            }
            break;
    }
    return new MediaSession2.SessionResult(RESULT_CODE_SUCCESS, null);
}
#method_after
@Override
public MediaSession.SessionResult onCustomCommand(@NonNull MediaSession session, @NonNull MediaSession.ControllerInfo controller, @NonNull SessionCommand customCommand, @Nullable Bundle args) {
    if (session != mMediaSession) {
        if (DEBUG) {
            Log.w(TAG, "onCustomCommand() is ignored. session is already gone.");
        }
    }
    if (isRemotePlayback()) {
        // TODO: call mRoutePlayer.onCommand()
        return new MediaSession.SessionResult(RESULT_CODE_SUCCESS, null);
    }
    switch(customCommand.getCustomCommand()) {
        case MediaControlView2.COMMAND_SHOW_SUBTITLE:
            int subtitleIndex = args != null ? args.getInt(MediaControlView2.KEY_SELECTED_SUBTITLE_INDEX, INVALID_TRACK_INDEX) : INVALID_TRACK_INDEX;
            if (subtitleIndex != INVALID_TRACK_INDEX) {
                int subtitleTrackIndex = mSubtitleTracks.keyAt(subtitleIndex);
                if (subtitleTrackIndex != mSelectedSubtitleTrackIndex) {
                    selectSubtitleTrack(subtitleTrackIndex);
                }
            }
            break;
        case MediaControlView2.COMMAND_HIDE_SUBTITLE:
            deselectSubtitleTrack();
            break;
        case MediaControlView2.COMMAND_SELECT_AUDIO_TRACK:
            int audioIndex = (args != null) ? args.getInt(MediaControlView2.KEY_SELECTED_AUDIO_INDEX, INVALID_TRACK_INDEX) : INVALID_TRACK_INDEX;
            if (audioIndex != INVALID_TRACK_INDEX) {
                int audioTrackIndex = mAudioTrackIndices.get(audioIndex);
                if (audioTrackIndex != mSelectedAudioTrackIndex) {
                    mSelectedAudioTrackIndex = audioTrackIndex;
                    mMediaPlayer.selectTrack(mSelectedAudioTrackIndex);
                }
            }
            break;
    }
    return new MediaSession.SessionResult(RESULT_CODE_SUCCESS, null);
}
#end_block

#method_before
@Override
public int onCommandRequest(@NonNull MediaSession2 session, @NonNull MediaSession2.ControllerInfo controller, @NonNull SessionCommand2 command) {
    if (session != mMediaSession) {
        if (DEBUG) {
            Log.w(TAG, "onCommandRequest() is ignored. session is already gone.");
        }
    }
    switch(command.getCommandCode()) {
        case SessionCommand2.COMMAND_CODE_PLAYER_PLAY:
            mTargetState = STATE_PLAYING;
            if (!mCurrentView.hasAvailableSurface() && !mIsMusicMediaType) {
                Log.d(TAG, "surface is not available");
                return RESULT_CODE_INVALID_STATE;
            }
            break;
        case SessionCommand2.COMMAND_CODE_PLAYER_PAUSE:
            mTargetState = STATE_PAUSED;
            break;
        case SessionCommand2.COMMAND_CODE_PLAYER_SEEK_TO:
            mSeekWhenPrepared = 0;
            break;
    }
    return RESULT_CODE_SUCCESS;
}
#method_after
@Override
public int onCommandRequest(@NonNull MediaSession session, @NonNull MediaSession.ControllerInfo controller, @NonNull SessionCommand command) {
    if (session != mMediaSession) {
        if (DEBUG) {
            Log.w(TAG, "onCommandRequest() is ignored. session is already gone.");
        }
    }
    switch(command.getCommandCode()) {
        case SessionCommand.COMMAND_CODE_PLAYER_PLAY:
            mTargetState = STATE_PLAYING;
            if (!mCurrentView.hasAvailableSurface() && !mIsMusicMediaType) {
                Log.d(TAG, "surface is not available");
                return RESULT_CODE_INVALID_STATE;
            }
            break;
        case SessionCommand.COMMAND_CODE_PLAYER_PAUSE:
            mTargetState = STATE_PAUSED;
            break;
        case SessionCommand.COMMAND_CODE_PLAYER_SEEK_TO:
            mSeekWhenPrepared = 0;
            break;
    }
    return RESULT_CODE_SUCCESS;
}
#end_block

#method_before
@Test
@MediumTest
public void testPlayAudioOnce() throws Exception {
    assertTrue(loadResource(R.raw.testmp3_2));
    AudioAttributesCompat attributes = new AudioAttributesCompat.Builder().setLegacyStreamType(AudioManager.STREAM_MUSIC).build();
    mPlayer.setAudioAttributes(attributes);
    final TestUtils.Monitor playing = new TestUtils.Monitor();
    mPlayer.registerPlayerCallback(mExecutor, new SessionPlayer2.PlayerCallback() {

        @Override
        public void onPlayerStateChanged(SessionPlayer2 player, int playerState) {
            playing.signal();
        }
    });
    mPlayer.prepare();
    mPlayer.play();
    assertTrue(playing.waitForSignal(SLEEP_TIME));
}
#method_after
@Test
@MediumTest
public void testPlayAudioOnce() throws Exception {
    assertTrue(loadResource(R.raw.testmp3_2));
    AudioAttributesCompat attributes = new AudioAttributesCompat.Builder().setLegacyStreamType(AudioManager.STREAM_MUSIC).build();
    mPlayer.setAudioAttributes(attributes);
    final TestUtils.Monitor playing = new TestUtils.Monitor();
    mPlayer.registerPlayerCallback(mExecutor, new SessionPlayer.PlayerCallback() {

        @Override
        public void onPlayerStateChanged(SessionPlayer player, int playerState) {
            playing.signal();
        }
    });
    mPlayer.prepare();
    mPlayer.play();
    assertTrue(playing.waitForSignal(SLEEP_TIME));
}
#end_block

#method_before
@Test
@LargeTest
public void testPlayAudio() throws Exception {
    final int resid = R.raw.testmp3_2;
    final int mp3Duration = 34909;
    final int tolerance = 70;
    final int seekDuration = 100;
    AssetFileDescriptor afd = mResources.openRawResourceFd(resid);
    mPlayer.setMediaItem(new FileMediaItem2.Builder(afd.getFileDescriptor(), afd.getStartOffset(), afd.getLength()).build());
    AudioAttributesCompat attributes = new AudioAttributesCompat.Builder().setLegacyStreamType(AudioManager.STREAM_MUSIC).build();
    mPlayer.setAudioAttributes(attributes);
    ListenableFuture<PlayerResult> future = mPlayer.prepare();
    assertEquals(RESULT_CODE_SUCCESS, future.get().getResultCode());
    assertFalse(mPlayer.getPlayerState() == MediaPlayer.PLAYER_STATE_PLAYING);
    future = mPlayer.play();
    assertEquals(RESULT_CODE_SUCCESS, future.get().getResultCode());
    assertTrue(mPlayer.getPlayerState() == MediaPlayer.PLAYER_STATE_PLAYING);
    assertEquals(mp3Duration, mPlayer.getDuration(), tolerance);
    long pos = mPlayer.getCurrentPosition();
    assertTrue(pos >= 0);
    assertTrue(pos < mp3Duration - seekDuration);
    future = mPlayer.seekTo(pos + seekDuration, MediaPlayer2.SEEK_PREVIOUS_SYNC);
    assertEquals(RESULT_CODE_SUCCESS, future.get().getResultCode());
    assertEquals(pos + seekDuration, mPlayer.getCurrentPosition(), tolerance);
    future = mPlayer.pause();
    assertEquals(RESULT_CODE_SUCCESS, future.get().getResultCode());
    assertFalse(mPlayer.getPlayerState() == MediaPlayer.PLAYER_STATE_PLAYING);
    future = mPlayer.play();
    assertEquals(RESULT_CODE_SUCCESS, future.get().getResultCode());
    assertTrue(mPlayer.getPlayerState() == MediaPlayer.PLAYER_STATE_PLAYING);
    // waiting to complete
    while (mPlayer.getPlayerState() == MediaPlayer.PLAYER_STATE_PLAYING) {
        Thread.sleep(SLEEP_TIME);
    }
}
#method_after
@Test
@LargeTest
public void testPlayAudio() throws Exception {
    final int resid = R.raw.testmp3_2;
    final int mp3Duration = 34909;
    final int tolerance = 70;
    final int seekDuration = 100;
    AssetFileDescriptor afd = mResources.openRawResourceFd(resid);
    mPlayer.setMediaItem(new FileMediaItem.Builder(afd.getFileDescriptor(), afd.getStartOffset(), afd.getLength()).build());
    AudioAttributesCompat attributes = new AudioAttributesCompat.Builder().setLegacyStreamType(AudioManager.STREAM_MUSIC).build();
    mPlayer.setAudioAttributes(attributes);
    ListenableFuture<PlayerResult> future = mPlayer.prepare();
    assertEquals(RESULT_CODE_SUCCESS, future.get().getResultCode());
    assertFalse(mPlayer.getPlayerState() == MediaPlayer.PLAYER_STATE_PLAYING);
    future = mPlayer.play();
    assertEquals(RESULT_CODE_SUCCESS, future.get().getResultCode());
    assertTrue(mPlayer.getPlayerState() == MediaPlayer.PLAYER_STATE_PLAYING);
    assertEquals(mp3Duration, mPlayer.getDuration(), tolerance);
    long pos = mPlayer.getCurrentPosition();
    assertTrue(pos >= 0);
    assertTrue(pos < mp3Duration - seekDuration);
    future = mPlayer.seekTo(pos + seekDuration, MediaPlayer2.SEEK_PREVIOUS_SYNC);
    assertEquals(RESULT_CODE_SUCCESS, future.get().getResultCode());
    assertEquals(pos + seekDuration, mPlayer.getCurrentPosition(), tolerance);
    future = mPlayer.pause();
    assertEquals(RESULT_CODE_SUCCESS, future.get().getResultCode());
    assertFalse(mPlayer.getPlayerState() == MediaPlayer.PLAYER_STATE_PLAYING);
    future = mPlayer.play();
    assertEquals(RESULT_CODE_SUCCESS, future.get().getResultCode());
    assertTrue(mPlayer.getPlayerState() == MediaPlayer.PLAYER_STATE_PLAYING);
    // waiting to complete
    while (mPlayer.getPlayerState() == MediaPlayer.PLAYER_STATE_PLAYING) {
        Thread.sleep(SLEEP_TIME);
    }
}
#end_block

#method_before
@Test
@LargeTest
public void testPlayVideo() throws Exception {
    if (!loadResource(R.raw.testvideo)) {
        fail();
    }
    final int width = 352;
    final int height = 288;
    final float volume = 0.5f;
    mPlayer.setSurface(mActivity.getSurfaceHolder().getSurface());
    final TestUtils.Monitor onVideoSizeChangedCalled = new TestUtils.Monitor();
    final TestUtils.Monitor onVideoRenderingStartCalled = new TestUtils.Monitor();
    MediaPlayer.PlayerCallback callback = new MediaPlayer.PlayerCallback() {

        @Override
        public void onVideoSizeChanged(MediaPlayer mp, MediaItem2 dsd, VideoSize size) {
            if (size.getWidth() == 0 && size.getHeight() == 0) {
                // A size of 0x0 can be sent initially one time when using NuPlayer.
                assertFalse(onVideoSizeChangedCalled.isSignalled());
                return;
            }
            onVideoSizeChangedCalled.signal();
            assertEquals(width, size.getWidth());
            assertEquals(height, size.getHeight());
        }

        @Override
        public void onError(MediaPlayer mp, MediaItem2 dsd, int what, int extra) {
            fail("Media player had error " + what + " playing video");
        }

        @Override
        public void onInfo(MediaPlayer mp, MediaItem2 dsd, int what, int extra) {
            if (what == MediaPlayer.MEDIA_INFO_VIDEO_RENDERING_START) {
                onVideoRenderingStartCalled.signal();
            }
        }
    };
    mPlayer.registerPlayerCallback(mExecutor, callback);
    mPlayer.prepare();
    mPlayer.play();
    onVideoSizeChangedCalled.waitForSignal();
    onVideoRenderingStartCalled.waitForSignal();
    mPlayer.setPlayerVolume(volume);
    // waiting to complete
    while (mPlayer.getPlayerState() == MediaPlayer.PLAYER_STATE_PLAYING) {
        Thread.sleep(SLEEP_TIME);
    }
    // validate a few MediaMetrics.
    PersistableBundle metrics = mPlayer.getMetrics();
    if (metrics == null) {
        fail("MediaPlayer.getMetrics() returned null metrics");
    } else if (metrics.isEmpty()) {
        fail("MediaPlayer.getMetrics() returned empty metrics");
    } else {
        int size = metrics.size();
        Set<String> keys = metrics.keySet();
        if (keys == null) {
            fail("MediaMetricsSet returned no keys");
        } else if (keys.size() != size) {
            fail("MediaMetricsSet.keys().size() mismatch MediaMetricsSet.size()");
        }
        // we played something; so one of these should be non-null
        String vmime = metrics.getString(MediaPlayer2.MetricsConstants.MIME_TYPE_VIDEO, null);
        String amime = metrics.getString(MediaPlayer2.MetricsConstants.MIME_TYPE_AUDIO, null);
        if (vmime == null && amime == null) {
            fail("getMetrics() returned neither video nor audio mime value");
        }
        long duration = metrics.getLong(MediaPlayer2.MetricsConstants.DURATION, -2);
        if (duration == -2) {
            fail("getMetrics() didn't return a duration");
        }
        long playing = metrics.getLong(MediaPlayer2.MetricsConstants.PLAYING, -2);
        if (playing == -2) {
            fail("getMetrics() didn't return a playing time");
        }
        if (!keys.contains(MediaPlayer2.MetricsConstants.PLAYING)) {
            fail("MediaMetricsSet.keys() missing: " + MediaPlayer2.MetricsConstants.PLAYING);
        }
    }
}
#method_after
@Test
@LargeTest
public void testPlayVideo() throws Exception {
    if (!loadResource(R.raw.testvideo)) {
        fail();
    }
    final int width = 352;
    final int height = 288;
    final float volume = 0.5f;
    mPlayer.setSurface(mActivity.getSurfaceHolder().getSurface());
    final TestUtils.Monitor onVideoSizeChangedCalled = new TestUtils.Monitor();
    final TestUtils.Monitor onVideoRenderingStartCalled = new TestUtils.Monitor();
    MediaPlayer.PlayerCallback callback = new MediaPlayer.PlayerCallback() {

        @Override
        public void onVideoSizeChanged(MediaPlayer mp, MediaItem dsd, VideoSize size) {
            if (size.getWidth() == 0 && size.getHeight() == 0) {
                // A size of 0x0 can be sent initially one time when using NuPlayer.
                assertFalse(onVideoSizeChangedCalled.isSignalled());
                return;
            }
            onVideoSizeChangedCalled.signal();
            assertEquals(width, size.getWidth());
            assertEquals(height, size.getHeight());
        }

        @Override
        public void onError(MediaPlayer mp, MediaItem dsd, int what, int extra) {
            fail("Media player had error " + what + " playing video");
        }

        @Override
        public void onInfo(MediaPlayer mp, MediaItem dsd, int what, int extra) {
            if (what == MediaPlayer.MEDIA_INFO_VIDEO_RENDERING_START) {
                onVideoRenderingStartCalled.signal();
            }
        }
    };
    mPlayer.registerPlayerCallback(mExecutor, callback);
    mPlayer.prepare();
    mPlayer.play();
    onVideoSizeChangedCalled.waitForSignal();
    onVideoRenderingStartCalled.waitForSignal();
    mPlayer.setPlayerVolume(volume);
    // waiting to complete
    while (mPlayer.getPlayerState() == MediaPlayer.PLAYER_STATE_PLAYING) {
        Thread.sleep(SLEEP_TIME);
    }
    // validate a few MediaMetrics.
    PersistableBundle metrics = mPlayer.getMetrics();
    if (metrics == null) {
        fail("MediaPlayer.getMetrics() returned null metrics");
    } else if (metrics.isEmpty()) {
        fail("MediaPlayer.getMetrics() returned empty metrics");
    } else {
        int size = metrics.size();
        Set<String> keys = metrics.keySet();
        if (keys == null) {
            fail("MediaMetricsSet returned no keys");
        } else if (keys.size() != size) {
            fail("MediaMetricsSet.keys().size() mismatch MediaMetricsSet.size()");
        }
        // we played something; so one of these should be non-null
        String vmime = metrics.getString(MediaPlayer2.MetricsConstants.MIME_TYPE_VIDEO, null);
        String amime = metrics.getString(MediaPlayer2.MetricsConstants.MIME_TYPE_AUDIO, null);
        if (vmime == null && amime == null) {
            fail("getMetrics() returned neither video nor audio mime value");
        }
        long duration = metrics.getLong(MediaPlayer2.MetricsConstants.DURATION, -2);
        if (duration == -2) {
            fail("getMetrics() didn't return a duration");
        }
        long playing = metrics.getLong(MediaPlayer2.MetricsConstants.PLAYING, -2);
        if (playing == -2) {
            fail("getMetrics() didn't return a playing time");
        }
        if (!keys.contains(MediaPlayer2.MetricsConstants.PLAYING)) {
            fail("MediaMetricsSet.keys() missing: " + MediaPlayer2.MetricsConstants.PLAYING);
        }
    }
}
#end_block

#method_before
@Test
@LargeTest
public void testPlaybackRate() throws Exception {
    final int toleranceMs = 1000;
    if (!loadResource(R.raw.video_480x360_mp4_h264_1000kbps_30fps_aac_stereo_128kbps_44100hz)) {
        fail();
    }
    mPlayer.setSurface(mActivity.getSurfaceHolder().getSurface());
    ListenableFuture<PlayerResult> future = mPlayer.prepare();
    assertEquals(MediaPlayer2.CALL_STATUS_NO_ERROR, future.get().getResultCode());
    float[] rates = { 0.25f, 0.5f, 1.0f, 2.0f };
    for (float playbackRate : rates) {
        mPlayer.seekTo(0, MediaPlayer2.SEEK_PREVIOUS_SYNC);
        Thread.sleep(1000);
        // The testing clip is about 10 second long.
        int playTime = 4000;
        int privState = mPlayer.getPlayerState();
        future = mPlayer.setPlaybackParams(new PlaybackParams2.Builder().setSpeed(playbackRate).build());
        assertEquals(MediaPlayer2.CALL_STATUS_NO_ERROR, future.get().getResultCode());
        assertTrue("setPlaybackParams() should not change player state. " + mPlayer.getPlayerState(), mPlayer.getPlayerState() == privState);
        future = mPlayer.play();
        assertEquals(MediaPlayer2.CALL_STATUS_NO_ERROR, future.get().getResultCode());
        Thread.sleep(playTime);
        PlaybackParams2 pbp = mPlayer.getPlaybackParams();
        assertEquals(playbackRate, pbp.getSpeed(), FLOAT_TOLERANCE);
        assertTrue("The player should still be playing", mPlayer.getPlayerState() == MediaPlayer.PLAYER_STATE_PLAYING);
        long playedMediaDurationMs = mPlayer.getCurrentPosition();
        int diff = Math.abs((int) (playedMediaDurationMs / playbackRate) - playTime);
        if (diff > toleranceMs) {
            fail("Media player had error in playback rate " + playbackRate + ", play time is " + playTime + " vs expected " + playedMediaDurationMs);
        }
        future = mPlayer.pause();
        assertEquals(MediaPlayer2.CALL_STATUS_NO_ERROR, future.get().getResultCode());
        pbp = mPlayer.getPlaybackParams();
        assertEquals("pause() should not change the playback rate property.", playbackRate, pbp.getSpeed(), FLOAT_TOLERANCE);
    }
    mPlayer.reset();
}
#method_after
@Test
@LargeTest
public void testPlaybackRate() throws Exception {
    final int toleranceMs = 1000;
    if (!loadResource(R.raw.video_480x360_mp4_h264_1000kbps_30fps_aac_stereo_128kbps_44100hz)) {
        fail();
    }
    mPlayer.setSurface(mActivity.getSurfaceHolder().getSurface());
    ListenableFuture<PlayerResult> future = mPlayer.prepare();
    assertEquals(MediaPlayer2.CALL_STATUS_NO_ERROR, future.get().getResultCode());
    float[] rates = { 0.25f, 0.5f, 1.0f, 2.0f };
    for (float playbackRate : rates) {
        mPlayer.seekTo(0, MediaPlayer2.SEEK_PREVIOUS_SYNC);
        Thread.sleep(1000);
        // The testing clip is about 10 second long.
        int playTime = 4000;
        int privState = mPlayer.getPlayerState();
        future = mPlayer.setPlaybackParams(new PlaybackParams.Builder().setSpeed(playbackRate).build());
        assertEquals(MediaPlayer2.CALL_STATUS_NO_ERROR, future.get().getResultCode());
        assertTrue("setPlaybackParams() should not change player state. " + mPlayer.getPlayerState(), mPlayer.getPlayerState() == privState);
        future = mPlayer.play();
        assertEquals(MediaPlayer2.CALL_STATUS_NO_ERROR, future.get().getResultCode());
        Thread.sleep(playTime);
        PlaybackParams pbp = mPlayer.getPlaybackParams();
        assertEquals(playbackRate, pbp.getSpeed(), FLOAT_TOLERANCE);
        assertTrue("The player should still be playing", mPlayer.getPlayerState() == MediaPlayer.PLAYER_STATE_PLAYING);
        long playedMediaDurationMs = mPlayer.getCurrentPosition();
        int diff = Math.abs((int) (playedMediaDurationMs / playbackRate) - playTime);
        if (diff > toleranceMs) {
            fail("Media player had error in playback rate " + playbackRate + ", play time is " + playTime + " vs expected " + playedMediaDurationMs);
        }
        future = mPlayer.pause();
        assertEquals(MediaPlayer2.CALL_STATUS_NO_ERROR, future.get().getResultCode());
        pbp = mPlayer.getPlaybackParams();
        assertEquals("pause() should not change the playback rate property.", playbackRate, pbp.getSpeed(), FLOAT_TOLERANCE);
    }
    mPlayer.reset();
}
#end_block

#method_before
@Test
@LargeTest
public void testGetTimestamp() throws Exception {
    final int toleranceUs = 100000;
    final float playbackRate = 1.0f;
    if (!loadResource(R.raw.video_480x360_mp4_h264_1000kbps_30fps_aac_stereo_128kbps_44100hz)) {
        fail();
    }
    mPlayer.setSurface(mActivity.getSurfaceHolder().getSurface());
    ListenableFuture<PlayerResult> future = mPlayer.prepare();
    assertEquals(MediaPlayer2.CALL_STATUS_NO_ERROR, future.get().getResultCode());
    mPlayer.play();
    mPlayer.setPlaybackParams(new PlaybackParams2.Builder().setSpeed(playbackRate).build());
    // let player get into stable state.
    Thread.sleep(SLEEP_TIME);
    long nt1 = System.nanoTime();
    MediaTimestamp2 ts1 = mPlayer.getTimestamp();
    long nt2 = System.nanoTime();
    assertTrue("Media player should return a valid time stamp", ts1 != null);
    assertEquals("MediaPlayer2 had error in clockRate " + ts1.getMediaClockRate(), playbackRate, ts1.getMediaClockRate(), 0.001f);
    assertTrue("The nanoTime of Media timestamp should be taken when getTimestamp is called.", nt1 <= ts1.getAnchorSystemNanoTime() && ts1.getAnchorSystemNanoTime() <= nt2);
    future = mPlayer.pause();
    assertEquals(MediaPlayer2.CALL_STATUS_NO_ERROR, future.get().getResultCode());
    ts1 = mPlayer.getTimestamp();
    assertTrue("Media player should return a valid time stamp", ts1 != null);
    assertTrue("Media player should have play rate of 0.0f when paused", ts1.getMediaClockRate() == 0.0f);
    mPlayer.seekTo(0, MediaPlayer2.SEEK_PREVIOUS_SYNC);
    mPlayer.play();
    // let player get into stable state.
    Thread.sleep(SLEEP_TIME);
    // The testing clip is about 10 second long.
    int playTime = 4000;
    ts1 = mPlayer.getTimestamp();
    assertTrue("Media player should return a valid time stamp", ts1 != null);
    Thread.sleep(playTime);
    MediaTimestamp2 ts2 = mPlayer.getTimestamp();
    assertTrue("Media player should return a valid time stamp", ts2 != null);
    assertTrue("The clockRate should not be changed.", ts1.getMediaClockRate() == ts2.getMediaClockRate());
    assertEquals("MediaPlayer2 had error in timestamp.", ts1.getAnchorMediaTimeUs() + (long) (playTime * ts1.getMediaClockRate() * 1000), ts2.getAnchorMediaTimeUs(), toleranceUs);
    mPlayer.reset();
}
#method_after
@Test
@LargeTest
public void testGetTimestamp() throws Exception {
    final int toleranceUs = 100000;
    final float playbackRate = 1.0f;
    if (!loadResource(R.raw.video_480x360_mp4_h264_1000kbps_30fps_aac_stereo_128kbps_44100hz)) {
        fail();
    }
    mPlayer.setSurface(mActivity.getSurfaceHolder().getSurface());
    ListenableFuture<PlayerResult> future = mPlayer.prepare();
    assertEquals(MediaPlayer2.CALL_STATUS_NO_ERROR, future.get().getResultCode());
    mPlayer.play();
    mPlayer.setPlaybackParams(new PlaybackParams.Builder().setSpeed(playbackRate).build());
    // let player get into stable state.
    Thread.sleep(SLEEP_TIME);
    long nt1 = System.nanoTime();
    MediaTimestamp ts1 = mPlayer.getTimestamp();
    long nt2 = System.nanoTime();
    assertTrue("Media player should return a valid time stamp", ts1 != null);
    assertEquals("MediaPlayer2 had error in clockRate " + ts1.getMediaClockRate(), playbackRate, ts1.getMediaClockRate(), 0.001f);
    assertTrue("The nanoTime of Media timestamp should be taken when getTimestamp is called.", nt1 <= ts1.getAnchorSystemNanoTime() && ts1.getAnchorSystemNanoTime() <= nt2);
    future = mPlayer.pause();
    assertEquals(MediaPlayer2.CALL_STATUS_NO_ERROR, future.get().getResultCode());
    ts1 = mPlayer.getTimestamp();
    assertTrue("Media player should return a valid time stamp", ts1 != null);
    assertTrue("Media player should have play rate of 0.0f when paused", ts1.getMediaClockRate() == 0.0f);
    mPlayer.seekTo(0, MediaPlayer2.SEEK_PREVIOUS_SYNC);
    mPlayer.play();
    // let player get into stable state.
    Thread.sleep(SLEEP_TIME);
    // The testing clip is about 10 second long.
    int playTime = 4000;
    ts1 = mPlayer.getTimestamp();
    assertTrue("Media player should return a valid time stamp", ts1 != null);
    Thread.sleep(playTime);
    MediaTimestamp ts2 = mPlayer.getTimestamp();
    assertTrue("Media player should return a valid time stamp", ts2 != null);
    assertTrue("The clockRate should not be changed.", ts1.getMediaClockRate() == ts2.getMediaClockRate());
    assertEquals("MediaPlayer2 had error in timestamp.", ts1.getAnchorMediaTimeUs() + (long) (playTime * ts1.getMediaClockRate() * 1000), ts2.getAnchorMediaTimeUs(), toleranceUs);
    mPlayer.reset();
}
#end_block

#method_before
@Test
@LargeTest
public void testDeselectTrackForSubtitleTracks() throws Throwable {
    if (!loadResource(R.raw.testvideo_with_2_subtitle_tracks)) {
        fail();
    }
    mInstrumentation.waitForIdleSync();
    MediaPlayer.PlayerCallback callback = new MediaPlayer.PlayerCallback() {

        @Override
        public void onInfo(MediaPlayer mp, MediaItem2 dsd, int what, int extra) {
            if (what == MediaPlayer2.MEDIA_INFO_METADATA_UPDATE) {
                mOnInfoCalled.signal();
            }
        }

        @Override
        public void onSubtitleData(MediaPlayer mp, MediaItem2 dsd, SubtitleData2 data) {
            if (data != null && data.getData() != null) {
                mOnSubtitleDataCalled.signal();
            }
        }
    };
    mPlayer.registerPlayerCallback(mExecutor, callback);
    mPlayer.setSurface(mActivity.getSurfaceHolder().getSurface());
    mPlayer.prepare();
    mPlayer.play().get();
    assertTrue(mPlayer.getPlayerState() == MediaPlayer.PLAYER_STATE_PLAYING);
    // Closed caption tracks are in-band.
    // So, those tracks will be found after processing a number of frames.
    mOnInfoCalled.waitForSignal(1500);
    mOnInfoCalled.reset();
    mOnInfoCalled.waitForSignal(1500);
    readSubtitleTracks();
    // Run twice to check if repeated selection-deselection on the same track works well.
    for (int i = 0; i < 2; i++) {
        // Waits until at least one subtitle is fired. Timeout is 2.5 seconds.
        selectSubtitleTrack(i);
        mOnSubtitleDataCalled.reset();
        assertTrue(mOnSubtitleDataCalled.waitForSignal(2500));
        // Try deselecting track.
        assertEquals(RESULT_CODE_SUCCESS, deselectSubtitleTrack(i));
        mOnSubtitleDataCalled.reset();
        assertFalse(mOnSubtitleDataCalled.waitForSignal(1500));
    }
    // Deselecting unselected track: expected error status
    assertNotEquals(RESULT_CODE_SUCCESS, deselectSubtitleTrack(0));
    mPlayer.reset();
}
#method_after
@Test
@LargeTest
public void testDeselectTrackForSubtitleTracks() throws Throwable {
    if (!loadResource(R.raw.testvideo_with_2_subtitle_tracks)) {
        fail();
    }
    mInstrumentation.waitForIdleSync();
    MediaPlayer.PlayerCallback callback = new MediaPlayer.PlayerCallback() {

        @Override
        public void onInfo(MediaPlayer mp, MediaItem dsd, int what, int extra) {
            if (what == MediaPlayer2.MEDIA_INFO_METADATA_UPDATE) {
                mOnInfoCalled.signal();
            }
        }

        @Override
        public void onSubtitleData(MediaPlayer mp, MediaItem dsd, SubtitleData data) {
            if (data != null && data.getData() != null) {
                mOnSubtitleDataCalled.signal();
            }
        }
    };
    mPlayer.registerPlayerCallback(mExecutor, callback);
    mPlayer.setSurface(mActivity.getSurfaceHolder().getSurface());
    mPlayer.prepare();
    mPlayer.play().get();
    assertTrue(mPlayer.getPlayerState() == MediaPlayer.PLAYER_STATE_PLAYING);
    // Closed caption tracks are in-band.
    // So, those tracks will be found after processing a number of frames.
    mOnInfoCalled.waitForSignal(1500);
    mOnInfoCalled.reset();
    mOnInfoCalled.waitForSignal(1500);
    readSubtitleTracks();
    // Run twice to check if repeated selection-deselection on the same track works well.
    for (int i = 0; i < 2; i++) {
        // Waits until at least one subtitle is fired. Timeout is 2.5 seconds.
        selectSubtitleTrack(i);
        mOnSubtitleDataCalled.reset();
        assertTrue(mOnSubtitleDataCalled.waitForSignal(2500));
        // Try deselecting track.
        assertEquals(RESULT_CODE_SUCCESS, deselectSubtitleTrack(i));
        mOnSubtitleDataCalled.reset();
        assertFalse(mOnSubtitleDataCalled.waitForSignal(1500));
    }
    // Deselecting unselected track: expected error status
    assertNotEquals(RESULT_CODE_SUCCESS, deselectSubtitleTrack(0));
    mPlayer.reset();
}
#end_block

#method_before
@Test
@LargeTest
public void testChangeSubtitleTrack() throws Throwable {
    if (!loadResource(R.raw.testvideo_with_2_subtitle_tracks)) {
        fail();
    }
    MediaPlayer.PlayerCallback callback = new MediaPlayer.PlayerCallback() {

        @Override
        public void onInfo(MediaPlayer mp, MediaItem2 dsd, int what, int extra) {
            if (what == MediaPlayer2.MEDIA_INFO_METADATA_UPDATE) {
                mOnInfoCalled.signal();
            }
        }

        @Override
        public void onSubtitleData(MediaPlayer mp, MediaItem2 dsd, SubtitleData2 data) {
            if (data != null && data.getData() != null) {
                mOnSubtitleDataCalled.signal();
            }
        }
    };
    mPlayer.registerPlayerCallback(mExecutor, callback);
    mPlayer.setSurface(mActivity.getSurfaceHolder().getSurface());
    mPlayer.prepare();
    mPlayer.play().get();
    assertTrue(mPlayer.getPlayerState() == MediaPlayer.PLAYER_STATE_PLAYING);
    // Closed caption tracks are in-band.
    // So, those tracks will be found after processing a number of frames.
    mOnInfoCalled.waitForSignal(1500);
    mOnInfoCalled.reset();
    mOnInfoCalled.waitForSignal(1500);
    readSubtitleTracks();
    // Waits until at least two captions are fired. Timeout is 2.5 sec.
    selectSubtitleTrack(0);
    assertTrue(mOnSubtitleDataCalled.waitForCountedSignals(2, 2500) >= 2);
    mOnSubtitleDataCalled.reset();
    selectSubtitleTrack(1);
    assertTrue(mOnSubtitleDataCalled.waitForCountedSignals(2, 2500) >= 2);
    mPlayer.reset();
}
#method_after
@Test
@LargeTest
public void testChangeSubtitleTrack() throws Throwable {
    if (!loadResource(R.raw.testvideo_with_2_subtitle_tracks)) {
        fail();
    }
    MediaPlayer.PlayerCallback callback = new MediaPlayer.PlayerCallback() {

        @Override
        public void onInfo(MediaPlayer mp, MediaItem dsd, int what, int extra) {
            if (what == MediaPlayer2.MEDIA_INFO_METADATA_UPDATE) {
                mOnInfoCalled.signal();
            }
        }

        @Override
        public void onSubtitleData(MediaPlayer mp, MediaItem dsd, SubtitleData data) {
            if (data != null && data.getData() != null) {
                mOnSubtitleDataCalled.signal();
            }
        }
    };
    mPlayer.registerPlayerCallback(mExecutor, callback);
    mPlayer.setSurface(mActivity.getSurfaceHolder().getSurface());
    mPlayer.prepare();
    mPlayer.play().get();
    assertTrue(mPlayer.getPlayerState() == MediaPlayer.PLAYER_STATE_PLAYING);
    // Closed caption tracks are in-band.
    // So, those tracks will be found after processing a number of frames.
    mOnInfoCalled.waitForSignal(1500);
    mOnInfoCalled.reset();
    mOnInfoCalled.waitForSignal(1500);
    readSubtitleTracks();
    // Waits until at least two captions are fired. Timeout is 2.5 sec.
    selectSubtitleTrack(0);
    assertTrue(mOnSubtitleDataCalled.waitForCountedSignals(2, 2500) >= 2);
    mOnSubtitleDataCalled.reset();
    selectSubtitleTrack(1);
    assertTrue(mOnSubtitleDataCalled.waitForCountedSignals(2, 2500) >= 2);
    mPlayer.reset();
}
#end_block

#method_before
@Test
@LargeTest
public void testGetTrackInfoForVideoWithSubtitleTracks() throws Throwable {
    if (!loadResource(R.raw.testvideo_with_2_subtitle_tracks)) {
        fail();
    }
    MediaPlayer.PlayerCallback callback = new MediaPlayer.PlayerCallback() {

        @Override
        public void onInfo(MediaPlayer mp, MediaItem2 dsd, int what, int extra) {
            if (what == MediaPlayer2.MEDIA_INFO_METADATA_UPDATE) {
                mOnInfoCalled.signal();
            }
        }
    };
    mPlayer.registerPlayerCallback(mExecutor, callback);
    mPlayer.setSurface(mActivity.getSurfaceHolder().getSurface());
    mPlayer.prepare();
    mPlayer.play().get();
    assertTrue(mPlayer.getPlayerState() == MediaPlayer.PLAYER_STATE_PLAYING);
    // The media metadata will be changed while playing since closed caption tracks are in-band
    // and those tracks will be found after processing a number of frames. These tracks will be
    // found within one second.
    mOnInfoCalled.waitForSignal(1500);
    mOnInfoCalled.reset();
    mOnInfoCalled.waitForSignal(1500);
    readSubtitleTracks();
    assertEquals(2, mSubtitleTrackIndex.size());
    mPlayer.reset();
}
#method_after
@Test
@LargeTest
public void testGetTrackInfoForVideoWithSubtitleTracks() throws Throwable {
    if (!loadResource(R.raw.testvideo_with_2_subtitle_tracks)) {
        fail();
    }
    MediaPlayer.PlayerCallback callback = new MediaPlayer.PlayerCallback() {

        @Override
        public void onInfo(MediaPlayer mp, MediaItem dsd, int what, int extra) {
            if (what == MediaPlayer2.MEDIA_INFO_METADATA_UPDATE) {
                mOnInfoCalled.signal();
            }
        }
    };
    mPlayer.registerPlayerCallback(mExecutor, callback);
    mPlayer.setSurface(mActivity.getSurfaceHolder().getSurface());
    mPlayer.prepare();
    mPlayer.play().get();
    assertTrue(mPlayer.getPlayerState() == MediaPlayer.PLAYER_STATE_PLAYING);
    // The media metadata will be changed while playing since closed caption tracks are in-band
    // and those tracks will be found after processing a number of frames. These tracks will be
    // found within one second.
    mOnInfoCalled.waitForSignal(1500);
    mOnInfoCalled.reset();
    mOnInfoCalled.waitForSignal(1500);
    readSubtitleTracks();
    assertEquals(2, mSubtitleTrackIndex.size());
    mPlayer.reset();
}
#end_block

#method_before
@Test
@LargeTest
public void testMediaTimeDiscontinuity() throws Exception {
    if (!loadResource(R.raw.bbb_s1_320x240_mp4_h264_mp2_800kbps_30fps_aac_lc_5ch_240kbps_44100hz)) {
        // skip
        return;
    }
    final BlockingDeque<MediaTimestamp2> timestamps = new LinkedBlockingDeque<>();
    MediaPlayer.PlayerCallback callback = new MediaPlayer.PlayerCallback() {

        @Override
        public void onMediaTimeDiscontinuity(MediaPlayer mp, MediaItem2 dsd, MediaTimestamp2 timestamp) {
            timestamps.add(timestamp);
            mOnMediaTimeDiscontinuityCalled.signal();
        }
    };
    mPlayer.registerPlayerCallback(mExecutor, callback);
    mPlayer.setSurface(mActivity.getSurfaceHolder().getSurface());
    mPlayer.prepare();
    // Timestamp needs to be reported when playback starts.
    mOnMediaTimeDiscontinuityCalled.reset();
    mPlayer.play();
    do {
        assertTrue(mOnMediaTimeDiscontinuityCalled.waitForSignal(1000));
    } while (Math.abs(timestamps.getLast().getMediaClockRate() - 1.0f) > 0.01f);
    // Timestamp needs to be reported when seeking is done.
    mOnMediaTimeDiscontinuityCalled.reset();
    assertEquals(RESULT_CODE_SUCCESS, mPlayer.seekTo(3000).get().getResultCode());
    do {
        assertTrue(mOnMediaTimeDiscontinuityCalled.waitForSignal(1000));
    } while (Math.abs(timestamps.getLast().getMediaClockRate() - 1.0f) > 0.01f);
    // Timestamp needs to be updated when playback rate changes.
    mOnMediaTimeDiscontinuityCalled.reset();
    mPlayer.setPlaybackParams(new PlaybackParams2.Builder().setSpeed(0.5f).build());
    mOnMediaTimeDiscontinuityCalled.waitForSignal();
    do {
        assertTrue(mOnMediaTimeDiscontinuityCalled.waitForSignal(1000));
    } while (Math.abs(timestamps.getLast().getMediaClockRate() - 0.5f) > 0.01f);
    // Timestamp needs to be updated when player is paused.
    mOnMediaTimeDiscontinuityCalled.reset();
    mPlayer.pause();
    mOnMediaTimeDiscontinuityCalled.waitForSignal();
    do {
        assertTrue(mOnMediaTimeDiscontinuityCalled.waitForSignal(1000));
    } while (Math.abs(timestamps.getLast().getMediaClockRate() - 0.0f) > 0.01f);
    mPlayer.reset();
}
#method_after
@Test
@LargeTest
public void testMediaTimeDiscontinuity() throws Exception {
    if (!loadResource(R.raw.bbb_s1_320x240_mp4_h264_mp2_800kbps_30fps_aac_lc_5ch_240kbps_44100hz)) {
        // skip
        return;
    }
    final BlockingDeque<MediaTimestamp> timestamps = new LinkedBlockingDeque<>();
    MediaPlayer.PlayerCallback callback = new MediaPlayer.PlayerCallback() {

        @Override
        public void onMediaTimeDiscontinuity(MediaPlayer mp, MediaItem dsd, MediaTimestamp timestamp) {
            timestamps.add(timestamp);
            mOnMediaTimeDiscontinuityCalled.signal();
        }
    };
    mPlayer.registerPlayerCallback(mExecutor, callback);
    mPlayer.setSurface(mActivity.getSurfaceHolder().getSurface());
    mPlayer.prepare();
    // Timestamp needs to be reported when playback starts.
    mOnMediaTimeDiscontinuityCalled.reset();
    mPlayer.play();
    do {
        assertTrue(mOnMediaTimeDiscontinuityCalled.waitForSignal(1000));
    } while (Math.abs(timestamps.getLast().getMediaClockRate() - 1.0f) > 0.01f);
    // Timestamp needs to be reported when seeking is done.
    mOnMediaTimeDiscontinuityCalled.reset();
    assertEquals(RESULT_CODE_SUCCESS, mPlayer.seekTo(3000).get().getResultCode());
    do {
        assertTrue(mOnMediaTimeDiscontinuityCalled.waitForSignal(1000));
    } while (Math.abs(timestamps.getLast().getMediaClockRate() - 1.0f) > 0.01f);
    // Timestamp needs to be updated when playback rate changes.
    mOnMediaTimeDiscontinuityCalled.reset();
    mPlayer.setPlaybackParams(new PlaybackParams.Builder().setSpeed(0.5f).build());
    mOnMediaTimeDiscontinuityCalled.waitForSignal();
    do {
        assertTrue(mOnMediaTimeDiscontinuityCalled.waitForSignal(1000));
    } while (Math.abs(timestamps.getLast().getMediaClockRate() - 0.5f) > 0.01f);
    // Timestamp needs to be updated when player is paused.
    mOnMediaTimeDiscontinuityCalled.reset();
    mPlayer.pause();
    mOnMediaTimeDiscontinuityCalled.waitForSignal();
    do {
        assertTrue(mOnMediaTimeDiscontinuityCalled.waitForSignal(1000));
    } while (Math.abs(timestamps.getLast().getMediaClockRate() - 0.0f) > 0.01f);
    mPlayer.reset();
}
#end_block

#method_before
@Test
@LargeTest
public void testPlaybackFromDataSourceCallback() throws Exception {
    final int resid = R.raw.video_480x360_mp4_h264_1350kbps_30fps_aac_stereo_192kbps_44100hz;
    final int duration = 10000;
    TestDataSourceCallback2 dataSource = TestDataSourceCallback2.fromAssetFd(mResources.openRawResourceFd(resid));
    // Test returning -1 from getSize() to indicate unknown size.
    dataSource.returnFromGetSize(-1);
    mPlayer.setMediaItem(new CallbackMediaItem2.Builder(dataSource).build());
    mPlayer.prepare();
    mPlayer.play().get();
    assertTrue(mPlayer.getPlayerState() == MediaPlayer.PLAYER_STATE_PLAYING);
    // Test pause and restart.
    mPlayer.pause();
    Thread.sleep(SLEEP_TIME);
    assertFalse(mPlayer.getPlayerState() == MediaPlayer.PLAYER_STATE_PLAYING);
    mPlayer.play().get();
    assertTrue(mPlayer.getPlayerState() == MediaPlayer.PLAYER_STATE_PLAYING);
    // Test reset.
    mPlayer.reset();
    mPlayer.setMediaItem(new CallbackMediaItem2.Builder(dataSource).build());
    mPlayer.prepare();
    mPlayer.play().get();
    assertTrue(mPlayer.getPlayerState() == MediaPlayer.PLAYER_STATE_PLAYING);
    // Test seek. Note: the seek position is cached and returned as the
    // current position so there's no point in comparing them.
    mPlayer.seekTo(duration - SLEEP_TIME, MediaPlayer2.SEEK_PREVIOUS_SYNC);
    while (mPlayer.getPlayerState() == MediaPlayer.PLAYER_STATE_PLAYING) {
        Thread.sleep(SLEEP_TIME);
    }
}
#method_after
@Test
@LargeTest
public void testPlaybackFromDataSourceCallback() throws Exception {
    final int resid = R.raw.video_480x360_mp4_h264_1350kbps_30fps_aac_stereo_192kbps_44100hz;
    final int duration = 10000;
    TestDataSourceCallback dataSource = TestDataSourceCallback.fromAssetFd(mResources.openRawResourceFd(resid));
    // Test returning -1 from getSize() to indicate unknown size.
    dataSource.returnFromGetSize(-1);
    mPlayer.setMediaItem(new CallbackMediaItem.Builder(dataSource).build());
    mPlayer.prepare();
    mPlayer.play().get();
    assertTrue(mPlayer.getPlayerState() == MediaPlayer.PLAYER_STATE_PLAYING);
    // Test pause and restart.
    mPlayer.pause();
    Thread.sleep(SLEEP_TIME);
    assertFalse(mPlayer.getPlayerState() == MediaPlayer.PLAYER_STATE_PLAYING);
    mPlayer.play().get();
    assertTrue(mPlayer.getPlayerState() == MediaPlayer.PLAYER_STATE_PLAYING);
    // Test reset.
    mPlayer.reset();
    mPlayer.setMediaItem(new CallbackMediaItem.Builder(dataSource).build());
    mPlayer.prepare();
    mPlayer.play().get();
    assertTrue(mPlayer.getPlayerState() == MediaPlayer.PLAYER_STATE_PLAYING);
    // Test seek. Note: the seek position is cached and returned as the
    // current position so there's no point in comparing them.
    mPlayer.seekTo(duration - SLEEP_TIME, MediaPlayer2.SEEK_PREVIOUS_SYNC);
    while (mPlayer.getPlayerState() == MediaPlayer.PLAYER_STATE_PLAYING) {
        Thread.sleep(SLEEP_TIME);
    }
}
#end_block

#method_before
@Test
@LargeTest
public void testMedia2DataSourceIsClosedOnReset() throws Exception {
    TestDataSourceCallback2 dataSource = new TestDataSourceCallback2(new byte[0]);
    assertEquals(RESULT_CODE_SUCCESS, mPlayer.setMediaItem(new CallbackMediaItem2.Builder(dataSource).build()).get().getResultCode());
    mPlayer.reset();
    assertTrue(dataSource.isClosed());
}
#method_after
@Test
@LargeTest
public void testMedia2DataSourceIsClosedOnReset() throws Exception {
    TestDataSourceCallback dataSource = new TestDataSourceCallback(new byte[0]);
    assertEquals(RESULT_CODE_SUCCESS, mPlayer.setMediaItem(new CallbackMediaItem.Builder(dataSource).build()).get().getResultCode());
    mPlayer.reset();
    assertTrue(dataSource.isClosed());
}
#end_block

#method_before
@Test
@LargeTest
public void testPlaybackFailsIfMedia2DataSourceThrows() throws Exception {
    final int resid = R.raw.video_480x360_mp4_h264_1350kbps_30fps_aac_stereo_192kbps_44100hz;
    MediaPlayer.PlayerCallback callback = new MediaPlayer.PlayerCallback() {

        @Override
        public void onError(MediaPlayer mp, MediaItem2 dsd, int what, int extra) {
            mOnErrorCalled.signal();
        }
    };
    mPlayer.registerPlayerCallback(mExecutor, callback);
    TestDataSourceCallback2 dataSource = TestDataSourceCallback2.fromAssetFd(mResources.openRawResourceFd(resid));
    mPlayer.setMediaItem(new CallbackMediaItem2.Builder(dataSource).build());
    mPlayer.prepare().get();
    mOnErrorCalled.reset();
    dataSource.throwFromReadAt();
    mPlayer.play();
    assertTrue(mOnErrorCalled.waitForSignal());
}
#method_after
@Test
@LargeTest
public void testPlaybackFailsIfMedia2DataSourceThrows() throws Exception {
    final int resid = R.raw.video_480x360_mp4_h264_1350kbps_30fps_aac_stereo_192kbps_44100hz;
    MediaPlayer.PlayerCallback callback = new MediaPlayer.PlayerCallback() {

        @Override
        public void onError(MediaPlayer mp, MediaItem dsd, int what, int extra) {
            mOnErrorCalled.signal();
        }
    };
    mPlayer.registerPlayerCallback(mExecutor, callback);
    TestDataSourceCallback dataSource = TestDataSourceCallback.fromAssetFd(mResources.openRawResourceFd(resid));
    mPlayer.setMediaItem(new CallbackMediaItem.Builder(dataSource).build());
    mPlayer.prepare().get();
    mOnErrorCalled.reset();
    dataSource.throwFromReadAt();
    mPlayer.play();
    assertTrue(mOnErrorCalled.waitForSignal());
}
#end_block

#method_before
@Test
@LargeTest
public void testPlaybackFailsIfMedia2DataSourceReturnsAnError() throws Exception {
    final int resid = R.raw.video_480x360_mp4_h264_1350kbps_30fps_aac_stereo_192kbps_44100hz;
    TestDataSourceCallback2 dataSource = TestDataSourceCallback2.fromAssetFd(mResources.openRawResourceFd(resid));
    mPlayer.setMediaItem(new CallbackMediaItem2.Builder(dataSource).build());
    MediaPlayer.PlayerCallback callback = new MediaPlayer.PlayerCallback() {

        @Override
        public void onError(MediaPlayer mp, MediaItem2 dsd, int what, int extra) {
            mOnErrorCalled.signal();
        }
    };
    mPlayer.registerPlayerCallback(mExecutor, callback);
    mPlayer.prepare().get();
    dataSource.returnFromReadAt(-2);
    mPlayer.play();
    assertTrue(mOnErrorCalled.waitForSignal());
}
#method_after
@Test
@LargeTest
public void testPlaybackFailsIfMedia2DataSourceReturnsAnError() throws Exception {
    final int resid = R.raw.video_480x360_mp4_h264_1350kbps_30fps_aac_stereo_192kbps_44100hz;
    TestDataSourceCallback dataSource = TestDataSourceCallback.fromAssetFd(mResources.openRawResourceFd(resid));
    mPlayer.setMediaItem(new CallbackMediaItem.Builder(dataSource).build());
    MediaPlayer.PlayerCallback callback = new MediaPlayer.PlayerCallback() {

        @Override
        public void onError(MediaPlayer mp, MediaItem dsd, int what, int extra) {
            mOnErrorCalled.signal();
        }
    };
    mPlayer.registerPlayerCallback(mExecutor, callback);
    mPlayer.prepare().get();
    dataSource.returnFromReadAt(-2);
    mPlayer.play();
    assertTrue(mOnErrorCalled.waitForSignal());
}
#end_block

#method_before
@Test
@LargeTest
public void testPreservePlaybackProperties() throws Exception {
/* TODO: enable this test once MediaPlayer has playlist implementation.
        final int resid1 = R.raw.video_480x360_mp4_h264_1350kbps_30fps_aac_stereo_192kbps_44100hz;
        final long start1 = 6000;
        final long end1 = 7000;
        AssetFileDescriptor afd1 = mResources.openRawResourceFd(resid1);
        MediaItem2 dsd1 = new FileMediaItem2.Builder(
                afd1.getFileDescriptor(), afd1.getStartOffset(), afd1.getLength())
                .setStartPosition(start1)
                .setEndPosition(end1)
                .build();

        final int resid2 = R.raw.testvideo;
        final long start2 = 3000;
        final long end2 = 4000;
        AssetFileDescriptor afd2 = mResources.openRawResourceFd(resid2);
        MediaItem2 dsd2 = new FileMediaItem2.Builder(
                afd2.getFileDescriptor(), afd2.getStartOffset(), afd2.getLength())
                .setStartPosition(start2)
                .setEndPosition(end2)
                .build();

        mPlayer.setMediaItem();
        mPlayer.setNextMediaItem(dsd2);
        mPlayer.setSurface(mActivity.getSurfaceHolder().getSurface());

        MediaPlayer.PlayerCallback callback = new MediaPlayer.PlayerCallback() {
            @Override
            public void onInfo(MediaPlayer2 mp, MediaItem2 dsd, int what, int extra) {
                if (what == MediaPlayer2.MEDIA_INFO_PREPARED) {
                    mOnPrepareCalled.signal();
                } else if (what == MediaPlayer2.MEDIA_INFO_DATA_SOURCE_END) {
                    mOnCompletionCalled.signal();
                }
            }

            @Override
            public void onCallCompleted(
                    MediaPlayer2 mp, MediaItem2 dsd, int what, int status) {
                if (what == MediaPlayer2.CALL_COMPLETED_PLAY) {
                    assertTrue(status == MediaPlayer2.CALL_STATUS_NO_ERROR);
                    mOnPlayCalled.signal();
                }
            }
        };
        mPlayer.registerPlayerCallback(mExecutor, callback);

        mOnPrepareCalled.reset();
        mPlayer.prepare();
        mOnPrepareCalled.waitForSignal();

        mOnPlayCalled.reset();
        mOnCompletionCalled.reset();
        mPlayer.setPlaybackParams(new PlaybackParams2.Builder().setSpeed(2.0f).build());
        mPlayer.play();

        mOnPlayCalled.waitForSignal();
        mOnCompletionCalled.waitForSignal();

        assertEquals(dsd2, mPlayer.getCurrentMediaItem());
        assertEquals(2.0f, mPlayer.getPlaybackParams().getSpeed(), 0.001f);

        afd1.close();
        afd2.close();
        */
}
#method_after
@Test
@LargeTest
public void testPreservePlaybackProperties() throws Exception {
/* TODO: enable this test once MediaPlayer has playlist implementation.
        final int resid1 = R.raw.video_480x360_mp4_h264_1350kbps_30fps_aac_stereo_192kbps_44100hz;
        final long start1 = 6000;
        final long end1 = 7000;
        AssetFileDescriptor afd1 = mResources.openRawResourceFd(resid1);
        MediaItem dsd1 = new FileMediaItem.Builder(
                afd1.getFileDescriptor(), afd1.getStartOffset(), afd1.getLength())
                .setStartPosition(start1)
                .setEndPosition(end1)
                .build();

        final int resid2 = R.raw.testvideo;
        final long start2 = 3000;
        final long end2 = 4000;
        AssetFileDescriptor afd2 = mResources.openRawResourceFd(resid2);
        MediaItem dsd2 = new FileMediaItem.Builder(
                afd2.getFileDescriptor(), afd2.getStartOffset(), afd2.getLength())
                .setStartPosition(start2)
                .setEndPosition(end2)
                .build();

        mPlayer.setMediaItem();
        mPlayer.setNextMediaItem(dsd2);
        mPlayer.setSurface(mActivity.getSurfaceHolder().getSurface());

        MediaPlayer.PlayerCallback callback = new MediaPlayer.PlayerCallback() {
            @Override
            public void onInfo(MediaPlayer2 mp, MediaItem dsd, int what, int extra) {
                if (what == MediaPlayer2.MEDIA_INFO_PREPARED) {
                    mOnPrepareCalled.signal();
                } else if (what == MediaPlayer2.MEDIA_INFO_DATA_SOURCE_END) {
                    mOnCompletionCalled.signal();
                }
            }

            @Override
            public void onCallCompleted(
                    MediaPlayer2 mp, MediaItem dsd, int what, int status) {
                if (what == MediaPlayer2.CALL_COMPLETED_PLAY) {
                    assertTrue(status == MediaPlayer2.CALL_STATUS_NO_ERROR);
                    mOnPlayCalled.signal();
                }
            }
        };
        mPlayer.registerPlayerCallback(mExecutor, callback);

        mOnPrepareCalled.reset();
        mPlayer.prepare();
        mOnPrepareCalled.waitForSignal();

        mOnPlayCalled.reset();
        mOnCompletionCalled.reset();
        mPlayer.setPlaybackParams(new PlaybackParams.Builder().setSpeed(2.0f).build());
        mPlayer.play();

        mOnPlayCalled.waitForSignal();
        mOnCompletionCalled.waitForSignal();

        assertEquals(dsd2, mPlayer.getCurrentMediaItem());
        assertEquals(2.0f, mPlayer.getPlaybackParams().getSpeed(), 0.001f);

        afd1.close();
        afd2.close();
        */
}
#end_block

#method_before
@Test
@MediumTest
public void testDefaultPlaybackParams() throws Exception {
    if (!loadResource(R.raw.testvideo_with_2_subtitle_tracks)) {
        fail();
    }
    mPlayer.prepare().get();
    PlaybackParams2 playbackParams = mPlayer.getPlaybackParams();
    assertEquals(PlaybackParams2.AUDIO_FALLBACK_MODE_DEFAULT, (int) playbackParams.getAudioFallbackMode());
    assertEquals(1.0f, playbackParams.getPitch(), 0.001f);
    assertEquals(1.0f, playbackParams.getSpeed(), 0.001f);
    mPlayer.reset();
}
#method_after
@Test
@MediumTest
public void testDefaultPlaybackParams() throws Exception {
    if (!loadResource(R.raw.testvideo_with_2_subtitle_tracks)) {
        fail();
    }
    mPlayer.prepare().get();
    PlaybackParams playbackParams = mPlayer.getPlaybackParams();
    assertEquals(PlaybackParams.AUDIO_FALLBACK_MODE_DEFAULT, (int) playbackParams.getAudioFallbackMode());
    assertEquals(1.0f, playbackParams.getPitch(), 0.001f);
    assertEquals(1.0f, playbackParams.getSpeed(), 0.001f);
    mPlayer.reset();
}
#end_block

#method_before
@Test
@SmallTest
public void testSkipUnnecessarySeek() throws Exception {
    final int resid = R.raw.video_480x360_mp4_h264_1350kbps_30fps_aac_stereo_192kbps_44100hz;
    final TestDataSourceCallback2 source = TestDataSourceCallback2.fromAssetFd(mResources.openRawResourceFd(resid));
    final Monitor readAllowed = new Monitor();
    DataSourceCallback2 dataSource = new DataSourceCallback2() {

        @Override
        public int readAt(long position, byte[] buffer, int offset, int size) throws IOException {
            if (!readAllowed.isSignalled()) {
                try {
                    readAllowed.waitForSignal();
                } catch (InterruptedException e) {
                    fail();
                }
            }
            return source.readAt(position, buffer, offset, size);
        }

        @Override
        public long getSize() throws IOException {
            return source.getSize();
        }

        @Override
        public void close() throws IOException {
            source.close();
        }
    };
    MediaPlayer.PlayerCallback callback = new MediaPlayer.PlayerCallback() {

        @Override
        public void onError(MediaPlayer mp, MediaItem2 dsd, int what, int extra) {
            mOnErrorCalled.signal();
        }
    };
    mPlayer.registerPlayerCallback(mExecutor, callback);
    mPlayer.setMediaItem(new CallbackMediaItem2.Builder(dataSource).build());
    mOnErrorCalled.reset();
    // prepare() will be pending until readAllowed is signaled.
    mPlayer.prepare();
    ListenableFuture<PlayerResult> seekFuture1 = mPlayer.seekTo(3000);
    ListenableFuture<PlayerResult> seekFuture2 = mPlayer.seekTo(2000);
    ListenableFuture<PlayerResult> seekFuture3 = mPlayer.seekTo(1000);
    readAllowed.signal();
    assertEquals(RESULT_CODE_SKIPPED, seekFuture1.get().getResultCode());
    assertEquals(RESULT_CODE_SKIPPED, seekFuture2.get().getResultCode());
    assertEquals(RESULT_CODE_SUCCESS, seekFuture3.get().getResultCode());
    assertFalse(mOnErrorCalled.isSignalled());
}
#method_after
@Test
@SmallTest
public void testSkipUnnecessarySeek() throws Exception {
    final int resid = R.raw.video_480x360_mp4_h264_1350kbps_30fps_aac_stereo_192kbps_44100hz;
    final TestDataSourceCallback source = TestDataSourceCallback.fromAssetFd(mResources.openRawResourceFd(resid));
    final Monitor readAllowed = new Monitor();
    DataSourceCallback dataSource = new DataSourceCallback() {

        @Override
        public int readAt(long position, byte[] buffer, int offset, int size) throws IOException {
            if (!readAllowed.isSignalled()) {
                try {
                    readAllowed.waitForSignal();
                } catch (InterruptedException e) {
                    fail();
                }
            }
            return source.readAt(position, buffer, offset, size);
        }

        @Override
        public long getSize() throws IOException {
            return source.getSize();
        }

        @Override
        public void close() throws IOException {
            source.close();
        }
    };
    MediaPlayer.PlayerCallback callback = new MediaPlayer.PlayerCallback() {

        @Override
        public void onError(MediaPlayer mp, MediaItem dsd, int what, int extra) {
            mOnErrorCalled.signal();
        }
    };
    mPlayer.registerPlayerCallback(mExecutor, callback);
    mPlayer.setMediaItem(new CallbackMediaItem.Builder(dataSource).build());
    mOnErrorCalled.reset();
    // prepare() will be pending until readAllowed is signaled.
    mPlayer.prepare();
    ListenableFuture<PlayerResult> seekFuture1 = mPlayer.seekTo(3000);
    ListenableFuture<PlayerResult> seekFuture2 = mPlayer.seekTo(2000);
    ListenableFuture<PlayerResult> seekFuture3 = mPlayer.seekTo(1000);
    readAllowed.signal();
    assertEquals(RESULT_CODE_SKIPPED, seekFuture1.get().getResultCode());
    assertEquals(RESULT_CODE_SKIPPED, seekFuture2.get().getResultCode());
    assertEquals(RESULT_CODE_SUCCESS, seekFuture3.get().getResultCode());
    assertFalse(mOnErrorCalled.isSignalled());
}
#end_block

#method_before
@Test
@LargeTest
public void testPlayerCallback() throws Throwable {
    final int mp4Duration = 8484;
    if (!loadResource(R.raw.video_480x360_mp4_h264_1000kbps_30fps_aac_stereo_128kbps_44100hz)) {
        // skip;
        return;
    }
    ListenableFuture<PlayerResult> future;
    final TestUtils.Monitor onSeekCompleteCalled = new TestUtils.Monitor();
    final TestUtils.Monitor onPlayerStateChangedCalled = new TestUtils.Monitor();
    final AtomicInteger playerState = new AtomicInteger();
    final TestUtils.Monitor onBufferingStateChangedCalled = new TestUtils.Monitor();
    final AtomicInteger bufferingState = new AtomicInteger();
    final TestUtils.Monitor onPlaybackSpeedChanged = new TestUtils.Monitor();
    final AtomicReference<Float> playbackSpeed = new AtomicReference<>();
    MediaPlayer.PlayerCallback callback = new MediaPlayer.PlayerCallback() {

        @Override
        public void onPlayerStateChanged(SessionPlayer2 player, int state) {
            playerState.set(state);
            onPlayerStateChangedCalled.signal();
        }

        @Override
        public void onBufferingStateChanged(SessionPlayer2 player, MediaItem2 item, int buffState) {
            bufferingState.set(buffState);
            onBufferingStateChangedCalled.signal();
        }

        @Override
        public void onPlaybackSpeedChanged(SessionPlayer2 player, float speed) {
            playbackSpeed.set(speed);
            onPlaybackSpeedChanged.signal();
        }

        @Override
        public void onSeekCompleted(SessionPlayer2 player, long position) {
            onSeekCompleteCalled.signal();
        }
    };
    mPlayer.registerPlayerCallback(mExecutor, callback);
    mPlayer.setSurface(mActivity.getSurfaceHolder().getSurface());
    onPlayerStateChangedCalled.reset();
    onBufferingStateChangedCalled.reset();
    future = mPlayer.prepare();
    do {
        assertTrue(onBufferingStateChangedCalled.waitForSignal(1000));
    } while (bufferingState.get() != MediaPlayer.BUFFERING_STATE_BUFFERING_AND_STARVED);
    assertEquals(MediaPlayer2.CALL_STATUS_NO_ERROR, future.get().getResultCode());
    do {
        assertTrue(onPlayerStateChangedCalled.waitForSignal(1000));
    } while (playerState.get() != MediaPlayer.PLAYER_STATE_PAUSED);
    do {
        assertTrue(onBufferingStateChangedCalled.waitForSignal(1000));
    } while (bufferingState.get() != MediaPlayer.BUFFERING_STATE_BUFFERING_AND_PLAYABLE);
    onSeekCompleteCalled.reset();
    mPlayer.seekTo(mp4Duration >> 1);
    onSeekCompleteCalled.waitForSignal();
    onPlaybackSpeedChanged.reset();
    mPlayer.setPlaybackSpeed(0.5f);
    do {
        assertTrue(onPlaybackSpeedChanged.waitForSignal(1000));
    } while (Math.abs(playbackSpeed.get() - 0.5f) > FLOAT_TOLERANCE);
    mPlayer.reset();
    assertEquals(MediaPlayer.PLAYER_STATE_IDLE, mPlayer.getPlayerState());
    mPlayer.unregisterPlayerCallback(callback);
}
#method_after
@Test
@LargeTest
public void testPlayerCallback() throws Throwable {
    final int mp4Duration = 8484;
    if (!loadResource(R.raw.video_480x360_mp4_h264_1000kbps_30fps_aac_stereo_128kbps_44100hz)) {
        // skip;
        return;
    }
    ListenableFuture<PlayerResult> future;
    final TestUtils.Monitor onSeekCompleteCalled = new TestUtils.Monitor();
    final TestUtils.Monitor onPlayerStateChangedCalled = new TestUtils.Monitor();
    final AtomicInteger playerState = new AtomicInteger();
    final TestUtils.Monitor onBufferingStateChangedCalled = new TestUtils.Monitor();
    final AtomicInteger bufferingState = new AtomicInteger();
    final TestUtils.Monitor onPlaybackSpeedChanged = new TestUtils.Monitor();
    final AtomicReference<Float> playbackSpeed = new AtomicReference<>();
    MediaPlayer.PlayerCallback callback = new MediaPlayer.PlayerCallback() {

        @Override
        public void onPlayerStateChanged(SessionPlayer player, int state) {
            playerState.set(state);
            onPlayerStateChangedCalled.signal();
        }

        @Override
        public void onBufferingStateChanged(SessionPlayer player, MediaItem item, int buffState) {
            bufferingState.set(buffState);
            onBufferingStateChangedCalled.signal();
        }

        @Override
        public void onPlaybackSpeedChanged(SessionPlayer player, float speed) {
            playbackSpeed.set(speed);
            onPlaybackSpeedChanged.signal();
        }

        @Override
        public void onSeekCompleted(SessionPlayer player, long position) {
            onSeekCompleteCalled.signal();
        }
    };
    mPlayer.registerPlayerCallback(mExecutor, callback);
    mPlayer.setSurface(mActivity.getSurfaceHolder().getSurface());
    onPlayerStateChangedCalled.reset();
    onBufferingStateChangedCalled.reset();
    future = mPlayer.prepare();
    do {
        assertTrue(onBufferingStateChangedCalled.waitForSignal(1000));
    } while (bufferingState.get() != MediaPlayer.BUFFERING_STATE_BUFFERING_AND_STARVED);
    assertEquals(MediaPlayer2.CALL_STATUS_NO_ERROR, future.get().getResultCode());
    do {
        assertTrue(onPlayerStateChangedCalled.waitForSignal(1000));
    } while (playerState.get() != MediaPlayer.PLAYER_STATE_PAUSED);
    do {
        assertTrue(onBufferingStateChangedCalled.waitForSignal(1000));
    } while (bufferingState.get() != MediaPlayer.BUFFERING_STATE_BUFFERING_AND_PLAYABLE);
    onSeekCompleteCalled.reset();
    mPlayer.seekTo(mp4Duration >> 1);
    onSeekCompleteCalled.waitForSignal();
    onPlaybackSpeedChanged.reset();
    mPlayer.setPlaybackSpeed(0.5f);
    do {
        assertTrue(onPlaybackSpeedChanged.waitForSignal(1000));
    } while (Math.abs(playbackSpeed.get() - 0.5f) > FLOAT_TOLERANCE);
    mPlayer.reset();
    assertEquals(MediaPlayer.PLAYER_STATE_IDLE, mPlayer.getPlayerState());
    mPlayer.unregisterPlayerCallback(callback);
}
#end_block

#method_before
@Test
@LargeTest
public void testCancelPendingCommands() throws Exception {
    final Monitor readRequested = new Monitor();
    final Monitor readAllowed = new Monitor();
    DataSourceCallback2 dataSource = new DataSourceCallback2() {

        TestDataSourceCallback2 mTestSource = TestDataSourceCallback2.fromAssetFd(mResources.openRawResourceFd(R.raw.testmp3));

        @Override
        public int readAt(long position, byte[] buffer, int offset, int size) throws IOException {
            try {
                readRequested.signal();
                readAllowed.waitForSignal();
            } catch (InterruptedException e) {
                fail();
            }
            return mTestSource.readAt(position, buffer, offset, size);
        }

        @Override
        public long getSize() throws IOException {
            return mTestSource.getSize();
        }

        @Override
        public void close() throws IOException {
            mTestSource.close();
        }
    };
    MediaPlayer.PlayerCallback ecb = new MediaPlayer.PlayerCallback() {

        @Override
        public void onError(MediaPlayer mp, MediaItem2 item, int what, int extra) {
            mOnErrorCalled.signal();
        }
    };
    mPlayer.registerPlayerCallback(mExecutor, ecb);
    mOnErrorCalled.reset();
    mPlayer.setMediaItem(new CallbackMediaItem2.Builder(dataSource).build());
    // prepare() will be pending until readAllowed is signaled.
    mPlayer.prepare();
    ListenableFuture<PlayerResult> seekFuture = mPlayer.seekTo(1000);
    ListenableFuture<PlayerResult> volumeFuture = mPlayer.setPlayerVolume(0.7f);
    readRequested.waitForSignal();
    // Cancel the pending commands while preparation is on hold.
    seekFuture.cancel(false);
    volumeFuture.cancel(false);
    // Make the on-going prepare operation resumed and check the results.
    readAllowed.signal();
    mPlayer.setSurface(null).get();
    assertEquals(0, /* default value */
    mPlayer.getCurrentPosition());
    assertEquals(1.0f, /* default value */
    mPlayer.getPlayerVolume(), 0.001f);
    assertEquals(0, mOnErrorCalled.getNumSignal());
}
#method_after
@Test
@LargeTest
public void testCancelPendingCommands() throws Exception {
    final Monitor readRequested = new Monitor();
    final Monitor readAllowed = new Monitor();
    DataSourceCallback dataSource = new DataSourceCallback() {

        TestDataSourceCallback mTestSource = TestDataSourceCallback.fromAssetFd(mResources.openRawResourceFd(R.raw.testmp3));

        @Override
        public int readAt(long position, byte[] buffer, int offset, int size) throws IOException {
            try {
                readRequested.signal();
                readAllowed.waitForSignal();
            } catch (InterruptedException e) {
                fail();
            }
            return mTestSource.readAt(position, buffer, offset, size);
        }

        @Override
        public long getSize() throws IOException {
            return mTestSource.getSize();
        }

        @Override
        public void close() throws IOException {
            mTestSource.close();
        }
    };
    MediaPlayer.PlayerCallback ecb = new MediaPlayer.PlayerCallback() {

        @Override
        public void onError(MediaPlayer mp, MediaItem item, int what, int extra) {
            mOnErrorCalled.signal();
        }
    };
    mPlayer.registerPlayerCallback(mExecutor, ecb);
    mOnErrorCalled.reset();
    mPlayer.setMediaItem(new CallbackMediaItem.Builder(dataSource).build());
    // prepare() will be pending until readAllowed is signaled.
    mPlayer.prepare();
    ListenableFuture<PlayerResult> seekFuture = mPlayer.seekTo(1000);
    ListenableFuture<PlayerResult> volumeFuture = mPlayer.setPlayerVolume(0.7f);
    readRequested.waitForSignal();
    // Cancel the pending commands while preparation is on hold.
    seekFuture.cancel(false);
    volumeFuture.cancel(false);
    // Make the on-going prepare operation resumed and check the results.
    readAllowed.signal();
    mPlayer.setSurface(null).get();
    assertEquals(0, /* default value */
    mPlayer.getCurrentPosition());
    assertEquals(1.0f, /* default value */
    mPlayer.getPlayerVolume(), 0.001f);
    assertEquals(0, mOnErrorCalled.getNumSignal());
}
#end_block

#method_before
@SmallTest
public void testSetAndGetShuflleMode() throws Exception {
    final TestUtils.Monitor onShuffleModeChangedMonitor = new TestUtils.Monitor();
    MediaPlayer.PlayerCallback callback = new MediaPlayer.PlayerCallback() {

        @Override
        public void onShuffleModeChanged(SessionPlayer2 player, int shuffleMode) {
            mPlayerCbArg1 = player;
            mPlayerCbArg2 = new Integer(shuffleMode);
            onShuffleModeChangedMonitor.signal();
        }
    };
    mPlayer.registerPlayerCallback(mExecutor, callback);
    int shuffleMode = mPlayer.getShuffleMode();
    ListenableFuture<PlayerResult> future;
    PlayerResult result;
    if (shuffleMode != SessionPlayer2.SHUFFLE_MODE_NONE) {
        onShuffleModeChangedMonitor.reset();
        future = mPlayer.setShuffleMode(SessionPlayer2.SHUFFLE_MODE_NONE);
        assertTrue(onShuffleModeChangedMonitor.waitForSignal(WAIT_TIME_MS));
        result = future.get();
        assertEquals(mPlayer, mPlayerCbArg1);
        assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
        assertEquals(SessionPlayer2.SHUFFLE_MODE_NONE, ((Integer) mPlayerCbArg2).intValue());
        assertEquals(SessionPlayer2.SHUFFLE_MODE_NONE, mPlayer.getShuffleMode());
    }
    onShuffleModeChangedMonitor.reset();
    future = mPlayer.setShuffleMode(SessionPlayer2.SHUFFLE_MODE_ALL);
    assertTrue(onShuffleModeChangedMonitor.waitForSignal(WAIT_TIME_MS));
    result = future.get();
    assertEquals(mPlayer, mPlayerCbArg1);
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertEquals(SessionPlayer2.SHUFFLE_MODE_ALL, ((Integer) mPlayerCbArg2).intValue());
    assertEquals(SessionPlayer2.SHUFFLE_MODE_ALL, mPlayer.getShuffleMode());
    onShuffleModeChangedMonitor.reset();
    future = mPlayer.setShuffleMode(SessionPlayer2.SHUFFLE_MODE_GROUP);
    assertTrue(onShuffleModeChangedMonitor.waitForSignal(WAIT_TIME_MS));
    result = future.get();
    assertEquals(mPlayer, mPlayerCbArg1);
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertEquals(SessionPlayer2.SHUFFLE_MODE_GROUP, ((Integer) mPlayerCbArg2).intValue());
    assertEquals(SessionPlayer2.SHUFFLE_MODE_GROUP, mPlayer.getShuffleMode());
    // INVALID_SHUFFLE_MODE will not change the shuffle mode.
    onShuffleModeChangedMonitor.reset();
    future = mPlayer.setShuffleMode(INVALID_SHUFFLE_MODE);
    assertFalse(onShuffleModeChangedMonitor.waitForSignal(WAIT_TIME_MS));
    result = future.get();
    assertEquals(mPlayer, mPlayerCbArg1);
    assertEquals(RESULT_CODE_BAD_VALUE, result.getResultCode());
    assertEquals(SessionPlayer2.SHUFFLE_MODE_GROUP, mPlayer.getShuffleMode());
}
#method_after
@SmallTest
public void testSetAndGetShuflleMode() throws Exception {
    final TestUtils.Monitor onShuffleModeChangedMonitor = new TestUtils.Monitor();
    MediaPlayer.PlayerCallback callback = new MediaPlayer.PlayerCallback() {

        @Override
        public void onShuffleModeChanged(SessionPlayer player, int shuffleMode) {
            mPlayerCbArg1 = player;
            mPlayerCbArg2 = new Integer(shuffleMode);
            onShuffleModeChangedMonitor.signal();
        }
    };
    mPlayer.registerPlayerCallback(mExecutor, callback);
    int shuffleMode = mPlayer.getShuffleMode();
    ListenableFuture<PlayerResult> future;
    PlayerResult result;
    if (shuffleMode != SessionPlayer.SHUFFLE_MODE_NONE) {
        onShuffleModeChangedMonitor.reset();
        future = mPlayer.setShuffleMode(SessionPlayer.SHUFFLE_MODE_NONE);
        assertTrue(onShuffleModeChangedMonitor.waitForSignal(WAIT_TIME_MS));
        result = future.get();
        assertEquals(mPlayer, mPlayerCbArg1);
        assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
        assertEquals(SessionPlayer.SHUFFLE_MODE_NONE, ((Integer) mPlayerCbArg2).intValue());
        assertEquals(SessionPlayer.SHUFFLE_MODE_NONE, mPlayer.getShuffleMode());
    }
    onShuffleModeChangedMonitor.reset();
    future = mPlayer.setShuffleMode(SessionPlayer.SHUFFLE_MODE_ALL);
    assertTrue(onShuffleModeChangedMonitor.waitForSignal(WAIT_TIME_MS));
    result = future.get();
    assertEquals(mPlayer, mPlayerCbArg1);
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertEquals(SessionPlayer.SHUFFLE_MODE_ALL, ((Integer) mPlayerCbArg2).intValue());
    assertEquals(SessionPlayer.SHUFFLE_MODE_ALL, mPlayer.getShuffleMode());
    onShuffleModeChangedMonitor.reset();
    future = mPlayer.setShuffleMode(SessionPlayer.SHUFFLE_MODE_GROUP);
    assertTrue(onShuffleModeChangedMonitor.waitForSignal(WAIT_TIME_MS));
    result = future.get();
    assertEquals(mPlayer, mPlayerCbArg1);
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertEquals(SessionPlayer.SHUFFLE_MODE_GROUP, ((Integer) mPlayerCbArg2).intValue());
    assertEquals(SessionPlayer.SHUFFLE_MODE_GROUP, mPlayer.getShuffleMode());
    // INVALID_SHUFFLE_MODE will not change the shuffle mode.
    onShuffleModeChangedMonitor.reset();
    future = mPlayer.setShuffleMode(INVALID_SHUFFLE_MODE);
    assertFalse(onShuffleModeChangedMonitor.waitForSignal(WAIT_TIME_MS));
    result = future.get();
    assertEquals(mPlayer, mPlayerCbArg1);
    assertEquals(RESULT_CODE_BAD_VALUE, result.getResultCode());
    assertEquals(SessionPlayer.SHUFFLE_MODE_GROUP, mPlayer.getShuffleMode());
}
#end_block

#method_before
@Test
@SmallTest
public void testSetAndGetRepeatMode() throws Exception {
    final TestUtils.Monitor onRepeatModeChangedMonitor = new TestUtils.Monitor();
    MediaPlayer.PlayerCallback callback = new MediaPlayer.PlayerCallback() {

        @Override
        public void onRepeatModeChanged(SessionPlayer2 player, int repeatMode) {
            mPlayerCbArg1 = player;
            mPlayerCbArg2 = new Integer(repeatMode);
            onRepeatModeChangedMonitor.signal();
        }
    };
    mPlayer.registerPlayerCallback(mExecutor, callback);
    int repeatMode = mPlayer.getRepeatMode();
    ListenableFuture<PlayerResult> future;
    PlayerResult result;
    if (repeatMode != SessionPlayer2.REPEAT_MODE_NONE) {
        onRepeatModeChangedMonitor.reset();
        future = mPlayer.setRepeatMode(SessionPlayer2.REPEAT_MODE_NONE);
        assertTrue(onRepeatModeChangedMonitor.waitForSignal(WAIT_TIME_MS));
        result = future.get();
        assertEquals(mPlayer, mPlayerCbArg1);
        assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
        assertEquals(SessionPlayer2.REPEAT_MODE_NONE, ((Integer) mPlayerCbArg2).intValue());
        assertEquals(SessionPlayer2.REPEAT_MODE_NONE, mPlayer.getRepeatMode());
    }
    onRepeatModeChangedMonitor.reset();
    future = mPlayer.setRepeatMode(SessionPlayer2.REPEAT_MODE_ALL);
    assertTrue(onRepeatModeChangedMonitor.waitForSignal(WAIT_TIME_MS));
    result = future.get();
    assertEquals(mPlayer, mPlayerCbArg1);
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertEquals(SessionPlayer2.REPEAT_MODE_ALL, ((Integer) mPlayerCbArg2).intValue());
    assertEquals(SessionPlayer2.REPEAT_MODE_ALL, mPlayer.getRepeatMode());
    onRepeatModeChangedMonitor.reset();
    future = mPlayer.setRepeatMode(SessionPlayer2.REPEAT_MODE_GROUP);
    assertTrue(onRepeatModeChangedMonitor.waitForSignal(WAIT_TIME_MS));
    result = future.get();
    assertEquals(mPlayer, mPlayerCbArg1);
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertEquals(SessionPlayer2.REPEAT_MODE_GROUP, ((Integer) mPlayerCbArg2).intValue());
    assertEquals(SessionPlayer2.REPEAT_MODE_GROUP, mPlayer.getRepeatMode());
    // INVALID_REPEAT_MODE will not change the repeat mode.
    onRepeatModeChangedMonitor.reset();
    future = mPlayer.setRepeatMode(INVALID_REPEAT_MODE);
    assertFalse(onRepeatModeChangedMonitor.waitForSignal(WAIT_TIME_MS));
    result = future.get();
    assertEquals(mPlayer, mPlayerCbArg1);
    assertEquals(RESULT_CODE_BAD_VALUE, result.getResultCode());
    assertEquals(SessionPlayer2.REPEAT_MODE_GROUP, mPlayer.getRepeatMode());
}
#method_after
@Test
@SmallTest
public void testSetAndGetRepeatMode() throws Exception {
    final TestUtils.Monitor onRepeatModeChangedMonitor = new TestUtils.Monitor();
    MediaPlayer.PlayerCallback callback = new MediaPlayer.PlayerCallback() {

        @Override
        public void onRepeatModeChanged(SessionPlayer player, int repeatMode) {
            mPlayerCbArg1 = player;
            mPlayerCbArg2 = new Integer(repeatMode);
            onRepeatModeChangedMonitor.signal();
        }
    };
    mPlayer.registerPlayerCallback(mExecutor, callback);
    int repeatMode = mPlayer.getRepeatMode();
    ListenableFuture<PlayerResult> future;
    PlayerResult result;
    if (repeatMode != SessionPlayer.REPEAT_MODE_NONE) {
        onRepeatModeChangedMonitor.reset();
        future = mPlayer.setRepeatMode(SessionPlayer.REPEAT_MODE_NONE);
        assertTrue(onRepeatModeChangedMonitor.waitForSignal(WAIT_TIME_MS));
        result = future.get();
        assertEquals(mPlayer, mPlayerCbArg1);
        assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
        assertEquals(SessionPlayer.REPEAT_MODE_NONE, ((Integer) mPlayerCbArg2).intValue());
        assertEquals(SessionPlayer.REPEAT_MODE_NONE, mPlayer.getRepeatMode());
    }
    onRepeatModeChangedMonitor.reset();
    future = mPlayer.setRepeatMode(SessionPlayer.REPEAT_MODE_ALL);
    assertTrue(onRepeatModeChangedMonitor.waitForSignal(WAIT_TIME_MS));
    result = future.get();
    assertEquals(mPlayer, mPlayerCbArg1);
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertEquals(SessionPlayer.REPEAT_MODE_ALL, ((Integer) mPlayerCbArg2).intValue());
    assertEquals(SessionPlayer.REPEAT_MODE_ALL, mPlayer.getRepeatMode());
    onRepeatModeChangedMonitor.reset();
    future = mPlayer.setRepeatMode(SessionPlayer.REPEAT_MODE_GROUP);
    assertTrue(onRepeatModeChangedMonitor.waitForSignal(WAIT_TIME_MS));
    result = future.get();
    assertEquals(mPlayer, mPlayerCbArg1);
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertEquals(SessionPlayer.REPEAT_MODE_GROUP, ((Integer) mPlayerCbArg2).intValue());
    assertEquals(SessionPlayer.REPEAT_MODE_GROUP, mPlayer.getRepeatMode());
    // INVALID_REPEAT_MODE will not change the repeat mode.
    onRepeatModeChangedMonitor.reset();
    future = mPlayer.setRepeatMode(INVALID_REPEAT_MODE);
    assertFalse(onRepeatModeChangedMonitor.waitForSignal(WAIT_TIME_MS));
    result = future.get();
    assertEquals(mPlayer, mPlayerCbArg1);
    assertEquals(RESULT_CODE_BAD_VALUE, result.getResultCode());
    assertEquals(SessionPlayer.REPEAT_MODE_GROUP, mPlayer.getRepeatMode());
}
#end_block

#method_before
@Test
@SmallTest
public void testSetPlaylist() throws Exception {
    List<MediaItem2> playlist = createPlaylist(10);
    try {
        mPlayer.setPlaylist(null, null);
        fail();
    } catch (Exception e) {
    // pass-through
    }
    try {
        List<MediaItem2> list = new ArrayList<>();
        list.add(null);
        mPlayer.setPlaylist(list, null);
        fail();
    } catch (Exception e) {
    // pass-through
    }
    ListenableFuture<PlayerResult> future = mPlayer.setPlaylist(playlist, null);
    PlayerResult result = future.get();
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertEquals(playlist.size(), mPlayer.getPlaylist().size());
    assertEquals(playlist.get(0), mPlayer.getCurrentMediaItem());
}
#method_after
@Test
@SmallTest
public void testSetPlaylist() throws Exception {
    List<MediaItem> playlist = createPlaylist(10);
    try {
        mPlayer.setPlaylist(null, null);
        fail();
    } catch (Exception e) {
    // pass-through
    }
    try {
        List<MediaItem> list = new ArrayList<>();
        list.add(null);
        mPlayer.setPlaylist(list, null);
        fail();
    } catch (Exception e) {
    // pass-through
    }
    ListenableFuture<PlayerResult> future = mPlayer.setPlaylist(playlist, null);
    PlayerResult result = future.get();
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertEquals(playlist.size(), mPlayer.getPlaylist().size());
    assertEquals(playlist.get(0), mPlayer.getCurrentMediaItem());
}
#end_block

#method_before
@Test
@SmallTest
public void testSkipToPlaylistItems() throws Exception {
    int listSize = 5;
    List<MediaItem2> playlist = createPlaylist(listSize);
    PlayerResult result = mPlayer.setPlaylist(playlist, null).get();
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    mPlayer.setRepeatMode(SessionPlayer2.REPEAT_MODE_NONE).get();
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    // Test skipToPlaylistItem
    for (int i = listSize - 1; i >= 0; --i) {
        result = mPlayer.skipToPlaylistItem(playlist.get(i)).get();
        assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
        assertEquals(playlist.get(i), mPlayer.getCurrentMediaItem());
    }
}
#method_after
@Test
@SmallTest
public void testSkipToPlaylistItems() throws Exception {
    int listSize = 5;
    List<MediaItem> playlist = createPlaylist(listSize);
    PlayerResult result = mPlayer.setPlaylist(playlist, null).get();
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    mPlayer.setRepeatMode(SessionPlayer.REPEAT_MODE_NONE).get();
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    // Test skipToPlaylistItem
    for (int i = listSize - 1; i >= 0; --i) {
        result = mPlayer.skipToPlaylistItem(playlist.get(i)).get();
        assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
        assertEquals(playlist.get(i), mPlayer.getCurrentMediaItem());
    }
}
#end_block

#method_before
@Test
@SmallTest
public void testSkipToNextItems() throws Exception {
    int listSize = 5;
    List<MediaItem2> playlist = createPlaylist(listSize);
    PlayerResult result = mPlayer.setPlaylist(playlist, null).get();
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    mPlayer.setRepeatMode(SessionPlayer2.REPEAT_MODE_NONE).get();
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    // curPlayPos = 0
    for (int curPlayPos = 0; curPlayPos < listSize - 1; ++curPlayPos) {
        result = mPlayer.skipToNextPlaylistItem().get();
        assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
        assertEquals(playlist.get(curPlayPos + 1), mPlayer.getCurrentMediaItem());
    }
    result = mPlayer.skipToNextPlaylistItem().get();
    assertEquals(RESULT_CODE_INVALID_STATE, result.getResultCode());
    assertEquals(playlist.get(listSize - 1), mPlayer.getCurrentMediaItem());
}
#method_after
@Test
@SmallTest
public void testSkipToNextItems() throws Exception {
    int listSize = 5;
    List<MediaItem> playlist = createPlaylist(listSize);
    PlayerResult result = mPlayer.setPlaylist(playlist, null).get();
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    mPlayer.setRepeatMode(SessionPlayer.REPEAT_MODE_NONE).get();
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    // curPlayPos = 0
    for (int curPlayPos = 0; curPlayPos < listSize - 1; ++curPlayPos) {
        result = mPlayer.skipToNextPlaylistItem().get();
        assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
        assertEquals(playlist.get(curPlayPos + 1), mPlayer.getCurrentMediaItem());
    }
    result = mPlayer.skipToNextPlaylistItem().get();
    assertEquals(RESULT_CODE_INVALID_STATE, result.getResultCode());
    assertEquals(playlist.get(listSize - 1), mPlayer.getCurrentMediaItem());
}
#end_block

#method_before
@Test
@SmallTest
public void testSkipToPreviousItems() throws Exception {
    int listSize = 5;
    List<MediaItem2> playlist = createPlaylist(listSize);
    PlayerResult result = mPlayer.setPlaylist(playlist, null).get();
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    mPlayer.setRepeatMode(SessionPlayer2.REPEAT_MODE_NONE).get();
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    result = mPlayer.skipToPlaylistItem(playlist.get(listSize - 1)).get();
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    // curPlayPos = listSize - 1
    for (int curPlayPos = listSize - 1; curPlayPos > 0; --curPlayPos) {
        result = mPlayer.skipToPreviousPlaylistItem().get();
        assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
        assertEquals(playlist.get(curPlayPos - 1), mPlayer.getCurrentMediaItem());
    }
    result = mPlayer.skipToPreviousPlaylistItem().get();
    assertEquals(RESULT_CODE_INVALID_STATE, result.getResultCode());
    assertEquals(playlist.get(0), mPlayer.getCurrentMediaItem());
}
#method_after
@Test
@SmallTest
public void testSkipToPreviousItems() throws Exception {
    int listSize = 5;
    List<MediaItem> playlist = createPlaylist(listSize);
    PlayerResult result = mPlayer.setPlaylist(playlist, null).get();
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    mPlayer.setRepeatMode(SessionPlayer.REPEAT_MODE_NONE).get();
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    result = mPlayer.skipToPlaylistItem(playlist.get(listSize - 1)).get();
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    // curPlayPos = listSize - 1
    for (int curPlayPos = listSize - 1; curPlayPos > 0; --curPlayPos) {
        result = mPlayer.skipToPreviousPlaylistItem().get();
        assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
        assertEquals(playlist.get(curPlayPos - 1), mPlayer.getCurrentMediaItem());
    }
    result = mPlayer.skipToPreviousPlaylistItem().get();
    assertEquals(RESULT_CODE_INVALID_STATE, result.getResultCode());
    assertEquals(playlist.get(0), mPlayer.getCurrentMediaItem());
}
#end_block

#method_before
@Test
@SmallTest
public void testSkipToNextPreviousItemsWithRepeatMode() throws Exception {
    int listSize = 5;
    List<MediaItem2> playlist = createPlaylist(listSize);
    PlayerResult result = mPlayer.setPlaylist(playlist, null).get();
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    result = mPlayer.setRepeatMode(SessionPlayer2.REPEAT_MODE_ALL).get();
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    result = mPlayer.skipToPreviousPlaylistItem().get();
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertEquals(playlist.get(listSize - 1), mPlayer.getCurrentMediaItem());
    result = mPlayer.skipToNextPlaylistItem().get();
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertEquals(playlist.get(0), mPlayer.getCurrentMediaItem());
}
#method_after
@Test
@SmallTest
public void testSkipToNextPreviousItemsWithRepeatMode() throws Exception {
    int listSize = 5;
    List<MediaItem> playlist = createPlaylist(listSize);
    PlayerResult result = mPlayer.setPlaylist(playlist, null).get();
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    result = mPlayer.setRepeatMode(SessionPlayer.REPEAT_MODE_ALL).get();
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    result = mPlayer.skipToPreviousPlaylistItem().get();
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertEquals(playlist.get(listSize - 1), mPlayer.getCurrentMediaItem());
    result = mPlayer.skipToNextPlaylistItem().get();
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertEquals(playlist.get(0), mPlayer.getCurrentMediaItem());
}
#end_block

#method_before
@Test
@SmallTest
public void testPlaylistAfterSkipToNextItem() throws Exception {
    int listSize = 2;
    List<MediaItem2> playlist = createPlaylist(listSize);
    PlayerResult result = mPlayer.setPlaylist(playlist, null).get();
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertEquals(playlist.get(0), mPlayer.getCurrentMediaItem());
    result = mPlayer.skipToNextPlaylistItem().get();
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertEquals(playlist.get(1), mPlayer.getCurrentMediaItem());
    // Will not go to the next if the next is end of the playlist
    result = mPlayer.skipToNextPlaylistItem().get();
    assertEquals(RESULT_CODE_INVALID_STATE, result.getResultCode());
    assertEquals(playlist.get(1), mPlayer.getCurrentMediaItem());
    result = mPlayer.setRepeatMode(SessionPlayer2.REPEAT_MODE_ALL).get();
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    result = mPlayer.skipToNextPlaylistItem().get();
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertEquals(playlist.get(0), mPlayer.getCurrentMediaItem());
}
#method_after
@Test
@SmallTest
public void testPlaylistAfterSkipToNextItem() throws Exception {
    int listSize = 2;
    List<MediaItem> playlist = createPlaylist(listSize);
    PlayerResult result = mPlayer.setPlaylist(playlist, null).get();
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertEquals(playlist.get(0), mPlayer.getCurrentMediaItem());
    result = mPlayer.skipToNextPlaylistItem().get();
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertEquals(playlist.get(1), mPlayer.getCurrentMediaItem());
    // Will not go to the next if the next is end of the playlist
    result = mPlayer.skipToNextPlaylistItem().get();
    assertEquals(RESULT_CODE_INVALID_STATE, result.getResultCode());
    assertEquals(playlist.get(1), mPlayer.getCurrentMediaItem());
    result = mPlayer.setRepeatMode(SessionPlayer.REPEAT_MODE_ALL).get();
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    result = mPlayer.skipToNextPlaylistItem().get();
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertEquals(playlist.get(0), mPlayer.getCurrentMediaItem());
}
#end_block

#method_before
@Test
@SmallTest
public void testPlaylistAfterSkipToPreviousItem() throws Exception {
    int listSize = 2;
    List<MediaItem2> playlist = createPlaylist(listSize);
    PlayerResult result = mPlayer.setPlaylist(playlist, null).get();
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertEquals(playlist.get(0), mPlayer.getCurrentMediaItem());
    // Will not go to the previous if the current is the first one
    result = mPlayer.skipToPreviousPlaylistItem().get();
    assertEquals(RESULT_CODE_INVALID_STATE, result.getResultCode());
    assertEquals(playlist.get(0), mPlayer.getCurrentMediaItem());
    result = mPlayer.setRepeatMode(SessionPlayer2.REPEAT_MODE_ALL).get();
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    result = mPlayer.skipToPreviousPlaylistItem().get();
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertEquals(playlist.get(1), mPlayer.getCurrentMediaItem());
}
#method_after
@Test
@SmallTest
public void testPlaylistAfterSkipToPreviousItem() throws Exception {
    int listSize = 2;
    List<MediaItem> playlist = createPlaylist(listSize);
    PlayerResult result = mPlayer.setPlaylist(playlist, null).get();
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertEquals(playlist.get(0), mPlayer.getCurrentMediaItem());
    // Will not go to the previous if the current is the first one
    result = mPlayer.skipToPreviousPlaylistItem().get();
    assertEquals(RESULT_CODE_INVALID_STATE, result.getResultCode());
    assertEquals(playlist.get(0), mPlayer.getCurrentMediaItem());
    result = mPlayer.setRepeatMode(SessionPlayer.REPEAT_MODE_ALL).get();
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    result = mPlayer.skipToPreviousPlaylistItem().get();
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertEquals(playlist.get(1), mPlayer.getCurrentMediaItem());
}
#end_block

#method_before
@Test
@SmallTest
public void testCurrentMediaItemChangedCalledAfterSetMediaItem() throws Exception {
    MediaItem2 item = createMediaItem(100);
    final TestUtils.Monitor onCurrentMediaItemChangedMonitor = new TestUtils.Monitor();
    MediaPlayer.PlayerCallback callback = new MediaPlayer.PlayerCallback() {

        @Override
        public void onCurrentMediaItemChanged(SessionPlayer2 player, MediaItem2 item) {
            onCurrentMediaItemChangedMonitor.signal();
        }
    };
    mPlayer.registerPlayerCallback(mExecutor, callback);
    PlayerResult result = mPlayer.setMediaItem(item).get();
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertTrue(onCurrentMediaItemChangedMonitor.waitForSignal(WAIT_TIME_MS));
}
#method_after
@Test
@SmallTest
public void testCurrentMediaItemChangedCalledAfterSetMediaItem() throws Exception {
    MediaItem item = createMediaItem(100);
    final TestUtils.Monitor onCurrentMediaItemChangedMonitor = new TestUtils.Monitor();
    MediaPlayer.PlayerCallback callback = new MediaPlayer.PlayerCallback() {

        @Override
        public void onCurrentMediaItemChanged(SessionPlayer player, MediaItem item) {
            onCurrentMediaItemChangedMonitor.signal();
        }
    };
    mPlayer.registerPlayerCallback(mExecutor, callback);
    PlayerResult result = mPlayer.setMediaItem(item).get();
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertTrue(onCurrentMediaItemChangedMonitor.waitForSignal(WAIT_TIME_MS));
}
#end_block

#method_before
@Test
@SmallTest
public void testCurrentMediaItemChangedCalledAfterSetPlayList() throws Exception {
    int listSize = 2;
    List<MediaItem2> playlist = createPlaylist(listSize);
    final TestUtils.Monitor onCurrentMediaItemChangedMonitor = new TestUtils.Monitor();
    MediaPlayer.PlayerCallback callback = new MediaPlayer.PlayerCallback() {

        @Override
        public void onCurrentMediaItemChanged(SessionPlayer2 player, MediaItem2 item) {
            onCurrentMediaItemChangedMonitor.signal();
        }
    };
    mPlayer.registerPlayerCallback(mExecutor, callback);
    PlayerResult result = mPlayer.setPlaylist(playlist, null).get();
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertTrue(onCurrentMediaItemChangedMonitor.waitForSignal(WAIT_TIME_MS));
}
#method_after
@Test
@SmallTest
public void testCurrentMediaItemChangedCalledAfterSetPlayList() throws Exception {
    int listSize = 2;
    List<MediaItem> playlist = createPlaylist(listSize);
    final TestUtils.Monitor onCurrentMediaItemChangedMonitor = new TestUtils.Monitor();
    MediaPlayer.PlayerCallback callback = new MediaPlayer.PlayerCallback() {

        @Override
        public void onCurrentMediaItemChanged(SessionPlayer player, MediaItem item) {
            onCurrentMediaItemChangedMonitor.signal();
        }
    };
    mPlayer.registerPlayerCallback(mExecutor, callback);
    PlayerResult result = mPlayer.setPlaylist(playlist, null).get();
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertTrue(onCurrentMediaItemChangedMonitor.waitForSignal(WAIT_TIME_MS));
}
#end_block

#method_before
private MediaItem2 createMediaItem(int key) throws Exception {
    AssetFileDescriptor afd = mResources.openRawResourceFd(R.raw.testvideo);
    return new FileMediaItem2.Builder(afd.getFileDescriptor(), afd.getStartOffset(), afd.getLength()).build();
}
#method_after
private MediaItem createMediaItem(int key) throws Exception {
    AssetFileDescriptor afd = mResources.openRawResourceFd(R.raw.testvideo);
    return new FileMediaItem.Builder(afd.getFileDescriptor(), afd.getStartOffset(), afd.getLength()).build();
}
#end_block

#method_before
private List<MediaItem2> createPlaylist(int size) throws Exception {
    List<MediaItem2> items = new ArrayList<>();
    for (int i = 0; i < size; ++i) {
        items.add(createMediaItem(i));
    }
    return items;
}
#method_after
private List<MediaItem> createPlaylist(int size) throws Exception {
    List<MediaItem> items = new ArrayList<>();
    for (int i = 0; i < size; ++i) {
        items.add(createMediaItem(i));
    }
    return items;
}
#end_block

#method_before
private void playLoadedModularDrmVideo_Generic(final Uri file, final Integer width, final Integer height, int playTime, ModularDrmTestType testType) throws Exception {
    final float volume = 0.5f;
    mAudioOnly = (width == 0);
    mECb = new MediaPlayer.PlayerCallback() {

        @Override
        public void onVideoSizeChanged(MediaPlayer mp, MediaItem2 item, VideoSize size) {
            Log.v(TAG, "VideoSizeChanged" + " w:" + size.getWidth() + " h:" + size.getHeight());
            mOnVideoSizeChangedCalled.signal();
        }

        @Override
        public void onError(MediaPlayer mp, MediaItem2 item, int what, int extra) {
            fail("Media player had error " + what + " playing video");
        }

        @Override
        public void onInfo(MediaPlayer mp, MediaItem2 item, int what, int extra) {
            if (what == MediaPlayer.MEDIA_INFO_MEDIA_ITEM_END) {
                Log.v(TAG, "playLoadedVideo: onInfo_PlaybackComplete");
                mOnPlaybackCompleted.signal();
            }
        }
    };
    mPlayer.registerPlayerCallback(mExecutor, mECb);
    Log.v(TAG, "playLoadedVideo: setMediaItem()");
    ListenableFuture<PlayerResult> future = mPlayer.setMediaItem(new UriMediaItem2.Builder(mContext, file).build());
    assertEquals(PlayerResult.RESULT_CODE_SUCCESS, future.get().getResultCode());
    SurfaceHolder surfaceHolder = mActivity.getSurfaceHolder();
    surfaceHolder.setKeepScreenOn(true);
    mPlayer.setSurface(surfaceHolder.getSurface());
    try {
        switch(testType) {
            case V0_SYNC_TEST:
                preparePlayerAndDrm_V0_syncDrmSetup();
                break;
            case V1_ASYNC_TEST:
                preparePlayerAndDrm_V1_asyncDrmSetup();
                break;
            case V2_SYNC_CONFIG_TEST:
                preparePlayerAndDrm_V2_syncDrmSetupPlusConfig();
                break;
            case V3_ASYNC_DRMPREPARED_TEST:
                preparePlayerAndDrm_V3_asyncDrmSetupPlusDrmPreparedListener();
                break;
        }
    } catch (IOException e) {
        e.printStackTrace();
        throw new PrepareFailedException();
    }
    Log.v(TAG, "playLoadedVideo: play()");
    mPlayer.play();
    if (!mAudioOnly) {
        mOnVideoSizeChangedCalled.waitForSignal();
    }
    mPlayer.setPlayerVolume(volume);
    // waiting to complete
    if (playTime == 0) {
        Log.v(TAG, "playLoadedVideo: waiting for playback completion");
        mOnPlaybackCompleted.waitForSignal();
    } else {
        Log.v(TAG, "playLoadedVideo: waiting while playing for " + playTime);
        mOnPlaybackCompleted.waitForSignal(playTime);
    }
    try {
        Log.v(TAG, "playLoadedVideo: releaseDrm");
        mPlayer.releaseDrm();
    } catch (Exception e) {
        e.printStackTrace();
        throw new PrepareFailedException();
    }
}
#method_after
private void playLoadedModularDrmVideo_Generic(final Uri file, final Integer width, final Integer height, int playTime, ModularDrmTestType testType) throws Exception {
    final float volume = 0.5f;
    mAudioOnly = (width == 0);
    mECb = new MediaPlayer.PlayerCallback() {

        @Override
        public void onVideoSizeChanged(MediaPlayer mp, MediaItem item, VideoSize size) {
            Log.v(TAG, "VideoSizeChanged" + " w:" + size.getWidth() + " h:" + size.getHeight());
            mOnVideoSizeChangedCalled.signal();
        }

        @Override
        public void onError(MediaPlayer mp, MediaItem item, int what, int extra) {
            fail("Media player had error " + what + " playing video");
        }

        @Override
        public void onInfo(MediaPlayer mp, MediaItem item, int what, int extra) {
            if (what == MediaPlayer.MEDIA_INFO_MEDIA_ITEM_END) {
                Log.v(TAG, "playLoadedVideo: onInfo_PlaybackComplete");
                mOnPlaybackCompleted.signal();
            }
        }
    };
    mPlayer.registerPlayerCallback(mExecutor, mECb);
    Log.v(TAG, "playLoadedVideo: setMediaItem()");
    ListenableFuture<PlayerResult> future = mPlayer.setMediaItem(new UriMediaItem.Builder(mContext, file).build());
    assertEquals(PlayerResult.RESULT_CODE_SUCCESS, future.get().getResultCode());
    SurfaceHolder surfaceHolder = mActivity.getSurfaceHolder();
    surfaceHolder.setKeepScreenOn(true);
    mPlayer.setSurface(surfaceHolder.getSurface());
    try {
        switch(testType) {
            case V0_SYNC_TEST:
                preparePlayerAndDrm_V0_syncDrmSetup();
                break;
            case V1_ASYNC_TEST:
                preparePlayerAndDrm_V1_asyncDrmSetup();
                break;
            case V2_SYNC_CONFIG_TEST:
                preparePlayerAndDrm_V2_syncDrmSetupPlusConfig();
                break;
            case V3_ASYNC_DRMPREPARED_TEST:
                preparePlayerAndDrm_V3_asyncDrmSetupPlusDrmPreparedListener();
                break;
        }
    } catch (IOException e) {
        e.printStackTrace();
        throw new PrepareFailedException();
    }
    Log.v(TAG, "playLoadedVideo: play()");
    mPlayer.play();
    if (!mAudioOnly) {
        mOnVideoSizeChangedCalled.waitForSignal();
    }
    mPlayer.setPlayerVolume(volume);
    // waiting to complete
    if (playTime == 0) {
        Log.v(TAG, "playLoadedVideo: waiting for playback completion");
        mOnPlaybackCompleted.waitForSignal();
    } else {
        Log.v(TAG, "playLoadedVideo: waiting while playing for " + playTime);
        mOnPlaybackCompleted.waitForSignal(playTime);
    }
    try {
        Log.v(TAG, "playLoadedVideo: releaseDrm");
        mPlayer.releaseDrm();
    } catch (Exception e) {
        e.printStackTrace();
        throw new PrepareFailedException();
    }
}
#end_block

#method_before
private void preparePlayerAndDrm_V1_asyncDrmSetup() throws InterruptedException, ExecutionException {
    final AtomicBoolean asyncSetupDrmError = new AtomicBoolean(false);
    mPlayer.registerPlayerCallback(mExecutor, new MediaPlayer.PlayerCallback() {

        @Override
        public void onDrmInfo(MediaPlayer mp, MediaItem2 item, DrmInfo drmInfo) {
            Log.v(TAG, "preparePlayerAndDrm_V1: onDrmInfo" + drmInfo);
            // in the callback (async mode) so handling exceptions here
            try {
                setupDrm(drmInfo, true, /* prepareDrm */
                true, /* synchronousNetworking */
                MediaDrm.KEY_TYPE_STREAMING);
            } catch (Exception e) {
                Log.v(TAG, "preparePlayerAndDrm_V1: setupDrm EXCEPTION " + e);
                asyncSetupDrmError.set(true);
            }
            mOnDrmInfoCalled.signal();
            Log.v(TAG, "preparePlayerAndDrm_V1: onDrmInfo done!");
        }
    });
    Log.v(TAG, "preparePlayerAndDrm_V1: calling prepare()");
    ListenableFuture<PlayerResult> future = mPlayer.prepare();
    assertEquals(PlayerResult.RESULT_CODE_SUCCESS, future.get().getResultCode());
    mOnDrmInfoCalled.waitForSignal();
    // to handle setupDrm error (async) in the main thread rather than the callback
    if (asyncSetupDrmError.get()) {
        fail("preparePlayerAndDrm_V1: setupDrm");
    }
}
#method_after
private void preparePlayerAndDrm_V1_asyncDrmSetup() throws InterruptedException, ExecutionException {
    final AtomicBoolean asyncSetupDrmError = new AtomicBoolean(false);
    mPlayer.registerPlayerCallback(mExecutor, new MediaPlayer.PlayerCallback() {

        @Override
        public void onDrmInfo(MediaPlayer mp, MediaItem item, DrmInfo drmInfo) {
            Log.v(TAG, "preparePlayerAndDrm_V1: onDrmInfo" + drmInfo);
            // in the callback (async mode) so handling exceptions here
            try {
                setupDrm(drmInfo, true, /* prepareDrm */
                true, /* synchronousNetworking */
                MediaDrm.KEY_TYPE_STREAMING);
            } catch (Exception e) {
                Log.v(TAG, "preparePlayerAndDrm_V1: setupDrm EXCEPTION " + e);
                asyncSetupDrmError.set(true);
            }
            mOnDrmInfoCalled.signal();
            Log.v(TAG, "preparePlayerAndDrm_V1: onDrmInfo done!");
        }
    });
    Log.v(TAG, "preparePlayerAndDrm_V1: calling prepare()");
    ListenableFuture<PlayerResult> future = mPlayer.prepare();
    assertEquals(PlayerResult.RESULT_CODE_SUCCESS, future.get().getResultCode());
    mOnDrmInfoCalled.waitForSignal();
    // to handle setupDrm error (async) in the main thread rather than the callback
    if (asyncSetupDrmError.get()) {
        fail("preparePlayerAndDrm_V1: setupDrm");
    }
}
#end_block

#method_before
private void preparePlayerAndDrm_V2_syncDrmSetupPlusConfig() throws Exception {
    mPlayer.setOnDrmConfigHelper(new MediaPlayer.OnDrmConfigHelper() {

        @Override
        public void onDrmConfig(MediaPlayer mp, MediaItem2 item) {
            String widevineSecurityLevel3 = "L3";
            String securityLevelProperty = "securityLevel";
            try {
                String level = mp.getDrmPropertyString(securityLevelProperty);
                Log.v(TAG, "preparePlayerAndDrm_V2: getDrmPropertyString: " + securityLevelProperty + " -> " + level);
                mp.setDrmPropertyString(securityLevelProperty, widevineSecurityLevel3);
                level = mp.getDrmPropertyString(securityLevelProperty);
                Log.v(TAG, "preparePlayerAndDrm_V2: getDrmPropertyString: " + securityLevelProperty + " -> " + level);
            } catch (MediaPlayer.NoDrmSchemeException e) {
                Log.v(TAG, "preparePlayerAndDrm_V2: NoDrmSchemeException");
            } catch (Exception e) {
                Log.v(TAG, "preparePlayerAndDrm_V2: onDrmConfig EXCEPTION " + e);
            }
        }
    });
    Log.v(TAG, "preparePlayerAndDrm_V2: calling prepare()");
    ListenableFuture<PlayerResult> future = mPlayer.prepare();
    assertEquals(PlayerResult.RESULT_CODE_SUCCESS, future.get().getResultCode());
    DrmInfo drmInfo = mPlayer.getDrmInfo();
    if (drmInfo != null) {
        setupDrm(drmInfo, true, /* prepareDrm */
        true, /* synchronousNetworking */
        MediaDrm.KEY_TYPE_STREAMING);
        Log.v(TAG, "preparePlayerAndDrm_V2: setupDrm done!");
    }
}
#method_after
private void preparePlayerAndDrm_V2_syncDrmSetupPlusConfig() throws Exception {
    mPlayer.setOnDrmConfigHelper(new MediaPlayer.OnDrmConfigHelper() {

        @Override
        public void onDrmConfig(MediaPlayer mp, MediaItem item) {
            String widevineSecurityLevel3 = "L3";
            String securityLevelProperty = "securityLevel";
            try {
                String level = mp.getDrmPropertyString(securityLevelProperty);
                Log.v(TAG, "preparePlayerAndDrm_V2: getDrmPropertyString: " + securityLevelProperty + " -> " + level);
                mp.setDrmPropertyString(securityLevelProperty, widevineSecurityLevel3);
                level = mp.getDrmPropertyString(securityLevelProperty);
                Log.v(TAG, "preparePlayerAndDrm_V2: getDrmPropertyString: " + securityLevelProperty + " -> " + level);
            } catch (MediaPlayer.NoDrmSchemeException e) {
                Log.v(TAG, "preparePlayerAndDrm_V2: NoDrmSchemeException");
            } catch (Exception e) {
                Log.v(TAG, "preparePlayerAndDrm_V2: onDrmConfig EXCEPTION " + e);
            }
        }
    });
    Log.v(TAG, "preparePlayerAndDrm_V2: calling prepare()");
    ListenableFuture<PlayerResult> future = mPlayer.prepare();
    assertEquals(PlayerResult.RESULT_CODE_SUCCESS, future.get().getResultCode());
    DrmInfo drmInfo = mPlayer.getDrmInfo();
    if (drmInfo != null) {
        setupDrm(drmInfo, true, /* prepareDrm */
        true, /* synchronousNetworking */
        MediaDrm.KEY_TYPE_STREAMING);
        Log.v(TAG, "preparePlayerAndDrm_V2: setupDrm done!");
    }
}
#end_block

#method_before
private void preparePlayerAndDrm_V3_asyncDrmSetupPlusDrmPreparedListener() throws InterruptedException, ExecutionException {
    final AtomicBoolean asyncSetupDrmError = new AtomicBoolean(false);
    mPlayer.registerPlayerCallback(mExecutor, new MediaPlayer.PlayerCallback() {

        @Override
        public void onDrmInfo(MediaPlayer mp, MediaItem2 item, DrmInfo drmInfo) {
            Log.v(TAG, "preparePlayerAndDrm_V3: onDrmInfo" + drmInfo);
            // DRM preperation
            List<UUID> supportedSchemes = drmInfo.getSupportedSchemes();
            if (supportedSchemes.isEmpty()) {
                Log.e(TAG, "preparePlayerAndDrm_V3: onDrmInfo: No supportedSchemes");
                asyncSetupDrmError.set(true);
                mOnDrmInfoCalled.signal();
                // we won't call prepareDrm anymore but need to get passed the wait
                mOnDrmPreparedCalled.signal();
                return;
            }
            // setting up with the first supported UUID
            // instead of supportedSchemes[0] in GTS
            UUID drmScheme = CLEARKEY_SCHEME_UUID;
            Log.d(TAG, "preparePlayerAndDrm_V3: onDrmInfo: selected " + drmScheme);
            Log.v(TAG, "preparePlayerAndDrm_V3: onDrmInfo: calling prepareDrm");
            final ListenableFuture<DrmResult> future = mp.prepareDrm(drmScheme);
            Log.v(TAG, "preparePlayerAndDrm_V3: onDrmInfo: called prepareDrm");
            future.addListener(new Runnable() {

                @Override
                public void run() {
                    try {
                        DrmResult result = future.get();
                        Log.v(TAG, "preparePlayerAndDrm_V3: prepareDrm status: " + result.getResultCode());
                        assertTrue("preparePlayerAndDrm_V3: onDrmPrepared did not succeed", result.getResultCode() == DrmResult.RESULT_CODE_SUCCESS);
                        DrmInfo drmInfo = mPlayer.getDrmInfo();
                        // in the callback (async mode) so handling exceptions here
                        try {
                            setupDrm(drmInfo, false, /* prepareDrm */
                            true, /* synchronousNetworking */
                            MediaDrm.KEY_TYPE_STREAMING);
                        } catch (Exception e) {
                            Log.v(TAG, "preparePlayerAndDrm_V3: setupDrm EXCEPTION ", e);
                            asyncSetupDrmError.set(true);
                        }
                        mOnDrmPreparedCalled.signal();
                        Log.v(TAG, "preparePlayerAndDrm_V3: onDrmPrepared done!");
                    } catch (ExecutionException | InterruptedException e) {
                        Log.e(TAG, "preparePlayerAndDrm_V3: onDrmInfo: prepareDrm exception ", e);
                        asyncSetupDrmError.set(true);
                        mOnDrmInfoCalled.signal();
                        // need to get passed the wait
                        mOnDrmPreparedCalled.signal();
                    }
                }
            }, mExecutor);
            mOnDrmInfoCalled.signal();
            Log.v(TAG, "preparePlayerAndDrm_V3: onDrmInfo done!");
        }
    });
    Log.v(TAG, "preparePlayerAndDrm_V3: calling prepare()");
    ListenableFuture<PlayerResult> future = mPlayer.prepare();
    assertEquals(PlayerResult.RESULT_CODE_SUCCESS, future.get().getResultCode());
    // Unlike v3, onDrmPrepared is not synced to onPrepared b/c of its own thread handler
    mOnDrmPreparedCalled.waitForSignal();
    // to handle setupDrm error (async) in the main thread rather than the callback
    if (asyncSetupDrmError.get()) {
        fail("preparePlayerAndDrm_V3: setupDrm");
    }
}
#method_after
private void preparePlayerAndDrm_V3_asyncDrmSetupPlusDrmPreparedListener() throws InterruptedException, ExecutionException {
    final AtomicBoolean asyncSetupDrmError = new AtomicBoolean(false);
    mPlayer.registerPlayerCallback(mExecutor, new MediaPlayer.PlayerCallback() {

        @Override
        public void onDrmInfo(MediaPlayer mp, MediaItem item, DrmInfo drmInfo) {
            Log.v(TAG, "preparePlayerAndDrm_V3: onDrmInfo" + drmInfo);
            // DRM preperation
            List<UUID> supportedSchemes = drmInfo.getSupportedSchemes();
            if (supportedSchemes.isEmpty()) {
                Log.e(TAG, "preparePlayerAndDrm_V3: onDrmInfo: No supportedSchemes");
                asyncSetupDrmError.set(true);
                mOnDrmInfoCalled.signal();
                // we won't call prepareDrm anymore but need to get passed the wait
                mOnDrmPreparedCalled.signal();
                return;
            }
            // setting up with the first supported UUID
            // instead of supportedSchemes[0] in GTS
            UUID drmScheme = CLEARKEY_SCHEME_UUID;
            Log.d(TAG, "preparePlayerAndDrm_V3: onDrmInfo: selected " + drmScheme);
            Log.v(TAG, "preparePlayerAndDrm_V3: onDrmInfo: calling prepareDrm");
            final ListenableFuture<DrmResult> future = mp.prepareDrm(drmScheme);
            Log.v(TAG, "preparePlayerAndDrm_V3: onDrmInfo: called prepareDrm");
            future.addListener(new Runnable() {

                @Override
                public void run() {
                    try {
                        DrmResult result = future.get();
                        Log.v(TAG, "preparePlayerAndDrm_V3: prepareDrm status: " + result.getResultCode());
                        assertTrue("preparePlayerAndDrm_V3: onDrmPrepared did not succeed", result.getResultCode() == DrmResult.RESULT_CODE_SUCCESS);
                        DrmInfo drmInfo = mPlayer.getDrmInfo();
                        // in the callback (async mode) so handling exceptions here
                        try {
                            setupDrm(drmInfo, false, /* prepareDrm */
                            true, /* synchronousNetworking */
                            MediaDrm.KEY_TYPE_STREAMING);
                        } catch (Exception e) {
                            Log.v(TAG, "preparePlayerAndDrm_V3: setupDrm EXCEPTION ", e);
                            asyncSetupDrmError.set(true);
                        }
                        mOnDrmPreparedCalled.signal();
                        Log.v(TAG, "preparePlayerAndDrm_V3: onDrmPrepared done!");
                    } catch (ExecutionException | InterruptedException e) {
                        Log.e(TAG, "preparePlayerAndDrm_V3: onDrmInfo: prepareDrm exception ", e);
                        asyncSetupDrmError.set(true);
                        mOnDrmInfoCalled.signal();
                        // need to get passed the wait
                        mOnDrmPreparedCalled.signal();
                    }
                }
            }, mExecutor);
            mOnDrmInfoCalled.signal();
            Log.v(TAG, "preparePlayerAndDrm_V3: onDrmInfo done!");
        }
    });
    Log.v(TAG, "preparePlayerAndDrm_V3: calling prepare()");
    ListenableFuture<PlayerResult> future = mPlayer.prepare();
    assertEquals(PlayerResult.RESULT_CODE_SUCCESS, future.get().getResultCode());
    // Unlike v3, onDrmPrepared is not synced to onPrepared b/c of its own thread handler
    mOnDrmPreparedCalled.waitForSignal();
    // to handle setupDrm error (async) in the main thread rather than the callback
    if (asyncSetupDrmError.get()) {
        fail("preparePlayerAndDrm_V3: setupDrm");
    }
}
#end_block

#method_before
private void playLoadedModularDrmVideo_V4_offlineKey(final Uri file, final Integer width, final Integer height, int playTime) throws Exception {
    final float volume = 0.5f;
    mAudioOnly = (width == 0);
    SurfaceHolder surfaceHolder = mActivity.getSurfaceHolder();
    Log.v(TAG, "playLoadedModularDrmVideo_V4_offlineKey: setSurface " + surfaceHolder);
    mPlayer.setSurface(surfaceHolder.getSurface());
    surfaceHolder.setKeepScreenOn(true);
    DrmInfo drmInfo = null;
    for (int round = 0; round < 2; round++) {
        boolean keyRequestRound = (round == 0);
        boolean restoreRound = (round == 1);
        Log.v(TAG, "playLoadedVideo: round " + round);
        try {
            mPlayer.registerPlayerCallback(mExecutor, mECb);
            Log.v(TAG, "playLoadedVideo: setMediaItem()");
            mPlayer.setMediaItem(new UriMediaItem2.Builder(mContext, file).build());
            Log.v(TAG, "playLoadedVideo: prepare()");
            ListenableFuture<PlayerResult> future = mPlayer.prepare();
            assertEquals(PlayerResult.RESULT_CODE_SUCCESS, future.get().getResultCode());
            // but preparing the DRM every time with proper key request type
            drmInfo = mPlayer.getDrmInfo();
            if (drmInfo != null) {
                if (keyRequestRound) {
                    // asking for offline keys
                    setupDrm(drmInfo, true, /* prepareDrm */
                    true, /* synchronousNetworking */
                    MediaDrm.KEY_TYPE_OFFLINE);
                } else if (restoreRound) {
                    setupDrmRestore(drmInfo, true);
                } else {
                    fail("preparePlayer: unexpected round " + round);
                }
                Log.v(TAG, "preparePlayer: setupDrm done!");
            }
        } catch (IOException e) {
            e.printStackTrace();
            throw new PrepareFailedException();
        }
        Log.v(TAG, "playLoadedVideo: play()");
        mPlayer.play();
        if (!mAudioOnly) {
            mOnVideoSizeChangedCalled.waitForSignal();
        }
        mPlayer.setPlayerVolume(volume);
        // waiting to complete
        if (playTime == 0) {
            Log.v(TAG, "playLoadedVideo: waiting for playback completion");
            mOnPlaybackCompleted.waitForSignal();
        } else {
            Log.v(TAG, "playLoadedVideo: waiting while playing for " + playTime);
            mOnPlaybackCompleted.waitForSignal(playTime);
        }
        try {
            if (drmInfo != null) {
                if (restoreRound) {
                    // releasing the offline key
                    setupDrm(null, /* drmInfo */
                    false, /* prepareDrm */
                    true, /* synchronousNetworking */
                    MediaDrm.KEY_TYPE_RELEASE);
                    Log.v(TAG, "playLoadedVideo: released offline keys");
                }
                Log.v(TAG, "playLoadedVideo: releaseDrm");
                mPlayer.releaseDrm();
            }
        } catch (Exception e) {
            e.printStackTrace();
            throw new PrepareFailedException();
        }
        if (keyRequestRound) {
            mOnVideoSizeChangedCalled.reset();
            mOnPlaybackCompleted.reset();
            final int sleepBetweenRounds = 1000;
            Thread.sleep(sleepBetweenRounds);
            Log.v(TAG, "playLoadedVideo: reset");
            mPlayer.reset();
        }
    }
// for
}
#method_after
private void playLoadedModularDrmVideo_V4_offlineKey(final Uri file, final Integer width, final Integer height, int playTime) throws Exception {
    final float volume = 0.5f;
    mAudioOnly = (width == 0);
    SurfaceHolder surfaceHolder = mActivity.getSurfaceHolder();
    Log.v(TAG, "playLoadedModularDrmVideo_V4_offlineKey: setSurface " + surfaceHolder);
    mPlayer.setSurface(surfaceHolder.getSurface());
    surfaceHolder.setKeepScreenOn(true);
    DrmInfo drmInfo = null;
    for (int round = 0; round < 2; round++) {
        boolean keyRequestRound = (round == 0);
        boolean restoreRound = (round == 1);
        Log.v(TAG, "playLoadedVideo: round " + round);
        try {
            mPlayer.registerPlayerCallback(mExecutor, mECb);
            Log.v(TAG, "playLoadedVideo: setMediaItem()");
            mPlayer.setMediaItem(new UriMediaItem.Builder(mContext, file).build());
            Log.v(TAG, "playLoadedVideo: prepare()");
            ListenableFuture<PlayerResult> future = mPlayer.prepare();
            assertEquals(PlayerResult.RESULT_CODE_SUCCESS, future.get().getResultCode());
            // but preparing the DRM every time with proper key request type
            drmInfo = mPlayer.getDrmInfo();
            if (drmInfo != null) {
                if (keyRequestRound) {
                    // asking for offline keys
                    setupDrm(drmInfo, true, /* prepareDrm */
                    true, /* synchronousNetworking */
                    MediaDrm.KEY_TYPE_OFFLINE);
                } else if (restoreRound) {
                    setupDrmRestore(drmInfo, true);
                } else {
                    fail("preparePlayer: unexpected round " + round);
                }
                Log.v(TAG, "preparePlayer: setupDrm done!");
            }
        } catch (IOException e) {
            e.printStackTrace();
            throw new PrepareFailedException();
        }
        Log.v(TAG, "playLoadedVideo: play()");
        mPlayer.play();
        if (!mAudioOnly) {
            mOnVideoSizeChangedCalled.waitForSignal();
        }
        mPlayer.setPlayerVolume(volume);
        // waiting to complete
        if (playTime == 0) {
            Log.v(TAG, "playLoadedVideo: waiting for playback completion");
            mOnPlaybackCompleted.waitForSignal();
        } else {
            Log.v(TAG, "playLoadedVideo: waiting while playing for " + playTime);
            mOnPlaybackCompleted.waitForSignal(playTime);
        }
        try {
            if (drmInfo != null) {
                if (restoreRound) {
                    // releasing the offline key
                    setupDrm(null, /* drmInfo */
                    false, /* prepareDrm */
                    true, /* synchronousNetworking */
                    MediaDrm.KEY_TYPE_RELEASE);
                    Log.v(TAG, "playLoadedVideo: released offline keys");
                }
                Log.v(TAG, "playLoadedVideo: releaseDrm");
                mPlayer.releaseDrm();
            }
        } catch (Exception e) {
            e.printStackTrace();
            throw new PrepareFailedException();
        }
        if (keyRequestRound) {
            mOnVideoSizeChangedCalled.reset();
            mOnPlaybackCompleted.reset();
            final int sleepBetweenRounds = 1000;
            Thread.sleep(sleepBetweenRounds);
            Log.v(TAG, "playLoadedVideo: reset");
            mPlayer.reset();
        }
    }
// for
}
#end_block

#method_before
public void execute() {
    if (!mExecuted && !isCancelled()) {
        mExecuted = true;
        mFutures = onExecute();
        setResultIfFinished();
    }
}
#method_after
public boolean execute() {
    if (!mExecuteCalled && !isCancelled()) {
        mExecuteCalled = true;
        mFutures = onExecute();
    }
    if (!isCancelled() && !isDone()) {
        setResultIfFinished();
    }
    return isCancelled() || isDone();
}
#end_block

#method_before
public boolean setResultIfFinished() {
    V result = null;
    for (int i = 0; i < mFutures.size(); ++i) {
        ResolvableFuture<V> future = mFutures.get(i);
        if (!future.isDone() && !future.isCancelled()) {
            return false;
        }
        try {
            result = future.get();
            int resultCode = result.getResultCode();
            if (resultCode != RESULT_CODE_SUCCESS && resultCode != RESULT_CODE_SKIPPED) {
                cancelFutures();
                set(result);
                return true;
            }
        } catch (Exception e) {
            cancelFutures();
            setException(e);
            return true;
        }
    }
    try {
        set(result);
    } catch (Exception e) {
        setException(e);
    }
    return true;
}
#method_after
private void setResultIfFinished() {
    V result = null;
    for (int i = 0; i < mFutures.size(); ++i) {
        ResolvableFuture<V> future = mFutures.get(i);
        if (!future.isDone() && !future.isCancelled()) {
            return;
        }
        try {
            result = future.get();
            int resultCode = result.getResultCode();
            if (resultCode != RESULT_CODE_SUCCESS && resultCode != RESULT_CODE_SKIPPED) {
                cancelFutures();
                set(result);
                return;
            }
        } catch (Exception e) {
            cancelFutures();
            setException(e);
            return;
        }
    }
    try {
        set(result);
    } catch (Exception e) {
        setException(e);
    }
}
#end_block

#method_before
private void cancelFutures() {
    for (ResolvableFuture<V> future : mFutures) {
        if (!future.isCancelled() && !future.isDone()) {
            future.cancel(true);
        }
    }
}
#method_after
@SuppressWarnings("WeakerAccess")
/* synthetic access */
void cancelFutures() {
    for (ResolvableFuture<V> future : mFutures) {
        if (!future.isCancelled() && !future.isDone()) {
            future.cancel(true);
        }
    }
}
#end_block

#method_before
private void addPendingFuture(final PendingFuture pendingFuture) {
    synchronized (mPendingFutures) {
        pendingFuture.addListener(new Runnable() {

            @Override
            public void run() {
                if (pendingFuture.isCancelled() && pendingFuture.mExecuted) {
                    for (Object f : pendingFuture.mFutures) {
                        ResolvableFuture future = (ResolvableFuture) f;
                        if (!future.isDone() && !future.isCancelled()) {
                            future.cancel(true);
                        }
                    }
                    pendingFuture.mFutures.clear();
                }
            }
        }, mExecutor);
        mPendingFutures.add(pendingFuture);
        executePendingFuturesIfNeeded();
    }
}
#method_after
private void addPendingFuture(final PendingFuture pendingFuture) {
    synchronized (mPendingFutures) {
        mPendingFutures.add(pendingFuture);
        executePendingFutures();
    }
}
#end_block

#method_before
@Override
@NonNull
public ListenableFuture<PlayerResult> play() {
    PendingFuture<PlayerResult> pendingFuture = new PendingFuture<PlayerResult>() {

        @Override
        List<ResolvableFuture<PlayerResult>> onExecute() {
            ArrayList<ResolvableFuture<PlayerResult>> futures = new ArrayList<>();
            // TODO: Make commands be executed sequentially
            final ResolvableFuture<PlayerResult> future;
            if (mAudioFocusHandler.onPlay()) {
                if (mPlayer.getAudioAttributes() == null) {
                    futures.add(setPlayerVolumeInternal(0f));
                }
                future = ResolvableFuture.create();
                synchronized (mPendingCommands) {
                    Object token = mPlayer.play();
                    addPendingCommandLocked(MediaPlayer2.CALL_COMPLETED_PLAY, future, token);
                }
            } else {
                future = createFutureForResultCode(RESULT_CODE_UNKNOWN_ERROR);
            }
            futures.add(future);
            return futures;
        }
    };
    addPendingFuture(pendingFuture);
    return pendingFuture;
}
#method_after
@Override
@NonNull
public ListenableFuture<PlayerResult> play() {
    PendingFuture<PlayerResult> pendingFuture = new PendingFuture<PlayerResult>(mExecutor) {

        @Override
        List<ResolvableFuture<PlayerResult>> onExecute() {
            ArrayList<ResolvableFuture<PlayerResult>> futures = new ArrayList<>();
            final ResolvableFuture<PlayerResult> future;
            if (mAudioFocusHandler.onPlay()) {
                if (mPlayer.getAudioAttributes() == null) {
                    futures.add(setPlayerVolumeInternal(0f));
                }
                future = ResolvableFuture.create();
                synchronized (mPendingCommands) {
                    Object token = mPlayer.play();
                    addPendingCommandLocked(MediaPlayer2.CALL_COMPLETED_PLAY, future, token);
                }
            } else {
                future = createFutureForResultCode(RESULT_CODE_UNKNOWN_ERROR);
            }
            futures.add(future);
            return futures;
        }
    };
    addPendingFuture(pendingFuture);
    return pendingFuture;
}
#end_block

#method_before
@Override
@NonNull
public ListenableFuture<PlayerResult> pause() {
    PendingFuture<PlayerResult> pendingFuture = new PendingFuture<PlayerResult>() {

        @Override
        List<ResolvableFuture<PlayerResult>> onExecute() {
            ArrayList<ResolvableFuture<PlayerResult>> futures = new ArrayList<>();
            ResolvableFuture<PlayerResult> future = ResolvableFuture.create();
            // TODO: Make commands be executed sequentially
            mAudioFocusHandler.onPause();
            synchronized (mPendingCommands) {
                Object token = mPlayer.pause();
                addPendingCommandLocked(MediaPlayer2.CALL_COMPLETED_PAUSE, future, token);
            }
            futures.add(future);
            return futures;
        }
    };
    addPendingFuture(pendingFuture);
    return pendingFuture;
}
#method_after
@Override
@NonNull
public ListenableFuture<PlayerResult> pause() {
    PendingFuture<PlayerResult> pendingFuture = new PendingFuture<PlayerResult>(mExecutor) {

        @Override
        List<ResolvableFuture<PlayerResult>> onExecute() {
            ArrayList<ResolvableFuture<PlayerResult>> futures = new ArrayList<>();
            ResolvableFuture<PlayerResult> future = ResolvableFuture.create();
            mAudioFocusHandler.onPause();
            synchronized (mPendingCommands) {
                Object token = mPlayer.pause();
                addPendingCommandLocked(MediaPlayer2.CALL_COMPLETED_PAUSE, future, token);
            }
            futures.add(future);
            return futures;
        }
    };
    addPendingFuture(pendingFuture);
    return pendingFuture;
}
#end_block

#method_before
@Override
@NonNull
public ListenableFuture<PlayerResult> prepare() {
    PendingFuture<PlayerResult> pendingFuture = new PendingFuture<PlayerResult>() {

        @Override
        List<ResolvableFuture<PlayerResult>> onExecute() {
            ArrayList<ResolvableFuture<PlayerResult>> futures = new ArrayList<>();
            ResolvableFuture<PlayerResult> future = ResolvableFuture.create();
            synchronized (mPendingCommands) {
                Object token = mPlayer.prepare();
                addPendingCommandLocked(MediaPlayer2.CALL_COMPLETED_PREPARE, future, token);
            }
            // TODO: Changing buffering state is not correct. Think about changing MP2 event
            // APIs for the initial buffering for prepare case.
            setBufferingState(mPlayer.getCurrentMediaItem(), BUFFERING_STATE_BUFFERING_AND_STARVED);
            futures.add(future);
            return futures;
        }
    };
    addPendingFuture(pendingFuture);
    return pendingFuture;
}
#method_after
@Override
@NonNull
public ListenableFuture<PlayerResult> prepare() {
    PendingFuture<PlayerResult> pendingFuture = new PendingFuture<PlayerResult>(mExecutor) {

        @Override
        List<ResolvableFuture<PlayerResult>> onExecute() {
            ArrayList<ResolvableFuture<PlayerResult>> futures = new ArrayList<>();
            ResolvableFuture<PlayerResult> future = ResolvableFuture.create();
            synchronized (mPendingCommands) {
                Object token = mPlayer.prepare();
                addPendingCommandLocked(MediaPlayer2.CALL_COMPLETED_PREPARE, future, token);
            }
            // TODO: Changing buffering state is not correct. Think about changing MP2 event
            // APIs for the initial buffering for prepare case.
            setBufferingState(mPlayer.getCurrentMediaItem(), BUFFERING_STATE_BUFFERING_AND_STARVED);
            futures.add(future);
            return futures;
        }
    };
    addPendingFuture(pendingFuture);
    return pendingFuture;
}
#end_block

#method_before
@Override
@NonNull
public ListenableFuture<PlayerResult> seekTo(final long position) {
    PendingFuture<PlayerResult> pendingFuture = new PendingFuture<PlayerResult>(true) {

        @Override
        List<ResolvableFuture<PlayerResult>> onExecute() {
            ArrayList<ResolvableFuture<PlayerResult>> futures = new ArrayList<>();
            ResolvableFuture<PlayerResult> future = ResolvableFuture.create();
            synchronized (mPendingCommands) {
                Object token = mPlayer.seekTo(position);
                addPendingCommandLocked(MediaPlayer2.CALL_COMPLETED_SEEK_TO, future, token);
            }
            futures.add(future);
            return futures;
        }
    };
    addPendingFuture(pendingFuture);
    return pendingFuture;
}
#method_after
@Override
@NonNull
public ListenableFuture<PlayerResult> seekTo(final long position) {
    PendingFuture<PlayerResult> pendingFuture = new PendingFuture<PlayerResult>(mExecutor, true) {

        @Override
        List<ResolvableFuture<PlayerResult>> onExecute() {
            ArrayList<ResolvableFuture<PlayerResult>> futures = new ArrayList<>();
            ResolvableFuture<PlayerResult> future = ResolvableFuture.create();
            synchronized (mPendingCommands) {
                Object token = mPlayer.seekTo(position);
                addPendingCommandLocked(MediaPlayer2.CALL_COMPLETED_SEEK_TO, future, token);
            }
            futures.add(future);
            return futures;
        }
    };
    addPendingFuture(pendingFuture);
    return pendingFuture;
}
#end_block

#method_before
@Override
@NonNull
public ListenableFuture<PlayerResult> setPlaybackSpeed(final float playbackSpeed) {
    PendingFuture<PlayerResult> pendingFuture = new PendingFuture<PlayerResult>() {

        @Override
        List<ResolvableFuture<PlayerResult>> onExecute() {
            ArrayList<ResolvableFuture<PlayerResult>> futures = new ArrayList<>();
            ResolvableFuture<PlayerResult> future = ResolvableFuture.create();
            synchronized (mPendingCommands) {
                Object token = mPlayer.setPlaybackParams(new PlaybackParams2.Builder(mPlayer.getPlaybackParams().getPlaybackParams()).setSpeed(playbackSpeed).build());
                addPendingCommandLocked(MediaPlayer2.CALL_COMPLETED_SET_PLAYBACK_PARAMS, future, token);
            }
            futures.add(future);
            return futures;
        }
    };
    addPendingFuture(pendingFuture);
    return pendingFuture;
}
#method_after
@Override
@NonNull
public ListenableFuture<PlayerResult> setPlaybackSpeed(final float playbackSpeed) {
    PendingFuture<PlayerResult> pendingFuture = new PendingFuture<PlayerResult>(mExecutor) {

        @Override
        List<ResolvableFuture<PlayerResult>> onExecute() {
            ArrayList<ResolvableFuture<PlayerResult>> futures = new ArrayList<>();
            ResolvableFuture<PlayerResult> future = ResolvableFuture.create();
            synchronized (mPendingCommands) {
                Object token = mPlayer.setPlaybackParams(new PlaybackParams.Builder(mPlayer.getPlaybackParams().getPlaybackParams()).setSpeed(playbackSpeed).build());
                addPendingCommandLocked(MediaPlayer2.CALL_COMPLETED_SET_PLAYBACK_PARAMS, future, token);
            }
            futures.add(future);
            return futures;
        }
    };
    addPendingFuture(pendingFuture);
    return pendingFuture;
}
#end_block

#method_before
@NonNull
@Override
public ListenableFuture<PlayerResult> setAudioAttributes(@NonNull final AudioAttributesCompat attr) {
    PendingFuture<PlayerResult> pendingFuture = new PendingFuture<PlayerResult>() {

        @Override
        List<ResolvableFuture<PlayerResult>> onExecute() {
            ArrayList<ResolvableFuture<PlayerResult>> futures = new ArrayList<>();
            ResolvableFuture<PlayerResult> future = ResolvableFuture.create();
            synchronized (mPendingCommands) {
                Object token = mPlayer.setAudioAttributes(attr);
                addPendingCommandLocked(MediaPlayer2.CALL_COMPLETED_SET_AUDIO_ATTRIBUTES, future, token);
            }
            futures.add(future);
            return futures;
        }
    };
    addPendingFuture(pendingFuture);
    return pendingFuture;
}
#method_after
@NonNull
@Override
public ListenableFuture<PlayerResult> setAudioAttributes(@NonNull final AudioAttributesCompat attr) {
    PendingFuture<PlayerResult> pendingFuture = new PendingFuture<PlayerResult>(mExecutor) {

        @Override
        List<ResolvableFuture<PlayerResult>> onExecute() {
            ArrayList<ResolvableFuture<PlayerResult>> futures = new ArrayList<>();
            ResolvableFuture<PlayerResult> future = ResolvableFuture.create();
            synchronized (mPendingCommands) {
                Object token = mPlayer.setAudioAttributes(attr);
                addPendingCommandLocked(MediaPlayer2.CALL_COMPLETED_SET_AUDIO_ATTRIBUTES, future, token);
            }
            futures.add(future);
            return futures;
        }
    };
    addPendingFuture(pendingFuture);
    return pendingFuture;
}
#end_block

#method_before
@Override
@NonNull
public ListenableFuture<PlayerResult> setMediaItem(@NonNull final MediaItem2 item) {
    if (item == null) {
        throw new IllegalArgumentException("item shouldn't be null");
    }
    PendingFuture<PlayerResult> pendingFuture = new PendingFuture<PlayerResult>() {

        @Override
        List<ResolvableFuture<PlayerResult>> onExecute() {
            ArrayList<ResolvableFuture<PlayerResult>> futures = new ArrayList<>();
            synchronized (mPlaylistLock) {
                mPlaylist.clear();
                mShuffledList.clear();
                mCurPlaylistItem = item;
                mNextPlaylistItem = null;
                mCurrentShuffleIdx = END_OF_PLAYLIST;
            }
            futures.addAll(setMediaItemsInternal(item, null));
            return futures;
        }
    };
    addPendingFuture(pendingFuture);
    return pendingFuture;
}
#method_after
@Override
@NonNull
public ListenableFuture<PlayerResult> setMediaItem(@NonNull final MediaItem item) {
    if (item == null) {
        throw new IllegalArgumentException("item shouldn't be null");
    }
    PendingFuture<PlayerResult> pendingFuture = new PendingFuture<PlayerResult>(mExecutor) {

        @Override
        List<ResolvableFuture<PlayerResult>> onExecute() {
            ArrayList<ResolvableFuture<PlayerResult>> futures = new ArrayList<>();
            synchronized (mPlaylistLock) {
                mPlaylist.clear();
                mShuffledList.clear();
                mCurPlaylistItem = item;
                mNextPlaylistItem = null;
                mCurrentShuffleIdx = END_OF_PLAYLIST;
            }
            futures.addAll(setMediaItemsInternal(item, null));
            return futures;
        }
    };
    addPendingFuture(pendingFuture);
    return pendingFuture;
}
#end_block

#method_before
@NonNull
@Override
public ListenableFuture<PlayerResult> setPlaylist(@NonNull final List<MediaItem2> playlist, @Nullable final MediaMetadata2 metadata) {
    if (playlist == null || playlist.isEmpty()) {
        throw new IllegalArgumentException("playlist shouldn't be null or empty");
    }
    for (MediaItem2 item : playlist) {
        if (item == null) {
            throw new IllegalArgumentException("playlist shouldn't contain null item");
        }
    }
    PendingFuture<PlayerResult> pendingFuture = new PendingFuture<PlayerResult>() {

        @Override
        List<ResolvableFuture<PlayerResult>> onExecute() {
            MediaItem2 curItem;
            MediaItem2 nextItem;
            synchronized (mPlaylistLock) {
                mPlaylistMetadata = metadata;
                mPlaylist.clear();
                mShuffledList.clear();
                mPlaylist.addAll(playlist);
                applyShuffleModeLocked();
                mCurrentShuffleIdx = 0;
                updateAndGetCurrentNextItemIfNeededLocked();
                curItem = mCurPlaylistItem;
                nextItem = mNextPlaylistItem;
            }
            notifySessionPlayerCallback(new SessionPlayerCallbackNotifier() {

                @Override
                public void callCallback(SessionPlayer2.PlayerCallback callback) {
                    callback.onPlaylistChanged(MediaPlayer.this, playlist, metadata);
                }
            });
            if (curItem != null) {
                return setMediaItemsInternal(curItem, nextItem);
            }
            return createFuturesForResultCode(RESULT_CODE_SUCCESS);
        }
    };
    addPendingFuture(pendingFuture);
    return pendingFuture;
}
#method_after
@NonNull
@Override
public ListenableFuture<PlayerResult> setPlaylist(@NonNull final List<MediaItem> playlist, @Nullable final MediaMetadata metadata) {
    if (playlist == null || playlist.isEmpty()) {
        throw new IllegalArgumentException("playlist shouldn't be null or empty");
    }
    for (MediaItem item : playlist) {
        if (item == null) {
            throw new IllegalArgumentException("playlist shouldn't contain null item");
        }
    }
    PendingFuture<PlayerResult> pendingFuture = new PendingFuture<PlayerResult>(mExecutor) {

        @Override
        List<ResolvableFuture<PlayerResult>> onExecute() {
            MediaItem curItem;
            MediaItem nextItem;
            synchronized (mPlaylistLock) {
                mPlaylistMetadata = metadata;
                mPlaylist.clear();
                mShuffledList.clear();
                mPlaylist.addAll(playlist);
                applyShuffleModeLocked();
                mCurrentShuffleIdx = 0;
                updateAndGetCurrentNextItemIfNeededLocked();
                curItem = mCurPlaylistItem;
                nextItem = mNextPlaylistItem;
            }
            notifySessionPlayerCallback(new SessionPlayerCallbackNotifier() {

                @Override
                public void callCallback(SessionPlayer.PlayerCallback callback) {
                    callback.onPlaylistChanged(MediaPlayer.this, playlist, metadata);
                }
            });
            if (curItem != null) {
                return setMediaItemsInternal(curItem, nextItem);
            }
            return createFuturesForResultCode(RESULT_CODE_SUCCESS);
        }
    };
    addPendingFuture(pendingFuture);
    return pendingFuture;
}
#end_block

#method_before
@NonNull
@Override
public ListenableFuture<PlayerResult> addPlaylistItem(final int index, @NonNull final MediaItem2 item) {
    if (item == null) {
        throw new IllegalArgumentException("item shouldn't be null");
    }
    if (index < 0) {
        throw new IllegalArgumentException("index shouldn't be negative integer");
    }
    synchronized (mPlaylistLock) {
        if (mPlaylist.contains(item)) {
            throw new IllegalStateException("The item is already in the playlist: " + item);
        }
    }
    PendingFuture<PlayerResult> pendingFuture = new PendingFuture<PlayerResult>() {

        @Override
        List<ResolvableFuture<PlayerResult>> onExecute() {
            Pair<MediaItem2, MediaItem2> updatedCurNextItem;
            synchronized (mPlaylistLock) {
                int clampedIndex = clamp(index, mPlaylist.size());
                int addedShuffleIdx = clampedIndex;
                mPlaylist.add(clampedIndex, item);
                if (mShuffleMode == SessionPlayer2.SHUFFLE_MODE_NONE) {
                    mShuffledList.add(clampedIndex, item);
                } else {
                    // Add the item in random position of mShuffledList.
                    addedShuffleIdx = (int) (Math.random() * (mShuffledList.size() + 1));
                    mShuffledList.add(addedShuffleIdx, item);
                }
                if (addedShuffleIdx <= mCurrentShuffleIdx) {
                    mCurrentShuffleIdx++;
                }
                updatedCurNextItem = updateAndGetCurrentNextItemIfNeededLocked();
            }
            final List<MediaItem2> playlist = getPlaylist();
            final MediaMetadata2 metadata = getPlaylistMetadata();
            notifySessionPlayerCallback(new SessionPlayerCallbackNotifier() {

                @Override
                public void callCallback(SessionPlayer2.PlayerCallback callback) {
                    callback.onPlaylistChanged(MediaPlayer.this, playlist, metadata);
                }
            });
            if (updatedCurNextItem.second == null) {
                return createFuturesForResultCode(RESULT_CODE_SUCCESS);
            }
            ArrayList<ResolvableFuture<PlayerResult>> futures = new ArrayList<>();
            futures.add(setNextMediaItemInternal(updatedCurNextItem.second));
            return futures;
        }
    };
    addPendingFuture(pendingFuture);
    return pendingFuture;
}
#method_after
@NonNull
@Override
public ListenableFuture<PlayerResult> addPlaylistItem(final int index, @NonNull final MediaItem item) {
    if (item == null) {
        throw new IllegalArgumentException("item shouldn't be null");
    }
    if (index < 0) {
        throw new IllegalArgumentException("index shouldn't be negative integer");
    }
    PendingFuture<PlayerResult> pendingFuture = new PendingFuture<PlayerResult>(mExecutor) {

        @Override
        List<ResolvableFuture<PlayerResult>> onExecute() {
            Pair<MediaItem, MediaItem> updatedCurNextItem;
            synchronized (mPlaylistLock) {
                if (mPlaylist.contains(item)) {
                    return createFuturesForResultCode(RESULT_CODE_BAD_VALUE, item);
                }
                int clampedIndex = clamp(index, mPlaylist.size());
                int addedShuffleIdx = clampedIndex;
                mPlaylist.add(clampedIndex, item);
                if (mShuffleMode == SessionPlayer.SHUFFLE_MODE_NONE) {
                    mShuffledList.add(clampedIndex, item);
                } else {
                    // Add the item in random position of mShuffledList.
                    addedShuffleIdx = (int) (Math.random() * (mShuffledList.size() + 1));
                    mShuffledList.add(addedShuffleIdx, item);
                }
                if (addedShuffleIdx <= mCurrentShuffleIdx) {
                    mCurrentShuffleIdx++;
                }
                updatedCurNextItem = updateAndGetCurrentNextItemIfNeededLocked();
            }
            final List<MediaItem> playlist = getPlaylist();
            final MediaMetadata metadata = getPlaylistMetadata();
            notifySessionPlayerCallback(new SessionPlayerCallbackNotifier() {

                @Override
                public void callCallback(SessionPlayer.PlayerCallback callback) {
                    callback.onPlaylistChanged(MediaPlayer.this, playlist, metadata);
                }
            });
            if (updatedCurNextItem.second == null) {
                return createFuturesForResultCode(RESULT_CODE_SUCCESS);
            }
            ArrayList<ResolvableFuture<PlayerResult>> futures = new ArrayList<>();
            futures.add(setNextMediaItemInternal(updatedCurNextItem.second));
            return futures;
        }
    };
    addPendingFuture(pendingFuture);
    return pendingFuture;
}
#end_block

#method_before
@Override
@NonNull
public ListenableFuture<PlayerResult> removePlaylistItem(@NonNull final MediaItem2 item) {
    if (item == null) {
        throw new IllegalArgumentException("item shouldn't be null");
    }
    PendingFuture<PlayerResult> pendingFuture = new PendingFuture<PlayerResult>() {

        @Override
        List<ResolvableFuture<PlayerResult>> onExecute() {
            int removedItemShuffleIdx;
            MediaItem2 curItem;
            MediaItem2 nextItem;
            Pair<MediaItem2, MediaItem2> updatedCurNextItem = null;
            synchronized (mPlaylistLock) {
                removedItemShuffleIdx = mShuffledList.indexOf(item);
                if (removedItemShuffleIdx >= 0) {
                    mPlaylist.remove(item);
                    mShuffledList.remove(removedItemShuffleIdx);
                    if (removedItemShuffleIdx < mCurrentShuffleIdx) {
                        mCurrentShuffleIdx--;
                    }
                    updatedCurNextItem = updateAndGetCurrentNextItemIfNeededLocked();
                }
                curItem = mCurPlaylistItem;
                nextItem = mNextPlaylistItem;
            }
            if (removedItemShuffleIdx >= 0) {
                final List<MediaItem2> playlist = getPlaylist();
                final MediaMetadata2 metadata = getPlaylistMetadata();
                notifySessionPlayerCallback(new SessionPlayerCallbackNotifier() {

                    @Override
                    public void callCallback(SessionPlayer2.PlayerCallback callback) {
                        callback.onPlaylistChanged(MediaPlayer.this, playlist, metadata);
                    }
                });
            }
            ArrayList<ResolvableFuture<PlayerResult>> futures = new ArrayList<>();
            if (updatedCurNextItem != null) {
                if (updatedCurNextItem.first != null) {
                    futures.addAll(setMediaItemsInternal(curItem, nextItem));
                } else if (updatedCurNextItem.second != null) {
                    futures.add(setNextMediaItemInternal(nextItem));
                }
            } else {
                futures.add(createFutureForResultCode(RESULT_CODE_SUCCESS));
            }
            return futures;
        }
    };
    addPendingFuture(pendingFuture);
    return pendingFuture;
}
#method_after
@Override
@NonNull
public ListenableFuture<PlayerResult> removePlaylistItem(@NonNull final MediaItem item) {
    if (item == null) {
        throw new IllegalArgumentException("item shouldn't be null");
    }
    PendingFuture<PlayerResult> pendingFuture = new PendingFuture<PlayerResult>(mExecutor) {

        @Override
        List<ResolvableFuture<PlayerResult>> onExecute() {
            int removedItemShuffleIdx;
            MediaItem curItem;
            MediaItem nextItem;
            Pair<MediaItem, MediaItem> updatedCurNextItem = null;
            synchronized (mPlaylistLock) {
                removedItemShuffleIdx = mShuffledList.indexOf(item);
                if (removedItemShuffleIdx >= 0) {
                    mPlaylist.remove(item);
                    mShuffledList.remove(removedItemShuffleIdx);
                    if (removedItemShuffleIdx < mCurrentShuffleIdx) {
                        mCurrentShuffleIdx--;
                    }
                    updatedCurNextItem = updateAndGetCurrentNextItemIfNeededLocked();
                }
                curItem = mCurPlaylistItem;
                nextItem = mNextPlaylistItem;
            }
            if (removedItemShuffleIdx >= 0) {
                final List<MediaItem> playlist = getPlaylist();
                final MediaMetadata metadata = getPlaylistMetadata();
                notifySessionPlayerCallback(new SessionPlayerCallbackNotifier() {

                    @Override
                    public void callCallback(SessionPlayer.PlayerCallback callback) {
                        callback.onPlaylistChanged(MediaPlayer.this, playlist, metadata);
                    }
                });
            }
            ArrayList<ResolvableFuture<PlayerResult>> futures = new ArrayList<>();
            if (updatedCurNextItem != null) {
                if (updatedCurNextItem.first != null) {
                    futures.addAll(setMediaItemsInternal(curItem, nextItem));
                } else if (updatedCurNextItem.second != null) {
                    futures.add(setNextMediaItemInternal(nextItem));
                }
            } else {
                futures.add(createFutureForResultCode(RESULT_CODE_SUCCESS));
            }
            return futures;
        }
    };
    addPendingFuture(pendingFuture);
    return pendingFuture;
}
#end_block

#method_before
@NonNull
@Override
public ListenableFuture<PlayerResult> replacePlaylistItem(final int index, @NonNull final MediaItem2 item) {
    if (item == null) {
        throw new IllegalArgumentException("item shouldn't be null");
    }
    if (index < 0) {
        throw new IllegalArgumentException("index shouldn't be negative integer");
    }
    synchronized (mPlaylistLock) {
        int itemIdx = mPlaylist.indexOf(item);
        if (itemIdx >= 0 && index == itemIdx) {
            throw new IllegalStateException("The item is already in the playlist: " + item);
        }
    }
    PendingFuture<PlayerResult> pendingFuture = new PendingFuture<PlayerResult>() {

        @Override
        List<ResolvableFuture<PlayerResult>> onExecute() {
            MediaItem2 curItem;
            MediaItem2 nextItem;
            Pair<MediaItem2, MediaItem2> updatedCurNextItem = null;
            synchronized (mPlaylistLock) {
                if (index >= mPlaylist.size()) {
                    return createFuturesForResultCode(RESULT_CODE_BAD_VALUE);
                }
                int shuffleIdx = mShuffledList.indexOf(mPlaylist.get(index));
                mShuffledList.set(shuffleIdx, item);
                mPlaylist.set(index, item);
                updatedCurNextItem = updateAndGetCurrentNextItemIfNeededLocked();
                curItem = mCurPlaylistItem;
                nextItem = mNextPlaylistItem;
            }
            // TODO: Should we notify current media item changed if it is replaced?
            final List<MediaItem2> playlist = getPlaylist();
            final MediaMetadata2 metadata = getPlaylistMetadata();
            notifySessionPlayerCallback(new SessionPlayerCallbackNotifier() {

                @Override
                public void callCallback(SessionPlayer2.PlayerCallback callback) {
                    callback.onPlaylistChanged(MediaPlayer.this, playlist, metadata);
                }
            });
            ArrayList<ResolvableFuture<PlayerResult>> futures = new ArrayList<>();
            if (updatedCurNextItem != null) {
                if (updatedCurNextItem.first != null) {
                    futures.addAll(setMediaItemsInternal(curItem, nextItem));
                } else if (updatedCurNextItem.second != null) {
                    futures.add(setNextMediaItemInternal(nextItem));
                }
            } else {
                futures.add(createFutureForResultCode(RESULT_CODE_SUCCESS));
            }
            return futures;
        }
    };
    addPendingFuture(pendingFuture);
    return pendingFuture;
}
#method_after
@NonNull
@Override
public ListenableFuture<PlayerResult> replacePlaylistItem(final int index, @NonNull final MediaItem item) {
    if (item == null) {
        throw new IllegalArgumentException("item shouldn't be null");
    }
    if (index < 0) {
        throw new IllegalArgumentException("index shouldn't be negative integer");
    }
    PendingFuture<PlayerResult> pendingFuture = new PendingFuture<PlayerResult>(mExecutor) {

        @Override
        List<ResolvableFuture<PlayerResult>> onExecute() {
            MediaItem curItem;
            MediaItem nextItem;
            Pair<MediaItem, MediaItem> updatedCurNextItem = null;
            synchronized (mPlaylistLock) {
                if (index >= mPlaylist.size() || mPlaylist.contains(item)) {
                    return createFuturesForResultCode(RESULT_CODE_BAD_VALUE, item);
                }
                int shuffleIdx = mShuffledList.indexOf(mPlaylist.get(index));
                mShuffledList.set(shuffleIdx, item);
                mPlaylist.set(index, item);
                updatedCurNextItem = updateAndGetCurrentNextItemIfNeededLocked();
                curItem = mCurPlaylistItem;
                nextItem = mNextPlaylistItem;
            }
            // TODO: Should we notify current media item changed if it is replaced?
            final List<MediaItem> playlist = getPlaylist();
            final MediaMetadata metadata = getPlaylistMetadata();
            notifySessionPlayerCallback(new SessionPlayerCallbackNotifier() {

                @Override
                public void callCallback(SessionPlayer.PlayerCallback callback) {
                    callback.onPlaylistChanged(MediaPlayer.this, playlist, metadata);
                }
            });
            ArrayList<ResolvableFuture<PlayerResult>> futures = new ArrayList<>();
            if (updatedCurNextItem != null) {
                if (updatedCurNextItem.first != null) {
                    futures.addAll(setMediaItemsInternal(curItem, nextItem));
                } else if (updatedCurNextItem.second != null) {
                    futures.add(setNextMediaItemInternal(nextItem));
                }
            } else {
                futures.add(createFutureForResultCode(RESULT_CODE_SUCCESS));
            }
            return futures;
        }
    };
    addPendingFuture(pendingFuture);
    return pendingFuture;
}
#end_block

#method_before
@Override
@NonNull
public ListenableFuture<PlayerResult> skipToPreviousPlaylistItem() {
    PendingFuture<PlayerResult> pendingFuture = new PendingFuture<PlayerResult>() {

        @Override
        List<ResolvableFuture<PlayerResult>> onExecute() {
            MediaItem2 curItem;
            MediaItem2 nextItem;
            synchronized (mPlaylistLock) {
                int prevShuffleIdx = mCurrentShuffleIdx - 1;
                if (prevShuffleIdx < 0) {
                    if (mRepeatMode == REPEAT_MODE_ALL || mRepeatMode == REPEAT_MODE_GROUP) {
                        prevShuffleIdx = mShuffledList.size() - 1;
                    } else {
                        return createFuturesForResultCode(RESULT_CODE_INVALID_STATE);
                    }
                }
                mCurrentShuffleIdx = prevShuffleIdx;
                updateAndGetCurrentNextItemIfNeededLocked();
                curItem = mCurPlaylistItem;
                nextItem = mNextPlaylistItem;
            }
            return setMediaItemsInternal(curItem, nextItem);
        }
    };
    addPendingFuture(pendingFuture);
    return pendingFuture;
}
#method_after
@Override
@NonNull
public ListenableFuture<PlayerResult> skipToPreviousPlaylistItem() {
    PendingFuture<PlayerResult> pendingFuture = new PendingFuture<PlayerResult>(mExecutor) {

        @Override
        List<ResolvableFuture<PlayerResult>> onExecute() {
            MediaItem curItem;
            MediaItem nextItem;
            synchronized (mPlaylistLock) {
                int prevShuffleIdx = mCurrentShuffleIdx - 1;
                if (prevShuffleIdx < 0) {
                    if (mRepeatMode == REPEAT_MODE_ALL || mRepeatMode == REPEAT_MODE_GROUP) {
                        prevShuffleIdx = mShuffledList.size() - 1;
                    } else {
                        return createFuturesForResultCode(RESULT_CODE_INVALID_STATE);
                    }
                }
                mCurrentShuffleIdx = prevShuffleIdx;
                updateAndGetCurrentNextItemIfNeededLocked();
                curItem = mCurPlaylistItem;
                nextItem = mNextPlaylistItem;
            }
            return setMediaItemsInternal(curItem, nextItem);
        }
    };
    addPendingFuture(pendingFuture);
    return pendingFuture;
}
#end_block

#method_before
@Override
@NonNull
public ListenableFuture<PlayerResult> skipToNextPlaylistItem() {
    PendingFuture<PlayerResult> pendingFuture = new PendingFuture<PlayerResult>() {

        @Override
        List<ResolvableFuture<PlayerResult>> onExecute() {
            MediaItem2 curItem;
            MediaItem2 nextItem;
            synchronized (mPlaylistLock) {
                int nextShuffleIdx = mCurrentShuffleIdx + 1;
                if (nextShuffleIdx >= mShuffledList.size()) {
                    if (mRepeatMode == REPEAT_MODE_ALL || mRepeatMode == REPEAT_MODE_GROUP) {
                        nextShuffleIdx = 0;
                    } else {
                        return createFuturesForResultCode(RESULT_CODE_INVALID_STATE);
                    }
                }
                mCurrentShuffleIdx = nextShuffleIdx;
                updateAndGetCurrentNextItemIfNeededLocked();
                curItem = mCurPlaylistItem;
                nextItem = mNextPlaylistItem;
            }
            if (curItem != null) {
                return setMediaItemsInternal(curItem, nextItem);
            }
            ArrayList<ResolvableFuture<PlayerResult>> futures = new ArrayList<>();
            futures.add(skipToNextInternal());
            return futures;
        }
    };
    addPendingFuture(pendingFuture);
    return pendingFuture;
}
#method_after
@Override
@NonNull
public ListenableFuture<PlayerResult> skipToNextPlaylistItem() {
    PendingFuture<PlayerResult> pendingFuture = new PendingFuture<PlayerResult>(mExecutor) {

        @Override
        List<ResolvableFuture<PlayerResult>> onExecute() {
            MediaItem curItem;
            MediaItem nextItem;
            synchronized (mPlaylistLock) {
                int nextShuffleIdx = mCurrentShuffleIdx + 1;
                if (nextShuffleIdx >= mShuffledList.size()) {
                    if (mRepeatMode == REPEAT_MODE_ALL || mRepeatMode == REPEAT_MODE_GROUP) {
                        nextShuffleIdx = 0;
                    } else {
                        return createFuturesForResultCode(RESULT_CODE_INVALID_STATE);
                    }
                }
                mCurrentShuffleIdx = nextShuffleIdx;
                updateAndGetCurrentNextItemIfNeededLocked();
                curItem = mCurPlaylistItem;
                nextItem = mNextPlaylistItem;
            }
            if (curItem != null) {
                return setMediaItemsInternal(curItem, nextItem);
            }
            ArrayList<ResolvableFuture<PlayerResult>> futures = new ArrayList<>();
            futures.add(skipToNextInternal());
            return futures;
        }
    };
    addPendingFuture(pendingFuture);
    return pendingFuture;
}
#end_block

#method_before
@Override
@NonNull
public ListenableFuture<PlayerResult> skipToPlaylistItem(@NonNull final MediaItem2 item) {
    PendingFuture<PlayerResult> pendingFuture = new PendingFuture<PlayerResult>() {

        @Override
        List<ResolvableFuture<PlayerResult>> onExecute() {
            MediaItem2 curItem;
            MediaItem2 nextItem;
            synchronized (mPlaylistLock) {
                int newShuffleIdx = mShuffledList.indexOf(item);
                if (newShuffleIdx < 0) {
                    return createFuturesForResultCode(RESULT_CODE_BAD_VALUE);
                }
                mCurrentShuffleIdx = newShuffleIdx;
                updateAndGetCurrentNextItemIfNeededLocked();
                curItem = mCurPlaylistItem;
                nextItem = mNextPlaylistItem;
            }
            return setMediaItemsInternal(curItem, nextItem);
        }
    };
    addPendingFuture(pendingFuture);
    return pendingFuture;
}
#method_after
@Override
@NonNull
public ListenableFuture<PlayerResult> skipToPlaylistItem(@NonNull final MediaItem item) {
    PendingFuture<PlayerResult> pendingFuture = new PendingFuture<PlayerResult>(mExecutor) {

        @Override
        List<ResolvableFuture<PlayerResult>> onExecute() {
            MediaItem curItem;
            MediaItem nextItem;
            synchronized (mPlaylistLock) {
                int newShuffleIdx = mShuffledList.indexOf(item);
                if (newShuffleIdx < 0) {
                    return createFuturesForResultCode(RESULT_CODE_BAD_VALUE);
                }
                mCurrentShuffleIdx = newShuffleIdx;
                updateAndGetCurrentNextItemIfNeededLocked();
                curItem = mCurPlaylistItem;
                nextItem = mNextPlaylistItem;
            }
            return setMediaItemsInternal(curItem, nextItem);
        }
    };
    addPendingFuture(pendingFuture);
    return pendingFuture;
}
#end_block

#method_before
@NonNull
@Override
public ListenableFuture<PlayerResult> updatePlaylistMetadata(@Nullable final MediaMetadata2 metadata) {
    PendingFuture<PlayerResult> pendingFuture = new PendingFuture<PlayerResult>() {

        @Override
        List<ResolvableFuture<PlayerResult>> onExecute() {
            synchronized (mPlaylistLock) {
                mPlaylistMetadata = metadata;
            }
            notifySessionPlayerCallback(new SessionPlayerCallbackNotifier() {

                @Override
                public void callCallback(SessionPlayer2.PlayerCallback callback) {
                    callback.onPlaylistMetadataChanged(MediaPlayer.this, metadata);
                }
            });
            return createFuturesForResultCode(RESULT_CODE_SUCCESS);
        }
    };
    addPendingFuture(pendingFuture);
    return pendingFuture;
}
#method_after
@NonNull
@Override
public ListenableFuture<PlayerResult> updatePlaylistMetadata(@Nullable final MediaMetadata metadata) {
    PendingFuture<PlayerResult> pendingFuture = new PendingFuture<PlayerResult>(mExecutor) {

        @Override
        List<ResolvableFuture<PlayerResult>> onExecute() {
            synchronized (mPlaylistLock) {
                mPlaylistMetadata = metadata;
            }
            notifySessionPlayerCallback(new SessionPlayerCallbackNotifier() {

                @Override
                public void callCallback(SessionPlayer.PlayerCallback callback) {
                    callback.onPlaylistMetadataChanged(MediaPlayer.this, metadata);
                }
            });
            return createFuturesForResultCode(RESULT_CODE_SUCCESS);
        }
    };
    addPendingFuture(pendingFuture);
    return pendingFuture;
}
#end_block

#method_before
@Override
@NonNull
public ListenableFuture<PlayerResult> setRepeatMode(final int repeatMode) {
    PendingFuture<PlayerResult> pendingFuture = new PendingFuture<PlayerResult>() {

        @Override
        List<ResolvableFuture<PlayerResult>> onExecute() {
            if (repeatMode < SessionPlayer2.REPEAT_MODE_NONE || repeatMode > SessionPlayer2.REPEAT_MODE_GROUP) {
                return createFuturesForResultCode(RESULT_CODE_BAD_VALUE);
            }
            boolean changed;
            synchronized (mPlaylistLock) {
                changed = mRepeatMode != repeatMode;
                mRepeatMode = repeatMode;
            }
            if (changed) {
                notifySessionPlayerCallback(new SessionPlayerCallbackNotifier() {

                    @Override
                    public void callCallback(SessionPlayer2.PlayerCallback callback) {
                        callback.onRepeatModeChanged(MediaPlayer.this, repeatMode);
                    }
                });
            }
            return createFuturesForResultCode(RESULT_CODE_SUCCESS);
        }
    };
    addPendingFuture(pendingFuture);
    return pendingFuture;
}
#method_after
@Override
@NonNull
public ListenableFuture<PlayerResult> setRepeatMode(final int repeatMode) {
    PendingFuture<PlayerResult> pendingFuture = new PendingFuture<PlayerResult>(mExecutor) {

        @Override
        List<ResolvableFuture<PlayerResult>> onExecute() {
            if (repeatMode < SessionPlayer.REPEAT_MODE_NONE || repeatMode > SessionPlayer.REPEAT_MODE_GROUP) {
                return createFuturesForResultCode(RESULT_CODE_BAD_VALUE);
            }
            boolean changed;
            synchronized (mPlaylistLock) {
                changed = mRepeatMode != repeatMode;
                mRepeatMode = repeatMode;
            }
            if (changed) {
                notifySessionPlayerCallback(new SessionPlayerCallbackNotifier() {

                    @Override
                    public void callCallback(SessionPlayer.PlayerCallback callback) {
                        callback.onRepeatModeChanged(MediaPlayer.this, repeatMode);
                    }
                });
            }
            return createFuturesForResultCode(RESULT_CODE_SUCCESS);
        }
    };
    addPendingFuture(pendingFuture);
    return pendingFuture;
}
#end_block

#method_before
@Override
@NonNull
public ListenableFuture<PlayerResult> setShuffleMode(final int shuffleMode) {
    PendingFuture<PlayerResult> pendingFuture = new PendingFuture<PlayerResult>() {

        @Override
        List<ResolvableFuture<PlayerResult>> onExecute() {
            if (shuffleMode < SessionPlayer2.SHUFFLE_MODE_NONE || shuffleMode > SessionPlayer2.SHUFFLE_MODE_GROUP) {
                return createFuturesForResultCode(RESULT_CODE_BAD_VALUE);
            }
            boolean changed;
            synchronized (mPlaylistLock) {
                changed = mShuffleMode != shuffleMode;
                mShuffleMode = shuffleMode;
            }
            if (changed) {
                notifySessionPlayerCallback(new SessionPlayerCallbackNotifier() {

                    @Override
                    public void callCallback(SessionPlayer2.PlayerCallback callback) {
                        callback.onShuffleModeChanged(MediaPlayer.this, shuffleMode);
                    }
                });
            }
            return createFuturesForResultCode(RESULT_CODE_SUCCESS);
        }
    };
    addPendingFuture(pendingFuture);
    return pendingFuture;
}
#method_after
@Override
@NonNull
public ListenableFuture<PlayerResult> setShuffleMode(final int shuffleMode) {
    PendingFuture<PlayerResult> pendingFuture = new PendingFuture<PlayerResult>(mExecutor) {

        @Override
        List<ResolvableFuture<PlayerResult>> onExecute() {
            if (shuffleMode < SessionPlayer.SHUFFLE_MODE_NONE || shuffleMode > SessionPlayer.SHUFFLE_MODE_GROUP) {
                return createFuturesForResultCode(RESULT_CODE_BAD_VALUE);
            }
            boolean changed;
            synchronized (mPlaylistLock) {
                changed = mShuffleMode != shuffleMode;
                mShuffleMode = shuffleMode;
            }
            if (changed) {
                notifySessionPlayerCallback(new SessionPlayerCallbackNotifier() {

                    @Override
                    public void callCallback(SessionPlayer.PlayerCallback callback) {
                        callback.onShuffleModeChanged(MediaPlayer.this, shuffleMode);
                    }
                });
            }
            return createFuturesForResultCode(RESULT_CODE_SUCCESS);
        }
    };
    addPendingFuture(pendingFuture);
    return pendingFuture;
}
#end_block

#method_before
@Override
@Nullable
public List<MediaItem2> getPlaylist() {
    synchronized (mPlaylistLock) {
        return mPlaylist.isEmpty() ? null : new ArrayList<>(mPlaylist);
    }
}
#method_after
@Override
@Nullable
public List<MediaItem> getPlaylist() {
    synchronized (mPlaylistLock) {
        return mPlaylist.isEmpty() ? null : new ArrayList<>(mPlaylist);
    }
}
#end_block

#method_before
@Override
@Nullable
public MediaMetadata2 getPlaylistMetadata() {
    synchronized (mPlaylistLock) {
        return mPlaylistMetadata;
    }
}
#method_after
@Override
@Nullable
public MediaMetadata getPlaylistMetadata() {
    synchronized (mPlaylistLock) {
        return mPlaylistMetadata;
    }
}
#end_block

#method_before
@Override
@Nullable
public MediaItem2 getCurrentMediaItem() {
    return mPlayer.getCurrentMediaItem();
}
#method_after
@Override
@Nullable
public MediaItem getCurrentMediaItem() {
    return mPlayer.getCurrentMediaItem();
}
#end_block

#method_before
public void reset() {
    // Cancel the pending futures.
    synchronized (mPendingFutures) {
        for (PendingFuture f : mPendingFutures) {
            if (f.mExecuted && !f.isDone() && !f.isCancelled()) {
                f.cancel(true);
            }
        }
        mPendingFutures.clear();
    }
    // Cancel the pending commands.
    synchronized (mPendingCommands) {
        for (PendingCommand c : mPendingCommands) {
            c.mFuture.cancel(true);
        }
        mPendingCommands.clear();
    }
    synchronized (mStateLock) {
        mState = PLAYER_STATE_IDLE;
        mMediaItemToBuffState.clear();
    }
    synchronized (mPlaylistLock) {
        mPlaylist.clear();
        mShuffledList.clear();
        mCurPlaylistItem = null;
        mNextPlaylistItem = null;
        mCurrentShuffleIdx = END_OF_PLAYLIST;
        mSetMediaItemCalled = false;
    }
    mAudioFocusHandler.onReset();
    mPlayer.reset();
}
#method_after
public void reset() {
    // Cancel the pending commands.
    synchronized (mPendingCommands) {
        for (PendingCommand c : mPendingCommands) {
            c.mFuture.cancel(true);
        }
        mPendingCommands.clear();
    }
    // Cancel the pending futures.
    synchronized (mPendingFutures) {
        for (PendingFuture f : mPendingFutures) {
            if (f.mExecuteCalled && !f.isDone() && !f.isCancelled()) {
                f.cancel(true);
            }
        }
        mPendingFutures.clear();
    }
    synchronized (mStateLock) {
        mState = PLAYER_STATE_IDLE;
        mMediaItemToBuffState.clear();
    }
    synchronized (mPlaylistLock) {
        mPlaylist.clear();
        mShuffledList.clear();
        mCurPlaylistItem = null;
        mNextPlaylistItem = null;
        mCurrentShuffleIdx = END_OF_PLAYLIST;
        mSetMediaItemCalled = false;
    }
    mAudioFocusHandler.onReset();
    mPlayer.reset();
}
#end_block

#method_before
@NonNull
public ListenableFuture<PlayerResult> setSurface(@Nullable final Surface surface) {
    PendingFuture<PlayerResult> pendingFuture = new PendingFuture<PlayerResult>() {

        @Override
        List<ResolvableFuture<PlayerResult>> onExecute() {
            ArrayList<ResolvableFuture<PlayerResult>> futures = new ArrayList<>();
            ResolvableFuture<PlayerResult> future = ResolvableFuture.create();
            synchronized (mPendingCommands) {
                Object token = mPlayer.setSurface(surface);
                addPendingCommandLocked(MediaPlayer2.CALL_COMPLETED_SET_SURFACE, future, token);
            }
            futures.add(future);
            return futures;
        }
    };
    addPendingFuture(pendingFuture);
    return pendingFuture;
}
#method_after
@NonNull
public ListenableFuture<PlayerResult> setSurface(@Nullable final Surface surface) {
    PendingFuture<PlayerResult> pendingFuture = new PendingFuture<PlayerResult>(mExecutor) {

        @Override
        List<ResolvableFuture<PlayerResult>> onExecute() {
            ArrayList<ResolvableFuture<PlayerResult>> futures = new ArrayList<>();
            ResolvableFuture<PlayerResult> future = ResolvableFuture.create();
            synchronized (mPendingCommands) {
                Object token = mPlayer.setSurface(surface);
                addPendingCommandLocked(MediaPlayer2.CALL_COMPLETED_SET_SURFACE, future, token);
            }
            futures.add(future);
            return futures;
        }
    };
    addPendingFuture(pendingFuture);
    return pendingFuture;
}
#end_block

#method_before
@NonNull
public ListenableFuture<PlayerResult> setPlayerVolume(final float volume) {
    PendingFuture<PlayerResult> pendingFuture = new PendingFuture<PlayerResult>() {

        @Override
        List<ResolvableFuture<PlayerResult>> onExecute() {
            ArrayList<ResolvableFuture<PlayerResult>> futures = new ArrayList<>();
            futures.add(setPlayerVolumeInternal(volume));
            return futures;
        }
    };
    addPendingFuture(pendingFuture);
    return pendingFuture;
}
#method_after
@NonNull
public ListenableFuture<PlayerResult> setPlayerVolume(final float volume) {
    PendingFuture<PlayerResult> pendingFuture = new PendingFuture<PlayerResult>(mExecutor) {

        @Override
        List<ResolvableFuture<PlayerResult>> onExecute() {
            ArrayList<ResolvableFuture<PlayerResult>> futures = new ArrayList<>();
            futures.add(setPlayerVolumeInternal(volume));
            return futures;
        }
    };
    addPendingFuture(pendingFuture);
    return pendingFuture;
}
#end_block

#method_before
public VideoSize getVideoSize() {
    return new VideoSize(mPlayer.getVideoWidth(), mPlayer.getVideoHeight());
}
#method_after
@NonNull
public VideoSize getVideoSize() {
    return new VideoSize(mPlayer.getVideoWidth(), mPlayer.getVideoHeight());
}
#end_block

#method_before
@NonNull
public ListenableFuture<PlayerResult> setPlaybackParams(@NonNull final PlaybackParams2 params) {
    PendingFuture<PlayerResult> pendingFuture = new PendingFuture<PlayerResult>() {

        @Override
        List<ResolvableFuture<PlayerResult>> onExecute() {
            ArrayList<ResolvableFuture<PlayerResult>> futures = new ArrayList<>();
            ResolvableFuture<PlayerResult> future = ResolvableFuture.create();
            synchronized (mPendingCommands) {
                Object token = mPlayer.setPlaybackParams(params);
                addPendingCommandLocked(MediaPlayer2.CALL_COMPLETED_SET_PLAYBACK_PARAMS, future, token);
            }
            futures.add(future);
            return futures;
        }
    };
    addPendingFuture(pendingFuture);
    return pendingFuture;
}
#method_after
@NonNull
public ListenableFuture<PlayerResult> setPlaybackParams(@NonNull final PlaybackParams params) {
    PendingFuture<PlayerResult> pendingFuture = new PendingFuture<PlayerResult>(mExecutor) {

        @Override
        List<ResolvableFuture<PlayerResult>> onExecute() {
            ArrayList<ResolvableFuture<PlayerResult>> futures = new ArrayList<>();
            ResolvableFuture<PlayerResult> future = ResolvableFuture.create();
            synchronized (mPendingCommands) {
                Object token = mPlayer.setPlaybackParams(params);
                addPendingCommandLocked(MediaPlayer2.CALL_COMPLETED_SET_PLAYBACK_PARAMS, future, token);
            }
            futures.add(future);
            return futures;
        }
    };
    addPendingFuture(pendingFuture);
    return pendingFuture;
}
#end_block

#method_before
@NonNull
public PlaybackParams2 getPlaybackParams() {
    return mPlayer.getPlaybackParams();
}
#method_after
@NonNull
public PlaybackParams getPlaybackParams() {
    return mPlayer.getPlaybackParams();
}
#end_block

#method_before
@NonNull
public ListenableFuture<PlayerResult> seekTo(final long msec, @SeekMode final int mode) {
    PendingFuture<PlayerResult> pendingFuture = new PendingFuture<PlayerResult>(true) {

        @Override
        List<ResolvableFuture<PlayerResult>> onExecute() {
            ArrayList<ResolvableFuture<PlayerResult>> futures = new ArrayList<>();
            ResolvableFuture<PlayerResult> future = ResolvableFuture.create();
            int mp2SeekMode = sSeekModeMap.getOrDefault(mode, SEEK_NEXT_SYNC);
            synchronized (mPendingCommands) {
                Object token = mPlayer.seekTo(msec, mp2SeekMode);
                addPendingCommandLocked(MediaPlayer2.CALL_COMPLETED_SEEK_TO, future, token);
            }
            futures.add(future);
            return futures;
        }
    };
    addPendingFuture(pendingFuture);
    return pendingFuture;
}
#method_after
@NonNull
public ListenableFuture<PlayerResult> seekTo(final long msec, @SeekMode final int mode) {
    PendingFuture<PlayerResult> pendingFuture = new PendingFuture<PlayerResult>(mExecutor, true) {

        @Override
        List<ResolvableFuture<PlayerResult>> onExecute() {
            ArrayList<ResolvableFuture<PlayerResult>> futures = new ArrayList<>();
            ResolvableFuture<PlayerResult> future = ResolvableFuture.create();
            int mp2SeekMode = sSeekModeMap.getOrDefault(mode, SEEK_NEXT_SYNC);
            synchronized (mPendingCommands) {
                Object token = mPlayer.seekTo(msec, mp2SeekMode);
                addPendingCommandLocked(MediaPlayer2.CALL_COMPLETED_SEEK_TO, future, token);
            }
            futures.add(future);
            return futures;
        }
    };
    addPendingFuture(pendingFuture);
    return pendingFuture;
}
#end_block

#method_before
@Nullable
public MediaTimestamp2 getTimestamp() {
    return mPlayer.getTimestamp();
}
#method_after
@Nullable
public MediaTimestamp getTimestamp() {
    return mPlayer.getTimestamp();
}
#end_block

#method_before
@NonNull
public ListenableFuture<PlayerResult> setAudioSessionId(final int sessionId) {
    PendingFuture<PlayerResult> pendingFuture = new PendingFuture<PlayerResult>() {

        @Override
        List<ResolvableFuture<PlayerResult>> onExecute() {
            ArrayList<ResolvableFuture<PlayerResult>> futures = new ArrayList<>();
            ResolvableFuture<PlayerResult> future = ResolvableFuture.create();
            synchronized (mPendingCommands) {
                Object token = mPlayer.setAudioSessionId(sessionId);
                addPendingCommandLocked(MediaPlayer2.CALL_COMPLETED_SET_AUDIO_SESSION_ID, future, token);
            }
            futures.add(future);
            return futures;
        }
    };
    addPendingFuture(pendingFuture);
    return pendingFuture;
}
#method_after
@NonNull
public ListenableFuture<PlayerResult> setAudioSessionId(final int sessionId) {
    PendingFuture<PlayerResult> pendingFuture = new PendingFuture<PlayerResult>(mExecutor) {

        @Override
        List<ResolvableFuture<PlayerResult>> onExecute() {
            ArrayList<ResolvableFuture<PlayerResult>> futures = new ArrayList<>();
            ResolvableFuture<PlayerResult> future = ResolvableFuture.create();
            synchronized (mPendingCommands) {
                Object token = mPlayer.setAudioSessionId(sessionId);
                addPendingCommandLocked(MediaPlayer2.CALL_COMPLETED_SET_AUDIO_SESSION_ID, future, token);
            }
            futures.add(future);
            return futures;
        }
    };
    addPendingFuture(pendingFuture);
    return pendingFuture;
}
#end_block

#method_before
@NonNull
public ListenableFuture<PlayerResult> attachAuxEffect(final int effectId) {
    PendingFuture<PlayerResult> pendingFuture = new PendingFuture<PlayerResult>() {

        @Override
        List<ResolvableFuture<PlayerResult>> onExecute() {
            ArrayList<ResolvableFuture<PlayerResult>> futures = new ArrayList<>();
            ResolvableFuture<PlayerResult> future = ResolvableFuture.create();
            synchronized (mPendingCommands) {
                Object token = mPlayer.attachAuxEffect(effectId);
                addPendingCommandLocked(MediaPlayer2.CALL_COMPLETED_ATTACH_AUX_EFFECT, future, token);
            }
            futures.add(future);
            return futures;
        }
    };
    addPendingFuture(pendingFuture);
    return pendingFuture;
}
#method_after
@NonNull
public ListenableFuture<PlayerResult> attachAuxEffect(final int effectId) {
    PendingFuture<PlayerResult> pendingFuture = new PendingFuture<PlayerResult>(mExecutor) {

        @Override
        List<ResolvableFuture<PlayerResult>> onExecute() {
            ArrayList<ResolvableFuture<PlayerResult>> futures = new ArrayList<>();
            ResolvableFuture<PlayerResult> future = ResolvableFuture.create();
            synchronized (mPendingCommands) {
                Object token = mPlayer.attachAuxEffect(effectId);
                addPendingCommandLocked(MediaPlayer2.CALL_COMPLETED_ATTACH_AUX_EFFECT, future, token);
            }
            futures.add(future);
            return futures;
        }
    };
    addPendingFuture(pendingFuture);
    return pendingFuture;
}
#end_block

#method_before
@NonNull
public ListenableFuture<PlayerResult> setAuxEffectSendLevel(final float level) {
    PendingFuture<PlayerResult> pendingFuture = new PendingFuture<PlayerResult>() {

        @Override
        List<ResolvableFuture<PlayerResult>> onExecute() {
            ArrayList<ResolvableFuture<PlayerResult>> futures = new ArrayList<>();
            ResolvableFuture<PlayerResult> future = ResolvableFuture.create();
            synchronized (mPendingCommands) {
                Object token = mPlayer.setAuxEffectSendLevel(level);
                addPendingCommandLocked(MediaPlayer2.CALL_COMPLETED_SET_AUX_EFFECT_SEND_LEVEL, future, token);
            }
            futures.add(future);
            return futures;
        }
    };
    addPendingFuture(pendingFuture);
    return pendingFuture;
}
#method_after
@NonNull
public ListenableFuture<PlayerResult> setAuxEffectSendLevel(final float level) {
    PendingFuture<PlayerResult> pendingFuture = new PendingFuture<PlayerResult>(mExecutor) {

        @Override
        List<ResolvableFuture<PlayerResult>> onExecute() {
            ArrayList<ResolvableFuture<PlayerResult>> futures = new ArrayList<>();
            ResolvableFuture<PlayerResult> future = ResolvableFuture.create();
            synchronized (mPendingCommands) {
                Object token = mPlayer.setAuxEffectSendLevel(level);
                addPendingCommandLocked(MediaPlayer2.CALL_COMPLETED_SET_AUX_EFFECT_SEND_LEVEL, future, token);
            }
            futures.add(future);
            return futures;
        }
    };
    addPendingFuture(pendingFuture);
    return pendingFuture;
}
#end_block

#method_before
@NonNull
public ListenableFuture<PlayerResult> selectTrack(final int index) {
    PendingFuture<PlayerResult> pendingFuture = new PendingFuture<PlayerResult>() {

        @Override
        List<ResolvableFuture<PlayerResult>> onExecute() {
            ArrayList<ResolvableFuture<PlayerResult>> futures = new ArrayList<>();
            ResolvableFuture<PlayerResult> future = ResolvableFuture.create();
            synchronized (mPendingCommands) {
                Object token = mPlayer.selectTrack(index);
                addPendingCommandLocked(MediaPlayer2.CALL_COMPLETED_SELECT_TRACK, future, token);
            }
            futures.add(future);
            return futures;
        }
    };
    addPendingFuture(pendingFuture);
    return pendingFuture;
}
#method_after
@NonNull
public ListenableFuture<PlayerResult> selectTrack(final int index) {
    PendingFuture<PlayerResult> pendingFuture = new PendingFuture<PlayerResult>(mExecutor) {

        @Override
        List<ResolvableFuture<PlayerResult>> onExecute() {
            ArrayList<ResolvableFuture<PlayerResult>> futures = new ArrayList<>();
            ResolvableFuture<PlayerResult> future = ResolvableFuture.create();
            synchronized (mPendingCommands) {
                Object token = mPlayer.selectTrack(index);
                addPendingCommandLocked(MediaPlayer2.CALL_COMPLETED_SELECT_TRACK, future, token);
            }
            futures.add(future);
            return futures;
        }
    };
    addPendingFuture(pendingFuture);
    return pendingFuture;
}
#end_block

#method_before
@NonNull
public ListenableFuture<PlayerResult> deselectTrack(final int index) {
    PendingFuture<PlayerResult> pendingFuture = new PendingFuture<PlayerResult>() {

        @Override
        List<ResolvableFuture<PlayerResult>> onExecute() {
            ArrayList<ResolvableFuture<PlayerResult>> futures = new ArrayList<>();
            ResolvableFuture<PlayerResult> future = ResolvableFuture.create();
            synchronized (mPendingCommands) {
                Object token = mPlayer.deselectTrack(index);
                addPendingCommandLocked(MediaPlayer2.CALL_COMPLETED_DESELECT_TRACK, future, token);
            }
            futures.add(future);
            return futures;
        }
    };
    addPendingFuture(pendingFuture);
    return pendingFuture;
}
#method_after
@NonNull
public ListenableFuture<PlayerResult> deselectTrack(final int index) {
    PendingFuture<PlayerResult> pendingFuture = new PendingFuture<PlayerResult>(mExecutor) {

        @Override
        List<ResolvableFuture<PlayerResult>> onExecute() {
            ArrayList<ResolvableFuture<PlayerResult>> futures = new ArrayList<>();
            ResolvableFuture<PlayerResult> future = ResolvableFuture.create();
            synchronized (mPendingCommands) {
                Object token = mPlayer.deselectTrack(index);
                addPendingCommandLocked(MediaPlayer2.CALL_COMPLETED_DESELECT_TRACK, future, token);
            }
            futures.add(future);
            return futures;
        }
    };
    addPendingFuture(pendingFuture);
    return pendingFuture;
}
#end_block

#method_before
@RestrictTo(LIBRARY_GROUP)
// This is an asynchronous call.
@NonNull
public ListenableFuture<DrmResult> prepareDrm(@NonNull final UUID uuid) {
    PendingFuture<DrmResult> pendingFuture = new PendingFuture<DrmResult>() {

        @Override
        List<ResolvableFuture<DrmResult>> onExecute() {
            ArrayList<ResolvableFuture<DrmResult>> futures = new ArrayList<>();
            ResolvableFuture<DrmResult> future = ResolvableFuture.create();
            synchronized (mPendingCommands) {
                Object token = mPlayer.prepareDrm(uuid);
                addPendingCommandLocked(MediaPlayer2.CALL_COMPLETED_PREPARE_DRM, future, token);
            }
            futures.add(future);
            return futures;
        }
    };
    addPendingFuture(pendingFuture);
    return pendingFuture;
}
#method_after
@RestrictTo(LIBRARY_GROUP)
// This is an asynchronous call.
@NonNull
public ListenableFuture<DrmResult> prepareDrm(@NonNull final UUID uuid) {
    PendingFuture<DrmResult> pendingFuture = new PendingFuture<DrmResult>(mExecutor) {

        @Override
        List<ResolvableFuture<DrmResult>> onExecute() {
            ArrayList<ResolvableFuture<DrmResult>> futures = new ArrayList<>();
            ResolvableFuture<DrmResult> future = ResolvableFuture.create();
            synchronized (mPendingCommands) {
                Object token = mPlayer.prepareDrm(uuid);
                addPendingCommandLocked(MediaPlayer2.CALL_COMPLETED_PREPARE_DRM, future, token);
            }
            futures.add(future);
            return futures;
        }
    };
    addPendingFuture(pendingFuture);
    return pendingFuture;
}
#end_block

#method_before
@RestrictTo(LIBRARY_GROUP)
public void setOnDrmConfigHelper(@Nullable final OnDrmConfigHelper listener) {
    mPlayer.setOnDrmConfigHelper(listener == null ? null : new MediaPlayer2.OnDrmConfigHelper() {

        @Override
        public void onDrmConfig(MediaPlayer2 mp, MediaItem2 item) {
            listener.onDrmConfig(MediaPlayer.this, item);
        }
    });
}
#method_after
@RestrictTo(LIBRARY_GROUP)
public void setOnDrmConfigHelper(@Nullable final OnDrmConfigHelper listener) {
    mPlayer.setOnDrmConfigHelper(listener == null ? null : new MediaPlayer2.OnDrmConfigHelper() {

        @Override
        public void onDrmConfig(MediaPlayer2 mp, MediaItem item) {
            listener.onDrmConfig(MediaPlayer.this, item);
        }
    });
}
#end_block

#method_before
@SuppressWarnings("WeakerAccess")
/* synthetic access */
void setState(@PlayerState final int state) {
    boolean needToNotify = false;
    synchronized (mStateLock) {
        if (mState != state) {
            mState = state;
            needToNotify = true;
        }
    }
    if (needToNotify) {
        notifySessionPlayerCallback(new SessionPlayerCallbackNotifier() {

            @Override
            public void callCallback(SessionPlayer2.PlayerCallback callback) {
                callback.onPlayerStateChanged(MediaPlayer.this, state);
            }
        });
    }
}
#method_after
@SuppressWarnings("WeakerAccess")
/* synthetic access */
void setState(@PlayerState final int state) {
    boolean needToNotify = false;
    synchronized (mStateLock) {
        if (mState != state) {
            mState = state;
            needToNotify = true;
        }
    }
    if (needToNotify) {
        notifySessionPlayerCallback(new SessionPlayerCallbackNotifier() {

            @Override
            public void callCallback(SessionPlayer.PlayerCallback callback) {
                callback.onPlayerStateChanged(MediaPlayer.this, state);
            }
        });
    }
}
#end_block

#method_before
@SuppressWarnings("WeakerAccess")
/* synthetic access */
void setBufferingState(final MediaItem2 item, @BuffState final int state) {
    Integer previousState;
    synchronized (mStateLock) {
        previousState = mMediaItemToBuffState.put(item, state);
    }
    if (previousState == null || previousState.intValue() != state) {
        notifySessionPlayerCallback(new SessionPlayerCallbackNotifier() {

            @Override
            public void callCallback(SessionPlayer2.PlayerCallback callback) {
                callback.onBufferingStateChanged(MediaPlayer.this, item, state);
            }
        });
    }
}
#method_after
@SuppressWarnings("WeakerAccess")
/* synthetic access */
void setBufferingState(final MediaItem item, @BuffState final int state) {
    Integer previousState;
    synchronized (mStateLock) {
        previousState = mMediaItemToBuffState.put(item, state);
    }
    if (previousState == null || previousState.intValue() != state) {
        notifySessionPlayerCallback(new SessionPlayerCallbackNotifier() {

            @Override
            public void callCallback(SessionPlayer.PlayerCallback callback) {
                callback.onBufferingStateChanged(MediaPlayer.this, item, state);
            }
        });
    }
}
#end_block

#method_before
@SuppressWarnings("WeakerAccess")
/* synthetic access */
void notifySessionPlayerCallback(final SessionPlayerCallbackNotifier notifier) {
    List<Pair<SessionPlayer2.PlayerCallback, Executor>> callbacks = getCallbacks();
    for (Pair<SessionPlayer2.PlayerCallback, Executor> pair : callbacks) {
        final SessionPlayer2.PlayerCallback callback = pair.first;
        pair.second.execute(new Runnable() {

            @Override
            public void run() {
                notifier.callCallback(callback);
            }
        });
    }
}
#method_after
@SuppressWarnings("WeakerAccess")
/* synthetic access */
void notifySessionPlayerCallback(final SessionPlayerCallbackNotifier notifier) {
    List<Pair<SessionPlayer.PlayerCallback, Executor>> callbacks = getCallbacks();
    for (Pair<SessionPlayer.PlayerCallback, Executor> pair : callbacks) {
        final SessionPlayer.PlayerCallback callback = pair.first;
        pair.second.execute(new Runnable() {

            @Override
            public void run() {
                notifier.callCallback(callback);
            }
        });
    }
}
#end_block

#method_before
@SuppressWarnings("WeakerAccess")
/* synthetic access */
void notifyMediaPlayerCallback(final MediaPlayerCallbackNotifier notifier) {
    List<Pair<SessionPlayer2.PlayerCallback, Executor>> callbacks = getCallbacks();
    for (Pair<SessionPlayer2.PlayerCallback, Executor> pair : callbacks) {
        if (pair.first instanceof PlayerCallback) {
            final PlayerCallback callback = (PlayerCallback) pair.first;
            pair.second.execute(new Runnable() {

                @Override
                public void run() {
                    notifier.callCallback(callback);
                }
            });
        }
    }
}
#method_after
@SuppressWarnings("WeakerAccess")
/* synthetic access */
void notifyMediaPlayerCallback(final MediaPlayerCallbackNotifier notifier) {
    List<Pair<SessionPlayer.PlayerCallback, Executor>> callbacks = getCallbacks();
    for (Pair<SessionPlayer.PlayerCallback, Executor> pair : callbacks) {
        if (pair.first instanceof PlayerCallback) {
            final PlayerCallback callback = (PlayerCallback) pair.first;
            pair.second.execute(new Runnable() {

                @Override
                public void run() {
                    notifier.callCallback(callback);
                }
            });
        }
    }
}
#end_block

#method_before
@SuppressWarnings("WeakerAccess")
/* synthetic access */
List<ResolvableFuture<PlayerResult>> setMediaItemsInternal(@NonNull MediaItem2 curItem, @Nullable MediaItem2 nextItem) {
    boolean setMediaItemCalled;
    synchronized (mPlaylistLock) {
        setMediaItemCalled = mSetMediaItemCalled;
    }
    ArrayList<ResolvableFuture<PlayerResult>> futures = new ArrayList<>();
    if (setMediaItemCalled) {
        futures.add(setNextMediaItemInternal(curItem));
        futures.add(skipToNextInternal());
    } else {
        futures.add(setMediaItemInternal(curItem));
    }
    if (nextItem != null) {
        futures.add(setNextMediaItemInternal(nextItem));
    }
    return futures;
}
#method_after
@SuppressWarnings("WeakerAccess")
/* synthetic access */
List<ResolvableFuture<PlayerResult>> setMediaItemsInternal(@NonNull MediaItem curItem, @Nullable MediaItem nextItem) {
    boolean setMediaItemCalled;
    synchronized (mPlaylistLock) {
        setMediaItemCalled = mSetMediaItemCalled;
    }
    ArrayList<ResolvableFuture<PlayerResult>> futures = new ArrayList<>();
    if (setMediaItemCalled) {
        futures.add(setNextMediaItemInternal(curItem));
        futures.add(skipToNextInternal());
    } else {
        futures.add(setMediaItemInternal(curItem));
    }
    if (nextItem != null) {
        futures.add(setNextMediaItemInternal(nextItem));
    }
    return futures;
}
#end_block

#method_before
private ResolvableFuture<PlayerResult> setMediaItemInternal(MediaItem2 item) {
    ResolvableFuture<PlayerResult> future = ResolvableFuture.create();
    synchronized (mPendingCommands) {
        Object token = mPlayer.setMediaItem(item);
        addPendingCommandLocked(MediaPlayer2.CALL_COMPLETED_SET_DATA_SOURCE, future, token);
    }
    synchronized (mPlaylistLock) {
        mSetMediaItemCalled = true;
    }
    return future;
}
#method_after
private ResolvableFuture<PlayerResult> setMediaItemInternal(MediaItem item) {
    ResolvableFuture<PlayerResult> future = ResolvableFuture.create();
    synchronized (mPendingCommands) {
        Object token = mPlayer.setMediaItem(item);
        addPendingCommandLocked(MediaPlayer2.CALL_COMPLETED_SET_DATA_SOURCE, future, token);
    }
    synchronized (mPlaylistLock) {
        mSetMediaItemCalled = true;
    }
    return future;
}
#end_block

#method_before
@SuppressWarnings("WeakerAccess")
/* synthetic access */
ResolvableFuture<PlayerResult> setNextMediaItemInternal(MediaItem2 item) {
    ResolvableFuture<PlayerResult> future = ResolvableFuture.create();
    synchronized (mPendingCommands) {
        Object token = mPlayer.setNextMediaItem(item);
        addPendingCommandLocked(MediaPlayer2.CALL_COMPLETED_SET_NEXT_DATA_SOURCE, future, token);
    }
    return future;
}
#method_after
@SuppressWarnings("WeakerAccess")
/* synthetic access */
ResolvableFuture<PlayerResult> setNextMediaItemInternal(MediaItem item) {
    ResolvableFuture<PlayerResult> future = ResolvableFuture.create();
    synchronized (mPendingCommands) {
        Object token = mPlayer.setNextMediaItem(item);
        addPendingCommandLocked(MediaPlayer2.CALL_COMPLETED_SET_NEXT_DATA_SOURCE, future, token);
    }
    return future;
}
#end_block

#method_before
@SuppressWarnings("WeakerAccess")
/* synthetic access */
ResolvableFuture<PlayerResult> createFutureForResultCode(int resultCode) {
    ResolvableFuture<PlayerResult> future = ResolvableFuture.create();
    future.set(new PlayerResult(resultCode, mPlayer.getCurrentMediaItem()));
    return future;
}
#method_after
@SuppressWarnings("WeakerAccess")
/* synthetic access */
ResolvableFuture<PlayerResult> createFutureForResultCode(int resultCode) {
    return createFutureForResultCode(resultCode, null);
}
#end_block

#method_before
@SuppressWarnings("WeakerAccess")
/* synthetic access */
ResolvableFuture<PlayerResult> createFutureForResultCode(int resultCode) {
    ResolvableFuture<PlayerResult> future = ResolvableFuture.create();
    future.set(new PlayerResult(resultCode, mPlayer.getCurrentMediaItem()));
    return future;
}
#method_after
@SuppressWarnings("WeakerAccess")
/* synthetic access */
ResolvableFuture<PlayerResult> createFutureForResultCode(int resultCode, MediaItem item) {
    ResolvableFuture<PlayerResult> future = ResolvableFuture.create();
    future.set(new PlayerResult(resultCode, item == null ? mPlayer.getCurrentMediaItem() : item));
    return future;
}
#end_block

#method_before
@SuppressWarnings("WeakerAccess")
/* synthetic access */
List<ResolvableFuture<PlayerResult>> createFuturesForResultCode(int resultCode) {
    ArrayList<ResolvableFuture<PlayerResult>> futures = new ArrayList<>();
    futures.add(createFutureForResultCode(resultCode));
    return futures;
}
#method_after
@SuppressWarnings("WeakerAccess")
/* synthetic access */
List<ResolvableFuture<PlayerResult>> createFuturesForResultCode(int resultCode) {
    return createFuturesForResultCode(resultCode, null);
}
#end_block

#method_before
@SuppressWarnings("WeakerAccess")
/* synthetic access */
List<ResolvableFuture<PlayerResult>> createFuturesForResultCode(int resultCode) {
    ArrayList<ResolvableFuture<PlayerResult>> futures = new ArrayList<>();
    futures.add(createFutureForResultCode(resultCode));
    return futures;
}
#method_after
@SuppressWarnings("WeakerAccess")
/* synthetic access */
List<ResolvableFuture<PlayerResult>> createFuturesForResultCode(int resultCode, MediaItem item) {
    ArrayList<ResolvableFuture<PlayerResult>> futures = new ArrayList<>();
    futures.add(createFutureForResultCode(resultCode, item));
    return futures;
}
#end_block

#method_before
@SuppressWarnings({ "GuardedBy", "WeakerAccess" })
/* synthetic access */
void applyShuffleModeLocked() {
    mShuffledList.clear();
    mShuffledList.addAll(mPlaylist);
    if (mShuffleMode == SessionPlayer2.SHUFFLE_MODE_ALL || mShuffleMode == SessionPlayer2.SHUFFLE_MODE_GROUP) {
        Collections.shuffle(mShuffledList);
    }
}
#method_after
@SuppressWarnings({ "GuardedBy", "WeakerAccess" })
/* synthetic access */
void applyShuffleModeLocked() {
    mShuffledList.clear();
    mShuffledList.addAll(mPlaylist);
    if (mShuffleMode == SessionPlayer.SHUFFLE_MODE_ALL || mShuffleMode == SessionPlayer.SHUFFLE_MODE_GROUP) {
        Collections.shuffle(mShuffledList);
    }
}
#end_block

#method_before
@SuppressWarnings({ "GuardedBy", "WeakerAccess" })
/* synthetic access */
Pair<MediaItem2, MediaItem2> updateAndGetCurrentNextItemIfNeededLocked() {
    MediaItem2 changedCurItem = null;
    MediaItem2 changedNextItem = null;
    if (mCurrentShuffleIdx < 0) {
        if (mCurPlaylistItem == null && mNextPlaylistItem == null) {
            return null;
        }
        mCurPlaylistItem = null;
        mNextPlaylistItem = null;
        return new Pair<>(null, null);
    }
    if (!Objects.equals(mCurPlaylistItem, mShuffledList.get(mCurrentShuffleIdx))) {
        changedCurItem = mCurPlaylistItem = mShuffledList.get(mCurrentShuffleIdx);
    }
    int nextShuffleIdx = mCurrentShuffleIdx + 1;
    if (nextShuffleIdx >= mShuffledList.size()) {
        if (mRepeatMode == REPEAT_MODE_ALL || mRepeatMode == REPEAT_MODE_GROUP) {
            nextShuffleIdx = 0;
        } else {
            nextShuffleIdx = END_OF_PLAYLIST;
        }
    }
    if (nextShuffleIdx == END_OF_PLAYLIST) {
        mNextPlaylistItem = null;
    } else if (!Objects.equals(mNextPlaylistItem, mShuffledList.get(nextShuffleIdx))) {
        changedNextItem = mNextPlaylistItem = mShuffledList.get(nextShuffleIdx);
    }
    return (changedCurItem == null && changedNextItem == null) ? null : new Pair<>(changedCurItem, changedNextItem);
}
#method_after
@SuppressWarnings({ "GuardedBy", "WeakerAccess" })
/* synthetic access */
Pair<MediaItem, MediaItem> updateAndGetCurrentNextItemIfNeededLocked() {
    MediaItem changedCurItem = null;
    MediaItem changedNextItem = null;
    if (mCurrentShuffleIdx < 0) {
        if (mCurPlaylistItem == null && mNextPlaylistItem == null) {
            return null;
        }
        mCurPlaylistItem = null;
        mNextPlaylistItem = null;
        return new Pair<>(null, null);
    }
    if (!Objects.equals(mCurPlaylistItem, mShuffledList.get(mCurrentShuffleIdx))) {
        changedCurItem = mCurPlaylistItem = mShuffledList.get(mCurrentShuffleIdx);
    }
    int nextShuffleIdx = mCurrentShuffleIdx + 1;
    if (nextShuffleIdx >= mShuffledList.size()) {
        if (mRepeatMode == REPEAT_MODE_ALL || mRepeatMode == REPEAT_MODE_GROUP) {
            nextShuffleIdx = 0;
        } else {
            nextShuffleIdx = END_OF_PLAYLIST;
        }
    }
    if (nextShuffleIdx == END_OF_PLAYLIST) {
        mNextPlaylistItem = null;
    } else if (!Objects.equals(mNextPlaylistItem, mShuffledList.get(nextShuffleIdx))) {
        changedNextItem = mNextPlaylistItem = mShuffledList.get(nextShuffleIdx);
    }
    return (changedCurItem == null && changedNextItem == null) ? null : new Pair<>(changedCurItem, changedNextItem);
}
#end_block

#method_before
@SuppressWarnings("WeakerAccess")
/* synthetic access */
void handleCallComplete(MediaPlayer2 mp, final MediaItem2 item, int what, int status) {
    PendingCommand expected;
    synchronized (mPendingCommands) {
        expected = mPendingCommands.pollFirst();
    }
    if (expected == null) {
        Log.i(TAG, "No matching call type for " + what + ". Possibly because of reset().");
        return;
    }
    if (what != expected.mCallType) {
        Log.w(TAG, "Call type does not match. expeced:" + expected.mCallType + " actual:" + what);
        status = MediaPlayer2.CALL_STATUS_ERROR_UNKNOWN;
    }
    if (status == MediaPlayer2.CALL_STATUS_NO_ERROR) {
        switch(what) {
            case MediaPlayer2.CALL_COMPLETED_PREPARE:
            case MediaPlayer2.CALL_COMPLETED_PAUSE:
                setState(PLAYER_STATE_PAUSED);
                break;
            case MediaPlayer2.CALL_COMPLETED_PLAY:
                setState(PLAYER_STATE_PLAYING);
                break;
            case MediaPlayer2.CALL_COMPLETED_SEEK_TO:
                final long pos = mPlayer.getCurrentPosition();
                notifySessionPlayerCallback(new SessionPlayerCallbackNotifier() {

                    @Override
                    public void callCallback(SessionPlayer2.PlayerCallback callback) {
                        callback.onSeekCompleted(MediaPlayer.this, pos);
                    }
                });
                break;
            case MediaPlayer2.CALL_COMPLETED_SET_DATA_SOURCE:
                notifySessionPlayerCallback(new SessionPlayerCallbackNotifier() {

                    @Override
                    public void callCallback(SessionPlayer2.PlayerCallback callback) {
                        callback.onCurrentMediaItemChanged(MediaPlayer.this, item);
                    }
                });
                break;
            case MediaPlayer2.CALL_COMPLETED_SET_PLAYBACK_PARAMS:
                // TODO: Need to check if the speed value is really changed.
                final float speed = mPlayer.getPlaybackParams().getSpeed();
                notifySessionPlayerCallback(new SessionPlayerCallbackNotifier() {

                    @Override
                    public void callCallback(SessionPlayer2.PlayerCallback callback) {
                        callback.onPlaybackSpeedChanged(MediaPlayer.this, speed);
                    }
                });
                break;
            case MediaPlayer2.CALL_COMPLETED_SET_AUDIO_ATTRIBUTES:
                final AudioAttributesCompat attr = mPlayer.getAudioAttributes();
                notifySessionPlayerCallback(new SessionPlayerCallbackNotifier() {

                    @Override
                    public void callCallback(SessionPlayer2.PlayerCallback callback) {
                        callback.onAudioAttributesChanged(MediaPlayer.this, attr);
                    }
                });
                break;
        }
    }
    if (what != MediaPlayer2.CALL_COMPLETED_PREPARE_DRM) {
        Integer resultCode = sResultCodeMap.getOrDefault(status, RESULT_CODE_UNKNOWN_ERROR);
        expected.mFuture.set(new PlayerResult(resultCode, item));
    } else {
        Integer resultCode = sPrepareDrmStatusMap.getOrDefault(status, DrmResult.RESULT_CODE_PREPARATION_ERROR);
        expected.mFuture.set(new DrmResult(resultCode, item));
    }
    executePendingFuturesIfNeeded();
}
#method_after
@SuppressWarnings("WeakerAccess")
/* synthetic access */
void handleCallComplete(MediaPlayer2 mp, final MediaItem item, int what, int status) {
    PendingCommand expected;
    synchronized (mPendingCommands) {
        expected = mPendingCommands.pollFirst();
    }
    if (expected == null) {
        Log.i(TAG, "No matching call type for " + what + ". Possibly because of reset().");
        return;
    }
    if (what != expected.mCallType) {
        Log.w(TAG, "Call type does not match. expeced:" + expected.mCallType + " actual:" + what);
        status = MediaPlayer2.CALL_STATUS_ERROR_UNKNOWN;
    }
    if (status == MediaPlayer2.CALL_STATUS_NO_ERROR) {
        switch(what) {
            case MediaPlayer2.CALL_COMPLETED_PREPARE:
            case MediaPlayer2.CALL_COMPLETED_PAUSE:
                setState(PLAYER_STATE_PAUSED);
                break;
            case MediaPlayer2.CALL_COMPLETED_PLAY:
                setState(PLAYER_STATE_PLAYING);
                break;
            case MediaPlayer2.CALL_COMPLETED_SEEK_TO:
                final long pos = mPlayer.getCurrentPosition();
                notifySessionPlayerCallback(new SessionPlayerCallbackNotifier() {

                    @Override
                    public void callCallback(SessionPlayer.PlayerCallback callback) {
                        callback.onSeekCompleted(MediaPlayer.this, pos);
                    }
                });
                break;
            case MediaPlayer2.CALL_COMPLETED_SET_DATA_SOURCE:
                notifySessionPlayerCallback(new SessionPlayerCallbackNotifier() {

                    @Override
                    public void callCallback(SessionPlayer.PlayerCallback callback) {
                        callback.onCurrentMediaItemChanged(MediaPlayer.this, item);
                    }
                });
                break;
            case MediaPlayer2.CALL_COMPLETED_SET_PLAYBACK_PARAMS:
                // TODO: Need to check if the speed value is really changed.
                final float speed = mPlayer.getPlaybackParams().getSpeed();
                notifySessionPlayerCallback(new SessionPlayerCallbackNotifier() {

                    @Override
                    public void callCallback(SessionPlayer.PlayerCallback callback) {
                        callback.onPlaybackSpeedChanged(MediaPlayer.this, speed);
                    }
                });
                break;
            case MediaPlayer2.CALL_COMPLETED_SET_AUDIO_ATTRIBUTES:
                final AudioAttributesCompat attr = mPlayer.getAudioAttributes();
                notifySessionPlayerCallback(new SessionPlayerCallbackNotifier() {

                    @Override
                    public void callCallback(SessionPlayer.PlayerCallback callback) {
                        callback.onAudioAttributesChanged(MediaPlayer.this, attr);
                    }
                });
                break;
        }
    }
    if (what != MediaPlayer2.CALL_COMPLETED_PREPARE_DRM) {
        Integer resultCode = sResultCodeMap.getOrDefault(status, RESULT_CODE_UNKNOWN_ERROR);
        expected.mFuture.set(new PlayerResult(resultCode, item));
    } else {
        Integer resultCode = sPrepareDrmStatusMap.getOrDefault(status, DrmResult.RESULT_CODE_PREPARATION_ERROR);
        expected.mFuture.set(new DrmResult(resultCode, item));
    }
    executePendingFutures();
}
#end_block

#method_before
@Override
public void onDrmInfo(MediaPlayer2 mp, final MediaItem2 item, final MediaPlayer2.DrmInfo drmInfo) {
    notifyMediaPlayerCallback(new MediaPlayerCallbackNotifier() {

        @Override
        public void callCallback(PlayerCallback callback) {
            callback.onDrmInfo(MediaPlayer.this, item, drmInfo == null ? null : new DrmInfo(drmInfo));
        }
    });
}
#method_after
@Override
public void onDrmInfo(MediaPlayer2 mp, final MediaItem item, final MediaPlayer2.DrmInfo drmInfo) {
    notifyMediaPlayerCallback(new MediaPlayerCallbackNotifier() {

        @Override
        public void callCallback(PlayerCallback callback) {
            callback.onDrmInfo(MediaPlayer.this, item, drmInfo == null ? null : new DrmInfo(drmInfo));
        }
    });
}
#end_block

#method_before
@Override
public void onDrmPrepared(MediaPlayer2 mp, final MediaItem2 item, final int status) {
    handleCallComplete(mp, item, MediaPlayer2.CALL_COMPLETED_PREPARE_DRM, status);
}
#method_after
@Override
public void onDrmPrepared(MediaPlayer2 mp, final MediaItem item, final int status) {
    handleCallComplete(mp, item, MediaPlayer2.CALL_COMPLETED_PREPARE_DRM, status);
}
#end_block

#method_before
@Override
public void onVideoSizeChanged(MediaPlayer2 mp, final MediaItem2 item, final int width, final int height) {
    final VideoSize size = new VideoSize(width, height);
    notifyMediaPlayerCallback(new MediaPlayerCallbackNotifier() {

        @Override
        public void callCallback(PlayerCallback callback) {
            callback.onVideoSizeChanged(MediaPlayer.this, item, size);
        }
    });
}
#method_after
@Override
public void onVideoSizeChanged(MediaPlayer2 mp, final MediaItem item, final int width, final int height) {
    final VideoSize size = new VideoSize(width, height);
    notifyMediaPlayerCallback(new MediaPlayerCallbackNotifier() {

        @Override
        public void callCallback(PlayerCallback callback) {
            callback.onVideoSizeChanged(MediaPlayer.this, item, size);
        }
    });
}
#end_block

#method_before
@Override
public void onTimedMetaDataAvailable(MediaPlayer2 mp, final MediaItem2 item, final TimedMetaData2 data) {
    notifyMediaPlayerCallback(new MediaPlayerCallbackNotifier() {

        @Override
        public void callCallback(PlayerCallback callback) {
            callback.onTimedMetaDataAvailable(MediaPlayer.this, item, data);
        }
    });
}
#method_after
@Override
public void onTimedMetaDataAvailable(MediaPlayer2 mp, final MediaItem item, final TimedMetaData data) {
    notifyMediaPlayerCallback(new MediaPlayerCallbackNotifier() {

        @Override
        public void callCallback(PlayerCallback callback) {
            callback.onTimedMetaDataAvailable(MediaPlayer.this, item, data);
        }
    });
}
#end_block

#method_before
@Override
public void onError(MediaPlayer2 mp, final MediaItem2 item, final int what, final int extra) {
    setState(PLAYER_STATE_ERROR);
    setBufferingState(item, BUFFERING_STATE_UNKNOWN);
    notifyMediaPlayerCallback(new MediaPlayerCallbackNotifier() {

        @Override
        public void callCallback(PlayerCallback callback) {
            callback.onError(MediaPlayer.this, item, what, extra);
        }
    });
}
#method_after
@Override
public void onError(MediaPlayer2 mp, final MediaItem item, final int what, final int extra) {
    setState(PLAYER_STATE_ERROR);
    setBufferingState(item, BUFFERING_STATE_UNKNOWN);
    notifyMediaPlayerCallback(new MediaPlayerCallbackNotifier() {

        @Override
        public void callCallback(PlayerCallback callback) {
            callback.onError(MediaPlayer.this, item, what, extra);
        }
    });
}
#end_block

#method_before
@Override
public void onInfo(MediaPlayer2 mp, final MediaItem2 item, final int mp2What, final int extra) {
    switch(mp2What) {
        case MediaPlayer2.MEDIA_INFO_BUFFERING_START:
            setBufferingState(item, BUFFERING_STATE_BUFFERING_AND_STARVED);
            break;
        case MediaPlayer2.MEDIA_INFO_PREPARED:
        case MediaPlayer2.MEDIA_INFO_BUFFERING_END:
            setBufferingState(item, BUFFERING_STATE_BUFFERING_AND_PLAYABLE);
            break;
        case MediaPlayer2.MEDIA_INFO_BUFFERING_UPDATE:
            if (extra >= /* percent */
            100) {
                setBufferingState(item, BUFFERING_STATE_COMPLETE);
            }
            break;
        case MediaPlayer2.MEDIA_INFO_DATA_SOURCE_LIST_END:
            setState(PLAYER_STATE_PAUSED);
            notifySessionPlayerCallback(new SessionPlayerCallbackNotifier() {

                @Override
                public void callCallback(SessionPlayer2.PlayerCallback callback) {
                    callback.onPlaybackCompleted(MediaPlayer.this);
                }
            });
            break;
    }
    final int what = sInfoCodeMap.getOrDefault(mp2What, MEDIA_INFO_UNKNOWN);
    notifyMediaPlayerCallback(new MediaPlayerCallbackNotifier() {

        @Override
        public void callCallback(PlayerCallback callback) {
            callback.onInfo(MediaPlayer.this, item, what, extra);
        }
    });
}
#method_after
@Override
public void onInfo(MediaPlayer2 mp, final MediaItem item, final int mp2What, final int extra) {
    switch(mp2What) {
        case MediaPlayer2.MEDIA_INFO_BUFFERING_START:
            setBufferingState(item, BUFFERING_STATE_BUFFERING_AND_STARVED);
            break;
        case MediaPlayer2.MEDIA_INFO_PREPARED:
        case MediaPlayer2.MEDIA_INFO_BUFFERING_END:
            setBufferingState(item, BUFFERING_STATE_BUFFERING_AND_PLAYABLE);
            break;
        case MediaPlayer2.MEDIA_INFO_BUFFERING_UPDATE:
            if (extra >= /* percent */
            100) {
                setBufferingState(item, BUFFERING_STATE_COMPLETE);
            }
            break;
        case MediaPlayer2.MEDIA_INFO_DATA_SOURCE_LIST_END:
            setState(PLAYER_STATE_PAUSED);
            notifySessionPlayerCallback(new SessionPlayerCallbackNotifier() {

                @Override
                public void callCallback(SessionPlayer.PlayerCallback callback) {
                    callback.onPlaybackCompleted(MediaPlayer.this);
                }
            });
            break;
    }
    final int what = sInfoCodeMap.getOrDefault(mp2What, MEDIA_INFO_UNKNOWN);
    notifyMediaPlayerCallback(new MediaPlayerCallbackNotifier() {

        @Override
        public void callCallback(PlayerCallback callback) {
            callback.onInfo(MediaPlayer.this, item, what, extra);
        }
    });
}
#end_block

#method_before
@Override
public void onCallCompleted(MediaPlayer2 mp, final MediaItem2 item, int what, int status) {
    handleCallComplete(mp, item, what, status);
}
#method_after
@Override
public void onCallCompleted(MediaPlayer2 mp, final MediaItem item, int what, int status) {
    handleCallComplete(mp, item, what, status);
}
#end_block

#method_before
@Override
public void onMediaTimeDiscontinuity(MediaPlayer2 mp, final MediaItem2 item, final MediaTimestamp2 timestamp) {
    notifyMediaPlayerCallback(new MediaPlayerCallbackNotifier() {

        @Override
        public void callCallback(PlayerCallback callback) {
            callback.onMediaTimeDiscontinuity(MediaPlayer.this, item, timestamp);
        }
    });
}
#method_after
@Override
public void onMediaTimeDiscontinuity(MediaPlayer2 mp, final MediaItem item, final MediaTimestamp timestamp) {
    notifyMediaPlayerCallback(new MediaPlayerCallbackNotifier() {

        @Override
        public void callCallback(PlayerCallback callback) {
            callback.onMediaTimeDiscontinuity(MediaPlayer.this, item, timestamp);
        }
    });
}
#end_block

#method_before
@Override
public void onSubtitleData(MediaPlayer2 mp, final MediaItem2 item, final SubtitleData2 data) {
    notifyMediaPlayerCallback(new MediaPlayerCallbackNotifier() {

        @Override
        public void callCallback(PlayerCallback callback) {
            callback.onSubtitleData(MediaPlayer.this, item, data);
        }
    });
}
#method_after
@Override
public void onSubtitleData(MediaPlayer2 mp, final MediaItem item, final SubtitleData data) {
    notifyMediaPlayerCallback(new MediaPlayerCallbackNotifier() {

        @Override
        public void callCallback(PlayerCallback callback) {
            callback.onSubtitleData(MediaPlayer.this, item, data);
        }
    });
}
#end_block

#method_before
public void onVideoSizeChanged(@NonNull MediaPlayer mp, @NonNull MediaItem2 item, VideoSize size) {
}
#method_after
public void onVideoSizeChanged(@NonNull MediaPlayer mp, @NonNull MediaItem item, @NonNull VideoSize size) {
}
#end_block

#method_before
public void onTimedMetaDataAvailable(@NonNull MediaPlayer mp, @NonNull MediaItem2 item, @NonNull TimedMetaData2 data) {
}
#method_after
public void onTimedMetaDataAvailable(@NonNull MediaPlayer mp, @NonNull MediaItem item, @NonNull TimedMetaData data) {
}
#end_block

#method_before
public void onError(@NonNull MediaPlayer mp, @NonNull MediaItem2 item, @MediaError int what, int extra) {
}
#method_after
public void onError(@NonNull MediaPlayer mp, @NonNull MediaItem item, @MediaError int what, int extra) {
}
#end_block

#method_before
public void onInfo(@NonNull MediaPlayer mp, @NonNull MediaItem2 item, @MediaInfo int what, int extra) {
}
#method_after
public void onInfo(@NonNull MediaPlayer mp, @NonNull MediaItem item, @MediaInfo int what, int extra) {
}
#end_block

#method_before
public void onMediaTimeDiscontinuity(@NonNull MediaPlayer mp, @NonNull MediaItem2 item, @NonNull MediaTimestamp2 timestamp) {
}
#method_after
public void onMediaTimeDiscontinuity(@NonNull MediaPlayer mp, @NonNull MediaItem item, @NonNull MediaTimestamp timestamp) {
}
#end_block

#method_before
public void onSubtitleData(@NonNull MediaPlayer mp, @NonNull MediaItem2 item, @NonNull SubtitleData2 data) {
}
#method_after
public void onSubtitleData(@NonNull MediaPlayer mp, @NonNull MediaItem item, @NonNull SubtitleData data) {
}
#end_block

#method_before
@RestrictTo(LIBRARY_GROUP)
public void onDrmInfo(@NonNull MediaPlayer mp, @NonNull MediaItem2 item, @NonNull DrmInfo drmInfo) {
}
#method_after
@RestrictTo(LIBRARY_GROUP)
public void onDrmInfo(@NonNull MediaPlayer mp, @NonNull MediaItem item, @NonNull DrmInfo drmInfo) {
}
#end_block

#method_before
@Override
protected void onCreate(@Nullable Bundle savedInstanceState) {
    // Checks if we have custom FragmentFactory and set it if we have.
    FragmentFactory fragmentFactory = ViewModelProviders.of(this).get(FragmentFactoryHolderViewModel.class).getFragmentFactory();
    if (fragmentFactory != null) {
        getSupportFragmentManager().setFragmentFactory(fragmentFactory);
    }
    // FragmentFactory needs to be set before calling the super.onCreate, otherwise the
    // Activity crashes when it is recreating and there is a fragment which has no
    // default constructor.
    super.onCreate(savedInstanceState);
}
#method_after
@Override
protected void onCreate(@Nullable Bundle savedInstanceState) {
    // Checks if we have a custom FragmentFactory and set it.
    ViewModelProvider viewModelProvider = new ViewModelProvider(this, ViewModelProvider.AndroidViewModelFactory.getInstance(getApplication()));
    FragmentFactory factory = viewModelProvider.get(FragmentFactoryHolderViewModel.class).getFragmentFactory();
    if (factory != null) {
        getSupportFragmentManager().setFragmentFactory(factory);
    }
    // FragmentFactory needs to be set before calling the super.onCreate, otherwise the
    // Activity crashes when it is recreating and there is a fragment which has no
    // default constructor.
    super.onCreate(savedInstanceState);
}
#end_block

#method_before
@NonNull
private static <F extends Fragment> FragmentScenario<F> internalLaunch(@NonNull final Class<F> fragmentClass, @Nullable final Bundle fragmentArgs, @Nullable final FragmentFactory factory, final int containerViewId) {
    FragmentScenario<F> scenario = new FragmentScenario<>(fragmentClass, factory, ActivityScenario.launch(EmptyFragmentActivity.class));
    scenario.mActivityScenario.onActivity(new ActivityScenario.ActivityAction<EmptyFragmentActivity>() {

        @Override
        public void perform(EmptyFragmentActivity activity) {
            if (factory != null) {
                ViewModelProviders.of(activity).get(FragmentFactoryHolderViewModel.class).setFragmentFactory(factory);
                activity.getSupportFragmentManager().setFragmentFactory(factory);
            }
            Fragment fragment = activity.getSupportFragmentManager().getFragmentFactory().instantiate(Preconditions.checkNotNull(fragmentClass.getClassLoader()), fragmentClass.getName(), fragmentArgs);
            fragment.setArguments(fragmentArgs);
            activity.getSupportFragmentManager().beginTransaction().add(containerViewId, fragment, FRAGMENT_TAG).commitNow();
        }
    });
    return scenario;
}
#method_after
@NonNull
private static <F extends Fragment> FragmentScenario<F> internalLaunch(@NonNull final Class<F> fragmentClass, @Nullable final Bundle fragmentArgs, @Nullable final FragmentFactory factory, final int containerViewId) {
    FragmentScenario<F> scenario = new FragmentScenario<>(fragmentClass, factory, ActivityScenario.launch(EmptyFragmentActivity.class));
    scenario.mActivityScenario.onActivity(new ActivityScenario.ActivityAction<EmptyFragmentActivity>() {

        @Override
        public void perform(EmptyFragmentActivity activity) {
            if (factory != null) {
                ViewModelProvider viewModelProvider = new ViewModelProvider(activity, ViewModelProvider.AndroidViewModelFactory.getInstance(activity.getApplication()));
                viewModelProvider.get(FragmentFactoryHolderViewModel.class).setFragmentFactory(factory);
                activity.getSupportFragmentManager().setFragmentFactory(factory);
            }
            Fragment fragment = activity.getSupportFragmentManager().getFragmentFactory().instantiate(Preconditions.checkNotNull(fragmentClass.getClassLoader()), fragmentClass.getName(), fragmentArgs);
            fragment.setArguments(fragmentArgs);
            activity.getSupportFragmentManager().beginTransaction().add(containerViewId, fragment, FRAGMENT_TAG).commitNow();
        }
    });
    return scenario;
}
#end_block

#method_before
@Test
public void testGettersAfterConnected() throws InterruptedException {
    prepareLooper();
    final int state = SessionPlayer.PLAYER_STATE_PLAYING;
    final int bufferingState = SessionPlayer.BUFFERING_STATE_COMPLETE;
    final long position = 150000;
    final long bufferedPosition = 900000;
    final float speed = 0.5f;
    final long timeDiff = 102;
    final MediaItem currentMediaItem = MediaTestUtils.createFileMediaItemWithMetadata();
    Bundle config = RemoteMediaSession.createMockPlayerConnectorConfig(state, bufferingState, position, bufferedPosition, speed, null, /* audioAttrs */
    null, /* playlist */
    currentMediaItem, null);
    mRemoteSession2.updatePlayer(config);
    MediaController controller = createController(mRemoteSession2.getToken());
    controller.setTimeDiff(timeDiff);
    assertEquals(state, controller.getPlayerState());
    assertEquals(bufferedPosition, controller.getBufferedPosition());
    assertEquals(speed, controller.getPlaybackSpeed(), 0.0f);
    assertEquals(position + (long) (speed * timeDiff), controller.getCurrentPosition());
    assertNotMediaItemSubclass(controller.getCurrentMediaItem());
    assertEqualMediaIds(currentMediaItem, controller.getCurrentMediaItem());
}
#method_after
@Test
public void testGettersAfterConnected() throws InterruptedException {
    prepareLooper();
    final int state = SessionPlayer.PLAYER_STATE_PLAYING;
    final int bufferingState = SessionPlayer.BUFFERING_STATE_COMPLETE;
    final long position = 150000;
    final long bufferedPosition = 900000;
    final float speed = 0.5f;
    final long timeDiff = 102;
    final MediaItem currentMediaItem = MediaTestUtils.createFileMediaItemWithMetadata();
    Bundle config = RemoteMediaSession.createMockPlayerConnectorConfig(state, bufferingState, position, bufferedPosition, speed, null, /* audioAttrs */
    null, /* playlist */
    currentMediaItem, null);
    mRemoteSession2.updatePlayer(config);
    MediaController controller = createController(mRemoteSession2.getToken());
    controller.setTimeDiff(timeDiff);
    assertEquals(state, controller.getPlayerState());
    assertEquals(bufferedPosition, controller.getBufferedPosition());
    assertEquals(speed, controller.getPlaybackSpeed(), 0.0f);
    assertEquals(position + (long) (speed * timeDiff), controller.getCurrentPosition());
    MediaTestUtils.assertNotMediaItemSubclass(controller.getCurrentMediaItem());
    MediaTestUtils.assertMediaIdEquals(currentMediaItem, controller.getCurrentMediaItem());
}
#end_block

#method_before
@Test
public void testControllerCallback_onCurrentMediaItemChanged_byMetadataChange() throws Exception {
    prepareLooper();
    final String testMediaId = "testControllerCallback_onCurrentMediaItemChanged_bySetMetadata";
    final CountDownLatch latch = new CountDownLatch(1);
    final ControllerCallback callback = new ControllerCallback() {

        @Override
        public void onCurrentMediaItemChanged(MediaController controller, MediaItem item) {
            assertMediaItemHasId(item, testMediaId);
            latch.countDown();
        }
    };
    mController = createController(mSession.getSessionToken(), true, callback);
    MediaMetadataCompat metadata = new MediaMetadataCompat.Builder().putText(MediaMetadataCompat.METADATA_KEY_MEDIA_ID, testMediaId).build();
    mSession.setMetadata(metadata);
    assertTrue(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
}
#method_after
@Test
public void testControllerCallback_onCurrentMediaItemChanged_byMetadataChange() throws Exception {
    prepareLooper();
    final String testMediaId = "testControllerCallback_onCurrentMediaItemChanged_bySetMetadata";
    final CountDownLatch latch = new CountDownLatch(1);
    final ControllerCallback callback = new ControllerCallback() {

        @Override
        public void onCurrentMediaItemChanged(MediaController controller, MediaItem item) {
            MediaTestUtils.assertMediaItemHasId(item, testMediaId);
            latch.countDown();
        }
    };
    mController = createController(mSession.getSessionToken(), true, callback);
    MediaMetadataCompat metadata = new MediaMetadataCompat.Builder().putText(MediaMetadataCompat.METADATA_KEY_MEDIA_ID, testMediaId).build();
    mSession.setMetadata(metadata);
    assertTrue(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
}
#end_block

#method_before
@Test
public void testControllerCallback_onCurrentMediaItemChanged_byActiveQueueItemChange() throws Exception {
    prepareLooper();
    final List<MediaItem> testList = MediaTestUtils.createFileMediaItems(2);
    final List<QueueItem> testQueue = MediaUtils.convertToQueueItemList(testList);
    mSession.setQueue(testQueue);
    PlaybackStateCompat.Builder builder = new PlaybackStateCompat.Builder();
    // Set the current active queue item to index 'oldItemIndex'.
    final int oldItemIndex = 0;
    builder.setActiveQueueItemId(testQueue.get(oldItemIndex).getQueueId());
    mSession.setPlaybackState(builder.build());
    final int newItemIndex = 1;
    final CountDownLatch latch = new CountDownLatch(1);
    final ControllerCallback callback = new ControllerCallback() {

        @Override
        public void onCurrentMediaItemChanged(MediaController controller, MediaItem item) {
            assertEqualMediaIds(testList.get(newItemIndex), item);
            latch.countDown();
        }
    };
    mController = createController(mSession.getSessionToken(), true, callback);
    // The new playbackState will tell the controller that the active queue item is changed to
    // 'newItemIndex'.
    builder.setActiveQueueItemId(testQueue.get(newItemIndex).getQueueId());
    mSession.setPlaybackState(builder.build());
    assertTrue(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
}
#method_after
@Test
public void testControllerCallback_onCurrentMediaItemChanged_byActiveQueueItemChange() throws Exception {
    prepareLooper();
    final List<MediaItem> testList = MediaTestUtils.createFileMediaItems(2);
    final List<QueueItem> testQueue = MediaUtils.convertToQueueItemList(testList);
    mSession.setQueue(testQueue);
    PlaybackStateCompat.Builder builder = new PlaybackStateCompat.Builder();
    // Set the current active queue item to index 'oldItemIndex'.
    final int oldItemIndex = 0;
    builder.setActiveQueueItemId(testQueue.get(oldItemIndex).getQueueId());
    mSession.setPlaybackState(builder.build());
    final int newItemIndex = 1;
    final CountDownLatch latch = new CountDownLatch(1);
    final ControllerCallback callback = new ControllerCallback() {

        @Override
        public void onCurrentMediaItemChanged(MediaController controller, MediaItem item) {
            MediaTestUtils.assertMediaIdEquals(testList.get(newItemIndex), item);
            latch.countDown();
        }
    };
    mController = createController(mSession.getSessionToken(), true, callback);
    // The new playbackState will tell the controller that the active queue item is changed to
    // 'newItemIndex'.
    builder.setActiveQueueItemId(testQueue.get(newItemIndex).getQueueId());
    mSession.setPlaybackState(builder.build());
    assertTrue(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
}
#end_block

#method_before
// /////////////////////////////////////////////////
// Protected or private methods
private void attachMediaControlView() {
    // Get MediaController from MediaSession and set it inside MediaControlView
    mMediaControlView.setMediaSessionToken2(mMediaSession.getToken());
    LayoutParams params = new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT);
    mInstance.addView(mMediaControlView, params);
}
#method_after
// /////////////////////////////////////////////////
// Protected or private methods
private void attachMediaControlView() {
    // Get MediaController from MediaSession and set it inside MediaControlView
    mMediaControlView.setSessionToken(mMediaSession.getToken());
    LayoutParams params = new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT);
    mInstance.addView(mMediaControlView, params);
}
#end_block

#method_before
@Override
public SessionCommandGroup onConnect(@NonNull MediaSession session, @NonNull MediaSession.ControllerInfo controller) {
    if (session != mMediaSession) {
        if (DEBUG) {
            Log.w(TAG, "onConnect() is ignored. session is already gone.");
        }
    }
    SessionCommandGroup.Builder commandsBuilder = new SessionCommandGroup.Builder().addCommand(SessionCommand.COMMAND_CODE_PLAYER_PAUSE).addCommand(SessionCommand.COMMAND_CODE_PLAYER_PLAY).addCommand(SessionCommand.COMMAND_CODE_PLAYER_PREPARE).addCommand(SessionCommand.COMMAND_CODE_PLAYER_SET_SPEED).addCommand(SessionCommand.COMMAND_CODE_SESSION_FAST_FORWARD).addCommand(SessionCommand.COMMAND_CODE_SESSION_REWIND).addCommand(SessionCommand.COMMAND_CODE_PLAYER_SEEK_TO).addCommand(SessionCommand.COMMAND_CODE_VOLUME_SET_VOLUME).addCommand(SessionCommand.COMMAND_CODE_VOLUME_ADJUST_VOLUME).addCommand(SessionCommand.COMMAND_CODE_SESSION_PLAY_FROM_URI).addCommand(SessionCommand.COMMAND_CODE_SESSION_PREPARE_FROM_URI).addCommand(SessionCommand.COMMAND_CODE_SESSION_SELECT_ROUTE).addCommand(SessionCommand.COMMAND_CODE_PLAYER_GET_PLAYLIST).addCommand(SessionCommand.COMMAND_CODE_PLAYER_GET_PLAYLIST_METADATA).addCommand(new SessionCommand(MediaControlView2.COMMAND_SELECT_AUDIO_TRACK, null)).addCommand(new SessionCommand(MediaControlView2.COMMAND_SHOW_SUBTITLE, null)).addCommand(new SessionCommand(MediaControlView2.COMMAND_HIDE_SUBTITLE, null));
    return commandsBuilder.build();
}
#method_after
@Override
public SessionCommandGroup onConnect(@NonNull MediaSession session, @NonNull MediaSession.ControllerInfo controller) {
    if (session != mMediaSession) {
        if (DEBUG) {
            Log.w(TAG, "onConnect() is ignored. session is already gone.");
        }
    }
    SessionCommandGroup.Builder commandsBuilder = new SessionCommandGroup.Builder().addCommand(SessionCommand.COMMAND_CODE_PLAYER_PAUSE).addCommand(SessionCommand.COMMAND_CODE_PLAYER_PLAY).addCommand(SessionCommand.COMMAND_CODE_PLAYER_PREPARE).addCommand(SessionCommand.COMMAND_CODE_PLAYER_SET_SPEED).addCommand(SessionCommand.COMMAND_CODE_SESSION_FAST_FORWARD).addCommand(SessionCommand.COMMAND_CODE_SESSION_REWIND).addCommand(SessionCommand.COMMAND_CODE_PLAYER_SEEK_TO).addCommand(SessionCommand.COMMAND_CODE_VOLUME_SET_VOLUME).addCommand(SessionCommand.COMMAND_CODE_VOLUME_ADJUST_VOLUME).addCommand(SessionCommand.COMMAND_CODE_SESSION_PLAY_FROM_URI).addCommand(SessionCommand.COMMAND_CODE_SESSION_PREPARE_FROM_URI).addCommand(SessionCommand.COMMAND_CODE_PLAYER_GET_PLAYLIST).addCommand(SessionCommand.COMMAND_CODE_PLAYER_GET_PLAYLIST_METADATA).addCommand(new SessionCommand(MediaControlView2.COMMAND_SELECT_AUDIO_TRACK, null)).addCommand(new SessionCommand(MediaControlView2.COMMAND_SHOW_SUBTITLE, null)).addCommand(new SessionCommand(MediaControlView2.COMMAND_HIDE_SUBTITLE, null));
    return commandsBuilder.build();
}
#end_block

#method_before
@Override
public ListenableFuture<ControllerResult> sendCustomCommand(@NonNull SessionCommand command, @Nullable Bundle args) {
    synchronized (mLock) {
        if (!mConnected) {
            Log.w(TAG, "Session isn't active", new IllegalStateException());
            return createFutureWithResult(RESULT_CODE_DISCONNECTED);
        }
        final ResolvableFuture<ControllerResult> result = ResolvableFuture.create();
        ResultReceiver cb = new ResultReceiver(mHandler) {

            @Override
            protected void onReceiveResult(int resultCode, Bundle resultData) {
                result.set(new ControllerResult(resultCode, resultData));
            }
        };
        mControllerCompat.sendCommand(command.getCustomCommand(), args, cb);
        return result;
    }
}
#method_after
@Override
public ListenableFuture<ControllerResult> sendCustomCommand(@NonNull SessionCommand command, @Nullable Bundle args) {
    synchronized (mLock) {
        if (!mConnected) {
            Log.w(TAG, "Session isn't active", new IllegalStateException());
            return createFutureWithResult(RESULT_CODE_DISCONNECTED);
        }
        if (mAllowedCommands.hasCommand(command)) {
            mControllerCompat.getTransportControls().sendCustomAction(command.getCustomCommand(), args);
            return createFutureWithResult(RESULT_CODE_SUCCESS);
        }
        final ResolvableFuture<ControllerResult> result = ResolvableFuture.create();
        ResultReceiver cb = new ResultReceiver(mHandler) {

            @Override
            protected void onReceiveResult(int resultCode, Bundle resultData) {
                result.set(new ControllerResult(resultCode, resultData));
            }
        };
        mControllerCompat.sendCommand(command.getCustomCommand(), args, cb);
        return result;
    }
}
#end_block

#method_before
void onConnectedNotLocked() {
    if (DEBUG) {
        Log.d(TAG, "onConnectedNotLocked token=" + mToken);
    }
    final SessionCommandGroup.Builder commandsBuilder = new SessionCommandGroup.Builder();
    synchronized (mLock) {
        if (mIsReleased || mConnected) {
            return;
        }
        long sessionFlags = mControllerCompat.getFlags();
        boolean includePlaylistCommands = (sessionFlags & FLAG_HANDLES_QUEUE_COMMANDS) != 0;
        commandsBuilder.addAllPlayerCommands(COMMAND_VERSION_CURRENT, includePlaylistCommands);
        commandsBuilder.addAllVolumeCommands(COMMAND_VERSION_CURRENT);
        commandsBuilder.addAllSessionCommands(COMMAND_VERSION_CURRENT);
        commandsBuilder.removeCommand(COMMAND_CODE_PLAYER_SET_SPEED);
        commandsBuilder.removeCommand(COMMAND_CODE_SESSION_SUBSCRIBE_ROUTES_INFO);
        commandsBuilder.removeCommand(COMMAND_CODE_SESSION_UNSUBSCRIBE_ROUTES_INFO);
        commandsBuilder.removeCommand(COMMAND_CODE_SESSION_SELECT_ROUTE);
        commandsBuilder.addCommand(new SessionCommand(SESSION_COMMAND_ON_EXTRA_CHANGED, null));
        commandsBuilder.addCommand(new SessionCommand(SESSION_COMMAND_ON_CAPTIONING_ENABLED_CHANGED, null));
        mAllowedCommands = commandsBuilder.build();
        mPlaybackStateCompat = mControllerCompat.getPlaybackState();
        if (mPlaybackStateCompat == null) {
            mPlayerState = PLAYER_STATE_IDLE;
            mBufferedPosition = UNKNOWN_TIME;
        } else {
            mPlayerState = MediaUtils.convertToPlayerState(mPlaybackStateCompat);
            mBufferedPosition = mPlaybackStateCompat.getBufferedPosition();
        }
        mPlaybackInfo = MediaUtils.toPlaybackInfo2(mControllerCompat.getPlaybackInfo());
        mRepeatMode = mControllerCompat.getRepeatMode();
        mShuffleMode = mControllerCompat.getShuffleMode();
        mQueue = MediaUtils.removeNullElements(mControllerCompat.getQueue());
        if (mQueue == null || mQueue.size() == 0) {
            // MediaSessionCompat can set queue as null or empty. However, SessionPlayer should
            // not set playlist as null or empty. Therefore, we treat them as the same.
            mQueue = null;
            mPlaylist = null;
        } else {
            mPlaylist = MediaUtils.convertQueueItemListToMediaItemList(mQueue);
        }
        mPlaylistMetadata = MediaUtils.convertToMediaMetadata(mControllerCompat.getQueueTitle());
        // Call this after set playlist.
        setCurrentMediaItemLocked(mControllerCompat.getMetadata());
        mConnected = true;
    }
    mCallbackExecutor.execute(new Runnable() {

        @Override
        public void run() {
            mCallback.onConnected(mInstance, commandsBuilder.build());
        }
    });
}
#method_after
void onConnectedNotLocked() {
    if (DEBUG) {
        Log.d(TAG, "onConnectedNotLocked token=" + mToken);
    }
    final SessionCommandGroup allowedCommands;
    final List<CommandButton> customLayout;
    synchronized (mLock) {
        if (mIsReleased || mConnected) {
            return;
        }
        mPlaybackStateCompat = mControllerCompat.getPlaybackState();
        mAllowedCommands = MediaUtils.convertToSessionCommandGroup(mControllerCompat.getFlags(), mPlaybackStateCompat);
        mPlayerState = MediaUtils.convertToPlayerState(mPlaybackStateCompat);
        mBufferedPosition = mPlaybackStateCompat == null ? UNKNOWN_TIME : mPlaybackStateCompat.getBufferedPosition();
        mCustomLayout = MediaUtils.convertToCustomLayout(mPlaybackStateCompat);
        allowedCommands = mAllowedCommands;
        customLayout = mCustomLayout;
        mPlaybackInfo = MediaUtils.toPlaybackInfo2(mControllerCompat.getPlaybackInfo());
        mRepeatMode = mControllerCompat.getRepeatMode();
        mShuffleMode = mControllerCompat.getShuffleMode();
        mQueue = MediaUtils.removeNullElements(mControllerCompat.getQueue());
        if (mQueue == null || mQueue.size() == 0) {
            // MediaSessionCompat can set queue as null or empty. However, SessionPlayer should
            // not set playlist as null or empty. Therefore, we treat them as the same.
            mQueue = null;
            mPlaylist = null;
        } else {
            mPlaylist = MediaUtils.convertQueueItemListToMediaItemList(mQueue);
        }
        mPlaylistMetadata = MediaUtils.convertToMediaMetadata(mControllerCompat.getQueueTitle());
        // Call this after set playlist.
        setCurrentMediaItemLocked(mControllerCompat.getMetadata());
        mConnected = true;
    }
    mCallbackExecutor.execute(new Runnable() {

        @Override
        public void run() {
            mCallback.onConnected(mInstance, allowedCommands);
        }
    });
    if (!customLayout.isEmpty()) {
        mCallbackExecutor.execute(new Runnable() {

            @Override
            public void run() {
                mCallback.onSetCustomLayout(mInstance, customLayout);
            }
        });
    }
}
#end_block

#method_before
@Override
public void onPlaybackStateChanged(final PlaybackStateCompat state) {
    final PlaybackStateCompat prevState;
    final MediaItem prevItem;
    final MediaItem currentItem;
    synchronized (mLock) {
        prevItem = mCurrentMediaItem;
        prevState = mPlaybackStateCompat;
        mPlaybackStateCompat = state;
        mPlayerState = MediaUtils.convertToPlayerState(state);
        mBufferedPosition = state == null ? UNKNOWN_TIME : state.getBufferedPosition();
        if (mQueue != null && state != null) {
            for (int i = 0; i < mQueue.size(); ++i) {
                if (mQueue.get(i).getQueueId() == state.getActiveQueueItemId()) {
                    mCurrentMediaItemIndex = i;
                    mCurrentMediaItem = mPlaylist.get(i);
                }
            }
        }
        currentItem = mCurrentMediaItem;
    }
    if (prevItem != currentItem) {
        mCallbackExecutor.execute(new Runnable() {

            @Override
            public void run() {
                mCallback.onCurrentMediaItemChanged(mInstance, currentItem);
            }
        });
    }
    if (state == null) {
        if (prevState != null) {
            mCallbackExecutor.execute(new Runnable() {

                @Override
                public void run() {
                    mCallback.onPlayerStateChanged(mInstance, PLAYER_STATE_IDLE);
                }
            });
        }
        return;
    }
    if (prevState == null || prevState.getState() != state.getState()) {
        mCallbackExecutor.execute(new Runnable() {

            @Override
            public void run() {
                mCallback.onPlayerStateChanged(mInstance, MediaUtils.convertToPlayerState(state));
            }
        });
    }
    if (prevState == null || prevState.getPlaybackSpeed() != state.getPlaybackSpeed()) {
        mCallbackExecutor.execute(new Runnable() {

            @Override
            public void run() {
                mCallback.onPlaybackSpeedChanged(mInstance, state.getPlaybackSpeed());
            }
        });
    }
    if (prevState != null) {
        final long currentPosition = state.getCurrentPosition(mInstance.mTimeDiff);
        long positionDiff = Math.abs(currentPosition - prevState.getCurrentPosition(mInstance.mTimeDiff));
        if (positionDiff > POSITION_DIFF_TOLERANCE) {
            mCallbackExecutor.execute(new Runnable() {

                @Override
                public void run() {
                    mCallback.onSeekCompleted(mInstance, currentPosition);
                }
            });
        }
    }
    if (currentItem == null) {
        return;
    }
    // Update buffering state if needed
    final int bufferingState = MediaUtils.toBufferingState(state.getState());
    final int prevBufferingState = prevState == null ? SessionPlayer.BUFFERING_STATE_UNKNOWN : MediaUtils.toBufferingState(prevState.getState());
    if (bufferingState != prevBufferingState) {
        mCallbackExecutor.execute(new Runnable() {

            @Override
            public void run() {
                mCallback.onBufferingStateChanged(mInstance, currentItem, bufferingState);
            }
        });
    }
}
#method_after
@Override
public void onPlaybackStateChanged(final PlaybackStateCompat state) {
    final PlaybackStateCompat prevState;
    final MediaItem prevItem;
    final MediaItem currentItem;
    final List<CommandButton> prevLayout;
    final List<CommandButton> currentLayout;
    final SessionCommandGroup prevAllowedCommands;
    final SessionCommandGroup currentAllowedCommands;
    synchronized (mLock) {
        prevItem = mCurrentMediaItem;
        prevState = mPlaybackStateCompat;
        mPlaybackStateCompat = state;
        mPlayerState = MediaUtils.convertToPlayerState(state);
        mBufferedPosition = state == null ? UNKNOWN_TIME : state.getBufferedPosition();
        if (mQueue != null && state != null) {
            for (int i = 0; i < mQueue.size(); ++i) {
                if (mQueue.get(i).getQueueId() == state.getActiveQueueItemId()) {
                    mCurrentMediaItemIndex = i;
                    mCurrentMediaItem = mPlaylist.get(i);
                }
            }
        }
        currentItem = mCurrentMediaItem;
        prevLayout = mCustomLayout;
        mCustomLayout = MediaUtils.convertToCustomLayout(state);
        currentLayout = mCustomLayout;
        prevAllowedCommands = mAllowedCommands;
        mAllowedCommands = MediaUtils.convertToSessionCommandGroup(mControllerCompat.getFlags(), mPlaybackStateCompat);
        currentAllowedCommands = mAllowedCommands;
    }
    if (prevItem != currentItem) {
        mCallbackExecutor.execute(new Runnable() {

            @Override
            public void run() {
                mCallback.onCurrentMediaItemChanged(mInstance, currentItem);
            }
        });
    }
    if (state == null) {
        if (prevState != null) {
            mCallbackExecutor.execute(new Runnable() {

                @Override
                public void run() {
                    mCallback.onPlayerStateChanged(mInstance, PLAYER_STATE_IDLE);
                }
            });
        }
        return;
    }
    if (prevState == null || prevState.getState() != state.getState()) {
        mCallbackExecutor.execute(new Runnable() {

            @Override
            public void run() {
                mCallback.onPlayerStateChanged(mInstance, MediaUtils.convertToPlayerState(state));
            }
        });
    }
    if (prevState == null || prevState.getPlaybackSpeed() != state.getPlaybackSpeed()) {
        mCallbackExecutor.execute(new Runnable() {

            @Override
            public void run() {
                mCallback.onPlaybackSpeedChanged(mInstance, state.getPlaybackSpeed());
            }
        });
    }
    if (prevState != null) {
        final long currentPosition = state.getCurrentPosition(mInstance.mTimeDiff);
        long positionDiff = Math.abs(currentPosition - prevState.getCurrentPosition(mInstance.mTimeDiff));
        if (positionDiff > POSITION_DIFF_TOLERANCE) {
            mCallbackExecutor.execute(new Runnable() {

                @Override
                public void run() {
                    mCallback.onSeekCompleted(mInstance, currentPosition);
                }
            });
        }
    }
    Set<SessionCommand> prevCommands = prevAllowedCommands.getCommands();
    Set<SessionCommand> currentCommands = currentAllowedCommands.getCommands();
    if (prevCommands.size() != currentCommands.size() || !prevCommands.containsAll(currentCommands)) {
        mCallbackExecutor.execute(new Runnable() {

            @Override
            public void run() {
                mCallback.onAllowedCommandsChanged(mInstance, currentAllowedCommands);
            }
        });
    }
    boolean layoutChanged;
    if (prevLayout.size() == currentLayout.size()) {
        layoutChanged = false;
        for (int i = 0; i < currentLayout.size(); i++) {
            if (!ObjectsCompat.equals(prevLayout.get(i).getCommand(), currentLayout.get(i).getCommand())) {
                layoutChanged = true;
                break;
            }
        }
    } else {
        layoutChanged = true;
    }
    if (layoutChanged) {
        mCallbackExecutor.execute(new Runnable() {

            @Override
            public void run() {
                mCallback.onSetCustomLayout(mInstance, currentLayout);
            }
        });
    }
    if (currentItem == null) {
        return;
    }
    // Update buffering state if needed
    final int bufferingState = MediaUtils.toBufferingState(state.getState());
    final int prevBufferingState = prevState == null ? SessionPlayer.BUFFERING_STATE_UNKNOWN : MediaUtils.toBufferingState(prevState.getState());
    if (bufferingState != prevBufferingState) {
        mCallbackExecutor.execute(new Runnable() {

            @Override
            public void run() {
                mCallback.onBufferingStateChanged(mInstance, currentItem, bufferingState);
            }
        });
    }
}
#end_block

#method_before
@Override
public void onExtrasChanged(final Bundle extras) {
    mCallbackExecutor.execute(new Runnable() {

        @Override
        public void run() {
            mCallback.onCustomCommand(mInstance, new SessionCommand(SESSION_COMMAND_ON_EXTRA_CHANGED, null), extras);
        }
    });
}
#method_after
@Override
public void onExtrasChanged(final Bundle extras) {
    mCallbackExecutor.execute(new Runnable() {

        @Override
        public void run() {
            mCallback.onCustomCommand(mInstance, new SessionCommand(SESSION_COMMAND_ON_EXTRAS_CHANGED, null), extras);
        }
    });
}
#end_block

#method_before
@Override
public void onCaptioningEnabledChanged(boolean enabled) {
    mCallbackExecutor.execute(new Runnable() {

        @Override
        public void run() {
            mCallback.onCustomCommand(mInstance, new SessionCommand(SESSION_COMMAND_ON_CAPTIONING_ENABLED_CHANGED, null), null);
        }
    });
}
#method_after
@Override
public void onCaptioningEnabledChanged(final boolean enabled) {
    mCallbackExecutor.execute(new Runnable() {

        @Override
        public void run() {
            mCallback.onCustomCommand(mInstance, new SessionCommand(SESSION_COMMAND_ON_CAPTIONING_ENABLED_CHANGED, null), null);
        }
    });
}
#end_block

#method_before
@Test
public void testAddOnSessionTokensChangedListener() throws InterruptedException {
// prepareLooper();
// TokensChangedListener listener = new TokensChangedListener();
// mManager.addOnSessionTokensChangedListener(sHandlerExecutor, listener);
// 
// listener.reset();
// MediaSession session1 = new MediaSession.Builder(mContext)
// .setPlayer(new MockPlayer(0))
// .setId(UUID.randomUUID().toString())
// .build();
// assertTrue(listener.await());
// assertTrue(listener.findToken(session1.getToken()));
// 
// listener.reset();
// session1.close();
// assertTrue(listener.await());
// assertFalse(listener.findToken(session1.getToken()));
// 
// listener.reset();
// MediaSession session2 = new MediaSession.Builder(mContext)
// .setPlayer(new MockPlayer(0))
// .setId(UUID.randomUUID().toString())
// .build();
// assertTrue(listener.await());
// assertFalse(listener.findToken(session1.getToken()));
// assertTrue(listener.findToken(session2.getToken()));
// 
// listener.reset();
// MediaSession session3 = new MediaSession.Builder(mContext)
// .setPlayer(new MockPlayer(0))
// .setId(UUID.randomUUID().toString())
// .build();
// assertTrue(listener.await());
// assertFalse(listener.findToken(session1.getToken()));
// assertTrue(listener.findToken(session2.getToken()));
// assertTrue(listener.findToken(session3.getToken()));
// 
// listener.reset();
// session2.close();
// assertTrue(listener.await());
// assertFalse(listener.findToken(session1.getToken()));
// assertFalse(listener.findToken(session2.getToken()));
// assertTrue(listener.findToken(session3.getToken()));
// 
// listener.reset();
// session3.close();
// assertTrue(listener.await());
// assertFalse(listener.findToken(session1.getToken()));
// assertFalse(listener.findToken(session2.getToken()));
// assertFalse(listener.findToken(session3.getToken()));
// 
// mManager.removeOnSessionTokensChangedListener(listener);
}
#method_after
@Test
public void testAddOnSessionTokensChangedListener() throws InterruptedException {
// prepareLooper();
// TokensChangedListener listener = new TokensChangedListener();
// mManager.addOnSessionTokensChangedListener(sHandlerExecutor, listener);
// 
// listener.reset();
// MediaSession session1 = new MediaSession.Builder(mContext)
// .setPlayer(new MockPlayer(0))
// .setId(UUID.randomUUID().toString())
// .build();
// assertTrue(listener.await());
// assertTrue(listener.findToken(session1.getToken()));
// 
// listener.reset();
// session1.close();
// assertTrue(listener.await());
// assertFalse(listener.findToken(session1.getToken()));
// 
// listener.reset();
// MediaSession session = new MediaSession.Builder(mContext)
// .setPlayer(new MockPlayer(0))
// .setId(UUID.randomUUID().toString())
// .build();
// assertTrue(listener.await());
// assertFalse(listener.findToken(session1.getToken()));
// assertTrue(listener.findToken(session.getToken()));
// 
// listener.reset();
// MediaSession session3 = new MediaSession.Builder(mContext)
// .setPlayer(new MockPlayer(0))
// .setId(UUID.randomUUID().toString())
// .build();
// assertTrue(listener.await());
// assertFalse(listener.findToken(session1.getToken()));
// assertTrue(listener.findToken(session.getToken()));
// assertTrue(listener.findToken(session3.getToken()));
// 
// listener.reset();
// session.close();
// assertTrue(listener.await());
// assertFalse(listener.findToken(session1.getToken()));
// assertFalse(listener.findToken(session.getToken()));
// assertTrue(listener.findToken(session3.getToken()));
// 
// listener.reset();
// session3.close();
// assertTrue(listener.await());
// assertFalse(listener.findToken(session1.getToken()));
// assertFalse(listener.findToken(session.getToken()));
// assertFalse(listener.findToken(session3.getToken()));
// 
// mManager.removeOnSessionTokensChangedListener(listener);
}
#end_block

#method_before
@Test
public void testRemoveOnSessionTokensChangedListener() throws InterruptedException {
// prepareLooper();
// TokensChangedListener listener = new TokensChangedListener();
// mManager.addOnSessionTokensChangedListener(sHandlerExecutor, listener);
// 
// listener.reset();
// MediaSession session1 = new MediaSession.Builder(mContext)
// .setPlayer(new MockPlayer(0))
// .setId(UUID.randomUUID().toString())
// .build();
// assertTrue(listener.await());
// 
// mManager.removeOnSessionTokensChangedListener(listener);
// 
// listener.reset();
// session1.close();
// assertFalse(listener.await());
// 
// listener.reset();
// MediaSession session2 = new MediaSession.Builder(mContext)
// .setPlayer(new MockPlayer(0))
// .setId(UUID.randomUUID().toString())
// .build();
// assertFalse(listener.await());
// 
// listener.reset();
// MediaSession session3 = new MediaSession.Builder(mContext)
// .setPlayer(new MockPlayer(0))
// .setId(UUID.randomUUID().toString())
// .build();
// assertFalse(listener.await());
// 
// listener.reset();
// session2.close();
// assertFalse(listener.await());
// 
// listener.reset();
// session3.close();
// assertFalse(listener.await());
}
#method_after
@Test
public void testRemoveOnSessionTokensChangedListener() throws InterruptedException {
// prepareLooper();
// TokensChangedListener listener = new TokensChangedListener();
// mManager.addOnSessionTokensChangedListener(sHandlerExecutor, listener);
// 
// listener.reset();
// MediaSession session1 = new MediaSession.Builder(mContext)
// .setPlayer(new MockPlayer(0))
// .setId(UUID.randomUUID().toString())
// .build();
// assertTrue(listener.await());
// 
// mManager.removeOnSessionTokensChangedListener(listener);
// 
// listener.reset();
// session1.close();
// assertFalse(listener.await());
// 
// listener.reset();
// MediaSession session = new MediaSession.Builder(mContext)
// .setPlayer(new MockPlayer(0))
// .setId(UUID.randomUUID().toString())
// .build();
// assertFalse(listener.await());
// 
// listener.reset();
// MediaSession session3 = new MediaSession.Builder(mContext)
// .setPlayer(new MockPlayer(0))
// .setId(UUID.randomUUID().toString())
// .build();
// assertFalse(listener.await());
// 
// listener.reset();
// session.close();
// assertFalse(listener.await());
// 
// listener.reset();
// session3.close();
// assertFalse(listener.await());
}
#end_block

#method_before
public static void assertMetadataEquals(MediaMetadata a, MediaMetadata b) {
    if (a == null || b == null) {
        assertEquals(a, b);
    } else {
        assertTrue(TestUtils.equals(a.toBundle(), b.toBundle()));
    }
}
#method_after
public static void assertMetadataEquals(MediaMetadata expected, MediaMetadata actual) {
    if (expected == null || actual == null) {
        assertEquals(expected, actual);
    } else {
        Set<String> expectedKeySet = expected.keySet();
        Set<String> actualKeySet = actual.keySet();
        assertEquals(expectedKeySet, actualKeySet);
        for (String key : expectedKeySet) {
            assertEquals(expected.getObject(key), actual.getObject(key));
        }
    }
}
#end_block

#method_before
@Before
public void setup() throws Throwable {
    mContext = InstrumentationRegistry.getTargetContext();
    mMainHandlerExecutor = ContextCompat.getMainExecutor(mContext);
    mInstrumentation = InstrumentationRegistry.getInstrumentation();
    mActivity = mActivityRule.getActivity();
    mVideoView = mActivity.findViewById(R.id.videoview);
    mMediaItem = createTestMediaItem2();
    setKeepScreenOn();
    checkAttachedToWindow();
    mControllerCallback = mock(MediaController.ControllerCallback.class);
    when(mControllerCallback.onCustomCommand(nullable(MediaController.class), nullable(SessionCommand.class), nullable(Bundle.class))).thenReturn(new ControllerResult(ControllerResult.RESULT_CODE_SUCCESS, null));
    mController = new MediaController(mVideoView.getContext(), mVideoView.getMediaSessionToken2(), mMainHandlerExecutor, mControllerCallback);
}
#method_after
@Before
public void setup() throws Throwable {
    mContext = InstrumentationRegistry.getTargetContext();
    mMainHandlerExecutor = ContextCompat.getMainExecutor(mContext);
    mInstrumentation = InstrumentationRegistry.getInstrumentation();
    mActivity = mActivityRule.getActivity();
    mVideoView = mActivity.findViewById(R.id.videoview);
    mMediaItem = createTestMediaItem2();
    setKeepScreenOn();
    checkAttachedToWindow();
    mControllerCallback = mock(MediaController.ControllerCallback.class);
    when(mControllerCallback.onCustomCommand(nullable(MediaController.class), nullable(SessionCommand.class), nullable(Bundle.class))).thenReturn(new ControllerResult(ControllerResult.RESULT_CODE_SUCCESS, null));
    mController = new MediaController(mVideoView.getContext(), mVideoView.getSessionToken(), mMainHandlerExecutor, mControllerCallback);
}
#end_block

#method_before
@Test
public void testPlayVideo() throws Throwable {
    // Don't run the test if the codec isn't supported.
    if (!hasCodec()) {
        Log.i(TAG, "SKIPPING testPlayVideo(): codec is not supported");
        return;
    }
    mActivityRule.runOnUiThread(new Runnable() {

        @Override
        public void run() {
            mVideoView.setMediaItem2(mMediaItem);
        }
    });
    verify(mControllerCallback, timeout(TIME_OUT).atLeastOnce()).onConnected(any(MediaController.class), any(SessionCommandGroup.class));
    verify(mControllerCallback, timeout(TIME_OUT).atLeastOnce()).onPlayerStateChanged(any(MediaController.class), eq(SessionPlayer.PLAYER_STATE_PAUSED));
    mController.play();
    verify(mControllerCallback, timeout(TIME_OUT).atLeastOnce()).onPlayerStateChanged(any(MediaController.class), eq(SessionPlayer.PLAYER_STATE_PLAYING));
}
#method_after
@Test
public void testPlayVideo() throws Throwable {
    // Don't run the test if the codec isn't supported.
    if (!hasCodec()) {
        Log.i(TAG, "SKIPPING testPlayVideo(): codec is not supported");
        return;
    }
    mActivityRule.runOnUiThread(new Runnable() {

        @Override
        public void run() {
            mVideoView.setMediaItem(mMediaItem);
        }
    });
    verify(mControllerCallback, timeout(TIME_OUT).atLeastOnce()).onConnected(any(MediaController.class), any(SessionCommandGroup.class));
    verify(mControllerCallback, timeout(TIME_OUT).atLeastOnce()).onPlayerStateChanged(any(MediaController.class), eq(SessionPlayer.PLAYER_STATE_PAUSED));
    mController.play();
    verify(mControllerCallback, timeout(TIME_OUT).atLeastOnce()).onPlayerStateChanged(any(MediaController.class), eq(SessionPlayer.PLAYER_STATE_PLAYING));
}
#end_block

#method_before
@Test
public void testSetMediaItem2() throws Throwable {
    // Don't run the test if the codec isn't supported.
    if (!hasCodec()) {
        Log.i(TAG, "SKIPPING testPlayVideo(): codec is not supported");
        return;
    }
    mActivityRule.runOnUiThread(new Runnable() {

        @Override
        public void run() {
            mVideoView.setMediaItem2(mMediaItem);
        }
    });
    verify(mControllerCallback, timeout(TIME_OUT).atLeastOnce()).onConnected(any(MediaController.class), any(SessionCommandGroup.class));
    verify(mControllerCallback, timeout(TIME_OUT).atLeastOnce()).onPlayerStateChanged(any(MediaController.class), eq(SessionPlayer.PLAYER_STATE_PAUSED));
    verify(mControllerCallback, after(TIME_OUT).never()).onPlayerStateChanged(any(MediaController.class), eq(SessionPlayer.PLAYER_STATE_PLAYING));
    assertEquals(SessionPlayer.PLAYER_STATE_PAUSED, mController.getPlayerState());
}
#method_after
@Test
public void testSetMediaItem2() throws Throwable {
    // Don't run the test if the codec isn't supported.
    if (!hasCodec()) {
        Log.i(TAG, "SKIPPING testPlayVideo(): codec is not supported");
        return;
    }
    mActivityRule.runOnUiThread(new Runnable() {

        @Override
        public void run() {
            mVideoView.setMediaItem(mMediaItem);
        }
    });
    verify(mControllerCallback, timeout(TIME_OUT).atLeastOnce()).onConnected(any(MediaController.class), any(SessionCommandGroup.class));
    verify(mControllerCallback, timeout(TIME_OUT).atLeastOnce()).onPlayerStateChanged(any(MediaController.class), eq(SessionPlayer.PLAYER_STATE_PAUSED));
    verify(mControllerCallback, after(TIME_OUT).never()).onPlayerStateChanged(any(MediaController.class), eq(SessionPlayer.PLAYER_STATE_PLAYING));
    assertEquals(SessionPlayer.PLAYER_STATE_PAUSED, mController.getPlayerState());
}
#end_block

#method_before
@Test
public void testPlayVideoWithMediaItemFromFileDescriptor() throws Throwable {
    // Don't run the test if the codec isn't supported.
    if (!hasCodec()) {
        Log.i(TAG, "SKIPPING testPlayVideoWithMediaItemFromFileDescriptor(): " + "codec is not supported");
        return;
    }
    AssetFileDescriptor afd = mContext.getResources().openRawResourceFd(R.raw.testvideo_with_2_subtitle_tracks);
    final MediaItem item = new FileMediaItem.Builder(afd.getFileDescriptor(), afd.getStartOffset(), afd.getLength()).build();
    mActivityRule.runOnUiThread(new Runnable() {

        @Override
        public void run() {
            mVideoView.setMediaItem2(item);
        }
    });
    verify(mControllerCallback, timeout(TIME_OUT).atLeastOnce()).onConnected(any(MediaController.class), any(SessionCommandGroup.class));
    verify(mControllerCallback, timeout(TIME_OUT).atLeastOnce()).onPlayerStateChanged(any(MediaController.class), eq(SessionPlayer.PLAYER_STATE_PAUSED));
    mController.play();
    verify(mControllerCallback, timeout(TIME_OUT).atLeastOnce()).onPlayerStateChanged(any(MediaController.class), eq(SessionPlayer.PLAYER_STATE_PLAYING));
}
#method_after
@Test
public void testPlayVideoWithMediaItemFromFileDescriptor() throws Throwable {
    // Don't run the test if the codec isn't supported.
    if (!hasCodec()) {
        Log.i(TAG, "SKIPPING testPlayVideoWithMediaItemFromFileDescriptor(): " + "codec is not supported");
        return;
    }
    AssetFileDescriptor afd = mContext.getResources().openRawResourceFd(R.raw.testvideo_with_2_subtitle_tracks);
    final MediaItem item = new FileMediaItem.Builder(afd.getFileDescriptor(), afd.getStartOffset(), afd.getLength()).build();
    mActivityRule.runOnUiThread(new Runnable() {

        @Override
        public void run() {
            mVideoView.setMediaItem(item);
        }
    });
    verify(mControllerCallback, timeout(TIME_OUT).atLeastOnce()).onConnected(any(MediaController.class), any(SessionCommandGroup.class));
    verify(mControllerCallback, timeout(TIME_OUT).atLeastOnce()).onPlayerStateChanged(any(MediaController.class), eq(SessionPlayer.PLAYER_STATE_PAUSED));
    mController.play();
    verify(mControllerCallback, timeout(TIME_OUT).atLeastOnce()).onPlayerStateChanged(any(MediaController.class), eq(SessionPlayer.PLAYER_STATE_PLAYING));
}
#end_block

#method_before
@Test
public void testPlayVideoOnTextureView() throws Throwable {
    // Don't run the test if the codec isn't supported.
    if (!hasCodec()) {
        Log.i(TAG, "SKIPPING testPlayVideoOnTextureView(): codec is not supported");
        return;
    }
    final VideoView2.OnViewTypeChangedListener mockViewTypeListener = mock(VideoView2.OnViewTypeChangedListener.class);
    // The default view type is surface view.
    assertEquals(mVideoView.getViewType(), mVideoView.VIEW_TYPE_SURFACEVIEW);
    mActivityRule.runOnUiThread(new Runnable() {

        @Override
        public void run() {
            mVideoView.setOnViewTypeChangedListener(mockViewTypeListener);
            mVideoView.setViewType(mVideoView.VIEW_TYPE_TEXTUREVIEW);
            mVideoView.setMediaItem2(mMediaItem);
        }
    });
    verify(mockViewTypeListener, timeout(TIME_OUT)).onViewTypeChanged(mVideoView, VideoView2.VIEW_TYPE_TEXTUREVIEW);
    verify(mControllerCallback, timeout(TIME_OUT).atLeastOnce()).onConnected(any(MediaController.class), any(SessionCommandGroup.class));
    verify(mControllerCallback, timeout(TIME_OUT).atLeast(1)).onPlayerStateChanged(any(MediaController.class), eq(SessionPlayer.PLAYER_STATE_PAUSED));
    mController.play();
    verify(mControllerCallback, timeout(TIME_OUT).atLeast(1)).onPlayerStateChanged(any(MediaController.class), eq(SessionPlayer.PLAYER_STATE_PLAYING));
}
#method_after
@Test
public void testPlayVideoOnTextureView() throws Throwable {
    // Don't run the test if the codec isn't supported.
    if (!hasCodec()) {
        Log.i(TAG, "SKIPPING testPlayVideoOnTextureView(): codec is not supported");
        return;
    }
    final VideoView2.OnViewTypeChangedListener mockViewTypeListener = mock(VideoView2.OnViewTypeChangedListener.class);
    // The default view type is surface view.
    assertEquals(mVideoView.getViewType(), mVideoView.VIEW_TYPE_SURFACEVIEW);
    mActivityRule.runOnUiThread(new Runnable() {

        @Override
        public void run() {
            mVideoView.setOnViewTypeChangedListener(mockViewTypeListener);
            mVideoView.setViewType(mVideoView.VIEW_TYPE_TEXTUREVIEW);
            mVideoView.setMediaItem(mMediaItem);
        }
    });
    verify(mockViewTypeListener, timeout(TIME_OUT)).onViewTypeChanged(mVideoView, VideoView2.VIEW_TYPE_TEXTUREVIEW);
    verify(mControllerCallback, timeout(TIME_OUT).atLeastOnce()).onConnected(any(MediaController.class), any(SessionCommandGroup.class));
    verify(mControllerCallback, timeout(TIME_OUT).atLeast(1)).onPlayerStateChanged(any(MediaController.class), eq(SessionPlayer.PLAYER_STATE_PAUSED));
    mController.play();
    verify(mControllerCallback, timeout(TIME_OUT).atLeast(1)).onPlayerStateChanged(any(MediaController.class), eq(SessionPlayer.PLAYER_STATE_PLAYING));
}
#end_block

#method_before
@Test
public void testSetViewType() throws Throwable {
    // Don't run the test if the codec isn't supported.
    if (!hasCodec()) {
        Log.i(TAG, "SKIPPING testPlayVideoOnTextureView(): codec is not supported");
        return;
    }
    final VideoView2.OnViewTypeChangedListener mockViewTypeListener = mock(VideoView2.OnViewTypeChangedListener.class);
    // The default view type is surface view.
    assertEquals(mVideoView.getViewType(), mVideoView.VIEW_TYPE_SURFACEVIEW);
    mActivityRule.runOnUiThread(new Runnable() {

        @Override
        public void run() {
            mVideoView.setOnViewTypeChangedListener(mockViewTypeListener);
            mVideoView.setViewType(mVideoView.VIEW_TYPE_TEXTUREVIEW);
            mVideoView.setViewType(mVideoView.VIEW_TYPE_SURFACEVIEW);
            mVideoView.setViewType(mVideoView.VIEW_TYPE_TEXTUREVIEW);
            mVideoView.setViewType(mVideoView.VIEW_TYPE_SURFACEVIEW);
            mVideoView.setMediaItem2(mMediaItem);
        }
    });
    verify(mControllerCallback, timeout(TIME_OUT).atLeastOnce()).onConnected(any(MediaController.class), any(SessionCommandGroup.class));
    verify(mControllerCallback, timeout(TIME_OUT).atLeast(1)).onPlayerStateChanged(any(MediaController.class), eq(SessionPlayer.PLAYER_STATE_PAUSED));
    assertEquals(mVideoView.getViewType(), mVideoView.VIEW_TYPE_SURFACEVIEW);
}
#method_after
@Test
public void testSetViewType() throws Throwable {
    // Don't run the test if the codec isn't supported.
    if (!hasCodec()) {
        Log.i(TAG, "SKIPPING testPlayVideoOnTextureView(): codec is not supported");
        return;
    }
    final VideoView2.OnViewTypeChangedListener mockViewTypeListener = mock(VideoView2.OnViewTypeChangedListener.class);
    // The default view type is surface view.
    assertEquals(mVideoView.getViewType(), mVideoView.VIEW_TYPE_SURFACEVIEW);
    mActivityRule.runOnUiThread(new Runnable() {

        @Override
        public void run() {
            mVideoView.setOnViewTypeChangedListener(mockViewTypeListener);
            mVideoView.setViewType(mVideoView.VIEW_TYPE_TEXTUREVIEW);
            mVideoView.setViewType(mVideoView.VIEW_TYPE_SURFACEVIEW);
            mVideoView.setViewType(mVideoView.VIEW_TYPE_TEXTUREVIEW);
            mVideoView.setViewType(mVideoView.VIEW_TYPE_SURFACEVIEW);
            mVideoView.setMediaItem(mMediaItem);
        }
    });
    verify(mControllerCallback, timeout(TIME_OUT).atLeastOnce()).onConnected(any(MediaController.class), any(SessionCommandGroup.class));
    verify(mControllerCallback, timeout(TIME_OUT).atLeast(1)).onPlayerStateChanged(any(MediaController.class), eq(SessionPlayer.PLAYER_STATE_PAUSED));
    assertEquals(mVideoView.getViewType(), mVideoView.VIEW_TYPE_SURFACEVIEW);
}
#end_block

#method_before
@Test
public void testSubtitleSelection() throws Throwable {
    if (!hasCodec()) {
        Log.i(TAG, "SKIPPING testSubtitleSelection(): codec is not supported");
        return;
    }
    mActivityRule.runOnUiThread(new Runnable() {

        @Override
        public void run() {
            mVideoView.setMediaItem2(mMediaItem);
        }
    });
    verify(mControllerCallback, timeout(TIME_OUT).atLeastOnce()).onConnected(any(MediaController.class), any(SessionCommandGroup.class));
    mController.play();
    // Verify the subtitle track count
    verify(mControllerCallback, timeout(TIME_OUT).atLeastOnce()).onCustomCommand(any(MediaController.class), argThat(new CommandMatcher(EVENT_UPDATE_TRACK_STATUS)), argThat(new CommandArgumentMatcher(KEY_SUBTITLE_TRACK_COUNT, 2)));
    // Select the first subtitle track
    Bundle extra = new Bundle();
    extra.putInt(KEY_SELECTED_SUBTITLE_INDEX, 0);
    mController.sendCustomCommand(new SessionCommand(COMMAND_SHOW_SUBTITLE, null), extra);
    verify(mControllerCallback, timeout(TIME_OUT).atLeastOnce()).onCustomCommand(any(MediaController.class), argThat(new CommandMatcher(EVENT_UPDATE_SUBTITLE_SELECTED)), argThat(new CommandArgumentMatcher(KEY_SELECTED_SUBTITLE_INDEX, 0)));
    // Select the second subtitle track
    extra.putInt(KEY_SELECTED_SUBTITLE_INDEX, 1);
    mController.sendCustomCommand(new SessionCommand(COMMAND_SHOW_SUBTITLE, null), extra);
    verify(mControllerCallback, timeout(TIME_OUT).atLeastOnce()).onCustomCommand(any(MediaController.class), argThat(new CommandMatcher(EVENT_UPDATE_SUBTITLE_SELECTED)), argThat(new CommandArgumentMatcher(KEY_SELECTED_SUBTITLE_INDEX, 1)));
    // Deselect subtitle track
    mController.sendCustomCommand(new SessionCommand(COMMAND_HIDE_SUBTITLE, null), null);
    verify(mControllerCallback, timeout(TIME_OUT).atLeastOnce()).onCustomCommand(any(MediaController.class), argThat(new CommandMatcher(EVENT_UPDATE_SUBTITLE_DESELECTED)), nullable(Bundle.class));
}
#method_after
@Test
public void testSubtitleSelection() throws Throwable {
    if (!hasCodec()) {
        Log.i(TAG, "SKIPPING testSubtitleSelection(): codec is not supported");
        return;
    }
    mActivityRule.runOnUiThread(new Runnable() {

        @Override
        public void run() {
            mVideoView.setMediaItem(mMediaItem);
        }
    });
    verify(mControllerCallback, timeout(TIME_OUT).atLeastOnce()).onConnected(any(MediaController.class), any(SessionCommandGroup.class));
    mController.play();
    // Verify the subtitle track count
    verify(mControllerCallback, timeout(TIME_OUT).atLeastOnce()).onCustomCommand(any(MediaController.class), argThat(new CommandMatcher(EVENT_UPDATE_TRACK_STATUS)), argThat(new CommandArgumentMatcher(KEY_SUBTITLE_TRACK_COUNT, 2)));
    // Select the first subtitle track
    Bundle extra = new Bundle();
    extra.putInt(KEY_SELECTED_SUBTITLE_INDEX, 0);
    mController.sendCustomCommand(new SessionCommand(COMMAND_SHOW_SUBTITLE, null), extra);
    verify(mControllerCallback, timeout(TIME_OUT).atLeastOnce()).onCustomCommand(any(MediaController.class), argThat(new CommandMatcher(EVENT_UPDATE_SUBTITLE_SELECTED)), argThat(new CommandArgumentMatcher(KEY_SELECTED_SUBTITLE_INDEX, 0)));
    // Select the second subtitle track
    extra.putInt(KEY_SELECTED_SUBTITLE_INDEX, 1);
    mController.sendCustomCommand(new SessionCommand(COMMAND_SHOW_SUBTITLE, null), extra);
    verify(mControllerCallback, timeout(TIME_OUT).atLeastOnce()).onCustomCommand(any(MediaController.class), argThat(new CommandMatcher(EVENT_UPDATE_SUBTITLE_SELECTED)), argThat(new CommandArgumentMatcher(KEY_SELECTED_SUBTITLE_INDEX, 1)));
    // Deselect subtitle track
    mController.sendCustomCommand(new SessionCommand(COMMAND_HIDE_SUBTITLE, null), null);
    verify(mControllerCallback, timeout(TIME_OUT).atLeastOnce()).onCustomCommand(any(MediaController.class), argThat(new CommandMatcher(EVENT_UPDATE_SUBTITLE_DESELECTED)), nullable(Bundle.class));
}
#end_block

#method_before
@Test
public void testSubclass_acrossProcessWithMediaUtils() {
    final UriMediaItem testUriItem = createUriMediaItem();
    // Mocks the binder call across the processes by using writeParcelable/readParcelable
    // which only happens between processes. Code snippets are copied from
    // VersionedParcelIntegTest#parcelCopy.
    final Parcel p = Parcel.obtain();
    p.writeParcelable(MediaUtils.toParcelable(testUriItem), 0);
    p.setDataPosition(0);
    final MediaItem testRemoteItem = MediaUtils.fromParcelable((ParcelImpl) p.readParcelable(MediaItem.class.getClassLoader()));
    assertFalse(testRemoteItem instanceof UriMediaItem);
    assertEquals(testUriItem.getStartPosition(), testRemoteItem.getStartPosition());
    assertEquals(testUriItem.getEndPosition(), testRemoteItem.getEndPosition());
    TestUtils.equals(testUriItem.getMetadata().toBundle(), testRemoteItem.getMetadata().toBundle());
}
#method_after
@Test
public void testSubclass_acrossProcessWithMediaUtils() {
    final UriMediaItem testUriItem = createUriMediaItem();
    // Mocks the binder call across the processes by using writeParcelable/readParcelable
    // which only happens between processes. Code snippets are copied from
    // VersionedParcelIntegTest#parcelCopy.
    final Parcel p = Parcel.obtain();
    p.writeParcelable(MediaUtils.toParcelable(testUriItem), 0);
    p.setDataPosition(0);
    final MediaItem testRemoteItem = MediaUtils.fromParcelable((ParcelImpl) p.readParcelable(MediaItem.class.getClassLoader()));
    assertFalse(testRemoteItem instanceof UriMediaItem);
    assertEquals(testUriItem.getStartPosition(), testRemoteItem.getStartPosition());
    assertEquals(testUriItem.getEndPosition(), testRemoteItem.getEndPosition());
    MediaTestUtils.assertMediaMetadataEquals(testUriItem.getMetadata(), testRemoteItem.getMetadata());
}
#end_block

#method_before
@Override
public void onSessionResult(int seq, ParcelImpl sessionResult) {
    if (sessionResult == null) {
        return;
    }
    final MediaControllerImplBase controller;
    try {
        controller = getController();
    } catch (IllegalStateException e) {
        Log.w(TAG, "Don't fail silently here. Highly likely a bug");
        return;
    }
    SessionResult result = MediaUtils.fromParcelable(sessionResult);
    if (result == null) {
        return;
    }
    mSequencedFutureManager.setFutureResult(seq, ControllerResult.from(result));
}
#method_after
@Override
public void onSessionResult(int seq, ParcelImpl sessionResult) {
    if (sessionResult == null) {
        return;
    }
    final long token = Binder.clearCallingIdentity();
    try {
        final MediaControllerImplBase controller;
        try {
            controller = getController();
        } catch (IllegalStateException e) {
            Log.w(TAG, "Don't fail silently here. Highly likely a bug");
            return;
        }
        SessionResult result = MediaUtils.fromParcelable(sessionResult);
        if (result == null) {
            return;
        }
        mSequencedFutureManager.setFutureResult(seq, ControllerResult.from(result));
    } finally {
        Binder.restoreCallingIdentity(token);
    }
}
#end_block

#method_before
@Override
public void onLibraryResult(int seq, ParcelImpl libraryResult) {
    if (libraryResult == null) {
        return;
    }
    try {
        final MediaBrowser browser = getBrowser();
    } catch (IllegalStateException e) {
        Log.w(TAG, "Don't fail silently here. Highly likely a bug");
        return;
    }
    LibraryResult result = MediaUtils.fromParcelable(libraryResult);
    if (result == null) {
        return;
    }
    mSequencedFutureManager.setFutureResult(seq, BrowserResult.from(result));
}
#method_after
@Override
public void onLibraryResult(int seq, ParcelImpl libraryResult) {
    if (libraryResult == null) {
        return;
    }
    final long token = Binder.clearCallingIdentity();
    try {
        try {
            final MediaBrowser browser = getBrowser();
        } catch (IllegalStateException e) {
            Log.w(TAG, "Don't fail silently here. Highly likely a bug");
            return;
        }
        LibraryResult result = MediaUtils.fromParcelable(libraryResult);
        if (result == null) {
            return;
        }
        mSequencedFutureManager.setFutureResult(seq, BrowserResult.from(result));
    } finally {
        Binder.restoreCallingIdentity(token);
    }
}
#end_block

#method_before
@Override
public void onCurrentMediaItemChanged(ParcelImpl item) {
    if (item == null) {
        return;
    }
    final MediaControllerImplBase controller;
    try {
        controller = getController();
    } catch (IllegalStateException e) {
        Log.w(TAG, "Don't fail silently here. Highly likely a bug");
        return;
    }
    controller.notifyCurrentMediaItemChanged((MediaItem) MediaUtils.fromParcelable(item));
}
#method_after
@Override
public void onCurrentMediaItemChanged(ParcelImpl item) {
    if (item == null) {
        return;
    }
    final long token = Binder.clearCallingIdentity();
    try {
        final MediaControllerImplBase controller;
        try {
            controller = getController();
        } catch (IllegalStateException e) {
            Log.w(TAG, "Don't fail silently here. Highly likely a bug");
            return;
        }
        controller.notifyCurrentMediaItemChanged((MediaItem) MediaUtils.fromParcelable(item));
    } finally {
        Binder.restoreCallingIdentity(token);
    }
}
#end_block

#method_before
@Override
public void onPlayerStateChanged(long eventTimeMs, long positionMs, int state) {
    final MediaControllerImplBase controller;
    try {
        controller = getController();
    } catch (IllegalStateException e) {
        Log.w(TAG, "Don't fail silently here. Highly likely a bug");
        return;
    }
    controller.notifyPlayerStateChanges(eventTimeMs, positionMs, state);
}
#method_after
@Override
public void onPlayerStateChanged(long eventTimeMs, long positionMs, int state) {
    final long token = Binder.clearCallingIdentity();
    try {
        final MediaControllerImplBase controller;
        try {
            controller = getController();
        } catch (IllegalStateException e) {
            Log.w(TAG, "Don't fail silently here. Highly likely a bug");
            return;
        }
        controller.notifyPlayerStateChanges(eventTimeMs, positionMs, state);
    } finally {
        Binder.restoreCallingIdentity(token);
    }
}
#end_block

#method_before
@Override
public void onPlaybackSpeedChanged(long eventTimeMs, long positionMs, float speed) {
    final MediaControllerImplBase controller;
    try {
        controller = getController();
    } catch (IllegalStateException e) {
        Log.w(TAG, "Don't fail silently here. Highly likely a bug");
        return;
    }
    controller.notifyPlaybackSpeedChanges(eventTimeMs, positionMs, speed);
}
#method_after
@Override
public void onPlaybackSpeedChanged(long eventTimeMs, long positionMs, float speed) {
    final long token = Binder.clearCallingIdentity();
    try {
        final MediaControllerImplBase controller;
        try {
            controller = getController();
        } catch (IllegalStateException e) {
            Log.w(TAG, "Don't fail silently here. Highly likely a bug");
            return;
        }
        controller.notifyPlaybackSpeedChanges(eventTimeMs, positionMs, speed);
    } finally {
        Binder.restoreCallingIdentity(token);
    }
}
#end_block

#method_before
@Override
public void onBufferingStateChanged(ParcelImpl item, @BuffState int state, long bufferedPositionMs) {
    if (item == null) {
        return;
    }
    final MediaControllerImplBase controller;
    try {
        controller = getController();
    } catch (IllegalStateException e) {
        Log.w(TAG, "Don't fail silently here. Highly likely a bug");
        return;
    }
    MediaItem item2 = MediaUtils.fromParcelable(item);
    if (item2 == null) {
        Log.w(TAG, "onBufferingStateChanged(): Ignoring null item");
        return;
    }
    controller.notifyBufferingStateChanged(item2, state, bufferedPositionMs);
}
#method_after
@Override
public void onBufferingStateChanged(ParcelImpl item, @BuffState int state, long bufferedPositionMs) {
    if (item == null) {
        return;
    }
    final long token = Binder.clearCallingIdentity();
    try {
        final MediaControllerImplBase controller;
        try {
            controller = getController();
        } catch (IllegalStateException e) {
            Log.w(TAG, "Don't fail silently here. Highly likely a bug");
            return;
        }
        MediaItem itemObj = MediaUtils.fromParcelable(item);
        if (itemObj == null) {
            Log.w(TAG, "onBufferingStateChanged(): Ignoring null item");
            return;
        }
        controller.notifyBufferingStateChanged(itemObj, state, bufferedPositionMs);
    } finally {
        Binder.restoreCallingIdentity(token);
    }
}
#end_block

#method_before
@Override
public void onPlaylistChanged(ParcelImplListSlice listSlice, ParcelImpl metadata) {
    if (metadata == null) {
        return;
    }
    final MediaControllerImplBase controller;
    try {
        controller = getController();
    } catch (IllegalStateException e) {
        Log.w(TAG, "Don't fail silently here. Highly likely a bug");
        return;
    }
    List<MediaItem> playlist = MediaUtils.convertParcelImplListSliceToMediaItemList(listSlice);
    controller.notifyPlaylistChanges(playlist, (MediaMetadata) MediaUtils.fromParcelable(metadata));
}
#method_after
@Override
public void onPlaylistChanged(ParcelImplListSlice listSlice, ParcelImpl metadata) {
    if (metadata == null) {
        return;
    }
    final long token = Binder.clearCallingIdentity();
    try {
        final MediaControllerImplBase controller;
        try {
            controller = getController();
        } catch (IllegalStateException e) {
            Log.w(TAG, "Don't fail silently here. Highly likely a bug");
            return;
        }
        List<MediaItem> playlist = MediaUtils.convertParcelImplListSliceToMediaItemList(listSlice);
        controller.notifyPlaylistChanges(playlist, (MediaMetadata) MediaUtils.fromParcelable(metadata));
    } finally {
        Binder.restoreCallingIdentity(token);
    }
}
#end_block

#method_before
@Override
public void onPlaylistMetadataChanged(ParcelImpl metadata) throws RuntimeException {
    if (metadata == null) {
        return;
    }
    final MediaControllerImplBase controller;
    try {
        controller = getController();
    } catch (IllegalStateException e) {
        Log.w(TAG, "Don't fail silently here. Highly likely a bug");
        return;
    }
    controller.notifyPlaylistMetadataChanges((MediaMetadata) MediaUtils.fromParcelable(metadata));
}
#method_after
@Override
public void onPlaylistMetadataChanged(ParcelImpl metadata) throws RuntimeException {
    if (metadata == null) {
        return;
    }
    final long token = Binder.clearCallingIdentity();
    try {
        final MediaControllerImplBase controller;
        try {
            controller = getController();
        } catch (IllegalStateException e) {
            Log.w(TAG, "Don't fail silently here. Highly likely a bug");
            return;
        }
        controller.notifyPlaylistMetadataChanges((MediaMetadata) MediaUtils.fromParcelable(metadata));
    } finally {
        Binder.restoreCallingIdentity(token);
    }
}
#end_block

#method_before
@Override
public void onRepeatModeChanged(int repeatMode) {
    final MediaControllerImplBase controller;
    try {
        controller = getController();
    } catch (IllegalStateException e) {
        Log.w(TAG, "Don't fail silently here. Highly likely a bug");
        return;
    }
    controller.notifyRepeatModeChanges(repeatMode);
}
#method_after
@Override
public void onRepeatModeChanged(int repeatMode) {
    final long token = Binder.clearCallingIdentity();
    try {
        final MediaControllerImplBase controller;
        try {
            controller = getController();
        } catch (IllegalStateException e) {
            Log.w(TAG, "Don't fail silently here. Highly likely a bug");
            return;
        }
        controller.notifyRepeatModeChanges(repeatMode);
    } finally {
        Binder.restoreCallingIdentity(token);
    }
}
#end_block

#method_before
@Override
public void onShuffleModeChanged(int shuffleMode) {
    final MediaControllerImplBase controller;
    try {
        controller = getController();
    } catch (IllegalStateException e) {
        Log.w(TAG, "Don't fail silently here. Highly likely a bug");
        return;
    }
    controller.notifyShuffleModeChanges(shuffleMode);
}
#method_after
@Override
public void onShuffleModeChanged(int shuffleMode) {
    final long token = Binder.clearCallingIdentity();
    try {
        final MediaControllerImplBase controller;
        try {
            controller = getController();
        } catch (IllegalStateException e) {
            Log.w(TAG, "Don't fail silently here. Highly likely a bug");
            return;
        }
        controller.notifyShuffleModeChanges(shuffleMode);
    } finally {
        Binder.restoreCallingIdentity(token);
    }
}
#end_block

#method_before
@Override
public void onPlaybackCompleted() {
    final MediaControllerImplBase controller;
    try {
        controller = getController();
    } catch (IllegalStateException e) {
        Log.w(TAG, "Don't fail silently here. Highly likely a bug");
        return;
    }
    controller.notifyPlaybackCompleted();
}
#method_after
@Override
public void onPlaybackCompleted() {
    final long token = Binder.clearCallingIdentity();
    try {
        final MediaControllerImplBase controller;
        try {
            controller = getController();
        } catch (IllegalStateException e) {
            Log.w(TAG, "Don't fail silently here. Highly likely a bug");
            return;
        }
        controller.notifyPlaybackCompleted();
    } finally {
        Binder.restoreCallingIdentity(token);
    }
}
#end_block

#method_before
@Override
public void onPlaybackInfoChanged(ParcelImpl playbackInfo) throws RuntimeException {
    if (playbackInfo == null) {
        return;
    }
    if (DEBUG) {
        Log.d(TAG, "onPlaybackInfoChanged");
    }
    final MediaControllerImplBase controller;
    try {
        controller = getController();
    } catch (IllegalStateException e) {
        Log.w(TAG, "Don't fail silently here. Highly likely a bug");
        return;
    }
    PlaybackInfo info = MediaUtils.fromParcelable(playbackInfo);
    if (info == null) {
        Log.w(TAG, "onPlaybackInfoChanged(): Ignoring null playbackInfo");
        return;
    }
    controller.notifyPlaybackInfoChanges(info);
}
#method_after
@Override
public void onPlaybackInfoChanged(ParcelImpl playbackInfo) throws RuntimeException {
    if (playbackInfo == null) {
        return;
    }
    if (DEBUG) {
        Log.d(TAG, "onPlaybackInfoChanged");
    }
    final long token = Binder.clearCallingIdentity();
    try {
        final MediaControllerImplBase controller;
        try {
            controller = getController();
        } catch (IllegalStateException e) {
            Log.w(TAG, "Don't fail silently here. Highly likely a bug");
            return;
        }
        PlaybackInfo info = MediaUtils.fromParcelable(playbackInfo);
        if (info == null) {
            Log.w(TAG, "onPlaybackInfoChanged(): Ignoring null playbackInfo");
            return;
        }
        controller.notifyPlaybackInfoChanges(info);
    } finally {
        Binder.restoreCallingIdentity(token);
    }
}
#end_block

#method_before
@Override
public void onSeekCompleted(long eventTimeMs, long positionMs, long seekPositionMs) {
    final MediaControllerImplBase controller;
    try {
        controller = getController();
    } catch (IllegalStateException e) {
        Log.w(TAG, "Don't fail silently here. Highly likely a bug");
        return;
    }
    controller.notifySeekCompleted(eventTimeMs, positionMs, seekPositionMs);
}
#method_after
@Override
public void onSeekCompleted(long eventTimeMs, long positionMs, long seekPositionMs) {
    final long token = Binder.clearCallingIdentity();
    try {
        final MediaControllerImplBase controller;
        try {
            controller = getController();
        } catch (IllegalStateException e) {
            Log.w(TAG, "Don't fail silently here. Highly likely a bug");
            return;
        }
        controller.notifySeekCompleted(eventTimeMs, positionMs, seekPositionMs);
    } finally {
        Binder.restoreCallingIdentity(token);
    }
}
#end_block

#method_before
@Override
public void onConnected(IMediaSession sessionBinder, ParcelImpl commandGroup, int playerState, ParcelImpl currentItem, long positionEventTimeMs, long positionMs, float playbackSpeed, long bufferedPositionMs, ParcelImpl playbackInfo, int shuffleMode, int repeatMode, ParcelImplListSlice listSlice, PendingIntent sessionActivity) {
    if (sessionBinder == null || commandGroup == null || currentItem == null || playbackInfo == null) {
        return;
    }
    final MediaControllerImplBase controller = mController.get();
    if (controller == null) {
        if (DEBUG) {
            Log.d(TAG, "onConnected after MediaController.close()");
        }
        return;
    }
    List<MediaItem> itemList = MediaUtils.convertParcelImplListSliceToMediaItemList(listSlice);
    controller.onConnectedNotLocked(sessionBinder, (SessionCommandGroup) MediaUtils.fromParcelable(commandGroup), playerState, (MediaItem) MediaUtils.fromParcelable(currentItem), positionEventTimeMs, positionMs, playbackSpeed, bufferedPositionMs, (PlaybackInfo) MediaUtils.fromParcelable(playbackInfo), repeatMode, shuffleMode, itemList, sessionActivity);
}
#method_after
@Override
public void onConnected(IMediaSession sessionBinder, ParcelImpl commandGroup, int playerState, ParcelImpl currentItem, long positionEventTimeMs, long positionMs, float playbackSpeed, long bufferedPositionMs, ParcelImpl playbackInfo, int shuffleMode, int repeatMode, ParcelImplListSlice listSlice, PendingIntent sessionActivity) {
    if (sessionBinder == null || commandGroup == null || currentItem == null || playbackInfo == null) {
        return;
    }
    final long token = Binder.clearCallingIdentity();
    try {
        final MediaControllerImplBase controller = mController.get();
        if (controller == null) {
            if (DEBUG) {
                Log.d(TAG, "onConnected after MediaController2.close()");
            }
            return;
        }
        List<MediaItem> itemList = MediaUtils.convertParcelImplListSliceToMediaItemList(listSlice);
        controller.onConnectedNotLocked(sessionBinder, (SessionCommandGroup) MediaUtils.fromParcelable(commandGroup), playerState, (MediaItem) MediaUtils.fromParcelable(currentItem), positionEventTimeMs, positionMs, playbackSpeed, bufferedPositionMs, (PlaybackInfo) MediaUtils.fromParcelable(playbackInfo), repeatMode, shuffleMode, itemList, sessionActivity);
    } finally {
        Binder.restoreCallingIdentity(token);
    }
}
#end_block

#method_before
@Override
public void onDisconnected() {
    final MediaControllerImplBase controller = mController.get();
    if (controller == null) {
        if (DEBUG) {
            Log.d(TAG, "onDisconnected after MediaController.close()");
        }
        return;
    }
    controller.getInstance().close();
}
#method_after
@Override
public void onDisconnected() {
    final long token = Binder.clearCallingIdentity();
    try {
        final MediaControllerImplBase controller = mController.get();
        if (controller == null) {
            if (DEBUG) {
                Log.d(TAG, "onDisconnected after MediaController2.close()");
            }
            return;
        }
        controller.getInstance().close();
    } finally {
        Binder.restoreCallingIdentity(token);
    }
}
#end_block

#method_before
@Override
public void onSetCustomLayout(int seq, List<ParcelImpl> commandButtonList) {
    if (commandButtonList == null) {
        Log.w(TAG, "setCustomLayout(): Ignoring null commandButtonList");
        return;
    }
    final MediaControllerImplBase controller;
    try {
        controller = getController();
    } catch (IllegalStateException e) {
        Log.w(TAG, "Don't fail silently here. Highly likely a bug");
        return;
    }
    if (controller == null) {
        // TODO(jaewan): Revisit here. Could be a bug
        return;
    }
    List<CommandButton> layout = new ArrayList<>();
    for (int i = 0; i < commandButtonList.size(); i++) {
        CommandButton button = MediaUtils.fromParcelable(commandButtonList.get(i));
        if (button != null) {
            layout.add(button);
        }
    }
    controller.onSetCustomLayout(seq, layout);
}
#method_after
@Override
public void onSetCustomLayout(int seq, List<ParcelImpl> commandButtonList) {
    if (commandButtonList == null) {
        Log.w(TAG, "setCustomLayout(): Ignoring null commandButtonList");
        return;
    }
    final long token = Binder.clearCallingIdentity();
    try {
        final MediaControllerImplBase controller;
        try {
            controller = getController();
        } catch (IllegalStateException e) {
            Log.w(TAG, "Don't fail silently here. Highly likely a bug");
            return;
        }
        if (controller == null) {
            // TODO(jaewan): Revisit here. Could be a bug
            return;
        }
        List<CommandButton> layout = new ArrayList<>();
        for (int i = 0; i < commandButtonList.size(); i++) {
            CommandButton button = MediaUtils.fromParcelable(commandButtonList.get(i));
            if (button != null) {
                layout.add(button);
            }
        }
        controller.onSetCustomLayout(seq, layout);
    } finally {
        Binder.restoreCallingIdentity(token);
    }
}
#end_block

#method_before
@Override
public void onAllowedCommandsChanged(ParcelImpl commands) {
    if (commands == null) {
        return;
    }
    final MediaControllerImplBase controller;
    try {
        controller = getController();
    } catch (IllegalStateException e) {
        Log.w(TAG, "Don't fail silently here. Highly likely a bug");
        return;
    }
    if (controller == null) {
        // TODO(jaewan): Revisit here. Could be a bug
        return;
    }
    SessionCommandGroup commandGroup = MediaUtils.fromParcelable(commands);
    if (commandGroup == null) {
        Log.w(TAG, "onAllowedCommandsChanged(): Ignoring null commands");
        return;
    }
    controller.onAllowedCommandsChanged(commandGroup);
}
#method_after
@Override
public void onAllowedCommandsChanged(ParcelImpl commands) {
    if (commands == null) {
        return;
    }
    final long token = Binder.clearCallingIdentity();
    try {
        final MediaControllerImplBase controller;
        try {
            controller = getController();
        } catch (IllegalStateException e) {
            Log.w(TAG, "Don't fail silently here. Highly likely a bug");
            return;
        }
        if (controller == null) {
            // TODO(jaewan): Revisit here. Could be a bug
            return;
        }
        SessionCommandGroup commandGroup = MediaUtils.fromParcelable(commands);
        if (commandGroup == null) {
            Log.w(TAG, "onAllowedCommandsChanged(): Ignoring null commands");
            return;
        }
        controller.onAllowedCommandsChanged(commandGroup);
    } finally {
        Binder.restoreCallingIdentity(token);
    }
}
#end_block

#method_before
@Override
public void onCustomCommand(int seq, ParcelImpl commandParcel, Bundle args) {
    if (commandParcel == null) {
        return;
    }
    final MediaControllerImplBase controller;
    try {
        controller = getController();
    } catch (IllegalStateException e) {
        Log.w(TAG, "Don't fail silently here. Highly likely a bug");
        return;
    }
    SessionCommand command = MediaUtils.fromParcelable(commandParcel);
    if (command == null) {
        Log.w(TAG, "sendCustomCommand(): Ignoring null command");
        return;
    }
    controller.onCustomCommand(seq, command, args);
}
#method_after
@Override
public void onCustomCommand(int seq, ParcelImpl commandParcel, Bundle args) {
    if (commandParcel == null) {
        return;
    }
    final long token = Binder.clearCallingIdentity();
    try {
        final MediaControllerImplBase controller;
        try {
            controller = getController();
        } catch (IllegalStateException e) {
            Log.w(TAG, "Don't fail silently here. Highly likely a bug");
            return;
        }
        SessionCommand command = MediaUtils.fromParcelable(commandParcel);
        if (command == null) {
            Log.w(TAG, "sendCustomCommand(): Ignoring null command");
            return;
        }
        controller.onCustomCommand(seq, command, args);
    } finally {
        Binder.restoreCallingIdentity(token);
    }
}
#end_block

#method_before
// //////////////////////////////////////////////////////////////////////////////////////////
// MediaBrowser specific
@Override
public void onSearchResultChanged(final String query, final int itemCount, final ParcelImpl libraryParams) throws RuntimeException {
    if (libraryParams == null) {
        return;
    }
    if (TextUtils.isEmpty(query)) {
        Log.w(TAG, "onSearchResultChanged(): Ignoring empty query");
        return;
    }
    if (itemCount < 0) {
        Log.w(TAG, "onSearchResultChanged(): Ignoring negative itemCount: " + itemCount);
        return;
    }
    final MediaBrowser browser;
    try {
        browser = getBrowser();
    } catch (IllegalStateException e) {
        Log.w(TAG, "Don't fail silently here. Highly likely a bug");
        return;
    }
    if (browser == null) {
        return;
    }
    browser.getCallbackExecutor().execute(new Runnable() {

        @Override
        public void run() {
            browser.getCallback().onSearchResultChanged(browser, query, itemCount, (LibraryParams) MediaUtils.fromParcelable(libraryParams));
        }
    });
}
#method_after
// //////////////////////////////////////////////////////////////////////////////////////////
// MediaBrowser specific
@Override
public void onSearchResultChanged(final String query, final int itemCount, final ParcelImpl libraryParams) throws RuntimeException {
    if (libraryParams == null) {
        return;
    }
    if (TextUtils.isEmpty(query)) {
        Log.w(TAG, "onSearchResultChanged(): Ignoring empty query");
        return;
    }
    if (itemCount < 0) {
        Log.w(TAG, "onSearchResultChanged(): Ignoring negative itemCount: " + itemCount);
        return;
    }
    final long token = Binder.clearCallingIdentity();
    try {
        final MediaBrowser browser;
        try {
            browser = getBrowser();
        } catch (IllegalStateException e) {
            Log.w(TAG, "Don't fail silently here. Highly likely a bug");
            return;
        }
        if (browser == null) {
            return;
        }
        browser.getCallbackExecutor().execute(new Runnable() {

            @Override
            public void run() {
                browser.getCallback().onSearchResultChanged(browser, query, itemCount, (LibraryParams) MediaUtils.fromParcelable(libraryParams));
            }
        });
    } finally {
        Binder.restoreCallingIdentity(token);
    }
}
#end_block

#method_before
@Override
public void onChildrenChanged(final String parentId, final int itemCount, final ParcelImpl libraryParams) {
    if (libraryParams == null) {
        return;
    }
    if (TextUtils.isEmpty(parentId)) {
        Log.w(TAG, "onChildrenChanged(): Ignoring empty parentId");
        return;
    }
    if (itemCount < 0) {
        Log.w(TAG, "onChildrenChanged(): Ignoring negative itemCount: " + itemCount);
        return;
    }
    final MediaBrowser browser;
    try {
        browser = getBrowser();
    } catch (IllegalStateException e) {
        Log.w(TAG, "Don't fail silently here. Highly likely a bug");
        return;
    }
    if (browser == null) {
        return;
    }
    browser.getCallbackExecutor().execute(new Runnable() {

        @Override
        public void run() {
            // TODO (b/118472216): Find all ParcelUtils.fromParcelable usages, and null check
            // before calling it.
            browser.getCallback().onChildrenChanged(browser, parentId, itemCount, (LibraryParams) MediaUtils.fromParcelable(libraryParams));
        }
    });
}
#method_after
@Override
public void onChildrenChanged(final String parentId, final int itemCount, final ParcelImpl libraryParams) {
    if (libraryParams == null) {
        return;
    }
    if (TextUtils.isEmpty(parentId)) {
        Log.w(TAG, "onChildrenChanged(): Ignoring empty parentId");
        return;
    }
    if (itemCount < 0) {
        Log.w(TAG, "onChildrenChanged(): Ignoring negative itemCount: " + itemCount);
        return;
    }
    final long token = Binder.clearCallingIdentity();
    try {
        final MediaBrowser browser;
        try {
            browser = getBrowser();
        } catch (IllegalStateException e) {
            Log.w(TAG, "Don't fail silently here. Highly likely a bug");
            return;
        }
        if (browser == null) {
            return;
        }
        browser.getCallbackExecutor().execute(new Runnable() {

            @Override
            public void run() {
                // TODO (b/118472216): Find all ParcelUtils.fromParcelable usages,
                // and null check before calling it.
                browser.getCallback().onChildrenChanged(browser, parentId, itemCount, (LibraryParams) MediaUtils.fromParcelable(libraryParams));
            }
        });
    } finally {
        Binder.restoreCallingIdentity(token);
    }
}
#end_block

#method_before
// Temporaily commenting out, since we don't have the Mock services yet.
// /**
// * Finds the session with id in this test package.
// *
// * @param context
// * @param id
// * @return
// */
// public static SessionToken getServiceToken(Context context, String id) {
// switch (id) {
// case MockMediaSessionService2.ID:
// return new SessionToken(context, new ComponentName(
// context.getPackageName(), MockMediaSessionService2.class.getName()));
// case MockMediaLibraryService.ID:
// return new SessionToken(context, new ComponentName(
// context.getPackageName(), MockMediaLibraryService.class.getName()));
// }
// fail("Unknown id=" + id);
// return null;
// }
public static List<MediaItem> createFileMediaItems(int size) {
    final List<MediaItem> list = new ArrayList<>();
    String caller = Thread.currentThread().getStackTrace()[1].getMethodName();
    for (int i = 0; i < size; i++) {
        list.add(new FileMediaItem.Builder(new FileDescriptor()).setMetadata(new MediaMetadata.Builder().putString(MediaMetadata.METADATA_KEY_MEDIA_ID, caller + "_item_" + (i + 1)).build()).build());
    }
    return list;
}
#method_after
// Temporaily commenting out, since we don't have the Mock services yet.
// /**
// * Finds the session with id in this test package.
// *
// * @param context
// * @param id
// * @return
// */
// public static SessionToken2 getServiceToken(Context context, String id) {
// switch (id) {
// case MockMediaSessionService.ID:
// return new SessionToken2(context, new ComponentName(
// context.getPackageName(), MockMediaSessionService.class.getName()));
// case MockMediaLibraryService.ID:
// return new SessionToken2(context, new ComponentName(
// context.getPackageName(), MockMediaLibraryService.class.getName()));
// }
// fail("Unknown id=" + id);
// return null;
// }
public static List<MediaItem> createFileMediaItems(int size) {
    final List<MediaItem> list = new ArrayList<>();
    String caller = Thread.currentThread().getStackTrace()[1].getMethodName();
    for (int i = 0; i < size; i++) {
        list.add(new FileMediaItem.Builder(new FileDescriptor()).setMetadata(new MediaMetadata.Builder().putString(MediaMetadata.METADATA_KEY_MEDIA_ID, caller + "_item_" + (i + 1)).build()).build());
    }
    return list;
}
#end_block

#method_before
@Test
public void testOnGetRootCalledByGetLibraryRoot() throws InterruptedException {
    prepareLooper();
    final String testMediaId = "testOnGetRootCalledByGetLibraryRoot";
    final Bundle testExtras = new Bundle();
    testExtras.putString(testMediaId, testMediaId);
    final LibraryParams testParams = new LibraryParams.Builder().setSuggested(true).setExtras(testExtras).build();
    final CountDownLatch latch = new CountDownLatch(1);
    MockMediaBrowserServiceCompat.setMediaBrowserServiceProxy(new Proxy() {

        @Override
        public BrowserRoot onGetRoot(String clientPackageName, int clientUid, Bundle rootHints) {
            assertEquals(CLIENT_PACKAGE_NAME, clientPackageName);
            if (rootHints.keySet().contains(testMediaId)) {
                assertEqualLibraryParams(testParams, rootHints);
                // This should happen because getLibraryRoot() is called with testExtras.
                latch.countDown();
            }
            // For other random connection requests.
            return new BrowserRoot("rootId", null);
        }
    });
    RemoteMediaBrowser browser = new RemoteMediaBrowser(mContext, mToken, true);
    browser.getLibraryRoot(testParams);
    assertTrue(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
}
#method_after
@Test
public void testOnGetRootCalledByGetLibraryRoot() throws InterruptedException {
    prepareLooper();
    final String testMediaId = "testOnGetRootCalledByGetLibraryRoot";
    final Bundle testExtras = new Bundle();
    testExtras.putString(testMediaId, testMediaId);
    final LibraryParams testParams = new LibraryParams.Builder().setSuggested(true).setExtras(testExtras).build();
    final CountDownLatch latch = new CountDownLatch(1);
    MockMediaBrowserServiceCompat.setMediaBrowserServiceProxy(new Proxy() {

        @Override
        public BrowserRoot onGetRoot(String clientPackageName, int clientUid, Bundle rootHints) {
            assertEquals(CLIENT_PACKAGE_NAME, clientPackageName);
            if (rootHints.keySet().contains(testMediaId)) {
                MediaTestUtils.assertEqualLibraryParams(testParams, rootHints);
                // This should happen because getLibraryRoot() is called with testExtras.
                latch.countDown();
            }
            // For other random connection requests.
            return new BrowserRoot("rootId", null);
        }
    });
    RemoteMediaBrowser browser = new RemoteMediaBrowser(mContext, mToken, true);
    browser.getLibraryRoot(testParams);
    assertTrue(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
}
#end_block

#method_before
@Test
public void testOnLoadChildrenCalledBySubscribe() throws InterruptedException {
    prepareLooper();
    final String testParentId = "testOnLoadChildrenCalledBySubscribe";
    final LibraryParams testParams = createLibraryParams();
    final CountDownLatch subscribeLatch = new CountDownLatch(1);
    MockMediaBrowserServiceCompat.setMediaBrowserServiceProxy(new Proxy() {

        @Override
        public void onLoadChildren(String parentId, Result<List<MediaItem>> result, Bundle option) {
            assertEquals(testParentId, parentId);
            assertEqualLibraryParams(testParams, option);
            result.sendResult(null);
            subscribeLatch.countDown();
        }
    });
    RemoteMediaBrowser browser = new RemoteMediaBrowser(mContext, mToken, true);
    browser.subscribe(testParentId, testParams);
    assertTrue(subscribeLatch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
}
#method_after
@Test
public void testOnLoadChildrenCalledBySubscribe() throws InterruptedException {
    prepareLooper();
    final String testParentId = "testOnLoadChildrenCalledBySubscribe";
    final LibraryParams testParams = MediaTestUtils.createLibraryParams();
    final CountDownLatch subscribeLatch = new CountDownLatch(1);
    MockMediaBrowserServiceCompat.setMediaBrowserServiceProxy(new Proxy() {

        @Override
        public void onLoadChildren(String parentId, Result<List<MediaItem>> result, Bundle option) {
            assertEquals(testParentId, parentId);
            MediaTestUtils.assertEqualLibraryParams(testParams, option);
            result.sendResult(null);
            subscribeLatch.countDown();
        }
    });
    RemoteMediaBrowser browser = new RemoteMediaBrowser(mContext, mToken, true);
    browser.subscribe(testParentId, testParams);
    assertTrue(subscribeLatch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
}
#end_block

#method_before
@Test
public void testOnSearchCalledBySearch() throws InterruptedException {
    prepareLooper();
    final String testQuery = "search_query";
    final int testPage = 2;
    final int testPageSize = 4;
    final LibraryParams testParams = createLibraryParams();
    final List<MediaItem> testFullSearchResult = createMediaItems((testPage + 1) * testPageSize + 3);
    final CountDownLatch latch = new CountDownLatch(1);
    MockMediaBrowserServiceCompat.setMediaBrowserServiceProxy(new Proxy() {

        @Override
        public void onSearch(String query, Bundle extras, Result<List<MediaItem>> result) {
            assertEquals(testQuery, query);
            assertEqualLibraryParams(testParams, extras);
            result.sendResult(testFullSearchResult);
            latch.countDown();
        }
    });
    RemoteMediaBrowser browser = new RemoteMediaBrowser(mContext, mToken, true);
    browser.search(testQuery, testParams);
    assertTrue(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
}
#method_after
@Test
public void testOnSearchCalledBySearch() throws InterruptedException {
    prepareLooper();
    final String testQuery = "search_query";
    final int testPage = 2;
    final int testPageSize = 4;
    final LibraryParams testParams = MediaTestUtils.createLibraryParams();
    final List<MediaItem> testFullSearchResult = createMediaItems((testPage + 1) * testPageSize + 3);
    final CountDownLatch latch = new CountDownLatch(1);
    MockMediaBrowserServiceCompat.setMediaBrowserServiceProxy(new Proxy() {

        @Override
        public void onSearch(String query, Bundle extras, Result<List<MediaItem>> result) {
            assertEquals(testQuery, query);
            MediaTestUtils.assertEqualLibraryParams(testParams, extras);
            result.sendResult(testFullSearchResult);
            latch.countDown();
        }
    });
    RemoteMediaBrowser browser = new RemoteMediaBrowser(mContext, mToken, true);
    browser.search(testQuery, testParams);
    assertTrue(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
}
#end_block

#method_before
@Test
public void testOnSearchCalledByGetSearchResult() throws InterruptedException {
    prepareLooper();
    final String testQuery = "search_query";
    final int testPage = 2;
    final int testPageSize = 4;
    final LibraryParams testParams = createLibraryParams();
    final CountDownLatch latch = new CountDownLatch(1);
    MockMediaBrowserServiceCompat.setMediaBrowserServiceProxy(new Proxy() {

        @Override
        public void onSearch(String query, Bundle extras, Result<List<MediaItem>> result) {
            assertEquals(testQuery, query);
            assertEqualLibraryParams(testParams, extras);
            assertEquals(testPage, extras.getInt(MediaBrowserCompat.EXTRA_PAGE));
            assertEquals(testPageSize, extras.getInt(MediaBrowserCompat.EXTRA_PAGE_SIZE));
            result.sendResult(null);
            latch.countDown();
        }
    });
    RemoteMediaBrowser browser = new RemoteMediaBrowser(mContext, mToken, true);
    browser.getSearchResult(testQuery, testPage, testPageSize, testParams);
    assertTrue(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
}
#method_after
@Test
public void testOnSearchCalledByGetSearchResult() throws InterruptedException {
    prepareLooper();
    final String testQuery = "search_query";
    final int testPage = 2;
    final int testPageSize = 4;
    final LibraryParams testParams = MediaTestUtils.createLibraryParams();
    final CountDownLatch latch = new CountDownLatch(1);
    MockMediaBrowserServiceCompat.setMediaBrowserServiceProxy(new Proxy() {

        @Override
        public void onSearch(String query, Bundle extras, Result<List<MediaItem>> result) {
            assertEquals(testQuery, query);
            MediaTestUtils.assertEqualLibraryParams(testParams, extras);
            assertEquals(testPage, extras.getInt(MediaBrowserCompat.EXTRA_PAGE));
            assertEquals(testPageSize, extras.getInt(MediaBrowserCompat.EXTRA_PAGE_SIZE));
            result.sendResult(null);
            latch.countDown();
        }
    });
    RemoteMediaBrowser browser = new RemoteMediaBrowser(mContext, mToken, true);
    browser.getSearchResult(testQuery, testPage, testPageSize, testParams);
    assertTrue(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
}
#end_block

#method_before
@NonNull
public LibraryParams build() {
    return new LibraryParams(mBundle, mRecent, mOffline, mSuggested);
}
#method_after
@Override
@NonNull
public MediaLibrarySession build() {
    if (mCallbackExecutor == null) {
        mCallbackExecutor = ContextCompat.getMainExecutor(mContext);
    }
    if (mCallback == null) {
        mCallback = new MediaLibrarySession.MediaLibrarySessionCallback() {
        };
    }
    return new MediaLibrarySession(mContext, mId, mPlayer, mSessionActivity, mCallbackExecutor, mCallback);
}
#end_block

#method_before
@Override
public void onSeekCompleted(MediaController controller, long position) {
    if (DEBUG) {
        Log.d(TAG, "onSeekCompleted(): " + position);
    }
    // Update progress bar and time text.
    int positionOnProgressBar = (mDuration <= 0) ? 0 : (int) (MAX_PROGRESS * position / mDuration);
    mProgress.setProgress(positionOnProgressBar);
    mCurrentTime.setText(stringForTime(position));
    if (mNextSeekPosition != SEEK_POSITION_NOT_SET) {
        mCurrentSeekPosition = mNextSeekPosition;
        // If the next seek position is set, seek to that position.
        mController.seekTo(mNextSeekPosition);
        mNextSeekPosition = SEEK_POSITION_NOT_SET;
    } else {
        mCurrentSeekPosition = SEEK_POSITION_NOT_SET;
        // If the next seek position is not set, start to update progress.
        removeCallbacks(mUpdateProgress);
        removeCallbacks(mHideMainBars);
        post(mUpdateProgress);
        postDelayed(mHideMainBars, mShowControllerIntervalMs);
    }
}
#method_after
@Override
public void onSeekCompleted(MediaController controller, long position) {
    if (DEBUG) {
        Log.d(TAG, "onSeekCompleted(): " + position);
    }
    // Update progress bar and time text.
    int positionOnProgressBar = (mDuration <= 0) ? 0 : (int) (MAX_PROGRESS * position / mDuration);
    mProgress.setProgress(positionOnProgressBar);
    mCurrentTime.setText(stringForTime(position));
    if (mNextSeekPosition != SEEK_POSITION_NOT_SET) {
        mCurrentSeekPosition = mNextSeekPosition;
        // If the next seek position is set, seek to that position.
        MediaControlView2.this.mController.seekTo(mNextSeekPosition);
        mNextSeekPosition = SEEK_POSITION_NOT_SET;
    } else {
        mCurrentSeekPosition = SEEK_POSITION_NOT_SET;
        // If the next seek position is not set, start to update progress.
        removeCallbacks(mUpdateProgress);
        removeCallbacks(mHideMainBars);
        post(mUpdateProgress);
        postDelayed(mHideMainBars, mShowControllerIntervalMs);
    }
}
#end_block

#method_before
public void setMediaItem(MediaItem mediaItem2) {
    mMediaItemQueue.setMediaItem(Preconditions.checkNotNull(mediaItem2));
}
#method_after
public void setMediaItem(MediaItem mediaItem) {
    mMediaItemQueue.setMediaItem(Preconditions.checkNotNull(mediaItem));
}
#end_block

#method_before
public void seekTo(long position, @MediaPlayer2.SeekMode int mode) {
    mPlayer.setSeekParameters(ExoPlayerUtils.getSeekParameters(mode));
    MediaItem mediaItem2 = mMediaItemQueue.getCurrentMediaItem();
    if (mediaItem2 != null) {
        Preconditions.checkArgument(mediaItem2.getStartPosition() <= position && mediaItem2.getEndPosition() >= position, "Requested seek position is out of range : " + position);
        position -= mediaItem2.getStartPosition();
    }
    mPlayer.seekTo(position);
}
#method_after
public void seekTo(long position, @MediaPlayer2.SeekMode int mode) {
    mPlayer.setSeekParameters(ExoPlayerUtils.getSeekParameters(mode));
    MediaItem mediaItem = mMediaItemQueue.getCurrentMediaItem();
    if (mediaItem != null) {
        Preconditions.checkArgument(mediaItem.getStartPosition() <= position && mediaItem.getEndPosition() >= position, "Requested seek position is out of range : " + position);
        position -= mediaItem.getStartPosition();
    }
    mPlayer.seekTo(position);
}
#end_block

#method_before
public long getCurrentPosition() {
    long position = mPlayer.getCurrentPosition();
    MediaItem mediaItem2 = mMediaItemQueue.getCurrentMediaItem();
    if (mediaItem2 != null) {
        position += mediaItem2.getStartPosition();
    }
    return position;
}
#method_after
public long getCurrentPosition() {
    long position = mPlayer.getCurrentPosition();
    MediaItem mediaItem = mMediaItemQueue.getCurrentMediaItem();
    if (mediaItem != null) {
        position += mediaItem.getStartPosition();
    }
    return position;
}
#end_block

#method_before
public long getBufferedPosition() {
    long position = mPlayer.getBufferedPosition();
    MediaItem mediaItem2 = mMediaItemQueue.getCurrentMediaItem();
    if (mediaItem2 != null) {
        position += mediaItem2.getStartPosition();
    }
    return position;
}
#method_after
public long getBufferedPosition() {
    long position = mPlayer.getBufferedPosition();
    MediaItem mediaItem = mMediaItemQueue.getCurrentMediaItem();
    if (mediaItem != null) {
        position += mediaItem.getStartPosition();
    }
    return position;
}
#end_block

#method_before
public void setNextMediaItem(MediaItem mediaItem2) {
    Preconditions.checkState(!mMediaItemQueue.isEmpty());
    mMediaItemQueue.setNextMediaItems(Collections.singletonList(mediaItem2));
}
#method_after
public void setNextMediaItem(MediaItem mediaItem) {
    Preconditions.checkState(!mMediaItemQueue.isEmpty());
    mMediaItemQueue.setNextMediaItems(Collections.singletonList(mediaItem));
}
#end_block

#method_before
public void setNextMediaItems(List<MediaItem> mediaItem2s) {
    Preconditions.checkState(!mMediaItemQueue.isEmpty());
    mMediaItemQueue.setNextMediaItems(Preconditions.checkNotNull(mediaItem2s));
}
#method_after
public void setNextMediaItems(List<MediaItem> mediaItems) {
    Preconditions.checkState(!mMediaItemQueue.isEmpty());
    mMediaItemQueue.setNextMediaItems(Preconditions.checkNotNull(mediaItems));
}
#end_block

#method_before
private void maybeNotifyReadyEvents() {
    MediaItem mediaItem2 = mMediaItemQueue.getCurrentMediaItem();
    boolean prepareComplete = !mPrepared;
    boolean seekComplete = mPendingSeek;
    if (prepareComplete) {
        mPrepared = true;
        mNewlyPrepared = true;
        mMediaItemQueue.onPositionDiscontinuity(/* isPeriodTransition= */
        false);
        // TODO(b/80232248): Trigger onInfo with MEDIA_INFO_PREPARED for any item in the data
        // source queue for which the duration is now known, even if this is not the initial
        // preparation.
        mListener.onPrepared(mediaItem2);
    } else if (seekComplete) {
        // TODO(b/80232248): Suppress notification if this is an initial seek for a non-zero
        // start position.
        mPendingSeek = false;
        mListener.onSeekCompleted(getCurrentPosition());
    } else if (mRebuffering) {
        mRebuffering = false;
        mListener.onBufferingEnded(getCurrentMediaItem());
    }
}
#method_after
private void maybeNotifyReadyEvents() {
    MediaItem mediaItem = mMediaItemQueue.getCurrentMediaItem();
    boolean prepareComplete = !mPrepared;
    boolean seekComplete = mPendingSeek;
    if (prepareComplete) {
        mPrepared = true;
        mNewlyPrepared = true;
        mMediaItemQueue.onPositionDiscontinuity(/* isPeriodTransition= */
        false);
        // TODO(b/80232248): Trigger onInfo with MEDIA_INFO_PREPARED for any item in the data
        // source queue for which the duration is now known, even if this is not the initial
        // preparation.
        mListener.onPrepared(mediaItem);
    } else if (seekComplete) {
        // TODO(b/80232248): Suppress notification if this is an initial seek for a non-zero
        // start position.
        mPendingSeek = false;
        mListener.onSeekCompleted(getCurrentPosition());
    } else if (mRebuffering) {
        mRebuffering = false;
        mListener.onBufferingEnded(getCurrentMediaItem());
    }
}
#end_block

#method_before
public void setMediaItem(MediaItem mediaItem2) {
    clear();
    mConcatenatingMediaSource.clear();
    setNextMediaItems(Collections.singletonList(mediaItem2));
}
#method_after
public void setMediaItem(MediaItem mediaItem) {
    clear();
    mConcatenatingMediaSource.clear();
    setNextMediaItems(Collections.singletonList(mediaItem));
}
#end_block

#method_before
public void setNextMediaItems(List<MediaItem> mediaItem2s) {
    int size = mConcatenatingMediaSource.getSize();
    if (size > 1) {
        mConcatenatingMediaSource.removeMediaSourceRange(/* fromIndex= */
        1, /* toIndex= */
        size);
        while (mMediaItemInfos.size() > 1) {
            releaseMediaItem(mMediaItemInfos.removeLast());
        }
    }
    List<MediaSource> mediaSources = new ArrayList<>(mediaItem2s.size());
    for (MediaItem mediaItem2 : mediaItem2s) {
        if (mediaItem2 == null) {
            mListener.onError(/* mediaItem2= */
            null, MEDIA_ERROR_UNKNOWN);
            return;
        }
        try {
            appendMediaItem(mediaItem2, mMediaItemInfos, mediaSources);
        } catch (IOException e) {
            mListener.onError(mediaItem2, MEDIA_ERROR_UNKNOWN);
        }
    }
    mConcatenatingMediaSource.addMediaSources(mediaSources);
}
#method_after
public void setNextMediaItems(List<MediaItem> mediaItems) {
    int size = mConcatenatingMediaSource.getSize();
    if (size > 1) {
        mConcatenatingMediaSource.removeMediaSourceRange(/* fromIndex= */
        1, /* toIndex= */
        size);
        while (mMediaItemInfos.size() > 1) {
            releaseMediaItem(mMediaItemInfos.removeLast());
        }
    }
    List<MediaSource> mediaSources = new ArrayList<>(mediaItems.size());
    for (MediaItem mediaItem : mediaItems) {
        if (mediaItem == null) {
            mListener.onError(/* mediaItem= */
            null, MEDIA_ERROR_UNKNOWN);
            return;
        }
        try {
            appendMediaItem(mediaItem, mMediaItemInfos, mediaSources);
        } catch (IOException e) {
            mListener.onError(mediaItem, MEDIA_ERROR_UNKNOWN);
        }
    }
    mConcatenatingMediaSource.addMediaSources(mediaSources);
}
#end_block

#method_before
private void appendMediaItem(MediaItem mediaItem2, Collection<MediaItemInfo> mediaItemInfos, Collection<MediaSource> mediaSources) throws IOException {
    DataSource.Factory dataSourceFactory = mDataSourceFactory;
    // Create a data source for reading from the file descriptor, if needed.
    FileDescriptor fileDescriptor = null;
    if (mediaItem2 instanceof FileMediaItem) {
        FileMediaItem fileMediaItem = (FileMediaItem) mediaItem2;
        // TODO(b/68398926): Remove dup'ing the file descriptor once FileMediaItem does it.
        Object lock = mFileDescriptorRegistry.registerMediaItemAndGetLock(fileMediaItem.getFileDescriptor());
        fileDescriptor = FileDescriptorUtil.dup(fileMediaItem.getFileDescriptor());
        long offset = fileMediaItem.getFileDescriptorOffset();
        long length = fileMediaItem.getFileDescriptorLength();
        dataSourceFactory = FileDescriptorDataSource.getFactory(fileDescriptor, offset, length, lock);
    }
    // Create a source for the item.
    MediaSource mediaSource = ExoPlayerUtils.createUnclippedMediaSource(dataSourceFactory, mediaItem2);
    // Apply clipping if needed. Because ExoPlayer doesn't expose the unclipped duration, we
    // wrap the child source in an intermediate source that lets us access its duration.
    DurationProvidingMediaSource durationProvidingMediaSource = null;
    long startPosition = mediaItem2.getStartPosition();
    long endPosition = mediaItem2.getEndPosition();
    if (startPosition != 0L || endPosition != MediaItem.POSITION_UNKNOWN) {
        durationProvidingMediaSource = new DurationProvidingMediaSource(mediaSource);
        // Disable the initial discontinuity to give seamless transitions to clips.
        mediaSource = new ClippingMediaSource(durationProvidingMediaSource, C.msToUs(startPosition), C.msToUs(endPosition), /* enableInitialDiscontinuity= */
        false, /* allowDynamicClippingUpdates= */
        false, /* relativeToDefaultPosition= */
        true);
    }
    mediaSources.add(mediaSource);
    mediaItemInfos.add(new MediaItemInfo(mediaItem2, durationProvidingMediaSource, fileDescriptor));
}
#method_after
private void appendMediaItem(MediaItem mediaItem, Collection<MediaItemInfo> mediaItemInfos, Collection<MediaSource> mediaSources) throws IOException {
    DataSource.Factory dataSourceFactory = mDataSourceFactory;
    // Create a data source for reading from the file descriptor, if needed.
    FileDescriptor fileDescriptor = null;
    if (mediaItem instanceof FileMediaItem) {
        FileMediaItem fileMediaItem = (FileMediaItem) mediaItem;
        // TODO(b/68398926): Remove dup'ing the file descriptor once FileMediaItem does it.
        Object lock = mFileDescriptorRegistry.registerMediaItemAndGetLock(fileMediaItem.getFileDescriptor());
        fileDescriptor = FileDescriptorUtil.dup(fileMediaItem.getFileDescriptor());
        long offset = fileMediaItem.getFileDescriptorOffset();
        long length = fileMediaItem.getFileDescriptorLength();
        dataSourceFactory = FileDescriptorDataSource.getFactory(fileDescriptor, offset, length, lock);
    }
    // Create a source for the item.
    MediaSource mediaSource = ExoPlayerUtils.createUnclippedMediaSource(dataSourceFactory, mediaItem);
    // Apply clipping if needed. Because ExoPlayer doesn't expose the unclipped duration, we
    // wrap the child source in an intermediate source that lets us access its duration.
    DurationProvidingMediaSource durationProvidingMediaSource = null;
    long startPosition = mediaItem.getStartPosition();
    long endPosition = mediaItem.getEndPosition();
    if (startPosition != 0L || endPosition != MediaItem.POSITION_UNKNOWN) {
        durationProvidingMediaSource = new DurationProvidingMediaSource(mediaSource);
        // Disable the initial discontinuity to give seamless transitions to clips.
        mediaSource = new ClippingMediaSource(durationProvidingMediaSource, C.msToUs(startPosition), C.msToUs(endPosition), /* enableInitialDiscontinuity= */
        false, /* allowDynamicClippingUpdates= */
        false, /* relativeToDefaultPosition= */
        true);
    }
    mediaSources.add(mediaSource);
    mediaItemInfos.add(new MediaItemInfo(mediaItem, durationProvidingMediaSource, fileDescriptor));
}
#end_block

#method_before
@Test
public void testOnSubscribe() throws InterruptedException {
    prepareLooper();
    final String testParentId = "testSubscribeId";
    final LibraryParams testParams = MediaTestUtils.createLibraryParams();
    final CountDownLatch latch = new CountDownLatch(1);
    final MediaLibrarySession.MediaLibrarySessionCallback sessionCallback = new MediaLibrarySession.MediaLibrarySessionCallback() {

        @Override
        public int onSubscribe(MediaLibrarySession session, MediaSession.ControllerInfo controller, String parentId, LibraryParams params) {
            assertEquals(testParentId, parentId);
            assertEqualLibraryParams(testParams, params);
            latch.countDown();
            return RESULT_CODE_SUCCESS;
        }
    };
    MockMediaLibraryService service = new MockMediaLibraryService();
    service.attachBaseContext(mContext);
    try (MediaLibrarySession session = new MediaLibrarySession.Builder(service, mPlayer, sHandlerExecutor, sessionCallback).setId("testOnSubscribe").build()) {
        RemoteMediaBrowser browser = createRemoteBrowser2(session.getToken());
        browser.subscribe(testParentId, testParams);
        assertTrue(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
    }
}
#method_after
@Test
public void testOnSubscribe() throws InterruptedException {
    prepareLooper();
    final String testParentId = "testSubscribeId";
    final LibraryParams testParams = MediaTestUtils.createLibraryParams();
    final CountDownLatch latch = new CountDownLatch(1);
    final MediaLibrarySession.MediaLibrarySessionCallback sessionCallback = new MediaLibrarySession.MediaLibrarySessionCallback() {

        @Override
        public int onSubscribe(MediaLibrarySession session, MediaSession.ControllerInfo controller, String parentId, LibraryParams params) {
            assertEquals(testParentId, parentId);
            MediaTestUtils.assertEqualLibraryParams(testParams, params);
            latch.countDown();
            return RESULT_CODE_SUCCESS;
        }
    };
    MockMediaLibraryService service = new MockMediaLibraryService();
    service.attachBaseContext(mContext);
    try (MediaLibrarySession session = new MediaLibrarySession.Builder(service, mPlayer, sHandlerExecutor, sessionCallback).setId("testOnSubscribe").build()) {
        RemoteMediaBrowser browser = createRemoteBrowser2(session.getToken());
        browser.subscribe(testParentId, testParams);
        assertTrue(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
    }
}
#end_block

#method_before
@Override
public void connect(final IMediaController caller, final String packageName) {
    final MediaSessionServiceImplBase serviceImpl = mServiceImpl.get();
    if (serviceImpl == null) {
        if (DEBUG) {
            Log.d(TAG, "ServiceImpl isn't available");
        }
        return;
    }
    final int pid = Binder.getCallingPid();
    final int uid = Binder.getCallingUid();
    mHandler.post(new Runnable() {

        @Override
        public void run() {
            boolean shouldNotifyDisconnected = true;
            try {
                final MediaSessionServiceImplBase serviceImpl = mServiceImpl.get();
                if (serviceImpl == null) {
                    if (DEBUG) {
                        Log.d(TAG, "ServiceImpl isn't available");
                    }
                    return;
                }
                final MediaSessionService service = serviceImpl.getInstance();
                if (service == null) {
                    if (DEBUG) {
                        Log.d(TAG, "Service isn't available");
                    }
                    return;
                }
                if (DEBUG) {
                    Log.d(TAG, "Handling incoming connection request from the controller" + ", controller=" + packageName);
                }
                final MediaSession session;
                try {
                    session = service.onGetSession();
                    service.addSession(session);
                    shouldNotifyDisconnected = false;
                    session.handleControllerConnectionFromService(caller, packageName, pid, uid);
                } catch (Exception e) {
                    // Don't propagate exception in service to the controller.
                    Log.w(TAG, "Failed to add a session to session service", e);
                }
            } finally {
                // Trick to call onDisconnected() in one place.
                if (shouldNotifyDisconnected) {
                    if (DEBUG) {
                        Log.d(TAG, "Service has destroyed prematurely." + " Rejecting connection");
                    }
                    try {
                        caller.onDisconnected();
                    } catch (RemoteException e) {
                    // Controller may be died prematurely.
                    // Not an issue because we'll ignore it anyway.
                    }
                }
            }
        }
    });
}
#method_after
@Override
public void connect(final IMediaController caller, final String packageName) {
    final MediaSessionServiceImplBase serviceImpl = mServiceImpl.get();
    if (serviceImpl == null) {
        if (DEBUG) {
            Log.d(TAG, "ServiceImpl isn't available");
        }
        return;
    }
    final int pid = Binder.getCallingPid();
    final int uid = Binder.getCallingUid();
    final long token = Binder.clearCallingIdentity();
    try {
        mHandler.post(new Runnable() {

            @Override
            public void run() {
                boolean shouldNotifyDisconnected = true;
                try {
                    final MediaSessionServiceImplBase serviceImpl = mServiceImpl.get();
                    if (serviceImpl == null) {
                        if (DEBUG) {
                            Log.d(TAG, "ServiceImpl isn't available");
                        }
                        return;
                    }
                    final MediaSessionService service = serviceImpl.getInstance();
                    if (service == null) {
                        if (DEBUG) {
                            Log.d(TAG, "Service isn't available");
                        }
                        return;
                    }
                    if (DEBUG) {
                        Log.d(TAG, "Handling incoming connection request from the" + " controller, controller=" + packageName);
                    }
                    final MediaSession session;
                    try {
                        session = service.onGetSession();
                        service.addSession(session);
                        shouldNotifyDisconnected = false;
                        session.handleControllerConnectionFromService(caller, packageName, pid, uid);
                    } catch (Exception e) {
                        // Don't propagate exception in service to the controller.
                        Log.w(TAG, "Failed to add a session to session service", e);
                    }
                } finally {
                    // Trick to call onDisconnected() in one place.
                    if (shouldNotifyDisconnected) {
                        if (DEBUG) {
                            Log.d(TAG, "Service has destroyed prematurely." + " Rejecting connection");
                        }
                        try {
                            caller.onDisconnected();
                        } catch (RemoteException e) {
                        // Controller may be died prematurely.
                        // Not an issue because we'll ignore it anyway.
                        }
                    }
                }
            }
        });
    } finally {
        Binder.restoreCallingIdentity(token);
    }
}
#end_block

#method_before
@Test
public void testGetSessionServiceTokens() {
    prepareLooper();
    boolean hasMockBrowserServiceCompat = false;
    boolean hasMockSessionService2 = false;
    boolean hasMockLibraryService2 = false;
    MediaSessionManager sessionManager2 = MediaSessionManager.getInstance(mContext);
    Set<SessionToken> serviceTokens = sessionManager2.getSessionServiceTokens();
    for (SessionToken token2 : serviceTokens) {
        ComponentName componentName = token2.getComponentName();
        if (MOCK_BROWSER_SERVICE_COMPAT_NAME.equals(componentName)) {
            hasMockBrowserServiceCompat = true;
        } else if (MOCK_MEDIA_SESSION_SERVICE.equals(componentName)) {
            hasMockSessionService2 = true;
        } else if (MOCK_MEDIA_LIBRARY_SERVICE.equals(componentName)) {
            hasMockLibraryService2 = true;
        }
    }
    assertTrue(hasMockBrowserServiceCompat);
    assertTrue(hasMockSessionService2);
    assertTrue(hasMockLibraryService2);
}
#method_after
@Test
public void testGetSessionServiceTokens() {
    prepareLooper();
    boolean hasMockBrowserServiceCompat = false;
    boolean hasMockSessionService2 = false;
    boolean hasMockLibraryService2 = false;
    MediaSessionManager sessionManager = MediaSessionManager.getInstance(mContext);
    Set<SessionToken> serviceTokens = sessionManager.getSessionServiceTokens();
    for (SessionToken token : serviceTokens) {
        ComponentName componentName = token.getComponentName();
        if (MOCK_BROWSER_SERVICE_COMPAT_NAME.equals(componentName)) {
            hasMockBrowserServiceCompat = true;
        } else if (MOCK_MEDIA_SESSION_SERVICE.equals(componentName)) {
            hasMockSessionService2 = true;
        } else if (MOCK_MEDIA_LIBRARY_SERVICE.equals(componentName)) {
            hasMockLibraryService2 = true;
        }
    }
    assertTrue(hasMockBrowserServiceCompat);
    assertTrue(hasMockSessionService2);
    assertTrue(hasMockLibraryService2);
}
#end_block

#method_before
@NonNull
public CommandButton build() {
    return new CommandButton(mCommand, mIconResId, mDisplayName, mExtras, mEnabled);
}
#method_after
@Override
@NonNull
public MediaSession build() {
    if (mCallbackExecutor == null) {
        mCallbackExecutor = ContextCompat.getMainExecutor(mContext);
    }
    if (mCallback == null) {
        mCallback = new SessionCallback() {
        };
    }
    return new MediaSession(mContext, mId, mPlayer, mSessionActivity, mCallbackExecutor, mCallback);
}
#end_block

#method_before
@Test
public void testPlayPauseButtonClick() throws Throwable {
    // Don't run the test if the codec isn't supported.
    if (!hasCodec(mFileSchemeUri)) {
        Log.i(TAG, "SKIPPING testPlayPauseButtonClick(): codec is not supported");
        return;
    }
    final CountDownLatch latchForPausedState = new CountDownLatch(1);
    final CountDownLatch latchForPlayingState = new CountDownLatch(1);
    final MediaController controller = createController(new MediaController.ControllerCallback() {

        @Override
        public void onPlayerStateChanged(@NonNull MediaController controller, int state) {
            if (state == SessionPlayer.PLAYER_STATE_PAUSED) {
                latchForPausedState.countDown();
            } else if (state == SessionPlayer.PLAYER_STATE_PLAYING) {
                latchForPlayingState.countDown();
            }
        }
    });
    mActivityRule.runOnUiThread(new Runnable() {

        @Override
        public void run() {
            mVideoView.setMediaItem2(mFileSchemeMediaItem);
        }
    });
    assertTrue(latchForPausedState.await(WAIT_TIME_MS, TimeUnit.MILLISECONDS));
    onView(withId(R.id.pause)).perform(click());
    assertTrue(latchForPlayingState.await(WAIT_TIME_MS, TimeUnit.MILLISECONDS));
}
#method_after
@Test
public void testPlayPauseButtonClick() throws Throwable {
    // Don't run the test if the codec isn't supported.
    if (!hasCodec(mFileSchemeUri)) {
        Log.i(TAG, "SKIPPING testPlayPauseButtonClick(): codec is not supported");
        return;
    }
    final CountDownLatch latchForPausedState = new CountDownLatch(1);
    final CountDownLatch latchForPlayingState = new CountDownLatch(1);
    final MediaController controller = createController(new MediaController.ControllerCallback() {

        @Override
        public void onPlayerStateChanged(@NonNull MediaController controller, int state) {
            if (state == SessionPlayer.PLAYER_STATE_PAUSED) {
                latchForPausedState.countDown();
            } else if (state == SessionPlayer.PLAYER_STATE_PLAYING) {
                latchForPlayingState.countDown();
            }
        }
    });
    mActivityRule.runOnUiThread(new Runnable() {

        @Override
        public void run() {
            mVideoView.setMediaItem(mFileSchemeMediaItem);
        }
    });
    assertTrue(latchForPausedState.await(WAIT_TIME_MS, TimeUnit.MILLISECONDS));
    onView(withId(R.id.pause)).perform(click());
    assertTrue(latchForPlayingState.await(WAIT_TIME_MS, TimeUnit.MILLISECONDS));
}
#end_block

#method_before
@Test
public void testFfwdButtonClick() throws Throwable {
    // Don't run the test if the codec isn't supported.
    if (!hasCodec(mFileSchemeUri)) {
        Log.i(TAG, "SKIPPING testFfwdButtonClick(): codec is not supported");
        return;
    }
    final CountDownLatch latchForPausedState = new CountDownLatch(1);
    final CountDownLatch latchForFfwd = new CountDownLatch(1);
    final MediaController controller = createController(new MediaController.ControllerCallback() {

        @Override
        public void onSeekCompleted(@NonNull MediaController controller, long position) {
            if (position >= FFWD_MS) {
                latchForFfwd.countDown();
            }
        }

        @Override
        public void onPlayerStateChanged(@NonNull MediaController controller, int state) {
            if (state == SessionPlayer.PLAYER_STATE_PAUSED) {
                latchForPausedState.countDown();
            }
        }
    });
    mActivityRule.runOnUiThread(new Runnable() {

        @Override
        public void run() {
            mVideoView.setMediaItem2(mFileSchemeMediaItem);
        }
    });
    assertTrue(latchForPausedState.await(WAIT_TIME_MS, TimeUnit.MILLISECONDS));
    onView(withId(R.id.ffwd)).perform(click());
    assertTrue(latchForFfwd.await(WAIT_TIME_MS, TimeUnit.MILLISECONDS));
}
#method_after
@Test
public void testFfwdButtonClick() throws Throwable {
    // Don't run the test if the codec isn't supported.
    if (!hasCodec(mFileSchemeUri)) {
        Log.i(TAG, "SKIPPING testFfwdButtonClick(): codec is not supported");
        return;
    }
    final CountDownLatch latchForPausedState = new CountDownLatch(1);
    final CountDownLatch latchForFfwd = new CountDownLatch(1);
    final MediaController controller = createController(new MediaController.ControllerCallback() {

        @Override
        public void onSeekCompleted(@NonNull MediaController controller, long position) {
            if (position >= FFWD_MS) {
                latchForFfwd.countDown();
            }
        }

        @Override
        public void onPlayerStateChanged(@NonNull MediaController controller, int state) {
            if (state == SessionPlayer.PLAYER_STATE_PAUSED) {
                latchForPausedState.countDown();
            }
        }
    });
    mActivityRule.runOnUiThread(new Runnable() {

        @Override
        public void run() {
            mVideoView.setMediaItem(mFileSchemeMediaItem);
        }
    });
    assertTrue(latchForPausedState.await(WAIT_TIME_MS, TimeUnit.MILLISECONDS));
    onView(withId(R.id.ffwd)).perform(click());
    assertTrue(latchForFfwd.await(WAIT_TIME_MS, TimeUnit.MILLISECONDS));
}
#end_block

#method_before
@Test
public void testRewButtonClick() throws Throwable {
    // Don't run the test if the codec isn't supported.
    if (!hasCodec(mFileSchemeUri)) {
        Log.i(TAG, "SKIPPING testRewButtonClick(): codec is not supported");
        return;
    }
    final CountDownLatch latchForFfwd = new CountDownLatch(1);
    final CountDownLatch latchForRew = new CountDownLatch(1);
    final MediaController controller = createController(new MediaController.ControllerCallback() {

        long mExpectedPosition;

        final long mDelta = 1000L;

        @Override
        public void onPlayerStateChanged(@NonNull MediaController controller, int state) {
            if (state == SessionPlayer.PLAYER_STATE_PAUSED) {
                mExpectedPosition = FFWD_MS;
                controller.seekTo(mExpectedPosition);
            }
        }

        @Override
        public void onSeekCompleted(@NonNull MediaController controller, long position) {
            assertTrue(equalsSeekPosition(mExpectedPosition, position, mDelta));
            if (mExpectedPosition == FFWD_MS) {
                mExpectedPosition = position - REW_MS;
                latchForFfwd.countDown();
            } else {
                latchForRew.countDown();
            }
        }

        private boolean equalsSeekPosition(long expected, long actual, long delta) {
            return (actual < expected + delta) && (actual > expected - delta);
        }
    });
    mActivityRule.runOnUiThread(new Runnable() {

        @Override
        public void run() {
            mVideoView.setMediaItem2(mFileSchemeMediaItem);
        }
    });
    assertTrue(latchForFfwd.await(WAIT_TIME_MS, TimeUnit.MILLISECONDS));
    onView(withId(R.id.rew)).perform(click());
    assertTrue(latchForRew.await(WAIT_TIME_MS, TimeUnit.MILLISECONDS));
}
#method_after
@Test
public void testRewButtonClick() throws Throwable {
    // Don't run the test if the codec isn't supported.
    if (!hasCodec(mFileSchemeUri)) {
        Log.i(TAG, "SKIPPING testRewButtonClick(): codec is not supported");
        return;
    }
    final CountDownLatch latchForFfwd = new CountDownLatch(1);
    final CountDownLatch latchForRew = new CountDownLatch(1);
    final MediaController controller = createController(new MediaController.ControllerCallback() {

        long mExpectedPosition;

        final long mDelta = 1000L;

        @Override
        public void onPlayerStateChanged(@NonNull MediaController controller, int state) {
            if (state == SessionPlayer.PLAYER_STATE_PAUSED) {
                mExpectedPosition = FFWD_MS;
                controller.seekTo(mExpectedPosition);
            }
        }

        @Override
        public void onSeekCompleted(@NonNull MediaController controller, long position) {
            assertTrue(equalsSeekPosition(mExpectedPosition, position, mDelta));
            if (mExpectedPosition == FFWD_MS) {
                mExpectedPosition = position - REW_MS;
                latchForFfwd.countDown();
            } else {
                latchForRew.countDown();
            }
        }

        private boolean equalsSeekPosition(long expected, long actual, long delta) {
            return (actual < expected + delta) && (actual > expected - delta);
        }
    });
    mActivityRule.runOnUiThread(new Runnable() {

        @Override
        public void run() {
            mVideoView.setMediaItem(mFileSchemeMediaItem);
        }
    });
    assertTrue(latchForFfwd.await(WAIT_TIME_MS, TimeUnit.MILLISECONDS));
    onView(withId(R.id.rew)).perform(click());
    assertTrue(latchForRew.await(WAIT_TIME_MS, TimeUnit.MILLISECONDS));
}
#end_block

#method_before
@Test
public void testPlayHttpsSchemeVideo() throws Throwable {
    // Don't run the test if the codec isn't supported.
    if (!hasCodec(mHttpsSchemeUri)) {
        Log.i(TAG, "SKIPPING testPlayHttpsSchemeVideo(): codec is not supported");
        return;
    }
    final CountDownLatch latchForPausedState = new CountDownLatch(1);
    final CountDownLatch latchForPlayingState = new CountDownLatch(1);
    final MediaController controller = createController(new MediaController.ControllerCallback() {

        @Override
        public void onPlayerStateChanged(@NonNull MediaController controller, int state) {
            if (state == SessionPlayer.PLAYER_STATE_PAUSED) {
                latchForPausedState.countDown();
            } else if (state == SessionPlayer.PLAYER_STATE_PLAYING) {
                latchForPlayingState.countDown();
            }
        }
    });
    mActivityRule.runOnUiThread(new Runnable() {

        @Override
        public void run() {
            mVideoView.setMediaItem2(mHttpsSchemeMediaItem);
        }
    });
    assertTrue(latchForPausedState.await(HTTPS_WAIT_TIME_MS, TimeUnit.MILLISECONDS));
    onView(withId(R.id.pause)).perform(click());
    assertTrue(latchForPlayingState.await(HTTPS_WAIT_TIME_MS, TimeUnit.MILLISECONDS));
}
#method_after
@Test
public void testPlayHttpsSchemeVideo() throws Throwable {
    // Don't run the test if the codec isn't supported.
    if (!hasCodec(mHttpsSchemeUri)) {
        Log.i(TAG, "SKIPPING testPlayHttpsSchemeVideo(): codec is not supported");
        return;
    }
    final CountDownLatch latchForPausedState = new CountDownLatch(1);
    final CountDownLatch latchForPlayingState = new CountDownLatch(1);
    final MediaController controller = createController(new MediaController.ControllerCallback() {

        @Override
        public void onPlayerStateChanged(@NonNull MediaController controller, int state) {
            if (state == SessionPlayer.PLAYER_STATE_PAUSED) {
                latchForPausedState.countDown();
            } else if (state == SessionPlayer.PLAYER_STATE_PLAYING) {
                latchForPlayingState.countDown();
            }
        }
    });
    mActivityRule.runOnUiThread(new Runnable() {

        @Override
        public void run() {
            mVideoView.setMediaItem(mHttpsSchemeMediaItem);
        }
    });
    assertTrue(latchForPausedState.await(HTTPS_WAIT_TIME_MS, TimeUnit.MILLISECONDS));
    onView(withId(R.id.pause)).perform(click());
    assertTrue(latchForPlayingState.await(HTTPS_WAIT_TIME_MS, TimeUnit.MILLISECONDS));
}
#end_block

#method_before
@Test
public void testGetMetadata() throws Throwable {
    // Don't run the test if the codec isn't supported.
    if (!hasCodec(mFileSchemeUri)) {
        Log.i(TAG, "SKIPPING testGetMetadata(): codec is not supported");
        return;
    }
    final long duration = 49056L;
    final String title = "BigBuckBunny";
    final CountDownLatch latch = new CountDownLatch(2);
    final MediaController controller = createController(new MediaController.ControllerCallback() {

        @Override
        public void onCurrentMediaItemChanged(@NonNull MediaController controller, @Nullable MediaItem item) {
            if (item != null) {
                MediaMetadata metadata = item.getMetadata();
                if (metadata != null) {
                    if (metadata.containsKey(MediaMetadata.METADATA_KEY_TITLE)) {
                        assertEquals(title, metadata.getString(MediaMetadata.METADATA_KEY_TITLE));
                        latch.countDown();
                    }
                    if (metadata.containsKey(MediaMetadata.METADATA_KEY_DURATION)) {
                        assertEquals(duration, metadata.getLong(MediaMetadata.METADATA_KEY_DURATION));
                        latch.countDown();
                    }
                }
            }
        }
    });
    mActivityRule.runOnUiThread(new Runnable() {

        @Override
        public void run() {
            mVideoView.setMediaItem2(mFileSchemeMediaItem);
        }
    });
    assertTrue(latch.await(WAIT_TIME_MS, TimeUnit.MILLISECONDS));
}
#method_after
@Test
public void testGetMetadata() throws Throwable {
    // Don't run the test if the codec isn't supported.
    if (!hasCodec(mFileSchemeUri)) {
        Log.i(TAG, "SKIPPING testGetMetadata(): codec is not supported");
        return;
    }
    final long duration = 49056L;
    final String title = "BigBuckBunny";
    final CountDownLatch latch = new CountDownLatch(2);
    final MediaController controller = createController(new MediaController.ControllerCallback() {

        @Override
        public void onCurrentMediaItemChanged(@NonNull MediaController controller, @Nullable MediaItem item) {
            if (item != null) {
                MediaMetadata metadata = item.getMetadata();
                if (metadata != null) {
                    if (metadata.containsKey(MediaMetadata.METADATA_KEY_TITLE)) {
                        assertEquals(title, metadata.getString(MediaMetadata.METADATA_KEY_TITLE));
                        latch.countDown();
                    }
                    if (metadata.containsKey(MediaMetadata.METADATA_KEY_DURATION)) {
                        assertEquals(duration, metadata.getLong(MediaMetadata.METADATA_KEY_DURATION));
                        latch.countDown();
                    }
                }
            }
        }
    });
    mActivityRule.runOnUiThread(new Runnable() {

        @Override
        public void run() {
            mVideoView.setMediaItem(mFileSchemeMediaItem);
        }
    });
    assertTrue(latch.await(WAIT_TIME_MS, TimeUnit.MILLISECONDS));
}
#end_block

#method_before
@Test
public void testGetMetadataFromMusic() throws Throwable {
    Uri uri = Uri.parse("android.resource://" + mContext.getPackageName() + "/" + R.raw.test_music);
    AssetFileDescriptor afd = mContext.getResources().openRawResourceFd(R.raw.test_music);
    // Don't run the test if the codec isn't supported.
    if (!hasCodec(uri) || !hasCodec(afd)) {
        Log.i(TAG, "SKIPPING testGetMetadataFromMusic(): codec is not supported");
        return;
    }
    final long duration = 4206L;
    final String title = "Chimey Phone";
    final String artist = "Android";
    final MediaItem uriMediaItem = createTestMediaItem2(uri);
    final MediaItem fileMediaItem = new FileMediaItem.Builder(afd.getFileDescriptor(), afd.getStartOffset(), afd.getLength()).build();
    final CountDownLatch latchForUri = new CountDownLatch(3);
    final CountDownLatch latchForFile = new CountDownLatch(3);
    final MediaController controller = createController(new MediaController.ControllerCallback() {

        @Override
        public void onCurrentMediaItemChanged(@NonNull MediaController controller, @Nullable MediaItem item) {
            if (item != null) {
                MediaMetadata metadata = item.getMetadata();
                if (metadata != null) {
                    if (metadata.containsKey(MediaMetadata.METADATA_KEY_TITLE)) {
                        assertEquals(title, metadata.getString(MediaMetadata.METADATA_KEY_TITLE));
                        countDown();
                    }
                    if (metadata.containsKey(MediaMetadata.METADATA_KEY_ARTIST)) {
                        assertEquals(artist, metadata.getString(MediaMetadata.METADATA_KEY_ARTIST));
                        countDown();
                    }
                    if (metadata.containsKey(MediaMetadata.METADATA_KEY_DURATION)) {
                        assertEquals(duration, metadata.getLong(MediaMetadata.METADATA_KEY_DURATION));
                        countDown();
                    }
                }
            }
        }

        private void countDown() {
            if (latchForUri.getCount() != 0) {
                latchForUri.countDown();
            } else {
                latchForFile.countDown();
            }
        }
    });
    mActivityRule.runOnUiThread(new Runnable() {

        @Override
        public void run() {
            mVideoView.setMediaItem2(uriMediaItem);
        }
    });
    assertTrue(latchForUri.await(WAIT_TIME_MS, TimeUnit.MILLISECONDS));
    mActivityRule.runOnUiThread(new Runnable() {

        @Override
        public void run() {
            mVideoView.setMediaItem2(fileMediaItem);
        }
    });
    assertTrue(latchForFile.await(WAIT_TIME_MS, TimeUnit.MILLISECONDS));
}
#method_after
@Test
public void testGetMetadataFromMusic() throws Throwable {
    Uri uri = Uri.parse("android.resource://" + mContext.getPackageName() + "/" + R.raw.test_music);
    AssetFileDescriptor afd = mContext.getResources().openRawResourceFd(R.raw.test_music);
    // Don't run the test if the codec isn't supported.
    if (!hasCodec(uri) || !hasCodec(afd)) {
        Log.i(TAG, "SKIPPING testGetMetadataFromMusic(): codec is not supported");
        return;
    }
    final long duration = 4206L;
    final String title = "Chimey Phone";
    final String artist = "Android";
    final MediaItem uriMediaItem = createTestMediaItem2(uri);
    final MediaItem fileMediaItem = new FileMediaItem.Builder(afd.getFileDescriptor(), afd.getStartOffset(), afd.getLength()).build();
    final CountDownLatch latchForUri = new CountDownLatch(3);
    final CountDownLatch latchForFile = new CountDownLatch(3);
    final MediaController controller = createController(new MediaController.ControllerCallback() {

        @Override
        public void onCurrentMediaItemChanged(@NonNull MediaController controller, @Nullable MediaItem item) {
            if (item != null) {
                MediaMetadata metadata = item.getMetadata();
                if (metadata != null) {
                    if (metadata.containsKey(MediaMetadata.METADATA_KEY_TITLE)) {
                        assertEquals(title, metadata.getString(MediaMetadata.METADATA_KEY_TITLE));
                        countDown();
                    }
                    if (metadata.containsKey(MediaMetadata.METADATA_KEY_ARTIST)) {
                        assertEquals(artist, metadata.getString(MediaMetadata.METADATA_KEY_ARTIST));
                        countDown();
                    }
                    if (metadata.containsKey(MediaMetadata.METADATA_KEY_DURATION)) {
                        assertEquals(duration, metadata.getLong(MediaMetadata.METADATA_KEY_DURATION));
                        countDown();
                    }
                }
            }
        }

        private void countDown() {
            if (latchForUri.getCount() != 0) {
                latchForUri.countDown();
            } else {
                latchForFile.countDown();
            }
        }
    });
    mActivityRule.runOnUiThread(new Runnable() {

        @Override
        public void run() {
            mVideoView.setMediaItem(uriMediaItem);
        }
    });
    assertTrue(latchForUri.await(WAIT_TIME_MS, TimeUnit.MILLISECONDS));
    mActivityRule.runOnUiThread(new Runnable() {

        @Override
        public void run() {
            mVideoView.setMediaItem(fileMediaItem);
        }
    });
    assertTrue(latchForFile.await(WAIT_TIME_MS, TimeUnit.MILLISECONDS));
}
#end_block

#method_before
private MediaController createController(MediaController.ControllerCallback callback) {
    MediaController controller = new MediaController(mVideoView.getContext(), mVideoView.getMediaSessionToken2(), mMainHandlerExecutor, callback);
    mControllers.add(controller);
    return controller;
}
#method_after
private MediaController createController(MediaController.ControllerCallback callback) {
    MediaController controller = new MediaController(mVideoView.getContext(), mVideoView.getSessionToken(), mMainHandlerExecutor, callback);
    mControllers.add(controller);
    return controller;
}
#end_block

#method_before
@Test
public void testSetCustomLayout() throws InterruptedException {
    prepareLooper();
    final List<CommandButton> customLayout = new ArrayList<>();
    customLayout.add(new CommandButton.Builder().setCommand(new SessionCommand(SessionCommand.COMMAND_CODE_PLAYER_PLAY)).setDisplayName("button").build());
    final CountDownLatch latch = new CountDownLatch(1);
    try (MediaSession session = new MediaSession.Builder(mContext, mPlayer).setId("testSetCustomLayout").setSessionCallback(sHandlerExecutor, new SessionCallback() {

        @Override
        public SessionCommandGroup onConnect(MediaSession session, ControllerInfo controller) {
            if (mContext.getPackageName().equals(controller.getPackageName())) {
                mTestControllerInfo = controller;
                return super.onConnect(session, controller);
            }
            return null;
        }
    }).build()) {
        final ControllerCallback callback = new ControllerCallback() {

            @Override
            public int onSetCustomLayout(MediaController controller2, List<CommandButton> layout) {
                assertEquals(customLayout.size(), layout.size());
                for (int i = 0; i < layout.size(); i++) {
                    assertEquals(customLayout.get(i).getCommand(), layout.get(i).getCommand());
                    assertEquals(customLayout.get(i).getDisplayName(), layout.get(i).getDisplayName());
                }
                latch.countDown();
                return RESULT_CODE_SUCCESS;
            }
        };
        MediaController controller = createController(session.getToken(), true, callback);
        session.setCustomLayout(mTestControllerInfo, customLayout);
        assertTrue(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
    }
}
#method_after
@Test
public void testSetCustomLayout() throws InterruptedException {
    prepareLooper();
    final List<CommandButton> customLayout = new ArrayList<>();
    customLayout.add(new CommandButton.Builder().setCommand(new SessionCommand(SessionCommand.COMMAND_CODE_PLAYER_PLAY)).setDisplayName("button").build());
    final CountDownLatch latch = new CountDownLatch(1);
    try (MediaSession session = new MediaSession.Builder(mContext, mPlayer).setId("testSetCustomLayout").setSessionCallback(sHandlerExecutor, new SessionCallback() {

        @Override
        public SessionCommandGroup onConnect(MediaSession session, ControllerInfo controller) {
            if (mContext.getPackageName().equals(controller.getPackageName())) {
                mTestControllerInfo = controller;
                return super.onConnect(session, controller);
            }
            return null;
        }
    }).build()) {
        final ControllerCallback callback = new ControllerCallback() {

            @Override
            public int onSetCustomLayout(MediaController controller, List<CommandButton> layout) {
                assertEquals(customLayout.size(), layout.size());
                for (int i = 0; i < layout.size(); i++) {
                    assertEquals(customLayout.get(i).getCommand(), layout.get(i).getCommand());
                    assertEquals(customLayout.get(i).getDisplayName(), layout.get(i).getDisplayName());
                }
                latch.countDown();
                return RESULT_CODE_SUCCESS;
            }
        };
        MediaController controller = createController(session.getToken(), true, callback);
        session.setCustomLayout(mTestControllerInfo, customLayout);
        assertTrue(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
    }
}
#end_block

#method_before
@Test
public void testGetItem() throws Exception {
    prepareLooper();
    final String mediaId = MediaBrowserConstants.MEDIA_ID_GET_ITEM;
    BrowserResult result = createBrowser().getItem(mediaId).get(TIMEOUT_MS, TimeUnit.MILLISECONDS);
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertMediaItemHasId(result.getMediaItem(), mediaId);
}
#method_after
@Test
public void testGetItem() throws Exception {
    prepareLooper();
    final String mediaId = MediaBrowserConstants.MEDIA_ID_GET_ITEM;
    BrowserResult result = createBrowser().getItem(mediaId).get(TIMEOUT_MS, TimeUnit.MILLISECONDS);
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    MediaTestUtils.assertMediaItemHasId(result.getMediaItem(), mediaId);
}
#end_block

#method_before
@Test
public void testGetChildren() throws Exception {
    prepareLooper();
    final String parentId = MediaBrowserConstants.PARENT_ID;
    final int page = 4;
    final int pageSize = 10;
    final LibraryParams params = createLibraryParams();
    MediaBrowser browser = createBrowser();
    setExpectedLibraryParam(browser, params);
    BrowserResult result = browser.getChildren(parentId, page, pageSize, params).get(TIMEOUT_MS, TimeUnit.MILLISECONDS);
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertNull(result.getLibraryParams());
    MediaTestUtils.assertPaginatedListHasIds(result.getMediaItems(), MediaBrowserConstants.GET_CHILDREN_RESULT, page, pageSize);
}
#method_after
@Test
public void testGetChildren() throws Exception {
    prepareLooper();
    final String parentId = MediaBrowserConstants.PARENT_ID;
    final int page = 4;
    final int pageSize = 10;
    final LibraryParams params = MediaTestUtils.createLibraryParams();
    MediaBrowser browser = createBrowser();
    setExpectedLibraryParam(browser, params);
    BrowserResult result = browser.getChildren(parentId, page, pageSize, params).get(TIMEOUT_MS, TimeUnit.MILLISECONDS);
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertNull(result.getLibraryParams());
    MediaTestUtils.assertPaginatedListHasIds(result.getMediaItems(), MediaBrowserConstants.GET_CHILDREN_RESULT, page, pageSize);
}
#end_block

#method_before
@Test
@LargeTest
public void testGetChildren_withLongList() throws Exception {
    prepareLooper();
    final String parentId = MediaBrowserConstants.PARENT_ID_LONG_LIST;
    final int page = 0;
    final int pageSize = Integer.MAX_VALUE;
    final LibraryParams params = createLibraryParams();
    MediaBrowser browser = createBrowser();
    setExpectedLibraryParam(browser, params);
    BrowserResult result = browser.getChildren(parentId, page, pageSize, params).get(10, TimeUnit.SECONDS);
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertNull(result.getLibraryParams());
    List<MediaItem> list = result.getMediaItems();
    assertEquals(LONG_LIST_COUNT, list.size());
    for (int i = 0; i < result.getMediaItems().size(); i++) {
        assertEquals(TestUtils.getMediaIdInDummyList(i), list.get(i).getMediaId());
    }
}
#method_after
@Test
@LargeTest
public void testGetChildren_withLongList() throws Exception {
    prepareLooper();
    final String parentId = MediaBrowserConstants.PARENT_ID_LONG_LIST;
    final int page = 0;
    final int pageSize = Integer.MAX_VALUE;
    final LibraryParams params = MediaTestUtils.createLibraryParams();
    MediaBrowser browser = createBrowser();
    setExpectedLibraryParam(browser, params);
    BrowserResult result = browser.getChildren(parentId, page, pageSize, params).get(10, TimeUnit.SECONDS);
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertNull(result.getLibraryParams());
    List<MediaItem> list = result.getMediaItems();
    assertEquals(LONG_LIST_COUNT, list.size());
    for (int i = 0; i < result.getMediaItems().size(); i++) {
        assertEquals(TestUtils.getMediaIdInDummyList(i), list.get(i).getMediaId());
    }
}
#end_block

#method_before
@Test
public void testSearchCallbacks() throws Exception {
    prepareLooper();
    final String query = MediaBrowserConstants.SEARCH_QUERY;
    final int page = 4;
    final int pageSize = 10;
    final LibraryParams testParams = createLibraryParams();
    final CountDownLatch latchForSearch = new CountDownLatch(1);
    final BrowserCallback callback = new BrowserCallback() {

        @Override
        public void onSearchResultChanged(MediaBrowser browser, String queryOut, int itemCount, LibraryParams params) {
            assertEquals(query, queryOut);
            assertEqualLibraryParams(testParams, params);
            assertEquals(MediaBrowserConstants.SEARCH_RESULT_COUNT, itemCount);
            latchForSearch.countDown();
        }
    };
    // Request the search.
    MediaBrowser browser = createBrowser(callback);
    setExpectedLibraryParam(browser, testParams);
    BrowserResult result = browser.search(query, testParams).get(TIMEOUT_MS, TimeUnit.MILLISECONDS);
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    // Get the search result.
    result = browser.getSearchResult(query, page, pageSize, testParams).get(TIMEOUT_MS, TimeUnit.MILLISECONDS);
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertPaginatedListHasIds(result.getMediaItems(), MediaBrowserConstants.SEARCH_RESULT, page, pageSize);
}
#method_after
@Test
public void testSearchCallbacks() throws Exception {
    prepareLooper();
    final String query = MediaBrowserConstants.SEARCH_QUERY;
    final int page = 4;
    final int pageSize = 10;
    final LibraryParams testParams = MediaTestUtils.createLibraryParams();
    final CountDownLatch latchForSearch = new CountDownLatch(1);
    final BrowserCallback callback = new BrowserCallback() {

        @Override
        public void onSearchResultChanged(MediaBrowser browser, String queryOut, int itemCount, LibraryParams params) {
            assertEquals(query, queryOut);
            MediaTestUtils.assertLibraryParamsEquals(testParams, params);
            assertEquals(MediaBrowserConstants.SEARCH_RESULT_COUNT, itemCount);
            latchForSearch.countDown();
        }
    };
    // Request the search.
    MediaBrowser browser = createBrowser(callback);
    setExpectedLibraryParam(browser, testParams);
    BrowserResult result = browser.search(query, testParams).get(TIMEOUT_MS, TimeUnit.MILLISECONDS);
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    // Get the search result.
    result = browser.getSearchResult(query, page, pageSize, testParams).get(TIMEOUT_MS, TimeUnit.MILLISECONDS);
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    MediaTestUtils.assertPaginatedListHasIds(result.getMediaItems(), MediaBrowserConstants.SEARCH_RESULT, page, pageSize);
}
#end_block

#method_before
@Test
@LargeTest
public void testSearchCallbacks_withLongList() throws Exception {
    prepareLooper();
    final String query = MediaBrowserConstants.SEARCH_QUERY_LONG_LIST;
    final int page = 0;
    final int pageSize = Integer.MAX_VALUE;
    final LibraryParams testParams = createLibraryParams();
    final CountDownLatch latch = new CountDownLatch(1);
    final BrowserCallback callback = new BrowserCallback() {

        @Override
        public void onSearchResultChanged(MediaBrowser browser, String queryOut, int itemCount, LibraryParams params) {
            assertEquals(query, queryOut);
            assertEqualLibraryParams(testParams, params);
            assertEquals(MediaBrowserConstants.LONG_LIST_COUNT, itemCount);
            latch.countDown();
        }
    };
    MediaBrowser browser = createBrowser(callback);
    setExpectedLibraryParam(browser, testParams);
    BrowserResult result = browser.search(query, testParams).get(TIMEOUT_MS, TimeUnit.MILLISECONDS);
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    result = browser.getSearchResult(query, page, pageSize, testParams).get(10, TimeUnit.SECONDS);
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    List<MediaItem> list = result.getMediaItems();
    for (int i = 0; i < list.size(); i++) {
        assertEquals(TestUtils.getMediaIdInDummyList(i), list.get(i).getMediaId());
    }
}
#method_after
@Test
@LargeTest
public void testSearchCallbacks_withLongList() throws Exception {
    prepareLooper();
    final String query = MediaBrowserConstants.SEARCH_QUERY_LONG_LIST;
    final int page = 0;
    final int pageSize = Integer.MAX_VALUE;
    final LibraryParams testParams = MediaTestUtils.createLibraryParams();
    final CountDownLatch latch = new CountDownLatch(1);
    final BrowserCallback callback = new BrowserCallback() {

        @Override
        public void onSearchResultChanged(MediaBrowser browser, String queryOut, int itemCount, LibraryParams params) {
            assertEquals(query, queryOut);
            MediaTestUtils.assertLibraryParamsEquals(testParams, params);
            assertEquals(MediaBrowserConstants.LONG_LIST_COUNT, itemCount);
            latch.countDown();
        }
    };
    MediaBrowser browser = createBrowser(callback);
    setExpectedLibraryParam(browser, testParams);
    BrowserResult result = browser.search(query, testParams).get(TIMEOUT_MS, TimeUnit.MILLISECONDS);
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    result = browser.getSearchResult(query, page, pageSize, testParams).get(10, TimeUnit.SECONDS);
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    List<MediaItem> list = result.getMediaItems();
    for (int i = 0; i < list.size(); i++) {
        assertEquals(TestUtils.getMediaIdInDummyList(i), list.get(i).getMediaId());
    }
}
#end_block

#method_before
@Test
@LargeTest
public void testOnSearchResultChanged_searchTakesTime() throws Exception {
    prepareLooper();
    final String query = MediaBrowserConstants.SEARCH_QUERY_TAKES_TIME;
    final LibraryParams testParams = createLibraryParams();
    final CountDownLatch latch = new CountDownLatch(1);
    final BrowserCallback callback = new BrowserCallback() {

        @Override
        public void onSearchResultChanged(MediaBrowser browser, String queryOut, int itemCount, LibraryParams params) {
            assertEquals(query, queryOut);
            assertEqualLibraryParams(testParams, params);
            assertEquals(MediaBrowserConstants.SEARCH_RESULT_COUNT, itemCount);
            latch.countDown();
        }
    };
    MediaBrowser browser = createBrowser(callback);
    setExpectedLibraryParam(browser, testParams);
    BrowserResult result = browser.search(query, testParams).get(MediaBrowserConstants.SEARCH_TIME_IN_MS + TIMEOUT_MS, TimeUnit.MILLISECONDS);
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
}
#method_after
@Test
@LargeTest
public void testOnSearchResultChanged_searchTakesTime() throws Exception {
    prepareLooper();
    final String query = MediaBrowserConstants.SEARCH_QUERY_TAKES_TIME;
    final LibraryParams testParams = MediaTestUtils.createLibraryParams();
    final CountDownLatch latch = new CountDownLatch(1);
    final BrowserCallback callback = new BrowserCallback() {

        @Override
        public void onSearchResultChanged(MediaBrowser browser, String queryOut, int itemCount, LibraryParams params) {
            assertEquals(query, queryOut);
            MediaTestUtils.assertLibraryParamsEquals(testParams, params);
            assertEquals(MediaBrowserConstants.SEARCH_RESULT_COUNT, itemCount);
            latch.countDown();
        }
    };
    MediaBrowser browser = createBrowser(callback);
    setExpectedLibraryParam(browser, testParams);
    BrowserResult result = browser.search(query, testParams).get(MediaBrowserConstants.SEARCH_TIME_IN_MS + TIMEOUT_MS, TimeUnit.MILLISECONDS);
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
}
#end_block

#method_before
@Test
public void testOnSearchResultChanged_emptyResult() throws Exception {
    prepareLooper();
    final String query = MediaBrowserConstants.SEARCH_QUERY_EMPTY_RESULT;
    final LibraryParams testParams = createLibraryParams();
    final CountDownLatch latch = new CountDownLatch(1);
    final BrowserCallback callback = new BrowserCallback() {

        @Override
        public void onSearchResultChanged(MediaBrowser browser, String queryOut, int itemCount, LibraryParams params) {
            assertEquals(query, queryOut);
            assertEqualLibraryParams(testParams, params);
            assertEquals(0, itemCount);
            latch.countDown();
        }
    };
    MediaBrowser browser = createBrowser(callback);
    setExpectedLibraryParam(browser, testParams);
    BrowserResult result = browser.search(query, testParams).get(TIMEOUT_MS, TimeUnit.MILLISECONDS);
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
}
#method_after
@Test
public void testOnSearchResultChanged_emptyResult() throws Exception {
    prepareLooper();
    final String query = MediaBrowserConstants.SEARCH_QUERY_EMPTY_RESULT;
    final LibraryParams testParams = MediaTestUtils.createLibraryParams();
    final CountDownLatch latch = new CountDownLatch(1);
    final BrowserCallback callback = new BrowserCallback() {

        @Override
        public void onSearchResultChanged(MediaBrowser browser, String queryOut, int itemCount, LibraryParams params) {
            assertEquals(query, queryOut);
            MediaTestUtils.assertLibraryParamsEquals(testParams, params);
            assertEquals(0, itemCount);
            latch.countDown();
        }
    };
    MediaBrowser browser = createBrowser(callback);
    setExpectedLibraryParam(browser, testParams);
    BrowserResult result = browser.search(query, testParams).get(TIMEOUT_MS, TimeUnit.MILLISECONDS);
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
}
#end_block

#method_before
@Test
public void testOnChildrenChanged_calledWhenSubscribed() throws Exception {
    // This test uses MediaLibrarySession.notifyChildrenChanged().
    prepareLooper();
    final String expectedParentId = SUBSCRIBE_ID_NOTIFY_CHILDREN_CHANGED_TO_ALL;
    final CountDownLatch latch = new CountDownLatch(1);
    final BrowserCallback controllerCallbackProxy = new BrowserCallback() {

        @Override
        public void onChildrenChanged(MediaBrowser browser, String parentId, int itemCount, LibraryParams params) {
            assertEquals(expectedParentId, parentId);
            assertEquals(NOTIFY_CHILDREN_CHANGED_ITEM_COUNT, itemCount);
            MediaTestUtils.assertEqualLibraryParams(params, NOTIFY_CHILDREN_CHANGED_EXTRAS);
            latch.countDown();
        }
    };
    BrowserResult result = createBrowser(controllerCallbackProxy).subscribe(expectedParentId, null).get(TIMEOUT_MS, TimeUnit.MILLISECONDS);
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    // The MediaLibrarySession in MockMediaLibraryService is supposed to call
    // notifyChildrenChanged() in its callback onSubscribe().
    assertTrue(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
}
#method_after
@Test
public void testOnChildrenChanged_calledWhenSubscribed() throws Exception {
    // This test uses MediaLibrarySession.notifyChildrenChanged().
    prepareLooper();
    final String expectedParentId = SUBSCRIBE_ID_NOTIFY_CHILDREN_CHANGED_TO_ALL;
    final CountDownLatch latch = new CountDownLatch(1);
    final BrowserCallback controllerCallbackProxy = new BrowserCallback() {

        @Override
        public void onChildrenChanged(MediaBrowser browser, String parentId, int itemCount, LibraryParams params) {
            assertEquals(expectedParentId, parentId);
            assertEquals(NOTIFY_CHILDREN_CHANGED_ITEM_COUNT, itemCount);
            MediaTestUtils.assertLibraryParamsEquals(params, NOTIFY_CHILDREN_CHANGED_EXTRAS);
            latch.countDown();
        }
    };
    BrowserResult result = createBrowser(controllerCallbackProxy).subscribe(expectedParentId, null).get(TIMEOUT_MS, TimeUnit.MILLISECONDS);
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    // The MediaLibrarySession in MockMediaLibraryService is supposed to call
    // notifyChildrenChanged() in its callback onSubscribe().
    assertTrue(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
}
#end_block

#method_before
@Test
public void testOnChildrenChanged_calledWhenSubscribed2() throws Exception {
    // This test uses MediaLibrarySession.notifyChildrenChanged(ControllerInfo).
    prepareLooper();
    final String expectedParentId = SUBSCRIBE_ID_NOTIFY_CHILDREN_CHANGED_TO_ONE;
    final CountDownLatch latch = new CountDownLatch(1);
    final BrowserCallback controllerCallbackProxy = new BrowserCallback() {

        @Override
        public void onChildrenChanged(MediaBrowser browser, String parentId, int itemCount, LibraryParams params) {
            assertEquals(expectedParentId, parentId);
            assertEquals(NOTIFY_CHILDREN_CHANGED_ITEM_COUNT, itemCount);
            assertEqualLibraryParams(params, NOTIFY_CHILDREN_CHANGED_EXTRAS);
            latch.countDown();
        }
    };
    BrowserResult result = createBrowser(controllerCallbackProxy).subscribe(expectedParentId, null).get(TIMEOUT_MS, TimeUnit.MILLISECONDS);
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    // The MediaLibrarySession in MockMediaLibraryService is supposed to call
    // notifyChildrenChanged(ControllerInfo) in its callback onSubscribe().
    assertTrue(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
}
#method_after
@Test
public void testOnChildrenChanged_calledWhenSubscribed2() throws Exception {
    // This test uses MediaLibrarySession.notifyChildrenChanged(ControllerInfo).
    prepareLooper();
    final String expectedParentId = SUBSCRIBE_ID_NOTIFY_CHILDREN_CHANGED_TO_ONE;
    final CountDownLatch latch = new CountDownLatch(1);
    final BrowserCallback controllerCallbackProxy = new BrowserCallback() {

        @Override
        public void onChildrenChanged(MediaBrowser browser, String parentId, int itemCount, LibraryParams params) {
            assertEquals(expectedParentId, parentId);
            assertEquals(NOTIFY_CHILDREN_CHANGED_ITEM_COUNT, itemCount);
            MediaTestUtils.assertLibraryParamsEquals(params, NOTIFY_CHILDREN_CHANGED_EXTRAS);
            latch.countDown();
        }
    };
    BrowserResult result = createBrowser(controllerCallbackProxy).subscribe(expectedParentId, null).get(TIMEOUT_MS, TimeUnit.MILLISECONDS);
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    // The MediaLibrarySession in MockMediaLibraryService is supposed to call
    // notifyChildrenChanged(ControllerInfo) in its callback onSubscribe().
    assertTrue(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
}
#end_block

#method_before
@Test
public void testControllerCallback_sessionUpdatePlayer() throws InterruptedException {
    prepareLooper();
    final int testState = SessionPlayer.PLAYER_STATE_PLAYING;
    final List<MediaItem> testPlaylist = MediaTestUtils.createFileMediaItems(3);
    final AudioAttributesCompat testAudioAttributes = new AudioAttributesCompat.Builder().setLegacyStreamType(AudioManager.STREAM_RING).build();
    final CountDownLatch latch = new CountDownLatch(3);
    mController = createController(mRemoteSession2.getToken(), true, /* waitForConnect */
    new MediaController.ControllerCallback() {

        @Override
        public void onPlayerStateChanged(MediaController controller, int state) {
            assertEquals(mController, controller);
            assertEquals(testState, state);
            latch.countDown();
        }

        @Override
        public void onPlaylistChanged(MediaController controller, List<MediaItem> list, MediaMetadata metadata) {
            assertEquals(mController, controller);
            assertNotMediaItemSubclass(list);
            assertEqualMediaIds(testPlaylist, list);
            assertNull(metadata);
            latch.countDown();
        }

        @Override
        public void onPlaybackInfoChanged(MediaController controller, MediaController.PlaybackInfo info) {
            assertEquals(mController, controller);
            assertEquals(testAudioAttributes, info.getAudioAttributes());
            latch.countDown();
        }
    });
    Bundle config = RemoteMediaSession.createMockPlayerConnectorConfig(testState, 0, /* buffState */
    0, /* position */
    0, /* buffPosition */
    0f, /* speed */
    testAudioAttributes, testPlaylist, null, /* currentItem */
    null);
    mRemoteSession2.updatePlayer(config);
    assertTrue(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
}
#method_after
@Test
public void testControllerCallback_sessionUpdatePlayer() throws InterruptedException {
    prepareLooper();
    final int testState = SessionPlayer.PLAYER_STATE_PLAYING;
    final List<MediaItem> testPlaylist = MediaTestUtils.createFileMediaItems(3);
    final AudioAttributesCompat testAudioAttributes = new AudioAttributesCompat.Builder().setLegacyStreamType(AudioManager.STREAM_RING).build();
    final CountDownLatch latch = new CountDownLatch(3);
    mController = createController(mRemoteSession2.getToken(), true, /* waitForConnect */
    new MediaController.ControllerCallback() {

        @Override
        public void onPlayerStateChanged(MediaController controller, int state) {
            assertEquals(mController, controller);
            assertEquals(testState, state);
            latch.countDown();
        }

        @Override
        public void onPlaylistChanged(MediaController controller, List<MediaItem> list, MediaMetadata metadata) {
            assertEquals(mController, controller);
            MediaTestUtils.assertNotMediaItemSubclass(list);
            MediaTestUtils.assertMediaIdEquals(testPlaylist, list);
            assertNull(metadata);
            latch.countDown();
        }

        @Override
        public void onPlaybackInfoChanged(MediaController controller, MediaController.PlaybackInfo info) {
            assertEquals(mController, controller);
            assertEquals(testAudioAttributes, info.getAudioAttributes());
            latch.countDown();
        }
    });
    Bundle config = RemoteMediaSession.createMockPlayerConnectorConfig(testState, 0, /* buffState */
    0, /* position */
    0, /* buffPosition */
    0f, /* speed */
    testAudioAttributes, testPlaylist, null, /* currentItem */
    null);
    mRemoteSession2.updatePlayer(config);
    assertTrue(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
}
#end_block

#method_before
@Test
public void testOnCurrentMediaItemChanged() throws Exception {
    prepareLooper();
    final int listSize = 5;
    final List<MediaItem> list = MediaTestUtils.createFileMediaItems(listSize);
    mRemoteSession2.getMockPlayer().setPlaylistWithDummyItem(list);
    final int currentItemIndex = 3;
    final MediaItem currentItem = list.get(currentItemIndex);
    final CountDownLatch latchForControllerCallback = new CountDownLatch(3);
    MediaController controller = createController(mRemoteSession2.getToken(), true, new MediaController.ControllerCallback() {

        @Override
        public void onCurrentMediaItemChanged(MediaController controller, MediaItem item) {
            switch((int) latchForControllerCallback.getCount()) {
                case 3:
                    // No check needed..
                    break;
                case 2:
                    assertNotMediaItemSubclass(item);
                    assertEquals(currentItem.getMediaId(), item.getMediaId());
                    break;
                case 1:
                    assertNull(item);
            }
            latchForControllerCallback.countDown();
        }
    });
    // Player notifies with the unknown item. Still OK.
    mRemoteSession2.getMockPlayer().notifyCurrentMediaItemChanged(INDEX_FOR_UNKONWN_ITEM);
    // Known ITEM should be notified through the onCurrentMediaItemChanged.
    mRemoteSession2.getMockPlayer().notifyCurrentMediaItemChanged(currentItemIndex);
    // Null ITEM becomes null MediaItem.
    mRemoteSession2.getMockPlayer().notifyCurrentMediaItemChanged(INDEX_FOR_NULL_ITEM);
    assertTrue(latchForControllerCallback.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
}
#method_after
@Test
public void testOnCurrentMediaItemChanged() throws Exception {
    prepareLooper();
    final int listSize = 5;
    final List<MediaItem> list = MediaTestUtils.createFileMediaItems(listSize);
    mRemoteSession2.getMockPlayer().setPlaylistWithDummyItem(list);
    final int currentItemIndex = 3;
    final MediaItem currentItem = list.get(currentItemIndex);
    final CountDownLatch latchForControllerCallback = new CountDownLatch(3);
    MediaController controller = createController(mRemoteSession2.getToken(), true, new MediaController.ControllerCallback() {

        @Override
        public void onCurrentMediaItemChanged(MediaController controller, MediaItem item) {
            switch((int) latchForControllerCallback.getCount()) {
                case 3:
                    // No check needed..
                    break;
                case 2:
                    MediaTestUtils.assertNotMediaItemSubclass(item);
                    assertEquals(currentItem.getMediaId(), item.getMediaId());
                    break;
                case 1:
                    assertNull(item);
            }
            latchForControllerCallback.countDown();
        }
    });
    // Player notifies with the unknown item. Still OK.
    mRemoteSession2.getMockPlayer().notifyCurrentMediaItemChanged(INDEX_FOR_UNKONWN_ITEM);
    // Known ITEM should be notified through the onCurrentMediaItemChanged.
    mRemoteSession2.getMockPlayer().notifyCurrentMediaItemChanged(currentItemIndex);
    // Null ITEM becomes null MediaItem.
    mRemoteSession2.getMockPlayer().notifyCurrentMediaItemChanged(INDEX_FOR_NULL_ITEM);
    assertTrue(latchForControllerCallback.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
}
#end_block

#method_before
@Test
public void testOnPlaylistChanged() throws InterruptedException {
    prepareLooper();
    final List<MediaItem> testList = MediaTestUtils.createFileMediaItems(2);
    final AtomicReference<List<MediaItem>> listFromCallback = new AtomicReference<>();
    final CountDownLatch latch = new CountDownLatch(1);
    final MediaController.ControllerCallback callback = new MediaController.ControllerCallback() {

        @Override
        public void onPlaylistChanged(MediaController controller, List<MediaItem> playlist, MediaMetadata metadata) {
            assertNotNull(playlist);
            assertNotMediaItemSubclass(playlist);
            assertEqualMediaIds(testList, playlist);
            listFromCallback.set(playlist);
            latch.countDown();
        }
    };
    MediaController controller = createController(mRemoteSession2.getToken(), true, callback);
    mRemoteSession2.getMockPlayer().setPlaylist(testList);
    mRemoteSession2.getMockPlayer().notifyPlaylistChanged();
    assertTrue(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
    assertEquals(listFromCallback.get(), controller.getPlaylist());
}
#method_after
@Test
public void testOnPlaylistChanged() throws InterruptedException {
    prepareLooper();
    final List<MediaItem> testList = MediaTestUtils.createFileMediaItems(2);
    final AtomicReference<List<MediaItem>> listFromCallback = new AtomicReference<>();
    final CountDownLatch latch = new CountDownLatch(1);
    final MediaController.ControllerCallback callback = new MediaController.ControllerCallback() {

        @Override
        public void onPlaylistChanged(MediaController controller, List<MediaItem> playlist, MediaMetadata metadata) {
            assertNotNull(playlist);
            MediaTestUtils.assertNotMediaItemSubclass(playlist);
            MediaTestUtils.assertMediaIdEquals(testList, playlist);
            listFromCallback.set(playlist);
            latch.countDown();
        }
    };
    MediaController controller = createController(mRemoteSession2.getToken(), true, callback);
    mRemoteSession2.getMockPlayer().setPlaylist(testList);
    mRemoteSession2.getMockPlayer().notifyPlaylistChanged();
    assertTrue(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
    assertEquals(listFromCallback.get(), controller.getPlaylist());
}
#end_block

#method_before
@Test
public void testOnPlaylistMetadataChanged_withManyLargeImages() throws InterruptedException {
    prepareLooper();
    final int imageCount = 100;
    final int originalWidth = 1024;
    final int originalHeight = 1024;
    final CountDownLatch latch = new CountDownLatch(1);
    final MediaController.ControllerCallback callback = new MediaController.ControllerCallback() {

        @Override
        public void onPlaylistMetadataChanged(MediaController controller, MediaMetadata metadata) {
            assertNotNull(metadata);
            Set<String> keySet = metadata.keySet();
            assertEquals(imageCount, keySet.size());
            for (String key : keySet) {
                Bitmap value = metadata.getBitmap(key);
                assertTrue("Bitmap should have been scaled down.", originalWidth > value.getWidth() && originalHeight > value.getHeight());
            }
            latch.countDown();
        }
    };
    RemoteMediaSession.RemoteMockPlayer player = mRemoteSession2.getMockPlayer();
    player.setPlaylistMetadataWithLargeBitmaps(imageCount, originalWidth, originalHeight);
    MediaController controller = createController(mRemoteSession2.getToken(), true, callback);
    player.notifyPlaylistMetadataChanged();
    assertTrue(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
}
#method_after
@Test
@LargeTest
public void testOnPlaylistMetadataChanged_withManyLargeImages() throws InterruptedException {
    prepareLooper();
    final int imageCount = 20;
    final int originalWidth = 1024;
    final int originalHeight = 1024;
    final CountDownLatch latch = new CountDownLatch(1);
    final MediaController.ControllerCallback callback = new MediaController.ControllerCallback() {

        @Override
        public void onPlaylistMetadataChanged(MediaController controller, MediaMetadata metadata) {
            assertNotNull(metadata);
            Set<String> keySet = metadata.keySet();
            assertEquals(imageCount, keySet.size());
            for (String key : keySet) {
                Bitmap value = metadata.getBitmap(key);
                assertTrue("Bitmap should have been scaled down.", originalWidth > value.getWidth() && originalHeight > value.getHeight());
            }
            latch.countDown();
        }
    };
    RemoteMediaSession.RemoteMockPlayer player = mRemoteSession2.getMockPlayer();
    player.setPlaylistMetadataWithLargeBitmaps(imageCount, originalWidth, originalHeight);
    MediaController controller = createController(mRemoteSession2.getToken(), true, callback);
    player.notifyPlaylistMetadataChanged();
    assertTrue(latch.await(3, TimeUnit.SECONDS));
}
#end_block

#method_before
@Test
public void testOnBufferingStateChanged() throws InterruptedException {
    prepareLooper();
    final CountDownLatch latch = new CountDownLatch(1);
    final List<MediaItem> testPlaylist = MediaTestUtils.createFileMediaItems(3);
    final int targetItemIndex = 0;
    final int testBufferingState = SessionPlayer.BUFFERING_STATE_BUFFERING_AND_PLAYABLE;
    final long testBufferingPosition = 500;
    final MediaController.ControllerCallback callback = new MediaController.ControllerCallback() {

        @Override
        public void onBufferingStateChanged(MediaController controller, MediaItem item, int state) {
            controller.setTimeDiff(0L);
            assertNotMediaItemSubclass(item);
            assertEquals(testPlaylist.get(targetItemIndex).getMediaId(), item.getMediaId());
            assertEquals(testBufferingState, state);
            assertEquals(testBufferingState, controller.getBufferingState());
            assertEquals(testBufferingPosition, controller.getBufferedPosition());
            latch.countDown();
        }
    };
    mRemoteSession2.getMockPlayer().setPlaylistWithDummyItem(testPlaylist);
    RemoteMediaSession.RemoteMockPlayer player = mRemoteSession2.getMockPlayer();
    player.setBufferedPosition(testBufferingPosition);
    MediaController controller = createController(mRemoteSession2.getToken(), true, callback);
    // Since we cannot pass the DataSourceDesc directly, send the item index so that the player
    // can select which item's state change should be notified.
    player.notifyBufferingStateChanged(targetItemIndex, testBufferingState);
    assertTrue(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
}
#method_after
@Test
public void testOnBufferingStateChanged() throws InterruptedException {
    prepareLooper();
    final CountDownLatch latch = new CountDownLatch(1);
    final List<MediaItem> testPlaylist = MediaTestUtils.createFileMediaItems(3);
    final int targetItemIndex = 0;
    final int testBufferingState = SessionPlayer.BUFFERING_STATE_BUFFERING_AND_PLAYABLE;
    final long testBufferingPosition = 500;
    final MediaController.ControllerCallback callback = new MediaController.ControllerCallback() {

        @Override
        public void onBufferingStateChanged(MediaController controller, MediaItem item, int state) {
            controller.setTimeDiff(0L);
            MediaTestUtils.assertNotMediaItemSubclass(item);
            assertEquals(testPlaylist.get(targetItemIndex).getMediaId(), item.getMediaId());
            assertEquals(testBufferingState, state);
            assertEquals(testBufferingState, controller.getBufferingState());
            assertEquals(testBufferingPosition, controller.getBufferedPosition());
            latch.countDown();
        }
    };
    mRemoteSession2.getMockPlayer().setPlaylistWithDummyItem(testPlaylist);
    RemoteMediaSession.RemoteMockPlayer player = mRemoteSession2.getMockPlayer();
    player.setBufferedPosition(testBufferingPosition);
    MediaController controller = createController(mRemoteSession2.getToken(), true, callback);
    // Since we cannot pass the DataSourceDesc directly, send the item index so that the player
    // can select which item's state change should be notified.
    player.notifyBufferingStateChanged(targetItemIndex, testBufferingState);
    assertTrue(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
}
#end_block

#method_before
// ExoPlayerWrapper.Listener implementation.
@Override
public void onPrepared(MediaItem mediaItem2) {
    notifyOnInfo(mediaItem2, MEDIA_INFO_PREPARED);
    synchronized (mTaskLock) {
        if (mCurrentTask != null && mCurrentTask.mMediaCallType == CALL_COMPLETED_PREPARE && ObjectsCompat.equals(mCurrentTask.mDSD, mediaItem2) && mCurrentTask.mNeedToWaitForEventToComplete) {
            mCurrentTask.sendCompleteNotification(CALL_STATUS_NO_ERROR);
            mCurrentTask = null;
            processPendingTask();
        }
    }
}
#method_after
// ExoPlayerWrapper.Listener implementation.
@Override
public void onPrepared(MediaItem mediaItem) {
    notifyOnInfo(mediaItem, MEDIA_INFO_PREPARED);
    synchronized (mTaskLock) {
        if (mCurrentTask != null && mCurrentTask.mMediaCallType == CALL_COMPLETED_PREPARE && ObjectsCompat.equals(mCurrentTask.mDSD, mediaItem) && mCurrentTask.mNeedToWaitForEventToComplete) {
            mCurrentTask.sendCompleteNotification(CALL_STATUS_NO_ERROR);
            mCurrentTask = null;
            processPendingTask();
        }
    }
}
#end_block

#method_before
@Override
public void onMetadataChanged(MediaItem mediaItem2) {
    notifyOnInfo(mediaItem2, MEDIA_INFO_METADATA_UPDATE);
}
#method_after
@Override
public void onMetadataChanged(MediaItem mediaItem) {
    notifyOnInfo(mediaItem, MEDIA_INFO_METADATA_UPDATE);
}
#end_block

#method_before
@Override
public void onBufferingStarted(MediaItem mediaItem2) {
    notifyOnInfo(mediaItem2, MEDIA_INFO_BUFFERING_START);
}
#method_after
@Override
public void onBufferingStarted(MediaItem mediaItem) {
    notifyOnInfo(mediaItem, MEDIA_INFO_BUFFERING_START);
}
#end_block

#method_before
@Override
public void onBufferingEnded(MediaItem mediaItem2) {
    notifyOnInfo(mediaItem2, MEDIA_INFO_BUFFERING_END);
}
#method_after
@Override
public void onBufferingEnded(MediaItem mediaItem) {
    notifyOnInfo(mediaItem, MEDIA_INFO_BUFFERING_END);
}
#end_block

#method_before
@Override
public void onVideoRenderingStart(MediaItem mediaItem2) {
    notifyOnInfo(mediaItem2, MEDIA_INFO_VIDEO_RENDERING_START);
}
#method_after
@Override
public void onVideoRenderingStart(MediaItem mediaItem) {
    notifyOnInfo(mediaItem, MEDIA_INFO_VIDEO_RENDERING_START);
}
#end_block

#method_before
@Override
public void onVideoSizeChanged(final MediaItem mediaItem2, final int width, final int height) {
    notifyMediaPlayer2Event(new ExoPlayerMediaPlayer2Impl.Mp2EventNotifier() {

        @Override
        public void notify(MediaPlayer2.EventCallback callback) {
            callback.onVideoSizeChanged(ExoPlayerMediaPlayer2Impl.this, mediaItem2, width, height);
        }
    });
}
#method_after
@Override
public void onVideoSizeChanged(final MediaItem mediaItem, final int width, final int height) {
    notifyMediaPlayer2Event(new ExoPlayerMediaPlayer2Impl.Mp2EventNotifier() {

        @Override
        public void notify(MediaPlayer2.EventCallback callback) {
            callback.onVideoSizeChanged(ExoPlayerMediaPlayer2Impl.this, mediaItem, width, height);
        }
    });
}
#end_block

#method_before
@Override
public void onSubtitleData(final MediaItem mediaItem2, final SubtitleData subtitleData2) {
    notifyMediaPlayer2Event(new Mp2EventNotifier() {

        @Override
        public void notify(EventCallback cb) {
            cb.onSubtitleData(ExoPlayerMediaPlayer2Impl.this, mediaItem2, subtitleData2);
        }
    });
}
#method_after
@Override
public void onSubtitleData(final MediaItem mediaItem, final SubtitleData subtitleData) {
    notifyMediaPlayer2Event(new Mp2EventNotifier() {

        @Override
        public void notify(EventCallback cb) {
            cb.onSubtitleData(ExoPlayerMediaPlayer2Impl.this, mediaItem, subtitleData);
        }
    });
}
#end_block

#method_before
@Override
public void onMediaItemStartedAsNext(final MediaItem mediaItem2) {
    notifyOnInfo(mediaItem2, MEDIA_INFO_DATA_SOURCE_START);
}
#method_after
@Override
public void onMediaItemStartedAsNext(final MediaItem mediaItem) {
    notifyOnInfo(mediaItem, MEDIA_INFO_DATA_SOURCE_START);
}
#end_block

#method_before
@Override
public void onMediaItemEnded(MediaItem mediaItem2) {
    notifyOnInfo(mediaItem2, MEDIA_INFO_DATA_SOURCE_END);
}
#method_after
@Override
public void onMediaItemEnded(MediaItem mediaItem) {
    notifyOnInfo(mediaItem, MEDIA_INFO_DATA_SOURCE_END);
}
#end_block

#method_before
@Override
public void onLoop(MediaItem mediaItem2) {
    notifyOnInfo(mediaItem2, MEDIA_INFO_DATA_SOURCE_REPEAT);
}
#method_after
@Override
public void onLoop(MediaItem mediaItem) {
    notifyOnInfo(mediaItem, MEDIA_INFO_DATA_SOURCE_REPEAT);
}
#end_block

#method_before
@Override
public void onMediaTimeDiscontinuity(final MediaItem mediaItem2, final MediaTimestamp mediaTimestamp2) {
    notifyMediaPlayer2Event(new Mp2EventNotifier() {

        @Override
        public void notify(EventCallback cb) {
            cb.onMediaTimeDiscontinuity(ExoPlayerMediaPlayer2Impl.this, mediaItem2, mediaTimestamp2);
        }
    });
}
#method_after
@Override
public void onMediaTimeDiscontinuity(final MediaItem mediaItem, final MediaTimestamp mediaTimestamp) {
    notifyMediaPlayer2Event(new Mp2EventNotifier() {

        @Override
        public void notify(EventCallback cb) {
            cb.onMediaTimeDiscontinuity(ExoPlayerMediaPlayer2Impl.this, mediaItem, mediaTimestamp);
        }
    });
}
#end_block

#method_before
@Override
public void onPlaybackEnded(MediaItem mediaItem2) {
    notifyOnInfo(mediaItem2, MEDIA_INFO_DATA_SOURCE_LIST_END);
}
#method_after
@Override
public void onPlaybackEnded(MediaItem mediaItem) {
    notifyOnInfo(mediaItem, MEDIA_INFO_DATA_SOURCE_LIST_END);
}
#end_block

#method_before
@Override
public void onError(final MediaItem mediaItem2, final int what) {
    synchronized (mTaskLock) {
        if (mCurrentTask != null && mCurrentTask.mNeedToWaitForEventToComplete) {
            mCurrentTask.sendCompleteNotification(CALL_STATUS_ERROR_UNKNOWN);
            mCurrentTask = null;
            processPendingTask();
        }
    }
    notifyMediaPlayer2Event(new Mp2EventNotifier() {

        @Override
        public void notify(EventCallback cb) {
            cb.onError(ExoPlayerMediaPlayer2Impl.this, mediaItem2, what, /* extra= */
            0);
        }
    });
}
#method_after
@Override
public void onError(final MediaItem mediaItem, final int what) {
    synchronized (mTaskLock) {
        if (mCurrentTask != null && mCurrentTask.mNeedToWaitForEventToComplete) {
            mCurrentTask.sendCompleteNotification(CALL_STATUS_ERROR_UNKNOWN);
            mCurrentTask = null;
            processPendingTask();
        }
    }
    notifyMediaPlayer2Event(new Mp2EventNotifier() {

        @Override
        public void notify(EventCallback cb) {
            cb.onError(ExoPlayerMediaPlayer2Impl.this, mediaItem, what, /* extra= */
            0);
        }
    });
}
#end_block

#method_before
// Internal functionality.
private void notifyOnInfo(MediaItem mediaItem2, int what) {
    notifyOnInfo(mediaItem2, what, /* extra= */
    0);
}
#method_after
// Internal functionality.
private void notifyOnInfo(MediaItem mediaItem, int what) {
    notifyOnInfo(mediaItem, what, /* extra= */
    0);
}
#end_block

#method_before
private void notifyOnInfo(final MediaItem mediaItem2, final int what, final int extra) {
    notifyMediaPlayer2Event(new ExoPlayerMediaPlayer2Impl.Mp2EventNotifier() {

        @Override
        public void notify(MediaPlayer2.EventCallback callback) {
            callback.onInfo(ExoPlayerMediaPlayer2Impl.this, mediaItem2, what, extra);
        }
    });
}
#method_after
private void notifyOnInfo(final MediaItem mediaItem, final int what, final int extra) {
    notifyMediaPlayer2Event(new ExoPlayerMediaPlayer2Impl.Mp2EventNotifier() {

        @Override
        public void notify(MediaPlayer2.EventCallback callback) {
            callback.onInfo(ExoPlayerMediaPlayer2Impl.this, mediaItem, what, extra);
        }
    });
}
#end_block

#method_before
public static MediaMetadataCompat convertToMediaMetadataCompat(MediaMetadata metadata) {
    if (metadata == null) {
        return null;
    }
    MediaMetadataCompat.Builder builder = new MediaMetadataCompat.Builder();
    Bundle bundle = metadata.toBundle();
    for (String key : bundle.keySet()) {
        Object value = bundle.get(key);
        if (value instanceof CharSequence) {
            builder.putText(key, (CharSequence) value);
        } else if (value instanceof Rating) {
            builder.putRating(key, convertToRatingCompat((Rating) value));
        } else if (value instanceof Bitmap) {
            builder.putBitmap(key, (Bitmap) value);
        } else if (value instanceof Long) {
            builder.putLong(key, (Long) value);
        }
    }
    return builder.build();
}
#method_after
public static MediaMetadataCompat convertToMediaMetadataCompat(MediaMetadata metadata) {
    if (metadata == null) {
        return null;
    }
    MediaMetadataCompat.Builder builder = new MediaMetadataCompat.Builder();
    for (String key : metadata.keySet()) {
        Object value = metadata.getObject(key);
        if (value instanceof CharSequence) {
            builder.putText(key, (CharSequence) value);
        } else if (value instanceof Rating) {
            builder.putRating(key, convertToRatingCompat((Rating) value));
        } else if (value instanceof Bitmap) {
            builder.putBitmap(key, (Bitmap) value);
        } else if (value instanceof Long) {
            builder.putLong(key, (Long) value);
        }
    }
    return builder.build();
}
#end_block

#method_before
@Override
void onLibraryResult(int seq, LibraryResult result) throws RemoteException {
// No-op. BrowserCompat doesn't understand Browser2 features.
}
#method_after
@Override
void onLibraryResult(int seq, LibraryResult result) throws RemoteException {
// No-op. BrowserCompat doesn't understand Browser features.
}
#end_block

#method_before
@Override
void onSearchResultChanged(String query, int itemCount, LibraryParams params) throws RemoteException {
    // In MediaLibrarySession/MediaBrowser, we have two different APIs for getting size of
    // search result (and also starting search) and getting result.
    // However, MediaBrowserService2/MediaBrowserCompat only have one search API for getting
    // search result.
    final List<SearchRequest> searchRequests = new ArrayList<>();
    synchronized (mLock) {
        for (int i = mSearchRequests.size() - 1; i >= 0; i--) {
            SearchRequest iter = mSearchRequests.get(i);
            if (ObjectsCompat.equals(mRemoteUserInfo, iter.mRemoteUserInfo) && iter.mQuery.equals(query)) {
                searchRequests.add(iter);
                mSearchRequests.remove(i);
            }
        }
        if (searchRequests.size() == 0) {
            if (DEBUG) {
                Log.d(TAG, "search() hasn't called by " + mRemoteUserInfo + " with query=" + query);
            }
            return;
        }
    }
    mLibrarySessionImpl.getCallbackExecutor().execute(new Runnable() {

        @Override
        public void run() {
            for (int i = 0; i < searchRequests.size(); i++) {
                SearchRequest request = searchRequests.get(i);
                int page = 0;
                int pageSize = Integer.MAX_VALUE;
                if (request.mExtras != null) {
                    try {
                        request.mExtras.setClassLoader(mLibrarySessionImpl.getContext().getClassLoader());
                        page = request.mExtras.getInt(MediaBrowserCompat.EXTRA_PAGE, -1);
                        pageSize = request.mExtras.getInt(MediaBrowserCompat.EXTRA_PAGE_SIZE, -1);
                    } catch (BadParcelableException e) {
                        request.mResult.sendResult(null);
                        return;
                    }
                }
                if (page < 0 || pageSize < 1) {
                    page = 0;
                    pageSize = Integer.MAX_VALUE;
                }
                LibraryParams params = MediaUtils.convertToLibraryParams(mLibrarySessionImpl.getContext(), request.mExtras);
                LibraryResult libraryResult = mLibrarySessionImpl.getCallback().onGetSearchResult(mLibrarySessionImpl.getInstance(), request.mController, request.mQuery, page, pageSize, params);
                if (libraryResult == null || libraryResult.getResultCode() != RESULT_CODE_SUCCESS) {
                    request.mResult.sendResult(null);
                } else {
                    request.mResult.sendResult(MediaUtils.truncateListBySize(MediaUtils.convertToMediaItemList(libraryResult.getMediaItems()), TRANSACTION_SIZE_LIMIT_IN_BYTES));
                }
            }
        }
    });
}
#method_after
@Override
void onSearchResultChanged(String query, int itemCount, LibraryParams params) throws RemoteException {
    // In MediaLibrarySession/MediaBrowser, we have two different APIs for getting size of
    // search result (and also starting search) and getting result.
    // However, MediaBrowserService/MediaBrowserCompat only have one search API for getting
    // search result.
    final List<SearchRequest> searchRequests = new ArrayList<>();
    synchronized (mLock) {
        for (int i = mSearchRequests.size() - 1; i >= 0; i--) {
            SearchRequest iter = mSearchRequests.get(i);
            if (ObjectsCompat.equals(mRemoteUserInfo, iter.mRemoteUserInfo) && iter.mQuery.equals(query)) {
                searchRequests.add(iter);
                mSearchRequests.remove(i);
            }
        }
        if (searchRequests.size() == 0) {
            if (DEBUG) {
                Log.d(TAG, "search() hasn't called by " + mRemoteUserInfo + " with query=" + query);
            }
            return;
        }
    }
    mLibrarySessionImpl.getCallbackExecutor().execute(new Runnable() {

        @Override
        public void run() {
            for (int i = 0; i < searchRequests.size(); i++) {
                SearchRequest request = searchRequests.get(i);
                int page = 0;
                int pageSize = Integer.MAX_VALUE;
                if (request.mExtras != null) {
                    try {
                        request.mExtras.setClassLoader(mLibrarySessionImpl.getContext().getClassLoader());
                        page = request.mExtras.getInt(MediaBrowserCompat.EXTRA_PAGE, -1);
                        pageSize = request.mExtras.getInt(MediaBrowserCompat.EXTRA_PAGE_SIZE, -1);
                    } catch (BadParcelableException e) {
                        request.mResult.sendResult(null);
                        return;
                    }
                }
                if (page < 0 || pageSize < 1) {
                    page = 0;
                    pageSize = Integer.MAX_VALUE;
                }
                LibraryParams params = MediaUtils.convertToLibraryParams(mLibrarySessionImpl.getContext(), request.mExtras);
                LibraryResult libraryResult = mLibrarySessionImpl.getCallback().onGetSearchResult(mLibrarySessionImpl.getInstance(), request.mController, request.mQuery, page, pageSize, params);
                if (libraryResult == null || libraryResult.getResultCode() != RESULT_CODE_SUCCESS) {
                    request.mResult.sendResult(null);
                } else {
                    request.mResult.sendResult(MediaUtils.truncateListBySize(MediaUtils.convertToMediaItemList(libraryResult.getMediaItems()), TRANSACTION_SIZE_LIMIT_IN_BYTES));
                }
            }
        }
    });
}
#end_block

#method_before
public static MediaSource createUnclippedMediaSource(DataSource.Factory dataSourceFactory, MediaItem mediaItem2) {
    if (mediaItem2 instanceof UriMediaItem) {
        Uri uri = ((UriMediaItem) mediaItem2).getUri();
        if (Util.inferContentType(uri) == C.TYPE_HLS) {
            return new HlsMediaSource.Factory(dataSourceFactory).setTag(mediaItem2).createMediaSource(uri);
        } else {
            return new ExtractorMediaSource.Factory(dataSourceFactory).setExtractorsFactory(sExtractorsFactory).setTag(mediaItem2).createMediaSource(uri);
        }
    } else if (mediaItem2 instanceof FileMediaItem) {
        return new ExtractorMediaSource.Factory(dataSourceFactory).setExtractorsFactory(sExtractorsFactory).setTag(mediaItem2).createMediaSource(Uri.EMPTY);
    } else if (mediaItem2 instanceof CallbackMediaItem) {
        CallbackMediaItem callbackMediaItem = (CallbackMediaItem) mediaItem2;
        dataSourceFactory = DataSourceCallbackDataSource.getFactory(callbackMediaItem.getDataSourceCallback());
        return new ExtractorMediaSource.Factory(dataSourceFactory).setExtractorsFactory(sExtractorsFactory).setTag(mediaItem2).createMediaSource(Uri.EMPTY);
    } else {
        throw new IllegalStateException();
    }
}
#method_after
public static MediaSource createUnclippedMediaSource(DataSource.Factory dataSourceFactory, MediaItem mediaItem) {
    if (mediaItem instanceof UriMediaItem) {
        Uri uri = ((UriMediaItem) mediaItem).getUri();
        if (Util.inferContentType(uri) == C.TYPE_HLS) {
            return new HlsMediaSource.Factory(dataSourceFactory).setTag(mediaItem).createMediaSource(uri);
        } else {
            return new ExtractorMediaSource.Factory(dataSourceFactory).setExtractorsFactory(sExtractorsFactory).setTag(mediaItem).createMediaSource(uri);
        }
    } else if (mediaItem instanceof FileMediaItem) {
        return new ExtractorMediaSource.Factory(dataSourceFactory).setExtractorsFactory(sExtractorsFactory).setTag(mediaItem).createMediaSource(Uri.EMPTY);
    } else if (mediaItem instanceof CallbackMediaItem) {
        CallbackMediaItem callbackMediaItem = (CallbackMediaItem) mediaItem;
        dataSourceFactory = DataSourceCallbackDataSource.getFactory(callbackMediaItem.getDataSourceCallback());
        return new ExtractorMediaSource.Factory(dataSourceFactory).setExtractorsFactory(sExtractorsFactory).setTag(mediaItem).createMediaSource(Uri.EMPTY);
    } else {
        throw new IllegalStateException();
    }
}
#end_block

#method_before
@Override
public void setPlaylistMetadata(String sessionId, Bundle metadata) throws RemoteException {
    MediaSession session = mSessionMap.get(sessionId);
    MockPlayer player = (MockPlayer) session.getPlayer();
    player.mMetadata = MediaMetadata.fromBundle(metadata);
}
#method_after
@Override
public void setPlaylistMetadata(String sessionId, ParcelImpl metadata) throws RemoteException {
    MediaSession session = mSessionMap.get(sessionId);
    MockPlayer player = (MockPlayer) session.getPlayer();
    player.mMetadata = MediaUtils.fromParcelable(metadata);
}
#end_block

#method_before
@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    // Remove title bar
    requestWindowFeature(Window.FEATURE_NO_TITLE);
    setContentView(R.layout.video_activity);
    mVideoView = findViewById(R.id.video_view);
    mVideoView.setActivity(this);
    String errorString = null;
    Intent intent = getIntent();
    Uri videoUri;
    if (intent == null || (videoUri = intent.getData()) == null || !videoUri.isAbsolute()) {
        errorString = "Invalid intent";
    } else {
        mUseTextureView = intent.getBooleanExtra(USE_TEXTURE_VIEW_EXTRA_NAME, false);
        if (mUseTextureView) {
            mVideoView.setViewType(VideoView2.VIEW_TYPE_TEXTUREVIEW);
        }
        UriMediaItem mediaItem = new UriMediaItem.Builder(this, videoUri).build();
        mVideoView.setMediaItem2(mediaItem);
        mMediaControlView = new MediaControlView2(this);
        mVideoView.setMediaControlView2(mMediaControlView, 2000);
        mMediaControlView.setOnFullScreenListener(new FullScreenListener());
        SessionToken token = mVideoView.getSession2Token();
        Executor executor = ContextCompat.getMainExecutor(this);
        mMediaController = new MediaController(this, token, executor, new ControllerCallback());
    }
    if (errorString != null) {
        showErrorDialog(errorString);
    }
}
#method_after
@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    // Remove title bar
    requestWindowFeature(Window.FEATURE_NO_TITLE);
    setContentView(R.layout.video_activity);
    mVideoView = findViewById(R.id.video_view);
    mVideoView.setActivity(this);
    String errorString = null;
    Intent intent = getIntent();
    Uri videoUri;
    if (intent == null || (videoUri = intent.getData()) == null || !videoUri.isAbsolute()) {
        errorString = "Invalid intent";
    } else {
        mUseTextureView = intent.getBooleanExtra(USE_TEXTURE_VIEW_EXTRA_NAME, false);
        if (mUseTextureView) {
            mVideoView.setViewType(VideoView2.VIEW_TYPE_TEXTUREVIEW);
        }
        UriMediaItem mediaItem = new UriMediaItem.Builder(this, videoUri).build();
        mVideoView.setMediaItem(mediaItem);
        mMediaControlView = new MediaControlView2(this);
        mVideoView.setMediaControlView2(mMediaControlView, 2000);
        mMediaControlView.setOnFullScreenListener(new FullScreenListener());
        SessionToken token = mVideoView.getSessionToken();
        Executor executor = ContextCompat.getMainExecutor(this);
        mMediaController = new MediaController(this, token, executor, new ControllerCallback());
    }
    if (errorString != null) {
        showErrorDialog(errorString);
    }
}
#end_block

#method_before
public void setPlaylistMetadata(MediaMetadata metadata) {
    try {
        mBinder.setPlaylistMetadata(mSessionId, metadata.toBundle());
    } catch (RemoteException ex) {
        Log.e(TAG, "Failed to call setPlaylistMetadata()");
    }
}
#method_after
public void setPlaylistMetadata(MediaMetadata metadata) {
    try {
        mBinder.setPlaylistMetadata(mSessionId, MediaUtils.toParcelable(metadata));
    } catch (RemoteException ex) {
        Log.e(TAG, "Failed to call setPlaylistMetadata()");
    }
}
#end_block

#method_before
private void dispatchSessionTaskInternal(@NonNull IMediaController caller, final int seq, @Nullable final SessionCommand sessionCommand, @CommandCode final int commandCode, @NonNull final SessionTask task) {
    final ControllerInfo controller = mConnectedControllersManager.getController(caller.asBinder());
    if (mSessionImpl.isClosed() || controller == null) {
        return;
    }
    mSessionImpl.getCallbackExecutor().execute(new Runnable() {

        @Override
        public void run() {
            if (!mConnectedControllersManager.isConnected(controller)) {
                return;
            }
            SessionCommand commandForOnCommandRequest;
            if (sessionCommand != null) {
                if (!mConnectedControllersManager.isAllowedCommand(controller, sessionCommand)) {
                    if (DEBUG) {
                        Log.d(TAG, "Command (" + sessionCommand + ") from " + controller + " isn't allowed.");
                    }
                    return;
                }
                commandForOnCommandRequest = sCommandsForOnCommandRequest.get(sessionCommand.getCommandCode());
            } else {
                if (!mConnectedControllersManager.isAllowedCommand(controller, commandCode)) {
                    if (DEBUG) {
                        Log.d(TAG, "Command (" + commandCode + ") from " + controller + " isn't allowed.");
                    }
                    return;
                }
                commandForOnCommandRequest = sCommandsForOnCommandRequest.get(commandCode);
            }
            try {
                if (commandForOnCommandRequest != null) {
                    int resultCode = mSessionImpl.getCallback().onCommandRequest(mSessionImpl.getInstance(), controller, commandForOnCommandRequest);
                    if (resultCode != RESULT_CODE_SUCCESS) {
                        // Don't run rejected command.
                        if (DEBUG) {
                            Log.d(TAG, "Command (" + commandForOnCommandRequest + ") from " + controller + " was rejected by " + mSessionImpl + ", code=" + resultCode);
                        }
                        sendSessionResult(controller, seq, resultCode);
                        return;
                    }
                }
                if (task instanceof SessionPlayerTask) {
                    final ListenableFuture<PlayerResult> future = ((SessionPlayerTask) task).run(controller);
                    if (future == null) {
                        throw new RuntimeException("SessionPlayer has returned null," + " commandCode=" + commandCode);
                    } else {
                        future.addListener(new Runnable() {

                            @Override
                            public void run() {
                                try {
                                    sendPlayerResult(controller, seq, future.get(0, TimeUnit.MILLISECONDS));
                                } catch (Exception e) {
                                    Log.w(TAG, "Cannot obtain PlayerResult after the" + " command is finished", e);
                                    sendSessionResult(controller, seq, RESULT_CODE_INVALID_STATE);
                                }
                            }
                        }, DIRECT_EXECUTOR);
                    }
                } else if (task instanceof SessionCallbackTask) {
                    final Object result = ((SessionCallbackTask) task).run(controller);
                    if (result == null) {
                        throw new RuntimeException("SessionCallback has returned null," + " commandCode=" + commandCode);
                    } else if (result instanceof Integer) {
                        sendSessionResult(controller, seq, (Integer) result);
                    } else if (result instanceof SessionResult) {
                        sendSessionResult(controller, seq, (SessionResult) result);
                    } else if (DEBUG) {
                        throw new RuntimeException("Unexpected return type " + result + ". Fix bug");
                    }
                } else if (task instanceof LibrarySessionCallbackTask) {
                    final Object result = ((LibrarySessionCallbackTask) task).run(controller);
                    if (result == null) {
                        throw new RuntimeException("LibrarySessionCallback has returned" + " null, commandCode=" + commandCode);
                    } else if (result instanceof Integer) {
                        sendLibraryResult(controller, seq, (Integer) result);
                    } else if (result instanceof LibraryResult) {
                        sendLibraryResult(controller, seq, (LibraryResult) result);
                    } else if (DEBUG) {
                        throw new RuntimeException("Unexpected return type " + result + ". Fix bug");
                    }
                } else if (DEBUG) {
                    throw new RuntimeException("Unknown task " + task + ". Fix bug");
                }
            } catch (RemoteException e) {
                // Currently it's TransactionTooLargeException or DeadSystemException.
                // We'd better to leave log for those cases because
                // - TransactionTooLargeException means that we may need to fix our code.
                // (e.g. add pagination or special way to deliver Bitmap)
                // - DeadSystemException means that errors around it can be ignored.
                Log.w(TAG, "Exception in " + controller.toString(), e);
            } catch (Exception e) {
                // Any random exception may be happen inside of the session player / callback.
                if (RETHROW_EXCEPTION) {
                    throw e;
                }
                if (task instanceof PlayerTask) {
                    sendPlayerResult(controller, seq, new PlayerResult(PlayerResult.RESULT_CODE_UNKNOWN_ERROR, null));
                } else if (task instanceof SessionCallbackTask) {
                    sendSessionResult(controller, seq, SessionResult.RESULT_CODE_UNKNOWN_ERROR);
                } else if (task instanceof LibrarySessionCallbackTask) {
                    sendLibraryResult(controller, seq, LibraryResult.RESULT_CODE_UNKNOWN_ERROR);
                }
            }
        }
    });
}
#method_after
private void dispatchSessionTaskInternal(@NonNull IMediaController caller, final int seq, @Nullable final SessionCommand sessionCommand, @CommandCode final int commandCode, @NonNull final SessionTask task) {
    final long token = Binder.clearCallingIdentity();
    try {
        final ControllerInfo controller = mConnectedControllersManager.getController(caller.asBinder());
        if (mSessionImpl.isClosed() || controller == null) {
            return;
        }
        mSessionImpl.getCallbackExecutor().execute(new Runnable() {

            @Override
            public void run() {
                if (!mConnectedControllersManager.isConnected(controller)) {
                    return;
                }
                SessionCommand commandForOnCommandRequest;
                if (sessionCommand != null) {
                    if (!mConnectedControllersManager.isAllowedCommand(controller, sessionCommand)) {
                        if (DEBUG) {
                            Log.d(TAG, "Command (" + sessionCommand + ") from " + controller + " isn't allowed.");
                        }
                        return;
                    }
                    commandForOnCommandRequest = sCommandsForOnCommandRequest.get(sessionCommand.getCommandCode());
                } else {
                    if (!mConnectedControllersManager.isAllowedCommand(controller, commandCode)) {
                        if (DEBUG) {
                            Log.d(TAG, "Command (" + commandCode + ") from " + controller + " isn't allowed.");
                        }
                        return;
                    }
                    commandForOnCommandRequest = sCommandsForOnCommandRequest.get(commandCode);
                }
                try {
                    if (commandForOnCommandRequest != null) {
                        int resultCode = mSessionImpl.getCallback().onCommandRequest(mSessionImpl.getInstance(), controller, commandForOnCommandRequest);
                        if (resultCode != RESULT_CODE_SUCCESS) {
                            // Don't run rejected command.
                            if (DEBUG) {
                                Log.d(TAG, "Command (" + commandForOnCommandRequest + ") from " + controller + " was rejected by " + mSessionImpl + ", code=" + resultCode);
                            }
                            sendSessionResult(controller, seq, resultCode);
                            return;
                        }
                    }
                    if (task instanceof SessionPlayerTask) {
                        final ListenableFuture<PlayerResult> future = ((SessionPlayerTask) task).run(controller);
                        if (future == null) {
                            throw new RuntimeException("SessionPlayer has returned null," + " commandCode=" + commandCode);
                        } else {
                            future.addListener(new Runnable() {

                                @Override
                                public void run() {
                                    try {
                                        sendPlayerResult(controller, seq, future.get(0, TimeUnit.MILLISECONDS));
                                    } catch (Exception e) {
                                        Log.w(TAG, "Cannot obtain PlayerResult after the" + " command is finished", e);
                                        sendSessionResult(controller, seq, RESULT_CODE_INVALID_STATE);
                                    }
                                }
                            }, DIRECT_EXECUTOR);
                        }
                    } else if (task instanceof SessionCallbackTask) {
                        final Object result = ((SessionCallbackTask) task).run(controller);
                        if (result == null) {
                            throw new RuntimeException("SessionCallback has returned null," + " commandCode=" + commandCode);
                        } else if (result instanceof Integer) {
                            sendSessionResult(controller, seq, (Integer) result);
                        } else if (result instanceof SessionResult) {
                            sendSessionResult(controller, seq, (SessionResult) result);
                        } else if (DEBUG) {
                            throw new RuntimeException("Unexpected return type " + result + ". Fix bug");
                        }
                    } else if (task instanceof LibrarySessionCallbackTask) {
                        final Object result = ((LibrarySessionCallbackTask) task).run(controller);
                        if (result == null) {
                            throw new RuntimeException("LibrarySessionCallback has returned" + " null, commandCode=" + commandCode);
                        } else if (result instanceof Integer) {
                            sendLibraryResult(controller, seq, (Integer) result);
                        } else if (result instanceof LibraryResult) {
                            sendLibraryResult(controller, seq, (LibraryResult) result);
                        } else if (DEBUG) {
                            throw new RuntimeException("Unexpected return type " + result + ". Fix bug");
                        }
                    } else if (DEBUG) {
                        throw new RuntimeException("Unknown task " + task + ". Fix bug");
                    }
                } catch (RemoteException e) {
                    // Currently it's TransactionTooLargeException or DeadSystemException.
                    // We'd better to leave log for those cases because
                    // - TransactionTooLargeException means that we may need to fix our code.
                    // (e.g. add pagination or special way to deliver Bitmap)
                    // - DeadSystemException means that errors around it can be ignored.
                    Log.w(TAG, "Exception in " + controller.toString(), e);
                } catch (Exception e) {
                    if (RETHROW_EXCEPTION) {
                        throw e;
                    }
                    if (task instanceof PlayerTask) {
                        sendPlayerResult(controller, seq, new PlayerResult(PlayerResult.RESULT_CODE_UNKNOWN_ERROR, null));
                    } else if (task instanceof SessionCallbackTask) {
                        sendSessionResult(controller, seq, SessionResult.RESULT_CODE_UNKNOWN_ERROR);
                    } else if (task instanceof LibrarySessionCallbackTask) {
                        sendLibraryResult(controller, seq, LibraryResult.RESULT_CODE_UNKNOWN_ERROR);
                    }
                }
            }
        });
    } finally {
        Binder.restoreCallingIdentity(token);
    }
}
#end_block

#method_before
// ////////////////////////////////////////////////////////////////////////////////////////////
// AIDL methods for session overrides
// ////////////////////////////////////////////////////////////////////////////////////////////
@Override
public void connect(final IMediaController caller, int seq, final String callingPackage) throws RuntimeException {
    if (caller == null || TextUtils.isEmpty(callingPackage)) {
        return;
    }
    connect(caller, callingPackage, Binder.getCallingPid(), Binder.getCallingUid());
}
#method_after
// ////////////////////////////////////////////////////////////////////////////////////////////
// AIDL methods for session overrides
// ////////////////////////////////////////////////////////////////////////////////////////////
@Override
public void connect(final IMediaController caller, int seq, final String callingPackage) throws RuntimeException {
    if (caller == null || TextUtils.isEmpty(callingPackage)) {
        return;
    }
    final int pid = Binder.getCallingPid();
    final int uid = Binder.getCallingUid();
    final long token = Binder.clearCallingIdentity();
    try {
        connect(caller, callingPackage, pid, uid);
    } finally {
        Binder.restoreCallingIdentity(token);
    }
}
#end_block

#method_before
@Override
public void release(final IMediaController caller, int seq) throws RemoteException {
    if (caller == null) {
        return;
    }
    mConnectedControllersManager.removeController(caller.asBinder());
}
#method_after
@Override
public void release(final IMediaController caller, int seq) throws RemoteException {
    if (caller == null) {
        return;
    }
    final long token = Binder.clearCallingIdentity();
    try {
        mConnectedControllersManager.removeController(caller.asBinder());
    } finally {
        Binder.restoreCallingIdentity(token);
    }
}
#end_block

#method_before
@Override
public void onControllerResult(final IMediaController caller, int seq, final ParcelImpl controllerResult) {
    if (caller == null || controllerResult == null) {
        return;
    }
    SequencedFutureManager manager = mConnectedControllersManager.getSequencedFutureManager(caller.asBinder());
    if (manager == null) {
        return;
    }
    MediaController.ControllerResult result = MediaUtils.fromParcelable(controllerResult);
    manager.setFutureResult(seq, SessionResult.from(result));
}
#method_after
@Override
public void onControllerResult(final IMediaController caller, int seq, final ParcelImpl controllerResult) {
    if (caller == null || controllerResult == null) {
        return;
    }
    final long token = Binder.clearCallingIdentity();
    try {
        SequencedFutureManager manager = mConnectedControllersManager.getSequencedFutureManager(caller.asBinder());
        if (manager == null) {
            return;
        }
        MediaController.ControllerResult result = MediaUtils.fromParcelable(controllerResult);
        manager.setFutureResult(seq, SessionResult.from(result));
    } finally {
        Binder.restoreCallingIdentity(token);
    }
}
#end_block

#method_before
private boolean isRateLimited(long now) {
    final long millisSinceLast = now - mLastNotificationMillis;
    if (millisSinceLast < mRateLimitMillis && mLastNotificationMillis > 0) {
        return true;
    }
    mLastNotificationMillis = now;
    return false;
}
#method_after
private boolean isRateLimited(long now) {
    final long millisSinceLast = now - mLastNotificationMillis;
    if (millisSinceLast < mRateLimitMillis) {
        return true;
    }
    mLastNotificationMillis = now;
    return false;
}
#end_block

#method_before
public static MediaMetadataCompat convertToMediaMetadataCompat(MediaMetadata2 metadata2) {
    if (metadata2 == null) {
        return null;
    }
    MediaMetadataCompat.Builder builder = new MediaMetadataCompat.Builder();
    Bundle bundle = metadata2.toBundle();
    for (String key : bundle.keySet()) {
        Object value = bundle.get(key);
        if (value instanceof CharSequence) {
            builder.putText(key, (CharSequence) value);
        } else if (value instanceof Rating2) {
            builder.putRating(key, convertToRatingCompat((Rating2) value));
        } else if (value instanceof Bitmap) {
            builder.putBitmap(key, (Bitmap) value);
        } else if (value instanceof Long) {
            builder.putLong(key, (Long) value);
        }
    }
    return builder.build();
}
#method_after
public static MediaMetadataCompat convertToMediaMetadataCompat(MediaMetadata2 metadata2) {
    if (metadata2 == null) {
        return null;
    }
    MediaMetadataCompat.Builder builder = new MediaMetadataCompat.Builder();
    for (String key : metadata2.keySet()) {
        Object value = metadata2.getObject(key);
        if (value instanceof CharSequence) {
            builder.putText(key, (CharSequence) value);
        } else if (value instanceof Rating2) {
            builder.putRating(key, convertToRatingCompat((Rating2) value));
        } else if (value instanceof Bitmap) {
            builder.putBitmap(key, (Bitmap) value);
        } else if (value instanceof Long) {
            builder.putLong(key, (Long) value);
        }
    }
    return builder.build();
}
#end_block

#method_before
public static SessionCommandGroup2 convertToSessionCommandGroup(long sessionFlags, PlaybackStateCompat state) {
    SessionCommandGroup2.Builder commandsBuilder = new SessionCommandGroup2.Builder();
    boolean includePlaylistCommands = (sessionFlags & FLAG_HANDLES_QUEUE_COMMANDS) != 0;
    commandsBuilder.addAllPlayerCommands(COMMAND_VERSION_CURRENT, includePlaylistCommands);
    commandsBuilder.addAllVolumeCommands(COMMAND_VERSION_CURRENT);
    commandsBuilder.addAllSessionCommands(COMMAND_VERSION_CURRENT);
    commandsBuilder.removeCommand(COMMAND_CODE_PLAYER_SET_SPEED);
    commandsBuilder.removeCommand(COMMAND_CODE_SESSION_SUBSCRIBE_ROUTES_INFO);
    commandsBuilder.removeCommand(COMMAND_CODE_SESSION_UNSUBSCRIBE_ROUTES_INFO);
    commandsBuilder.removeCommand(COMMAND_CODE_SESSION_SELECT_ROUTE);
    commandsBuilder.addCommand(new SessionCommand2(SESSION_COMMAND_ON_EXTRA_CHANGED, null));
    commandsBuilder.addCommand(new SessionCommand2(SESSION_COMMAND_ON_CAPTIONING_ENABLED_CHANGED, null));
    if (state != null && state.getCustomActions() != null) {
        for (CustomAction customAction : state.getCustomActions()) {
            commandsBuilder.addCommand(new SessionCommand2(customAction.getAction(), customAction.getExtras()));
        }
    }
    return commandsBuilder.build();
}
#method_after
@NonNull
public static SessionCommandGroup2 convertToSessionCommandGroup(long sessionFlags, PlaybackStateCompat state) {
    SessionCommandGroup2.Builder commandsBuilder = new SessionCommandGroup2.Builder();
    boolean includePlaylistCommands = (sessionFlags & FLAG_HANDLES_QUEUE_COMMANDS) != 0;
    commandsBuilder.addAllPlayerCommands(COMMAND_VERSION_CURRENT, includePlaylistCommands);
    commandsBuilder.addAllVolumeCommands(COMMAND_VERSION_CURRENT);
    commandsBuilder.addAllSessionCommands(COMMAND_VERSION_CURRENT);
    commandsBuilder.removeCommand(COMMAND_CODE_PLAYER_SET_SPEED);
    commandsBuilder.removeCommand(COMMAND_CODE_SESSION_SUBSCRIBE_ROUTES_INFO);
    commandsBuilder.removeCommand(COMMAND_CODE_SESSION_UNSUBSCRIBE_ROUTES_INFO);
    commandsBuilder.removeCommand(COMMAND_CODE_SESSION_SELECT_ROUTE);
    if (state != null && state.getCustomActions() != null) {
        for (CustomAction customAction : state.getCustomActions()) {
            commandsBuilder.addCommand(new SessionCommand2(customAction.getAction(), customAction.getExtras()));
        }
    }
    return commandsBuilder.build();
}
#end_block

#method_before
public static List<CommandButton> convertToCustomLayout(PlaybackStateCompat state) {
    List<CommandButton> layout = new ArrayList<>();
    if (state == null) {
        return layout;
    }
    for (CustomAction action : state.getCustomActions()) {
        CommandButton button = new CommandButton.Builder().setCommand(new SessionCommand2(action.getAction(), action.getExtras())).setDisplayName(action.getName()).setEnabled(true).setIconResId(action.getIcon()).build();
        layout.add(button);
    }
    return layout;
}
#method_after
@NonNull
public static List<CommandButton> convertToCustomLayout(PlaybackStateCompat state) {
    List<CommandButton> layout = new ArrayList<>();
    if (state == null) {
        return layout;
    }
    for (CustomAction action : state.getCustomActions()) {
        CommandButton button = new CommandButton.Builder().setCommand(new SessionCommand2(action.getAction(), action.getExtras())).setDisplayName(action.getName()).setEnabled(true).setIconResId(action.getIcon()).build();
        layout.add(button);
    }
    return layout;
}
#end_block

#method_before
@Override
public ListenableFuture<ControllerResult> sendCustomCommand(@NonNull SessionCommand2 command, @Nullable Bundle args) {
    synchronized (mLock) {
        if (!mConnected) {
            Log.w(TAG, "Session isn't active", new IllegalStateException());
            return createFutureWithResult(RESULT_CODE_DISCONNECTED);
        }
        final ResolvableFuture<ControllerResult> result = ResolvableFuture.create();
        ResultReceiver cb = new ResultReceiver(mHandler) {

            @Override
            protected void onReceiveResult(int resultCode, Bundle resultData) {
                result.set(new ControllerResult(resultCode, resultData));
            }
        };
        mControllerCompat.sendCommand(command.getCustomCommand(), args, cb);
        return result;
    }
}
#method_after
@Override
public ListenableFuture<ControllerResult> sendCustomCommand(@NonNull SessionCommand2 command, @Nullable Bundle args) {
    synchronized (mLock) {
        if (!mConnected) {
            Log.w(TAG, "Session isn't active", new IllegalStateException());
            return createFutureWithResult(RESULT_CODE_DISCONNECTED);
        }
        if (mAllowedCommands.hasCommand(command)) {
            mControllerCompat.getTransportControls().sendCustomAction(command.getCustomCommand(), args);
            return createFutureWithResult(RESULT_CODE_SUCCESS);
        }
        final ResolvableFuture<ControllerResult> result = ResolvableFuture.create();
        ResultReceiver cb = new ResultReceiver(mHandler) {

            @Override
            protected void onReceiveResult(int resultCode, Bundle resultData) {
                result.set(new ControllerResult(resultCode, resultData));
            }
        };
        mControllerCompat.sendCommand(command.getCustomCommand(), args, cb);
        return result;
    }
}
#end_block

#method_before
void onConnectedNotLocked() {
    if (DEBUG) {
        Log.d(TAG, "onConnectedNotLocked token=" + mToken);
    }
    final SessionCommandGroup2 allowedCommands;
    final List<CommandButton> customLayout;
    synchronized (mLock) {
        if (mIsReleased || mConnected) {
            return;
        }
        mPlaybackStateCompat = mControllerCompat.getPlaybackState();
        mAllowedCommands = MediaUtils2.convertToSessionCommandGroup(mControllerCompat.getFlags(), mPlaybackStateCompat);
        mPlayerState = MediaUtils2.convertToPlayerState(mPlaybackStateCompat);
        mBufferedPosition = mPlaybackStateCompat == null ? UNKNOWN_TIME : mPlaybackStateCompat.getBufferedPosition();
        mCustomLayout = MediaUtils2.convertToCustomLayout(mPlaybackStateCompat);
        allowedCommands = mAllowedCommands;
        customLayout = mCustomLayout;
        mPlaybackInfo = MediaUtils2.toPlaybackInfo2(mControllerCompat.getPlaybackInfo());
        mRepeatMode = mControllerCompat.getRepeatMode();
        mShuffleMode = mControllerCompat.getShuffleMode();
        mQueue = MediaUtils2.removeNullElements(mControllerCompat.getQueue());
        if (mQueue == null || mQueue.size() == 0) {
            // MediaSessionCompat can set queue as null or empty. However, SessionPlayer2 should
            // not set playlist as null or empty. Therefore, we treat them as the same.
            mQueue = null;
            mPlaylist = null;
        } else {
            mPlaylist = MediaUtils2.convertQueueItemListToMediaItem2List(mQueue);
        }
        mPlaylistMetadata = MediaUtils2.convertToMediaMetadata2(mControllerCompat.getQueueTitle());
        // Call this after set playlist.
        setCurrentMediaItemLocked(mControllerCompat.getMetadata());
        mConnected = true;
    }
    mCallbackExecutor.execute(new Runnable() {

        @Override
        public void run() {
            mCallback.onConnected(mInstance, allowedCommands);
        }
    });
    if (customLayout.size() != 0) {
        mCallbackExecutor.execute(new Runnable() {

            @Override
            public void run() {
                mCallback.onSetCustomLayout(mInstance, customLayout);
            }
        });
    }
}
#method_after
void onConnectedNotLocked() {
    if (DEBUG) {
        Log.d(TAG, "onConnectedNotLocked token=" + mToken);
    }
    final SessionCommandGroup2 allowedCommands;
    final List<CommandButton> customLayout;
    synchronized (mLock) {
        if (mIsReleased || mConnected) {
            return;
        }
        mPlaybackStateCompat = mControllerCompat.getPlaybackState();
        mAllowedCommands = MediaUtils2.convertToSessionCommandGroup(mControllerCompat.getFlags(), mPlaybackStateCompat);
        mPlayerState = MediaUtils2.convertToPlayerState(mPlaybackStateCompat);
        mBufferedPosition = mPlaybackStateCompat == null ? UNKNOWN_TIME : mPlaybackStateCompat.getBufferedPosition();
        mCustomLayout = MediaUtils2.convertToCustomLayout(mPlaybackStateCompat);
        allowedCommands = mAllowedCommands;
        customLayout = mCustomLayout;
        mPlaybackInfo = MediaUtils2.toPlaybackInfo2(mControllerCompat.getPlaybackInfo());
        mRepeatMode = mControllerCompat.getRepeatMode();
        mShuffleMode = mControllerCompat.getShuffleMode();
        mQueue = MediaUtils2.removeNullElements(mControllerCompat.getQueue());
        if (mQueue == null || mQueue.size() == 0) {
            // MediaSessionCompat can set queue as null or empty. However, SessionPlayer2 should
            // not set playlist as null or empty. Therefore, we treat them as the same.
            mQueue = null;
            mPlaylist = null;
        } else {
            mPlaylist = MediaUtils2.convertQueueItemListToMediaItem2List(mQueue);
        }
        mPlaylistMetadata = MediaUtils2.convertToMediaMetadata2(mControllerCompat.getQueueTitle());
        // Call this after set playlist.
        setCurrentMediaItemLocked(mControllerCompat.getMetadata());
        mConnected = true;
    }
    mCallbackExecutor.execute(new Runnable() {

        @Override
        public void run() {
            mCallback.onConnected(mInstance, allowedCommands);
        }
    });
    if (!customLayout.isEmpty()) {
        mCallbackExecutor.execute(new Runnable() {

            @Override
            public void run() {
                mCallback.onSetCustomLayout(mInstance, customLayout);
            }
        });
    }
}
#end_block

#method_before
@Override
public void onExtrasChanged(final Bundle extras) {
    mCallbackExecutor.execute(new Runnable() {

        @Override
        public void run() {
            mCallback.onCustomCommand(mInstance, new SessionCommand2(MediaUtils2.SESSION_COMMAND_ON_EXTRA_CHANGED, null), extras);
        }
    });
}
#method_after
@Override
public void onExtrasChanged(final Bundle extras) {
    mCallbackExecutor.execute(new Runnable() {

        @Override
        public void run() {
            mCallback.onCustomCommand(mInstance, new SessionCommand2(SESSION_COMMAND_ON_EXTRAS_CHANGED, null), extras);
        }
    });
}
#end_block

#method_before
@Override
public void onCaptioningEnabledChanged(boolean enabled) {
    mCallbackExecutor.execute(new Runnable() {

        @Override
        public void run() {
            mCallback.onCustomCommand(mInstance, new SessionCommand2(MediaUtils2.SESSION_COMMAND_ON_CAPTIONING_ENABLED_CHANGED, null), null);
        }
    });
}
#method_after
@Override
public void onCaptioningEnabledChanged(final boolean enabled) {
    mCallbackExecutor.execute(new Runnable() {

        @Override
        public void run() {
            mCallback.onCustomCommand(mInstance, new SessionCommand2(SESSION_COMMAND_ON_CAPTIONING_ENABLED_CHANGED, null), null);
        }
    });
}
#end_block

#method_before
@Test
public void testControllerCallback_onCurrentMediaItemChanged_byMetadataChange() throws Exception {
    prepareLooper();
    final String testMediaId = "testControllerCallback_onCurrentMediaItemChanged_bySetMetadata";
    final CountDownLatch latch = new CountDownLatch(1);
    final ControllerCallback callback = new ControllerCallback() {

        @Override
        public void onCurrentMediaItemChanged(MediaController2 controller, MediaItem2 item) {
            assertMediaItemHasId(item, testMediaId);
            latch.countDown();
        }
    };
    mController = createController(mSession.getSessionToken(), true, callback);
    MediaMetadataCompat metadata = new MediaMetadataCompat.Builder().putText(MediaMetadataCompat.METADATA_KEY_MEDIA_ID, testMediaId).build();
    mSession.setMetadata(metadata);
    assertTrue(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
}
#method_after
@Test
public void testControllerCallback_onCurrentMediaItemChanged_byMetadataChange() throws Exception {
    prepareLooper();
    final String testMediaId = "testControllerCallback_onCurrentMediaItemChanged_bySetMetadata";
    final CountDownLatch latch = new CountDownLatch(1);
    final ControllerCallback callback = new ControllerCallback() {

        @Override
        public void onCurrentMediaItemChanged(MediaController2 controller, MediaItem2 item) {
            MediaTestUtils.assertMediaItemHasId(item, testMediaId);
            latch.countDown();
        }
    };
    mController = createController(mSession.getSessionToken(), true, callback);
    MediaMetadataCompat metadata = new MediaMetadataCompat.Builder().putText(MediaMetadataCompat.METADATA_KEY_MEDIA_ID, testMediaId).build();
    mSession.setMetadata(metadata);
    assertTrue(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
}
#end_block

#method_before
@Test
public void testControllerCallback_onCurrentMediaItemChanged_byActiveQueueItemChange() throws Exception {
    prepareLooper();
    final List<MediaItem2> testList = MediaTestUtils.createFileMediaItems(2);
    final List<QueueItem> testQueue = MediaUtils2.convertToQueueItemList(testList);
    mSession.setQueue(testQueue);
    PlaybackStateCompat.Builder builder = new PlaybackStateCompat.Builder();
    // Set the current active queue item to index 'oldItemIndex'.
    final int oldItemIndex = 0;
    builder.setActiveQueueItemId(testQueue.get(oldItemIndex).getQueueId());
    mSession.setPlaybackState(builder.build());
    final int newItemIndex = 1;
    final CountDownLatch latch = new CountDownLatch(1);
    final ControllerCallback callback = new ControllerCallback() {

        @Override
        public void onCurrentMediaItemChanged(MediaController2 controller, MediaItem2 item) {
            assertEqualMediaIds(testList.get(newItemIndex), item);
            latch.countDown();
        }
    };
    mController = createController(mSession.getSessionToken(), true, callback);
    // The new playbackState will tell the controller that the active queue item is changed to
    // 'newItemIndex'.
    builder.setActiveQueueItemId(testQueue.get(newItemIndex).getQueueId());
    mSession.setPlaybackState(builder.build());
    assertTrue(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
}
#method_after
@Test
public void testControllerCallback_onCurrentMediaItemChanged_byActiveQueueItemChange() throws Exception {
    prepareLooper();
    final List<MediaItem2> testList = MediaTestUtils.createFileMediaItems(2);
    final List<QueueItem> testQueue = MediaUtils2.convertToQueueItemList(testList);
    mSession.setQueue(testQueue);
    PlaybackStateCompat.Builder builder = new PlaybackStateCompat.Builder();
    // Set the current active queue item to index 'oldItemIndex'.
    final int oldItemIndex = 0;
    builder.setActiveQueueItemId(testQueue.get(oldItemIndex).getQueueId());
    mSession.setPlaybackState(builder.build());
    final int newItemIndex = 1;
    final CountDownLatch latch = new CountDownLatch(1);
    final ControllerCallback callback = new ControllerCallback() {

        @Override
        public void onCurrentMediaItemChanged(MediaController2 controller, MediaItem2 item) {
            MediaTestUtils.assertMediaIdEquals(testList.get(newItemIndex), item);
            latch.countDown();
        }
    };
    mController = createController(mSession.getSessionToken(), true, callback);
    // The new playbackState will tell the controller that the active queue item is changed to
    // 'newItemIndex'.
    builder.setActiveQueueItemId(testQueue.get(newItemIndex).getQueueId());
    mSession.setPlaybackState(builder.build());
    assertTrue(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
}
#end_block

#method_before
@Test
public void testControllerCallback_onPlaybackInfoChanged_byPlaybackTypeChangeToLocal() throws Exception {
    prepareLooper();
    mSession.setPlaybackToRemote(VolumeProviderCompat.VOLUME_CONTROL_ABSOLUTE, 100, 45);
    final int testLocalStreamType = AudioManager.STREAM_ALARM;
    final int maxVolume = mAudioManager.getStreamMaxVolume(testLocalStreamType);
    final int currentVolume = mAudioManager.getStreamVolume(testLocalStreamType);
    final CountDownLatch latch = new CountDownLatch(1);
    final ControllerCallback callback = new ControllerCallback() {

        @Override
        public void onPlaybackInfoChanged(MediaController2 controller, MediaController2.PlaybackInfo info) {
            assertEquals(MediaController2.PlaybackInfo.PLAYBACK_TYPE_LOCAL, info.getPlaybackType());
            assertEquals(RemoteSessionPlayer2.VOLUME_CONTROL_ABSOLUTE, info.getControlType());
            assertEquals(maxVolume, info.getMaxVolume());
            assertEquals(currentVolume, info.getCurrentVolume());
            latch.countDown();
        }
    };
    mController = createController(mSession.getSessionToken(), true, callback);
    mSession.setPlaybackToLocal(testLocalStreamType);
    assertTrue(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
}
#method_after
@Test
public void testControllerCallback_onPlaybackInfoChanged_byPlaybackTypeChangeToLocal() throws Exception {
    if (Build.VERSION.SDK_INT == 21 || Build.VERSION.SDK_INT == 22) {
        // In API 21 and 22, onAudioInfoChanged is not called.
        return;
    }
    prepareLooper();
    mSession.setPlaybackToRemote(VolumeProviderCompat.VOLUME_CONTROL_ABSOLUTE, 100, 45);
    final int testLocalStreamType = AudioManager.STREAM_ALARM;
    final int maxVolume = mAudioManager.getStreamMaxVolume(testLocalStreamType);
    final int currentVolume = mAudioManager.getStreamVolume(testLocalStreamType);
    final CountDownLatch latch = new CountDownLatch(1);
    final ControllerCallback callback = new ControllerCallback() {

        @Override
        public void onPlaybackInfoChanged(MediaController2 controller, MediaController2.PlaybackInfo info) {
            assertEquals(MediaController2.PlaybackInfo.PLAYBACK_TYPE_LOCAL, info.getPlaybackType());
            assertEquals(RemoteSessionPlayer2.VOLUME_CONTROL_ABSOLUTE, info.getControlType());
            assertEquals(maxVolume, info.getMaxVolume());
            assertEquals(currentVolume, info.getCurrentVolume());
            latch.countDown();
        }
    };
    mController = createController(mSession.getSessionToken(), true, callback);
    mSession.setPlaybackToLocal(testLocalStreamType);
    assertTrue(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
}
#end_block

#method_before
@Test
public void testControllerCallback_onAllowedCommandChanged() throws Exception {
    prepareLooper();
    final CustomAction testCustomAction1 = new CustomAction.Builder("testCustomAction1", "testName1", 1).build();
    final CustomAction testCustomAction2 = new CustomAction.Builder("testCustomAction2", "testName2", 2).build();
    final CountDownLatch latch = new CountDownLatch(1);
    final ControllerCallback callback = new ControllerCallback() {

        @Override
        public void onAllowedCommandsChanged(MediaController2 controller, SessionCommandGroup2 commands) {
            assertFalse(commands.hasCommand(new SessionCommand2(testCustomAction1.getAction(), testCustomAction1.getExtras())));
            latch.countDown();
        }
    };
    mSession.setPlaybackState(new PlaybackStateCompat.Builder().addCustomAction(testCustomAction1).build());
    // onSetCustomLayout will be called when its connected
    mController = createController(mSession.getSessionToken(), true, callback);
    // onSetCustomLayout will be called again when the custom action in the playback state is
    // changed.
    mSession.setPlaybackState(new PlaybackStateCompat.Builder().addCustomAction(testCustomAction2).build());
    assertTrue(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
}
#method_after
@Test
public void testControllerCallback_onAllowedCommandChanged() throws Exception {
    prepareLooper();
    final CustomAction testCustomAction1 = new CustomAction.Builder("testCustomAction1", "testName1", 1).build();
    final CustomAction testCustomAction2 = new CustomAction.Builder("testCustomAction2", "testName2", 2).build();
    final CountDownLatch latch = new CountDownLatch(1);
    final ControllerCallback callback = new ControllerCallback() {

        @Override
        public void onAllowedCommandsChanged(MediaController2 controller, SessionCommandGroup2 commands) {
            assertFalse(commands.hasCommand(new SessionCommand2(testCustomAction1.getAction(), testCustomAction1.getExtras())));
            assertTrue(commands.hasCommand(new SessionCommand2(testCustomAction2.getAction(), testCustomAction2.getExtras())));
            latch.countDown();
        }
    };
    mSession.setPlaybackState(new PlaybackStateCompat.Builder().addCustomAction(testCustomAction1).build());
    mController = createController(mSession.getSessionToken(), true, callback);
    mSession.setPlaybackState(new PlaybackStateCompat.Builder().addCustomAction(testCustomAction2).build());
    assertTrue(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
}
#end_block

#method_before
public int getRowHeight(RowContent row, SliceViewPolicy policy) {
    int maxHeight = policy.getMaxSmallHeight() > 0 ? policy.getMaxSmallHeight() : mMaxHeight;
    if (row.getRange() != null || policy.getMode() == MODE_LARGE) {
        if (row.getRange() != null) {
            // Range element always has set height and then the height of the text
            // area on the row will vary depending on if 1 or 2 lines of text.
            int textAreaHeight = row.getLineCount() > 1 ? mTextWithRangeHeight : mSingleTextWithRangeHeight;
            return textAreaHeight + mRangeHeight;
        } else {
            return (row.getLineCount() > 1 || row.getIsHeader()) ? maxHeight : mMinHeight;
        }
    } else {
        return maxHeight;
    }
}
#method_after
public int getRowHeight(RowContent row, SliceViewPolicy policy) {
    int maxHeight = policy.getMaxSmallHeight() > 0 ? policy.getMaxSmallHeight() : mRowMaxHeight;
    if (row.getRange() != null || policy.getMode() == MODE_LARGE) {
        if (row.getRange() != null) {
            // Range element always has set height and then the height of the text
            // area on the row will vary depending on if 1 or 2 lines of text.
            int textAreaHeight = row.getLineCount() > 1 ? mRowTextWithRangeHeight : mRowSingleTextWithRangeHeight;
            return textAreaHeight + mRowRangeHeight;
        } else {
            return (row.getLineCount() > 1 || row.getIsHeader()) ? maxHeight : mRowMinHeight;
        }
    } else {
        return maxHeight;
    }
}
#end_block

#method_before
public static Bundle createMockPlayerConnectorConfig(int state, int buffState, long pos, long buffPos, float speed, @Nullable AudioAttributesCompat attr, @Nullable List<MediaItem2> playlist, @Nullable MediaItem2 currentItem, @Nullable MediaMetadata2 metadata) {
    Bundle bundle = createMockPlayerConnectorConfig(state, buffState, pos, buffPos, speed, attr);
    if (playlist != null) {
        bundle.putParcelableArrayList(KEY_PLAYLIST, MediaTestUtils.playlistToParcelableArrayList(playlist));
    }
    if (currentItem != null) {
        bundle.putBundle(KEY_MEDIA_ITEM, currentItem.toBundle());
    }
    if (metadata != null) {
        ParcelUtils.putVersionedParcelable(bundle, KEY_METADATA, metadata);
    }
    return bundle;
}
#method_after
public static Bundle createMockPlayerConnectorConfig(int state, int buffState, long pos, long buffPos, float speed, @Nullable AudioAttributesCompat attr, @Nullable List<MediaItem2> playlist, @Nullable MediaItem2 currentItem, @Nullable MediaMetadata2 metadata) {
    Bundle bundle = createMockPlayerConnectorConfig(state, buffState, pos, buffPos, speed, attr);
    if (playlist != null) {
        ParcelImplListSlice listSlice = new ParcelImplListSlice(MediaTestUtils.convertToParcelImplList(playlist));
        bundle.putParcelable(KEY_PLAYLIST, listSlice);
    }
    if (currentItem != null) {
        bundle.putParcelable(KEY_MEDIA_ITEM, MediaUtils2.toParcelable(currentItem));
    }
    if (metadata != null) {
        ParcelUtils.putVersionedParcelable(bundle, KEY_METADATA, metadata);
    }
    return bundle;
}
#end_block

#method_before
public void broadcastCustomCommand(@NonNull SessionCommand2 command, @Nullable Bundle args) {
    try {
        mBinder.broadcastCustomCommand(mSessionId, command.toBundle(), args);
    } catch (RemoteException ex) {
        Log.e(TAG, "Failed to call broadcastCustomCommand()");
    }
}
#method_after
public void broadcastCustomCommand(@NonNull SessionCommand2 command, @Nullable Bundle args) {
    try {
        mBinder.broadcastCustomCommand(mSessionId, MediaUtils2.toParcelable(command), args);
    } catch (RemoteException ex) {
        Log.e(TAG, "Failed to call broadcastCustomCommand()");
    }
}
#end_block

#method_before
public void sendCustomCommand(@NonNull ControllerInfo controller, @NonNull SessionCommand2 command, @Nullable Bundle args) {
    try {
        // TODO: ControllerInfo should be handled.
        mBinder.sendCustomCommand(mSessionId, null, command.toBundle(), args);
    } catch (RemoteException ex) {
        Log.e(TAG, "Failed to call sendCustomCommand2()");
    }
}
#method_after
public void sendCustomCommand(@NonNull ControllerInfo controller, @NonNull SessionCommand2 command, @Nullable Bundle args) {
    try {
        // TODO: ControllerInfo should be handled.
        mBinder.sendCustomCommand(mSessionId, null, MediaUtils2.toParcelable(command), args);
    } catch (RemoteException ex) {
        Log.e(TAG, "Failed to call sendCustomCommand2()");
    }
}
#end_block

#method_before
public void setAllowedCommands(@NonNull ControllerInfo controller, @NonNull SessionCommandGroup2 commands) {
    try {
        // TODO: ControllerInfo should be handled.
        mBinder.setAllowedCommands(mSessionId, null, commands.toBundle());
    } catch (RemoteException ex) {
        Log.e(TAG, "Failed to call setAllowedCommands()");
    }
}
#method_after
public void setAllowedCommands(@NonNull ControllerInfo controller, @NonNull SessionCommandGroup2 commands) {
    try {
        // TODO: ControllerInfo should be handled.
        mBinder.setAllowedCommands(mSessionId, null, MediaUtils2.toParcelable(commands));
    } catch (RemoteException ex) {
        Log.e(TAG, "Failed to call setAllowedCommands()");
    }
}
#end_block

#method_before
public void setPlaylist(List<MediaItem2> playlist) {
    try {
        mBinder.setPlaylist(mSessionId, MediaTestUtils.mediaItem2ListToBundleList(playlist));
    } catch (RemoteException ex) {
        Log.e(TAG, "Failed to call setPlaylist()");
    }
}
#method_after
public void setPlaylist(List<MediaItem2> playlist) {
    try {
        mBinder.setPlaylist(mSessionId, MediaTestUtils.convertToParcelImplList(playlist));
    } catch (RemoteException ex) {
        Log.e(TAG, "Failed to call setPlaylist()");
    }
}
#end_block

#method_before
public void setPlaylistWithDummyItem(List<MediaItem2> playlist) {
    try {
        mBinder.setPlaylistWithDummyItem(mSessionId, MediaTestUtils.mediaItem2ListToBundleList(playlist));
    } catch (RemoteException ex) {
        Log.e(TAG, "Failed to call setPlaylistWithDummyItem()");
    }
}
#method_after
public void setPlaylistWithDummyItem(List<MediaItem2> playlist) {
    try {
        mBinder.setPlaylistWithDummyItem(mSessionId, MediaTestUtils.convertToParcelImplList(playlist));
    } catch (RemoteException ex) {
        Log.e(TAG, "Failed to call setPlaylistWithDummyItem()");
    }
}
#end_block

#method_before
private SessionPlayer2 createMockPlayer(Bundle config) {
    SessionPlayer2 player;
    if (config.containsKey(KEY_VOLUME_CONTROL_TYPE)) {
        // Remote player
        player = new MockRemotePlayer(config.getInt(KEY_VOLUME_CONTROL_TYPE), config.getInt(KEY_MAX_VOLUME), config.getInt(KEY_CURRENT_VOLUME));
    } else {
        // Local player
        MockPlayer localPlayer = new MockPlayer(0);
        localPlayer.mLastPlayerState = config.getInt(KEY_PLAYER_STATE);
        localPlayer.mLastBufferingState = config.getInt(KEY_BUFFERING_STATE);
        localPlayer.mCurrentPosition = config.getLong(KEY_CURRENT_POSITION);
        localPlayer.mBufferedPosition = config.getLong(KEY_BUFFERED_POSITION);
        localPlayer.mPlaybackSpeed = config.getFloat(KEY_SPEED);
        localPlayer.mPlaylist = MediaTestUtils.playlistFromParcelableList(config.getParcelableArrayList(KEY_PLAYLIST), false);
        localPlayer.mCurrentMediaItem = MediaItem2.fromBundle(config.getBundle(KEY_MEDIA_ITEM));
        localPlayer.mMetadata = ParcelUtils.getVersionedParcelable(config, KEY_METADATA);
        player = localPlayer;
    }
    player.setAudioAttributes(AudioAttributesCompat.fromBundle(config.getBundle(KEY_AUDIO_ATTRIBUTES)));
    return player;
}
#method_after
private SessionPlayer2 createMockPlayer(Bundle config) {
    SessionPlayer2 player;
    if (config.containsKey(KEY_VOLUME_CONTROL_TYPE)) {
        // Remote player
        player = new MockRemotePlayer(config.getInt(KEY_VOLUME_CONTROL_TYPE), config.getInt(KEY_MAX_VOLUME), config.getInt(KEY_CURRENT_VOLUME));
    } else {
        // Local player
        MockPlayer localPlayer = new MockPlayer(0);
        localPlayer.mLastPlayerState = config.getInt(KEY_PLAYER_STATE);
        localPlayer.mLastBufferingState = config.getInt(KEY_BUFFERING_STATE);
        localPlayer.mCurrentPosition = config.getLong(KEY_CURRENT_POSITION);
        localPlayer.mBufferedPosition = config.getLong(KEY_BUFFERED_POSITION);
        localPlayer.mPlaybackSpeed = config.getFloat(KEY_SPEED);
        ParcelImplListSlice listSlice = config.getParcelable(KEY_PLAYLIST);
        if (listSlice != null) {
            localPlayer.mPlaylist = MediaTestUtils.convertToMediaItems(listSlice.getList(), false);
        }
        ParcelImpl currentItem = config.getParcelable(KEY_MEDIA_ITEM);
        localPlayer.mCurrentMediaItem = (currentItem == null) ? null : (MediaItem2) MediaUtils2.fromParcelable(currentItem);
        localPlayer.mMetadata = ParcelUtils.getVersionedParcelable(config, KEY_METADATA);
        player = localPlayer;
    }
    player.setAudioAttributes(AudioAttributesCompat.fromBundle(config.getBundle(KEY_AUDIO_ATTRIBUTES)));
    return player;
}
#end_block

#method_before
@Override
public void broadcastCustomCommand(String sessionId, Bundle command, Bundle args) throws RemoteException {
    MediaSession2 session2 = mSession2Map.get(sessionId);
    session2.broadcastCustomCommand(SessionCommand2.fromBundle(command), args);
}
#method_after
@Override
public void broadcastCustomCommand(String sessionId, ParcelImpl command, Bundle args) throws RemoteException {
    MediaSession2 session2 = mSession2Map.get(sessionId);
    session2.broadcastCustomCommand((SessionCommand2) MediaUtils2.fromParcelable(command), args);
}
#end_block

#method_before
@Override
public void sendCustomCommand(String sessionId, Bundle controller, Bundle command, Bundle args) throws RemoteException {
    MediaSession2 session2 = mSession2Map.get(sessionId);
    ControllerInfo info = MediaTestUtils.getTestControllerInfo(session2);
    session2.sendCustomCommand(info, SessionCommand2.fromBundle(command), args);
}
#method_after
@Override
public void sendCustomCommand(String sessionId, Bundle controller, ParcelImpl command, Bundle args) throws RemoteException {
    MediaSession2 session2 = mSession2Map.get(sessionId);
    ControllerInfo info = MediaTestUtils.getTestControllerInfo(session2);
    session2.sendCustomCommand(info, (SessionCommand2) MediaUtils2.fromParcelable(command), args);
}
#end_block

#method_before
@Override
public void setAllowedCommands(String sessionId, Bundle controller, Bundle commands) throws RemoteException {
    MediaSession2 session2 = mSession2Map.get(sessionId);
    ControllerInfo info = MediaTestUtils.getTestControllerInfo(session2);
    session2.setAllowedCommands(info, SessionCommandGroup2.fromBundle(commands));
}
#method_after
@Override
public void setAllowedCommands(String sessionId, Bundle controller, ParcelImpl commands) throws RemoteException {
    MediaSession2 session2 = mSession2Map.get(sessionId);
    ControllerInfo info = MediaTestUtils.getTestControllerInfo(session2);
    session2.setAllowedCommands(info, (SessionCommandGroup2) MediaUtils2.fromParcelable(commands));
}
#end_block

#method_before
// //////////////////////////////////////////////////////////////////////////////
// MockPlaylistAgent methods
// //////////////////////////////////////////////////////////////////////////////
@Override
public void setPlaylist(String sessionId, List<Bundle> playlist) throws RemoteException {
    MediaSession2 session2 = mSession2Map.get(sessionId);
    MockPlayer player = (MockPlayer) session2.getPlayer();
    List<MediaItem2> list = new ArrayList<>();
    for (Bundle bundle : playlist) {
        list.add(MediaItem2.fromBundle(bundle));
    }
    player.mPlaylist = list;
}
#method_after
// //////////////////////////////////////////////////////////////////////////////
// MockPlaylistAgent methods
// //////////////////////////////////////////////////////////////////////////////
@Override
public void setPlaylist(String sessionId, List<ParcelImpl> playlist) throws RemoteException {
    MediaSession2 session2 = mSession2Map.get(sessionId);
    MockPlayer player = (MockPlayer) session2.getPlayer();
    player.mPlaylist = MediaTestUtils.convertToMediaItems(playlist, false);
}
#end_block

#method_before
@Override
public void setPlaylistWithDummyItem(String sessionId, List<Bundle> playlist) throws RemoteException {
    MediaSession2 session2 = mSession2Map.get(sessionId);
    MockPlayer player = (MockPlayer) session2.getPlayer();
    List<MediaItem2> list = new ArrayList<>();
    for (Bundle bundle : playlist) {
        MediaItem2 item = MediaItem2.fromBundle(bundle);
        list.add(new FileMediaItem2.Builder(new FileDescriptor()).setMetadata(item.getMetadata()).build());
    }
    player.mPlaylist = list;
}
#method_after
@Override
public void setPlaylistWithDummyItem(String sessionId, List<ParcelImpl> playlist) throws RemoteException {
    MediaSession2 session2 = mSession2Map.get(sessionId);
    MockPlayer player = (MockPlayer) session2.getPlayer();
    List<MediaItem2> list = new ArrayList<>();
    for (ParcelImpl parcel : playlist) {
        MediaItem2 item = MediaUtils2.fromParcelable(parcel);
        list.add(new FileMediaItem2.Builder(new FileDescriptor()).setMetadata(item.getMetadata()).build());
    }
    player.mPlaylist = list;
}
#end_block

#method_before
@Override
public void setMediaControlView2(MediaControlView2 mediaControlView, long intervalMs) {
    mMediaControlView = mediaControlView;
    mMediaControlView.setShowControllerInterval(intervalMs);
    if (mInstance.isAttachedToWindow()) {
        attachMediaControlView();
    }
}
#method_after
@Override
public void setMediaControlView2(@NonNull MediaControlView2 mediaControlView, long intervalMs) {
    mMediaControlView = mediaControlView;
    mMediaControlView.setShowControllerInterval(intervalMs);
    if (mInstance.isAttachedToWindow()) {
        attachMediaControlView();
    }
}
#end_block

#method_before
@Override
public SessionToken2 getMediaSessionToken2() {
    if (mMediaSession == null) {
        throw new IllegalStateException("MediaSession2 instance is not available.");
    }
    return mMediaSession.getToken();
}
#method_after
@Override
@NonNull
public SessionToken2 getMediaSessionToken2() {
    if (mMediaSession == null) {
        throw new IllegalStateException("MediaSession2 instance is not available.");
    }
    return mMediaSession.getToken();
}
#end_block

#method_before
public void setMediaSessionToken2(SessionToken2 token) {
    mController.setMediaSessionToken2(token);
    if (mController.hasMetadata()) {
        updateMetadata();
    }
}
#method_after
public void setMediaSessionToken2(@NonNull SessionToken2 token) {
    mController.setMediaSessionToken2(token);
    if (mController.hasMetadata()) {
        updateMetadata();
    }
}
#end_block

#method_before
public void setOnFullScreenListener(OnFullScreenListener l) {
    mOnFullScreenListener = l;
    mFullScreenButton.setVisibility(View.VISIBLE);
}
#method_after
public void setOnFullScreenListener(@NonNull OnFullScreenListener l) {
    mOnFullScreenListener = l;
    mFullScreenButton.setVisibility(View.VISIBLE);
}
#end_block

#method_before
void updateMetadata() {
    if (!mController.hasMetadata()) {
        return;
    }
    long duration = mController.getDurationMs();
    if (duration != 0) {
        mDuration = duration;
        mTimeView.setVisibility(View.VISIBLE);
        setProgress();
    }
    if (mMediaType != MEDIA_TYPE_MUSIC) {
        String title = mController.getTitle();
        if (title != null) {
            mTitleView.setText(title);
        }
    } else {
        String title = mController.getTitle();
        if (title == null) {
            title = mResources.getString(R.string.mcv2_music_title_unknown_text);
        }
        String artist = mController.getArtistText();
        if (artist == null) {
            artist = mResources.getString(R.string.mcv2_music_artist_unknown_text);
        }
        // Update title for Embedded size type
        mTitleView.setText(title + " - " + artist);
        // Remove unnecessary buttons
        mVideoQualityButton.setVisibility(View.GONE);
        if (mFfwdButton != null) {
            mFfwdButton.setVisibility(View.GONE);
        }
        if (mRewButton != null) {
            mRewButton.setVisibility(View.GONE);
        }
        Point screenSize = new Point();
        mWindowManager.getDefaultDisplay().getSize(screenSize);
        updateLayout(BOTTOM_BAR_RIGHT_VIEW_MAX_ICON_NUM_MUSIC, getMeasuredWidth(), getMeasuredHeight(), screenSize.x, screenSize.y);
    }
}
#method_after
void updateMetadata() {
    if (!mController.hasMetadata()) {
        return;
    }
    long duration = mController.getDurationMs();
    if (duration != 0) {
        mDuration = duration;
        mTimeView.setVisibility(View.VISIBLE);
        setProgress();
    }
    if (mMediaType != MEDIA_TYPE_MUSIC) {
        CharSequence title = mController.getTitle();
        if (title != null) {
            mTitleView.setText(title.toString());
        }
    } else {
        CharSequence title = mController.getTitle();
        if (title == null) {
            title = mResources.getString(R.string.mcv2_music_title_unknown_text);
        }
        CharSequence artist = mController.getArtistText();
        if (artist == null) {
            artist = mResources.getString(R.string.mcv2_music_artist_unknown_text);
        }
        // Update title for Embedded size type
        mTitleView.setText(title.toString() + " - " + artist.toString());
        // Remove unnecessary buttons
        mVideoQualityButton.setVisibility(View.GONE);
        if (mFfwdButton != null) {
            mFfwdButton.setVisibility(View.GONE);
        }
        if (mRewButton != null) {
            mRewButton.setVisibility(View.GONE);
        }
        Point screenSize = new Point();
        mWindowManager.getDefaultDisplay().getSize(screenSize);
        updateLayout(BOTTOM_BAR_RIGHT_VIEW_MAX_ICON_NUM_MUSIC, getMeasuredWidth(), getMeasuredHeight(), screenSize.x, screenSize.y);
    }
}
#end_block

#method_before
String getTitle() {
    if (mMediaMetadata2 != null) {
        if (mMediaMetadata2.containsKey(MediaMetadata2.METADATA_KEY_TITLE)) {
            return mMediaMetadata2.getString(MediaMetadata2.METADATA_KEY_TITLE);
        }
    }
    return null;
}
#method_after
CharSequence getTitle() {
    if (mMediaMetadata2 != null) {
        if (mMediaMetadata2.containsKey(MediaMetadata2.METADATA_KEY_TITLE)) {
            return mMediaMetadata2.getText(MediaMetadata2.METADATA_KEY_TITLE);
        }
    }
    return null;
}
#end_block

#method_before
String getArtistText() {
    if (mMediaMetadata2 != null) {
        if (mMediaMetadata2.containsKey(MediaMetadata2.METADATA_KEY_ARTIST)) {
            return mMediaMetadata2.getString(MediaMetadata2.METADATA_KEY_ARTIST);
        }
    }
    return null;
}
#method_after
CharSequence getArtistText() {
    if (mMediaMetadata2 != null) {
        if (mMediaMetadata2.containsKey(MediaMetadata2.METADATA_KEY_ARTIST)) {
            return mMediaMetadata2.getText(MediaMetadata2.METADATA_KEY_ARTIST);
        }
    }
    return null;
}
#end_block

#method_before
@Nullable
public Rating2 getRating(@NonNull @RatingKey String key) {
    if (key == null) {
        throw new IllegalArgumentException("key shouldn't be null");
    }
    Rating2 rating = null;
    try {
        rating = ParcelUtils.fromParcelable(mBundle.getParcelable(key));
    } catch (Exception e) {
        // ignore, value was not a rating
        Log.w(TAG, "Failed to retrieve a key as Rating.", e);
    }
    return rating;
}
#method_after
@Nullable
public Rating2 getRating(@NonNull @RatingKey String key) {
    if (key == null) {
        throw new IllegalArgumentException("key shouldn't be null");
    }
    Rating2 rating = null;
    try {
        rating = ParcelUtils.getVersionedParcelable(mBundle, key);
    } catch (Exception e) {
        // ignore, value was not a rating
        Log.w(TAG, "Failed to retrieve a key as Rating.", e);
    }
    return rating;
}
#end_block

#method_before
@Override
@RestrictTo(LIBRARY_GROUP)
public void onPreParceling(boolean isStream) {
    List<ParcelImpl> parcelImplList = new ArrayList<>();
    List<String> keysForBitmap = new ArrayList<>();
    for (String key : mBundle.keySet()) {
        Object value = mBundle.get(key);
        if (!(value instanceof Bitmap)) {
            // Note: Null bitmap is sent through mBundle.
            continue;
        }
        Bitmap bitmap = (Bitmap) value;
        parcelImplList.add((ParcelImpl) ParcelUtils.toParcelable(new BitmapEntry(key, bitmap)));
        keysForBitmap.add(key);
    }
    for (String key : keysForBitmap) {
        mBundle.remove(key);
    }
    mBitmapListSlice = new ParcelImplListSlice(parcelImplList);
}
#method_after
@Override
@RestrictTo(LIBRARY_GROUP)
public void onPreParceling(boolean isStream) {
    List<ParcelImpl> parcelImplList = new ArrayList<>();
    List<String> keysForBitmap = new ArrayList<>();
    for (String key : mBundle.keySet()) {
        Object value = mBundle.get(key);
        if (!(value instanceof Bitmap)) {
            // Note: Null bitmap is sent through mBundle.
            continue;
        }
        Bitmap bitmap = (Bitmap) value;
        parcelImplList.add(MediaUtils2.toParcelable(new BitmapEntry(key, bitmap)));
        keysForBitmap.add(key);
    }
    for (String key : keysForBitmap) {
        mBundle.remove(key);
    }
    mBitmapListSlice = new ParcelImplListSlice(parcelImplList);
}
#end_block

#method_before
@Override
@RestrictTo(LIBRARY_GROUP)
public void onPostParceling() {
    List<ParcelImpl> parcelImplList = mBitmapListSlice.getList();
    for (ParcelImpl parcelImpl : parcelImplList) {
        BitmapEntry entry = ParcelUtils.fromParcelable(parcelImpl);
        mBundle.putParcelable(entry.getKey(), entry.getBitmap());
    }
    parcelImplList.clear();
    mBitmapListSlice = null;
}
#method_after
@Override
@RestrictTo(LIBRARY_GROUP)
public void onPostParceling() {
    List<ParcelImpl> parcelImplList = mBitmapListSlice.getList();
    for (ParcelImpl parcelImpl : parcelImplList) {
        BitmapEntry entry = MediaUtils2.fromParcelable(parcelImpl);
        mBundle.putParcelable(entry.getKey(), entry.getBitmap());
    }
    parcelImplList.clear();
    mBitmapListSlice = null;
}
#end_block

#method_before
@NonNull
public Builder putRating(@NonNull @RatingKey String key, @Nullable Rating2 value) {
    if (key == null) {
        throw new IllegalArgumentException("key shouldn't be null");
    }
    if (METADATA_KEYS_TYPE.containsKey(key)) {
        if (METADATA_KEYS_TYPE.get(key) != METADATA_TYPE_RATING) {
            throw new IllegalArgumentException("The " + key + " key cannot be used to put a Rating");
        }
    }
    mBundle.putParcelable(key, ParcelUtils.toParcelable(value));
    return this;
}
#method_after
@NonNull
public Builder putRating(@NonNull @RatingKey String key, @Nullable Rating2 value) {
    if (key == null) {
        throw new IllegalArgumentException("key shouldn't be null");
    }
    if (METADATA_KEYS_TYPE.containsKey(key)) {
        if (METADATA_KEYS_TYPE.get(key) != METADATA_TYPE_RATING) {
            throw new IllegalArgumentException("The " + key + " key cannot be used to put a Rating");
        }
    }
    ParcelUtils.putVersionedParcelable(mBundle, key, value);
    return this;
}
#end_block

#method_before
@Before
public void setup() {
    mUser0 = 0;
    mUser1 = 1;
    String isa = VMRuntime.getInstructionSet(Build.SUPPORTED_ABIS[0]);
    String foo = "foo";
    String bar = "bar";
    mFooUser0 = new TestData(foo, isa, mUser0, PATH_CLASS_LOADER_NAME);
    mBarUser0 = new TestData(bar, isa, mUser0, PATH_CLASS_LOADER_NAME);
    mBarUser1 = new TestData(bar, isa, mUser1, PATH_CLASS_LOADER_NAME);
    mInvalidIsa = new TestData("INVALID", "INVALID_ISA", mUser0);
    mDoesNotExist = new TestData("DOES.NOT.EXIST", isa, mUser1);
    mBarUser0UnsupportedClassLoader = new TestData(bar, isa, mUser0, "unsupported.class_loader");
    mBarUser0DelegateLastClassLoader = new TestData(bar, isa, mUser0, DELEGATE_LAST_CLASS_LOADER_NAME);
    mDexManager = new DexManager(/*Context*/
    null, mPM, /*PackageDexOptimizer*/
    null, mInstaller, mInstallLock, mListener);
    // Foo and Bar are available to user0.
    // Only Bar is available to user1;
    Map<Integer, List<PackageInfo>> existingPackages = new HashMap<>();
    existingPackages.put(mUser0, Arrays.asList(mFooUser0.mPackageInfo, mBarUser0.mPackageInfo));
    existingPackages.put(mUser1, Arrays.asList(mBarUser1.mPackageInfo));
    mDexManager.load(existingPackages);
}
#method_after
@Before
public void setup() {
    mUser0 = 0;
    mUser1 = 1;
    String isa = VMRuntime.getInstructionSet(Build.SUPPORTED_ABIS[0]);
    String foo = "foo";
    String bar = "bar";
    mFooUser0 = new TestData(foo, isa, mUser0, PATH_CLASS_LOADER_NAME);
    mBarUser0 = new TestData(bar, isa, mUser0, PATH_CLASS_LOADER_NAME);
    mBarUser1 = new TestData(bar, isa, mUser1, PATH_CLASS_LOADER_NAME);
    mInvalidIsa = new TestData("INVALID", "INVALID_ISA", mUser0);
    mDoesNotExist = new TestData("DOES.NOT.EXIST", isa, mUser1);
    mBarUser0UnsupportedClassLoader = new TestData(bar, isa, mUser0, UNSUPPORTED_CLASS_LOADER_NAME);
    mBarUser0DelegateLastClassLoader = new TestData(bar, isa, mUser0, DELEGATE_LAST_CLASS_LOADER_NAME);
    mDexManager = new DexManager(/*Context*/
    null, mPM, /*PackageDexOptimizer*/
    null, mInstaller, mInstallLock, mListener);
    // Foo and Bar are available to user0.
    // Only Bar is available to user1;
    Map<Integer, List<PackageInfo>> existingPackages = new HashMap<>();
    existingPackages.put(mUser0, Arrays.asList(mFooUser0.mPackageInfo, mBarUser0.mPackageInfo));
    existingPackages.put(mUser1, Arrays.asList(mBarUser1.mPackageInfo));
    mDexManager.load(existingPackages);
}
#end_block

#method_before
@Test
public void testNotifySupportedAndUnsupportedClassLoader() {
}
#method_after
@Test
public void testNotifySupportedAndUnsupportedClassLoader() {
    String classPath = String.join(File.pathSeparator, mBarUser0.getSecondaryDexPaths());
    List<String> classLoaders = Arrays.asList(PATH_CLASS_LOADER_NAME, UNSUPPORTED_CLASS_LOADER_NAME);
    List<String> classPaths = Arrays.asList(classPath, classPath);
    notifyDexLoad(mBarUser0, classLoaders, classPaths, mUser0);
    assertNoUseInfo(mBarUser0);
}
#end_block

#method_before
private void notifyDexLoad(TestData testData, List<String> classLoader, List<String> classPaths, int loaderUserId) {
    // We call the internal function so any exceptions thrown cause test failures.
    mDexManager.notifyDexLoadInternal(testData.mPackageInfo.applicationInfo, classLoader, classPaths, testData.mLoaderIsa, loaderUserId);
}
#method_after
private void notifyDexLoad(TestData testData, List<String> classLoaders, List<String> classPaths, int loaderUserId) {
    // We call the internal function so any exceptions thrown cause test failures.
    mDexManager.notifyDexLoadInternal(testData.mPackageInfo.applicationInfo, classLoaders, classPaths, testData.mLoaderIsa, loaderUserId);
}
#end_block

#method_before
private void reportClassLoaderChain() {
    ArrayList<ClassLoader> classLoadersChain = new ArrayList<>();
    ArrayList<String> classPaths = new ArrayList<>();
    classLoadersChain.add(this);
    classPaths.add(String.join(File.pathSeparator, pathList.getDexPaths()));
    ClassLoader bootClassLoader = ClassLoader.getSystemClassLoader().getParent();
    ClassLoader current = getParent();
    while (current != null && current != bootClassLoader) {
        classLoadersChain.add(current);
        if (current instanceof BaseDexClassLoader) {
            BaseDexClassLoader bdcCurrent = (BaseDexClassLoader) current;
            classPaths.add(String.join(File.pathSeparator, bdcCurrent.pathList.getDexPaths()));
        } else {
            // We can't determine the classpath for arbitrary class loaders.
            classPaths.add("");
        }
        current = current.getParent();
    }
    reporter.report(classLoadersChain, classPaths);
}
#method_after
private void reportClassLoaderChain() {
    ArrayList<ClassLoader> classLoadersChain = new ArrayList<>();
    ArrayList<String> classPaths = new ArrayList<>();
    classLoadersChain.add(this);
    classPaths.add(String.join(File.pathSeparator, pathList.getDexPaths()));
    ClassLoader bootClassLoader = ClassLoader.getSystemClassLoader().getParent();
    ClassLoader current = getParent();
    while (current != null && current != bootClassLoader) {
        classLoadersChain.add(current);
        if (current instanceof BaseDexClassLoader) {
            BaseDexClassLoader bdcCurrent = (BaseDexClassLoader) current;
            classPaths.add(String.join(File.pathSeparator, bdcCurrent.pathList.getDexPaths()));
        } else {
            // We can't determine the classpath for arbitrary class loaders.
            classPaths.add(null);
        }
        current = current.getParent();
    }
    reporter.report(classLoadersChain, classPaths);
}
#end_block

#method_before
@BeforeClass
public static void extractTestJar() throws Exception {
    // Extract loading-test.jar from the resource.
    pcl = BaseDexClassLoaderTest.class.getClassLoader();
    jar = File.createTempFile("loading-test", ".jar");
    try (InputStream in = pcl.getResourceAsStream("dalvik/system/loading-test.jar");
        FileOutputStream out = new FileOutputStream(jar)) {
        Streams.copy(in, out);
    }
}
#method_after
@Before
public void extractTestJar() throws Exception {
    // Extract loading-test.jar from the resource.
    pcl = BaseDexClassLoaderTest.class.getClassLoader();
    jar = File.createTempFile("loading-test", ".jar");
    try (InputStream in = pcl.getResourceAsStream("dalvik/system/loading-test.jar");
        FileOutputStream out = new FileOutputStream(jar)) {
        Streams.copy(in, out);
    }
}
#end_block

#method_before
@AfterClass
public static void deleteTestJar() throws Exception {
    assertTrue(jar.delete());
}
#method_after
@After
public void deleteTestJar() throws Exception {
    assertTrue(jar.delete());
}
#end_block

#method_before
@Test
public void testNoReportingAfterResetting() throws Exception {
    BaseDexClassLoader cl1 = new PathClassLoader(jar.getPath(), ClassLoader.getSystemClassLoader());
    assertEquals(2, reporter.loadedDexPaths.size());
    assertEquals(2, reporter.classLoaders.size());
    // Reset the reporter and check we don't report anymore.
    reporter.reset();
    BaseDexClassLoader.setReporter(null);
    // Load the jar file using another PathClassLoader.
    BaseDexClassLoader cl2 = new PathClassLoader(jar.getPath(), pcl);
    // Verify nothing reported
    assertEquals(0, reporter.loadedDexPaths.size());
    assertEquals(0, reporter.classLoaders.size());
}
#method_after
@Test
public void testNoReportingAfterResetting() throws Exception {
    BaseDexClassLoader cl1 = new PathClassLoader(jar.getPath(), ClassLoader.getSystemClassLoader());
    assertEquals(2, reporter.loadedDexPaths.size());
    assertEquals(2, reporter.classLoaders.size());
    // Check we don't report after the reporter is unregistered.
    unregisterReporter();
    reporter.reset();
    // Load the jar file using another PathClassLoader.
    BaseDexClassLoader cl2 = new PathClassLoader(jar.getPath(), pcl);
    // Verify nothing reported
    assertEquals(0, reporter.loadedDexPaths.size());
    assertEquals(0, reporter.classLoaders.size());
}
#end_block

#method_before
@Test
public void testControllerCallback_sessionUpdatePlayer() throws InterruptedException {
    prepareLooper();
    final int testState = SessionPlayer2.PLAYER_STATE_PLAYING;
    final List<MediaItem2> testPlaylist = MediaTestUtils.createFileMediaItems(3);
    final AudioAttributesCompat testAudioAttributes = new AudioAttributesCompat.Builder().setLegacyStreamType(AudioManager.STREAM_RING).build();
    final CountDownLatch latch = new CountDownLatch(3);
    mController = createController(mRemoteSession2.getToken(), true, /* waitForConnect */
    new MediaController2.ControllerCallback() {

        @Override
        public void onPlayerStateChanged(MediaController2 controller, int state) {
            assertEquals(mController, controller);
            assertEquals(testState, state);
            latch.countDown();
        }

        @Override
        public void onPlaylistChanged(MediaController2 controller, List<MediaItem2> list, MediaMetadata2 metadata) {
            assertEquals(mController, controller);
            MediaTestUtils.assertMediaItems(list);
            MediaTestUtils.assertMediaItemListsWithId(testPlaylist, list);
            assertNull(metadata);
            latch.countDown();
        }

        @Override
        public void onPlaybackInfoChanged(MediaController2 controller, MediaController2.PlaybackInfo info) {
            assertEquals(mController, controller);
            assertEquals(testAudioAttributes, info.getAudioAttributes());
            latch.countDown();
        }
    });
    Bundle config = RemoteMediaSession2.createMockPlayerConnectorConfig(testState, 0, /* buffState */
    0, /* position */
    0, /* buffPosition */
    0f, /* speed */
    testAudioAttributes, testPlaylist, null, /* currentItem */
    null);
    mRemoteSession2.updatePlayer(config);
    assertTrue(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
}
#method_after
@Test
public void testControllerCallback_sessionUpdatePlayer() throws InterruptedException {
    prepareLooper();
    final int testState = SessionPlayer2.PLAYER_STATE_PLAYING;
    final List<MediaItem2> testPlaylist = MediaTestUtils.createFileMediaItems(3);
    final AudioAttributesCompat testAudioAttributes = new AudioAttributesCompat.Builder().setLegacyStreamType(AudioManager.STREAM_RING).build();
    final CountDownLatch latch = new CountDownLatch(3);
    mController = createController(mRemoteSession2.getToken(), true, /* waitForConnect */
    new MediaController2.ControllerCallback() {

        @Override
        public void onPlayerStateChanged(MediaController2 controller, int state) {
            assertEquals(mController, controller);
            assertEquals(testState, state);
            latch.countDown();
        }

        @Override
        public void onPlaylistChanged(MediaController2 controller, List<MediaItem2> list, MediaMetadata2 metadata) {
            assertEquals(mController, controller);
            assertNotMediaItemSubclass(list);
            assertEqualMediaIds(testPlaylist, list);
            assertNull(metadata);
            latch.countDown();
        }

        @Override
        public void onPlaybackInfoChanged(MediaController2 controller, MediaController2.PlaybackInfo info) {
            assertEquals(mController, controller);
            assertEquals(testAudioAttributes, info.getAudioAttributes());
            latch.countDown();
        }
    });
    Bundle config = RemoteMediaSession2.createMockPlayerConnectorConfig(testState, 0, /* buffState */
    0, /* position */
    0, /* buffPosition */
    0f, /* speed */
    testAudioAttributes, testPlaylist, null, /* currentItem */
    null);
    mRemoteSession2.updatePlayer(config);
    assertTrue(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
}
#end_block

#method_before
@Test
public void testOnCurrentMediaItemChanged() throws Exception {
    prepareLooper();
    final int listSize = 5;
    final List<MediaItem2> list = MediaTestUtils.createFileMediaItems(listSize);
    mRemoteSession2.getMockPlayer().setPlaylistWithDummyItem(list);
    final int currentItemIndex = 3;
    final MediaItem2 currentItem = list.get(currentItemIndex);
    final CountDownLatch latchForControllerCallback = new CountDownLatch(3);
    MediaController2 controller = createController(mRemoteSession2.getToken(), true, new MediaController2.ControllerCallback() {

        @Override
        public void onCurrentMediaItemChanged(MediaController2 controller, MediaItem2 item) {
            switch((int) latchForControllerCallback.getCount()) {
                case 3:
                    // No check needed..
                    break;
                case 2:
                    assertFalse(item instanceof FileMediaItem2);
                    assertEquals(currentItem.getMediaId(), item.getMediaId());
                    break;
                case 1:
                    assertNull(item);
            }
            latchForControllerCallback.countDown();
        }
    });
    // Player notifies with the unknown item. Still OK.
    mRemoteSession2.getMockPlayer().notifyCurrentMediaItemChanged(INDEX_FOR_UNKONWN_ITEM);
    // Known ITEM should be notified through the onCurrentMediaItemChanged.
    mRemoteSession2.getMockPlayer().notifyCurrentMediaItemChanged(currentItemIndex);
    // Null ITEM becomes null MediaItem2.
    mRemoteSession2.getMockPlayer().notifyCurrentMediaItemChanged(INDEX_FOR_NULL_ITEM);
    assertTrue(latchForControllerCallback.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
}
#method_after
@Test
public void testOnCurrentMediaItemChanged() throws Exception {
    prepareLooper();
    final int listSize = 5;
    final List<MediaItem2> list = MediaTestUtils.createFileMediaItems(listSize);
    mRemoteSession2.getMockPlayer().setPlaylistWithDummyItem(list);
    final int currentItemIndex = 3;
    final MediaItem2 currentItem = list.get(currentItemIndex);
    final CountDownLatch latchForControllerCallback = new CountDownLatch(3);
    MediaController2 controller = createController(mRemoteSession2.getToken(), true, new MediaController2.ControllerCallback() {

        @Override
        public void onCurrentMediaItemChanged(MediaController2 controller, MediaItem2 item) {
            switch((int) latchForControllerCallback.getCount()) {
                case 3:
                    // No check needed..
                    break;
                case 2:
                    assertNotMediaItemSubclass(item);
                    assertEquals(currentItem.getMediaId(), item.getMediaId());
                    break;
                case 1:
                    assertNull(item);
            }
            latchForControllerCallback.countDown();
        }
    });
    // Player notifies with the unknown item. Still OK.
    mRemoteSession2.getMockPlayer().notifyCurrentMediaItemChanged(INDEX_FOR_UNKONWN_ITEM);
    // Known ITEM should be notified through the onCurrentMediaItemChanged.
    mRemoteSession2.getMockPlayer().notifyCurrentMediaItemChanged(currentItemIndex);
    // Null ITEM becomes null MediaItem2.
    mRemoteSession2.getMockPlayer().notifyCurrentMediaItemChanged(INDEX_FOR_NULL_ITEM);
    assertTrue(latchForControllerCallback.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
}
#end_block

#method_before
@Test
public void testOnPlaylistChanged() throws InterruptedException {
    prepareLooper();
    final List<MediaItem2> testList = MediaTestUtils.createFileMediaItems(2);
    final AtomicReference<List<MediaItem2>> listFromCallback = new AtomicReference<>();
    final CountDownLatch latch = new CountDownLatch(1);
    final MediaController2.ControllerCallback callback = new MediaController2.ControllerCallback() {

        @Override
        public void onPlaylistChanged(MediaController2 controller, List<MediaItem2> playlist, MediaMetadata2 metadata) {
            assertNotNull(playlist);
            MediaTestUtils.assertMediaItems(playlist);
            MediaTestUtils.assertMediaItemListsWithId(testList, playlist);
            listFromCallback.set(playlist);
            latch.countDown();
        }
    };
    MediaController2 controller = createController(mRemoteSession2.getToken(), true, callback);
    mRemoteSession2.getMockPlayer().setPlaylist(testList);
    mRemoteSession2.getMockPlayer().notifyPlaylistChanged();
    assertTrue(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
    assertEquals(listFromCallback.get(), controller.getPlaylist());
}
#method_after
@Test
public void testOnPlaylistChanged() throws InterruptedException {
    prepareLooper();
    final List<MediaItem2> testList = MediaTestUtils.createFileMediaItems(2);
    final AtomicReference<List<MediaItem2>> listFromCallback = new AtomicReference<>();
    final CountDownLatch latch = new CountDownLatch(1);
    final MediaController2.ControllerCallback callback = new MediaController2.ControllerCallback() {

        @Override
        public void onPlaylistChanged(MediaController2 controller, List<MediaItem2> playlist, MediaMetadata2 metadata) {
            assertNotNull(playlist);
            assertNotMediaItemSubclass(playlist);
            assertEqualMediaIds(testList, playlist);
            listFromCallback.set(playlist);
            latch.countDown();
        }
    };
    MediaController2 controller = createController(mRemoteSession2.getToken(), true, callback);
    mRemoteSession2.getMockPlayer().setPlaylist(testList);
    mRemoteSession2.getMockPlayer().notifyPlaylistChanged();
    assertTrue(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
    assertEquals(listFromCallback.get(), controller.getPlaylist());
}
#end_block

#method_before
@Test
public void testOnBufferingStateChanged() throws InterruptedException {
    prepareLooper();
    final CountDownLatch latch = new CountDownLatch(1);
    final List<MediaItem2> testPlaylist = MediaTestUtils.createFileMediaItems(3);
    final int targetItemIndex = 0;
    final int testBufferingState = SessionPlayer2.BUFFERING_STATE_BUFFERING_AND_PLAYABLE;
    final long testBufferingPosition = 500;
    final MediaController2.ControllerCallback callback = new MediaController2.ControllerCallback() {

        @Override
        public void onBufferingStateChanged(MediaController2 controller, MediaItem2 item, int state) {
            controller.setTimeDiff(0L);
            assertFalse(item instanceof FileMediaItem2);
            assertEquals(testPlaylist.get(targetItemIndex).getMediaId(), item.getMediaId());
            assertEquals(testBufferingState, state);
            assertEquals(testBufferingState, controller.getBufferingState());
            assertEquals(testBufferingPosition, controller.getBufferedPosition());
            latch.countDown();
        }
    };
    mRemoteSession2.getMockPlayer().setPlaylistWithDummyItem(testPlaylist);
    RemoteMediaSession2.RemoteMockPlayer player = mRemoteSession2.getMockPlayer();
    player.setBufferedPosition(testBufferingPosition);
    MediaController2 controller = createController(mRemoteSession2.getToken(), true, callback);
    // Since we cannot pass the DataSourceDesc directly, send the item index so that the player
    // can select which item's state change should be notified.
    player.notifyBufferingStateChanged(targetItemIndex, testBufferingState);
    assertTrue(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
}
#method_after
@Test
public void testOnBufferingStateChanged() throws InterruptedException {
    prepareLooper();
    final CountDownLatch latch = new CountDownLatch(1);
    final List<MediaItem2> testPlaylist = MediaTestUtils.createFileMediaItems(3);
    final int targetItemIndex = 0;
    final int testBufferingState = SessionPlayer2.BUFFERING_STATE_BUFFERING_AND_PLAYABLE;
    final long testBufferingPosition = 500;
    final MediaController2.ControllerCallback callback = new MediaController2.ControllerCallback() {

        @Override
        public void onBufferingStateChanged(MediaController2 controller, MediaItem2 item, int state) {
            controller.setTimeDiff(0L);
            assertNotMediaItemSubclass(item);
            assertEquals(testPlaylist.get(targetItemIndex).getMediaId(), item.getMediaId());
            assertEquals(testBufferingState, state);
            assertEquals(testBufferingState, controller.getBufferingState());
            assertEquals(testBufferingPosition, controller.getBufferedPosition());
            latch.countDown();
        }
    };
    mRemoteSession2.getMockPlayer().setPlaylistWithDummyItem(testPlaylist);
    RemoteMediaSession2.RemoteMockPlayer player = mRemoteSession2.getMockPlayer();
    player.setBufferedPosition(testBufferingPosition);
    MediaController2 controller = createController(mRemoteSession2.getToken(), true, callback);
    // Since we cannot pass the DataSourceDesc directly, send the item index so that the player
    // can select which item's state change should be notified.
    player.notifyBufferingStateChanged(targetItemIndex, testBufferingState);
    assertTrue(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
}
#end_block

#method_before
@Test
public void testOnCustomCommand() throws InterruptedException {
    prepareLooper();
    final SessionCommand2 testCommand = new SessionCommand2(SessionCommand2.COMMAND_CODE_PLAYER_PREFETCH);
    final Bundle testArgs = TestUtils.createTestBundle();
    final CountDownLatch latch = new CountDownLatch(2);
    final MediaController2.ControllerCallback callback = new MediaController2.ControllerCallback() {

        @Override
        public MediaController2.ControllerResult onCustomCommand(MediaController2 controller, SessionCommand2 command, Bundle args) {
            assertEquals(testCommand, command);
            assertTrue(TestUtils.equals(testArgs, args));
            latch.countDown();
            return new MediaController2.ControllerResult(RESULT_CODE_SUCCESS, null);
        }
    };
    MediaController2 controller = createController(mRemoteSession2.getToken(), true, callback);
    // TODO(jaewan): Test with multiple controllers
    mRemoteSession2.broadcastCustomCommand(testCommand, testArgs);
    // TODO(jaewan): Test receivers as well.
    mRemoteSession2.sendCustomCommand(TEST_CONTROLLER_INFO, testCommand, testArgs);
    assertTrue(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
}
#method_after
@Test
public void testOnCustomCommand() throws InterruptedException {
    prepareLooper();
    final SessionCommand2 testCommand = new SessionCommand2(SessionCommand2.COMMAND_CODE_PLAYER_PREPARE);
    final Bundle testArgs = TestUtils.createTestBundle();
    final CountDownLatch latch = new CountDownLatch(2);
    final MediaController2.ControllerCallback callback = new MediaController2.ControllerCallback() {

        @Override
        public MediaController2.ControllerResult onCustomCommand(MediaController2 controller, SessionCommand2 command, Bundle args) {
            assertEquals(testCommand, command);
            assertTrue(TestUtils.equals(testArgs, args));
            latch.countDown();
            return new MediaController2.ControllerResult(RESULT_CODE_SUCCESS, null);
        }
    };
    MediaController2 controller = createController(mRemoteSession2.getToken(), true, callback);
    // TODO(jaewan): Test with multiple controllers
    mRemoteSession2.broadcastCustomCommand(testCommand, testArgs);
    // TODO(jaewan): Test receivers as well.
    mRemoteSession2.sendCustomCommand(TEST_CONTROLLER_INFO, testCommand, testArgs);
    assertTrue(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
}
#end_block

#method_before
@Override
public void playFromMediaId(final IMediaController2 caller, int seq, final String mediaId, final Bundle extras) {
    if (caller == null) {
        return;
    }
    dispatchSessionTask(caller, seq, SessionCommand2.COMMAND_CODE_SESSION_PLAY_FROM_MEDIA_ID, new SessionCallbackTask<Integer>() {

        @Override
        public Integer run(ControllerInfo controller) {
            if (mediaId == null) {
                Log.w(TAG, "playFromMediaId(): Ignoring null mediaId from " + controller);
                return RESULT_CODE_BAD_VALUE;
            }
            return mSessionImpl.getCallback().onPlayFromMediaId(mSessionImpl.getInstance(), controller, mediaId, extras);
        }
    });
}
#method_after
@Override
public void playFromMediaId(final IMediaController2 caller, int seq, final String mediaId, final Bundle extras) {
    if (caller == null) {
        return;
    }
    dispatchSessionTask(caller, seq, SessionCommand2.COMMAND_CODE_SESSION_PLAY_FROM_MEDIA_ID, new SessionCallbackTask<Integer>() {

        @Override
        public Integer run(ControllerInfo controller) {
            if (TextUtils.isEmpty(mediaId)) {
                Log.w(TAG, "playFromMediaId(): Ignoring empty mediaId from " + controller);
                return RESULT_CODE_BAD_VALUE;
            }
            return mSessionImpl.getCallback().onPlayFromMediaId(mSessionImpl.getInstance(), controller, mediaId, extras);
        }
    });
}
#end_block

#method_before
@Override
public void setRating(final IMediaController2 caller, int seq, final String mediaId, final ParcelImpl rating) {
    if (caller == null || rating == null) {
        return;
    }
    final Rating2 rating2 = MediaUtils2.fromParcelable(rating);
    dispatchSessionTask(caller, seq, SessionCommand2.COMMAND_CODE_SESSION_SET_RATING, new SessionCallbackTask<Integer>() {

        @Override
        public Integer run(ControllerInfo controller) {
            if (mediaId == null) {
                Log.w(TAG, "setRating(): Ignoring null mediaId from " + controller);
                return RESULT_CODE_BAD_VALUE;
            }
            if (rating2 == null) {
                Log.w(TAG, "setRating(): Ignoring null rating from " + controller);
                return RESULT_CODE_BAD_VALUE;
            }
            return mSessionImpl.getCallback().onSetRating(mSessionImpl.getInstance(), controller, mediaId, rating2);
        }
    });
}
#method_after
@Override
public void setRating(final IMediaController2 caller, int seq, final String mediaId, final ParcelImpl rating) {
    if (caller == null || rating == null) {
        return;
    }
    final Rating2 rating2 = MediaUtils2.fromParcelable(rating);
    dispatchSessionTask(caller, seq, SessionCommand2.COMMAND_CODE_SESSION_SET_RATING, new SessionCallbackTask<Integer>() {

        @Override
        public Integer run(ControllerInfo controller) {
            if (TextUtils.isEmpty(mediaId)) {
                Log.w(TAG, "setRating(): Ignoring empty mediaId from " + controller);
                return RESULT_CODE_BAD_VALUE;
            }
            if (rating2 == null) {
                Log.w(TAG, "setRating(): Ignoring null rating from " + controller);
                return RESULT_CODE_BAD_VALUE;
            }
            return mSessionImpl.getCallback().onSetRating(mSessionImpl.getInstance(), controller, mediaId, rating2);
        }
    });
}
#end_block

#method_before
@Override
public void unsubscribe(final IMediaController2 caller, int seq, final String parentId) {
    if (caller == null) {
        return;
    }
    dispatchLibrarySessionTask(caller, seq, SessionCommand2.COMMAND_CODE_LIBRARY_UNSUBSCRIBE, new LibrarySessionCallbackTask<Integer>() {

        @Override
        public Integer run(ControllerInfo controller) {
            if (parentId == null) {
                Log.w(TAG, "unsubscribe(): Ignoring null parentId from " + controller);
                return LibraryResult.RESULT_CODE_BAD_VALUE;
            }
            return getLibrarySession().onUnsubscribeOnExecutor(controller, parentId);
        }
    });
}
#method_after
@Override
public void unsubscribe(final IMediaController2 caller, int seq, final String parentId) {
    if (caller == null) {
        return;
    }
    dispatchLibrarySessionTask(caller, seq, SessionCommand2.COMMAND_CODE_LIBRARY_UNSUBSCRIBE, new LibrarySessionCallbackTask<Integer>() {

        @Override
        public Integer run(ControllerInfo controller) {
            if (TextUtils.isEmpty(parentId)) {
                Log.w(TAG, "unsubscribe(): Ignoring empty parentId from " + controller);
                return LibraryResult.RESULT_CODE_BAD_VALUE;
            }
            return getLibrarySession().onUnsubscribeOnExecutor(controller, parentId);
        }
    });
}
#end_block

#method_before
@Override
public void onChildrenChanged(final String parentId, final int itemCount, final ParcelImpl libraryParams) {
    if (libraryParams == null) {
        return;
    }
    if (parentId == null) {
        Log.w(TAG, "onChildrenChanged(): Ignoring null parentId");
        return;
    }
    if (itemCount < 0) {
        Log.w(TAG, "onChildrenChanged(): Ignoring negative itemCount: " + itemCount);
        return;
    }
    final MediaBrowser2 browser;
    try {
        browser = getBrowser();
    } catch (IllegalStateException e) {
        Log.w(TAG, "Don't fail silently here. Highly likely a bug");
        return;
    }
    if (browser == null) {
        return;
    }
    browser.getCallbackExecutor().execute(new Runnable() {

        @Override
        public void run() {
            // TODO (b/118472216): Find all ParcelUtils.fromParcelable usages, and null check
            // before calling it.
            browser.getCallback().onChildrenChanged(browser, parentId, itemCount, (LibraryParams) MediaUtils2.fromParcelable(libraryParams));
        }
    });
}
#method_after
@Override
public void onChildrenChanged(final String parentId, final int itemCount, final ParcelImpl libraryParams) {
    if (libraryParams == null) {
        return;
    }
    if (TextUtils.isEmpty(parentId)) {
        Log.w(TAG, "onChildrenChanged(): Ignoring empty parentId");
        return;
    }
    if (itemCount < 0) {
        Log.w(TAG, "onChildrenChanged(): Ignoring negative itemCount: " + itemCount);
        return;
    }
    final MediaBrowser2 browser;
    try {
        browser = getBrowser();
    } catch (IllegalStateException e) {
        Log.w(TAG, "Don't fail silently here. Highly likely a bug");
        return;
    }
    if (browser == null) {
        return;
    }
    browser.getCallbackExecutor().execute(new Runnable() {

        @Override
        public void run() {
            // TODO (b/118472216): Find all ParcelUtils.fromParcelable usages, and null check
            // before calling it.
            browser.getCallback().onChildrenChanged(browser, parentId, itemCount, (LibraryParams) MediaUtils2.fromParcelable(libraryParams));
        }
    });
}
#end_block

#method_before
@Override
public String toString() {
    final StringBuilder sb = new StringBuilder("MediaItem2{");
    sb.append("mMetadata=").append(mMetadata);
    sb.append(", mStartPositionMs=").append(mStartPositionMs);
    sb.append(", mEndPositionMs=").append(mEndPositionMs);
    sb.append('}');
    return sb.toString();
}
#method_after
@Override
public String toString() {
    final StringBuilder sb = new StringBuilder(getClass().getSimpleName());
    sb.append("{mMetadata=").append(mMetadata);
    sb.append(", mStartPositionMs=").append(mStartPositionMs);
    sb.append(", mEndPositionMs=").append(mEndPositionMs);
    sb.append('}');
    return sb.toString();
}
#end_block

#method_before
@Test
public void testGettersAfterConnected() throws InterruptedException {
    prepareLooper();
    final int state = SessionPlayer2.PLAYER_STATE_PLAYING;
    final int bufferingState = SessionPlayer2.BUFFERING_STATE_COMPLETE;
    final long position = 150000;
    final long bufferedPosition = 900000;
    final float speed = 0.5f;
    final long timeDiff = 102;
    final MediaItem2 currentMediaItem = MediaTestUtils.createFileMediaItemWithMetadata();
    Bundle config = RemoteMediaSession2.createMockPlayerConnectorConfig(state, bufferingState, position, bufferedPosition, speed, null, /* audioAttrs */
    null, /* playlist */
    currentMediaItem, null);
    mRemoteSession2.updatePlayer(config);
    MediaController2 controller = createController(mRemoteSession2.getToken());
    controller.setTimeDiff(timeDiff);
    assertEquals(state, controller.getPlayerState());
    assertEquals(bufferedPosition, controller.getBufferedPosition());
    assertEquals(speed, controller.getPlaybackSpeed(), 0.0f);
    assertEquals(position + (long) (speed * timeDiff), controller.getCurrentPosition());
    assertFalse(controller.getCurrentMediaItem() instanceof FileMediaItem2);
    MediaTestUtils.assertMediaItemsWithId(currentMediaItem, controller.getCurrentMediaItem());
}
#method_after
@Test
public void testGettersAfterConnected() throws InterruptedException {
    prepareLooper();
    final int state = SessionPlayer2.PLAYER_STATE_PLAYING;
    final int bufferingState = SessionPlayer2.BUFFERING_STATE_COMPLETE;
    final long position = 150000;
    final long bufferedPosition = 900000;
    final float speed = 0.5f;
    final long timeDiff = 102;
    final MediaItem2 currentMediaItem = MediaTestUtils.createFileMediaItemWithMetadata();
    Bundle config = RemoteMediaSession2.createMockPlayerConnectorConfig(state, bufferingState, position, bufferedPosition, speed, null, /* audioAttrs */
    null, /* playlist */
    currentMediaItem, null);
    mRemoteSession2.updatePlayer(config);
    MediaController2 controller = createController(mRemoteSession2.getToken());
    controller.setTimeDiff(timeDiff);
    assertEquals(state, controller.getPlayerState());
    assertEquals(bufferedPosition, controller.getBufferedPosition());
    assertEquals(speed, controller.getPlaybackSpeed(), 0.0f);
    assertEquals(position + (long) (speed * timeDiff), controller.getCurrentPosition());
    assertNotMediaItemSubclass(controller.getCurrentMediaItem());
    assertEqualMediaIds(currentMediaItem, controller.getCurrentMediaItem());
}
#end_block

#method_before
// Temporaily commenting out, since we don't have the Mock services yet.
// /**
// * Finds the session with id in this test package.
// *
// * @param context
// * @param id
// * @return
// */
// public static SessionToken2 getServiceToken(Context context, String id) {
// switch (id) {
// case MockMediaSessionService2.ID:
// return new SessionToken2(context, new ComponentName(
// context.getPackageName(), MockMediaSessionService2.class.getName()));
// case MockMediaLibraryService2.ID:
// return new SessionToken2(context, new ComponentName(
// context.getPackageName(), MockMediaLibraryService2.class.getName()));
// }
// fail("Unknown id=" + id);
// return null;
// }
public static List<MediaItem2> createFileMediaItems(int size) {
    final List<MediaItem2> list = new ArrayList<>();
    String caller = Thread.currentThread().getStackTrace()[1].getMethodName();
    for (int i = 0; i < size; i++) {
        list.add(new FileMediaItem2.Builder(new FileDescriptor()).setMetadata(new MediaMetadata2.Builder().putString(MediaMetadata2.METADATA_KEY_MEDIA_ID, caller + "_item_" + (size + 1)).build()).build());
    }
    return list;
}
#method_after
// Temporaily commenting out, since we don't have the Mock services yet.
// /**
// * Finds the session with id in this test package.
// *
// * @param context
// * @param id
// * @return
// */
// public static SessionToken2 getServiceToken(Context context, String id) {
// switch (id) {
// case MockMediaSessionService2.ID:
// return new SessionToken2(context, new ComponentName(
// context.getPackageName(), MockMediaSessionService2.class.getName()));
// case MockMediaLibraryService2.ID:
// return new SessionToken2(context, new ComponentName(
// context.getPackageName(), MockMediaLibraryService2.class.getName()));
// }
// fail("Unknown id=" + id);
// return null;
// }
public static List<MediaItem2> createFileMediaItems(int size) {
    final List<MediaItem2> list = new ArrayList<>();
    String caller = Thread.currentThread().getStackTrace()[1].getMethodName();
    for (int i = 0; i < size; i++) {
        list.add(new FileMediaItem2.Builder(new FileDescriptor()).setMetadata(new MediaMetadata2.Builder().putString(MediaMetadata2.METADATA_KEY_MEDIA_ID, caller + "_item_" + (i + 1)).build()).build());
    }
    return list;
}
#end_block

#method_before
public Builder setExtras(@Nullable Bundle extras) {
    mBundle.putBundle(METADATA_KEY_EXTRAS, extras);
    return this;
}
#method_after
@NonNull
public Builder setExtras(@Nullable Bundle extras) {
    mBundle.putBundle(METADATA_KEY_EXTRAS, extras);
    return this;
}
#end_block

#method_before
@Test
@Ignore("b/110738672")
public void testControllerCallback_onSeekCompleted() throws Exception {
    prepareLooper();
    final long testSeekPosition = 400;
    final long testPosition = 500;
    final CountDownLatch latch = new CountDownLatch(1);
    final ControllerCallback callback = new ControllerCallback() {

        @Override
        public void onSeekCompleted(MediaController2 controller, long position) {
            assertEquals(testSeekPosition, position);
            latch.countDown();
        }
    };
    mSession.setPlaybackState(new PlaybackStateCompat.Builder().setState(PlaybackStateCompat.STATE_PLAYING, testPosition, /* position */
    1f).build());
    mController = createController(mSession.getSessionToken(), true, callback);
    mController.setTimeDiff(Long.valueOf(0));
    mSession.setPlaybackState(new PlaybackStateCompat.Builder().setState(PlaybackStateCompat.STATE_PLAYING, testSeekPosition, /* position */
    1f).build());
    assertTrue(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
}
#method_after
@Test
public void testControllerCallback_onSeekCompleted() throws Exception {
    prepareLooper();
    final long testSeekPosition = 400;
    final long testPosition = 500;
    final CountDownLatch latch = new CountDownLatch(1);
    final ControllerCallback callback = new ControllerCallback() {

        @Override
        public void onSeekCompleted(MediaController2 controller, long position) {
            assertEquals(testSeekPosition, position);
            latch.countDown();
        }
    };
    mSession.setPlaybackState(new PlaybackStateCompat.Builder().setState(PlaybackStateCompat.STATE_PLAYING, testPosition, /* position */
    1f).build());
    mController = createController(mSession.getSessionToken(), true, callback);
    mController.setTimeDiff(Long.valueOf(0));
    mSession.setPlaybackState(new PlaybackStateCompat.Builder().setState(PlaybackStateCompat.STATE_PLAYING, testSeekPosition, /* position */
    1f).build());
    assertTrue(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
}
#end_block

#method_before
@Test
@Ignore("b/110738672")
public void testControllerCallback_onPlayerStateChanged() throws Exception {
    prepareLooper();
    final int testPlayerState = SessionPlayer2.PLAYER_STATE_PLAYING;
    final long testPosition = 500;
    final CountDownLatch latch = new CountDownLatch(1);
    final ControllerCallback callback = new ControllerCallback() {

        @Override
        public void onPlayerStateChanged(MediaController2 controller, int state) {
            assertEquals(testPlayerState, state);
            assertEquals(testPlayerState, controller.getPlayerState());
            assertEquals(testPosition, controller.getCurrentPosition());
            latch.countDown();
        }
    };
    mSession.setPlaybackState(new PlaybackStateCompat.Builder().setState(PlaybackStateCompat.STATE_NONE, 0, /* position */
    1f).build());
    mController = createController(mSession.getSessionToken(), true, callback);
    mController.setTimeDiff(Long.valueOf(0));
    mSession.setPlaybackState(new PlaybackStateCompat.Builder().setState(PlaybackStateCompat.STATE_PLAYING, testPosition, /* position */
    1f).build());
    assertTrue(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
}
#method_after
@Test
public void testControllerCallback_onPlayerStateChanged() throws Exception {
    prepareLooper();
    final int testPlayerState = SessionPlayer2.PLAYER_STATE_PLAYING;
    final long testPosition = 500;
    final CountDownLatch latch = new CountDownLatch(1);
    final ControllerCallback callback = new ControllerCallback() {

        @Override
        public void onPlayerStateChanged(MediaController2 controller, int state) {
            assertEquals(testPlayerState, state);
            assertEquals(testPlayerState, controller.getPlayerState());
            assertEquals(testPosition, controller.getCurrentPosition());
            latch.countDown();
        }
    };
    mSession.setPlaybackState(new PlaybackStateCompat.Builder().setState(PlaybackStateCompat.STATE_NONE, 0, /* position */
    1f).build());
    mController = createController(mSession.getSessionToken(), true, callback);
    mController.setTimeDiff(Long.valueOf(0));
    mSession.setPlaybackState(new PlaybackStateCompat.Builder().setState(PlaybackStateCompat.STATE_PLAYING, testPosition, /* position */
    1f).build());
    assertTrue(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
}
#end_block

#method_before
public static MediaItem2 convertToMediaItem2(MediaMetadataCompat metadataCompat) {
    if (metadataCompat == null) {
        return null;
    }
    // Item is from the MediaControllerCompat, so forcefully set the playable.
    MediaMetadata2 metadata2 = new MediaMetadata2.Builder(metadataCompat.getBundle()).putLong(METADATA_KEY_PLAYABLE, 1).build();
    return new MediaItem2.Builder().setMetadata(metadata2).build();
}
#method_after
public static MediaItem2 convertToMediaItem2(MediaMetadataCompat metadataCompat) {
    if (metadataCompat == null) {
        return null;
    }
    // Item is from the MediaControllerCompat, so forcefully set the playable.
    MediaMetadata2 metadata2 = new MediaMetadata2.Builder(metadataCompat.getBundle()).putLong(METADATA_KEY_BROWSABLE, BROWSABLE_TYPE_NONE).putLong(METADATA_KEY_PLAYABLE, 1).build();
    return new MediaItem2.Builder().setMetadata(metadata2).build();
}
#end_block

#method_before
public static List<MediaItem2> convertParcelImplListSliceToMediaItem2List(ParcelImplListSlice listSlice) {
    if (listSlice == null) {
        return null;
    }
    List<ParcelImpl> parcelImplList = listSlice.getList();
    List<MediaItem2> mediaItem2List = new ArrayList<>();
    for (int i = 0; i < parcelImplList.size(); i++) {
        final ParcelImpl itemParcelImpl = parcelImplList.get(i);
        if (itemParcelImpl != null) {
            mediaItem2List.add((MediaItem2) MediaUtils2.fromParcelable(itemParcelImpl));
        }
    }
    return mediaItem2List;
}
#method_after
public static List<MediaItem2> convertParcelImplListSliceToMediaItem2List(ParcelImplListSlice listSlice) {
    if (listSlice == null) {
        return null;
    }
    List<ParcelImpl> parcelImplList = listSlice.getList();
    List<MediaItem2> mediaItem2List = new ArrayList<>();
    for (int i = 0; i < parcelImplList.size(); i++) {
        final ParcelImpl itemParcelImpl = parcelImplList.get(i);
        if (itemParcelImpl != null) {
            mediaItem2List.add((MediaItem2) fromParcelable(itemParcelImpl));
        }
    }
    return mediaItem2List;
}
#end_block

#method_before
private static MediaMetadata2 convertToMediaMetadata2(MediaDescriptionCompat descCompat, boolean browsable, boolean playable) {
    if (descCompat == null) {
        return null;
    }
    MediaMetadata2.Builder metadata2Builder = new MediaMetadata2.Builder();
    metadata2Builder.putString(METADATA_KEY_MEDIA_ID, descCompat.getMediaId());
    CharSequence title = descCompat.getTitle();
    if (title != null) {
        metadata2Builder.putText(METADATA_KEY_DISPLAY_TITLE, title);
    }
    CharSequence description = descCompat.getDescription();
    if (description != null) {
        metadata2Builder.putText(METADATA_KEY_DISPLAY_DESCRIPTION, descCompat.getDescription());
    }
    CharSequence subtitle = descCompat.getSubtitle();
    if (subtitle != null) {
        metadata2Builder.putText(METADATA_KEY_DISPLAY_SUBTITLE, subtitle);
    }
    Bitmap icon = descCompat.getIconBitmap();
    if (icon != null) {
        metadata2Builder.putBitmap(METADATA_KEY_DISPLAY_ICON, icon);
    }
    Uri iconUri = descCompat.getIconUri();
    if (iconUri != null) {
        metadata2Builder.putText(METADATA_KEY_DISPLAY_ICON_URI, iconUri.toString());
    }
    Bundle bundle = descCompat.getExtras();
    if (bundle != null) {
        metadata2Builder.setExtras(bundle);
    }
    Uri mediaUri = descCompat.getMediaUri();
    if (mediaUri != null) {
        metadata2Builder.putText(METADATA_KEY_MEDIA_URI, mediaUri.toString());
    }
    if (bundle != null && bundle.containsKey(EXTRA_BT_FOLDER_TYPE)) {
        metadata2Builder.putLong(METADATA_KEY_BROWSABLE, bundle.getLong(EXTRA_BT_FOLDER_TYPE));
    } else if (browsable) {
        metadata2Builder.putLong(METADATA_KEY_BROWSABLE, BROWSABLE_TYPE_MIXED);
    }
    if (playable) {
        metadata2Builder.putLong(METADATA_KEY_PLAYABLE, 1);
    }
    return metadata2Builder.build();
}
#method_after
private static MediaMetadata2 convertToMediaMetadata2(MediaDescriptionCompat descCompat, boolean browsable, boolean playable) {
    if (descCompat == null) {
        return null;
    }
    MediaMetadata2.Builder metadata2Builder = new MediaMetadata2.Builder();
    metadata2Builder.putString(METADATA_KEY_MEDIA_ID, descCompat.getMediaId());
    CharSequence title = descCompat.getTitle();
    if (title != null) {
        metadata2Builder.putText(METADATA_KEY_DISPLAY_TITLE, title);
    }
    CharSequence description = descCompat.getDescription();
    if (description != null) {
        metadata2Builder.putText(METADATA_KEY_DISPLAY_DESCRIPTION, descCompat.getDescription());
    }
    CharSequence subtitle = descCompat.getSubtitle();
    if (subtitle != null) {
        metadata2Builder.putText(METADATA_KEY_DISPLAY_SUBTITLE, subtitle);
    }
    Bitmap icon = descCompat.getIconBitmap();
    if (icon != null) {
        metadata2Builder.putBitmap(METADATA_KEY_DISPLAY_ICON, icon);
    }
    Uri iconUri = descCompat.getIconUri();
    if (iconUri != null) {
        metadata2Builder.putText(METADATA_KEY_DISPLAY_ICON_URI, iconUri.toString());
    }
    Bundle bundle = descCompat.getExtras();
    if (bundle != null) {
        metadata2Builder.setExtras(bundle);
    }
    Uri mediaUri = descCompat.getMediaUri();
    if (mediaUri != null) {
        metadata2Builder.putText(METADATA_KEY_MEDIA_URI, mediaUri.toString());
    }
    if (bundle != null && bundle.containsKey(EXTRA_BT_FOLDER_TYPE)) {
        metadata2Builder.putLong(METADATA_KEY_BROWSABLE, bundle.getLong(EXTRA_BT_FOLDER_TYPE));
    } else if (browsable) {
        metadata2Builder.putLong(METADATA_KEY_BROWSABLE, BROWSABLE_TYPE_MIXED);
    } else {
        metadata2Builder.putLong(METADATA_KEY_BROWSABLE, BROWSABLE_TYPE_NONE);
    }
    metadata2Builder.putLong(METADATA_KEY_PLAYABLE, playable ? 1 : 0);
    return metadata2Builder.build();
}
#end_block

#method_before
public static MediaMetadata2 convertToMediaMetadata2(CharSequence queueTitle) {
    if (queueTitle == null) {
        return null;
    }
    return new MediaMetadata2.Builder().putString(METADATA_KEY_TITLE, queueTitle.toString()).build();
}
#method_after
public static MediaMetadata2 convertToMediaMetadata2(CharSequence queueTitle) {
    if (queueTitle == null) {
        return null;
    }
    return new MediaMetadata2.Builder().putString(METADATA_KEY_TITLE, queueTitle.toString()).putLong(METADATA_KEY_BROWSABLE, BROWSABLE_TYPE_MIXED).putLong(METADATA_KEY_PLAYABLE, 1).build();
}
#end_block

#method_before
public static List<ParcelImpl> convertCommandButtonListToParcelImplList(List<CommandButton> commandButtonList) {
    if (commandButtonList == null) {
        return null;
    }
    List<ParcelImpl> parcelImplList = new ArrayList<>();
    for (int i = 0; i < commandButtonList.size(); i++) {
        final CommandButton commandButton = commandButtonList.get(i);
        parcelImplList.add(MediaUtils2.toParcelable(commandButton));
    }
    return parcelImplList;
}
#method_after
public static List<ParcelImpl> convertCommandButtonListToParcelImplList(List<CommandButton> commandButtonList) {
    if (commandButtonList == null) {
        return null;
    }
    List<ParcelImpl> parcelImplList = new ArrayList<>();
    for (int i = 0; i < commandButtonList.size(); i++) {
        final CommandButton commandButton = commandButtonList.get(i);
        parcelImplList.add(toParcelable(commandButton));
    }
    return parcelImplList;
}
#end_block

#method_before
public static ParcelImplListSlice convertMediaItem2ListToParcelImplListSlice(List<MediaItem2> mediaItem2List) {
    if (mediaItem2List == null) {
        return null;
    }
    List<ParcelImpl> itemParcelableList = new ArrayList<>();
    for (int i = 0; i < mediaItem2List.size(); i++) {
        final MediaItem2 item = mediaItem2List.get(i);
        if (item != null) {
            final ParcelImpl itemParcelImpl = MediaUtils2.toParcelable(item);
            itemParcelableList.add(itemParcelImpl);
        }
    }
    return new ParcelImplListSlice(itemParcelableList);
}
#method_after
public static ParcelImplListSlice convertMediaItem2ListToParcelImplListSlice(List<MediaItem2> mediaItem2List) {
    if (mediaItem2List == null) {
        return null;
    }
    List<ParcelImpl> itemParcelableList = new ArrayList<>();
    for (int i = 0; i < mediaItem2List.size(); i++) {
        final MediaItem2 item = mediaItem2List.get(i);
        if (item != null) {
            final ParcelImpl itemParcelImpl = toParcelable(item);
            itemParcelableList.add(itemParcelImpl);
        }
    }
    return new ParcelImplListSlice(itemParcelableList);
}
#end_block

#method_before
public void setOnFullScreenListener(OnFullScreenListener l) {
    mOnFullScreenListener = l;
    mFullScreenButton.setVisibility(View.VISIBLE);
}
#method_after
public void setOnFullScreenListener(@NonNull OnFullScreenListener l) {
    mOnFullScreenListener = l;
    mFullScreenButton.setVisibility(View.VISIBLE);
}
#end_block

#method_before
private void writeDeviceConfig(ProtoOutputStream protoOutputStream, long fieldId, PrintWriter pw, Configuration config, DisplayManager dm) {
    Point stableSize = dm.getStableDisplaySize();
    long token = -1;
    if (protoOutputStream != null) {
        token = protoOutputStream.start(fieldId);
        protoOutputStream.write(DeviceConfigurationProto.STABLE_SCREEN_WIDTH_PX, stableSize.x);
        protoOutputStream.write(DeviceConfigurationProto.STABLE_SCREEN_HEIGHT_PX, stableSize.y);
        protoOutputStream.write(DeviceConfigurationProto.STABLE_DENSITY_DPI, DisplayMetrics.DENSITY_DEVICE_STABLE);
    }
    if (pw != null) {
        pw.print("stable-width-px: ");
        pw.println(stableSize.x);
        pw.print("stable-height-px: ");
        pw.println(stableSize.y);
        pw.print("stable-density-dpi: ");
        pw.println(DisplayMetrics.DENSITY_DEVICE_STABLE);
    }
    MemInfoReader memreader = new MemInfoReader();
    memreader.readMemInfo();
    KeyguardManager kgm = mInternal.mContext.getSystemService(KeyguardManager.class);
    if (protoOutputStream != null) {
        protoOutputStream.write(DeviceConfigurationProto.TOTAL_RAM, memreader.getTotalSize());
        protoOutputStream.write(DeviceConfigurationProto.LOW_RAM, ActivityManager.isLowRamDeviceStatic());
        protoOutputStream.write(DeviceConfigurationProto.MAX_CORES, Runtime.getRuntime().availableProcessors());
        protoOutputStream.write(DeviceConfigurationProto.HAS_SECURE_SCREEN_LOCK, kgm.isDeviceSecure());
    }
    if (pw != null) {
        pw.print("total-ram: ");
        pw.println(memreader.getTotalSize());
        pw.print("low-ram: ");
        pw.println(ActivityManager.isLowRamDeviceStatic());
        pw.print("max-cores: ");
        pw.println(Runtime.getRuntime().availableProcessors());
        pw.print("has-secure-screen-lock: ");
        pw.println(kgm.isDeviceSecure());
    }
    ConfigurationInfo configInfo = mInternal.getDeviceConfigurationInfo();
    if (configInfo.reqGlEsVersion != ConfigurationInfo.GL_ES_VERSION_UNDEFINED) {
        if (protoOutputStream != null) {
            protoOutputStream.write(DeviceConfigurationProto.OPENGL_VERSION, configInfo.reqGlEsVersion);
        }
        if (pw != null) {
            pw.print("opengl-version: 0x");
            pw.println(Integer.toHexString(configInfo.reqGlEsVersion));
        }
    }
    Set<String> glExtensionsSet = getGlExtensionsFromDriver();
    String[] glExtensions = new String[glExtensionsSet.size()];
    glExtensions = glExtensionsSet.toArray(glExtensions);
    Arrays.sort(glExtensions);
    for (int i = 0; i < glExtensions.length; i++) {
        if (protoOutputStream != null) {
            protoOutputStream.write(DeviceConfigurationProto.OPENGL_EXTENSIONS, glExtensions[i]);
        }
        if (pw != null) {
            pw.print("opengl-extensions: ");
            pw.println(glExtensions[i]);
        }
    }
    PackageManager pm = mInternal.mContext.getPackageManager();
    List<SharedLibraryInfo> slibs = pm.getSharedLibraries(0);
    Collections.sort(slibs, Comparator.comparing(SharedLibraryInfo::getName));
    for (int i = 0; i < slibs.size(); i++) {
        if (protoOutputStream != null) {
            protoOutputStream.write(DeviceConfigurationProto.SHARED_LIBRARIES, slibs.get(i).getName());
        }
        if (pw != null) {
            pw.print("shared-libraries: ");
            pw.println(slibs.get(i).getName());
        }
    }
    FeatureInfo[] features = pm.getSystemAvailableFeatures();
    Arrays.sort(features, (o1, o2) -> (o1.name == o2.name ? 0 : (o1.name == null ? -1 : (o2.name == null) ? 1 : o1.name.compareTo(o2.name))));
    for (int i = 0; i < features.length; i++) {
        if (features[i].name != null) {
            if (protoOutputStream != null) {
                protoOutputStream.write(DeviceConfigurationProto.FEATURES, features[i].name);
            }
            if (pw != null) {
                pw.print("features: ");
                pw.println(features[i].name);
            }
        }
    }
    if (protoOutputStream != null) {
        protoOutputStream.end(token);
    }
}
#method_after
private void writeDeviceConfig(ProtoOutputStream protoOutputStream, long fieldId, PrintWriter pw, Configuration config, DisplayManager dm) {
    Point stableSize = dm.getStableDisplaySize();
    long token = -1;
    if (protoOutputStream != null) {
        token = protoOutputStream.start(fieldId);
        protoOutputStream.write(DeviceConfigurationProto.STABLE_SCREEN_WIDTH_PX, stableSize.x);
        protoOutputStream.write(DeviceConfigurationProto.STABLE_SCREEN_HEIGHT_PX, stableSize.y);
        protoOutputStream.write(DeviceConfigurationProto.STABLE_DENSITY_DPI, DisplayMetrics.DENSITY_DEVICE_STABLE);
    }
    if (pw != null) {
        pw.print("stable-width-px: ");
        pw.println(stableSize.x);
        pw.print("stable-height-px: ");
        pw.println(stableSize.y);
        pw.print("stable-density-dpi: ");
        pw.println(DisplayMetrics.DENSITY_DEVICE_STABLE);
    }
    MemInfoReader memreader = new MemInfoReader();
    memreader.readMemInfo();
    KeyguardManager kgm = mInternal.mContext.getSystemService(KeyguardManager.class);
    if (protoOutputStream != null) {
        protoOutputStream.write(DeviceConfigurationProto.TOTAL_RAM, memreader.getTotalSize());
        protoOutputStream.write(DeviceConfigurationProto.LOW_RAM, ActivityManager.isLowRamDeviceStatic());
        protoOutputStream.write(DeviceConfigurationProto.MAX_CORES, Runtime.getRuntime().availableProcessors());
        protoOutputStream.write(DeviceConfigurationProto.HAS_SECURE_SCREEN_LOCK, kgm.isDeviceSecure());
    }
    if (pw != null) {
        pw.print("total-ram: ");
        pw.println(memreader.getTotalSize());
        pw.print("low-ram: ");
        pw.println(ActivityManager.isLowRamDeviceStatic());
        pw.print("max-cores: ");
        pw.println(Runtime.getRuntime().availableProcessors());
        pw.print("has-secure-screen-lock: ");
        pw.println(kgm.isDeviceSecure());
    }
    ConfigurationInfo configInfo = mInternal.getDeviceConfigurationInfo();
    if (configInfo.reqGlEsVersion != ConfigurationInfo.GL_ES_VERSION_UNDEFINED) {
        if (protoOutputStream != null) {
            protoOutputStream.write(DeviceConfigurationProto.OPENGL_VERSION, configInfo.reqGlEsVersion);
        }
        if (pw != null) {
            pw.print("opengl-version: 0x");
            pw.println(Integer.toHexString(configInfo.reqGlEsVersion));
        }
    }
    Set<String> glExtensionsSet = getGlExtensionsFromDriver();
    String[] glExtensions = new String[glExtensionsSet.size()];
    glExtensions = glExtensionsSet.toArray(glExtensions);
    Arrays.sort(glExtensions);
    for (int i = 0; i < glExtensions.length; i++) {
        if (protoOutputStream != null) {
            protoOutputStream.write(DeviceConfigurationProto.OPENGL_EXTENSIONS, glExtensions[i]);
        }
        if (pw != null) {
            pw.print("opengl-extensions: ");
            pw.println(glExtensions[i]);
        }
    }
    PackageManager pm = mInternal.mContext.getPackageManager();
    List<SharedLibraryInfo> slibs = pm.getSharedLibraries(0);
    Collections.sort(slibs, Comparator.comparing(SharedLibraryInfo::getName));
    for (int i = 0; i < slibs.size(); i++) {
        if (protoOutputStream != null) {
            protoOutputStream.write(DeviceConfigurationProto.SHARED_LIBRARIES, slibs.get(i).getName());
        }
        if (pw != null) {
            pw.print("shared-libraries: ");
            pw.println(slibs.get(i).getName());
        }
    }
    FeatureInfo[] features = pm.getSystemAvailableFeatures();
    Arrays.sort(features, (o1, o2) -> {
        if (o1.name == o2.name)
            return 0;
        if (o1.name == null)
            return -1;
        if (o2.name == null)
            return 1;
        return o1.name.compareTo(o2.name);
    });
    for (int i = 0; i < features.length; i++) {
        if (features[i].name != null) {
            if (protoOutputStream != null) {
                protoOutputStream.write(DeviceConfigurationProto.FEATURES, features[i].name);
            }
            if (pw != null) {
                pw.print("features: ");
                pw.println(features[i].name);
            }
        }
    }
    if (protoOutputStream != null) {
        protoOutputStream.end(token);
    }
}
#end_block

#method_before
@Override
public void onMeasureImpl(int widthMeasureSpec, int heightMeasureSpec) {
    if (mIsMusicMediaType) {
        int currWidth = mInstance.getMeasuredWidth();
        int currHeight = mInstance.getMeasuredHeight();
        if (mPrevWidth != currWidth) {
            Point screenSize = new Point();
            mManager.getDefaultDisplay().getSize(screenSize);
            int screenWidth = screenSize.x;
            if (currWidth == screenWidth) {
                int orientation = retrieveOrientation();
                if (orientation == ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE) {
                    updateCurrentMusicView(mMusicFullLandscapeView);
                } else {
                    updateCurrentMusicView(mMusicFullPortraitView);
                }
                if (mSizeType != SIZE_TYPE_FULL) {
                    mSizeType = SIZE_TYPE_FULL;
                }
            } else {
                if (mSizeType != SIZE_TYPE_EMBEDDED) {
                    mSizeType = SIZE_TYPE_EMBEDDED;
                    updateCurrentMusicView(mMusicEmbeddedView);
                }
            }
            mPrevWidth = currWidth;
            mPrevHeight = currHeight;
        }
    }
}
#method_after
@Override
public void onMeasureImpl(int widthMeasureSpec, int heightMeasureSpec) {
    if (mIsMusicMediaType) {
        int currWidth = mInstance.getMeasuredWidth();
        int currHeight = mInstance.getMeasuredHeight();
        if (mPrevWidth != currWidth) {
            Point screenSize = new Point();
            mManager.getDefaultDisplay().getSize(screenSize);
            int screenWidth = screenSize.x;
            if (currWidth == screenWidth) {
                int orientation = retrieveOrientation();
                if (orientation == ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE) {
                    updateCurrentMusicView(mMusicFullLandscapeView);
                } else {
                    updateCurrentMusicView(mMusicFullPortraitView);
                }
                if (mSizeType != SIZE_TYPE_FULL) {
                    mSizeType = SIZE_TYPE_FULL;
                }
            } else {
                if (mSizeType != SIZE_TYPE_EMBEDDED) {
                    mSizeType = SIZE_TYPE_EMBEDDED;
                    updateCurrentMusicView(mMusicEmbeddedView);
                }
            }
            mPrevWidth = currWidth;
        }
    }
}
#end_block

#method_before
void openVideo() {
    if (DEBUG) {
        Log.d(TAG, "openVideo()");
    }
    if (mMediaItem != null) {
        resetPlayer();
        if (isRemotePlayback()) {
            mRoutePlayer.setMediaItem(mMediaItem);
            return;
        }
    }
    try {
        if (mMediaPlayer == null) {
            mMediaPlayer = new VideoView2Player(mInstance.getContext());
        }
        mSurfaceView.setMediaPlayer(mMediaPlayer);
        mTextureView.setMediaPlayer(mMediaPlayer);
        if (!mCurrentView.assignSurfaceToMediaPlayer(mMediaPlayer)) {
            Log.w(TAG, "failed to assign surface");
        }
        mMediaPlayer.setAudioAttributes(mAudioAttributes);
        ensureSessionWithPlayer(mMediaPlayer);
        mMediaPlayer.setMediaItem(mMediaItem);
        final Context context = mInstance.getContext();
        mSubtitleController = new SubtitleController(context);
        mSubtitleController.registerRenderer(new ClosedCaptionRenderer(context));
        mSubtitleController.registerRenderer(new Cea708CaptionRenderer(context));
        mSubtitleController.setAnchor((SubtitleController.Anchor) mSubtitleAnchorView);
        // we don't set the target state here either, but preserve the
        // target state that was there before.
        mCurrentState = STATE_PREPARING;
        mMediaSession.getPlayer().prepare();
    } catch (IllegalArgumentException ex) {
        Log.w(TAG, "Unable to open content: " + mMediaItem, ex);
        mCurrentState = STATE_ERROR;
        mTargetState = STATE_ERROR;
    }
}
#method_after
void openVideo() {
    if (DEBUG) {
        Log.d(TAG, "openVideo()");
    }
    if (mMediaItem != null) {
        resetPlayer();
        if (isRemotePlayback()) {
            mRoutePlayer.setMediaItem(mMediaItem);
            return;
        }
    }
    try {
        if (mMediaPlayer == null) {
            mMediaPlayer = new VideoView2Player(mInstance.getContext());
        }
        mSurfaceView.setMediaPlayer(mMediaPlayer);
        mTextureView.setMediaPlayer(mMediaPlayer);
        if (!mCurrentView.assignSurfaceToMediaPlayer(mMediaPlayer)) {
            Log.w(TAG, "failed to assign surface");
        }
        mMediaPlayer.setAudioAttributes(mAudioAttributes);
        ensureSessionWithPlayer(mMediaPlayer);
        mMediaPlayer.setMediaItem(mMediaItem);
        final Context context = mInstance.getContext();
        mSubtitleController = new SubtitleController(context);
        mSubtitleController.registerRenderer(new ClosedCaptionRenderer(context));
        mSubtitleController.registerRenderer(new Cea708CaptionRenderer(context));
        mSubtitleController.setAnchor(mSubtitleAnchorView);
        // we don't set the target state here either, but preserve the
        // target state that was there before.
        mCurrentState = STATE_PREPARING;
        mMediaSession.getPlayer().prepare();
    } catch (IllegalArgumentException ex) {
        Log.w(TAG, "Unable to open content: " + mMediaItem, ex);
        mCurrentState = STATE_ERROR;
        mTargetState = STATE_ERROR;
    }
}
#end_block

#method_before
@Override
public void invocationComplete(IInvocationContext context, Map<ITestDevice, FreeDeviceState> devicesStates) {
    for (ITestDevice device : context.getDevices()) {
        mDeviceManager.freeDevice(device, devicesStates.get(device));
        if (device instanceof IManagedTestDevice) {
            // This quite an important setting so we do make sure it's reset.
            ((IManagedTestDevice) device).setFastbootPath(mDeviceManager.getFastbootPath());
        }
    }
}
#method_after
@Override
public void invocationComplete(IInvocationContext context, Map<ITestDevice, FreeDeviceState> devicesStates) {
    for (ITestDevice device : context.getDevices()) {
        mDeviceManager.freeDevice(device, devicesStates.get(device));
        if (device instanceof IManagedTestDevice) {
            // This is quite an important setting so we do make sure it's reset.
            ((IManagedTestDevice) device).setFastbootPath(mDeviceManager.getFastbootPath());
        }
    }
}
#end_block

#method_before
private void fillList() {
    final TelephonyManager tm = (TelephonyManager) getSystemService(Context.TELEPHONY_SERVICE);
    final int subId = mSubscriptionInfo != null ? mSubscriptionInfo.getSubscriptionId() : SubscriptionManager.INVALID_SUBSCRIPTION_ID;
    final String mccmnc = mSubscriptionInfo == null ? "" : tm.getSimOperator(subId);
    Log.d(TAG, "mccmnc = " + mccmnc);
    StringBuilder where = new StringBuilder("numeric=\"" + mccmnc + "\" AND NOT (type='ia' AND (apn=\"\" OR apn IS NULL)) AND user_visible!=0");
    if (mHideImsApn) {
        where.append(" AND NOT (type='ims')");
    }
    Cursor cursor = getContentResolver().query(Telephony.Carriers.CONTENT_URI, new String[] { "_id", "name", "apn", "type", "mvno_type", "mvno_match_data" }, where.toString(), null, Telephony.Carriers.DEFAULT_SORT_ORDER);
    if (cursor != null) {
        IccRecords r = null;
        if (mUiccController != null && mSubscriptionInfo != null) {
            r = mUiccController.getIccRecords(SubscriptionManager.getPhoneId(subId), UiccController.APP_FAM_3GPP);
        }
        PreferenceGroup apnList = (PreferenceGroup) findPreference("apn_list");
        apnList.removeAll();
        ArrayList<ApnPreference> mnoApnList = new ArrayList<ApnPreference>();
        ArrayList<ApnPreference> mvnoApnList = new ArrayList<ApnPreference>();
        ArrayList<ApnPreference> mnoMmsApnList = new ArrayList<ApnPreference>();
        ArrayList<ApnPreference> mvnoMmsApnList = new ArrayList<ApnPreference>();
        mSelectedKey = getSelectedApnKey();
        cursor.moveToFirst();
        while (!cursor.isAfterLast()) {
            String name = cursor.getString(NAME_INDEX);
            String apn = cursor.getString(APN_INDEX);
            String key = cursor.getString(ID_INDEX);
            String type = cursor.getString(TYPES_INDEX);
            String mvnoType = cursor.getString(MVNO_TYPE_INDEX);
            String mvnoMatchData = cursor.getString(MVNO_MATCH_DATA_INDEX);
            ApnPreference pref = new ApnPreference(getPrefContext());
            pref.setKey(key);
            pref.setTitle(name);
            pref.setSummary(apn);
            pref.setPersistent(false);
            pref.setOnPreferenceChangeListener(this);
            pref.setSubId(subId);
            boolean selectable = ((type == null) || !type.equals("mms"));
            pref.setSelectable(selectable);
            if (selectable) {
                if ((mSelectedKey != null) && mSelectedKey.equals(key)) {
                    pref.setChecked();
                }
                addApnToList(pref, mnoApnList, mvnoApnList, r, mvnoType, mvnoMatchData);
            } else {
                addApnToList(pref, mnoMmsApnList, mvnoMmsApnList, r, mvnoType, mvnoMatchData);
            }
            cursor.moveToNext();
        }
        cursor.close();
        if (!mvnoApnList.isEmpty()) {
            mnoApnList = mvnoApnList;
            mnoMmsApnList = mvnoMmsApnList;
        // Also save the mvno info
        }
        for (Preference preference : mnoApnList) {
            apnList.addPreference(preference);
        }
        for (Preference preference : mnoMmsApnList) {
            apnList.addPreference(preference);
        }
    }
}
#method_after
private void fillList() {
    final TelephonyManager tm = (TelephonyManager) getSystemService(Context.TELEPHONY_SERVICE);
    final int subId = mSubscriptionInfo != null ? mSubscriptionInfo.getSubscriptionId() : SubscriptionManager.INVALID_SUBSCRIPTION_ID;
    final String mccmnc = mSubscriptionInfo == null ? "" : tm.getSimOperator(subId);
    Log.d(TAG, "mccmnc = " + mccmnc);
    StringBuilder where = new StringBuilder("numeric=\"" + mccmnc + "\" AND NOT (type='ia' AND (apn=\"\" OR apn IS NULL)) AND user_visible!=0");
    if (mHideImsApn) {
        where.append(" AND NOT (type='ims')");
    }
    Cursor cursor = getContentResolver().query(Telephony.Carriers.CONTENT_URI, new String[] { "_id", "name", "apn", "type", "mvno_type", "mvno_match_data" }, where.toString(), null, Telephony.Carriers.DEFAULT_SORT_ORDER);
    if (cursor != null) {
        IccRecords r = null;
        if (mUiccController != null && mSubscriptionInfo != null) {
            r = mUiccController.getIccRecords(SubscriptionManager.getPhoneId(subId), UiccController.APP_FAM_3GPP);
        }
        PreferenceGroup apnList = (PreferenceGroup) findPreference("apn_list");
        apnList.removeAll();
        ArrayList<ApnPreference> mnoApnList = new ArrayList<ApnPreference>();
        ArrayList<ApnPreference> mvnoApnList = new ArrayList<ApnPreference>();
        ArrayList<ApnPreference> mnoMmsApnList = new ArrayList<ApnPreference>();
        ArrayList<ApnPreference> mvnoMmsApnList = new ArrayList<ApnPreference>();
        mSelectedKey = getSelectedApnKey();
        cursor.moveToFirst();
        while (!cursor.isAfterLast()) {
            String name = cursor.getString(NAME_INDEX);
            String apn = cursor.getString(APN_INDEX);
            String key = cursor.getString(ID_INDEX);
            String type = cursor.getString(TYPES_INDEX);
            String mvnoType = cursor.getString(MVNO_TYPE_INDEX);
            String mvnoMatchData = cursor.getString(MVNO_MATCH_DATA_INDEX);
            ApnPreference pref = new ApnPreference(getPrefContext());
            pref.setKey(key);
            pref.setTitle(name);
            pref.setSummary(apn);
            pref.setPersistent(false);
            pref.setSubId(subId);
            boolean selectable = ((type == null) || !type.equals("mms"));
            pref.setSelectable(selectable);
            if (selectable) {
                if ((mSelectedKey != null) && mSelectedKey.equals(key)) {
                    pref.setChecked();
                }
                addApnToList(pref, mnoApnList, mvnoApnList, r, mvnoType, mvnoMatchData);
            } else {
                addApnToList(pref, mnoMmsApnList, mvnoMmsApnList, r, mvnoType, mvnoMatchData);
            }
            cursor.moveToNext();
        }
        cursor.close();
        if (!mvnoApnList.isEmpty()) {
            mnoApnList = mvnoApnList;
            mnoMmsApnList = mvnoMmsApnList;
        // Also save the mvno info
        }
        for (Preference preference : mnoApnList) {
            apnList.addPreference(preference);
        }
        for (Preference preference : mnoMmsApnList) {
            apnList.addPreference(preference);
        }
    }
}
#end_block

#method_before
private String getAlgorithmFromPKCS8(byte[] keyData) {
    try {
        final ASN1InputStream bIn = new ASN1InputStream(new ByteArrayInputStream(keyData));
        final PrivateKeyInfo pki = PrivateKeyInfo.getInstance(bIn.readObject());
        final String algOid = pki.getAlgorithmId().getAlgorithm().getId();
        return new AlgorithmId(new ObjectIdentifier(algOid)).getName();
    } catch (IOException e) {
        Log.e(TAG, "getAlgorithmFromPKCS8 Failed to parse key data");
        Log.e(TAG, Log.getStackTraceString(e));
        return null;
    }
}
#method_after
private String getAlgorithmFromPKCS8(byte[] keyData) {
    try {
        final ASN1InputStream bIn = new ASN1InputStream(new ByteArrayInputStream(keyData));
        final PrivateKeyInfo pki = PrivateKeyInfo.getInstance(bIn.readObject());
        final String algOid = pki.getPrivateKeyAlgorithm().getAlgorithm().getId();
        return new AlgorithmId(new ObjectIdentifier(algOid)).getName();
    } catch (IOException e) {
        Log.e(TAG, "getAlgorithmFromPKCS8 Failed to parse key data");
        Log.e(TAG, Log.getStackTraceString(e));
        return null;
    }
}
#end_block

#method_before
public boolean importKey(String alias, byte[] keyData, int uid, int flags) {
    String algorithm = getAlgorithmFromPKCS8(keyData);
    if (algorithm == null)
        return false;
    KeymasterArguments args = makeLegacyArguments(algorithm);
    KeyCharacteristics out = new KeyCharacteristics();
    int result = importKey(alias, args, KeymasterDefs.KM_KEY_FORMAT_PKCS8, keyData, uid, flags, out);
    if (result != NO_ERROR) {
        Log.e(TAG, Log.getStackTraceString(new KeyStoreException(result, "legace key import failed")));
        return false;
    }
    return true;
}
#method_after
public boolean importKey(String alias, byte[] keyData, int uid, int flags) {
    String algorithm = getAlgorithmFromPKCS8(keyData);
    if (algorithm == null)
        return false;
    KeymasterArguments args = makeLegacyArguments(algorithm);
    KeyCharacteristics out = new KeyCharacteristics();
    int result = importKey(alias, args, KeymasterDefs.KM_KEY_FORMAT_PKCS8, keyData, uid, flags, out);
    if (result != NO_ERROR) {
        Log.e(TAG, Log.getStackTraceString(new KeyStoreException(result, "legacy key import failed")));
        return false;
    }
    return true;
}
#end_block

#method_before
private String getAlgorithmFromPKCS8(byte[] keyData) {
    try {
        final ASN1InputStream bIn = new ASN1InputStream(new ByteArrayInputStream(keyData));
        final PrivateKeyInfo pki = PrivateKeyInfo.getInstance(bIn.readObject());
        final String algOid = pki.getAlgorithmId().getAlgorithm().getId();
        return new AlgorithmId(new ObjectIdentifier(algOid)).getName();
    } catch (IOException e) {
        Log.e(TAG, "getAlgorithmFromPKCS8 Failed to parse key data");
        Log.e(TAG, Log.getStackTraceString(e));
        return null;
    }
}
#method_after
private String getAlgorithmFromPKCS8(byte[] keyData) {
    try {
        final ASN1InputStream bIn = new ASN1InputStream(new ByteArrayInputStream(keyData));
        final PrivateKeyInfo pki = PrivateKeyInfo.getInstance(bIn.readObject());
        final String algOid = pki.getPrivateKeyAlgorithm().getAlgorithm().getId();
        return new AlgorithmId(new ObjectIdentifier(algOid)).getName();
    } catch (IOException e) {
        Log.e(TAG, "getAlgorithmFromPKCS8 Failed to parse key data");
        Log.e(TAG, Log.getStackTraceString(e));
        return null;
    }
}
#end_block

#method_before
public boolean importKey(String alias, byte[] keyData, int uid, int flags) {
    String algorithm = getAlgorithmFromPKCS8(keyData);
    if (algorithm == null)
        return false;
    KeymasterArguments args = makeLegacyArguments(algorithm);
    KeyCharacteristics out = new KeyCharacteristics();
    int result = importKey(alias, args, KeymasterDefs.KM_KEY_FORMAT_PKCS8, keyData, uid, flags, out);
    if (result != NO_ERROR) {
        Log.e(TAG, Log.getStackTraceString(new KeyStoreException(result, "legace key import failed")));
        return false;
    }
    return true;
}
#method_after
public boolean importKey(String alias, byte[] keyData, int uid, int flags) {
    String algorithm = getAlgorithmFromPKCS8(keyData);
    if (algorithm == null)
        return false;
    KeymasterArguments args = makeLegacyArguments(algorithm);
    KeyCharacteristics out = new KeyCharacteristics();
    int result = importKey(alias, args, KeymasterDefs.KM_KEY_FORMAT_PKCS8, keyData, uid, flags, out);
    if (result != NO_ERROR) {
        Log.e(TAG, Log.getStackTraceString(new KeyStoreException(result, "legacy key import failed")));
        return false;
    }
    return true;
}
#end_block

#method_before
@Test
public void testControllerCallback_onPlaybackInfoChanged_byPlaybackTypeChangeToRemote() throws Exception {
    prepareLooper();
    final int volumeControlType = VolumeProviderCompat.VOLUME_CONTROL_ABSOLUTE;
    final int maxVolume = 100;
    final int currentVolume = 45;
    final CountDownLatch latch = new CountDownLatch(1);
    final ControllerCallback callback = new ControllerCallback() {

        @Override
        public void onPlaybackInfoChanged(MediaController2 controller, MediaController2.PlaybackInfo info) {
            assertEquals(MediaController2.PlaybackInfo.PLAYBACK_TYPE_REMOTE, info.getPlaybackType());
            assertEquals(volumeControlType, info.getControlType());
            assertEquals(maxVolume, info.getMaxVolume());
            assertEquals(currentVolume, info.getCurrentVolume());
            latch.countDown();
        }
    };
    mController = createController(mSession.getSessionToken(), true, callback);
    mSession.setPlaybackToRemote(volumeControlType, maxVolume, currentVolume);
    assertTrue(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
}
#method_after
@Test
public void testControllerCallback_onPlaybackInfoChanged_byPlaybackTypeChangeToRemote() throws Exception {
    prepareLooper();
    final int volumeControlType = VolumeProviderCompat.VOLUME_CONTROL_ABSOLUTE;
    final int maxVolume = 100;
    final int currentVolume = 45;
    final CountDownLatch latch = new CountDownLatch(1);
    final ControllerCallback callback = new ControllerCallback() {

        @Override
        public void onPlaybackInfoChanged(MediaController2 controller, MediaController2.PlaybackInfo info) {
            // Here, we are intentionally avoid using assertEquals(), since this callback
            // can be called many times which of them have inaccurate values.
            Log.d(TAG, "Given playbackType=" + info.getPlaybackType() + " controlType=" + info.getControlType() + " maxVolume=" + info.getMaxVolume() + " currentVolume=" + info.getCurrentVolume() + " audioAttrs=" + info.getAudioAttributes());
            if (MediaController2.PlaybackInfo.PLAYBACK_TYPE_REMOTE == info.getPlaybackType() && volumeControlType == info.getControlType() && maxVolume == info.getMaxVolume() && currentVolume == info.getCurrentVolume()) {
                latch.countDown();
            }
        }
    };
    mController = createController(mSession.getSessionToken(), true, callback);
    mSession.setPlaybackToRemote(volumeControlType, maxVolume, currentVolume);
    assertTrue(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
}
#end_block

#method_before
@Test
public void testRequiresClat() throws Exception {
    final int[] supportedTypes = { ConnectivityManager.TYPE_MOBILE, ConnectivityManager.TYPE_WIFI, ConnectivityManager.TYPE_ETHERNET };
    // NetworkInfo doesn't allow setting the State directly, but rather
    // requires setting DetailedState in order set State as a side-effect.
    final NetworkInfo.DetailedState[] supportedDetailedStates = { NetworkInfo.DetailedState.CONNECTED, NetworkInfo.DetailedState.SUSPENDED };
    for (int type : supportedTypes) {
        mNai.networkInfo.setType(type);
        for (NetworkInfo.DetailedState state : supportedDetailedStates) {
            mNai.networkInfo.setDetailedState(state, "reason", "extraInfo");
            mNai.netMisc().skip464xlat = true;
            assertFalse(String.format("requiresClat expected for type=%d state=%s skip464xlat=%b", type, state, mNai.netMisc().skip464xlat), Nat464Xlat.requiresClat(mNai));
            mNai.netMisc().skip464xlat = false;
            assertTrue(String.format("requiresClat expected for type=%d state=%s skip464xlat=%b", type, state, mNai.netMisc().skip464xlat), Nat464Xlat.requiresClat(mNai));
        }
    }
}
#method_after
@Test
public void testRequiresClat() throws Exception {
    final int[] supportedTypes = { ConnectivityManager.TYPE_MOBILE, ConnectivityManager.TYPE_WIFI, ConnectivityManager.TYPE_ETHERNET };
    // NetworkInfo doesn't allow setting the State directly, but rather
    // requires setting DetailedState in order set State as a side-effect.
    final NetworkInfo.DetailedState[] supportedDetailedStates = { NetworkInfo.DetailedState.CONNECTED, NetworkInfo.DetailedState.SUSPENDED };
    for (int type : supportedTypes) {
        mNai.networkInfo.setType(type);
        for (NetworkInfo.DetailedState state : supportedDetailedStates) {
            mNai.networkInfo.setDetailedState(state, "reason", "extraInfo");
            String msg = String.format("requiresClat expected for type=%d state=%s", type, state);
            mMisc.skip464xlat = true;
            String errorMsg = msg + String.format(" skip464xlat=%b", mMisc.skip464xlat);
            assertFalse(errorMsg, Nat464Xlat.requiresClat(mNai));
            mMisc.skip464xlat = false;
            errorMsg = msg + String.format(" skip464xlat=%b", mMisc.skip464xlat);
            assertTrue(errorMsg, Nat464Xlat.requiresClat(mNai));
        }
    }
}
#end_block

#method_before
@Override
public void onPause() {
    synchronized (mLock) {
        mResumeWhenAudioFocusGain = false;
        unregisterReceiverLocked();
    }
}
#method_after
@Override
public void onPause() {
    synchronized (mLock) {
        mResumeWhenAudioFocusGain = false;
        unregisterBecomingNoisyReceiverLocked();
    }
}
#end_block

#method_before
@Override
public void onReset() {
    synchronized (mLock) {
        abandonAudioFocusLocked();
        unregisterReceiverLocked();
    }
}
#method_after
@Override
public void onReset() {
    synchronized (mLock) {
        abandonAudioFocusLocked();
        unregisterBecomingNoisyReceiverLocked();
    }
}
#end_block

#method_before
@Override
public void close() {
    synchronized (mLock) {
        unregisterReceiverLocked();
        abandonAudioFocusLocked();
    }
}
#method_after
@Override
public void close() {
    synchronized (mLock) {
        unregisterBecomingNoisyReceiverLocked();
        abandonAudioFocusLocked();
    }
}
#end_block

#method_before
@Override
public void sendIntent(Intent intent) {
    mBecomingNoisyIntentReceiver.onReceive(mContext, intent);
}
#method_after
@Override
public void sendIntent(Intent intent) {
    mBecomingNoisyReceiver.onReceive(mContext, intent);
}
#end_block

#method_before
// This is the thread where the AudioManager was originally instantiated.
@Override
public void onAudioFocusChange(int focusGain) {
    switch(focusGain) {
        case AudioManager.AUDIOFOCUS_GAIN:
            // Regains focus after the LOSS_TRANSIENT or LOSS_TRANSIENT_CAN_DUCK.
            if (mPlayer.getPlayerState() == PLAYER_STATE_PAUSED) {
                // Note: onPlayRequested() will be called again with this.
                synchronized (mLock) {
                    if (!mResumeWhenAudioFocusGain) {
                        break;
                    }
                }
                mPlayer.play();
            } else {
                // Resets the volume if the user didn't change it.
                final float currentVolume = mPlayer.getPlayerVolume();
                final float volumeBeforeDucking;
                synchronized (mLock) {
                    if (currentVolume != mPlayerDuckingVolume) {
                        // User manually changed the volume meanwhile. Don't reset.
                        break;
                    }
                    volumeBeforeDucking = mPlayerVolumeBeforeDucking;
                }
                mPlayer.setPlayerVolume(volumeBeforeDucking);
            }
            break;
        case AudioManager.AUDIOFOCUS_LOSS:
            // Audio-focus developer guide says 'Your app should pause playback
            // immediately, as it won't ever receive an AUDIOFOCUS_GAIN callback'.
            // Audio focus will be abandoned in XMediaPlayer#pause() will abandon audio
            // focus.
            mPlayer.pause();
            // Don't resume even after you regain the audio focus.
            synchronized (mLock) {
                mResumeWhenAudioFocusGain = false;
            }
            break;
        case AudioManager.AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK:
            final boolean pause;
            synchronized (mLock) {
                if (mAudioAttributes == null) {
                    // This shouldn't happen. Just ignoring for now.
                    break;
                }
                pause = (mAudioAttributes.getContentType() == AudioAttributesCompat.CONTENT_TYPE_SPEECH);
            }
            if (pause) {
                mPlayer.pause();
            } else {
                // Lower the volume by the factor
                final float currentVolume = mPlayer.getPlayerVolume();
                final float duckingVolume = currentVolume * VOLUME_DUCK_FACTOR;
                synchronized (mLock) {
                    mPlayerVolumeBeforeDucking = currentVolume;
                    mPlayerDuckingVolume = duckingVolume;
                }
                mPlayer.setPlayerVolume(duckingVolume);
            }
            break;
        case AudioManager.AUDIOFOCUS_LOSS_TRANSIENT:
            mPlayer.pause();
            // Resume after regaining the audio focus.
            synchronized (mLock) {
                mResumeWhenAudioFocusGain = true;
            }
            break;
    }
}
#method_after
// This is the thread where the AudioManager was originally instantiated.
@Override
public void onAudioFocusChange(int focusGain) {
    switch(focusGain) {
        case AudioManager.AUDIOFOCUS_GAIN:
            // Regains focus after the LOSS_TRANSIENT or LOSS_TRANSIENT_CAN_DUCK.
            if (mPlayer.getPlayerState() == PLAYER_STATE_PAUSED) {
                // Note: onPlay() will be called again with this.
                synchronized (mLock) {
                    if (!mResumeWhenAudioFocusGain) {
                        break;
                    }
                }
                mPlayer.play();
            } else {
                // Resets the volume if the user didn't change it.
                final float currentVolume = mPlayer.getPlayerVolume();
                final float volumeBeforeDucking;
                synchronized (mLock) {
                    if (currentVolume != mPlayerDuckingVolume) {
                        // User manually changed the volume meanwhile. Don't reset.
                        break;
                    }
                    volumeBeforeDucking = mPlayerVolumeBeforeDucking;
                }
                mPlayer.setPlayerVolume(volumeBeforeDucking);
            }
            break;
        case AudioManager.AUDIOFOCUS_LOSS:
            // Audio-focus developer guide says 'Your app should pause playback
            // immediately, as it won't ever receive an AUDIOFOCUS_GAIN callback'.
            mPlayer.pause();
            // Don't resume even after you regain the audio focus.
            synchronized (mLock) {
                mResumeWhenAudioFocusGain = false;
            }
            break;
        case AudioManager.AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK:
            final boolean pause;
            synchronized (mLock) {
                if (mAudioAttributes == null) {
                    // This shouldn't happen. Just ignoring for now.
                    break;
                }
                pause = (mAudioAttributes.getContentType() == AudioAttributesCompat.CONTENT_TYPE_SPEECH);
            }
            if (pause) {
                mPlayer.pause();
            } else {
                // Lower the volume by the factor
                final float currentVolume = mPlayer.getPlayerVolume();
                final float duckingVolume = currentVolume * VOLUME_DUCK_FACTOR;
                synchronized (mLock) {
                    mPlayerVolumeBeforeDucking = currentVolume;
                    mPlayerDuckingVolume = duckingVolume;
                }
                mPlayer.setPlayerVolume(duckingVolume);
            }
            break;
        case AudioManager.AUDIOFOCUS_LOSS_TRANSIENT:
            mPlayer.pause();
            // Resume after regaining the audio focus.
            synchronized (mLock) {
                mResumeWhenAudioFocusGain = true;
            }
            break;
    }
}
#end_block

#method_before
private static List<Runner> constructClassRunners(Class<?> suite, RunnerBuilder builder, Bundle args) throws InitializationError {
    // TODO(b/118340229): Refactor to share logic with base class. In the meanwhile, keep the
    // logic here in sync with the base class.
    // Retrieve annotated suite classes.
    SuiteClasses annotation = suite.getAnnotation(SuiteClasses.class);
    if (annotation == null) {
        throw new InitializationError(String.format("Longevity suite, '%s', must have a SuiteClasses annotation", suite.getName()));
    }
    // Construct and store custom runners for the full suite.
    BiFunction<Bundle, List<Runner>, List<Runner>> modifier = new Iterate<Runner>().andThen(new Shuffle<Runner>()).andThen(new Profile());
    return modifier.apply(args, builder.runners(suite, annotation.value()));
}
#method_after
private static List<Runner> constructClassRunners(Class<?> suite, RunnerBuilder builder, Bundle args) throws InitializationError {
    // TODO(b/118340229): Refactor to share logic with base class. In the meanwhile, keep the
    // logic here in sync with the base class.
    // Retrieve annotated suite classes.
    SuiteClasses annotation = suite.getAnnotation(SuiteClasses.class);
    if (annotation == null) {
        throw new InitializationError(String.format("Longevity suite, '%s', must have a SuiteClasses annotation", suite.getName()));
    }
    // Construct and store custom runners for the full suite.
    BiFunction<Bundle, List<Runner>, List<Runner>> modifier = new Iterate<Runner>().andThen(new Shuffle<Runner>()).andThen(new Profile(args));
    return modifier.apply(args, builder.runners(suite, annotation.value()));
}
#end_block

#method_before
@Override
public void run(final RunNotifier notifier) {
    Log.v(LOG_TAG, "Running tests...");
    // Register the battery terminator available only on the platform library, if present.
    if (hasBattery()) {
        notifier.addListener(new BatteryTerminator(notifier, mArguments, mContext));
    }
    // Sleep until the first scheduled test starts.
    if (!mProfile.allScenariosDone()) {
        SystemClock.sleep(mProfile.getMillisecondsUntilNextScenario());
    }
    // Register other listeners and continue with standard longevity run.
    super.run(notifier);
}
#method_after
@Override
public void run(final RunNotifier notifier) {
    // Register the battery terminator available only on the platform library, if present.
    if (hasBattery()) {
        notifier.addListener(new BatteryTerminator(notifier, mArguments, mContext));
    }
    // no sleep is performed.
    if (mProfile.hasNextScheduledScenario()) {
        mProfile.setTestRunStartTimeMillis(System.currentTimeMillis());
        SystemClock.sleep(mProfile.getMillisecondsUntilNextScenario());
    }
    // Register other listeners and continue with standard longevity run.
    super.run(notifier);
}
#end_block

#method_before
@Override
protected void runChild(Runner runner, final RunNotifier notifier) {
    Log.v(LOG_TAG, String.format("Running test %s.", runner.getDescription().getDisplayName()));
    super.runChild(runner, notifier);
    mProfile.scenarioEnded();
    if (!mProfile.allScenariosDone()) {
        SystemClock.sleep(mProfile.getMillisecondsUntilNextScenario());
    }
}
#method_after
@Override
protected void runChild(Runner runner, final RunNotifier notifier) {
    super.runChild(runner, notifier);
    mProfile.scenarioEnded();
    // When no profile is supplied, allScenariosDone() returns true and no sleep is performed.
    if (mProfile.hasNextScheduledScenario()) {
        SystemClock.sleep(mProfile.getMillisecondsUntilNextScenario());
    }
}
#end_block

#method_before
protected List<Runner> getTestSequenceFromConfiguration(Configuration config, List<Runner> input) {
    Map<String, Runner> nameToRunner = input.stream().collect(Collectors.toMap(r -> r.getDescription().getDisplayName(), Function.identity()));
    logInfo(LOG_TAG, String.format("Available journeys: %s", nameToRunner.keySet().stream().collect(Collectors.joining(", "))));
    loadScenariosListFromConfiguration(config);
    List<Runner> result = mScenariosList.stream().map(Configuration.Scenario::getJourney).map(journeyName -> {
        if (nameToRunner.containsKey(journeyName)) {
            return nameToRunner.get(journeyName);
        } else {
            throw new IllegalArgumentException(String.format("Journey %s in profile does not exist. " + "Use 'adb logcat %s:V *:S' to see " + "available journeys.", journeyName, LOG_TAG));
        }
    }).collect(Collectors.toList());
    logInfo(LOG_TAG, String.format("Returned runners: %s", result.stream().map(Runner::getDescription).map(Description::getDisplayName).collect(Collectors.toList())));
    return result;
}
#method_after
protected List<Runner> getTestSequenceFromConfiguration(Configuration config, List<Runner> input) {
    Map<String, Runner> nameToRunner = input.stream().collect(Collectors.toMap(r -> r.getDescription().getDisplayName(), Function.identity()));
    logInfo(LOG_TAG, String.format("Available journeys: %s", nameToRunner.keySet().stream().collect(Collectors.joining(", "))));
    List<Runner> result = mOrderedScenariosList.stream().map(Configuration.Scenario::getJourney).map(journeyName -> {
        if (nameToRunner.containsKey(journeyName)) {
            return nameToRunner.get(journeyName);
        } else {
            throw new IllegalArgumentException(String.format("Journey %s in profile not found. " + "Check logcat to see available journeys.", journeyName));
        }
    }).collect(Collectors.toList());
    logInfo(LOG_TAG, String.format("Returned runners: %s", result.stream().map(Runner::getDescription).map(Description::getDisplayName).collect(Collectors.toList())));
    return result;
}
#end_block

#method_before
public long getMillisecondsUntilNextScenario() {
    Scenario nextScenario = mScenariosList.get(mScenarioIndex);
    if (nextScenario.hasAt()) {
        try {
            long startTimeMillis = TIMESTAMP_FORMATTER.parse(nextScenario.getAt()).getTime();
            // Time in milliseconds from the start of the test run to the current point in time.
            long currentTimeMillis = System.currentTimeMillis() - mRunStartTimeMillis;
            // TODO(b/118495360): Deal with the IfLate situation.
            if (startTimeMillis > currentTimeMillis) {
                return startTimeMillis - currentTimeMillis;
            }
        } catch (ParseException e) {
            throw new IllegalArgumentException(String.format("Time %s from scenario %s could not be parsed", nextScenario.getAt(), nextScenario.getJourney()));
        }
    }
    // For non-scheduled profiles (not a priority at this point), simply return 0.
    return 0L;
}
#method_after
public long getMillisecondsUntilNextScenario() {
    Scenario nextScenario = mOrderedScenariosList.get(mScenarioIndex);
    if (nextScenario.hasAt()) {
        try {
            long startTimeMillis = TIMESTAMP_FORMATTER.parse(nextScenario.getAt()).getTime();
            // Time in milliseconds from the start of the test run to the current point in time.
            long currentTimeMillis = System.currentTimeMillis() - mRunStartTimeMillis;
            // TODO(b/118495360): Deal with the IfLate situation.
            if (startTimeMillis > currentTimeMillis) {
                return startTimeMillis - currentTimeMillis;
            }
        } catch (ParseException e) {
            throw new IllegalArgumentException(String.format("Time %s from scenario %s could not be parsed", nextScenario.getAt(), nextScenario.getJourney()));
        }
    }
    // For non-scheduled profiles (not a priority at this point), simply return 0.
    return 0L;
}
#end_block

#method_before
@Test
@SdkSuppress(minSdkVersion = 23)
public void testParams_equals() {
    final Params base = new Params.Builder(PAINT).setBreakStrategy(Layout.BREAK_STRATEGY_HIGH_QUALITY).setHyphenationFrequency(Layout.HYPHENATION_FREQUENCY_NORMAL).setTextDirection(LTR).build();
    assertFalse(base.equals(null));
    assertTrue(base.equals(base));
    assertFalse(base.equals(new Object()));
    Params other = new Params.Builder(PAINT).setBreakStrategy(Layout.BREAK_STRATEGY_HIGH_QUALITY).setHyphenationFrequency(Layout.HYPHENATION_FREQUENCY_NORMAL).setTextDirection(LTR).build();
    assertTrue(base.equals(other));
    assertTrue(base.equalsWithoutTextDirection(other));
    assertTrue(other.equals(base));
    assertTrue(other.equalsWithoutTextDirection(base));
    assertEquals(base.hashCode(), other.hashCode());
    other = new Params.Builder(PAINT).setBreakStrategy(Layout.BREAK_STRATEGY_SIMPLE).setHyphenationFrequency(Layout.HYPHENATION_FREQUENCY_NORMAL).setTextDirection(LTR).build();
    assertFalse(base.equals(other));
    assertFalse(base.equalsWithoutTextDirection(other));
    assertFalse(other.equals(base));
    assertFalse(other.equalsWithoutTextDirection(base));
    other = new Params.Builder(PAINT).setBreakStrategy(Layout.BREAK_STRATEGY_HIGH_QUALITY).setHyphenationFrequency(Layout.HYPHENATION_FREQUENCY_NONE).setTextDirection(LTR).build();
    assertFalse(base.equals(other));
    assertFalse(base.equalsWithoutTextDirection(other));
    assertFalse(other.equals(base));
    assertFalse(other.equalsWithoutTextDirection(base));
    other = new Params.Builder(PAINT).setBreakStrategy(Layout.BREAK_STRATEGY_HIGH_QUALITY).setHyphenationFrequency(Layout.HYPHENATION_FREQUENCY_NORMAL).setTextDirection(RTL).build();
    assertFalse(base.equals(other));
    assertTrue(base.equalsWithoutTextDirection(other));
    assertFalse(other.equals(base));
    assertTrue(other.equalsWithoutTextDirection(base));
    TextPaint anotherPaint = new TextPaint(PAINT);
    anotherPaint.setTextSize(PAINT.getTextSize() * 2.0f);
    other = new Params.Builder(anotherPaint).setBreakStrategy(Layout.BREAK_STRATEGY_HIGH_QUALITY).setHyphenationFrequency(Layout.HYPHENATION_FREQUENCY_NORMAL).setTextDirection(LTR).build();
    assertFalse(base.equals(other));
    assertFalse(base.equalsWithoutTextDirection(other));
    assertFalse(other.equals(base));
    assertFalse(other.equalsWithoutTextDirection(base));
}
#method_after
@Test
@SdkSuppress(minSdkVersion = 23)
public void testParams_equals() {
    final Params base = new Params.Builder(PAINT).setBreakStrategy(Layout.BREAK_STRATEGY_HIGH_QUALITY).setHyphenationFrequency(Layout.HYPHENATION_FREQUENCY_NORMAL).setTextDirection(LTR).build();
    assertFalse(base.equals(null));
    assertTrue(base.equals(base));
    assertFalse(base.equals(new Object()));
    Params other = new Params.Builder(PAINT).setBreakStrategy(Layout.BREAK_STRATEGY_HIGH_QUALITY).setHyphenationFrequency(Layout.HYPHENATION_FREQUENCY_NORMAL).setTextDirection(LTR).build();
    assertTrue(base.equals(other));
    assertTrue(other.equals(base));
    assertEquals(base.hashCode(), other.hashCode());
    other = new Params.Builder(PAINT).setBreakStrategy(Layout.BREAK_STRATEGY_SIMPLE).setHyphenationFrequency(Layout.HYPHENATION_FREQUENCY_NORMAL).setTextDirection(LTR).build();
    assertFalse(base.equals(other));
    assertFalse(other.equals(base));
    other = new Params.Builder(PAINT).setBreakStrategy(Layout.BREAK_STRATEGY_HIGH_QUALITY).setHyphenationFrequency(Layout.HYPHENATION_FREQUENCY_NONE).setTextDirection(LTR).build();
    assertFalse(base.equals(other));
    assertFalse(other.equals(base));
    other = new Params.Builder(PAINT).setBreakStrategy(Layout.BREAK_STRATEGY_HIGH_QUALITY).setHyphenationFrequency(Layout.HYPHENATION_FREQUENCY_NORMAL).setTextDirection(RTL).build();
    assertFalse(base.equals(other));
    assertFalse(other.equals(base));
    TextPaint anotherPaint = new TextPaint(PAINT);
    anotherPaint.setTextSize(PAINT.getTextSize() * 2.0f);
    other = new Params.Builder(anotherPaint).setBreakStrategy(Layout.BREAK_STRATEGY_HIGH_QUALITY).setHyphenationFrequency(Layout.HYPHENATION_FREQUENCY_NORMAL).setTextDirection(LTR).build();
    assertFalse(base.equals(other));
    assertFalse(other.equals(base));
}
#end_block

#method_before
@Test
public void testParams_equals2() {
    final Params base = new Params.Builder(PAINT).build();
    assertFalse(base.equals(null));
    assertTrue(base.equals(base));
    assertFalse(base.equals(new Object()));
    Params other = new Params.Builder(PAINT).build();
    assertTrue(base.equals(other));
    assertTrue(base.equalsWithoutTextDirection(other));
    assertTrue(other.equals(base));
    assertTrue(other.equalsWithoutTextDirection(base));
    assertEquals(base.hashCode(), other.hashCode());
    TextPaint paint = new TextPaint(PAINT);
    paint.setTextSize(paint.getTextSize() * 2.0f + 1.0f);
    other = new Params.Builder(paint).build();
    assertFalse(base.equals(other));
    assertFalse(base.equalsWithoutTextDirection(other));
    assertFalse(other.equals(base));
    assertFalse(other.equalsWithoutTextDirection(base));
}
#method_after
@Test
public void testParams_equals2() {
    final Params base = new Params.Builder(PAINT).build();
    assertFalse(base.equals(null));
    assertTrue(base.equals(base));
    assertFalse(base.equals(new Object()));
    Params other = new Params.Builder(PAINT).build();
    assertTrue(base.equals(other));
    assertTrue(other.equals(base));
    assertEquals(base.hashCode(), other.hashCode());
    TextPaint paint = new TextPaint(PAINT);
    paint.setTextSize(paint.getTextSize() * 2.0f + 1.0f);
    other = new Params.Builder(paint).build();
    assertFalse(base.equals(other));
    assertFalse(other.equals(base));
}
#end_block

#method_before
@Test
@LargeTest
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.KITKAT)
public void testVideoSurfaceResetting() throws Exception {
    final int tolerance = 150;
    final int audioLatencyTolerance = 1000;
    /* covers audio path latency variability */
    // This is the I-frame position
    final int seekPos = 4760;
    final CountDownLatch seekDone = new CountDownLatch(1);
    MediaPlayer2.EventCallback ecb = new MediaPlayer2.EventCallback() {

        @Override
        public void onCallCompleted(MediaPlayer2 mp, MediaItem2 item, int what, int status) {
            if (what == MediaPlayer2.CALL_COMPLETED_SEEK_TO) {
                seekDone.countDown();
            }
        }
    };
    synchronized (mEventCbLock) {
        mEventCallbacks.add(ecb);
    }
    if (!checkLoadResource(R.raw.testvideoh264)) {
        // skip;
        return;
    }
    playLoadedVideo(352, 288, -1);
    Thread.sleep(SLEEP_TIME);
    long posBefore = mPlayer.getCurrentPosition();
    mPlayer.setSurface(mActivity.getSurfaceHolder2().getSurface());
    long posAfter = mPlayer.getCurrentPosition();
    /* temporarily disable timestamp checking because MediaPlayer2 now seeks to I-frame
         * position, instead of requested position. setDisplay invovles a seek operation
         * internally.
         */
    // TODO: uncomment out line below when MediaPlayer2 can seek to requested position.
    // assertEquals(posAfter, posBefore, tolerance);
    assertTrue(mPlayer.getState() == MediaPlayer2.PLAYER_STATE_PLAYING);
    Thread.sleep(SLEEP_TIME);
    mPlayer.seekTo(seekPos, MediaPlayer2.SEEK_PREVIOUS_SYNC);
    seekDone.await();
    posAfter = mPlayer.getCurrentPosition();
    assertEquals(seekPos, posAfter, tolerance + audioLatencyTolerance);
    Thread.sleep(SLEEP_TIME / 2);
    posBefore = mPlayer.getCurrentPosition();
    mPlayer.setSurface(null);
    posAfter = mPlayer.getCurrentPosition();
    // TODO: uncomment out line below when MediaPlayer2 can seek to requested position.
    // assertEquals(posAfter, posBefore, tolerance);
    assertTrue(mPlayer.getState() == MediaPlayer2.PLAYER_STATE_PLAYING);
    Thread.sleep(SLEEP_TIME);
    posBefore = mPlayer.getCurrentPosition();
    mPlayer.setSurface(mActivity.getSurfaceHolder().getSurface());
    posAfter = mPlayer.getCurrentPosition();
    // TODO: uncomment out line below when MediaPlayer2 can seek to requested position.
    // assertEquals(posAfter, posBefore, tolerance);
    assertTrue(mPlayer.getState() == MediaPlayer2.PLAYER_STATE_PLAYING);
    Thread.sleep(SLEEP_TIME);
}
#method_after
@Test
@LargeTest
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.KITKAT)
public void testVideoSurfaceResetting() throws Exception {
    final int tolerance = 150;
    final int audioLatencyTolerance = 1000;
    /* covers audio path latency variability */
    // This is the I-frame position
    final int seekPos = 1840;
    final CountDownLatch seekDone = new CountDownLatch(1);
    MediaPlayer2.EventCallback ecb = new MediaPlayer2.EventCallback() {

        @Override
        public void onCallCompleted(MediaPlayer2 mp, MediaItem2 item, int what, int status) {
            if (what == MediaPlayer2.CALL_COMPLETED_SEEK_TO) {
                seekDone.countDown();
            }
        }
    };
    synchronized (mEventCbLock) {
        mEventCallbacks.add(ecb);
    }
    if (!checkLoadResource(R.raw.video_480x360_mp4_h264_500kbps_25fps_aac_stereo_128kbps_44100hz)) {
        // skip;
        return;
    }
    playLoadedVideo(480, 360, -1);
    Thread.sleep(SLEEP_TIME);
    long posBefore = mPlayer.getCurrentPosition();
    mPlayer.setSurface(mActivity.getSurfaceHolder2().getSurface());
    long posAfter = mPlayer.getCurrentPosition();
    /* temporarily disable timestamp checking because MediaPlayer2 now seeks to I-frame
         * position, instead of requested position. setDisplay invovles a seek operation
         * internally.
         */
    // TODO: uncomment out line below when MediaPlayer2 can seek to requested position.
    // assertEquals(posAfter, posBefore, tolerance);
    assertTrue(mPlayer.getState() == MediaPlayer2.PLAYER_STATE_PLAYING);
    Thread.sleep(SLEEP_TIME);
    mPlayer.seekTo(seekPos, MediaPlayer2.SEEK_PREVIOUS_SYNC);
    seekDone.await();
    posAfter = mPlayer.getCurrentPosition();
    assertEquals(seekPos, posAfter, tolerance + audioLatencyTolerance);
    Thread.sleep(SLEEP_TIME / 2);
    posBefore = mPlayer.getCurrentPosition();
    mPlayer.setSurface(null);
    posAfter = mPlayer.getCurrentPosition();
    // TODO: uncomment out line below when MediaPlayer2 can seek to requested position.
    // assertEquals(posAfter, posBefore, tolerance);
    assertTrue(mPlayer.getState() == MediaPlayer2.PLAYER_STATE_PLAYING);
    Thread.sleep(SLEEP_TIME);
    posBefore = mPlayer.getCurrentPosition();
    mPlayer.setSurface(mActivity.getSurfaceHolder().getSurface());
    posAfter = mPlayer.getCurrentPosition();
    // TODO: uncomment out line below when MediaPlayer2 can seek to requested position.
    // assertEquals(posAfter, posBefore, tolerance);
    assertTrue(mPlayer.getState() == MediaPlayer2.PLAYER_STATE_PLAYING);
    Thread.sleep(SLEEP_TIME);
}
#end_block

#method_before
public static long TestInt(int... values) {
    crc32.reset();
    for (int value : values) {
        crc32.update(value);
    }
    return crc32.getValue();
}
#method_after
public static long TestInt(int value) {
    crc32.reset();
    crc32.update(value);
    return crc32.getValue();
}
#end_block

#method_before
public static void main(String[] args) {
    // public void update(int b)
    // 
    // Tests for checksums of the byte 0x0
    assertEqual(0xD202EF8DL, TestInt(0x0));
    assertEqual(0xD202EF8DL, TestInt(0x0100));
    assertEqual(0xD202EF8DL, TestInt(0x010000));
    assertEqual(0xD202EF8DL, TestInt(0x01000000));
    assertEqual(0xD202EF8DL, TestInt(0xff00));
    assertEqual(0xD202EF8DL, TestInt(0xffff00));
    assertEqual(0xD202EF8DL, TestInt(0xffffff00));
    assertEqual(0xD202EF8DL, TestInt(0x1200));
    assertEqual(0xD202EF8DL, TestInt(0x123400));
    assertEqual(0xD202EF8DL, TestInt(0x12345600));
    assertEqual(0xD202EF8DL, TestInt(Integer.MIN_VALUE));
    // Tests for checksums of the byte 0x1
    assertEqual(0xA505DF1BL, TestInt(0x1));
    assertEqual(0xA505DF1BL, TestInt(0x0101));
    assertEqual(0xA505DF1BL, TestInt(0x010001));
    assertEqual(0xA505DF1BL, TestInt(0x01000001));
    assertEqual(0xA505DF1BL, TestInt(0xff01));
    assertEqual(0xA505DF1BL, TestInt(0xffff01));
    assertEqual(0xA505DF1BL, TestInt(0xffffff01));
    assertEqual(0xA505DF1BL, TestInt(0x1201));
    assertEqual(0xA505DF1BL, TestInt(0x123401));
    assertEqual(0xA505DF1BL, TestInt(0x12345601));
    // Tests for checksums of the byte 0x0f
    assertEqual(0x42BDF21CL, TestInt(0x0f));
    assertEqual(0x42BDF21CL, TestInt(0x010f));
    assertEqual(0x42BDF21CL, TestInt(0x01000f));
    assertEqual(0x42BDF21CL, TestInt(0x0100000f));
    assertEqual(0x42BDF21CL, TestInt(0xff0f));
    assertEqual(0x42BDF21CL, TestInt(0xffff0f));
    assertEqual(0x42BDF21CL, TestInt(0xffffff0f));
    assertEqual(0x42BDF21CL, TestInt(0x120f));
    assertEqual(0x42BDF21CL, TestInt(0x12340f));
    assertEqual(0x42BDF21CL, TestInt(0x1234560f));
    // Tests for checksums of the bute 0xff
    assertEqual(0xFF000000L, TestInt(0x00ff));
    assertEqual(0xFF000000L, TestInt(0x01ff));
    assertEqual(0xFF000000L, TestInt(0x0100ff));
    assertEqual(0xFF000000L, TestInt(0x010000ff));
    assertEqual(0xFF000000L, TestInt(0x0000ffff));
    assertEqual(0xFF000000L, TestInt(0x00ffffff));
    assertEqual(0xFF000000L, TestInt(0xffffffff));
    assertEqual(0xFF000000L, TestInt(0x12ff));
    assertEqual(0xFF000000L, TestInt(0x1234ff));
    assertEqual(0xFF000000L, TestInt(0x123456ff));
    assertEqual(0xFF000000L, TestInt(Integer.MAX_VALUE));
    // Tests for sequences
    assertEqual(0xFF41D912L, TestInt(0, 0, 0));
    assertEqual(0xFF41D912L, TestInt(0x0100, 0x010000, 0x01000000));
    assertEqual(0xFF41D912L, TestInt(0xff00, 0xffff00, 0xffffff00));
    assertEqual(0xFF41D912L, TestInt(0x1200, 0x123400, 0x12345600));
    assertEqual(0x909FB2F2L, TestInt(1, 1, 1));
    assertEqual(0x909FB2F2L, TestInt(0x0101, 0x010001, 0x01000001));
    assertEqual(0x909FB2F2L, TestInt(0xff01, 0xffff01, 0xffffff01));
    assertEqual(0x909FB2F2L, TestInt(0x1201, 0x123401, 0x12345601));
    assertEqual(0xE33A9F71L, TestInt(0x0f, 0x0f, 0x0f));
    assertEqual(0xE33A9F71L, TestInt(0x010f, 0x01000f, 0x0100000f));
    assertEqual(0xE33A9F71L, TestInt(0xff0f, 0xffff0f, 0xffffff0f));
    assertEqual(0xE33A9F71L, TestInt(0x120f, 0x12340f, 0x1234560f));
    assertEqual(0xFFFFFF00L, TestInt(0x0ff, 0x0ff, 0x0ff));
    assertEqual(0xFFFFFF00L, TestInt(0x01ff, 0x0100ff, 0x010000ff));
    assertEqual(0xFFFFFF00L, TestInt(0x00ffff, 0x00ffffff, 0xffffffff));
    assertEqual(0xFFFFFF00L, TestInt(0x12ff, 0x1234ff, 0x123456ff));
    assertEqual(0xB6CC4292L, TestInt(0x01, 0x02));
    assertEqual(0xB2DE047CL, TestInt(0x0, -1, Integer.MIN_VALUE, Integer.MAX_VALUE));
}
#method_after
public static void main(String[] args) {
    // public void update(int b)
    // 
    // Tests for checksums of the byte 0x0
    assertEqual(0xD202EF8DL, TestInt(0x0));
    assertEqual(0xD202EF8DL, TestInt(0x0100));
    assertEqual(0xD202EF8DL, TestInt(0x010000));
    assertEqual(0xD202EF8DL, TestInt(0x01000000));
    assertEqual(0xD202EF8DL, TestInt(0xff00));
    assertEqual(0xD202EF8DL, TestInt(0xffff00));
    assertEqual(0xD202EF8DL, TestInt(0xffffff00));
    assertEqual(0xD202EF8DL, TestInt(0x1200));
    assertEqual(0xD202EF8DL, TestInt(0x123400));
    assertEqual(0xD202EF8DL, TestInt(0x12345600));
    assertEqual(0xD202EF8DL, TestInt(Integer.MIN_VALUE));
    // Tests for checksums of the byte 0x1
    assertEqual(0xA505DF1BL, TestInt(0x1));
    assertEqual(0xA505DF1BL, TestInt(0x0101));
    assertEqual(0xA505DF1BL, TestInt(0x010001));
    assertEqual(0xA505DF1BL, TestInt(0x01000001));
    assertEqual(0xA505DF1BL, TestInt(0xff01));
    assertEqual(0xA505DF1BL, TestInt(0xffff01));
    assertEqual(0xA505DF1BL, TestInt(0xffffff01));
    assertEqual(0xA505DF1BL, TestInt(0x1201));
    assertEqual(0xA505DF1BL, TestInt(0x123401));
    assertEqual(0xA505DF1BL, TestInt(0x12345601));
    // Tests for checksums of the byte 0x0f
    assertEqual(0x42BDF21CL, TestInt(0x0f));
    assertEqual(0x42BDF21CL, TestInt(0x010f));
    assertEqual(0x42BDF21CL, TestInt(0x01000f));
    assertEqual(0x42BDF21CL, TestInt(0x0100000f));
    assertEqual(0x42BDF21CL, TestInt(0xff0f));
    assertEqual(0x42BDF21CL, TestInt(0xffff0f));
    assertEqual(0x42BDF21CL, TestInt(0xffffff0f));
    assertEqual(0x42BDF21CL, TestInt(0x120f));
    assertEqual(0x42BDF21CL, TestInt(0x12340f));
    assertEqual(0x42BDF21CL, TestInt(0x1234560f));
    // Tests for checksums of the byte 0xff
    assertEqual(0xFF000000L, TestInt(0x00ff));
    assertEqual(0xFF000000L, TestInt(0x01ff));
    assertEqual(0xFF000000L, TestInt(0x0100ff));
    assertEqual(0xFF000000L, TestInt(0x010000ff));
    assertEqual(0xFF000000L, TestInt(0x0000ffff));
    assertEqual(0xFF000000L, TestInt(0x00ffffff));
    assertEqual(0xFF000000L, TestInt(0xffffffff));
    assertEqual(0xFF000000L, TestInt(0x12ff));
    assertEqual(0xFF000000L, TestInt(0x1234ff));
    assertEqual(0xFF000000L, TestInt(0x123456ff));
    assertEqual(0xFF000000L, TestInt(Integer.MAX_VALUE));
    // Tests for sequences
    assertEqual(0xFF41D912L, TestInt(0, 0, 0));
    assertEqual(0xFF41D912L, TestInt(0x0100, 0x010000, 0x01000000));
    assertEqual(0xFF41D912L, TestInt(0xff00, 0xffff00, 0xffffff00));
    assertEqual(0xFF41D912L, TestInt(0x1200, 0x123400, 0x12345600));
    assertEqual(0x909FB2F2L, TestInt(1, 1, 1));
    assertEqual(0x909FB2F2L, TestInt(0x0101, 0x010001, 0x01000001));
    assertEqual(0x909FB2F2L, TestInt(0xff01, 0xffff01, 0xffffff01));
    assertEqual(0x909FB2F2L, TestInt(0x1201, 0x123401, 0x12345601));
    assertEqual(0xE33A9F71L, TestInt(0x0f, 0x0f, 0x0f));
    assertEqual(0xE33A9F71L, TestInt(0x010f, 0x01000f, 0x0100000f));
    assertEqual(0xE33A9F71L, TestInt(0xff0f, 0xffff0f, 0xffffff0f));
    assertEqual(0xE33A9F71L, TestInt(0x120f, 0x12340f, 0x1234560f));
    assertEqual(0xFFFFFF00L, TestInt(0x0ff, 0x0ff, 0x0ff));
    assertEqual(0xFFFFFF00L, TestInt(0x01ff, 0x0100ff, 0x010000ff));
    assertEqual(0xFFFFFF00L, TestInt(0x00ffff, 0x00ffffff, 0xffffffff));
    assertEqual(0xFFFFFF00L, TestInt(0x12ff, 0x1234ff, 0x123456ff));
    assertEqual(0xB6CC4292L, TestInt(0x01, 0x02));
    assertEqual(0xB2DE047CL, TestInt(0x0, -1, Integer.MIN_VALUE, Integer.MAX_VALUE));
}
#end_block

#method_before
@Override
public void setDefaultValues() {
    mRssi = SIGNAL_STRENGTH_LTE_RSSI_UNKNOWN;
    mRsrp = Integer.MAX_VALUE;
    mRsrq = Integer.MAX_VALUE;
    mRssnr = Integer.MAX_VALUE;
    mCqi = Integer.MAX_VALUE;
    mTimingAdvance = Integer.MAX_VALUE;
}
#method_after
@Override
public void setDefaultValues() {
    mRssi = CellInfo.UNAVAILABLE;
    mRsrp = CellInfo.UNAVAILABLE;
    mRsrq = CellInfo.UNAVAILABLE;
    mRssnr = CellInfo.UNAVAILABLE;
    mCqi = CellInfo.UNAVAILABLE;
    mTimingAdvance = CellInfo.UNAVAILABLE;
}
#end_block

#method_before
@Override
public int getLevel() {
    int levelRsrp = 0;
    int levelRssnr = 0;
    if (mRsrp == Integer.MAX_VALUE)
        levelRsrp = 0;
    else if (mRsrp >= -95)
        levelRsrp = SIGNAL_STRENGTH_GREAT;
    else if (mRsrp >= -105)
        levelRsrp = SIGNAL_STRENGTH_GOOD;
    else if (mRsrp >= -115)
        levelRsrp = SIGNAL_STRENGTH_MODERATE;
    else
        levelRsrp = SIGNAL_STRENGTH_POOR;
    // See RIL_LTE_SignalStrength in ril.h
    if (mRssnr == Integer.MAX_VALUE)
        levelRssnr = 0;
    else if (mRssnr >= 45)
        levelRssnr = SIGNAL_STRENGTH_GREAT;
    else if (mRssnr >= 10)
        levelRssnr = SIGNAL_STRENGTH_GOOD;
    else if (mRssnr >= -30)
        levelRssnr = SIGNAL_STRENGTH_MODERATE;
    else
        levelRssnr = SIGNAL_STRENGTH_POOR;
    int level;
    if (mRsrp == Integer.MAX_VALUE)
        level = levelRssnr;
    else if (mRssnr == Integer.MAX_VALUE)
        level = levelRsrp;
    else
        level = (levelRssnr < levelRsrp) ? levelRssnr : levelRsrp;
    if (DBG)
        log("Lte rsrp level: " + levelRsrp + " snr level: " + levelRssnr + " level: " + level);
    return level;
}
#method_after
@Override
public int getLevel() {
    int levelRsrp = 0;
    int levelRssnr = 0;
    if (mRsrp == CellInfo.UNAVAILABLE)
        levelRsrp = 0;
    else if (mRsrp >= -95)
        levelRsrp = SIGNAL_STRENGTH_GREAT;
    else if (mRsrp >= -105)
        levelRsrp = SIGNAL_STRENGTH_GOOD;
    else if (mRsrp >= -115)
        levelRsrp = SIGNAL_STRENGTH_MODERATE;
    else
        levelRsrp = SIGNAL_STRENGTH_POOR;
    // See RIL_LTE_SignalStrength in ril.h
    if (mRssnr == CellInfo.UNAVAILABLE)
        levelRssnr = 0;
    else if (mRssnr >= 45)
        levelRssnr = SIGNAL_STRENGTH_GREAT;
    else if (mRssnr >= 10)
        levelRssnr = SIGNAL_STRENGTH_GOOD;
    else if (mRssnr >= -30)
        levelRssnr = SIGNAL_STRENGTH_MODERATE;
    else
        levelRssnr = SIGNAL_STRENGTH_POOR;
    int level;
    if (mRsrp == CellInfo.UNAVAILABLE) {
        level = levelRssnr;
    } else if (mRssnr == CellInfo.UNAVAILABLE) {
        level = levelRsrp;
    } else {
        level = (levelRssnr < levelRsrp) ? levelRssnr : levelRsrp;
    }
    if (DBG)
        log("Lte rsrp level: " + levelRsrp + " snr level: " + levelRssnr + " level: " + level);
    return level;
}
#end_block

#method_before
@Override
public int getAsuLevel() {
    int lteAsuLevel = 99;
    int lteDbm = getDbm();
    if (lteDbm == Integer.MAX_VALUE)
        lteAsuLevel = 99;
    else if (lteDbm <= -140)
        lteAsuLevel = 0;
    else if (lteDbm >= -43)
        lteAsuLevel = 97;
    else
        lteAsuLevel = lteDbm + 140;
    if (DBG)
        log("Lte Asu level: " + lteAsuLevel);
    return lteAsuLevel;
}
#method_after
@Override
public int getAsuLevel() {
    int lteAsuLevel = 99;
    int lteDbm = getDbm();
    if (lteDbm == CellInfo.UNAVAILABLE)
        lteAsuLevel = 99;
    else if (lteDbm <= -140)
        lteAsuLevel = 0;
    else if (lteDbm >= -43)
        lteAsuLevel = 97;
    else
        lteAsuLevel = lteDbm + 140;
    if (DBG)
        log("Lte Asu level: " + lteAsuLevel);
    return lteAsuLevel;
}
#end_block

#method_before
@Override
public String toString() {
    return "CellSignalStrengthLte:" + " rssi=" + mRssi + " rsrp=" + mRsrp + " rsrq=" + mRsrq + " rssnr=" + mRssnr + " cqi=" + mCqi + " ta=" + mTimingAdvance;
}
#method_after
@Override
public String toString() {
    return "CellSignalStrengthLte:" + " rssi(dBm)=" + mRssi + " rsrp=" + mRsrp + " rsrq=" + mRsrq + " rssnr=" + mRssnr + " cqi=" + mCqi + " ta=" + mTimingAdvance;
}
#end_block

#method_before
@Override
public void writeToParcel(Parcel dest, int flags) {
    if (DBG)
        log("writeToParcel(Parcel, int): " + toString());
    dest.writeInt(mRssi);
    // Need to multiply rsrp and rsrq by -1
    // to ensure consistency when reading values written here
    // unless the values are invalid
    dest.writeInt(mRsrp * (mRsrp != Integer.MAX_VALUE ? -1 : 1));
    dest.writeInt(mRsrq * (mRsrq != Integer.MAX_VALUE ? -1 : 1));
    dest.writeInt(mRssnr);
    dest.writeInt(mCqi);
    dest.writeInt(mTimingAdvance);
}
#method_after
@Override
public void writeToParcel(Parcel dest, int flags) {
    if (DBG)
        log("writeToParcel(Parcel, int): " + toString());
    dest.writeInt(mRssi);
    // Need to multiply rsrp and rsrq by -1
    // to ensure consistency when reading values written here
    // unless the values are invalid
    dest.writeInt(mRsrp * (mRsrp != CellInfo.UNAVAILABLE ? -1 : 1));
    dest.writeInt(mRsrq * (mRsrq != CellInfo.UNAVAILABLE ? -1 : 1));
    dest.writeInt(mRssnr);
    dest.writeInt(mCqi);
    dest.writeInt(mTimingAdvance);
}
#end_block

#method_before
@NonNull
public Builder setIcon(@Nullable Image icon) {
    mIcon = icon;
    return this;
}
#method_after
@NonNull
public Builder setIcon(@Nullable ImageReference icon) {
    mIcon = icon;
    return this;
}
#end_block

#method_before
@Nullable
public Image getIcon() {
    return mIcon;
}
#method_after
@Nullable
public ImageReference getIcon() {
    return mIcon;
}
#end_block

#method_before
@NonNull
public Step build() {
    return new Step(mDistance, mManeuver, mLanes, mImageCues, mTextCues);
}
#method_after
@NonNull
public Step build() {
    return new Step(mDistance, mManeuver, mLanes, mLanesImage, mCue);
}
#end_block

#method_before
@NonNull
public List<Lane> getLanes() {
    return Common.nonNullOrEmpty(mLanes);
}
#method_after
@NonNull
public List<Lane> getLanes() {
    return Common.immutableOrEmpty(mLanes);
}
#end_block

#method_before
@Override
public boolean equals(Object o) {
    if (this == o) {
        return true;
    }
    if (o == null || getClass() != o.getClass()) {
        return false;
    }
    Step step = (Step) o;
    return Objects.equals(getManeuver(), step.getManeuver()) && Objects.equals(getDistance(), step.getDistance()) && Objects.equals(getLanes(), step.getLanes()) && Objects.equals(getImageCues(), step.getImageCues()) && Objects.equals(getTextCues(), step.getTextCues());
}
#method_after
@Override
public boolean equals(Object o) {
    if (this == o) {
        return true;
    }
    if (o == null || getClass() != o.getClass()) {
        return false;
    }
    Step step = (Step) o;
    return Objects.equals(getManeuver(), step.getManeuver()) && Objects.equals(getDistance(), step.getDistance()) && Objects.equals(getLanes(), step.getLanes()) && Objects.equals(getLanesImage(), step.getLanesImage()) && Objects.equals(getCue(), step.getCue());
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hash(getManeuver(), getDistance(), getLanes(), getImageCues(), getTextCues());
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(getManeuver(), getDistance(), getLanes(), getLanesImage(), getCue());
}
#end_block

#method_before
@Override
public String toString() {
    return String.format("{maneuver: %s, distance: %s, lanes: %s, imageCues: %s, textCues: %s}", mManeuver, mDistance, mLanes, mImageCues, mTextCues);
}
#method_after
@Override
public String toString() {
    return String.format("{maneuver: %s, distance: %s, lanes: %s, lanesImage: %s, cue: %s}", mManeuver, mDistance, mLanes, mLanesImage, mCue);
}
#end_block

#method_before
@Test
public void testSetExtra() {
    final Bundle extras = new Bundle();
    extras.putString("MediaMetadata2Test", "testBuilder");
    Builder builder = new Builder();
    try {
        builder.putLong(MediaMetadata2.METADATA_KEY_EXTRAS, 1);
        fail();
    } catch (Exception e) {
    // expected
    }
    builder.setExtras(extras);
    MediaMetadata2 metadata = builder.build();
    assertTrue(TestUtils.equals(extras, metadata.getExtras()));
}
#method_after
@Test
public void testSetExtra() {
    final Bundle extras = new Bundle();
    extras.putString("MediaMetadata2Test", "testBuilder");
    Builder builder = new Builder();
    try {
        builder.putLong(MediaMetadata2.METADATA_KEY_EXTRAS, 1);
        fail();
    } catch (IllegalArgumentException e) {
    // expected
    }
    builder.setExtras(extras);
    MediaMetadata2 metadata = builder.build();
    assertTrue(TestUtils.equals(extras, metadata.getExtras()));
}
#end_block

#method_before
@Override
public void onReset(IVold vold) {
    if (mResetListener != null) {
        mResetListener.onReset(vold);
    }
}
#method_after
public void onReset(IVold vold) {
    synchronized (mResetListeners) {
        for (StorageManagerInternal.ResetListener listener : mResetListeners) {
            listener.onReset(vold);
        }
    }
}
#end_block

#method_before
private void runSnapOnMaxFlingNextView(int velocity) throws Throwable {
    // Record the current center view.
    View view = findCenterView(mLayoutManager);
    assertCenterAligned(view);
    int velocityDir = mReverseScroll ? -velocity : velocity;
    mLayoutManager.expectIdleState(1);
    // Scroll at one pixel in the correct direction to allow fling snapping to the next view.
    mActivityRule.runOnUiThread(new Runnable() {

        @Override
        public void run() {
            mRecyclerView.scrollBy(mReverseScroll ? -1 : 1, mReverseScroll ? -1 : 1);
        }
    });
    waitForIdleScroll(mRecyclerView);
    assertTrue(fling(velocityDir, velocityDir));
    mLayoutManager.waitForSnap(100);
    getInstrumentation().waitForIdleSync();
    View viewAfterFling = findCenterView(mLayoutManager);
    assertNotSame("The view should have scrolled", view, viewAfterFling);
    int expectedPosition = mConfig.mItemCount / 2 + (mConfig.mReverseLayout ? (mReverseScroll ? 1 : -1) : (mReverseScroll ? -1 : 1));
    assertEquals(expectedPosition, mLayoutManager.getPosition(viewAfterFling));
    assertCenterAligned(viewAfterFling);
}
#method_after
private void runSnapOnMaxFlingNextView(int velocity) throws Throwable {
    // Record the current center view.
    View view = findCenterView(mLayoutManager);
    assertCenterAligned(view);
    int velocityDir = mReverseScroll ? -velocity : velocity;
    mLayoutManager.expectIdleState(1);
    // Scroll at one pixel in the correct direction to allow fling snapping to the next view.
    mActivityRule.runOnUiThread(new Runnable() {

        @Override
        public void run() {
            mRecyclerView.scrollBy(mReverseScroll ? -1 : 1, mReverseScroll ? -1 : 1);
        }
    });
    waitForIdleScroll(mRecyclerView);
    assertTrue(fling(velocityDir, velocityDir));
    mLayoutManager.waitForSnap(100);
    View viewAfterFling = findCenterView(mLayoutManager);
    assertNotSame("The view should have scrolled", view, viewAfterFling);
    int expectedPosition = mConfig.mItemCount / 2 + (mConfig.mReverseLayout ? (mReverseScroll ? 1 : -1) : (mReverseScroll ? -1 : 1));
    assertEquals(expectedPosition, mLayoutManager.getPosition(viewAfterFling));
    assertCenterAligned(viewAfterFling);
}
#end_block

#method_before
private void runSnapOnFlingExactlyToNextView() throws Throwable {
    // Record the current center view.
    View view = findCenterView(mLayoutManager);
    assertCenterAligned(view);
    // Determine the target item to scroll to
    final int expectedPosition = mConfig.mItemCount / 2 + (mConfig.mReverseLayout ? (mReverseScroll ? 1 : -1) : (mReverseScroll ? -1 : 1));
    // Smooth scroll in the correct direction to allow fling snapping to the next view.
    mActivityRule.runOnUiThread(new Runnable() {

        @Override
        public void run() {
            mRecyclerView.smoothScrollToPosition(expectedPosition);
        }
    });
    waitForDistanceToTarget(expectedPosition, .5f);
    // Interrupt scroll and fling to target view, ending exactly when the view is snapped
    mLayoutManager.expectIdleState(1);
    onView(allOf(isDescendantOfA(isAssignableFrom(RecyclerView.class)), withText(mTestAdapter.getItemAt(expectedPosition).getDisplayText()))).perform(SwipeToLocation.flingToCenter());
    waitForIdleScroll(mRecyclerView);
    // Wait until the RecyclerView comes to a rest
    mLayoutManager.waitForSnap(100);
    getInstrumentation().waitForIdleSync();
    // Check the result
    View viewAfterFling = findCenterView(mLayoutManager);
    assertNotSame("The view should have scrolled", view, viewAfterFling);
    assertEquals(expectedPosition, mLayoutManager.getPosition(viewAfterFling));
    assertCenterAligned(viewAfterFling);
}
#method_after
private void runSnapOnFlingExactlyToNextView() throws Throwable {
    // Record the current center view.
    View view = findCenterView(mLayoutManager);
    assertCenterAligned(view);
    // Determine the target item to scroll to
    final int expectedPosition = mConfig.mItemCount / 2 + (mConfig.mReverseLayout ? (mReverseScroll ? 1 : -1) : (mReverseScroll ? -1 : 1));
    // Smooth scroll in the correct direction to allow fling snapping to the next view.
    mActivityRule.runOnUiThread(new Runnable() {

        @Override
        public void run() {
            mRecyclerView.smoothScrollToPosition(expectedPosition);
        }
    });
    waitForDistanceToTarget(expectedPosition, .5f);
    // Interrupt scroll and fling to target view, ending exactly when the view is snapped
    mLayoutManager.expectIdleState(1);
    onView(allOf(isDescendantOfA(isAssignableFrom(RecyclerView.class)), withText(mTestAdapter.getItemAt(expectedPosition).getDisplayText()))).perform(SwipeToLocation.flingToCenter());
    waitForIdleScroll(mRecyclerView);
    // Wait until the RecyclerView comes to a rest
    mLayoutManager.waitForSnap(100);
    // Check the result
    View viewAfterFling = findCenterView(mLayoutManager);
    assertNotSame("The view should have scrolled", view, viewAfterFling);
    assertEquals(expectedPosition, mLayoutManager.getPosition(viewAfterFling));
    assertCenterAligned(viewAfterFling);
}
#end_block

#method_before
private void waitForDistanceToTarget(final int targetPosition, final float distancePercent) throws InterruptedException {
    final CountDownLatch latch = new CountDownLatch(1);
    mRecyclerView.addOnScrollListener(new RecyclerView.OnScrollListener() {

        @Override
        public void onScrolled(@NonNull RecyclerView recyclerView, int dx, int dy) {
            View target = mLayoutManager.findViewByPosition(targetPosition);
            if (target == null) {
                return;
            }
            int distancePx = distFromCenter(target);
            int size = mConfig.mOrientation == HORIZONTAL ? target.getWidth() : target.getHeight();
            if ((float) distancePx / size <= distancePercent) {
                latch.countDown();
            }
        }
    });
    assertTrue("should be close enough to the target view in 10 seconds", latch.await(10, TimeUnit.SECONDS));
}
#method_after
private void waitForDistanceToTarget(final int targetPosition, final float distancePercent) throws InterruptedException {
    final CountDownLatch latch = new CountDownLatch(1);
    mRecyclerView.addOnScrollListener(new RecyclerView.OnScrollListener() {

        @Override
        public void onScrolled(@NonNull RecyclerView recyclerView, int dx, int dy) {
            View target = mLayoutManager.findViewByPosition(targetPosition);
            if (target == null) {
                return;
            }
            int distancePx = distFromCenter(target);
            int size = mConfig.mOrientation == HORIZONTAL ? target.getWidth() : target.getHeight();
            if ((float) distancePx / size <= distancePercent) {
                latch.countDown();
            }
        }
    });
    assertTrue("should be close enough to the target view within 10 seconds", latch.await(10, TimeUnit.SECONDS));
}
#end_block

#method_before
@Override
protected LinearSmoothScroller createSnapScroller(RecyclerView.LayoutManager layoutManager) {
    if (!(layoutManager instanceof RecyclerView.SmoothScroller.ScrollVectorProvider)) {
        return null;
    }
    return new LinearSmoothScroller(mRecyclerView.getContext()) {

        @Override
        protected void onTargetFound(View targetView, RecyclerView.State state, Action action) {
            int[] snapDistances = calculateDistanceToFinalSnap(mRecyclerView.getLayoutManager(), targetView);
            final int dx = snapDistances[0];
            final int dy = snapDistances[1];
            final int time = calculateTimeForDeceleration(Math.max(Math.abs(dx), Math.abs(dy)));
            action.update(dx, dy, Math.max(1, time), mDecelerateInterpolator);
        }

        @Override
        protected float calculateSpeedPerPixel(DisplayMetrics displayMetrics) {
            return MILLISECONDS_PER_INCH / displayMetrics.densityDpi;
        }

        @Override
        protected int calculateTimeForScrolling(int dx) {
            return Math.min(MAX_SCROLL_ON_FLING_DURATION, super.calculateTimeForScrolling(dx));
        }
    };
}
#method_after
@Override
protected LinearSmoothScroller createSnapScroller(RecyclerView.LayoutManager layoutManager) {
    if (!(layoutManager instanceof RecyclerView.SmoothScroller.ScrollVectorProvider)) {
        return null;
    }
    return new LinearSmoothScroller(mRecyclerView.getContext()) {

        @Override
        protected void onTargetFound(View targetView, RecyclerView.State state, Action action) {
            int[] snapDistances = calculateDistanceToFinalSnap(mRecyclerView.getLayoutManager(), targetView);
            final int dx = snapDistances[0];
            final int dy = snapDistances[1];
            final int time = calculateTimeForDeceleration(Math.max(Math.abs(dx), Math.abs(dy)));
            // TODO: revert change in next line when b/118663993 is fixed
            action.update(dx, dy, Math.max(1, time), mDecelerateInterpolator);
        }

        @Override
        protected float calculateSpeedPerPixel(DisplayMetrics displayMetrics) {
            return MILLISECONDS_PER_INCH / displayMetrics.densityDpi;
        }

        @Override
        protected int calculateTimeForScrolling(int dx) {
            return Math.min(MAX_SCROLL_ON_FLING_DURATION, super.calculateTimeForScrolling(dx));
        }
    };
}
#end_block

#method_before
@Override
public ListenableFuture<ControllerResult> skipForward() {
    // To match with KEYCODE_MEDIA_SKIP_FORWARD
    return null;
}
#method_after
@Override
public ListenableFuture<ControllerResult> skipForward() {
    return dispatchRemoteSessionTask(COMMAND_CODE_SESSION_SKIP_FORWARD, new RemoteSessionTask() {

        @Override
        public void run(IMediaSession2 iSession2, int seq) throws RemoteException {
            iSession2.skipForward(mControllerStub, seq);
        }
    });
}
#end_block

#method_before
@Override
public ListenableFuture<ControllerResult> skipBackward() {
    // To match with KEYCODE_MEDIA_SKIP_BACKWARD
    return null;
}
#method_after
@Override
public ListenableFuture<ControllerResult> skipBackward() {
    return dispatchRemoteSessionTask(COMMAND_CODE_SESSION_SKIP_BACKWARD, new RemoteSessionTask() {

        @Override
        public void run(IMediaSession2 iSession2, int seq) throws RemoteException {
            iSession2.skipBackward(mControllerStub, seq);
        }
    });
}
#end_block

#method_before
private void dispatchSessionTaskInternal(@NonNull IMediaController2 caller, final int seq, @Nullable final SessionCommand2 sessionCommand, @CommandCode final int commandCode, @NonNull final SessionTask task) {
    final ControllerInfo controller = mConnectedControllersManager.getController(caller == null ? null : caller.asBinder());
    if (mSessionImpl.isClosed() || controller == null) {
        return;
    }
    mSessionImpl.getCallbackExecutor().execute(new Runnable() {

        @Override
        public void run() {
            if (!mConnectedControllersManager.isConnected(controller)) {
                return;
            }
            SessionCommand2 commandForOnCommandRequest;
            if (sessionCommand != null) {
                if (!mConnectedControllersManager.isAllowedCommand(controller, sessionCommand)) {
                    if (DEBUG) {
                        Log.d(TAG, "Command (" + sessionCommand + ") from " + controller + " isn't allowed.");
                    }
                    return;
                }
                commandForOnCommandRequest = sCommandsForOnCommandRequest.get(sessionCommand.getCommandCode());
            } else {
                if (!mConnectedControllersManager.isAllowedCommand(controller, commandCode)) {
                    if (DEBUG) {
                        Log.d(TAG, "Command (" + commandCode + ") from " + controller + " isn't allowed.");
                    }
                    return;
                }
                commandForOnCommandRequest = sCommandsForOnCommandRequest.get(commandCode);
            }
            try {
                if (commandForOnCommandRequest != null) {
                    int resultCode = mSessionImpl.getCallback().onCommandRequest(mSessionImpl.getInstance(), controller, commandForOnCommandRequest);
                    if (resultCode != RESULT_CODE_SUCCESS) {
                        // Don't run rejected command.
                        if (DEBUG) {
                            Log.d(TAG, "Command (" + commandForOnCommandRequest + ") from " + controller + " was rejected by " + mSessionImpl + ", code=" + resultCode);
                        }
                        sendSessionResult(controller, seq, resultCode);
                        return;
                    }
                }
                if (task instanceof SessionPlayerTask) {
                    final ListenableFuture<PlayerResult> future = ((SessionPlayerTask) task).run(controller);
                    if (future == null) {
                        if (THROW_EXCEPTION_FOR_NULL_RESULT) {
                            throw new RuntimeException("SessionPlayer has returned null," + " commandCode=" + commandCode);
                        } else {
                            sendPlayerResult(controller, seq, new PlayerResult(PlayerResult.RESULT_CODE_UNKNOWN_ERROR, null));
                        }
                    } else {
                        future.addListener(new Runnable() {

                            @Override
                            public void run() {
                                try {
                                    sendPlayerResult(controller, seq, future.get(0, TimeUnit.MILLISECONDS));
                                } catch (Exception e) {
                                    Log.w(TAG, "Cannot obtain PlayerResult after the" + " command is finished", e);
                                    sendSessionResult(controller, seq, RESULT_CODE_INVALID_STATE);
                                }
                            }
                        }, DIRECT_EXECUTOR);
                    }
                } else if (task instanceof SessionCallbackTask) {
                    final Object result = ((SessionCallbackTask) task).run(controller);
                    if (result == null) {
                        if (THROW_EXCEPTION_FOR_NULL_RESULT) {
                            throw new RuntimeException("SessionCallback has returned null," + " commandCode=" + commandCode);
                        } else {
                            sendSessionResult(controller, seq, SessionResult.RESULT_CODE_UNKNOWN_ERROR);
                        }
                    } else if (result instanceof Integer) {
                        sendSessionResult(controller, seq, (Integer) result);
                    } else if (result instanceof SessionResult) {
                        sendSessionResult(controller, seq, (SessionResult) result);
                    } else if (DEBUG) {
                        throw new RuntimeException("Unexpected return type " + result + ". Fix bug");
                    }
                } else if (task instanceof LibrarySessionCallbackTask) {
                    final Object result = ((LibrarySessionCallbackTask) task).run(controller);
                    if (result == null) {
                        if (THROW_EXCEPTION_FOR_NULL_RESULT) {
                            throw new RuntimeException("LibrarySessionCallback has returned" + " null, commandCode=" + commandCode);
                        } else {
                            sendLibraryResult(controller, seq, LibraryResult.RESULT_CODE_UNKNOWN_ERROR);
                        }
                    } else if (result instanceof Integer) {
                        sendLibraryResult(controller, seq, (Integer) result);
                    } else if (result instanceof LibraryResult) {
                        sendLibraryResult(controller, seq, (LibraryResult) result);
                    } else if (DEBUG) {
                        throw new RuntimeException("Unexpected return type " + result + ". Fix bug");
                    }
                } else if (DEBUG) {
                    throw new RuntimeException("Unknown task " + task + ". Fix bug");
                }
            } catch (RemoteException e) {
                // Currently it's TransactionTooLargeException or DeadSystemException.
                // We'd better to leave log for those cases because
                // - TransactionTooLargeException means that we may need to fix our code.
                // (e.g. add pagination or special way to deliver Bitmap)
                // - DeadSystemException means that errors around it can be ignored.
                Log.w(TAG, "Exception in " + controller.toString(), e);
            }
        }
    });
}
#method_after
private void dispatchSessionTaskInternal(@NonNull IMediaController2 caller, final int seq, @Nullable final SessionCommand2 sessionCommand, @CommandCode final int commandCode, @NonNull final SessionTask task) {
    final ControllerInfo controller = mConnectedControllersManager.getController(caller == null ? null : caller.asBinder());
    if (mSessionImpl.isClosed() || controller == null) {
        return;
    }
    mSessionImpl.getCallbackExecutor().execute(new Runnable() {

        @Override
        public void run() {
            if (!mConnectedControllersManager.isConnected(controller)) {
                return;
            }
            SessionCommand2 commandForOnCommandRequest;
            if (sessionCommand != null) {
                if (!mConnectedControllersManager.isAllowedCommand(controller, sessionCommand)) {
                    if (DEBUG) {
                        Log.d(TAG, "Command (" + sessionCommand + ") from " + controller + " isn't allowed.");
                    }
                    return;
                }
                commandForOnCommandRequest = sCommandsForOnCommandRequest.get(sessionCommand.getCommandCode());
            } else {
                if (!mConnectedControllersManager.isAllowedCommand(controller, commandCode)) {
                    if (DEBUG) {
                        Log.d(TAG, "Command (" + commandCode + ") from " + controller + " isn't allowed.");
                    }
                    return;
                }
                commandForOnCommandRequest = sCommandsForOnCommandRequest.get(commandCode);
            }
            try {
                if (commandForOnCommandRequest != null) {
                    int resultCode = mSessionImpl.getCallback().onCommandRequest(mSessionImpl.getInstance(), controller, commandForOnCommandRequest);
                    if (resultCode != RESULT_CODE_SUCCESS) {
                        // Don't run rejected command.
                        if (DEBUG) {
                            Log.d(TAG, "Command (" + commandForOnCommandRequest + ") from " + controller + " was rejected by " + mSessionImpl + ", code=" + resultCode);
                        }
                        sendSessionResult(controller, seq, resultCode);
                        return;
                    }
                }
                if (task instanceof SessionPlayerTask) {
                    final ListenableFuture<PlayerResult> future = ((SessionPlayerTask) task).run(controller);
                    if (future == null) {
                        if (THROW_EXCEPTION_FOR_NULL_RESULT) {
                            throw new RuntimeException("SessionPlayer has returned null," + " commandCode=" + commandCode);
                        } else {
                            sendPlayerResult(controller, seq, new PlayerResult(PlayerResult.RESULT_CODE_UNKNOWN_ERROR, null));
                        }
                    } else {
                        future.addListener(new Runnable() {

                            @Override
                            public void run() {
                                try {
                                    sendPlayerResult(controller, seq, future.get(0, TimeUnit.MILLISECONDS));
                                } catch (Exception e) {
                                    Log.w(TAG, "Cannot obtain PlayerResult after the" + " command is finished", e);
                                    sendSessionResult(controller, seq, RESULT_CODE_INVALID_STATE);
                                }
                            }
                        }, DIRECT_EXECUTOR);
                    }
                } else if (task instanceof SessionCallbackTask) {
                    final Object result = ((SessionCallbackTask) task).run(controller);
                    if (result == null) {
                        if (THROW_EXCEPTION_FOR_NULL_RESULT) {
                            throw new RuntimeException("SessionCallback has returned null," + " commandCode=" + commandCode);
                        } else {
                            sendSessionResult(controller, seq, SessionResult.RESULT_CODE_UNKNOWN_ERROR);
                        }
                    } else if (result instanceof Integer) {
                        sendSessionResult(controller, seq, (Integer) result);
                    } else if (result instanceof SessionResult) {
                        sendSessionResult(controller, seq, (SessionResult) result);
                    } else if (DEBUG) {
                        throw new RuntimeException("Unexpected return type " + result + ". Fix bug");
                    }
                } else if (task instanceof LibrarySessionCallbackTask) {
                    final Object result = ((LibrarySessionCallbackTask) task).run(controller);
                    if (result == null) {
                        if (THROW_EXCEPTION_FOR_NULL_RESULT) {
                            throw new RuntimeException("LibrarySessionCallback has returned" + " null, commandCode=" + commandCode);
                        } else {
                            sendLibraryResult(controller, seq, LibraryResult.RESULT_CODE_UNKNOWN_ERROR);
                        }
                    } else if (result instanceof Integer) {
                        sendLibraryResult(controller, seq, (Integer) result);
                    } else if (result instanceof LibraryResult) {
                        sendLibraryResult(controller, seq, (LibraryResult) result);
                    } else if (DEBUG) {
                        throw new RuntimeException("Unexpected return type " + result + ". Fix bug");
                    }
                } else if (DEBUG) {
                    throw new RuntimeException("Unknown task " + task + ". Fix bug");
                }
            } catch (RemoteException e) {
                // Currently it's TransactionTooLargeException or DeadSystemException.
                // We'd better to leave log for those cases because
                // - TransactionTooLargeException means that we may need to fix our code.
                // (e.g. add pagination or special way to deliver Bitmap)
                // - DeadSystemException means that errors around it can be ignored.
                Log.w(TAG, "Exception in " + controller.toString(), e);
            } catch (Exception e) {
                // Any random exception may be happen inside of the session player / callback.
                if (task instanceof PlayerTask) {
                    sendPlayerResult(controller, seq, new PlayerResult(PlayerResult.RESULT_CODE_UNKNOWN_ERROR, null));
                } else if (task instanceof SessionCallbackTask) {
                    sendSessionResult(controller, seq, SessionResult.RESULT_CODE_UNKNOWN_ERROR);
                } else if (task instanceof LibrarySessionCallbackTask) {
                    sendLibraryResult(controller, seq, LibraryResult.RESULT_CODE_UNKNOWN_ERROR);
                }
            }
        }
    });
}
#end_block

#method_before
@Test
public void testSetMetadataForCurrentMediaItem() throws InterruptedException {
    // TODO: Add test for changing metadata in a playlist
    final CountDownLatch latch = new CountDownLatch(2);
    final long duration = 1000L;
    final MediaItem2 item = TestUtils.createMediaItemWithMetadata();
    final ControllerCallback callback = new ControllerCallback() {

        @Override
        public void onCurrentMediaItemChanged(@NonNull MediaController2 controller, @Nullable MediaItem2 item) {
            MediaMetadata2 metadata = item.getMetadata();
            if (metadata != null) {
                switch((int) latch.getCount()) {
                    case 2:
                        assertFalse(metadata.containsKey(MediaMetadata2.METADATA_KEY_DURATION));
                        break;
                    case 1:
                        assertTrue(metadata.containsKey(MediaMetadata2.METADATA_KEY_DURATION));
                        assertEquals(duration, metadata.getLong(MediaMetadata2.METADATA_KEY_DURATION));
                }
            }
            latch.countDown();
        }
    };
    MediaController2 controller = createController(mSession.getToken(), true, callback);
    mPlayer.setMediaItem(item);
    mPlayer.notifyCurrentMediaItemChanged(item);
    assertFalse(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
    item.setMetadata(TestUtils.createMetadata(item.getMediaId(), duration));
    assertTrue(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
}
#method_after
@Test
public void testSetMetadataForCurrentMediaItem() throws InterruptedException {
    final CountDownLatch latch = new CountDownLatch(2);
    final long duration = 1000L;
    final MediaItem2 item = TestUtils.createMediaItemWithMetadata();
    final ControllerCallback callback = new ControllerCallback() {

        @Override
        public void onCurrentMediaItemChanged(@NonNull MediaController2 controller, @Nullable MediaItem2 item) {
            MediaMetadata2 metadata = item.getMetadata();
            if (metadata != null) {
                switch((int) latch.getCount()) {
                    case 2:
                        assertFalse(metadata.containsKey(MediaMetadata2.METADATA_KEY_DURATION));
                        break;
                    case 1:
                        assertTrue(metadata.containsKey(MediaMetadata2.METADATA_KEY_DURATION));
                        assertEquals(duration, metadata.getLong(MediaMetadata2.METADATA_KEY_DURATION));
                }
            }
            latch.countDown();
        }
    };
    MediaController2 controller = createController(mSession.getToken(), true, callback);
    mPlayer.setMediaItem(item);
    mPlayer.notifyCurrentMediaItemChanged(item);
    assertFalse(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
    item.setMetadata(TestUtils.createMetadata(item.getMediaId(), duration));
    assertTrue(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
}
#end_block

#method_before
@Override
public void onSkipToQueueItem(final long id) {
    dispatchSessionTask(SessionCommand2.COMMAND_CODE_PLAYER_SKIP_TO_PLAYLIST_ITEM, new SessionTask() {

        @Override
        public void run(ControllerInfo controller) throws RemoteException {
            List<MediaItem2> playlist = mSessionImpl.getPlayer().getPlaylist();
            if (playlist == null) {
                return;
            }
            mSessionImpl.skipToPlaylistItem((int) id);
        }
    });
}
#method_after
@Override
public void onSkipToQueueItem(final long queueId) {
    dispatchSessionTask(SessionCommand2.COMMAND_CODE_PLAYER_SKIP_TO_PLAYLIST_ITEM, new SessionTask() {

        @Override
        public void run(ControllerInfo controller) throws RemoteException {
            List<MediaItem2> playlist = mSessionImpl.getPlayer().getPlaylist();
            if (playlist == null) {
                return;
            }
            // Use queueId as an index as we've published {@link QueueItem} as so.
            // see: {@link MediaUtils2#convertToQueueItemList}.
            mSessionImpl.skipToPlaylistItem((int) queueId);
        }
    });
}
#end_block

#method_before
@Override
public ListenableFuture<PlayerResult> removePlaylistItem(@NonNull final int index) {
    return dispatchPlayerTask(new PlayerTask<ListenableFuture<PlayerResult>>() {

        @Override
        public ListenableFuture<PlayerResult> run(SessionPlayer2 player) throws Exception {
            if (index < 0) {
                throw new IllegalArgumentException("index shouldn't be negative");
            }
            final List<MediaItem2> list = player.getPlaylist();
            if (index >= list.size()) {
                return PlayerResult.createFuture(RESULT_CODE_BAD_VALUE);
            }
            return player.removePlaylistItem(list.get(index));
        }
    });
}
#method_after
@Override
public ListenableFuture<PlayerResult> removePlaylistItem(final int index) {
    return dispatchPlayerTask(new PlayerTask<ListenableFuture<PlayerResult>>() {

        @Override
        public ListenableFuture<PlayerResult> run(SessionPlayer2 player) throws Exception {
            if (index < 0) {
                throw new IllegalArgumentException("index shouldn't be negative");
            }
            final List<MediaItem2> list = player.getPlaylist();
            if (index >= list.size()) {
                return PlayerResult.createFuture(RESULT_CODE_BAD_VALUE);
            }
            return player.removePlaylistItem(list.get(index));
        }
    });
}
#end_block

#method_before
@Override
public void onCurrentMediaItemChanged(final SessionPlayer2 player, final MediaItem2 item) {
    final MediaSession2ImplBase session = getSession();
    if (session == null || session.getPlayer() != player || player == null) {
        return;
    }
    synchronized (session.mLock) {
        if (mMediaItem != null) {
            mMediaItem.removeOnMetadataChangedListener(mMediaItemListener);
        }
        if (item != null) {
            item.addOnMetadataChangedListener(session.mCallbackExecutor, mMediaItemListener);
        }
        mMediaItem = item;
    }
    // Note: No sanity check whether the item is in the playlist.
    updateDurationIfNeeded(player, item);
    session.dispatchRemoteControllerCallbackTask(new RemoteControllerCallbackTask() {

        @Override
        public void run(ControllerCb callback) throws RemoteException {
            callback.onCurrentMediaItemChanged(item);
        }
    });
}
#method_after
@Override
public void onCurrentMediaItemChanged(final SessionPlayer2 player, final MediaItem2 item) {
    final MediaSession2ImplBase session = getSession();
    if (session == null || session.getPlayer() != player || player == null) {
        return;
    }
    synchronized (session.mLock) {
        if (mMediaItem != null) {
            mMediaItem.removeOnMetadataChangedListener(mCurrentItemChangedListener);
        }
        if (item != null) {
            item.addOnMetadataChangedListener(session.mCallbackExecutor, mCurrentItemChangedListener);
        }
        mMediaItem = item;
    }
    // Note: No sanity check whether the item is in the playlist.
    updateDurationIfNeeded(player, item);
    session.dispatchRemoteControllerCallbackTask(new RemoteControllerCallbackTask() {

        @Override
        public void run(ControllerCb callback) throws RemoteException {
            callback.onCurrentMediaItemChanged(item);
        }
    });
}
#end_block

#method_before
@Override
public void onPlaylistChanged(final SessionPlayer2 player, final List<MediaItem2> list, final MediaMetadata2 metadata) {
    // TODO: Add code for changing metadata of media item in a playlist
    dispatchRemoteControllerTask(player, new RemoteControllerCallbackTask() {

        @Override
        public void run(ControllerCb callback) throws RemoteException {
            callback.onPlaylistChanged(list, metadata);
        }
    });
}
#method_after
@Override
public void onPlaylistChanged(final SessionPlayer2 player, final List<MediaItem2> list, final MediaMetadata2 metadata) {
    final MediaSession2ImplBase session = getSession();
    if (session == null || session.getPlayer() != player || player == null) {
        return;
    }
    synchronized (session.mLock) {
        if (mList != null) {
            for (int i = 0; i < mList.size(); i++) {
                mList.get(i).removeOnMetadataChangedListener(mPlaylistItemChangedListener);
            }
        }
        if (list != null) {
            for (int i = 0; i < list.size(); i++) {
                list.get(i).addOnMetadataChangedListener(session.mCallbackExecutor, mPlaylistItemChangedListener);
            }
        }
        mList = list;
    }
    dispatchRemoteControllerTask(player, new RemoteControllerCallbackTask() {

        @Override
        public void run(ControllerCb callback) throws RemoteException {
            callback.onPlaylistChanged(list, metadata);
        }
    });
}
#end_block

#method_before
@Override
public ListenableFuture<ControllerResult> skipForward() {
    // To match with KEYCODE_MEDIA_SKIP_FORWARD
    return null;
}
#method_after
@Override
public ListenableFuture<ControllerResult> skipForward() {
    // Unsupported action
    return createFutureWithResult(RESULT_CODE_NOT_SUPPORTED);
}
#end_block

#method_before
@Override
public ListenableFuture<ControllerResult> skipBackward() {
    // To match with KEYCODE_MEDIA_SKIP_BACKWARD
    return null;
}
#method_after
@Override
public ListenableFuture<ControllerResult> skipBackward() {
    // Unsupported action
    return createFutureWithResult(RESULT_CODE_NOT_SUPPORTED);
}
#end_block

#method_before
@Override
@Nullable
public List<MediaItem2> getPlaylist() {
    synchronized (mLock) {
        if (!mConnected) {
            Log.w(TAG, "Session isn't active", new IllegalStateException());
            return null;
        }
        return mPlaylist;
    }
}
#method_after
@Override
@Nullable
public List<MediaItem2> getPlaylist() {
    synchronized (mLock) {
        if (!mConnected) {
            Log.w(TAG, "Session isn't active", new IllegalStateException());
            return null;
        }
        return (mPlaylist == null || mPlaylist.size() == 0) ? null : mPlaylist;
    }
}
#end_block

#method_before
void onConnectedNotLocked() {
    if (DEBUG) {
        Log.d(TAG, "onConnectedNotLocked token=" + mToken);
    }
    final SessionCommandGroup2.Builder commandsBuilder = new SessionCommandGroup2.Builder();
    synchronized (mLock) {
        if (mIsReleased || mConnected) {
            return;
        }
        long sessionFlags = mControllerCompat.getFlags();
        boolean includePlaylistCommands = (sessionFlags & FLAG_HANDLES_QUEUE_COMMANDS) != 0;
        commandsBuilder.addAllPlayerCommands(COMMAND_VERSION_CURRENT, includePlaylistCommands);
        commandsBuilder.addAllVolumeCommands(COMMAND_VERSION_CURRENT);
        commandsBuilder.addAllSessionCommands(COMMAND_VERSION_CURRENT);
        commandsBuilder.removeCommand(COMMAND_CODE_PLAYER_SET_SPEED);
        commandsBuilder.removeCommand(COMMAND_CODE_SESSION_SUBSCRIBE_ROUTES_INFO);
        commandsBuilder.removeCommand(COMMAND_CODE_SESSION_UNSUBSCRIBE_ROUTES_INFO);
        commandsBuilder.removeCommand(COMMAND_CODE_SESSION_SELECT_ROUTE);
        commandsBuilder.addCommand(new SessionCommand2(SESSION_COMMAND_ON_EXTRA_CHANGED, null));
        commandsBuilder.addCommand(new SessionCommand2(SESSION_COMMAND_ON_CAPTIONING_ENABLED_CHANGED, null));
        mAllowedCommands = commandsBuilder.build();
        mPlaybackStateCompat = mControllerCompat.getPlaybackState();
        if (mPlaybackStateCompat == null) {
            mPlayerState = PLAYER_STATE_IDLE;
            mBufferedPosition = UNKNOWN_TIME;
        } else {
            mPlayerState = MediaUtils2.convertToPlayerState(mPlaybackStateCompat);
            mBufferedPosition = mPlaybackStateCompat.getBufferedPosition();
        }
        mPlaybackInfo = MediaUtils2.toPlaybackInfo2(mControllerCompat.getPlaybackInfo());
        mRepeatMode = mControllerCompat.getRepeatMode();
        mShuffleMode = mControllerCompat.getShuffleMode();
        mQueue = mControllerCompat.getQueue();
        if (mQueue != null) {
            mPlaylist = MediaUtils2.convertQueueItemListToMediaItem2List(mQueue);
        } else {
            // MediaSessionCompat can set queue as null. However, SessionPlayer2 should not
            // set playlist as null. Therefore, we treat a null queue as an empty playlist.
            mQueue = new ArrayList<>();
            mPlaylist = new ArrayList<>();
        }
        mPlaylistMetadata = MediaUtils2.convertToMediaMetadata2(mControllerCompat.getQueueTitle());
        // Call this after set playlist.
        setCurrentMediaItemLocked(mControllerCompat.getMetadata());
        mConnected = true;
    }
    mCallbackExecutor.execute(new Runnable() {

        @Override
        public void run() {
            mCallback.onConnected(mInstance, commandsBuilder.build());
        }
    });
}
#method_after
void onConnectedNotLocked() {
    if (DEBUG) {
        Log.d(TAG, "onConnectedNotLocked token=" + mToken);
    }
    final SessionCommandGroup2.Builder commandsBuilder = new SessionCommandGroup2.Builder();
    synchronized (mLock) {
        if (mIsReleased || mConnected) {
            return;
        }
        long sessionFlags = mControllerCompat.getFlags();
        boolean includePlaylistCommands = (sessionFlags & FLAG_HANDLES_QUEUE_COMMANDS) != 0;
        commandsBuilder.addAllPlayerCommands(COMMAND_VERSION_CURRENT, includePlaylistCommands);
        commandsBuilder.addAllVolumeCommands(COMMAND_VERSION_CURRENT);
        commandsBuilder.addAllSessionCommands(COMMAND_VERSION_CURRENT);
        commandsBuilder.removeCommand(COMMAND_CODE_PLAYER_SET_SPEED);
        commandsBuilder.removeCommand(COMMAND_CODE_SESSION_SUBSCRIBE_ROUTES_INFO);
        commandsBuilder.removeCommand(COMMAND_CODE_SESSION_UNSUBSCRIBE_ROUTES_INFO);
        commandsBuilder.removeCommand(COMMAND_CODE_SESSION_SELECT_ROUTE);
        commandsBuilder.addCommand(new SessionCommand2(SESSION_COMMAND_ON_EXTRA_CHANGED, null));
        commandsBuilder.addCommand(new SessionCommand2(SESSION_COMMAND_ON_CAPTIONING_ENABLED_CHANGED, null));
        mAllowedCommands = commandsBuilder.build();
        mPlaybackStateCompat = mControllerCompat.getPlaybackState();
        if (mPlaybackStateCompat == null) {
            mPlayerState = PLAYER_STATE_IDLE;
            mBufferedPosition = UNKNOWN_TIME;
        } else {
            mPlayerState = MediaUtils2.convertToPlayerState(mPlaybackStateCompat);
            mBufferedPosition = mPlaybackStateCompat.getBufferedPosition();
        }
        mPlaybackInfo = MediaUtils2.toPlaybackInfo2(mControllerCompat.getPlaybackInfo());
        mRepeatMode = mControllerCompat.getRepeatMode();
        mShuffleMode = mControllerCompat.getShuffleMode();
        mQueue = MediaUtils2.removeNullElements(mControllerCompat.getQueue());
        if (mQueue == null || mQueue.size() == 0) {
            // MediaSessionCompat can set queue as null or empty. However, SessionPlayer2 should
            // not set playlist as null or empty. Therefore, we treat them as the same.
            mQueue = null;
            mPlaylist = null;
        } else {
            mPlaylist = MediaUtils2.convertQueueItemListToMediaItem2List(mQueue);
        }
        mPlaylistMetadata = MediaUtils2.convertToMediaMetadata2(mControllerCompat.getQueueTitle());
        // Call this after set playlist.
        setCurrentMediaItemLocked(mControllerCompat.getMetadata());
        mConnected = true;
    }
    mCallbackExecutor.execute(new Runnable() {

        @Override
        public void run() {
            mCallback.onConnected(mInstance, commandsBuilder.build());
        }
    });
}
#end_block

#method_before
@SuppressWarnings({ "GuardedBy", "WeakerAccess" })
/* WeakerAccess for synthetic access */
void setCurrentMediaItemLocked(MediaMetadataCompat metadata) {
    mMediaMetadataCompat = metadata;
    if (metadata == null) {
        mCurrentMediaItemIndex = -1;
        mCurrentMediaItem = null;
        return;
    }
    if (mPlaybackStateCompat != null) {
        // If playback state is updated before, compare use queue id and media id.
        long queueId = mPlaybackStateCompat.getActiveQueueItemId();
        for (int i = 0; i < mQueue.size(); ++i) {
            QueueItem item = mQueue.get(i);
            if (item.getQueueId() == queueId) {
                mCurrentMediaItem = MediaUtils2.convertToMediaItem2(metadata);
                mCurrentMediaItemIndex = i;
                return;
            }
        }
    }
    String mediaId = metadata.getString(METADATA_KEY_MEDIA_ID);
    if (mediaId == null) {
        mCurrentMediaItemIndex = -1;
        mCurrentMediaItem = MediaUtils2.convertToMediaItem2(metadata);
        return;
    }
    // Note that there can be multiple media items with the same media id.
    if (mSkipToPlaylistIndex >= 0 && mSkipToPlaylistIndex < mQueue.size() && TextUtils.equals(mediaId, mQueue.get(mSkipToPlaylistIndex).getDescription().getMediaId())) {
        // metadata changed after skipToPlaylistIItem() was called.
        mCurrentMediaItem = MediaUtils2.convertToMediaItem2(metadata);
        mCurrentMediaItemIndex = mSkipToPlaylistIndex;
        mSkipToPlaylistIndex = -1;
        return;
    }
    // Find mediaId from the playlist.
    for (int i = 0; i < mQueue.size(); ++i) {
        QueueItem item = mQueue.get(i);
        if (TextUtils.equals(mediaId, item.getDescription().getMediaId())) {
            mCurrentMediaItemIndex = i;
            mCurrentMediaItem = MediaUtils2.convertToMediaItem2(metadata);
            return;
        }
    }
    // Failed to find media item from the playlist.
    mCurrentMediaItemIndex = -1;
    mCurrentMediaItem = MediaUtils2.convertToMediaItem2(mMediaMetadataCompat);
}
#method_after
@SuppressWarnings({ "GuardedBy", "WeakerAccess" })
/* WeakerAccess for synthetic access */
void setCurrentMediaItemLocked(MediaMetadataCompat metadata) {
    mMediaMetadataCompat = metadata;
    if (metadata == null) {
        mCurrentMediaItemIndex = -1;
        mCurrentMediaItem = null;
        return;
    }
    if (mQueue == null) {
        mCurrentMediaItemIndex = -1;
        mCurrentMediaItem = MediaUtils2.convertToMediaItem2(metadata);
        return;
    }
    if (mPlaybackStateCompat != null) {
        // If playback state is updated before, compare use queue id and media id.
        long queueId = mPlaybackStateCompat.getActiveQueueItemId();
        for (int i = 0; i < mQueue.size(); ++i) {
            QueueItem item = mQueue.get(i);
            if (item.getQueueId() == queueId) {
                mCurrentMediaItem = MediaUtils2.convertToMediaItem2(metadata);
                mCurrentMediaItemIndex = i;
                return;
            }
        }
    }
    String mediaId = metadata.getString(METADATA_KEY_MEDIA_ID);
    if (mediaId == null) {
        mCurrentMediaItemIndex = -1;
        mCurrentMediaItem = MediaUtils2.convertToMediaItem2(metadata);
        return;
    }
    // Note that there can be multiple media items with the same media id.
    if (mSkipToPlaylistIndex >= 0 && mSkipToPlaylistIndex < mQueue.size() && TextUtils.equals(mediaId, mQueue.get(mSkipToPlaylistIndex).getDescription().getMediaId())) {
        // metadata changed after skipToPlaylistIItem() was called.
        mCurrentMediaItem = MediaUtils2.convertToMediaItem2(metadata);
        mCurrentMediaItemIndex = mSkipToPlaylistIndex;
        mSkipToPlaylistIndex = -1;
        return;
    }
    // Find mediaId from the playlist.
    for (int i = 0; i < mQueue.size(); ++i) {
        QueueItem item = mQueue.get(i);
        if (TextUtils.equals(mediaId, item.getDescription().getMediaId())) {
            mCurrentMediaItemIndex = i;
            mCurrentMediaItem = MediaUtils2.convertToMediaItem2(metadata);
            return;
        }
    }
    // Failed to find media item from the playlist.
    mCurrentMediaItemIndex = -1;
    mCurrentMediaItem = MediaUtils2.convertToMediaItem2(mMediaMetadataCompat);
}
#end_block

#method_before
@Override
public void onQueueChanged(List<QueueItem> queue) {
    final List<MediaItem2> playlist;
    final MediaMetadata2 playlistMetadata;
    synchronized (mLock) {
        mQueue = queue;
        if (mQueue != null) {
            mPlaylist = MediaUtils2.convertQueueItemListToMediaItem2List(queue);
        } else {
            // MediaSessionCompat can set queue as null. However, SessionPlayer2 should not
            // set playlist as null. Therefore, we treat a null queue as an empty playlist.
            mQueue = new ArrayList<>();
            mPlaylist = new ArrayList<>();
        }
        playlist = mPlaylist;
        playlistMetadata = mPlaylistMetadata;
    }
    mCallbackExecutor.execute(new Runnable() {

        @Override
        public void run() {
            mCallback.onPlaylistChanged(mInstance, playlist, playlistMetadata);
        }
    });
}
#method_after
@Override
public void onQueueChanged(List<QueueItem> queue) {
    final List<MediaItem2> playlist;
    final MediaMetadata2 playlistMetadata;
    synchronized (mLock) {
        mQueue = MediaUtils2.removeNullElements(queue);
        if (mQueue == null || mQueue.size() == 0) {
            // MediaSessionCompat can set queue as null or empty. However, SessionPlayer2
            // should not set playlist as null or empty. Therefore, we treat them as the
            // same.
            mQueue = null;
            mPlaylist = null;
        } else {
            mPlaylist = MediaUtils2.convertQueueItemListToMediaItem2List(mQueue);
        }
        playlist = mPlaylist;
        playlistMetadata = mPlaylistMetadata;
    }
    mCallbackExecutor.execute(new Runnable() {

        @Override
        public void run() {
            mCallback.onPlaylistChanged(mInstance, playlist, playlistMetadata);
        }
    });
}
#end_block

#method_before
@NonNull
public CommandButton build() {
    return new CommandButton(mCommand, mIconResId, mDisplayName, mExtras, mEnabled);
}
#method_after
@Override
@NonNull
public MediaSession2 build() {
    if (mCallbackExecutor == null) {
        mCallbackExecutor = ContextCompat.getMainExecutor(mContext);
    }
    if (mCallback == null) {
        mCallback = new SessionCallback() {
        };
    }
    return new MediaSession2(mContext, mId, mPlayer, mSessionActivity, mCallbackExecutor, mCallback);
}
#end_block

#method_before
public ListenableFuture<ControllerResult> fastForward() {
    if (isConnected()) {
        return getImpl().fastForward();
    }
    return createDisconnectedFuture();
}
#method_after
@NonNull
public ListenableFuture<ControllerResult> fastForward() {
    if (isConnected()) {
        return getImpl().fastForward();
    }
    return createDisconnectedFuture();
}
#end_block

#method_before
public ListenableFuture<ControllerResult> rewind() {
    if (isConnected()) {
        return getImpl().rewind();
    }
    return createDisconnectedFuture();
}
#method_after
@NonNull
public ListenableFuture<ControllerResult> rewind() {
    if (isConnected()) {
        return getImpl().rewind();
    }
    return createDisconnectedFuture();
}
#end_block

#method_before
@RestrictTo(LIBRARY_GROUP)
public ListenableFuture<ControllerResult> skipForward() {
    // To match with KEYCODE_MEDIA_SKIP_FORWARD
    if (isConnected()) {
        return getImpl().skipForward();
    }
    return createDisconnectedFuture();
}
#method_after
@NonNull
public ListenableFuture<ControllerResult> skipForward() {
    // To match with KEYCODE_MEDIA_SKIP_FORWARD
    if (isConnected()) {
        return getImpl().skipForward();
    }
    return createDisconnectedFuture();
}
#end_block

#method_before
@RestrictTo(LIBRARY_GROUP)
public ListenableFuture<ControllerResult> skipBackward() {
    // To match with KEYCODE_MEDIA_SKIP_BACKWARD
    if (isConnected()) {
        return getImpl().skipBackward();
    }
    return createDisconnectedFuture();
}
#method_after
@NonNull
public ListenableFuture<ControllerResult> skipBackward() {
    // To match with KEYCODE_MEDIA_SKIP_BACKWARD
    if (isConnected()) {
        return getImpl().skipBackward();
    }
    return createDisconnectedFuture();
}
#end_block

#method_before
public ListenableFuture<ControllerResult> addPlaylistItem(int index, @NonNull String mediaId) {
    if (index < 0) {
        throw new IllegalArgumentException("index shouldn't be negative");
    }
    if (TextUtils.isEmpty(mediaId)) {
        throw new IllegalArgumentException("mediaId shouldn't be empty");
    }
    if (isConnected()) {
        return getImpl().addPlaylistItem(index, mediaId);
    }
    return createDisconnectedFuture();
}
#method_after
public ListenableFuture<ControllerResult> addPlaylistItem(@IntRange(from = 0) int index, @NonNull String mediaId) {
    if (index < 0) {
        throw new IllegalArgumentException("index shouldn't be negative");
    }
    if (TextUtils.isEmpty(mediaId)) {
        throw new IllegalArgumentException("mediaId shouldn't be empty");
    }
    if (isConnected()) {
        return getImpl().addPlaylistItem(index, mediaId);
    }
    return createDisconnectedFuture();
}
#end_block

#method_before
public void onPlaylistChanged(@NonNull MediaController2 controller, @NonNull List<MediaItem2> list, @Nullable MediaMetadata2 metadata) {
}
#method_after
public void onPlaylistChanged(@NonNull MediaController2 controller, @Nullable List<MediaItem2> list, @Nullable MediaMetadata2 metadata) {
}
#end_block

#method_before
protected Executor getExecutor() {
    return AsyncTask.THREAD_POOL_EXECUTOR;
}
#method_after
@NonNull
protected Executor getExecutor() {
    return AsyncTask.THREAD_POOL_EXECUTOR;
}
#end_block

#method_before
@SuppressWarnings("unused")
public Cursor queryRecentDocuments(String rootId, String[] projection, Bundle queryArgs) throws FileNotFoundException {
    Cursor c = queryRecentDocuments(rootId, projection);
    c.getExtras().putStringArray(ContentResolver.EXTRA_HONORED_ARGS, new String[0]);
    return c;
}
#method_after
@SuppressWarnings("unused")
public Cursor queryRecentDocuments(String rootId, String[] projection, @Nullable Bundle queryArgs, @Nullable CancellationSignal signal) throws FileNotFoundException {
    Cursor c = queryRecentDocuments(rootId, projection);
    Bundle extras = new Bundle();
    c.setExtras(extras);
    extras.putStringArray(ContentResolver.EXTRA_HONORED_ARGS, new String[0]);
    return c;
}
#end_block

#method_before
@Override
public final Cursor query(Uri uri, String[] projection, Bundle queryArgs, CancellationSignal cancellationSignal) {
    try {
        switch(mMatcher.match(uri)) {
            case MATCH_ROOTS:
                return queryRoots(projection);
            case MATCH_RECENT:
                return queryRecentDocuments(getRootId(uri), projection, queryArgs);
            case MATCH_SEARCH:
                return querySearchDocuments(getRootId(uri), getSearchDocumentsQuery(uri), projection);
            case MATCH_DOCUMENT:
            case MATCH_DOCUMENT_TREE:
                enforceTree(uri);
                return queryDocument(getDocumentId(uri), projection);
            case MATCH_CHILDREN:
            case MATCH_CHILDREN_TREE:
                enforceTree(uri);
                if (DocumentsContract.isManageMode(uri)) {
                    // TODO: Update "ForManage" variant to support query args.
                    return queryChildDocumentsForManage(getDocumentId(uri), projection, getSortClause(queryArgs));
                } else {
                    return queryChildDocuments(getDocumentId(uri), projection, queryArgs);
                }
            default:
                throw new UnsupportedOperationException("Unsupported Uri " + uri);
        }
    } catch (FileNotFoundException e) {
        Log.w(TAG, "Failed during query", e);
        return null;
    }
}
#method_after
@Override
public final Cursor query(Uri uri, String[] projection, Bundle queryArgs, CancellationSignal cancellationSignal) {
    try {
        switch(mMatcher.match(uri)) {
            case MATCH_ROOTS:
                return queryRoots(projection);
            case MATCH_RECENT:
                return queryRecentDocuments(getRootId(uri), projection, queryArgs, cancellationSignal);
            case MATCH_SEARCH:
                return querySearchDocuments(getRootId(uri), getSearchDocumentsQuery(uri), projection);
            case MATCH_DOCUMENT:
            case MATCH_DOCUMENT_TREE:
                enforceTree(uri);
                return queryDocument(getDocumentId(uri), projection);
            case MATCH_CHILDREN:
            case MATCH_CHILDREN_TREE:
                enforceTree(uri);
                if (DocumentsContract.isManageMode(uri)) {
                    // TODO: Update "ForManage" variant to support query args.
                    return queryChildDocumentsForManage(getDocumentId(uri), projection, getSortClause(queryArgs));
                } else {
                    return queryChildDocuments(getDocumentId(uri), projection, queryArgs);
                }
            default:
                throw new UnsupportedOperationException("Unsupported Uri " + uri);
        }
    } catch (FileNotFoundException e) {
        Log.w(TAG, "Failed during query", e);
        return null;
    }
}
#end_block

#method_before
private void testSharedSurfaceYUVImageReaderSwitch(String cameraId, int switchCount, int format, Size frameSize, boolean blockMaxAcquired) throws Exception {
    assertTrue("YUV_IMG_READER_COUNT should be equal or greater than 2", (YUV_IMG_READER_COUNT >= 2));
    SimpleImageListener[] imageListeners = new SimpleImageListener[YUV_IMG_READER_COUNT];
    SimpleCaptureCallback resultListener = new SimpleCaptureCallback();
    ImageReader[] imageReaders = new ImageReader[YUV_IMG_READER_COUNT];
    Surface[] readerSurfaces = new Surface[YUV_IMG_READER_COUNT];
    for (int i = 0; i < YUV_IMG_READER_COUNT; i++) {
        imageListeners[i] = new SimpleImageListener();
        imageReaders[i] = ImageReader.newInstance(frameSize.getWidth(), frameSize.getHeight(), format, 2);
        imageReaders[i].setOnImageAvailableListener(imageListeners[i], mHandler);
        readerSurfaces[i] = imageReaders[i].getSurface();
    }
    OutputConfiguration outputConfig = new OutputConfiguration(readerSurfaces[0]);
    outputConfig.enableSurfaceSharing();
    List<OutputConfiguration> outputConfigurations = new ArrayList<>();
    outputConfigurations.add(outputConfig);
    if (outputConfig.getMaxSharedSurfaceCount() < YUV_IMG_READER_COUNT) {
        return;
    }
    createSessionWithConfigs(cameraId, outputConfigurations);
    // Test YUV ImageReader surface sharing. The first ImageReader will
    // always be part of the capture request, the rest will switch on each
    // iteration.
    // If 'blockMaxAcquired' is enabled, the first image reader will acquire
    // the maximum possible amount of buffers and also block a few more.
    int maxAcquiredImages = imageReaders[0].getMaxImages();
    if (blockMaxAcquired && (maxAcquiredImages <= 0)) {
        return;
    }
    int acquiredCount = 0;
    Image[] acquiredImages = new Image[maxAcquiredImages];
    for (int j = 0; j < switchCount; j++) {
        for (int i = 1; i < YUV_IMG_READER_COUNT; i++) {
            outputConfig.addSurface(readerSurfaces[i]);
            updateOutputConfiguration(cameraId, outputConfig);
            CaptureRequest.Builder imageReaderRequestBuilder = getCaptureBuilder(cameraId, CameraDevice.TEMPLATE_PREVIEW);
            imageReaderRequestBuilder.addTarget(readerSurfaces[i]);
            if (blockMaxAcquired) {
                if (acquiredCount <= (maxAcquiredImages + 1)) {
                    // Camera should be able to handle cases where
                    // one output blocks more buffers than the respective
                    // maximum acquired count.
                    imageReaderRequestBuilder.addTarget(readerSurfaces[0]);
                }
            } else {
                imageReaderRequestBuilder.addTarget(readerSurfaces[0]);
            }
            capture(cameraId, imageReaderRequestBuilder.build(), resultListener);
            imageListeners[i].waitForAnyImageAvailable(PREVIEW_TIME_MS);
            Image img = imageReaders[i].acquireLatestImage();
            assertNotNull("Invalid image acquired!", img);
            assertNotNull("Image planes are invalid!", img.getPlanes());
            img.close();
            if (blockMaxAcquired) {
                if (acquiredCount < maxAcquiredImages) {
                    imageListeners[0].waitForAnyImageAvailable(PREVIEW_TIME_MS);
                    acquiredImages[acquiredCount] = imageReaders[0].acquireNextImage();
                }
                acquiredCount++;
            } else {
                imageListeners[0].waitForAnyImageAvailable(PREVIEW_TIME_MS);
                img = imageReaders[0].acquireLatestImage();
                assertNotNull("Invalid image acquired!", img);
                img.close();
            }
            outputConfig.removeSurface(readerSurfaces[i]);
            updateOutputConfiguration(cameraId, outputConfig);
        }
    }
    for (int i = 0; i < YUV_IMG_READER_COUNT; i++) {
        imageReaders[i].close();
    }
}
#method_after
private void testSharedSurfaceYUVImageReaderSwitch(String cameraId, int switchCount, int format, Size frameSize, boolean blockMaxAcquired) throws Exception {
    assertTrue("YUV_IMG_READER_COUNT should be equal or greater than 2", (YUV_IMG_READER_COUNT >= 2));
    SimpleImageListener[] imageListeners = new SimpleImageListener[YUV_IMG_READER_COUNT];
    SimpleCaptureCallback resultListener = new SimpleCaptureCallback();
    ImageReader[] imageReaders = new ImageReader[YUV_IMG_READER_COUNT];
    Surface[] readerSurfaces = new Surface[YUV_IMG_READER_COUNT];
    for (int i = 0; i < YUV_IMG_READER_COUNT; i++) {
        imageListeners[i] = new SimpleImageListener();
        imageReaders[i] = ImageReader.newInstance(frameSize.getWidth(), frameSize.getHeight(), format, 2);
        imageReaders[i].setOnImageAvailableListener(imageListeners[i], mHandler);
        readerSurfaces[i] = imageReaders[i].getSurface();
    }
    OutputConfiguration outputConfig = new OutputConfiguration(readerSurfaces[0]);
    outputConfig.enableSurfaceSharing();
    List<OutputConfiguration> outputConfigurations = new ArrayList<>();
    outputConfigurations.add(outputConfig);
    if (outputConfig.getMaxSharedSurfaceCount() < YUV_IMG_READER_COUNT) {
        return;
    }
    createSessionWithConfigs(cameraId, outputConfigurations);
    // Test YUV ImageReader surface sharing. The first ImageReader will
    // always be part of the capture request, the rest will switch on each
    // iteration.
    // If 'blockMaxAcquired' is enabled, the first image reader will acquire
    // the maximum possible amount of buffers and also block a few more.
    int maxAcquiredImages = imageReaders[0].getMaxImages();
    int acquiredCount = 0;
    Image[] acquiredImages = new Image[maxAcquiredImages];
    for (int j = 0; j < switchCount; j++) {
        for (int i = 1; i < YUV_IMG_READER_COUNT; i++) {
            outputConfig.addSurface(readerSurfaces[i]);
            updateOutputConfiguration(cameraId, outputConfig);
            CaptureRequest.Builder imageReaderRequestBuilder = getCaptureBuilder(cameraId, CameraDevice.TEMPLATE_PREVIEW);
            imageReaderRequestBuilder.addTarget(readerSurfaces[i]);
            if (blockMaxAcquired) {
                if (acquiredCount <= (maxAcquiredImages + 1)) {
                    // Camera should be able to handle cases where
                    // one output blocks more buffers than the respective
                    // maximum acquired count.
                    imageReaderRequestBuilder.addTarget(readerSurfaces[0]);
                }
            } else {
                imageReaderRequestBuilder.addTarget(readerSurfaces[0]);
            }
            capture(cameraId, imageReaderRequestBuilder.build(), resultListener);
            imageListeners[i].waitForAnyImageAvailable(PREVIEW_TIME_MS);
            Image img = imageReaders[i].acquireLatestImage();
            assertNotNull("Invalid image acquired!", img);
            assertNotNull("Image planes are invalid!", img.getPlanes());
            img.close();
            if (blockMaxAcquired) {
                if (acquiredCount < maxAcquiredImages) {
                    imageListeners[0].waitForAnyImageAvailable(PREVIEW_TIME_MS);
                    acquiredImages[acquiredCount] = imageReaders[0].acquireNextImage();
                }
                acquiredCount++;
            } else {
                imageListeners[0].waitForAnyImageAvailable(PREVIEW_TIME_MS);
                img = imageReaders[0].acquireLatestImage();
                assertNotNull("Invalid image acquired!", img);
                img.close();
            }
            outputConfig.removeSurface(readerSurfaces[i]);
            updateOutputConfiguration(cameraId, outputConfig);
        }
    }
    for (int i = 0; i < YUV_IMG_READER_COUNT; i++) {
        imageReaders[i].close();
    }
}
#end_block

#method_before
@Test
public void testGettersAfterConnected() throws InterruptedException {
    prepareLooper();
    final int state = SessionPlayer2.PLAYER_STATE_PLAYING;
    final int bufferingState = SessionPlayer2.BUFFERING_STATE_BUFFERING_COMPLETE;
    final long position = 150000;
    final long bufferedPosition = 900000;
    final float speed = 0.5f;
    final long timeDiff = 102;
    final MediaItem2 currentMediaItem = TestUtils.createMediaItemWithMetadata();
    mPlayer.mLastPlayerState = state;
    mPlayer.mLastBufferingState = bufferingState;
    mPlayer.mCurrentPosition = position;
    mPlayer.mBufferedPosition = bufferedPosition;
    mPlayer.mPlaybackSpeed = speed;
    mPlayer.mCurrentMediaItem = currentMediaItem;
    MediaController2 controller = createController(mSession.getToken());
    controller.setTimeDiff(timeDiff);
    assertEquals(state, controller.getPlayerState());
    assertEquals(bufferedPosition, controller.getBufferedPosition());
    assertEquals(speed, controller.getPlaybackSpeed(), 0.0f);
    assertEquals(position + (long) (speed * timeDiff), controller.getCurrentPosition());
    assertEquals(currentMediaItem, controller.getCurrentMediaItem());
}
#method_after
@Test
public void testGettersAfterConnected() throws InterruptedException {
    prepareLooper();
    final int state = SessionPlayer2.PLAYER_STATE_PLAYING;
    final int bufferingState = SessionPlayer2.BUFFERING_STATE_COMPLETE;
    final long position = 150000;
    final long bufferedPosition = 900000;
    final float speed = 0.5f;
    final long timeDiff = 102;
    final MediaItem2 currentMediaItem = TestUtils.createMediaItemWithMetadata();
    mPlayer.mLastPlayerState = state;
    mPlayer.mLastBufferingState = bufferingState;
    mPlayer.mCurrentPosition = position;
    mPlayer.mBufferedPosition = bufferedPosition;
    mPlayer.mPlaybackSpeed = speed;
    mPlayer.mCurrentMediaItem = currentMediaItem;
    MediaController2 controller = createController(mSession.getToken());
    controller.setTimeDiff(timeDiff);
    assertEquals(state, controller.getPlayerState());
    assertEquals(bufferedPosition, controller.getBufferedPosition());
    assertEquals(speed, controller.getPlaybackSpeed(), 0.0f);
    assertEquals(position + (long) (speed * timeDiff), controller.getCurrentPosition());
    assertEquals(currentMediaItem, controller.getCurrentMediaItem());
}
#end_block

#method_before
@Override
@SuppressLint("WrongConstant")
public void updatePlayer(@NonNull SessionPlayer2 player) {
    if (player == null) {
        throw new IllegalArgumentException("player shouldn't be null");
    }
    final boolean isPlaybackInfoChanged;
    final SessionPlayer2 oldPlayer;
    final PlaybackInfo info = createPlaybackInfo(player, null);
    synchronized (mLock) {
        isPlaybackInfoChanged = !info.equals(mPlaybackInfo);
        oldPlayer = mPlayer;
        mPlayer = player;
        mPlaybackInfo = info;
        if (oldPlayer != mPlayer) {
            if (oldPlayer != null) {
                oldPlayer.unregisterPlayerCallback(mPlayerCallback);
            }
            mPlayer.registerPlayerCallback(mCallbackExecutor, mPlayerCallback);
        }
    }
    if (oldPlayer == null) {
        // updatePlayerConnector() is called inside of the constructor.
        // There's no connected controllers at this moment, so just initialize session compat's
        // playback state. Otherwise, framework doesn't know whether this is ready to receive
        // media key event.
        mSessionCompat.setPlaybackState(createPlaybackStateCompat());
    } else {
        if (player != oldPlayer) {
            final int state = getPlayerState();
            mCallbackExecutor.execute(new Runnable() {

                @Override
                public void run() {
                    mCallback.onPlayerStateChanged(getInstance(), state);
                }
            });
            notifyPlayerUpdatedNotLocked(oldPlayer);
        }
        if (isPlaybackInfoChanged) {
            notifyPlaybackInfoChangedNotLocked(info);
        }
    }
    if (player instanceof RemoteSessionPlayer2) {
        final RemoteSessionPlayer2 remotePlayer = (RemoteSessionPlayer2) player;
        VolumeProviderCompat volumeProvider = new VolumeProviderCompat(remotePlayer.getVolumeControlType(), remotePlayer.getMaxVolume(), remotePlayer.getVolume()) {

            @Override
            public void onSetVolumeTo(int volume) {
                remotePlayer.setVolume(volume);
            }

            @Override
            public void onAdjustVolume(int direction) {
                remotePlayer.adjustVolume(direction);
            }
        };
        mSessionCompat.setPlaybackToRemote(volumeProvider);
    } else {
        int stream = getLegacyStreamType(player.getAudioAttributes());
        mSessionCompat.setPlaybackToLocal(stream);
    }
}
#method_after
@Override
@SuppressLint("WrongConstant")
public void updatePlayer(@NonNull SessionPlayer2 player) {
    final boolean isPlaybackInfoChanged;
    final SessionPlayer2 oldPlayer;
    final PlaybackInfo info = createPlaybackInfo(player, null);
    synchronized (mLock) {
        isPlaybackInfoChanged = !info.equals(mPlaybackInfo);
        oldPlayer = mPlayer;
        mPlayer = player;
        mPlaybackInfo = info;
        if (oldPlayer != mPlayer) {
            if (oldPlayer != null) {
                oldPlayer.unregisterPlayerCallback(mPlayerCallback);
            }
            mPlayer.registerPlayerCallback(mCallbackExecutor, mPlayerCallback);
        }
    }
    if (oldPlayer == null) {
        // updatePlayerConnector() is called inside of the constructor.
        // There's no connected controllers at this moment, so just initialize session compat's
        // playback state. Otherwise, framework doesn't know whether this is ready to receive
        // media key event.
        mSessionCompat.setPlaybackState(createPlaybackStateCompat());
    } else {
        if (player != oldPlayer) {
            final int state = getPlayerState();
            mCallbackExecutor.execute(new Runnable() {

                @Override
                public void run() {
                    mCallback.onPlayerStateChanged(getInstance(), state);
                }
            });
            notifyPlayerUpdatedNotLocked(oldPlayer);
        }
        if (isPlaybackInfoChanged) {
            notifyPlaybackInfoChangedNotLocked(info);
        }
    }
    if (player instanceof RemoteSessionPlayer2) {
        final RemoteSessionPlayer2 remotePlayer = (RemoteSessionPlayer2) player;
        VolumeProviderCompat volumeProvider = new VolumeProviderCompat(remotePlayer.getVolumeControlType(), remotePlayer.getMaxVolume(), remotePlayer.getVolume()) {

            @Override
            public void onSetVolumeTo(int volume) {
                remotePlayer.setVolume(volume);
            }

            @Override
            public void onAdjustVolume(int direction) {
                remotePlayer.adjustVolume(direction);
            }
        };
        mSessionCompat.setPlaybackToRemote(volumeProvider);
    } else {
        int stream = getLegacyStreamType(player.getAudioAttributes());
        mSessionCompat.setPlaybackToLocal(stream);
    }
}
#end_block

#method_before
@Override
public ListenableFuture<SessionResult> setCustomLayout(@NonNull ControllerInfo controller, @NonNull final List<MediaSession2.CommandButton> layout) {
    if (controller == null) {
        throw new IllegalArgumentException("controller shouldn't be null");
    }
    if (layout == null) {
        throw new IllegalArgumentException("layout shouldn't be null");
    }
    return dispatchRemoteControllerTask(controller, new RemoteControllerTask() {

        @Override
        public void run(ControllerCb controller, int seq) throws RemoteException {
            controller.setCustomLayout(seq, layout);
        }
    });
}
#method_after
@Override
public ListenableFuture<SessionResult> setCustomLayout(@NonNull ControllerInfo controller, @NonNull final List<MediaSession2.CommandButton> layout) {
    return dispatchRemoteControllerTask(controller, new RemoteControllerTask() {

        @Override
        public void run(ControllerCb controller, int seq) throws RemoteException {
            controller.setCustomLayout(seq, layout);
        }
    });
}
#end_block

#method_before
@Override
public void setAllowedCommands(@NonNull ControllerInfo controller, @NonNull final SessionCommandGroup2 commands) {
    if (controller == null) {
        throw new IllegalArgumentException("controller shouldn't be null");
    }
    if (commands == null) {
        throw new IllegalArgumentException("commands shouldn't be null");
    }
    if (mSession2Stub.getConnectedControllersManager().isConnected(controller)) {
        mSession2Stub.getConnectedControllersManager().updateAllowedCommands(controller, commands);
        dispatchRemoteControllerCallbackTask(controller, new RemoteControllerCallbackTask() {

            @Override
            public void run(ControllerCb callback) throws RemoteException {
                callback.onAllowedCommandsChanged(commands);
            }
        });
    } else {
        mSessionLegacyStub.getConnectedControllersManager().updateAllowedCommands(controller, commands);
    }
}
#method_after
@Override
public void setAllowedCommands(@NonNull ControllerInfo controller, @NonNull final SessionCommandGroup2 commands) {
    if (mSession2Stub.getConnectedControllersManager().isConnected(controller)) {
        mSession2Stub.getConnectedControllersManager().updateAllowedCommands(controller, commands);
        dispatchRemoteControllerCallbackTask(controller, new RemoteControllerCallbackTask() {

            @Override
            public void run(ControllerCb callback) throws RemoteException {
                callback.onAllowedCommandsChanged(commands);
            }
        });
    } else {
        mSessionLegacyStub.getConnectedControllersManager().updateAllowedCommands(controller, commands);
    }
}
#end_block

#method_before
@Override
public void broadcastCustomCommand(@NonNull final SessionCommand2 command, @Nullable final Bundle args) {
    if (command == null) {
        throw new IllegalArgumentException("command shouldn't be null");
    }
    dispatchRemoteControllerTask(new RemoteControllerTask() {

        @Override
        public void run(ControllerCb controller, int seq) throws RemoteException {
            controller.sendCustomCommand(seq, command, args);
        }
    });
}
#method_after
@Override
public void broadcastCustomCommand(@NonNull final SessionCommand2 command, @Nullable final Bundle args) {
    dispatchRemoteControllerTask(new RemoteControllerTask() {

        @Override
        public void run(ControllerCb controller, int seq) throws RemoteException {
            controller.sendCustomCommand(seq, command, args);
        }
    });
}
#end_block

#method_before
@Override
public ListenableFuture<SessionResult> sendCustomCommand(@NonNull ControllerInfo controller, @NonNull final SessionCommand2 command, @Nullable final Bundle args) {
    if (controller == null) {
        throw new IllegalArgumentException("controller shouldn't be null");
    }
    if (command == null) {
        throw new IllegalArgumentException("command shouldn't be null");
    }
    return dispatchRemoteControllerTask(controller, new RemoteControllerTask() {

        @Override
        public void run(ControllerCb controller, int seq) throws RemoteException {
            controller.sendCustomCommand(seq, command, args);
        }
    });
}
#method_after
@Override
public ListenableFuture<SessionResult> sendCustomCommand(@NonNull ControllerInfo controller, @NonNull final SessionCommand2 command, @Nullable final Bundle args) {
    return dispatchRemoteControllerTask(controller, new RemoteControllerTask() {

        @Override
        public void run(ControllerCb controller, int seq) throws RemoteException {
            controller.sendCustomCommand(seq, command, args);
        }
    });
}
#end_block

#method_before
@Override
public ListenableFuture<PlayerResult> play() {
    return dispatchPlayerTask(new PlayerTask<ListenableFuture<PlayerResult>>() {

        @Override
        public ListenableFuture<PlayerResult> run(SessionPlayer2 player) throws Exception {
            if (player.getPlayerState() != PLAYER_STATE_IDLE) {
                return player.play();
            }
            final ListenableFuture<PlayerResult> prepareFuture = player.prefetch();
            final ListenableFuture<PlayerResult> playFuture = player.play();
            if (prepareFuture == null || playFuture == null) {
                // Let dispatchPlayerTask() handle such cases.
                return null;
            }
            return XMediaPlayer.CombindedCommandResultFuture.create(DIRECT_EXECUTOR, prepareFuture, playFuture);
        }
    });
}
#method_after
@Override
public ListenableFuture<PlayerResult> play() {
    return dispatchPlayerTask(new PlayerTask<ListenableFuture<PlayerResult>>() {

        @Override
        public ListenableFuture<PlayerResult> run(SessionPlayer2 player) throws Exception {
            if (player.getPlayerState() != PLAYER_STATE_IDLE) {
                return player.play();
            }
            final ListenableFuture<PlayerResult> prepareFuture = player.prepare();
            final ListenableFuture<PlayerResult> playFuture = player.play();
            if (prepareFuture == null || playFuture == null) {
                // Let dispatchPlayerTask() handle such cases.
                return null;
            }
            return XMediaPlayer.CombindedCommandResultFuture.create(DIRECT_EXECUTOR, prepareFuture, playFuture);
        }
    });
}
#end_block

#method_before
@Override
public ListenableFuture<PlayerResult> prefetch() {
    return dispatchPlayerTask(new PlayerTask<ListenableFuture<PlayerResult>>() {

        @Override
        public ListenableFuture<PlayerResult> run(SessionPlayer2 player) throws Exception {
            return player.prefetch();
        }
    });
}
#method_after
@Override
public ListenableFuture<PlayerResult> prefetch() {
    return dispatchPlayerTask(new PlayerTask<ListenableFuture<PlayerResult>>() {

        @Override
        public ListenableFuture<PlayerResult> run(SessionPlayer2 player) throws Exception {
            return player.prepare();
        }
    });
}
#end_block

#method_before
private ListenableFuture<SessionResult> dispatchRemoteControllerTask(@NonNull ControllerInfo controller, @NonNull RemoteControllerTask task) {
    if (!isConnected(controller)) {
        return SessionResult.createFutureWithResult(RESULT_CODE_DISCONNECTED);
    }
    try {
        final ListenableFuture<SessionResult> future;
        final int seq;
        final SequencedFutureManager manager = mSession2Stub.getConnectedControllersManager().getSequencedFutureManager(controller);
        if (manager != null) {
            future = manager.createSequencedFuture();
            seq = ((SequencedFuture<SessionResult>) future).getSequenceNumber();
        } else {
            // Can be null in two cases. Use the 0 as sequence number in both cases because
            // Case 1) Controller is from the legacy stub
            // -> Sequence number isn't needed, so 0 is OK
            // Case 2) Controller is removed after the connection check above
            // -> Call will fail below or ignored by the controller, so 0 is OK.
            seq = 0;
            future = SessionResult.createFutureWithResult(RESULT_CODE_SUCCESS);
        }
        task.run(controller.getControllerCb(), seq);
        return future;
    } catch (DeadObjectException e) {
        onDeadObjectException(controller, e);
        return SessionResult.createFutureWithResult(RESULT_CODE_DISCONNECTED);
    } catch (RemoteException e) {
        // Currently it's TransactionTooLargeException or DeadSystemException.
        // We'd better to leave log for those cases because
        // - TransactionTooLargeException means that we may need to fix our code.
        // (e.g. add pagination or special way to deliver Bitmap)
        // - DeadSystemException means that errors around it can be ignored.
        Log.w(TAG, "Exception in " + controller.toString(), e);
    }
    return SessionResult.createFutureWithResult(RESULT_CODE_UNKNOWN_ERROR);
}
#method_after
private ListenableFuture<SessionResult> dispatchRemoteControllerTask(@NonNull ControllerInfo controller, @NonNull RemoteControllerTask task) {
    if (!isConnected(controller)) {
        return SessionResult.createFutureWithResult(RESULT_CODE_DISCONNECTED);
    }
    try {
        final ListenableFuture<SessionResult> future;
        final int seq;
        final SequencedFutureManager manager = mSession2Stub.getConnectedControllersManager().getSequencedFutureManager(controller);
        if (manager != null) {
            future = manager.createSequencedFuture(RESULT_WHEN_CLOSED);
            seq = ((SequencedFuture<SessionResult>) future).getSequenceNumber();
        } else {
            // Can be null in two cases. Use the 0 as sequence number in both cases because
            // Case 1) Controller is from the legacy stub
            // -> Sequence number isn't needed, so 0 is OK
            // Case 2) Controller is removed after the connection check above
            // -> Call will fail below or ignored by the controller, so 0 is OK.
            seq = 0;
            future = SessionResult.createFutureWithResult(RESULT_CODE_SUCCESS);
        }
        task.run(controller.getControllerCb(), seq);
        return future;
    } catch (DeadObjectException e) {
        onDeadObjectException(controller, e);
        return SessionResult.createFutureWithResult(RESULT_CODE_DISCONNECTED);
    } catch (RemoteException e) {
        // Currently it's TransactionTooLargeException or DeadSystemException.
        // We'd better to leave log for those cases because
        // - TransactionTooLargeException means that we may need to fix our code.
        // (e.g. add pagination or special way to deliver Bitmap)
        // - DeadSystemException means that errors around it can be ignored.
        Log.w(TAG, "Exception in " + controller.toString(), e);
    }
    return SessionResult.createFutureWithResult(RESULT_CODE_UNKNOWN_ERROR);
}
#end_block

#method_before
@Override
public void onCurrentMediaItemChanged(final SessionPlayer2 player, final MediaItem2 item) {
    final MediaSession2ImplBase session = getSession();
    if (session == null || session.getPlayer() != player || player == null) {
        return;
    }
    synchronized (session.mLock) {
        if (mMediaItem != null) {
            mMediaItem.unregisterCallback(mMediaItemCallback);
        }
        if (item != null) {
            item.registerCallback(mMediaItemCallback);
        }
        mMediaItem = item;
    }
    // Note: No sanity check whether the item is in the playlist.
    updateDurationIfNeeded(player, item);
    session.dispatchRemoteControllerCallbackTask(new RemoteControllerCallbackTask() {

        @Override
        public void run(ControllerCb callback) throws RemoteException {
            callback.onCurrentMediaItemChanged(item);
        }
    });
}
#method_after
@Override
public void onCurrentMediaItemChanged(final SessionPlayer2 player, final MediaItem2 item) {
    final MediaSession2ImplBase session = getSession();
    if (session == null || session.getPlayer() != player || player == null) {
        return;
    }
    synchronized (session.mLock) {
        if (mMediaItem != null) {
            mMediaItem.removeOnMetadataChangedListener(mCurrentItemChangedListener);
        }
        if (item != null) {
            item.addOnMetadataChangedListener(session.mCallbackExecutor, mCurrentItemChangedListener);
        }
        mMediaItem = item;
    }
    // Note: No sanity check whether the item is in the playlist.
    updateDurationIfNeeded(player, item);
    session.dispatchRemoteControllerCallbackTask(new RemoteControllerCallbackTask() {

        @Override
        public void run(ControllerCb callback) throws RemoteException {
            callback.onCurrentMediaItemChanged(item);
        }
    });
}
#end_block

#method_before
@Override
public void onPlaylistChanged(final SessionPlayer2 player, final List<MediaItem2> list, final MediaMetadata2 metadata) {
    final MediaSession2ImplBase session = getSession();
    if (session == null || session.getPlayer() != player || player == null) {
        return;
    }
    synchronized (session.mLock) {
        if (mList != null) {
            for (int i = 0; i < mList.size(); i++) {
                mList.get(i).unregisterCallback(mMediaItemCallback);
            }
        }
        if (list != null) {
            for (int i = 0; i < list.size(); i++) {
                list.get(i).registerCallback(mMediaItemCallback);
            }
        }
        mList = list;
    }
    dispatchRemoteControllerTask(player, new RemoteControllerCallbackTask() {

        @Override
        public void run(ControllerCb callback) throws RemoteException {
            callback.onPlaylistChanged(list, metadata);
        }
    });
}
#method_after
@Override
public void onPlaylistChanged(final SessionPlayer2 player, final List<MediaItem2> list, final MediaMetadata2 metadata) {
    final MediaSession2ImplBase session = getSession();
    if (session == null || session.getPlayer() != player || player == null) {
        return;
    }
    synchronized (session.mLock) {
        if (mList != null) {
            for (int i = 0; i < mList.size(); i++) {
                mList.get(i).removeOnMetadataChangedListener(mPlaylistItemChangedListener);
            }
        }
        if (list != null) {
            for (int i = 0; i < list.size(); i++) {
                list.get(i).addOnMetadataChangedListener(session.mCallbackExecutor, mPlaylistItemChangedListener);
            }
        }
        mList = list;
    }
    dispatchRemoteControllerTask(player, new RemoteControllerCallbackTask() {

        @Override
        public void run(ControllerCb callback) throws RemoteException {
            callback.onPlaylistChanged(list, metadata);
        }
    });
}
#end_block

#method_before
@NonNull
public Builder putFloatArray(String key, @NonNull float[] value) {
    mValues.put(key, convertPrimitiveFloatArray(value));
    return this;
}
#method_after
@NonNull
public Builder putFloatArray(@NonNull String key, @NonNull float[] value) {
    mValues.put(key, convertPrimitiveFloatArray(value));
    return this;
}
#end_block

#method_before
// END Android-changed: Implement sleep() methods using a shared native implementation.
public static void sleep(long millis, int nanos) throws InterruptedException {
    /*
        if (millis < 0) {
            throw new IllegalArgumentException("timeout value is negative");
        }

        if (nanos < 0 || nanos > 999999) {
            throw new IllegalArgumentException(
                                "nanosecond timeout value out of range");
        }
        */
    if (millis < 0) {
        throw new IllegalArgumentException("millis < 0: " + millis);
    }
    if (nanos < 0) {
        throw new IllegalArgumentException("nanos < 0: " + nanos);
    }
    if (nanos > 999999) {
        throw new IllegalArgumentException("nanos > 999999: " + nanos);
    }
    // time...need not have observable effects."
    if (millis == 0 && nanos == 0) {
        // ...but we still have to handle being interrupted.
        if (Thread.interrupted()) {
            throw new InterruptedException();
        }
        return;
    }
    long start = System.nanoTime();
    long duration = (millis * NANOS_PER_MILLI) + nanos;
    Object lock = currentThread().lock;
    // early, so loop until sleep duration passes.
    synchronized (lock) {
        while (true) {
            sleep(lock, millis, nanos);
            long now = System.nanoTime();
            long elapsed = now - start;
            if (elapsed >= duration) {
                break;
            }
            duration -= elapsed;
            start = now;
            millis = duration / NANOS_PER_MILLI;
            nanos = (int) (duration % NANOS_PER_MILLI);
        }
    }
// END Android-changed: Implement sleep() methods using a shared native implementation.
}
#method_after
// END Android-changed: Implement sleep() methods using a shared native implementation.
public static void sleep(long millis, int nanos) throws InterruptedException {
    /*
        if (millis < 0) {
            throw new IllegalArgumentException("timeout value is negative");
        }

        if (nanos < 0 || nanos > 999999) {
            throw new IllegalArgumentException(
                                "nanosecond timeout value out of range");
        }
        */
    if (millis < 0) {
        throw new IllegalArgumentException("millis < 0: " + millis);
    }
    if (nanos < 0) {
        throw new IllegalArgumentException("nanos < 0: " + nanos);
    }
    if (nanos > 999999) {
        throw new IllegalArgumentException("nanos > 999999: " + nanos);
    }
    // time...need not have observable effects."
    if (millis == 0 && nanos == 0) {
        // ...but we still have to handle being interrupted.
        if (Thread.interrupted()) {
            throw new InterruptedException();
        }
        return;
    }
    final int nanosPerMilli = 1000000;
    long start = System.nanoTime();
    long duration = (millis * nanosPerMilli) + nanos;
    Object lock = currentThread().lock;
    // early, so loop until sleep duration passes.
    synchronized (lock) {
        while (true) {
            sleep(lock, millis, nanos);
            long now = System.nanoTime();
            long elapsed = now - start;
            if (elapsed >= duration) {
                break;
            }
            duration -= elapsed;
            start = now;
            millis = duration / nanosPerMilli;
            nanos = (int) (duration % nanosPerMilli);
        }
    }
// END Android-changed: Implement sleep() methods using a shared native implementation.
}
#end_block

#method_before
@libcore.api.CorePlatformApi
public static void setUncaughtExceptionPreHandler(UncaughtExceptionHandler eh) {
    uncaughtExceptionPreHandler = eh;
}
#method_after
public static void setUncaughtExceptionPreHandler(UncaughtExceptionHandler eh) {
    uncaughtExceptionPreHandler = eh;
}
#end_block

#method_before
@libcore.api.CorePlatformApi
public static UncaughtExceptionHandler getUncaughtExceptionPreHandler() {
    return uncaughtExceptionPreHandler;
}
#method_after
public static UncaughtExceptionHandler getUncaughtExceptionPreHandler() {
    return uncaughtExceptionPreHandler;
}
#end_block

#method_before
@Override
public String getParsingExpression() {
    StringBuilder expression = new StringBuilder();
    if (list) {
        expression.append(String.format("%s value = %s;\n", getName(), "raw"));
        expression.append("for (auto token : android::base::Split(value,\"\\\\s+\")) {\n");
        expression.append(String.format("value.push_back(move(%s));\n", String.format(rawParsingExpression, "token")));
        expression.append("}\n");
    } else {
        expression.append(String.format("%s value = %s;\n", getName(), String.format(rawParsingExpression, "raw")));
    }
    return expression.toString();
}
#method_after
@Override
public String getParsingExpression() {
    StringBuilder expression = new StringBuilder();
    if (list) {
        expression.append(String.format("%s value;\n", getName()));
        expression.append("for (auto& token : android::base::Split(raw, \" \")) {\n");
        expression.append(String.format("value.push_back(std::move(%s));\n", String.format(rawParsingExpression, "token")));
        expression.append("}\n");
    } else {
        expression.append(String.format("%s value = %s;\n", getName(), String.format(rawParsingExpression, "raw")));
    }
    return expression.toString();
}
#end_block

#method_before
public static void main(String[] args) throws Exception {
    if (args.length != 4) {
        System.err.println("Failed - the number of arguments should be 3.");
        System.err.println("Usage: ./xsdc input_xsd_file package_name output_directory" + "language");
        exit(-1);
    }
    String xsdFile = args[0], packageName = args[1], outDir = args[2], language = args[3];
    XmlSchema xmlSchema;
    try (FileInputStream in = new FileInputStream(xsdFile)) {
        SAXParserFactory factory = SAXParserFactory.newInstance();
        factory.setNamespaceAware(true);
        SAXParser parser = factory.newSAXParser();
        XsdHandler xsdHandler = new XsdHandler();
        parser.parse(in, xsdHandler);
        xmlSchema = xsdHandler.getSchema();
    }
    if (language.equals("java")) {
        File packageDir = new File(Paths.get(outDir, packageName.replace(".", "/")).toString());
        packageDir.mkdirs();
        FileSystem fs = new FileSystem(packageDir);
        JavaCodeGenerator javaCodeGenerator = new JavaCodeGenerator(xmlSchema, packageName);
        javaCodeGenerator.print(fs);
    } else if (language.equals("cpp")) {
        File includeDir = new File(Paths.get(outDir, "include").toString());
        includeDir.mkdirs();
        FileSystem fs = new FileSystem(new File(outDir));
        CppCodeGenerator cppCodeGenerator = new CppCodeGenerator(xmlSchema, packageName.replace(".", "_"));
        cppCodeGenerator.print(fs);
    }
}
#method_after
public static void main(String[] args) throws Exception {
    Options options = new Options();
    options.addOption(OptionBuilder.withLongOpt("package").hasArgs(1).withDescription("Package name of the generated java file. " + "file name of generated cpp file and header").create("p"));
    options.addOption(OptionBuilder.withLongOpt("outDir").hasArgs(1).withDescription("Out Directory").create("o"));
    options.addOption(OptionBuilder.withLongOpt("java").hasArgs(0).withDescription("Generate Java code.").create("j"));
    options.addOption(OptionBuilder.withLongOpt("cpp").hasArgs(0).withDescription("Generate Cpp code.").create("c"));
    CommandLineParser CommandParser = new GnuParser();
    CommandLine cmd;
    try {
        cmd = CommandParser.parse(options, args);
    } catch (ParseException e) {
        System.err.println(e.getMessage());
        help(options);
        return;
    }
    String[] xsdFile = cmd.getArgs();
    String packageName = cmd.getOptionValue('p', null);
    String outDir = cmd.getOptionValue('o', null);
    if (xsdFile.length != 1 || packageName == null) {
        System.err.println("Error: no xsd files or pacakge name");
        help(options);
    }
    if (outDir == null) {
        outDir = ".";
    }
    XmlSchema xmlSchema;
    try (FileInputStream in = new FileInputStream(xsdFile[0])) {
        SAXParserFactory factory = SAXParserFactory.newInstance();
        factory.setNamespaceAware(true);
        SAXParser parser = factory.newSAXParser();
        XsdHandler xsdHandler = new XsdHandler();
        parser.parse(in, xsdHandler);
        xmlSchema = xsdHandler.getSchema();
    }
    if (cmd.hasOption('j')) {
        File packageDir = new File(Paths.get(outDir, packageName.replace(".", "/")).toString());
        packageDir.mkdirs();
        FileSystem fs = new FileSystem(packageDir);
        JavaCodeGenerator javaCodeGenerator = new JavaCodeGenerator(xmlSchema, packageName);
        javaCodeGenerator.print(fs);
    } else if (cmd.hasOption('c')) {
        File includeDir = new File(Paths.get(outDir, "include").toString());
        includeDir.mkdirs();
        FileSystem fs = new FileSystem(new File(outDir));
        CppCodeGenerator cppCodeGenerator = new CppCodeGenerator(xmlSchema, packageName.replace(".", "_"));
        cppCodeGenerator.print(fs);
    }
}
#end_block

#method_before
@Override
public String getParsingExpression() {
    return String.format("%s value = %sRead(child);\n", name, Utils.lowerize(name));
}
#method_after
@Override
public String getParsingExpression() {
    return String.format("%s value = %s::read(child);\n", name, name);
}
#end_block

#method_before
public void print(FileSystem fs) throws CppCodeGeneratorException, IOException {
    // cpp file, headr file init
    cppFile = new CodeWriter(fs.getPrintWriter(fileName + ".cpp"));
    headerFile = new CodeWriter(fs.getPrintWriter("include/" + fileName + ".h"));
    headerFile.printf("#ifndef %s_H\n", fileName.toUpperCase().replace(".", "_"));
    headerFile.printf("#define %s_H\n\n", fileName.toUpperCase().replace(".", "_"));
    headerFile.printf("#include <libxml/parser.h>\n");
    headerFile.printf("#include <libxml/xinclude.h>\n\n");
    headerFile.printf("#include <string>\n");
    headerFile.printf("#include <vector>\n\n");
    cppFile.printf("#define LOG_TAG \"%s\"\n\n", fileName);
    cppFile.printf("#include <android/log.h>\n\n");
    cppFile.printf("#include <libxml/parser.h>\n");
    cppFile.printf("#include <libxml/xinclude.h>\n\n");
    cppFile.printf("#include \"%s.h\"\n\n", fileName);
    printPrototype();
    printXmlParser();
    for (XsdType type : xmlSchema.getTypeMap().values()) {
        if (type instanceof XsdComplexType) {
            String name = Utils.toClassName(type.getName());
            XsdComplexType complexType = (XsdComplexType) type;
            printClass(name, complexType);
        }
    }
    for (XsdElement element : xmlSchema.getElementMap().values()) {
        XsdType type = element.getType();
        if (type.getRef() == null && type instanceof XsdComplexType) {
            String name = Utils.toClassName(element.getName());
            XsdComplexType complexType = (XsdComplexType) type;
            printClass(name, complexType);
        }
    }
    headerFile.printf("#endif // %s_H\n", fileName.toUpperCase().replace(".", "_"));
    cppFile.close();
    headerFile.close();
}
#method_after
public void print(FileSystem fs) throws CppCodeGeneratorException, IOException {
    // cpp file, headr file init
    cppFile = new CodeWriter(fs.getPrintWriter(fileName + ".cpp"));
    headerFile = new CodeWriter(fs.getPrintWriter("include/" + fileName + ".h"));
    headerFile.printf("#ifndef %s_H\n", fileName.toUpperCase().replace(".", "_"));
    headerFile.printf("#define %s_H\n\n", fileName.toUpperCase().replace(".", "_"));
    headerFile.printf("#include <libxml/parser.h>\n");
    headerFile.printf("#include <libxml/xinclude.h>\n\n");
    headerFile.printf("#include <string>\n");
    headerFile.printf("#include <vector>\n\n");
    cppFile.printf("#define LOG_TAG \"%s\"\n\n", fileName);
    cppFile.printf("#include <android/log.h>\n");
    cppFile.printf("#include <android-base/strings.h>\n\n");
    cppFile.printf("#include <libxml/parser.h>\n");
    cppFile.printf("#include <libxml/xinclude.h>\n\n");
    cppFile.printf("#include \"%s.h\"\n\n", fileName);
    printPrototype();
    printXmlParser();
    for (XsdType type : xmlSchema.getTypeMap().values()) {
        if (type instanceof XsdComplexType) {
            String name = Utils.toClassName(type.getName());
            XsdComplexType complexType = (XsdComplexType) type;
            printClass(name, "", complexType);
        }
    }
    for (XsdElement element : xmlSchema.getElementMap().values()) {
        XsdType type = element.getType();
        if (type.getRef() == null && type instanceof XsdComplexType) {
            String name = Utils.toClassName(element.getName());
            XsdComplexType complexType = (XsdComplexType) type;
            printClass(name, "", complexType);
        }
    }
    headerFile.printf("#endif // %s_H\n", fileName.toUpperCase().replace(".", "_"));
    cppFile.close();
    headerFile.close();
}
#end_block

#method_before
private void printPrototype() throws CppCodeGeneratorException {
    for (XsdType type : xmlSchema.getTypeMap().values()) {
        if (type instanceof XsdComplexType) {
            String name = Utils.toClassName(type.getName());
            headerFile.printf("class %s;\n", name);
            headerFile.printf("%s %sRead(xmlNode *root);\n\n", name, Utils.lowerize(name));
        }
    }
    for (XsdElement element : xmlSchema.getElementMap().values()) {
        XsdType type = element.getType();
        if (type.getRef() == null && type instanceof XsdComplexType) {
            String name = Utils.toClassName(element.getName());
            headerFile.printf("class %s;\n", name);
            headerFile.printf("%s %sRead(xmlNode *root);\n\n", name, Utils.lowerize(name));
        }
    }
}
#method_after
private void printPrototype() throws CppCodeGeneratorException {
    for (XsdType type : xmlSchema.getTypeMap().values()) {
        if (type instanceof XsdComplexType) {
            String name = Utils.toClassName(type.getName());
            headerFile.printf("class %s;\n", name);
        }
    }
    for (XsdElement element : xmlSchema.getElementMap().values()) {
        XsdType type = element.getType();
        if (type.getRef() == null && type instanceof XsdComplexType) {
            String name = Utils.toClassName(element.getName());
            headerFile.printf("class %s;\n", name);
        }
    }
}
#end_block

#method_before
private void printClass(String name, XsdComplexType complexType) throws CppCodeGeneratorException {
    assert name != null;
    // need element, attribute name duplicate validation?
    String baseName = getBaseName(complexType);
    CppSimpleType valueType = (complexType instanceof XsdSimpleContent) ? getValueType((XsdSimpleContent) complexType, false) : null;
    headerFile.printf("class %s ", name);
    if (baseName != null) {
        headerFile.printf(": public %s {\n", baseName);
    } else {
        headerFile.println("{");
    }
    // parse types for elements and attributes
    List<CppType> elementTypes = new ArrayList<>();
    for (XsdElement element : complexType.getElements()) {
        CppType cppType;
        XsdElement elementValue = resolveElement(element);
        if (element.getRef() == null && element.getType().getRef() == null && element.getType() instanceof XsdComplexType) {
            // print inner class for anonymous types
            String innerName = Utils.toClassName(element.getName());
            XsdComplexType innerType = (XsdComplexType) element.getType();
            printClass(innerName, innerType);
            headerFile.println();
            cppType = new CppComplexType(innerName);
        } else {
            cppType = parseType(elementValue.getType(), elementValue.getName());
        }
        elementTypes.add(cppType);
    }
    List<CppSimpleType> attributeTypes = new ArrayList<>();
    for (XsdAttribute attribute : complexType.getAttributes()) {
        XsdType type = resolveAttribute(attribute).getType();
        attributeTypes.add(parseSimpleType(type, false));
    }
    // print member variables
    headerFile.printf("private:\n");
    for (int i = 0; i < elementTypes.size(); ++i) {
        CppType type = elementTypes.get(i);
        XsdElement element = complexType.getElements().get(i);
        XsdElement elementValue = resolveElement(element);
        String typeName = String.format("std::vector<%s>", type.getName());
        headerFile.printf("%s %s;\n", typeName, Utils.toVariableName(elementValue.getName()));
    }
    for (int i = 0; i < attributeTypes.size(); ++i) {
        CppType type = attributeTypes.get(i);
        XsdAttribute attribute = resolveAttribute(complexType.getAttributes().get(i));
        headerFile.printf("%s %s;\n", type.getName(), Utils.toVariableName(attribute.getName()));
    }
    if (valueType != null) {
        headerFile.printf("%s value;\n", valueType.getName());
    }
    // print getters and setters
    headerFile.printf("public:\n");
    for (int i = 0; i < elementTypes.size(); ++i) {
        CppType type = elementTypes.get(i);
        XsdElement element = complexType.getElements().get(i);
        XsdElement elementValue = resolveElement(element);
        printGetterAndSetter(name, type, Utils.toVariableName(elementValue.getName()), true);
    }
    for (int i = 0; i < attributeTypes.size(); ++i) {
        CppType type = attributeTypes.get(i);
        XsdAttribute attribute = resolveAttribute(complexType.getAttributes().get(i));
        printGetterAndSetter(name, type, Utils.toVariableName(attribute.getName()), false);
    }
    if (valueType != null) {
        printGetterAndSetter(name, valueType, "value", false);
    }
    headerFile.println();
    headerFile.println("};\n");
    printParser(name, complexType);
}
#method_after
private void printClass(String name, String nameScope, XsdComplexType complexType) throws CppCodeGeneratorException {
    assert name != null;
    // need element, attribute name duplicate validation?
    String baseName = getBaseName(complexType);
    CppSimpleType valueType = (complexType instanceof XsdSimpleContent) ? getValueType((XsdSimpleContent) complexType, false) : null;
    headerFile.printf("class %s ", name);
    if (baseName != null) {
        headerFile.printf(": public %s {\n", baseName);
    } else {
        headerFile.println("{");
    }
    // parse types for elements and attributes
    List<CppType> elementTypes = new ArrayList<>();
    for (XsdElement element : complexType.getElements()) {
        CppType cppType;
        XsdElement elementValue = resolveElement(element);
        if (element.getRef() == null && element.getType().getRef() == null && element.getType() instanceof XsdComplexType) {
            // print inner class for anonymous types
            headerFile.printf("public:\n");
            String innerName = Utils.toClassName(element.getName());
            XsdComplexType innerType = (XsdComplexType) element.getType();
            printClass(innerName, nameScope + name + "::", innerType);
            headerFile.println();
            cppType = new CppComplexType(nameScope + name + "::" + innerName);
        } else {
            cppType = parseType(elementValue.getType(), elementValue.getName());
        }
        elementTypes.add(cppType);
    }
    List<CppSimpleType> attributeTypes = new ArrayList<>();
    for (XsdAttribute attribute : complexType.getAttributes()) {
        XsdType type = resolveAttribute(attribute).getType();
        attributeTypes.add(parseSimpleType(type, false));
    }
    // print member variables
    headerFile.printf("private:\n");
    for (int i = 0; i < elementTypes.size(); ++i) {
        CppType type = elementTypes.get(i);
        XsdElement element = complexType.getElements().get(i);
        XsdElement elementValue = resolveElement(element);
        // String typeName = String.format("std::vector<%s>", type.getName());
        String typeName = element.isMultiple() || type instanceof CppComplexType ? String.format("std::vector<%s>", type.getName()) : type.getName();
        headerFile.printf("%s %s;\n", typeName, Utils.toVariableName(elementValue.getName()));
    }
    for (int i = 0; i < attributeTypes.size(); ++i) {
        CppType type = attributeTypes.get(i);
        XsdAttribute attribute = resolveAttribute(complexType.getAttributes().get(i));
        headerFile.printf("%s %s;\n", type.getName(), Utils.toVariableName(attribute.getName()));
    }
    if (valueType != null) {
        headerFile.printf("%s value;\n", valueType.getName());
    }
    // print getters and setters
    headerFile.printf("public:\n");
    for (int i = 0; i < elementTypes.size(); ++i) {
        CppType type = elementTypes.get(i);
        XsdElement element = complexType.getElements().get(i);
        XsdElement elementValue = resolveElement(element);
        printGetterAndSetter(nameScope + name, type, Utils.toVariableName(elementValue.getName()), type instanceof CppComplexType ? true : element.isMultiple());
    }
    for (int i = 0; i < attributeTypes.size(); ++i) {
        CppType type = attributeTypes.get(i);
        XsdAttribute attribute = resolveAttribute(complexType.getAttributes().get(i));
        printGetterAndSetter(nameScope + name, type, Utils.toVariableName(attribute.getName()), false);
    }
    if (valueType != null) {
        printGetterAndSetter(nameScope + name, valueType, "value", false);
    }
    printParser(name, nameScope, complexType);
    headerFile.println("};\n");
}
#end_block

#method_before
private void printParser(String name, XsdComplexType complexType) throws CppCodeGeneratorException {
    CppSimpleType baseValueType = (complexType instanceof XsdSimpleContent) ? getValueType((XsdSimpleContent) complexType, true) : null;
    List<XsdElement> allElements = new ArrayList<>();
    List<XsdAttribute> allAttributes = new ArrayList<>();
    stackComponents(complexType, allElements, allAttributes);
    // parse types for elements and attributes
    List<CppType> allElementTypes = new ArrayList<>();
    for (XsdElement element : allElements) {
        XsdElement elementValue = resolveElement(element);
        CppType cppType = parseType(elementValue.getType(), elementValue.getName());
        allElementTypes.add(cppType);
    }
    List<CppSimpleType> allAttributeTypes = new ArrayList<>();
    for (XsdAttribute attribute : allAttributes) {
        XsdType type = resolveAttribute(attribute).getType();
        allAttributeTypes.add(parseSimpleType(type, false));
    }
    cppFile.printf("\n%s %sRead(xmlNode *root) {\n", name, Utils.lowerize(name));
    cppFile.printf("%s instance;\n std::string raw;\n", name, name);
    for (int i = 0; i < allAttributes.size(); ++i) {
        CppType type = allAttributeTypes.get(i);
        XsdAttribute attribute = resolveAttribute(allAttributes.get(i));
        String variableName = Utils.toVariableName(attribute.getName());
        cppFile.printf("raw = getXmlAttribute(root, \"%s\");\n", attribute.getName());
        cppFile.printf("if (raw != \"\") {\n");
        cppFile.print(type.getParsingExpression());
        cppFile.printf("instance.set%s(value);\n}\n", Utils.capitalize(variableName));
    }
    if (baseValueType != null) {
    // ?????
    } else if (!allElements.isEmpty()) {
        cppFile.print("for (xmlNode *child = root->xmlChildrenNode; child != nullptr;" + "child = child->next) {\n");
        for (int i = 0; i < allElements.size(); ++i) {
            CppType type = allElementTypes.get(i);
            XsdElement element = allElements.get(i);
            XsdElement elementValue = resolveElement(element);
            String variableName = Utils.toVariableName(elementValue.getName());
            if (i != 0)
                cppFile.printf(" else ");
            cppFile.printf("if (!xmlStrcmp(child->name, reinterpret_cast<const xmlChar*>");
            cppFile.printf("(\"%s\"))) {\n", elementValue.getName());
            if (type instanceof CppSimpleType) {
                cppFile.printf("auto xmlValue make_xmlUnique(xmlNodeListGetString(");
                cppFile.printf("child->doc, child->xmlChildrenNode, 1));\n");
                cppFile.printf("if (xmlValue == nullptr) {\ncontinue;\n}\n");
                cppFile.printf("raw = (reinterpret_cast<const char*>(xmlValue.get()));\n");
            }
            cppFile.print(type.getParsingExpression());
            cppFile.printf("instance.get%s().push_back(std::move(value));\n", Utils.capitalize(variableName));
            cppFile.printf("}");
        }
        cppFile.printf("\n}\n");
    }
    cppFile.printf("return instance;\n" + "}\n");
}
#method_after
private void printParser(String name, String nameScope, XsdComplexType complexType) throws CppCodeGeneratorException {
    CppSimpleType baseValueType = (complexType instanceof XsdSimpleContent) ? getValueType((XsdSimpleContent) complexType, true) : null;
    List<XsdElement> allElements = new ArrayList<>();
    List<XsdAttribute> allAttributes = new ArrayList<>();
    stackComponents(complexType, allElements, allAttributes);
    // parse types for elements and attributes
    List<CppType> allElementTypes = new ArrayList<>();
    for (XsdElement element : allElements) {
        XsdElement elementValue = resolveElement(element);
        CppType cppType = parseType(elementValue.getType(), elementValue.getName());
        allElementTypes.add(cppType);
    }
    List<CppSimpleType> allAttributeTypes = new ArrayList<>();
    for (XsdAttribute attribute : allAttributes) {
        XsdType type = resolveAttribute(attribute).getType();
        allAttributeTypes.add(parseSimpleType(type, false));
    }
    String fullName = nameScope + name;
    headerFile.printf("static %s read(xmlNode *root);\n", fullName, Utils.lowerize(name));
    cppFile.printf("\n%s %s::read(xmlNode *root) {\n", fullName, fullName);
    cppFile.printf("%s instance;\n std::string raw;\n", fullName, fullName);
    for (int i = 0; i < allAttributes.size(); ++i) {
        CppType type = allAttributeTypes.get(i);
        XsdAttribute attribute = resolveAttribute(allAttributes.get(i));
        String variableName = Utils.toVariableName(attribute.getName());
        cppFile.printf("raw = getXmlAttribute(root, \"%s\");\n", attribute.getName());
        cppFile.printf("if (raw != \"\") {\n");
        cppFile.print(type.getParsingExpression());
        cppFile.printf("instance.set%s(value);\n}\n", Utils.capitalize(variableName));
    }
    if (baseValueType != null) {
        cppFile.printf("auto xmlValue = make_xmlUnique(xmlNodeListGetString(" + "root->doc, root->xmlChildrenNode, 1));\n" + "if (xmlValue != nullptr) {\n" + "raw = reinterpret_cast<const char*>(xmlValue.get());\n");
        cppFile.print(baseValueType.getParsingExpression());
        cppFile.printf("instance.setValue(value);\n");
        cppFile.printf("}\n");
    } else if (!allElements.isEmpty()) {
        cppFile.print("for (xmlNode *child = root->xmlChildrenNode; child != nullptr;" + " child = child->next) {\n");
        for (int i = 0; i < allElements.size(); ++i) {
            CppType type = allElementTypes.get(i);
            XsdElement element = allElements.get(i);
            XsdElement elementValue = resolveElement(element);
            String variableName = Utils.toVariableName(elementValue.getName());
            if (i != 0)
                cppFile.printf("} else ");
            cppFile.printf("if (!xmlStrcmp(child->name, reinterpret_cast<const xmlChar*>");
            cppFile.printf("(\"%s\"))) {\n", elementValue.getName());
            if (type instanceof CppSimpleType) {
                cppFile.printf("auto xmlValue = make_xmlUnique(xmlNodeListGetString(");
                cppFile.printf("child->doc, child->xmlChildrenNode, 1));\n");
                cppFile.printf("if (xmlValue == nullptr) {\ncontinue;\n}\n");
                cppFile.printf("raw = reinterpret_cast<const char*>(xmlValue.get());\n");
            }
            cppFile.print(type.getParsingExpression());
            if (element.isMultiple() || type instanceof CppComplexType) {
                cppFile.printf("instance.get%s().push_back(std::move(value));\n", Utils.capitalize(variableName));
            } else {
                cppFile.printf("instance.set%s(value);\n", Utils.capitalize(variableName));
            }
        }
        cppFile.printf("}\n}\n");
    }
    cppFile.printf("return instance;\n" + "}\n");
}
#end_block

#method_before
private void printGetterAndSetter(String name, CppType type, String variableName, boolean isMultiple) {
    String typeName = isMultiple ? String.format("std::vector<%s>", type.getName()) : type.getName();
    // Header file
    headerFile.printf("%s& get%s();\n", typeName, Utils.capitalize(variableName));
    headerFile.printf("void set%s(%s);\n", Utils.capitalize(variableName), typeName);
    // CPP file
    cppFile.println();
    cppFile.printf("%s& %s::get%s() {\n", typeName, name, Utils.capitalize(variableName));
    cppFile.printf("return %s;\n}\n", variableName);
    if (isMultiple)
        return;
    cppFile.println();
    cppFile.printf("void %s::set%s(%s %s) {\n" + "this->%s = std::move(%s);\n" + "}\n", name, Utils.capitalize(variableName), typeName, variableName, variableName, variableName);
}
#method_after
private void printGetterAndSetter(String name, CppType type, String variableName, boolean isMultiple) {
    String typeName = isMultiple ? String.format("std::vector<%s>", type.getName()) : type.getName();
    headerFile.printf("%s& get%s();\n", typeName, Utils.capitalize(variableName));
    cppFile.println();
    cppFile.printf("%s& %s::get%s() {\n" + "return %s;\n}\n", typeName, name, Utils.capitalize(variableName), variableName);
    if (isMultiple)
        return;
    headerFile.printf("void set%s(%s);\n", Utils.capitalize(variableName), typeName);
    cppFile.println();
    cppFile.printf("void %s::set%s(%s %s) {\n" + "this->%s = std::move(%s);\n" + "}\n", name, Utils.capitalize(variableName), typeName, variableName, variableName, variableName);
}
#end_block

#method_before
private void printXmlParser() throws CppCodeGeneratorException {
    cppFile.printf("template <class T>\n" + "constexpr void (*xmlDeleter)(T* t);\n" + "template <>\nconstexpr auto xmlDeleter<xmlDoc> = xmlFreeDoc;\n" + "template <>\nauto xmlDeleter<xmlChar> = [](xmlChar *s) { xmlFree(s); };\n\n" + "template <class T>\n" + "constexpr auto make_xmlUnique(T *t) {\n" + "auto deleter = [](T *t) { xmlDeleter<T>(t); };\n" + "return std::unique_ptr<T, decltype(deleter)>{t, deleter};\n" + "}\n\n");
    cppFile.printf("static std::string getXmlAttribute" + "(const xmlNode *cur, const char *attribute) {\n" + "auto xmlValue = make_xmlUnique(xmlGetProp(cur, " + "reinterpret_cast<const xmlChar*>(attribute)));\n" + "if (xmlValue == nullptr) {\n" + "return \"\";\n" + "}\n" + "std::string value(reinterpret_cast<const char*>(xmlValue.get()));\n" + "return value;\n" + "}\n\n");
    List<String> elements = new ArrayList<>();
    for (XsdElement element : xmlSchema.getElementMap().values()) {
        elements.add(element.getName());
    }
    String className = Utils.toClassName(fileName);
    headerFile.printf("class %s {\n", className);
    headerFile.printf("private:\n");
    for (String name : elements) {
        headerFile.printf("std::vector<%s> %s;\n", Utils.toClassName(name), Utils.toVariableName(name));
    }
    cppFile.printf("%s read(const char* configFile) {\n", className);
    cppFile.printf("%s config;\n", className);
    cppFile.printf("auto doc = make_xmlUnique(xmlParseFile(configFile));\n" + "if (doc == nullptr) {\n" + "return config;\n" + "}\n" + "xmlNodePtr root = xmlDocGetRootElement(doc.get());\n" + "if (root == NULL) {\n" + "return config;\n" + "}\n\n");
    headerFile.printf("public:\n");
    for (String name : elements) {
        cppFile.printf("if (!xmlStrcmp(root->name, reinterpret_cast<const xmlChar*>(\"%s\")))" + " {\n", name);
        cppFile.printf("%s value = %sRead(root);\n" + "config.get%s().push_back(std::move(value));\n" + "}\n", Utils.toClassName(name), Utils.lowerize(name), Utils.capitalize(name));
    }
    cppFile.printf("return config;\n");
    cppFile.printf("}\n\n");
    for (String name : elements) {
        headerFile.printf("std::vector<%s>& get%s();\n", Utils.toClassName(name), Utils.capitalize(name));
        cppFile.printf("std::vector<%s>& %s::get%s() {\n" + "return %s;\n}\n", Utils.toClassName(name), className, Utils.capitalize(name), Utils.toVariableName(name));
    }
    headerFile.printf("};\n\n%s read(const char* configFile);\n\n", className);
}
#method_after
private void printXmlParser() throws CppCodeGeneratorException {
    cppFile.printf("template <class T>\n" + "constexpr void (*xmlDeleter)(T* t);\n" + "template <>\nconstexpr auto xmlDeleter<xmlDoc> = xmlFreeDoc;\n" + "template <>\nauto xmlDeleter<xmlChar> = [](xmlChar *s) { xmlFree(s); };\n\n" + "template <class T>\n" + "constexpr auto make_xmlUnique(T *t) {\n" + "auto deleter = [](T *t) { xmlDeleter<T>(t); };\n" + "return std::unique_ptr<T, decltype(deleter)>{t, deleter};\n" + "}\n\n");
    if (hasAttr) {
        cppFile.printf("static std::string getXmlAttribute" + "(const xmlNode *cur, const char *attribute) {\n" + "auto xmlValue = make_xmlUnique(xmlGetProp(cur, " + "reinterpret_cast<const xmlChar*>(attribute)));\n" + "if (xmlValue == nullptr) {\n" + "return \"\";\n" + "}\n" + "std::string value(reinterpret_cast<const char*>(xmlValue.get()));\n" + "return value;\n" + "}\n\n");
    }
    String className = Utils.toClassName(fileName);
    headerFile.printf("class %s {\n", className);
    headerFile.printf("private:\n");
    for (XsdElement element : xmlSchema.getElementMap().values()) {
        CppType cppType = parseType(element.getType(), element.getName());
        String typeName = cppType instanceof CppSimpleType ? cppType.getName() : Utils.toClassName(cppType.getName());
        headerFile.printf("std::vector<%s> %s;\n", typeName, Utils.toVariableName(element.getName()));
    }
    cppFile.printf("%s %s::read(const char* configFile) {\n", className, className);
    cppFile.printf("%s config;\n", className);
    cppFile.printf("auto doc = make_xmlUnique(xmlParseFile(configFile));\n" + "if (doc == nullptr) {\n" + "return config;\n" + "}\n" + "xmlNodePtr child = xmlDocGetRootElement(doc.get());\n" + "if (child == NULL) {\n" + "return config;\n" + "}\n\n");
    headerFile.printf("public:\n");
    for (XsdElement element : xmlSchema.getElementMap().values()) {
        CppType cppType = parseType(element.getType(), element.getName());
        cppFile.printf("if (!xmlStrcmp(child->name, reinterpret_cast<const xmlChar*>" + "(\"%s\"))) {\n", element.getName());
        if (cppType instanceof CppSimpleType) {
            cppFile.printf("%s value = getXmlAttribute(child, \"%s\");\n", cppType.getName(), element.getName());
        } else {
            cppFile.printf(cppType.getParsingExpression());
        }
        cppFile.printf("config.get%s().push_back(std::move(value));\n" + "}\n", Utils.capitalize(Utils.toVariableName(element.getName())));
    }
    cppFile.printf("return config;\n");
    cppFile.printf("}\n\n");
    for (XsdElement element : xmlSchema.getElementMap().values()) {
        CppType cppType = parseType(element.getType(), element.getName());
        String name = element.getName();
        String typeName = cppType instanceof CppSimpleType ? cppType.getName() : Utils.toClassName(cppType.getName());
        headerFile.printf("std::vector<%s>& get%s();\n", typeName, Utils.capitalize(Utils.toVariableName(name)));
        cppFile.printf("std::vector<%s>& %s::get%s() {\n" + "return %s;\n}\n", typeName, className, Utils.capitalize(Utils.toVariableName(name)), Utils.toVariableName(name));
    }
    headerFile.printf("static %s read(const char* configFile);\n};\n\n", className);
}
#end_block

#method_before
private CppSimpleType parseSimpleTypeValue(XsdSimpleType simpleType, boolean traverse) throws CppCodeGeneratorException {
    if (simpleType instanceof XsdList) {
        XsdList list = (XsdList) simpleType;
        return parseSimpleType(list.getItemType(), traverse).newListType();
    } else if (simpleType instanceof XsdRestriction) {
        // we don't consider any restrictions.
        XsdRestriction restriction = (XsdRestriction) simpleType;
        return parseSimpleType(restriction.getBase(), traverse);
    } else if (simpleType instanceof XsdUnion) {
        // unions are almost always interpreted as java.lang.String
        // Exceptionally, if any of member types of union are 'list', then we interpret it as
        // List<String>
        XsdUnion union = (XsdUnion) simpleType;
        for (XsdType memberType : union.getMemberTypes()) {
            if (parseSimpleType(memberType, traverse).isList()) {
                return new CppSimpleType("java.lang.String", "%s", true);
            }
        }
        return new CppSimpleType("java.lang.String", "%s", false);
    } else {
        // unreachable
        throw new IllegalStateException("unknown simple type");
    }
}
#method_after
private CppSimpleType parseSimpleTypeValue(XsdSimpleType simpleType, boolean traverse) throws CppCodeGeneratorException {
    if (simpleType instanceof XsdList) {
        XsdList list = (XsdList) simpleType;
        return parseSimpleType(list.getItemType(), traverse).newListType();
    } else if (simpleType instanceof XsdRestriction) {
        // we don't consider any restrictions.
        XsdRestriction restriction = (XsdRestriction) simpleType;
        return parseSimpleType(restriction.getBase(), traverse);
    } else if (simpleType instanceof XsdUnion) {
        // unions are almost always interpreted as java.lang.String
        // Exceptionally, if any of member types of union are 'list', then we interpret it as
        // List<String>
        XsdUnion union = (XsdUnion) simpleType;
        for (XsdType memberType : union.getMemberTypes()) {
            if (parseSimpleType(memberType, traverse).isList()) {
                return new CppSimpleType("std::string", "%s", true);
            }
        }
        return new CppSimpleType("std::string", "%s", false);
    } else {
        // unreachable
        throw new IllegalStateException("unknown simple type");
    }
}
#end_block

#method_before
private static CppSimpleType predefinedType(String name) throws CppCodeGeneratorException {
    switch(name) {
        case "string":
        case "token":
        case "normalizedString":
        case "language":
        case "ENTITY":
        case "ID":
        case "Name":
        case "NCName":
        case "NMTOKEN":
        case "anyURI":
        case "anyType":
        case "QName":
        case "NOTATION":
        case "IDREF":
            return new CppSimpleType("std::string", "%s", false);
        case "ENTITIES":
        case "NMTOKENS":
        case "IDREFS":
            return new CppSimpleType("std::string", "%s", true);
        case "date":
        case "dateTime":
        case "time":
        case "gDay":
        case "gMonth":
        case "gYear":
        case "gMonthDay":
        case "gYearMonth":
        case "duration":
            return new CppSimpleType("std::string", "%s", false);
        case "decimal":
            return new CppSimpleType("double", "std::stod(%s)", false);
        case "integer":
        case "negativeInteger":
        case "nonNegativeInteger":
        case "positiveInteger":
        case "nonPositiveInteger":
            return new CppSimpleType("long long", "std::stoll(%s)", false);
        case "unsignedLong":
            return new CppSimpleType("unsigned long", "std::stoul(%s)", false);
        case "long":
            return new CppSimpleType("long", "std::stol(%s)", false);
        case "unsignedInt":
            return new CppSimpleType("unsigned int", "static_cast<unsigned int>stoul(%s)", false);
        case "int":
            return new CppSimpleType("int", "static_cast<int>std::stoi(%s)", false);
        case "unsignedShort":
            return new CppSimpleType("unsigned shart", "static_cast<unsigned short>std::stoi(%s)", false);
        case "short":
            return new CppSimpleType("shart", "static_cast<short>std::stoi(%s)", false);
        case "unsignedByte":
            return new CppSimpleType("unsigned char", "static_cast<unsigned char>std::stoi(%s)", false);
        case "byte":
            return new CppSimpleType("char", "static_cast<char>std::stoi(%s)", false);
        case "boolean":
            return new CppSimpleType("bool", "%s.compare(\"true\") ? false : true", false);
        case "double":
            return new CppSimpleType("double", "std::stod(%s)", false);
        case "float":
            return new CppSimpleType("float", "std::stof(%s)", false);
        case "base64Binary":
        case "hexBinary":
            return new CppSimpleType("char *", "%s.c_str()", false);
    }
    throw new CppCodeGeneratorException("unknown xsd predefined type : " + name);
}
#method_after
private static CppSimpleType predefinedType(String name) throws CppCodeGeneratorException {
    switch(name) {
        case "string":
        case "token":
        case "normalizedString":
        case "language":
        case "ENTITY":
        case "ID":
        case "Name":
        case "NCName":
        case "NMTOKEN":
        case "anyURI":
        case "anyType":
        case "QName":
        case "NOTATION":
        case "IDREF":
            return new CppSimpleType("std::string", "%s", false);
        case "ENTITIES":
        case "NMTOKENS":
        case "IDREFS":
            return new CppSimpleType("std::string", "%s", true);
        case "date":
        case "dateTime":
        case "time":
        case "gDay":
        case "gMonth":
        case "gYear":
        case "gMonthDay":
        case "gYearMonth":
        case "duration":
            return new CppSimpleType("std::string", "%s", false);
        case "decimal":
            return new CppSimpleType("double", "std::stod(%s)", false);
        case "integer":
        case "negativeInteger":
        case "nonNegativeInteger":
        case "positiveInteger":
        case "nonPositiveInteger":
            return new CppSimpleType("long long", "std::stoll(%s)", false);
        case "unsignedLong":
            return new CppSimpleType("unsigned long", "std::stoul(%s)", false);
        case "long":
            return new CppSimpleType("long", "std::stol(%s)", false);
        case "unsignedInt":
            return new CppSimpleType("unsigned int", "static_cast<unsigned int>(stoul(%s))", false);
        case "int":
            return new CppSimpleType("int", "std::stoi(%s)", false);
        case "unsignedShort":
            return new CppSimpleType("unsigned short", "static_cast<unsigned short>(std::stoi(%s))", false);
        case "short":
            return new CppSimpleType("short", "static_cast<short>(std::stoi(%s))", false);
        case "unsignedByte":
            return new CppSimpleType("unsigned char", "static_cast<unsigned char>(std::stoi(%s))", false);
        case "byte":
            return new CppSimpleType("char", "static_cast<char>(std::stoi(%s))", false);
        case "boolean":
            return new CppSimpleType("bool", "%s == \"true\"", false);
        case "double":
            return new CppSimpleType("double", "std::stod(%s)", false);
        case "float":
            return new CppSimpleType("float", "std::stof(%s)", false);
        case "base64Binary":
        case "hexBinary":
            return new CppSimpleType("std::string", "%s", false);
    }
    throw new CppCodeGeneratorException("unknown xsd predefined type : " + name);
}
#end_block

#method_before
public static MediaMetadataCompat fromMediaMetadata(Object metadataObj) {
    if (metadataObj != null && Build.VERSION.SDK_INT >= 21) {
        Parcel p = Parcel.obtain();
        ((MediaMetadata) metadataObj).writeToParcel(p, 0);
        p.setDataPosition(0);
        MediaMetadataCompat metadata = MediaMetadataCompat.CREATOR.createFromParcel(p);
        p.recycle();
        metadata.mMetadataObj = (MediaMetadata) metadataObj;
        return metadata;
    } else {
        return null;
    }
}
#method_after
public static MediaMetadataCompat fromMediaMetadata(Object metadataObj) {
    if (metadataObj != null && Build.VERSION.SDK_INT >= 21) {
        Parcel p = Parcel.obtain();
        ((MediaMetadata) metadataObj).writeToParcel(p, 0);
        p.setDataPosition(0);
        MediaMetadataCompat metadata = MediaMetadataCompat.CREATOR.createFromParcel(p);
        p.recycle();
        metadata.mMetadataFwk = (MediaMetadata) metadataObj;
        return metadata;
    } else {
        return null;
    }
}
#end_block

#method_before
public Object getMediaMetadata() {
    if (mMetadataObj == null && Build.VERSION.SDK_INT >= 21) {
        Parcel p = Parcel.obtain();
        writeToParcel(p, 0);
        p.setDataPosition(0);
        mMetadataObj = MediaMetadata.CREATOR.createFromParcel(p);
        p.recycle();
    }
    return mMetadataObj;
}
#method_after
public Object getMediaMetadata() {
    if (mMetadataFwk == null && Build.VERSION.SDK_INT >= 21) {
        Parcel p = Parcel.obtain();
        writeToParcel(p, 0);
        p.setDataPosition(0);
        mMetadataFwk = MediaMetadata.CREATOR.createFromParcel(p);
        p.recycle();
    }
    return mMetadataFwk;
}
#end_block

#method_before
public final void setCurrentVolume(int currentVolume) {
    mCurrentVolume = currentVolume;
    Object volumeProviderObj = getVolumeProvider();
    if (volumeProviderObj != null && Build.VERSION.SDK_INT >= 21) {
        ((VolumeProvider) volumeProviderObj).setCurrentVolume(currentVolume);
    }
    if (mCallback != null) {
        mCallback.onVolumeChanged(this);
    }
}
#method_after
public final void setCurrentVolume(int currentVolume) {
    mCurrentVolume = currentVolume;
    if (Build.VERSION.SDK_INT >= 21) {
        VolumeProvider volumeProviderFwk = (VolumeProvider) getVolumeProvider();
        volumeProviderFwk.setCurrentVolume(currentVolume);
    }
    if (mCallback != null) {
        mCallback.onVolumeChanged(this);
    }
}
#end_block

#method_before
public Object getVolumeProvider() {
    if (mVolumeProviderObj == null && Build.VERSION.SDK_INT >= 21) {
        mVolumeProviderObj = new VolumeProvider(mControlType, mMaxVolume, mCurrentVolume) {

            @Override
            public void onSetVolumeTo(int volume) {
                VolumeProviderCompat.this.onSetVolumeTo(volume);
            }

            @Override
            public void onAdjustVolume(int direction) {
                VolumeProviderCompat.this.onAdjustVolume(direction);
            }
        };
    }
    return mVolumeProviderObj;
}
#method_after
public Object getVolumeProvider() {
    if (mVolumeProviderFwk == null && Build.VERSION.SDK_INT >= 21) {
        mVolumeProviderFwk = new VolumeProvider(mControlType, mMaxVolume, mCurrentVolume) {

            @Override
            public void onSetVolumeTo(int volume) {
                VolumeProviderCompat.this.onSetVolumeTo(volume);
            }

            @Override
            public void onAdjustVolume(int direction) {
                VolumeProviderCompat.this.onAdjustVolume(direction);
            }
        };
    }
    return mVolumeProviderFwk;
}
#end_block

#method_before
public void setMetadata(@Nullable MediaMetadata2 metadata) {
    if (metadata != null && !TextUtils.equals(mMediaId, metadata.getMediaId())) {
        throw new IllegalArgumentException("metadata's id should be matched with the mediaId");
    }
    mMetadata = metadata;
    if (metadata != null) {
        mDurationMs = metadata.getLong(MediaMetadata2.METADATA_KEY_DURATION);
    }
    if (mCallback != null) {
        mCallback.onMetadataChanged(this);
    }
}
#method_after
public void setMetadata(@Nullable MediaMetadata2 metadata) {
    if (metadata != null && !TextUtils.equals(mMediaId, metadata.getMediaId())) {
        throw new IllegalArgumentException("metadata's id should be matched with the mediaId");
    }
    mMetadata = metadata;
    if (metadata != null) {
        mDurationMs = metadata.getLong(MediaMetadata2.METADATA_KEY_DURATION);
    }
    List<Pair<OnMetadataChangedListener, Executor>> listeners = new ArrayList<>();
    synchronized (mLock) {
        listeners.addAll(mListeners);
    }
    for (Pair<OnMetadataChangedListener, Executor> pair : listeners) {
        final OnMetadataChangedListener listener = pair.first;
        pair.second.execute(new Runnable() {

            @Override
            public void run() {
                listener.onMetadataChanged(MediaItem2.this);
            }
        });
    }
}
#end_block

#method_before
@Override
public ListenableFuture<PlayerResult> play() {
    return dispatchPlayerTask(new PlayerTask<ListenableFuture<PlayerResult>>() {

        @Override
        public ListenableFuture<PlayerResult> run(SessionPlayer2 player) throws Exception {
            if (player.getPlayerState() != PLAYER_STATE_IDLE) {
                return player.play();
            }
            final ListenableFuture<PlayerResult> prepareFuture = player.prefetch();
            final ListenableFuture<PlayerResult> playFuture = player.play();
            if (prepareFuture == null || playFuture == null) {
                // Let dispatchPlayerTask() handle such cases.
                return null;
            }
            return XMediaPlayer.CombindedCommandResultFuture.create(DIRECT_EXECUTOR, prepareFuture, playFuture);
        }
    });
}
#method_after
@Override
public ListenableFuture<PlayerResult> play() {
    return dispatchPlayerTask(new PlayerTask<ListenableFuture<PlayerResult>>() {

        @Override
        public ListenableFuture<PlayerResult> run(SessionPlayer2 player) throws Exception {
            if (player.getPlayerState() != PLAYER_STATE_IDLE) {
                return player.play();
            }
            final ListenableFuture<PlayerResult> prepareFuture = player.prepare();
            final ListenableFuture<PlayerResult> playFuture = player.play();
            if (prepareFuture == null || playFuture == null) {
                // Let dispatchPlayerTask() handle such cases.
                return null;
            }
            return XMediaPlayer.CombindedCommandResultFuture.create(DIRECT_EXECUTOR, prepareFuture, playFuture);
        }
    });
}
#end_block

#method_before
@Override
public ListenableFuture<PlayerResult> prefetch() {
    return dispatchPlayerTask(new PlayerTask<ListenableFuture<PlayerResult>>() {

        @Override
        public ListenableFuture<PlayerResult> run(SessionPlayer2 player) throws Exception {
            return player.prefetch();
        }
    });
}
#method_after
@Override
public ListenableFuture<PlayerResult> prefetch() {
    return dispatchPlayerTask(new PlayerTask<ListenableFuture<PlayerResult>>() {

        @Override
        public ListenableFuture<PlayerResult> run(SessionPlayer2 player) throws Exception {
            return player.prepare();
        }
    });
}
#end_block

#method_before
private ListenableFuture<SessionResult> dispatchRemoteControllerTask(@NonNull ControllerInfo controller, @NonNull RemoteControllerTask task) {
    if (!isConnected(controller)) {
        return SessionResult.createFutureWithResult(RESULT_CODE_DISCONNECTED);
    }
    try {
        final ListenableFuture<SessionResult> future;
        final int seq;
        final SequencedFutureManager manager = mSession2Stub.getConnectedControllersManager().getSequencedFutureManager(controller);
        if (manager != null) {
            future = manager.createSequencedFuture();
            seq = ((SequencedFuture<SessionResult>) future).getSequenceNumber();
        } else {
            // Can be null in two cases. Use the 0 as sequence number in both cases because
            // Case 1) Controller is from the legacy stub
            // -> Sequence number isn't needed, so 0 is OK
            // Case 2) Controller is removed after the connection check above
            // -> Call will fail below or ignored by the controller, so 0 is OK.
            seq = 0;
            future = SessionResult.createFutureWithResult(RESULT_CODE_SUCCESS);
        }
        task.run(controller.getControllerCb(), seq);
        return future;
    } catch (DeadObjectException e) {
        onDeadObjectException(controller, e);
        return SessionResult.createFutureWithResult(RESULT_CODE_DISCONNECTED);
    } catch (RemoteException e) {
        // Currently it's TransactionTooLargeException or DeadSystemException.
        // We'd better to leave log for those cases because
        // - TransactionTooLargeException means that we may need to fix our code.
        // (e.g. add pagination or special way to deliver Bitmap)
        // - DeadSystemException means that errors around it can be ignored.
        Log.w(TAG, "Exception in " + controller.toString(), e);
    }
    return SessionResult.createFutureWithResult(RESULT_CODE_UNKNOWN_ERROR);
}
#method_after
private ListenableFuture<SessionResult> dispatchRemoteControllerTask(@NonNull ControllerInfo controller, @NonNull RemoteControllerTask task) {
    if (!isConnected(controller)) {
        return SessionResult.createFutureWithResult(RESULT_CODE_DISCONNECTED);
    }
    try {
        final ListenableFuture<SessionResult> future;
        final int seq;
        final SequencedFutureManager manager = mSession2Stub.getConnectedControllersManager().getSequencedFutureManager(controller);
        if (manager != null) {
            future = manager.createSequencedFuture(RESULT_WHEN_CLOSED);
            seq = ((SequencedFuture<SessionResult>) future).getSequenceNumber();
        } else {
            // Can be null in two cases. Use the 0 as sequence number in both cases because
            // Case 1) Controller is from the legacy stub
            // -> Sequence number isn't needed, so 0 is OK
            // Case 2) Controller is removed after the connection check above
            // -> Call will fail below or ignored by the controller, so 0 is OK.
            seq = 0;
            future = SessionResult.createFutureWithResult(RESULT_CODE_SUCCESS);
        }
        task.run(controller.getControllerCb(), seq);
        return future;
    } catch (DeadObjectException e) {
        onDeadObjectException(controller, e);
        return SessionResult.createFutureWithResult(RESULT_CODE_DISCONNECTED);
    } catch (RemoteException e) {
        // Currently it's TransactionTooLargeException or DeadSystemException.
        // We'd better to leave log for those cases because
        // - TransactionTooLargeException means that we may need to fix our code.
        // (e.g. add pagination or special way to deliver Bitmap)
        // - DeadSystemException means that errors around it can be ignored.
        Log.w(TAG, "Exception in " + controller.toString(), e);
    }
    return SessionResult.createFutureWithResult(RESULT_CODE_UNKNOWN_ERROR);
}
#end_block

#method_before
@Override
public void onCurrentMediaItemChanged(final SessionPlayer2 player, final MediaItem2 item) {
    final MediaSession2ImplBase session = getSession();
    if (session == null || session.getPlayer() != player || player == null) {
        return;
    }
    if (item != null) {
        item.setCallback(new MediaItemCallback(session));
    }
    // Note: No sanity check whether the item is in the playlist.
    updateDurationIfNeeded(player, item);
    session.dispatchRemoteControllerCallbackTask(new RemoteControllerCallbackTask() {

        @Override
        public void run(ControllerCb callback) throws RemoteException {
            callback.onCurrentMediaItemChanged(item);
        }
    });
}
#method_after
@Override
public void onCurrentMediaItemChanged(final SessionPlayer2 player, final MediaItem2 item) {
    final MediaSession2ImplBase session = getSession();
    if (session == null || session.getPlayer() != player || player == null) {
        return;
    }
    synchronized (session.mLock) {
        if (mMediaItem != null) {
            mMediaItem.removeOnMetadataChangedListener(mMediaItemListener);
        }
        if (item != null) {
            item.addOnMetadataChangedListener(session.mCallbackExecutor, mMediaItemListener);
        }
        mMediaItem = item;
    }
    // Note: No sanity check whether the item is in the playlist.
    updateDurationIfNeeded(player, item);
    session.dispatchRemoteControllerCallbackTask(new RemoteControllerCallbackTask() {

        @Override
        public void run(ControllerCb callback) throws RemoteException {
            callback.onCurrentMediaItemChanged(item);
        }
    });
}
#end_block

#method_before
@Test
public void testGettersAfterConnected() throws InterruptedException {
    prepareLooper();
    final int state = SessionPlayer2.PLAYER_STATE_PLAYING;
    final int bufferingState = SessionPlayer2.BUFFERING_STATE_BUFFERING_COMPLETE;
    final long position = 150000;
    final long bufferedPosition = 900000;
    final float speed = 0.5f;
    final long timeDiff = 102;
    final MediaItem2 currentMediaItem = TestUtils.createMediaItemWithMetadata();
    mPlayer.mLastPlayerState = state;
    mPlayer.mLastBufferingState = bufferingState;
    mPlayer.mCurrentPosition = position;
    mPlayer.mBufferedPosition = bufferedPosition;
    mPlayer.mPlaybackSpeed = speed;
    mPlayer.mCurrentMediaItem = currentMediaItem;
    MediaController2 controller = createController(mSession.getToken());
    controller.setTimeDiff(timeDiff);
    assertEquals(state, controller.getPlayerState());
    assertEquals(bufferedPosition, controller.getBufferedPosition());
    assertEquals(speed, controller.getPlaybackSpeed(), 0.0f);
    assertEquals(position + (long) (speed * timeDiff), controller.getCurrentPosition());
    assertEquals(currentMediaItem, controller.getCurrentMediaItem());
}
#method_after
@Test
public void testGettersAfterConnected() throws InterruptedException {
    prepareLooper();
    final int state = SessionPlayer2.PLAYER_STATE_PLAYING;
    final int bufferingState = SessionPlayer2.BUFFERING_STATE_COMPLETE;
    final long position = 150000;
    final long bufferedPosition = 900000;
    final float speed = 0.5f;
    final long timeDiff = 102;
    final MediaItem2 currentMediaItem = TestUtils.createMediaItemWithMetadata();
    mPlayer.mLastPlayerState = state;
    mPlayer.mLastBufferingState = bufferingState;
    mPlayer.mCurrentPosition = position;
    mPlayer.mBufferedPosition = bufferedPosition;
    mPlayer.mPlaybackSpeed = speed;
    mPlayer.mCurrentMediaItem = currentMediaItem;
    MediaController2 controller = createController(mSession.getToken());
    controller.setTimeDiff(timeDiff);
    assertEquals(state, controller.getPlayerState());
    assertEquals(bufferedPosition, controller.getBufferedPosition());
    assertEquals(speed, controller.getPlaybackSpeed(), 0.0f);
    assertEquals(position + (long) (speed * timeDiff), controller.getCurrentPosition());
    assertEquals(currentMediaItem, controller.getCurrentMediaItem());
}
#end_block

#method_before
@Test
public void testSetMetadataForCurrentMediaItem() throws InterruptedException {
    // TODO: Add test for changing metadata in a playlist
    final CountDownLatch latch = new CountDownLatch(2);
    final long duration = 1000L;
    final MediaItem2 item = TestUtils.createMediaItemWithMetadata();
    final ControllerCallback callback = new ControllerCallback() {

        @Override
        public void onCurrentMediaItemChanged(@NonNull MediaController2 controller, @Nullable MediaItem2 item) {
            MediaMetadata2 metadata = item.getMetadata();
            if (metadata != null) {
                switch((int) latch.getCount()) {
                    case 2:
                        assertFalse(metadata.containsKey(MediaMetadata2.METADATA_KEY_DURATION));
                        item.setMetadata(TestUtils.createMetadata(metadata.getMediaId(), duration));
                        break;
                    case 1:
                        assertTrue(metadata.containsKey(MediaMetadata2.METADATA_KEY_DURATION));
                        assertEquals(duration, metadata.getLong(MediaMetadata2.METADATA_KEY_DURATION));
                }
            }
            latch.countDown();
        }
    };
    MediaController2 controller = createController(mSession.getToken(), true, callback);
    mPlayer.setMediaItem(item);
    mPlayer.notifyCurrentMediaItemChanged(item);
    assertTrue(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
}
#method_after
@Test
public void testSetMetadataForCurrentMediaItem() throws InterruptedException {
    // TODO: Add test for changing metadata in a playlist
    final CountDownLatch latch = new CountDownLatch(2);
    final long duration = 1000L;
    final MediaItem2 item = TestUtils.createMediaItemWithMetadata();
    final ControllerCallback callback = new ControllerCallback() {

        @Override
        public void onCurrentMediaItemChanged(@NonNull MediaController2 controller, @Nullable MediaItem2 item) {
            MediaMetadata2 metadata = item.getMetadata();
            if (metadata != null) {
                switch((int) latch.getCount()) {
                    case 2:
                        assertFalse(metadata.containsKey(MediaMetadata2.METADATA_KEY_DURATION));
                        break;
                    case 1:
                        assertTrue(metadata.containsKey(MediaMetadata2.METADATA_KEY_DURATION));
                        assertEquals(duration, metadata.getLong(MediaMetadata2.METADATA_KEY_DURATION));
                }
            }
            latch.countDown();
        }
    };
    MediaController2 controller = createController(mSession.getToken(), true, callback);
    mPlayer.setMediaItem(item);
    mPlayer.notifyCurrentMediaItemChanged(item);
    assertFalse(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
    item.setMetadata(TestUtils.createMetadata(item.getMediaId(), duration));
    assertTrue(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
}
#end_block

#method_before
void openVideo() {
    if (DEBUG) {
        Log.d(TAG, "openVideo()");
    }
    if (mMediaItem != null) {
        resetPlayer();
        if (isRemotePlayback()) {
            mRoutePlayer.setMediaItem(mMediaItem);
            return;
        }
    }
    try {
        if (mMediaPlayer == null) {
            mMediaPlayer = new VideoView2Player(mInstance.getContext());
        }
        mSurfaceView.setMediaPlayer(mMediaPlayer);
        mTextureView.setMediaPlayer(mMediaPlayer);
        if (!mCurrentView.assignSurfaceToMediaPlayer(mMediaPlayer)) {
            Log.w(TAG, "failed to assign surface");
        }
        mMediaPlayer.setAudioAttributes(mAudioAttributes);
        ensureSessionWithPlayer(mMediaPlayer);
        mMediaPlayer.setMediaItem(mMediaItem);
        final Context context = mInstance.getContext();
        mSubtitleController = new SubtitleController(context);
        mSubtitleController.registerRenderer(new ClosedCaptionRenderer(context));
        mSubtitleController.registerRenderer(new Cea708CaptionRenderer(context));
        mSubtitleController.setAnchor((SubtitleController.Anchor) mSubtitleAnchorView);
        // we don't set the target state here either, but preserve the
        // target state that was there before.
        mCurrentState = STATE_PREPARING;
        mMediaSession.getPlayer().prefetch();
    } catch (IllegalArgumentException ex) {
        Log.w(TAG, "Unable to open content: " + mMediaItem, ex);
        mCurrentState = STATE_ERROR;
        mTargetState = STATE_ERROR;
    }
}
#method_after
void openVideo() {
    if (DEBUG) {
        Log.d(TAG, "openVideo()");
    }
    if (mMediaItem != null) {
        resetPlayer();
        if (isRemotePlayback()) {
            mRoutePlayer.setMediaItem(mMediaItem);
            return;
        }
    }
    try {
        if (mMediaPlayer == null) {
            mMediaPlayer = new VideoView2Player(mInstance.getContext());
        }
        mSurfaceView.setMediaPlayer(mMediaPlayer);
        mTextureView.setMediaPlayer(mMediaPlayer);
        if (!mCurrentView.assignSurfaceToMediaPlayer(mMediaPlayer)) {
            Log.w(TAG, "failed to assign surface");
        }
        mMediaPlayer.setAudioAttributes(mAudioAttributes);
        ensureSessionWithPlayer(mMediaPlayer);
        mMediaPlayer.setMediaItem(mMediaItem);
        final Context context = mInstance.getContext();
        mSubtitleController = new SubtitleController(context);
        mSubtitleController.registerRenderer(new ClosedCaptionRenderer(context));
        mSubtitleController.registerRenderer(new Cea708CaptionRenderer(context));
        mSubtitleController.setAnchor((SubtitleController.Anchor) mSubtitleAnchorView);
        // we don't set the target state here either, but preserve the
        // target state that was there before.
        mCurrentState = STATE_PREPARING;
        mMediaSession.getPlayer().prepare();
    } catch (IllegalArgumentException ex) {
        Log.w(TAG, "Unable to open content: " + mMediaItem, ex);
        mCurrentState = STATE_ERROR;
        mTargetState = STATE_ERROR;
    }
}
#end_block

#method_before
@Override
public void createAndSetDummyPlaylist(String controllerId, int size, Bundle metadata) throws RemoteException {
    MediaController2 controller2 = mMediaController2Map.get(controllerId);
    List<MediaItem2> list = new ArrayList<>();
    MediaItem2.Builder builder = new MediaItem2.Builder();
    for (int i = 0; i < size; i++) {
        // Make media ID of each item same with its index.
        list.add(builder.setMediaId(TestUtils.getMediaIdInDummyList(i)).build());
    }
    controller2.setPlaylist(list, MediaMetadata2.fromBundle(metadata));
}
#method_after
@Override
public void createAndSetDummyPlaylist(String controllerId, int size, Bundle listMetadata) throws RemoteException {
    MediaController2 controller2 = mMediaController2Map.get(controllerId);
    List<MediaItem2> list = new ArrayList<>();
    MediaItem2.Builder builder = new MediaItem2.Builder();
    for (int i = 0; i < size; i++) {
        // Make media ID of each item same with its index.
        MediaMetadata2 metadata = new MediaMetadata2.Builder().putString(MediaMetadata2.METADATA_KEY_MEDIA_ID, TestUtils.getMediaIdInDummyList(i)).build();
        list.add(builder.setMetadata(metadata).build());
    }
    controller2.setPlaylist(list, MediaMetadata2.fromBundle(listMetadata));
}
#end_block

#method_before
public static MediaItem2 convertToMediaItem2(MediaItem item) {
    if (item == null) {
        return null;
    }
    MediaMetadata2 metadata2 = convertToMediaMetadata2(item.getDescription(), item.isBrowsable(), item.isPlayable());
    return new MediaItem2.Builder().setMediaId(item.getMediaId()).setMetadata(metadata2).build();
}
#method_after
public static MediaItem2 convertToMediaItem2(MediaItem item) {
    if (item == null) {
        return null;
    }
    MediaMetadata2 metadata2 = convertToMediaMetadata2(item.getDescription(), item.isBrowsable(), item.isPlayable());
    return new MediaItem2.Builder().setMetadata(metadata2).build();
}
#end_block

#method_before
/**
 * Convert a {@link PlaybackStateCompat.State} into {@link SessionPlayer2.BuffState}.
 */
public static int toBufferingState(int playbackStateCompatState) {
    switch(playbackStateCompatState) {
        case PlaybackStateCompat.STATE_BUFFERING:
            return SessionPlayer2.BUFFERING_STATE_BUFFERING_AND_STARVED;
        case PlaybackStateCompat.STATE_PLAYING:
            return SessionPlayer2.BUFFERING_STATE_BUFFERING_COMPLETE;
        default:
            return SessionPlayer2.BUFFERING_STATE_UNKNOWN;
    }
}
#method_after
/**
 * Convert a {@link PlaybackStateCompat.State} into {@link SessionPlayer2.BuffState}.
 */
public static int toBufferingState(int playbackStateCompatState) {
    switch(playbackStateCompatState) {
        case PlaybackStateCompat.STATE_BUFFERING:
            return SessionPlayer2.BUFFERING_STATE_BUFFERING_AND_STARVED;
        case PlaybackStateCompat.STATE_PLAYING:
            return SessionPlayer2.BUFFERING_STATE_COMPLETE;
        default:
            return SessionPlayer2.BUFFERING_STATE_UNKNOWN;
    }
}
#end_block

#method_before
/**
 * Return this object as a bundle to share between processes.
 *
 * @return a new bundle instance
 * @hide
 */
@NonNull
public Bundle toBundle() {
    Bundle bundle = new Bundle();
    bundle.putString(KEY_ID, mMediaId);
    if (mMetadata != null) {
        bundle.putBundle(KEY_METADATA, mMetadata.toBundle());
    }
    bundle.putParcelable(KEY_UUID, mParcelUuid);
    return bundle;
}
#method_after
/**
 * Return this object as a bundle to share between processes.
 *
 * @return a new bundle instance
 * @hide
 */
@NonNull
public Bundle toBundle() {
    Bundle bundle = new Bundle();
    if (mMetadata != null) {
        bundle.putBundle(KEY_METADATA, mMetadata.toBundle());
    }
    bundle.putParcelable(KEY_UUID, mParcelUuid);
    return bundle;
}
#end_block

#method_before
static MediaItem2 fromBundle(@NonNull Bundle bundle, @Nullable ParcelUuid parcelUuid) {
    if (bundle == null) {
        return null;
    }
    final UUID uuid = (parcelUuid != null) ? parcelUuid.getUuid() : null;
    final String id = bundle.getString(KEY_ID);
    final Bundle metadataBundle = bundle.getBundle(KEY_METADATA);
    final MediaMetadata2 metadata = metadataBundle != null ? MediaMetadata2.fromBundle(metadataBundle) : null;
    return new MediaItem2(uuid, id, metadata, 0, 0, 0);
}
#method_after
static MediaItem2 fromBundle(@NonNull Bundle bundle, @Nullable ParcelUuid parcelUuid) {
    if (bundle == null) {
        return null;
    }
    final UUID uuid = (parcelUuid != null) ? parcelUuid.getUuid() : null;
    final Bundle metadataBundle = bundle.getBundle(KEY_METADATA);
    final MediaMetadata2 metadata = metadataBundle != null ? MediaMetadata2.fromBundle(metadataBundle) : null;
    return new MediaItem2(uuid, metadata, 0, 0);
}
#end_block

#method_before
@Override
public String toString() {
    final StringBuilder sb = new StringBuilder("MediaItem2{");
    sb.append("mMediaId=").append(mMediaId);
    sb.append(", mMetadata=").append(mMetadata);
    sb.append(", mStartPositionMs=").append(mStartPositionMs);
    sb.append(", mEndPositionMs=").append(mEndPositionMs);
    sb.append('}');
    return sb.toString();
}
#method_after
@Override
public String toString() {
    final StringBuilder sb = new StringBuilder("MediaItem2{");
    sb.append("mMetadata=").append(mMetadata);
    sb.append(", mStartPositionMs=").append(mStartPositionMs);
    sb.append(", mEndPositionMs=").append(mEndPositionMs);
    sb.append('}');
    return sb.toString();
}
#end_block

#method_before
public void setMetadata(@Nullable MediaMetadata2 metadata) {
    if (metadata != null && !TextUtils.equals(mMediaId, metadata.getMediaId())) {
        throw new IllegalArgumentException("metadata's id should be matched with the mediaId");
    }
    mMetadata = metadata;
    if (metadata != null) {
        mDurationMs = metadata.getLong(MediaMetadata2.METADATA_KEY_DURATION);
    }
}
#method_after
public void setMetadata(@Nullable MediaMetadata2 metadata) {
    if (metadata != null && !TextUtils.equals(getMediaId(), metadata.getMediaId())) {
        throw new IllegalArgumentException("metadata's id should be matched with the mediaId");
    }
    mMetadata = metadata;
    List<Pair<OnMetadataChangedListener, Executor>> listeners = new ArrayList<>();
    synchronized (mLock) {
        listeners.addAll(mListeners);
    }
    for (Pair<OnMetadataChangedListener, Executor> pair : listeners) {
        final OnMetadataChangedListener listener = pair.first;
        pair.second.execute(new Runnable() {

            @Override
            public void run() {
                listener.onMetadataChanged(MediaItem2.this);
            }
        });
    }
}
#end_block

#method_before
/**
 * Gets the media id for this item. If it's not {@code null}, it's a persistent unique key
 * for the underlying media content.
 *
 * @return media Id from the session
 * @hide
 */
@RestrictTo(LIBRARY)
@Nullable
public String getMediaId() {
    return mMediaId;
}
#method_after
/**
 * Gets the media id for this item. If it's not {@code null}, it's a persistent unique key
 * for the underlying media content.
 *
 * @return media Id from the session
 * @hide
 */
@RestrictTo(LIBRARY)
@Nullable
public String getMediaId() {
    return mMetadata != null ? mMetadata.getString(MediaMetadata2.METADATA_KEY_MEDIA_ID) : null;
}
#end_block

#method_before
@Override
public ListenableFuture<BrowserResult> subscribe(@NonNull String parentId, @Nullable LibraryParams params) {
    if (parentId == null) {
        throw new IllegalArgumentException("parentId shouldn't be null");
    }
    MediaBrowserCompat browser = getBrowserCompat();
    if (browser == null) {
        return BrowserResult.createFutureWithResult(RESULT_CODE_DISCONNECTED);
    }
    SubscribeCallback callback = new SubscribeCallback();
    synchronized (mLock) {
        List<SubscribeCallback> list = mSubscribeCallbacks.get(parentId);
        if (list == null) {
            list = new ArrayList<>();
            mSubscribeCallbacks.put(parentId, list);
        }
        list.add(callback);
    }
    browser.subscribe(parentId, getExtras(params), callback);
    // No way to get result. Just return success.
    return BrowserResult.createFutureWithResult(BrowserResult.RESULT_CODE_SUCCESS);
}
#method_after
@Override
public ListenableFuture<BrowserResult> subscribe(@NonNull String parentId, @Nullable LibraryParams params) {
    MediaBrowserCompat browser = getBrowserCompat();
    if (browser == null) {
        return BrowserResult.createFutureWithResult(RESULT_CODE_DISCONNECTED);
    }
    SubscribeCallback callback = new SubscribeCallback();
    synchronized (mLock) {
        List<SubscribeCallback> list = mSubscribeCallbacks.get(parentId);
        if (list == null) {
            list = new ArrayList<>();
            mSubscribeCallbacks.put(parentId, list);
        }
        list.add(callback);
    }
    browser.subscribe(parentId, getExtras(params), callback);
    // No way to get result. Just return success.
    return BrowserResult.createFutureWithResult(BrowserResult.RESULT_CODE_SUCCESS);
}
#end_block

#method_before
@Override
public ListenableFuture<BrowserResult> unsubscribe(@NonNull String parentId) {
    if (parentId == null) {
        throw new IllegalArgumentException("parentId shouldn't be null");
    }
    MediaBrowserCompat browser = getBrowserCompat();
    if (browser == null) {
        return BrowserResult.createFutureWithResult(RESULT_CODE_DISCONNECTED);
    }
    // callback for getChildren.
    synchronized (mLock) {
        List<SubscribeCallback> list = mSubscribeCallbacks.get(parentId);
        if (list == null) {
            return BrowserResult.createFutureWithResult(RESULT_CODE_BAD_VALUE);
        }
        for (int i = 0; i < list.size(); i++) {
            browser.unsubscribe(parentId, list.get(i));
        }
    }
    // No way to get result. Just return success.
    return BrowserResult.createFutureWithResult(BrowserResult.RESULT_CODE_SUCCESS);
}
#method_after
@Override
public ListenableFuture<BrowserResult> unsubscribe(@NonNull String parentId) {
    MediaBrowserCompat browser = getBrowserCompat();
    if (browser == null) {
        return BrowserResult.createFutureWithResult(RESULT_CODE_DISCONNECTED);
    }
    // callback for getChildren.
    synchronized (mLock) {
        List<SubscribeCallback> list = mSubscribeCallbacks.get(parentId);
        if (list == null) {
            return BrowserResult.createFutureWithResult(RESULT_CODE_BAD_VALUE);
        }
        for (int i = 0; i < list.size(); i++) {
            browser.unsubscribe(parentId, list.get(i));
        }
    }
    // No way to get result. Just return success.
    return BrowserResult.createFutureWithResult(BrowserResult.RESULT_CODE_SUCCESS);
}
#end_block

#method_before
@Override
public ListenableFuture<BrowserResult> getChildren(@NonNull String parentId, int page, int pageSize, @Nullable LibraryParams params) {
    if (parentId == null) {
        throw new IllegalArgumentException("parentId shouldn't be null");
    }
    if (page < 0) {
        throw new IllegalArgumentException("page shouldn't be negative");
    }
    if (pageSize < 1) {
        throw new IllegalArgumentException("pageSize shouldn't be less than 1");
    }
    MediaBrowserCompat browser = getBrowserCompat();
    if (browser == null) {
        return BrowserResult.createFutureWithResult(RESULT_CODE_DISCONNECTED);
    }
    final ResolvableFuture<BrowserResult> future = ResolvableFuture.create();
    Bundle options = createBundle(params);
    options.putInt(MediaBrowserCompat.EXTRA_PAGE, page);
    options.putInt(MediaBrowserCompat.EXTRA_PAGE_SIZE, pageSize);
    browser.subscribe(parentId, options, new GetChildrenCallback(future, parentId));
    return future;
}
#method_after
@Override
public ListenableFuture<BrowserResult> getChildren(@NonNull String parentId, int page, int pageSize, @Nullable LibraryParams params) {
    MediaBrowserCompat browser = getBrowserCompat();
    if (browser == null) {
        return BrowserResult.createFutureWithResult(RESULT_CODE_DISCONNECTED);
    }
    final ResolvableFuture<BrowserResult> future = ResolvableFuture.create();
    Bundle options = createBundle(params);
    options.putInt(MediaBrowserCompat.EXTRA_PAGE, page);
    options.putInt(MediaBrowserCompat.EXTRA_PAGE_SIZE, pageSize);
    browser.subscribe(parentId, options, new GetChildrenCallback(future, parentId));
    return future;
}
#end_block

#method_before
@Override
public void onChildrenLoaded(final String parentId, List<MediaItem> children, final Bundle options) {
    final MediaBrowserCompat browser = getBrowserCompat();
    if (browser == null) {
        // Browser is closed.
        return;
    }
    final int itemCount;
    if (children != null) {
        itemCount = children.size();
    } else {
        // Currently no way to tell failures in MediaBrowser2#subscribe().
        return;
    }
    final LibraryParams params = MediaUtils2.convertToLibraryParams(mContext, browser.getNotifyChildrenChangedOptions());
    getCallbackExecutor().execute(new Runnable() {

        @Override
        public void run() {
            // TODO(Post-P): Cache children result for later getChildren() calls.
            getCallback().onChildrenChanged(getInstance(), parentId, itemCount, params);
        }
    });
}
#method_after
@Override
public void onChildrenLoaded(final String parentId, List<MediaItem> children, final Bundle options) {
    if (TextUtils.isEmpty(parentId)) {
        Log.w(TAG, "SubscribeCallback.onChildrenLoaded(): Ignoring empty parentId");
        return;
    }
    final MediaBrowserCompat browser = getBrowserCompat();
    if (browser == null) {
        // Browser is closed.
        return;
    }
    final int itemCount;
    if (children != null) {
        itemCount = children.size();
    } else {
        // Currently no way to tell failures in MediaBrowser2#subscribe().
        return;
    }
    final LibraryParams params = MediaUtils2.convertToLibraryParams(mContext, browser.getNotifyChildrenChangedOptions());
    getCallbackExecutor().execute(new Runnable() {

        @Override
        public void run() {
            // TODO(Post-P): Cache children result for later getChildren() calls.
            getCallback().onChildrenChanged(getInstance(), parentId, itemCount, params);
        }
    });
}
#end_block

#method_before
@Override
public void onChildrenLoaded(final String parentId, List<MediaItem> children, Bundle options) {
    MediaBrowserCompat browser = getBrowserCompat();
    if (browser == null) {
        mFuture.set(new BrowserResult(RESULT_CODE_DISCONNECTED));
        return;
    }
    browser.unsubscribe(mParentId, GetChildrenCallback.this);
    final List<MediaItem2> items = new ArrayList<>();
    if (children == null) {
        // list are non-Null, so it must be internal error.
        mFuture.set(new BrowserResult(RESULT_CODE_UNKNOWN_ERROR));
    } else {
        for (int i = 0; i < children.size(); i++) {
            items.add(MediaUtils2.convertToMediaItem2(children.get(i)));
        }
        // Don't set extra here, because 'extra' have different meanings between old
        // API and new API as follows.
        // - Old API: Extra/Option specified with subscribe().
        // - New API: Extra from MediaLibraryService2 to MediaBrowser2
        mFuture.set(new BrowserResult(RESULT_CODE_SUCCESS, items, null));
    }
}
#method_after
@Override
public void onChildrenLoaded(final String parentId, List<MediaItem> children, Bundle options) {
    if (TextUtils.isEmpty(parentId)) {
        Log.w(TAG, "GetChildrenCallback.onChildrenLoaded(): Ignoring empty parentId");
        return;
    }
    MediaBrowserCompat browser = getBrowserCompat();
    if (browser == null) {
        mFuture.set(new BrowserResult(RESULT_CODE_DISCONNECTED));
        return;
    }
    browser.unsubscribe(mParentId, GetChildrenCallback.this);
    final List<MediaItem2> items = new ArrayList<>();
    if (children == null) {
        // list are non-Null, so it must be internal error.
        mFuture.set(new BrowserResult(RESULT_CODE_UNKNOWN_ERROR));
    } else {
        for (int i = 0; i < children.size(); i++) {
            items.add(MediaUtils2.convertToMediaItem2(children.get(i)));
        }
        // Don't set extra here, because 'extra' have different meanings between old
        // API and new API as follows.
        // - Old API: Extra/Option specified with subscribe().
        // - New API: Extra from MediaLibraryService2 to MediaBrowser2
        mFuture.set(new BrowserResult(RESULT_CODE_SUCCESS, items, null));
    }
}
#end_block

#method_before
@Test
public void testNotification() throws InterruptedException {
    prepareLooper();
    final CountDownLatch latch = new CountDownLatch(1);
    final MediaLibrarySessionCallback sessionCallback = new MediaLibrarySessionCallback() {

        @Override
        public SessionCommandGroup2 onConnect(@NonNull MediaSession2 session, @NonNull ControllerInfo controller) {
            if (CLIENT_PACKAGE_NAME.equals(controller.getPackageName())) {
                mSession = session;
                // Change the player and playlist agent with ours.
                session.updatePlayer(mPlayer);
                latch.countDown();
            }
            return super.onConnect(session, controller);
        }
    };
    TestServiceRegistry.getInstance().setSessionCallback(sessionCallback);
    // Create a controller to start the service.
    RemoteMediaController2 controller = new RemoteMediaController2(mContext, new SessionToken2(mContext, MOCK_MEDIA_SESSION_SERVICE), true);
    // Set current media item.
    final String mediaId = "testMediaId";
    Bitmap albumArt = BitmapFactory.decodeResource(mContext.getResources(), android.support.mediacompat.service.R.drawable.big_buck_bunny);
    MediaMetadata2 metadata = new MediaMetadata2.Builder().putText(MediaMetadata2.METADATA_KEY_MEDIA_ID, mediaId).putText(MediaMetadata2.METADATA_KEY_DISPLAY_TITLE, "Test Song Name").putText(MediaMetadata2.METADATA_KEY_ARTIST, "Test Artist Name").putBitmap(MediaMetadata2.METADATA_KEY_ALBUM_ART, albumArt).putLong(MediaMetadata2.METADATA_KEY_PLAYABLE, 1).build();
    mPlayer.mCurrentMediaItem = new MediaItem2.Builder().setMetadata(metadata).setMediaId(mediaId).build();
    // Notification should be shown. Clicking play/pause button will change the player state.
    // When playing, the notification will not be removed by swiping horizontally.
    // When paused, the notification can be swiped away.
    mPlayer.notifyPlayerStateChanged(SessionPlayer2.PLAYER_STATE_PLAYING);
    Thread.sleep(NOTIFICATION_SHOW_TIME_MS);
}
#method_after
@Test
public void testNotification() throws InterruptedException {
    prepareLooper();
    final CountDownLatch latch = new CountDownLatch(1);
    final MediaLibrarySessionCallback sessionCallback = new MediaLibrarySessionCallback() {

        @Override
        public SessionCommandGroup2 onConnect(@NonNull MediaSession2 session, @NonNull ControllerInfo controller) {
            if (CLIENT_PACKAGE_NAME.equals(controller.getPackageName())) {
                mSession = session;
                // Change the player and playlist agent with ours.
                session.updatePlayer(mPlayer);
                latch.countDown();
            }
            return super.onConnect(session, controller);
        }
    };
    TestServiceRegistry.getInstance().setSessionCallback(sessionCallback);
    // Create a controller to start the service.
    RemoteMediaController2 controller = new RemoteMediaController2(mContext, new SessionToken2(mContext, MOCK_MEDIA_SESSION_SERVICE), true);
    // Set current media item.
    final String mediaId = "testMediaId";
    Bitmap albumArt = BitmapFactory.decodeResource(mContext.getResources(), android.support.mediacompat.service.R.drawable.big_buck_bunny);
    MediaMetadata2 metadata = new MediaMetadata2.Builder().putText(MediaMetadata2.METADATA_KEY_MEDIA_ID, mediaId).putText(MediaMetadata2.METADATA_KEY_DISPLAY_TITLE, "Test Song Name").putText(MediaMetadata2.METADATA_KEY_ARTIST, "Test Artist Name").putBitmap(MediaMetadata2.METADATA_KEY_ALBUM_ART, albumArt).putLong(MediaMetadata2.METADATA_KEY_PLAYABLE, 1).build();
    mPlayer.mCurrentMediaItem = new MediaItem2.Builder().setMetadata(metadata).build();
    // Notification should be shown. Clicking play/pause button will change the player state.
    // When playing, the notification will not be removed by swiping horizontally.
    // When paused, the notification can be swiped away.
    mPlayer.notifyPlayerStateChanged(SessionPlayer2.PLAYER_STATE_PLAYING);
    Thread.sleep(NOTIFICATION_SHOW_TIME_MS);
}
#end_block

#method_before
public static List<MediaItem2> createPlaylist(int size) {
    final List<MediaItem2> list = new ArrayList<>();
    String caller = Thread.currentThread().getStackTrace()[3].getMethodName();
    for (int i = 0; i < size; i++) {
        MediaItem2 item = new FileMediaItem2.Builder(new FileDescriptor()).setMediaId(caller + "_item_" + (size + 1)).build();
        list.add(item);
    }
    return list;
}
#method_after
public static List<MediaItem2> createPlaylist(int size) {
    final List<MediaItem2> list = new ArrayList<>();
    String caller = Thread.currentThread().getStackTrace()[3].getMethodName();
    for (int i = 0; i < size; i++) {
        MediaItem2 item = new FileMediaItem2.Builder(new FileDescriptor()).setMetadata(new MediaMetadata2.Builder().putString(MediaMetadata2.METADATA_KEY_MEDIA_ID, caller + "_item_" + (size + 1)).build()).build();
        list.add(item);
    }
    return list;
}
#end_block

#method_before
public static MediaMetadata2 createMetadata() {
    String mediaId = Thread.currentThread().getStackTrace()[3].getMethodName();
    return new MediaMetadata2.Builder().putString(MediaMetadata2.METADATA_KEY_MEDIA_ID, mediaId).build();
}
#method_after
public static MediaMetadata2 createMetadata(String mediaId, long duration) {
    return new MediaMetadata2.Builder().putString(MediaMetadata2.METADATA_KEY_MEDIA_ID, mediaId).putLong(MediaMetadata2.METADATA_KEY_DURATION, duration).build();
}
#end_block

#method_before
@Test
public void testGettersAfterConnected() throws Exception {
    prepareLooper();
    final long position = 150000;
    final long bufferedPosition = 900000;
    final long timeDiff = 102;
    final float speed = 0.5f;
    final MediaMetadataCompat metadata = MediaUtils2.convertToMediaMetadataCompat(MediaTestUtils.createMetadata());
    mSession.setPlaybackState(new PlaybackStateCompat.Builder().setState(PlaybackStateCompat.STATE_PLAYING, position, speed).setBufferedPosition(bufferedPosition).build());
    mSession.setMetadata(metadata);
    mController = createController(mSession.getSessionToken());
    mController.setTimeDiff(timeDiff);
    assertEquals(SessionPlayer2.PLAYER_STATE_PLAYING, mController.getPlayerState());
    assertEquals(SessionPlayer2.BUFFERING_STATE_BUFFERING_COMPLETE, mController.getBufferingState());
    assertEquals(bufferedPosition, mController.getBufferedPosition());
    assertEquals(speed, mController.getPlaybackSpeed(), 0.0f);
    assertEquals((double) position + (speed * timeDiff), (double) mController.getCurrentPosition(), 100.0);
    assertEquals(metadata.getDescription().getMediaId(), mController.getCurrentMediaItem().getMediaId());
}
#method_after
@Test
public void testGettersAfterConnected() throws Exception {
    prepareLooper();
    final long position = 150000;
    final long bufferedPosition = 900000;
    final long timeDiff = 102;
    final float speed = 0.5f;
    final MediaMetadataCompat metadata = MediaUtils2.convertToMediaMetadataCompat(MediaTestUtils.createMetadata());
    mSession.setPlaybackState(new PlaybackStateCompat.Builder().setState(PlaybackStateCompat.STATE_PLAYING, position, speed).setBufferedPosition(bufferedPosition).build());
    mSession.setMetadata(metadata);
    mController = createController(mSession.getSessionToken());
    mController.setTimeDiff(timeDiff);
    assertEquals(SessionPlayer2.PLAYER_STATE_PLAYING, mController.getPlayerState());
    assertEquals(SessionPlayer2.BUFFERING_STATE_COMPLETE, mController.getBufferingState());
    assertEquals(bufferedPosition, mController.getBufferedPosition());
    assertEquals(speed, mController.getPlaybackSpeed(), 0.0f);
    assertEquals((double) position + (speed * timeDiff), (double) mController.getCurrentPosition(), 100.0);
    assertEquals(metadata.getDescription().getMediaId(), mController.getCurrentMediaItem().getMediaId());
}
#end_block

#method_before
@Test
@Ignore("b/110738672")
public void testControllerCallbackBufferingCompleted() throws Exception {
    prepareLooper();
    final List<MediaItem2> testPlaylist = MediaTestUtils.createPlaylist(1);
    final MediaMetadataCompat metadata = MediaUtils2.convertToMediaMetadataCompat(testPlaylist.get(0).getMetadata());
    final int testBufferingState = SessionPlayer2.BUFFERING_STATE_BUFFERING_COMPLETE;
    final long testBufferingPosition = 500;
    final CountDownLatch latch = new CountDownLatch(1);
    final ControllerCallback callback = new ControllerCallback() {

        @Override
        public void onBufferingStateChanged(MediaController2 controller, MediaItem2 item, int state) {
            assertEquals(metadata.getDescription().getMediaId(), item.getMediaId());
            assertEquals(testBufferingState, state);
            assertEquals(testBufferingState, controller.getBufferingState());
            assertEquals(testBufferingPosition, controller.getBufferedPosition());
            latch.countDown();
        }
    };
    mSession.setMetadata(metadata);
    mSession.setPlaybackState(new PlaybackStateCompat.Builder().setState(PlaybackStateCompat.STATE_BUFFERING, 0, /* position */
    1f).setBufferedPosition(0).build());
    mController = createController(mSession.getSessionToken(), true, callback);
    mController.setTimeDiff(Long.valueOf(0));
    mSession.setPlaybackState(new PlaybackStateCompat.Builder().setState(PlaybackStateCompat.STATE_PLAYING, 0, /* position */
    1f).setBufferedPosition(testBufferingPosition).build());
    assertTrue(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
}
#method_after
@Test
@Ignore("b/110738672")
public void testControllerCallbackBufferingCompleted() throws Exception {
    prepareLooper();
    final List<MediaItem2> testPlaylist = MediaTestUtils.createPlaylist(1);
    final MediaMetadataCompat metadata = MediaUtils2.convertToMediaMetadataCompat(testPlaylist.get(0).getMetadata());
    final int testBufferingState = SessionPlayer2.BUFFERING_STATE_COMPLETE;
    final long testBufferingPosition = 500;
    final CountDownLatch latch = new CountDownLatch(1);
    final ControllerCallback callback = new ControllerCallback() {

        @Override
        public void onBufferingStateChanged(MediaController2 controller, MediaItem2 item, int state) {
            assertEquals(metadata.getDescription().getMediaId(), item.getMediaId());
            assertEquals(testBufferingState, state);
            assertEquals(testBufferingState, controller.getBufferingState());
            assertEquals(testBufferingPosition, controller.getBufferedPosition());
            latch.countDown();
        }
    };
    mSession.setMetadata(metadata);
    mSession.setPlaybackState(new PlaybackStateCompat.Builder().setState(PlaybackStateCompat.STATE_BUFFERING, 0, /* position */
    1f).setBufferedPosition(0).build());
    mController = createController(mSession.getSessionToken(), true, callback);
    mController.setTimeDiff(Long.valueOf(0));
    mSession.setPlaybackState(new PlaybackStateCompat.Builder().setState(PlaybackStateCompat.STATE_PLAYING, 0, /* position */
    1f).setBufferedPosition(testBufferingPosition).build());
    assertTrue(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
}
#end_block

#method_before
@Override
public void createAndSetDummyPlaylist(String sessionId, int size) throws RemoteException {
    MediaSession2 session2 = mSession2Map.get(sessionId);
    MockPlayer player = (MockPlayer) session2.getPlayer();
    List<MediaItem2> list = new ArrayList<>();
    for (int i = 0; i < size; i++) {
        list.add(new MediaItem2.Builder().setMediaId(TestUtils.getMediaIdInDummyList(i)).build());
    }
    player.mPlaylist = list;
}
#method_after
@Override
public void createAndSetDummyPlaylist(String sessionId, int size) throws RemoteException {
    MediaSession2 session2 = mSession2Map.get(sessionId);
    MockPlayer player = (MockPlayer) session2.getPlayer();
    List<MediaItem2> list = new ArrayList<>();
    for (int i = 0; i < size; i++) {
        list.add(new MediaItem2.Builder().setMetadata(new MediaMetadata2.Builder().putString(MediaMetadata2.METADATA_KEY_MEDIA_ID, TestUtils.getMediaIdInDummyList(i)).build()).build());
    }
    player.mPlaylist = list;
}
#end_block

#method_before
@Override
public void setPlaylistWithDummyItem(String sessionId, List<Bundle> playlist) throws RemoteException {
    MediaSession2 session2 = mSession2Map.get(sessionId);
    MockPlayer player = (MockPlayer) session2.getPlayer();
    List<MediaItem2> list = new ArrayList<>();
    for (Bundle bundle : playlist) {
        MediaItem2 item = MediaItem2.fromBundle(bundle);
        list.add(new FileMediaItem2.Builder(new FileDescriptor()).setMetadata(item.getMetadata()).setMediaId(item.getMediaId()).build());
    }
    player.mPlaylist = list;
}
#method_after
@Override
public void setPlaylistWithDummyItem(String sessionId, List<Bundle> playlist) throws RemoteException {
    MediaSession2 session2 = mSession2Map.get(sessionId);
    MockPlayer player = (MockPlayer) session2.getPlayer();
    List<MediaItem2> list = new ArrayList<>();
    for (Bundle bundle : playlist) {
        MediaItem2 item = MediaItem2.fromBundle(bundle);
        list.add(new FileMediaItem2.Builder(new FileDescriptor()).setMetadata(item.getMetadata()).build());
    }
    player.mPlaylist = list;
}
#end_block

#method_before
private MediaItem2 createMediaItem(String mediaId) {
    return new MediaItem2.Builder().setMediaId(mediaId).setMetadata(new MediaMetadata2.Builder().putString(MediaMetadata2.METADATA_KEY_MEDIA_ID, mediaId).putLong(MediaMetadata2.METADATA_KEY_BROWSABLE, MediaMetadata2.BROWSABLE_TYPE_MIXED).build()).build();
}
#method_after
private MediaItem2 createMediaItem(String mediaId) {
    return new MediaItem2.Builder().setMetadata(new MediaMetadata2.Builder().putString(MediaMetadata2.METADATA_KEY_MEDIA_ID, mediaId).putLong(MediaMetadata2.METADATA_KEY_BROWSABLE, MediaMetadata2.BROWSABLE_TYPE_MIXED).build()).build();
}
#end_block

#method_before
@Override
public LibraryResult onGetChildren(MediaLibrarySession session, ControllerInfo controller, String parentId, int page, int pageSize, LibraryParams params) {
    assertLibraryParams(params);
    if (PARENT_ID.equals(parentId)) {
        return new LibraryResult(RESULT_CODE_SUCCESS, getPaginatedResult(GET_CHILDREN_RESULT, page, pageSize), null);
    } else if (PARENT_ID_LONG_LIST.equals(parentId)) {
        List<MediaItem2> list = new ArrayList<>(LONG_LIST_COUNT);
        MediaItem2.Builder builder = new MediaItem2.Builder();
        for (int i = 0; i < LONG_LIST_COUNT; i++) {
            list.add(builder.setMediaId(TestUtils.getMediaIdInDummyList(i)).build());
        }
        return new LibraryResult(RESULT_CODE_SUCCESS, list, null);
    } else if (PARENT_ID_ERROR.equals(parentId)) {
        return new LibraryResult(RESULT_CODE_BAD_VALUE);
    }
    // Includes the case of PARENT_ID_NO_CHILDREN.
    return new LibraryResult(RESULT_CODE_SUCCESS, new ArrayList<MediaItem2>(), null);
}
#method_after
@Override
public LibraryResult onGetChildren(MediaLibrarySession session, ControllerInfo controller, String parentId, int page, int pageSize, LibraryParams params) {
    assertLibraryParams(params);
    if (PARENT_ID.equals(parentId)) {
        return new LibraryResult(RESULT_CODE_SUCCESS, getPaginatedResult(GET_CHILDREN_RESULT, page, pageSize), null);
    } else if (PARENT_ID_LONG_LIST.equals(parentId)) {
        List<MediaItem2> list = new ArrayList<>(LONG_LIST_COUNT);
        MediaItem2.Builder builder = new MediaItem2.Builder();
        for (int i = 0; i < LONG_LIST_COUNT; i++) {
            list.add(builder.setMetadata(new MediaMetadata2.Builder().putString(MediaMetadata2.METADATA_KEY_MEDIA_ID, TestUtils.getMediaIdInDummyList(i)).build()).build());
        }
        return new LibraryResult(RESULT_CODE_SUCCESS, list, null);
    } else if (PARENT_ID_ERROR.equals(parentId)) {
        return new LibraryResult(RESULT_CODE_BAD_VALUE);
    }
    // Includes the case of PARENT_ID_NO_CHILDREN.
    return new LibraryResult(RESULT_CODE_SUCCESS, new ArrayList<MediaItem2>(), null);
}
#end_block

#method_before
@Override
public LibraryResult onGetSearchResult(MediaLibrarySession session, ControllerInfo controllerInfo, String query, int page, int pageSize, LibraryParams params) {
    assertLibraryParams(params);
    if (SEARCH_QUERY.equals(query)) {
        return new LibraryResult(RESULT_CODE_SUCCESS, getPaginatedResult(SEARCH_RESULT, page, pageSize), null);
    } else if (SEARCH_QUERY_LONG_LIST.equals(query)) {
        List<MediaItem2> list = new ArrayList<>(LONG_LIST_COUNT);
        MediaItem2.Builder builder = new MediaItem2.Builder();
        for (int i = 0; i < LONG_LIST_COUNT; i++) {
            list.add(builder.setMediaId(TestUtils.getMediaIdInDummyList(i)).build());
        }
        return new LibraryResult(RESULT_CODE_SUCCESS, list, null);
    } else if (SEARCH_QUERY_EMPTY_RESULT.equals(query)) {
        return new LibraryResult(RESULT_CODE_SUCCESS, new ArrayList<MediaItem2>(), null);
    } else {
        // SEARCH_QUERY_ERROR will be handled here.
        return new LibraryResult(RESULT_CODE_BAD_VALUE);
    }
}
#method_after
@Override
public LibraryResult onGetSearchResult(MediaLibrarySession session, ControllerInfo controllerInfo, String query, int page, int pageSize, LibraryParams params) {
    assertLibraryParams(params);
    if (SEARCH_QUERY.equals(query)) {
        return new LibraryResult(RESULT_CODE_SUCCESS, getPaginatedResult(SEARCH_RESULT, page, pageSize), null);
    } else if (SEARCH_QUERY_LONG_LIST.equals(query)) {
        List<MediaItem2> list = new ArrayList<>(LONG_LIST_COUNT);
        MediaItem2.Builder builder = new MediaItem2.Builder();
        for (int i = 0; i < LONG_LIST_COUNT; i++) {
            list.add(builder.setMetadata(new MediaMetadata2.Builder().putString(MediaMetadata2.METADATA_KEY_MEDIA_ID, TestUtils.getMediaIdInDummyList(i)).build()).build());
        }
        return new LibraryResult(RESULT_CODE_SUCCESS, list, null);
    } else if (SEARCH_QUERY_EMPTY_RESULT.equals(query)) {
        return new LibraryResult(RESULT_CODE_SUCCESS, new ArrayList<MediaItem2>(), null);
    } else {
        // SEARCH_QUERY_ERROR will be handled here.
        return new LibraryResult(RESULT_CODE_BAD_VALUE);
    }
}
#end_block

#method_before
private MediaItem2 createMediaItem(String mediaId) {
    MediaMetadata2 metadata = new MediaMetadata2.Builder().putString(MediaMetadata2.METADATA_KEY_MEDIA_ID, mediaId).putLong(MediaMetadata2.METADATA_KEY_PLAYABLE, 1).build();
    return new MediaItem2.Builder().setMediaId(mediaId).setMetadata(metadata).build();
}
#method_after
private MediaItem2 createMediaItem(String mediaId) {
    MediaMetadata2 metadata = new MediaMetadata2.Builder().putString(MediaMetadata2.METADATA_KEY_MEDIA_ID, mediaId).putLong(MediaMetadata2.METADATA_KEY_PLAYABLE, 1).build();
    return new MediaItem2.Builder().setMetadata(metadata).build();
}
#end_block

#method_before
@Override
protected void onCreate(Bundle savedInstanceSttate) {
    super.onCreate(savedInstanceSttate);
    // Set an empty view since we're only interested in the action bar styling.
    setContentView(new FrameLayout(/* context= */
    this));
}
#method_after
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    // Set an empty view since we're only interested in the action bar styling.
    setContentView(new FrameLayout(/* context= */
    this));
}
#end_block

#method_before
protected String convertNumberIfNecessary(Phone phone, String dialNumber) {
    if (dialNumber == null) {
        return dialNumber;
    }
    String[] convertMaps = null;
    CarrierConfigManager configManager = (CarrierConfigManager) phone.getContext().getSystemService(Context.CARRIER_CONFIG_SERVICE);
    PersistableBundle bundle = configManager.getConfigForSubId(getSubId());
    if (bundle != null) {
        convertMaps = bundle.getStringArray(CarrierConfigManager.KEY_DIAL_STRING_REPLACE_STRING_ARRAY);
    }
    if (convertMaps == null) {
        // By default no replacement is necessary
        log("convertNumberIfNecessary convertMaps is null");
        return dialNumber;
    }
    log("convertNumberIfNecessary Roaming" + " convertMaps.length " + convertMaps.length + " dialNumber.length() " + dialNumber.length());
    if (convertMaps.length < 1 || dialNumber.length() < VALID_COMPARE_LENGTH) {
        return dialNumber;
    }
    String[] entry;
    String outNumber = "";
    for (String convertMap : convertMaps) {
        log("convertNumberIfNecessary: " + convertMap);
        // entry format is  "dialStringToReplace:dialStringReplacement"
        entry = convertMap.split(":");
        if (entry != null && entry.length > 1) {
            String dsToReplace = entry[0];
            String dsReplacement = entry[1];
            if (!TextUtils.isEmpty(dsToReplace) && dialNumber.equals(dsToReplace)) {
                // Needs to be converted
                if (!TextUtils.isEmpty(dsReplacement) && dsReplacement.endsWith("MDN")) {
                    String mdn = phone.getLine1Number();
                    if (!TextUtils.isEmpty(mdn)) {
                        if (mdn.startsWith("+")) {
                            outNumber = mdn;
                        } else {
                            outNumber = dsReplacement.substring(0, dsReplacement.length() - 3) + mdn;
                        }
                    }
                } else {
                    outNumber = dsReplacement;
                }
                break;
            }
        }
    }
    if (!TextUtils.isEmpty(outNumber)) {
        log("convertNumberIfNecessary: convert service number");
        mNumberConverted = true;
        return outNumber;
    }
    return dialNumber;
}
#method_after
protected String convertNumberIfNecessary(Phone phone, String dialNumber) {
    if (dialNumber == null) {
        return dialNumber;
    }
    String[] convertMaps = null;
    CarrierConfigManager configManager = (CarrierConfigManager) phone.getContext().getSystemService(Context.CARRIER_CONFIG_SERVICE);
    PersistableBundle bundle = configManager.getConfigForSubId(phone.getSubId());
    if (bundle != null) {
        convertMaps = bundle.getStringArray(CarrierConfigManager.KEY_DIAL_STRING_REPLACE_STRING_ARRAY);
    }
    if (convertMaps == null) {
        // By default no replacement is necessary
        log("convertNumberIfNecessary convertMaps is null");
        return dialNumber;
    }
    log("convertNumberIfNecessary Roaming" + " convertMaps.length " + convertMaps.length + " dialNumber.length() " + dialNumber.length());
    if (convertMaps.length < 1 || dialNumber.length() < VALID_COMPARE_LENGTH) {
        return dialNumber;
    }
    String[] entry;
    String outNumber = "";
    for (String convertMap : convertMaps) {
        log("convertNumberIfNecessary: " + convertMap);
        // entry format is  "dialStringToReplace:dialStringReplacement"
        entry = convertMap.split(":");
        if (entry != null && entry.length > 1) {
            String dsToReplace = entry[0];
            String dsReplacement = entry[1];
            if (!TextUtils.isEmpty(dsToReplace) && dialNumber.equals(dsToReplace)) {
                // Needs to be converted
                if (!TextUtils.isEmpty(dsReplacement) && dsReplacement.endsWith("MDN")) {
                    String mdn = phone.getLine1Number();
                    if (!TextUtils.isEmpty(mdn)) {
                        if (mdn.startsWith("+")) {
                            outNumber = mdn;
                        } else {
                            outNumber = dsReplacement.substring(0, dsReplacement.length() - 3) + mdn;
                        }
                    }
                } else {
                    outNumber = dsReplacement;
                }
                break;
            }
        }
    }
    if (!TextUtils.isEmpty(outNumber)) {
        log("convertNumberIfNecessary: convert service number");
        mNumberConverted = true;
        return outNumber;
    }
    return dialNumber;
}
#end_block

#method_before
public void onChildrenChanged(@NonNull MediaBrowser2 browser, @NonNull String parentId, int itemCount, @Nullable Bundle extras) {
}
#method_after
public void onChildrenChanged(@NonNull MediaBrowser2 browser, @NonNull String parentId, int itemCount, @Nullable LibraryParams params) {
}
#end_block

#method_before
public void onSearchResultChanged(@NonNull MediaBrowser2 browser, @NonNull String query, int itemCount, @Nullable Bundle extras) {
}
#method_after
public void onSearchResultChanged(@NonNull MediaBrowser2 browser, @NonNull String query, int itemCount, @Nullable LibraryParams params) {
}
#end_block

#method_before
public void getLibraryRoot(@Nullable final Bundle rootHints) {
    if (isConnected()) {
        getImpl().getLibraryRoot(rootHints);
    }
}
#method_after
public ListenableFuture<BrowserResult> getLibraryRoot(@Nullable final LibraryParams params) {
    if (isConnected()) {
        return getImpl().getLibraryRoot(params);
    }
    return createDisconnectedFuture();
}
#end_block

#method_before
public void subscribe(@NonNull String parentId, @Nullable Bundle extras) {
    if (parentId == null) {
        throw new IllegalArgumentException("parentId shouldn't be null");
    }
    if (isConnected()) {
        getImpl().subscribe(parentId, extras);
    }
}
#method_after
public ListenableFuture<BrowserResult> subscribe(@NonNull String parentId, @Nullable LibraryParams params) {
    if (TextUtils.isEmpty(parentId)) {
        throw new IllegalArgumentException("parentId shouldn't be empty");
    }
    if (isConnected()) {
        return getImpl().subscribe(parentId, params);
    }
    return createDisconnectedFuture();
}
#end_block

#method_before
public void unsubscribe(@NonNull String parentId) {
    if (parentId == null) {
        throw new IllegalArgumentException("parentId shouldn't be null");
    }
    if (isConnected()) {
        getImpl().unsubscribe(parentId);
    }
}
#method_after
public ListenableFuture<BrowserResult> unsubscribe(@NonNull String parentId) {
    if (TextUtils.isEmpty(parentId)) {
        throw new IllegalArgumentException("parentId shouldn't be empty");
    }
    if (isConnected()) {
        return getImpl().unsubscribe(parentId);
    }
    return createDisconnectedFuture();
}
#end_block

#method_before
public void getChildren(@NonNull String parentId, int page, int pageSize, @Nullable Bundle extras) {
    if (parentId == null) {
        throw new IllegalArgumentException("parentId shouldn't be null");
    }
    if (page < 0) {
        throw new IllegalArgumentException("page shouldn't be negative");
    }
    if (pageSize < 1) {
        throw new IllegalArgumentException("pageSize shouldn't be less than 1");
    }
    if (isConnected()) {
        getImpl().getChildren(parentId, page, pageSize, extras);
    }
}
#method_after
public ListenableFuture<BrowserResult> getChildren(@NonNull String parentId, @IntRange(from = 0) int page, @IntRange(from = 1) int pageSize, @Nullable LibraryParams params) {
    if (TextUtils.isEmpty(parentId)) {
        throw new IllegalArgumentException("parentId shouldn't be empty");
    }
    if (page < 0) {
        throw new IllegalArgumentException("page shouldn't be negative");
    }
    if (pageSize < 1) {
        throw new IllegalArgumentException("pageSize shouldn't be less than 1");
    }
    if (isConnected()) {
        return getImpl().getChildren(parentId, page, pageSize, params);
    }
    return createDisconnectedFuture();
}
#end_block

#method_before
public void getItem(@NonNull final String mediaId) {
    if (mediaId == null) {
        throw new IllegalArgumentException("mediaId shouldn't be null");
    }
    if (isConnected()) {
        getImpl().getItem(mediaId);
    }
}
#method_after
public ListenableFuture<BrowserResult> getItem(@NonNull final String mediaId) {
    if (TextUtils.isEmpty(mediaId)) {
        throw new IllegalArgumentException("mediaId shouldn't be empty");
    }
    if (isConnected()) {
        return getImpl().getItem(mediaId);
    }
    return createDisconnectedFuture();
}
#end_block

#method_before
public void search(@NonNull String query, @Nullable Bundle extras) {
    if (query == null) {
        throw new IllegalArgumentException("query shouldn't be null");
    }
    if (isConnected()) {
        getImpl().search(query, extras);
    }
}
#method_after
public ListenableFuture<BrowserResult> search(@NonNull String query, @Nullable LibraryParams params) {
    if (TextUtils.isEmpty(query)) {
        throw new IllegalArgumentException("query shouldn't be empty");
    }
    if (isConnected()) {
        return getImpl().search(query, params);
    }
    return createDisconnectedFuture();
}
#end_block

#method_before
public void getSearchResult(@NonNull final String query, final int page, final int pageSize, @Nullable final Bundle extras) {
    if (query == null) {
        throw new IllegalArgumentException("query shouldn't be null");
    }
    if (page < 0) {
        throw new IllegalArgumentException("page shouldn't be negative");
    }
    if (pageSize < 1) {
        throw new IllegalArgumentException("pageSize shouldn't be less than 1");
    }
    if (isConnected()) {
        getImpl().getSearchResult(query, page, pageSize, extras);
    }
}
#method_after
public ListenableFuture<BrowserResult> getSearchResult(@NonNull final String query, @IntRange(from = 0) int page, @IntRange(from = 1) int pageSize, @Nullable final LibraryParams params) {
    if (TextUtils.isEmpty(query)) {
        throw new IllegalArgumentException("query shouldn't be empty");
    }
    if (page < 0) {
        throw new IllegalArgumentException("page shouldn't be negative");
    }
    if (pageSize < 1) {
        throw new IllegalArgumentException("pageSize shouldn't be less than 1");
    }
    if (isConnected()) {
        return getImpl().getSearchResult(query, page, pageSize, params);
    }
    return createDisconnectedFuture();
}
#end_block

#method_before
@Override
public void getLibraryRoot(@Nullable final Bundle extras) {
    final MediaBrowserCompat browser = getBrowserCompat(extras);
    if (browser != null) {
        // Already connected with the given extras.
        getCallbackExecutor().execute(new Runnable() {

            @Override
            public void run() {
                getCallback().onGetLibraryRootDone(getInstance(), extras, browser.getRoot(), browser.getExtras());
            }
        });
    } else {
        getCallbackExecutor().execute(new Runnable() {

            @Override
            public void run() {
                // Do this on the callback executor to set the looper of MediaBrowserCompat's
                // callback handler to this looper.
                MediaBrowserCompat newBrowser = new MediaBrowserCompat(getContext(), getConnectedSessionToken().getComponentName(), new GetLibraryRootCallback(extras), extras);
                synchronized (mLock) {
                    mBrowserCompats.put(extras, newBrowser);
                }
                newBrowser.connect();
            }
        });
    }
}
#method_after
@Override
public ListenableFuture<BrowserResult> getLibraryRoot(@Nullable final LibraryParams params) {
    final ResolvableFuture<BrowserResult> result = ResolvableFuture.create();
    final MediaBrowserCompat browser = getBrowserCompat(params);
    if (browser != null) {
        // Already connected with the given extras.
        result.set(new BrowserResult(RESULT_CODE_SUCCESS, createRootMediaItem(browser), null));
    } else {
        getCallbackExecutor().execute(new Runnable() {

            @Override
            public void run() {
                // Do this on the callback executor to set the looper of MediaBrowserCompat's
                // callback handler to this looper.
                Bundle rootHints = MediaUtils2.convertToRootHints(params);
                MediaBrowserCompat newBrowser = new MediaBrowserCompat(getContext(), getConnectedSessionToken().getComponentName(), new GetLibraryRootCallback(result, params), rootHints);
                synchronized (mLock) {
                    mBrowserCompats.put(params, newBrowser);
                }
                newBrowser.connect();
            }
        });
    }
    return result;
}
#end_block

#method_before
@Override
public void subscribe(@NonNull String parentId, @Nullable Bundle extras) {
    MediaBrowserCompat browser = getBrowserCompat();
    if (browser == null) {
        return;
    }
    SubscribeCallback callback = new SubscribeCallback();
    synchronized (mLock) {
        List<SubscribeCallback> list = mSubscribeCallbacks.get(parentId);
        if (list == null) {
            list = new ArrayList<>();
            mSubscribeCallbacks.put(parentId, list);
        }
        list.add(callback);
    }
    browser.subscribe(parentId, extras, callback);
}
#method_after
@Override
public ListenableFuture<BrowserResult> subscribe(@NonNull String parentId, @Nullable LibraryParams params) {
    MediaBrowserCompat browser = getBrowserCompat();
    if (browser == null) {
        return BrowserResult.createFutureWithResult(RESULT_CODE_DISCONNECTED);
    }
    SubscribeCallback callback = new SubscribeCallback();
    synchronized (mLock) {
        List<SubscribeCallback> list = mSubscribeCallbacks.get(parentId);
        if (list == null) {
            list = new ArrayList<>();
            mSubscribeCallbacks.put(parentId, list);
        }
        list.add(callback);
    }
    browser.subscribe(parentId, getExtras(params), callback);
    // No way to get result. Just return success.
    return BrowserResult.createFutureWithResult(BrowserResult.RESULT_CODE_SUCCESS);
}
#end_block

#method_before
@Override
public void unsubscribe(@NonNull String parentId) {
    MediaBrowserCompat browser = getBrowserCompat();
    if (browser == null) {
        return;
    }
    // callback for getChildren.
    synchronized (mLock) {
        List<SubscribeCallback> list = mSubscribeCallbacks.get(parentId);
        if (list == null) {
            return;
        }
        for (int i = 0; i < list.size(); i++) {
            browser.unsubscribe(parentId, list.get(i));
        }
    }
}
#method_after
@Override
public ListenableFuture<BrowserResult> unsubscribe(@NonNull String parentId) {
    MediaBrowserCompat browser = getBrowserCompat();
    if (browser == null) {
        return BrowserResult.createFutureWithResult(RESULT_CODE_DISCONNECTED);
    }
    // callback for getChildren.
    synchronized (mLock) {
        List<SubscribeCallback> list = mSubscribeCallbacks.get(parentId);
        if (list == null) {
            return BrowserResult.createFutureWithResult(RESULT_CODE_BAD_VALUE);
        }
        for (int i = 0; i < list.size(); i++) {
            browser.unsubscribe(parentId, list.get(i));
        }
    }
    // No way to get result. Just return success.
    return BrowserResult.createFutureWithResult(BrowserResult.RESULT_CODE_SUCCESS);
}
#end_block

#method_before
@Override
public void getChildren(@NonNull String parentId, int page, int pageSize, @Nullable Bundle extras) {
    MediaBrowserCompat browser = getBrowserCompat();
    if (browser == null) {
        return;
    }
    Bundle options = createBundle(extras);
    options.putInt(MediaBrowserCompat.EXTRA_PAGE, page);
    options.putInt(MediaBrowserCompat.EXTRA_PAGE_SIZE, pageSize);
    browser.subscribe(parentId, options, new GetChildrenCallback(parentId, page, pageSize));
}
#method_after
@Override
public ListenableFuture<BrowserResult> getChildren(@NonNull String parentId, int page, int pageSize, @Nullable LibraryParams params) {
    MediaBrowserCompat browser = getBrowserCompat();
    if (browser == null) {
        return BrowserResult.createFutureWithResult(RESULT_CODE_DISCONNECTED);
    }
    final ResolvableFuture<BrowserResult> future = ResolvableFuture.create();
    Bundle options = createBundle(params);
    options.putInt(MediaBrowserCompat.EXTRA_PAGE, page);
    options.putInt(MediaBrowserCompat.EXTRA_PAGE_SIZE, pageSize);
    browser.subscribe(parentId, options, new GetChildrenCallback(future, parentId));
    return future;
}
#end_block

#method_before
@Override
public void getItem(@NonNull final String mediaId) {
    MediaBrowserCompat browser = getBrowserCompat();
    if (browser == null) {
        return;
    }
    browser.getItem(mediaId, new ItemCallback() {

        @Override
        public void onItemLoaded(final MediaItem item) {
            getCallbackExecutor().execute(new Runnable() {

                @Override
                public void run() {
                    getCallback().onGetItemDone(getInstance(), mediaId, MediaUtils2.convertToMediaItem2(item));
                }
            });
        }

        @Override
        public void onError(String itemId) {
            getCallbackExecutor().execute(new Runnable() {

                @Override
                public void run() {
                    getCallback().onGetItemDone(getInstance(), mediaId, null);
                }
            });
        }
    });
}
#method_after
@Override
public ListenableFuture<BrowserResult> getItem(@NonNull final String mediaId) {
    MediaBrowserCompat browser = getBrowserCompat();
    if (browser == null) {
        return BrowserResult.createFutureWithResult(RESULT_CODE_DISCONNECTED);
    }
    final ResolvableFuture<BrowserResult> result = ResolvableFuture.create();
    browser.getItem(mediaId, new ItemCallback() {

        @Override
        public void onItemLoaded(final MediaItem item) {
            getCallbackExecutor().execute(new Runnable() {

                @Override
                public void run() {
                    if (item != null) {
                        result.set(new BrowserResult(RESULT_CODE_SUCCESS, MediaUtils2.convertToMediaItem2(item), null));
                    } else {
                        result.set(new BrowserResult(RESULT_CODE_BAD_VALUE));
                    }
                }
            });
        }

        @Override
        public void onError(String itemId) {
            getCallbackExecutor().execute(new Runnable() {

                @Override
                public void run() {
                    result.set(new BrowserResult(RESULT_CODE_UNKNOWN_ERROR));
                }
            });
        }
    });
    return result;
}
#end_block

#method_before
@Override
public void search(@NonNull String query, @Nullable Bundle extras) {
    MediaBrowserCompat browser = getBrowserCompat();
    if (browser == null) {
        return;
    }
    browser.search(query, extras, new MediaBrowserCompat.SearchCallback() {

        @Override
        public void onSearchResult(final String query, final Bundle extras, final List<MediaItem> items) {
            getCallbackExecutor().execute(new Runnable() {

                @Override
                public void run() {
                    // Set extra null here, because 'extra' have different meanings between old
                    // API and new API as follows.
                    // - Old API: Extra/Option specified with search().
                    // - New API: Extra from MediaLibraryService2 to MediaBrowser2
                    // TODO(Post-P): Cache search result for later getSearchResult() calls.
                    getCallback().onSearchResultChanged(getInstance(), query, items.size(), null);
                }
            });
        }

        @Override
        public void onError(final String query, final Bundle extras) {
            getCallbackExecutor().execute(new Runnable() {

                @Override
                public void run() {
                    // Set extra null here, because 'extra' have different meanings between old
                    // API and new API as follows.
                    // - Old API: Extra/Option specified with search().
                    // - New API: Extra from MediaLibraryService2 to MediaBrowser2
                    getCallback().onSearchResultChanged(getInstance(), query, 0, null);
                }
            });
        }
    });
}
#method_after
@Override
public ListenableFuture<BrowserResult> search(@NonNull String query, @Nullable LibraryParams params) {
    MediaBrowserCompat browser = getBrowserCompat();
    if (browser == null) {
        return BrowserResult.createFutureWithResult(RESULT_CODE_DISCONNECTED);
    }
    browser.search(query, getExtras(params), new MediaBrowserCompat.SearchCallback() {

        @Override
        public void onSearchResult(final String query, final Bundle extras, final List<MediaItem> items) {
            getCallbackExecutor().execute(new Runnable() {

                @Override
                public void run() {
                    // Set extra null here, because 'extra' have different meanings between old
                    // API and new API as follows.
                    // - Old API: Extra/Option specified with search().
                    // - New API: Extra from MediaLibraryService2 to MediaBrowser2
                    // TODO(Post-P): Cache search result for later getSearchResult() calls.
                    getCallback().onSearchResultChanged(getInstance(), query, items.size(), null);
                }
            });
        }

        @Override
        public void onError(final String query, final Bundle extras) {
            getCallbackExecutor().execute(new Runnable() {

                @Override
                public void run() {
                    // Set extra null here, because 'extra' have different meanings between old
                    // API and new API as follows.
                    // - Old API: Extra/Option specified with search().
                    // - New API: Extra from MediaLibraryService2 to MediaBrowser2
                    getCallback().onSearchResultChanged(getInstance(), query, 0, null);
                }
            });
        }
    });
    // No way to get result. Just return success.
    return BrowserResult.createFutureWithResult(RESULT_CODE_SUCCESS);
}
#end_block

#method_before
@Override
public void getSearchResult(@NonNull final String query, final int page, final int pageSize, @Nullable final Bundle extras) {
    MediaBrowserCompat browser = getBrowserCompat();
    if (browser == null) {
        return;
    }
    Bundle options = createBundle(extras);
    options.putInt(MediaBrowserCompat.EXTRA_PAGE, page);
    options.putInt(MediaBrowserCompat.EXTRA_PAGE_SIZE, pageSize);
    browser.search(query, options, new MediaBrowserCompat.SearchCallback() {

        @Override
        public void onSearchResult(final String query, final Bundle extrasSent, final List<MediaItem> items) {
            getCallbackExecutor().execute(new Runnable() {

                @Override
                public void run() {
                    List<MediaItem2> item2List = MediaUtils2.convertMediaItemListToMediaItem2List(items);
                    // Set extra null here, because 'extra' have different meanings between old
                    // API and new API as follows.
                    // - Old API: Extra/Option specified with search().
                    // - New API: Extra from MediaLibraryService2 to MediaBrowser2
                    getCallback().onGetSearchResultDone(getInstance(), query, page, pageSize, item2List, null);
                }
            });
        }

        @Override
        public void onError(final String query, final Bundle extrasSent) {
            getCallbackExecutor().execute(new Runnable() {

                @Override
                public void run() {
                    // Set extra null here, because 'extra' have different meanings between old
                    // API and new API as follows.
                    // - Old API: Extra/Option specified with search().
                    // - New API: Extra from MediaLibraryService2 to MediaBrowser2
                    getCallback().onGetSearchResultDone(getInstance(), query, page, pageSize, null, null);
                }
            });
        }
    });
}
#method_after
@Override
public ListenableFuture<BrowserResult> getSearchResult(@NonNull final String query, final int page, final int pageSize, @Nullable final LibraryParams param) {
    MediaBrowserCompat browser = getBrowserCompat();
    if (browser == null) {
        return BrowserResult.createFutureWithResult(RESULT_CODE_DISCONNECTED);
    }
    final ResolvableFuture<BrowserResult> future = ResolvableFuture.create();
    Bundle options = createBundle(param);
    options.putInt(MediaBrowserCompat.EXTRA_PAGE, page);
    options.putInt(MediaBrowserCompat.EXTRA_PAGE_SIZE, pageSize);
    browser.search(query, options, new MediaBrowserCompat.SearchCallback() {

        @Override
        public void onSearchResult(final String query, final Bundle extrasSent, final List<MediaItem> items) {
            getCallbackExecutor().execute(new Runnable() {

                @Override
                public void run() {
                    List<MediaItem2> item2List = MediaUtils2.convertMediaItemListToMediaItem2List(items);
                    future.set(new BrowserResult(RESULT_CODE_SUCCESS, item2List, null));
                }
            });
        }

        @Override
        public void onError(final String query, final Bundle extrasSent) {
            getCallbackExecutor().execute(new Runnable() {

                @Override
                public void run() {
                    future.set(new BrowserResult(RESULT_CODE_UNKNOWN_ERROR));
                }
            });
        }
    });
    return future;
}
#end_block

#method_before
private MediaBrowserCompat getBrowserCompat(Bundle extras) {
    synchronized (mLock) {
        return mBrowserCompats.get(extras);
    }
}
#method_after
private MediaBrowserCompat getBrowserCompat(LibraryParams extras) {
    synchronized (mLock) {
        return mBrowserCompats.get(extras);
    }
}
#end_block

#method_before
private Bundle createBundle(Bundle bundle) {
    return bundle == null ? new Bundle() : new Bundle(bundle);
}
#method_after
private static Bundle createBundle(@Nullable LibraryParams params) {
    return params == null || params.getExtras() == null ? new Bundle() : new Bundle(params.getExtras());
}
#end_block

#method_before
@Override
public void onConnected() {
    getCallbackExecutor().execute(new Runnable() {

        @Override
        public void run() {
            MediaBrowserCompat browser;
            synchronized (mLock) {
                browser = mBrowserCompats.get(mExtras);
            }
            if (browser == null) {
                // Shouldn't be happen.
                return;
            }
            getCallback().onGetLibraryRootDone(getInstance(), mExtras, browser.getRoot(), browser.getExtras());
        }
    });
}
#method_after
@Override
public void onConnected() {
    MediaBrowserCompat browser;
    synchronized (mLock) {
        browser = mBrowserCompats.get(mParams);
    }
    if (browser == null) {
        // Shouldn't be happen. Internal error?
        mResult.set(new BrowserResult(RESULT_CODE_UNKNOWN_ERROR));
    } else {
        mResult.set(new BrowserResult(RESULT_CODE_SUCCESS, createRootMediaItem(browser), MediaUtils2.convertToLibraryParams(mContext, browser.getExtras())));
    }
}
#end_block

#method_before
@Override
public void onConnectionSuspended() {
    close();
}
#method_after
@Override
public void onConnectionSuspended() {
    onConnectionFailed();
}
#end_block

#method_before
@Override
public void onConnectionFailed() {
    close();
}
#method_after
@Override
public void onConnectionFailed() {
    // Unknown extra field.
    mResult.set(new BrowserResult(RESULT_CODE_BAD_VALUE));
    close();
}
#end_block

#method_before
@Override
public void onChildrenLoaded(final String parentId, List<MediaItem> children, final Bundle options) {
    final MediaBrowserCompat browser = getBrowserCompat();
    if (browser == null) {
        // Browser is closed.
        return;
    }
    final int itemCount;
    if (children != null) {
        itemCount = children.size();
    } else {
        // Currently no way to tell failures in MediaBrowser2#subscribe().
        return;
    }
    final Bundle notifyChildrenChangedOptions = browser.getNotifyChildrenChangedOptions();
    getCallbackExecutor().execute(new Runnable() {

        @Override
        public void run() {
            // TODO(Post-P): Cache children result for later getChildren() calls.
            getCallback().onChildrenChanged(getInstance(), parentId, itemCount, notifyChildrenChangedOptions);
        }
    });
}
#method_after
@Override
public void onChildrenLoaded(final String parentId, List<MediaItem> children, final Bundle options) {
    final MediaBrowserCompat browser = getBrowserCompat();
    if (browser == null) {
        // Browser is closed.
        return;
    }
    final int itemCount;
    if (children != null) {
        itemCount = children.size();
    } else {
        // Currently no way to tell failures in MediaBrowser2#subscribe().
        return;
    }
    final LibraryParams params = MediaUtils2.convertToLibraryParams(mContext, browser.getNotifyChildrenChangedOptions());
    getCallbackExecutor().execute(new Runnable() {

        @Override
        public void run() {
            // TODO(Post-P): Cache children result for later getChildren() calls.
            getCallback().onChildrenChanged(getInstance(), parentId, itemCount, params);
        }
    });
}
#end_block

#method_before
@Override
public void onError(String parentId) {
    onChildrenLoaded(parentId, null, null);
}
#method_after
@Override
public void onError(String parentId) {
    mFuture.set(new BrowserResult(RESULT_CODE_UNKNOWN_ERROR));
}
#end_block

#method_before
@Override
public void onError(String parentId, Bundle options) {
    onChildrenLoaded(parentId, null, options);
}
#method_after
@Override
public void onError(String parentId, Bundle options) {
    mFuture.set(new BrowserResult(RESULT_CODE_UNKNOWN_ERROR));
}
#end_block

#method_before
@Override
public void onChildrenLoaded(final String parentId, List<MediaItem> children, Bundle options) {
    final List<MediaItem2> items;
    if (children == null) {
        items = null;
    } else {
        items = new ArrayList<>();
        for (int i = 0; i < children.size(); i++) {
            items.add(MediaUtils2.convertToMediaItem2(children.get(i)));
        }
    }
    getCallbackExecutor().execute(new Runnable() {

        @Override
        public void run() {
            MediaBrowserCompat browser = getBrowserCompat();
            if (browser == null) {
                return;
            }
            // Set extra null here, because 'extra' have different meanings between old
            // API and new API as follows.
            // - Old API: Extra/Option specified with subscribe().
            // - New API: Extra from MediaLibraryService2 to MediaBrowser2
            getCallback().onGetChildrenDone(getInstance(), parentId, mPage, mPageSize, items, null);
            browser.unsubscribe(mParentId, GetChildrenCallback.this);
        }
    });
}
#method_after
@Override
public void onChildrenLoaded(final String parentId, List<MediaItem> children, Bundle options) {
    MediaBrowserCompat browser = getBrowserCompat();
    if (browser == null) {
        mFuture.set(new BrowserResult(RESULT_CODE_DISCONNECTED));
        return;
    }
    browser.unsubscribe(mParentId, GetChildrenCallback.this);
    final List<MediaItem2> items = new ArrayList<>();
    if (children == null) {
        // list are non-Null, so it must be internal error.
        mFuture.set(new BrowserResult(RESULT_CODE_UNKNOWN_ERROR));
    } else {
        for (int i = 0; i < children.size(); i++) {
            items.add(MediaUtils2.convertToMediaItem2(children.get(i)));
        }
        // Don't set extra here, because 'extra' have different meanings between old
        // API and new API as follows.
        // - Old API: Extra/Option specified with subscribe().
        // - New API: Extra from MediaLibraryService2 to MediaBrowser2
        mFuture.set(new BrowserResult(RESULT_CODE_SUCCESS, items, null));
    }
}
#end_block

#method_before
private ListenableFuture<SessionResult> dispatchRemoteControllerTask(@NonNull ControllerInfo controller, @NonNull RemoteControllerTask task) {
    if (!isConnected(controller)) {
        return SessionResult.createFutureWithResult(RESULT_CODE_DISCONNECTED);
    }
    try {
        final ListenableFuture<SessionResult> future;
        final int seq;
        final SequencedFutureManager manager = mSession2Stub.getConnectedControllersManager().getSequencedFutureManager(controller);
        if (manager != null) {
            future = manager.createSequencedFuture();
            seq = ((SequencedFuture<SessionResult>) future).getSequenceNumber();
        } else {
            // Can be null in two cases. Use the 0 as sequence number in both cases because
            // Case 1) Controller is from the legacy stub
            // -> Sequence number isn't needed, so 0 is OK
            // Case 2) Controller is removed after the connection check above
            // -> Call will fail below or ignored by the controller, so 0 is OK.
            seq = 0;
            future = SessionResult.createFutureWithResult(RESULT_CODE_SUCCESS);
        }
        task.run(controller.getControllerCb(), seq);
        return future;
    } catch (DeadObjectException e) {
        onDeadObjectException(controller, e);
        return SessionResult.createFutureWithResult(RESULT_CODE_DISCONNECTED);
    } catch (RemoteException e) {
        // Currently it's TransactionTooLargeException or DeadSystemException.
        // We'd better to leave log for those cases because
        // - TransactionTooLargeException means that we may need to fix our code.
        // (e.g. add pagination or special way to deliver Bitmap)
        // - DeadSystemException means that errors around it can be ignored.
        Log.w(TAG, "Exception in " + controller.toString(), e);
    }
    return SessionResult.createFutureWithResult(RESULT_CODE_UNKNOWN_ERROR);
}
#method_after
private ListenableFuture<SessionResult> dispatchRemoteControllerTask(@NonNull ControllerInfo controller, @NonNull RemoteControllerTask task) {
    if (!isConnected(controller)) {
        return SessionResult.createFutureWithResult(RESULT_CODE_DISCONNECTED);
    }
    try {
        final ListenableFuture<SessionResult> future;
        final int seq;
        final SequencedFutureManager manager = mSession2Stub.getConnectedControllersManager().getSequencedFutureManager(controller);
        if (manager != null) {
            future = manager.createSequencedFuture(RESULT_WHEN_CLOSED);
            seq = ((SequencedFuture<SessionResult>) future).getSequenceNumber();
        } else {
            // Can be null in two cases. Use the 0 as sequence number in both cases because
            // Case 1) Controller is from the legacy stub
            // -> Sequence number isn't needed, so 0 is OK
            // Case 2) Controller is removed after the connection check above
            // -> Call will fail below or ignored by the controller, so 0 is OK.
            seq = 0;
            future = SessionResult.createFutureWithResult(RESULT_CODE_SUCCESS);
        }
        task.run(controller.getControllerCb(), seq);
        return future;
    } catch (DeadObjectException e) {
        onDeadObjectException(controller, e);
        return SessionResult.createFutureWithResult(RESULT_CODE_DISCONNECTED);
    } catch (RemoteException e) {
        // Currently it's TransactionTooLargeException or DeadSystemException.
        // We'd better to leave log for those cases because
        // - TransactionTooLargeException means that we may need to fix our code.
        // (e.g. add pagination or special way to deliver Bitmap)
        // - DeadSystemException means that errors around it can be ignored.
        Log.w(TAG, "Exception in " + controller.toString(), e);
    }
    return SessionResult.createFutureWithResult(RESULT_CODE_UNKNOWN_ERROR);
}
#end_block

#method_before
@Nullable
public LibraryRoot onGetLibraryRoot(@NonNull MediaLibrarySession session, @NonNull ControllerInfo controller, @Nullable Bundle rootHints) {
    return null;
}
#method_after
@NonNull
public LibraryResult onGetLibraryRoot(@NonNull MediaLibrarySession session, @NonNull ControllerInfo controller, @Nullable LibraryParams params) {
    return new LibraryResult(RESULT_CODE_NOT_SUPPORTED);
}
#end_block

#method_before
@Nullable
public MediaItem2 onGetItem(@NonNull MediaLibrarySession session, @NonNull ControllerInfo controller, @NonNull String mediaId) {
    return null;
}
#method_after
@NonNull
public LibraryResult onGetItem(@NonNull MediaLibrarySession session, @NonNull ControllerInfo controller, @NonNull String mediaId) {
    return new LibraryResult(RESULT_CODE_NOT_SUPPORTED);
}
#end_block

#method_before
@Nullable
public List<MediaItem2> onGetChildren(@NonNull MediaLibrarySession session, @NonNull ControllerInfo controller, @NonNull String parentId, int page, int pageSize, @Nullable Bundle extras) {
    return null;
}
#method_after
@NonNull
public LibraryResult onGetChildren(@NonNull MediaLibrarySession session, @NonNull ControllerInfo controller, @NonNull String parentId, int page, int pageSize, @Nullable LibraryParams params) {
    return new LibraryResult(RESULT_CODE_NOT_SUPPORTED);
}
#end_block

#method_before
public void onSubscribe(@NonNull MediaLibrarySession session, @NonNull ControllerInfo controller, @NonNull String parentId, @Nullable Bundle extras) {
}
#method_after
@ResultCode
public int onSubscribe(@NonNull MediaLibrarySession session, @NonNull ControllerInfo controller, @NonNull String parentId, @Nullable LibraryParams params) {
    return RESULT_CODE_NOT_SUPPORTED;
}
#end_block

#method_before
public void onUnsubscribe(@NonNull MediaLibrarySession session, @NonNull ControllerInfo controller, @NonNull String parentId) {
}
#method_after
@ResultCode
public int onUnsubscribe(@NonNull MediaLibrarySession session, @NonNull ControllerInfo controller, @NonNull String parentId) {
    return RESULT_CODE_NOT_SUPPORTED;
}
#end_block

#method_before
public void onSearch(@NonNull MediaLibrarySession session, @NonNull ControllerInfo controller, @NonNull String query, @Nullable Bundle extras) {
}
#method_after
@ResultCode
public int onSearch(@NonNull MediaLibrarySession session, @NonNull ControllerInfo controller, @NonNull String query, @Nullable LibraryParams params) {
    return RESULT_CODE_NOT_SUPPORTED;
}
#end_block

#method_before
@Nullable
public List<MediaItem2> onGetSearchResult(@NonNull MediaLibrarySession session, @NonNull ControllerInfo controller, @NonNull String query, int page, int pageSize, @Nullable Bundle extras) {
    return null;
}
#method_after
@NonNull
public LibraryResult onGetSearchResult(@NonNull MediaLibrarySession session, @NonNull ControllerInfo controller, @NonNull String query, int page, int pageSize, @Nullable LibraryParams params) {
    return new LibraryResult(RESULT_CODE_NOT_SUPPORTED);
}
#end_block

#method_before
/**
 * Notify all controllers that subscribed to the parent about change in the parent's
 * children, regardless of the extra bundle supplied by
 * {@link MediaBrowser2#subscribe(String, Bundle)}.
 *
 * @param parentId parent id
 * @param itemCount number of children
 * @param extras extra information from session to controller
 */
public void notifyChildrenChanged(@NonNull String parentId, int itemCount, @Nullable Bundle extras) {
    if (TextUtils.isEmpty(parentId)) {
        throw new IllegalArgumentException("parentId shouldn't be empty");
    }
    if (itemCount < 0) {
        throw new IllegalArgumentException("itemCount shouldn't be negative");
    }
    getImpl().notifyChildrenChanged(parentId, itemCount, extras);
}
#method_after
public void notifyChildrenChanged(@NonNull ControllerInfo controller, @NonNull String parentId, @IntRange(from = 0) int itemCount, @Nullable LibraryParams params) {
    if (controller == null) {
        throw new IllegalArgumentException("controller shouldn't be null");
    }
    if (TextUtils.isEmpty(parentId)) {
        throw new IllegalArgumentException("parentId shouldn't be empty");
    }
    if (itemCount < 0) {
        throw new IllegalArgumentException("itemCount shouldn't be negative");
    }
    getImpl().notifyChildrenChanged(controller, parentId, itemCount, params);
}
#end_block

#method_before
public void notifySearchResultChanged(@NonNull ControllerInfo controller, @NonNull String query, int itemCount, @Nullable Bundle extras) {
    if (controller == null) {
        throw new IllegalArgumentException("controller shouldn't be null");
    }
    if (TextUtils.isEmpty(query)) {
        throw new IllegalArgumentException("query shouldn't be empty");
    }
    getImpl().notifySearchResultChanged(controller, query, itemCount, extras);
}
#method_after
public void notifySearchResultChanged(@NonNull ControllerInfo controller, @NonNull String query, @IntRange(from = 0) int itemCount, @Nullable LibraryParams params) {
    if (controller == null) {
        throw new IllegalArgumentException("controller shouldn't be null");
    }
    if (TextUtils.isEmpty(query)) {
        throw new IllegalArgumentException("query shouldn't be empty");
    }
    if (itemCount < 0) {
        throw new IllegalArgumentException("itemCount shouldn't be negative");
    }
    getImpl().notifySearchResultChanged(controller, query, itemCount, params);
}
#end_block

#method_before
@Override
@NonNull
public MediaLibrarySession build() {
    if (mCallbackExecutor == null) {
        mCallbackExecutor = ContextCompat.getMainExecutor(mContext);
    }
    if (mCallback == null) {
        mCallback = new MediaLibrarySession.MediaLibrarySessionCallback() {
        };
    }
    return new MediaLibrarySession(mContext, mId, mPlayer, mSessionActivity, mCallbackExecutor, mCallback);
}
#method_after
public LibraryParams build() {
    return new LibraryParams(mBundle, mRecent, mOffline, mSuggested);
}
#end_block

#method_before
@NonNull
public CommandButton build() {
    return new CommandButton(mCommand, mIconResId, mDisplayName, mExtras, mEnabled);
}
#method_after
@Override
@NonNull
public MediaSession2 build() {
    if (mCallbackExecutor == null) {
        mCallbackExecutor = ContextCompat.getMainExecutor(mContext);
    }
    if (mCallback == null) {
        mCallback = new SessionCallback() {
        };
    }
    return new MediaSession2(mContext, mId, mPlayer, mSessionActivity, mCallbackExecutor, mCallback);
}
#end_block

#method_before
@Override
public void notifyChildrenChanged(final ControllerInfo controller, final String parentId, final int itemCount, final Bundle extras) {
    dispatchRemoteControllerCallbackTask(controller, new RemoteControllerCallbackTask() {

        @Override
        public void run(ControllerCb callback) throws RemoteException {
            if (!isSubscribed(callback, parentId)) {
                if (DEBUG) {
                    Log.d(TAG, "Skipping notifyChildrenChanged() to " + controller + " because it hasn't subscribed");
                    dumpSubscription();
                }
                return;
            }
            callback.onChildrenChanged(parentId, itemCount, extras);
        }
    });
}
#method_after
@Override
public void notifyChildrenChanged(final String parentId, final int itemCount, final LibraryParams params) {
    dispatchRemoteControllerCallbackTask(new RemoteControllerCallbackTask() {

        @Override
        public void run(ControllerCb callback) throws RemoteException {
            if (isSubscribed(callback, parentId)) {
                callback.onChildrenChanged(parentId, itemCount, params);
            }
        }
    });
}
#end_block

#method_before
@Override
public void notifySearchResultChanged(ControllerInfo controller, final String query, final int itemCount, final Bundle extras) {
    dispatchRemoteControllerCallbackTask(controller, new RemoteControllerCallbackTask() {

        @Override
        public void run(ControllerCb callback) throws RemoteException {
            callback.onSearchResultChanged(query, itemCount, extras);
        }
    });
}
#method_after
@Override
public void notifySearchResultChanged(ControllerInfo controller, final String query, final int itemCount, final LibraryParams params) {
    dispatchRemoteControllerCallbackTask(controller, new RemoteControllerCallbackTask() {

        @Override
        public void run(ControllerCb callback) throws RemoteException {
            callback.onSearchResultChanged(query, itemCount, params);
        }
    });
}
#end_block

#method_before
@Override
public void onGetLibraryRootOnExecutor(ControllerInfo controller, final Bundle rootHints) {
    final LibraryRoot root = getCallback().onGetLibraryRoot(getInstance(), controller, rootHints);
    dispatchRemoteControllerCallbackTask(controller, new RemoteControllerCallbackTask() {

        @Override
        public void run(ControllerCb callback) throws RemoteException {
            callback.onGetLibraryRootDone(rootHints, root == null ? null : root.getRootId(), root == null ? null : root.getExtras());
        }
    });
}
#method_after
@Override
public LibraryResult onGetLibraryRootOnExecutor(ControllerInfo controller, final LibraryParams params) {
    LibraryResult result = getCallback().onGetLibraryRoot(getInstance(), controller, params);
    return ensureNonNullResultWithValidItem(result);
}
#end_block

#method_before
@Override
public void onGetItemOnExecutor(ControllerInfo controller, final String mediaId) {
    final MediaItem2 result = getCallback().onGetItem(getInstance(), controller, mediaId);
    dispatchRemoteControllerCallbackTask(controller, new RemoteControllerCallbackTask() {

        @Override
        public void run(ControllerCb callback) throws RemoteException {
            callback.onGetItemDone(mediaId, result);
        }
    });
}
#method_after
@Override
public LibraryResult onGetItemOnExecutor(ControllerInfo controller, final String mediaId) {
    LibraryResult result = getCallback().onGetItem(getInstance(), controller, mediaId);
    return ensureNonNullResultWithValidItem(result);
}
#end_block

#method_before
@Override
public void onGetChildrenOnExecutor(ControllerInfo controller, final String parentId, final int page, final int pageSize, final Bundle extras) {
    final List<MediaItem2> result = getCallback().onGetChildren(getInstance(), controller, parentId, page, pageSize, extras);
    if (result != null && result.size() > pageSize) {
        throw new IllegalArgumentException("onGetChildren() shouldn't return media items " + "more than pageSize. result.size()=" + result.size() + " pageSize=" + pageSize);
    }
    dispatchRemoteControllerCallbackTask(controller, new RemoteControllerCallbackTask() {

        @Override
        public void run(ControllerCb callback) throws RemoteException {
            callback.onGetChildrenDone(parentId, page, pageSize, result, extras);
        }
    });
}
#method_after
@Override
public LibraryResult onGetChildrenOnExecutor(ControllerInfo controller, final String parentId, final int page, final int pageSize, final LibraryParams params) {
    LibraryResult result = getCallback().onGetChildren(getInstance(), controller, parentId, page, pageSize, params);
    return ensureNonNullResultWithValidList(result, pageSize);
}
#end_block

#method_before
@Override
public void onSubscribeOnExecutor(ControllerInfo controller, String parentId, Bundle option) {
    synchronized (mLock) {
        Set<String> subscription = mSubscriptions.get(controller.getControllerCb());
        if (subscription == null) {
            subscription = new HashSet<>();
            mSubscriptions.put(controller.getControllerCb(), subscription);
        }
        subscription.add(parentId);
    }
    // Call callbacks after adding it to the subscription list because library session may want
    // to call notifyChildrenChanged() in the callback.
    getCallback().onSubscribe(getInstance(), controller, parentId, option);
}
#method_after
@Override
public int onSubscribeOnExecutor(ControllerInfo controller, String parentId, LibraryParams params) {
    synchronized (mLock) {
        Set<String> subscription = mSubscriptions.get(controller.getControllerCb());
        if (subscription == null) {
            subscription = new HashSet<>();
            mSubscriptions.put(controller.getControllerCb(), subscription);
        }
        subscription.add(parentId);
    }
    // Call callbacks after adding it to the subscription list because library session may want
    // to call notifyChildrenChanged() in the callback.
    int resultCode = getCallback().onSubscribe(getInstance(), controller, parentId, params);
    // When error happens, remove from the subscription list.
    if (resultCode != RESULT_CODE_SUCCESS) {
        synchronized (mLock) {
            mSubscriptions.remove(controller.getControllerCb());
        }
    }
    return resultCode;
}
#end_block

#method_before
@Override
public void onUnsubscribeOnExecutor(ControllerInfo controller, String parentId) {
    getCallback().onUnsubscribe(getInstance(), controller, parentId);
    synchronized (mLock) {
        mSubscriptions.remove(controller.getControllerCb());
    }
}
#method_after
@Override
public int onUnsubscribeOnExecutor(ControllerInfo controller, String parentId) {
    int resultCode = getCallback().onUnsubscribe(getInstance(), controller, parentId);
    synchronized (mLock) {
        mSubscriptions.remove(controller.getControllerCb());
    }
    return resultCode;
}
#end_block

#method_before
@Override
public void onSearchOnExecutor(ControllerInfo controller, String query, Bundle extras) {
    getCallback().onSearch(getInstance(), controller, query, extras);
}
#method_after
@Override
public int onSearchOnExecutor(ControllerInfo controller, String query, LibraryParams params) {
    return getCallback().onSearch(getInstance(), controller, query, params);
}
#end_block

#method_before
@Override
public void onGetSearchResultOnExecutor(ControllerInfo controller, final String query, final int page, final int pageSize, final Bundle extras) {
    final List<MediaItem2> result = getCallback().onGetSearchResult(getInstance(), controller, query, page, pageSize, extras);
    if (result != null && result.size() > pageSize) {
        throw new IllegalArgumentException("onGetSearchResult() shouldn't return media " + "items more than pageSize. result.size()=" + result.size() + " pageSize=" + pageSize);
    }
    dispatchRemoteControllerCallbackTask(controller, new RemoteControllerCallbackTask() {

        @Override
        public void run(ControllerCb callback) throws RemoteException {
            callback.onGetSearchResultDone(query, page, pageSize, result, extras);
        }
    });
}
#method_after
@Override
public LibraryResult onGetSearchResultOnExecutor(ControllerInfo controller, final String query, final int page, final int pageSize, final LibraryParams params) {
    LibraryResult result = getCallback().onGetSearchResult(getInstance(), controller, query, page, pageSize, params);
    return ensureNonNullResultWithValidList(result, pageSize);
}
#end_block

#method_before
@Override
public ListenableFuture<ControllerResult> play() {
    return sendCommand(COMMAND_CODE_PLAYER_PLAY, new SessionCommand() {

        @Override
        public void run(IMediaSession2 iSession2, int seq) throws RemoteException {
            iSession2.play(mControllerStub, seq);
        }
    });
}
#method_after
@Override
public ListenableFuture<ControllerResult> play() {
    return dispatchRemoteSessionTask(COMMAND_CODE_PLAYER_PLAY, new RemoteSessionTask() {

        @Override
        public void run(IMediaSession2 iSession2, int seq) throws RemoteException {
            iSession2.play(mControllerStub, seq);
        }
    });
}
#end_block

#method_before
@Override
public ListenableFuture<ControllerResult> pause() {
    return sendCommand(COMMAND_CODE_PLAYER_PAUSE, new SessionCommand() {

        @Override
        public void run(IMediaSession2 iSession2, int seq) throws RemoteException {
            iSession2.pause(mControllerStub, seq);
        }
    });
}
#method_after
@Override
public ListenableFuture<ControllerResult> pause() {
    return dispatchRemoteSessionTask(COMMAND_CODE_PLAYER_PAUSE, new RemoteSessionTask() {

        @Override
        public void run(IMediaSession2 iSession2, int seq) throws RemoteException {
            iSession2.pause(mControllerStub, seq);
        }
    });
}
#end_block

#method_before
@Override
public ListenableFuture<ControllerResult> prefetch() {
    return sendCommand(COMMAND_CODE_PLAYER_PREFETCH, new SessionCommand() {

        @Override
        public void run(IMediaSession2 iSession2, int seq) throws RemoteException {
            iSession2.prefetch(mControllerStub, seq);
        }
    });
}
#method_after
@Override
public ListenableFuture<ControllerResult> prefetch() {
    return dispatchRemoteSessionTask(COMMAND_CODE_PLAYER_PREFETCH, new RemoteSessionTask() {

        @Override
        public void run(IMediaSession2 iSession2, int seq) throws RemoteException {
            iSession2.prefetch(mControllerStub, seq);
        }
    });
}
#end_block

#method_before
@Override
public ListenableFuture<ControllerResult> fastForward() {
    return sendCommand(COMMAND_CODE_SESSION_FAST_FORWARD, new SessionCommand() {

        @Override
        public void run(IMediaSession2 iSession2, int seq) throws RemoteException {
            iSession2.fastForward(mControllerStub, seq);
        }
    });
}
#method_after
@Override
public ListenableFuture<ControllerResult> fastForward() {
    return dispatchRemoteSessionTask(COMMAND_CODE_SESSION_FAST_FORWARD, new RemoteSessionTask() {

        @Override
        public void run(IMediaSession2 iSession2, int seq) throws RemoteException {
            iSession2.fastForward(mControllerStub, seq);
        }
    });
}
#end_block

#method_before
@Override
public ListenableFuture<ControllerResult> rewind() {
    return sendCommand(COMMAND_CODE_SESSION_REWIND, new SessionCommand() {

        @Override
        public void run(IMediaSession2 iSession2, int seq) throws RemoteException {
            iSession2.rewind(mControllerStub, seq);
        }
    });
}
#method_after
@Override
public ListenableFuture<ControllerResult> rewind() {
    return dispatchRemoteSessionTask(COMMAND_CODE_SESSION_REWIND, new RemoteSessionTask() {

        @Override
        public void run(IMediaSession2 iSession2, int seq) throws RemoteException {
            iSession2.rewind(mControllerStub, seq);
        }
    });
}
#end_block

#method_before
@Override
public ListenableFuture<ControllerResult> seekTo(final long pos) {
    if (pos < 0) {
        throw new IllegalArgumentException("position shouldn't be negative");
    }
    return sendCommand(COMMAND_CODE_PLAYER_SEEK_TO, new SessionCommand() {

        @Override
        public void run(IMediaSession2 iSession2, int seq) throws RemoteException {
            iSession2.seekTo(mControllerStub, seq, pos);
        }
    });
}
#method_after
@Override
public ListenableFuture<ControllerResult> seekTo(final long pos) {
    if (pos < 0) {
        throw new IllegalArgumentException("position shouldn't be negative");
    }
    return dispatchRemoteSessionTask(COMMAND_CODE_PLAYER_SEEK_TO, new RemoteSessionTask() {

        @Override
        public void run(IMediaSession2 iSession2, int seq) throws RemoteException {
            iSession2.seekTo(mControllerStub, seq, pos);
        }
    });
}
#end_block

#method_before
@Override
public ListenableFuture<ControllerResult> playFromMediaId(@NonNull final String mediaId, @Nullable final Bundle extras) {
    return sendCommand(COMMAND_CODE_SESSION_PLAY_FROM_MEDIA_ID, new SessionCommand() {

        @Override
        public void run(IMediaSession2 iSession2, int seq) throws RemoteException {
            iSession2.playFromMediaId(mControllerStub, seq, mediaId, extras);
        }
    });
}
#method_after
@Override
public ListenableFuture<ControllerResult> playFromMediaId(@NonNull final String mediaId, @Nullable final Bundle extras) {
    return dispatchRemoteSessionTask(COMMAND_CODE_SESSION_PLAY_FROM_MEDIA_ID, new RemoteSessionTask() {

        @Override
        public void run(IMediaSession2 iSession2, int seq) throws RemoteException {
            iSession2.playFromMediaId(mControllerStub, seq, mediaId, extras);
        }
    });
}
#end_block

#method_before
@Override
public ListenableFuture<ControllerResult> playFromSearch(@NonNull final String query, @Nullable final Bundle extras) {
    return sendCommand(COMMAND_CODE_SESSION_PLAY_FROM_SEARCH, new SessionCommand() {

        @Override
        public void run(IMediaSession2 iSession2, int seq) throws RemoteException {
            iSession2.playFromSearch(mControllerStub, seq, query, extras);
        }
    });
}
#method_after
@Override
public ListenableFuture<ControllerResult> playFromSearch(@NonNull final String query, @Nullable final Bundle extras) {
    return dispatchRemoteSessionTask(COMMAND_CODE_SESSION_PLAY_FROM_SEARCH, new RemoteSessionTask() {

        @Override
        public void run(IMediaSession2 iSession2, int seq) throws RemoteException {
            iSession2.playFromSearch(mControllerStub, seq, query, extras);
        }
    });
}
#end_block

#method_before
@Override
public ListenableFuture<ControllerResult> playFromUri(@NonNull final Uri uri, @NonNull final Bundle extras) {
    return sendCommand(COMMAND_CODE_SESSION_PLAY_FROM_URI, new SessionCommand() {

        @Override
        public void run(IMediaSession2 iSession2, int seq) throws RemoteException {
            iSession2.playFromUri(mControllerStub, seq, uri, extras);
        }
    });
}
#method_after
@Override
public ListenableFuture<ControllerResult> playFromUri(@NonNull final Uri uri, @NonNull final Bundle extras) {
    return dispatchRemoteSessionTask(COMMAND_CODE_SESSION_PLAY_FROM_URI, new RemoteSessionTask() {

        @Override
        public void run(IMediaSession2 iSession2, int seq) throws RemoteException {
            iSession2.playFromUri(mControllerStub, seq, uri, extras);
        }
    });
}
#end_block

#method_before
@Override
public ListenableFuture<ControllerResult> prefetchFromMediaId(@NonNull final String mediaId, @Nullable final Bundle extras) {
    return sendCommand(COMMAND_CODE_SESSION_PREFETCH_FROM_MEDIA_ID, new SessionCommand() {

        @Override
        public void run(IMediaSession2 iSession2, int seq) throws RemoteException {
            iSession2.prefetchFromMediaId(mControllerStub, seq, mediaId, extras);
        }
    });
}
#method_after
@Override
public ListenableFuture<ControllerResult> prefetchFromMediaId(@NonNull final String mediaId, @Nullable final Bundle extras) {
    return dispatchRemoteSessionTask(COMMAND_CODE_SESSION_PREFETCH_FROM_MEDIA_ID, new RemoteSessionTask() {

        @Override
        public void run(IMediaSession2 iSession2, int seq) throws RemoteException {
            iSession2.prefetchFromMediaId(mControllerStub, seq, mediaId, extras);
        }
    });
}
#end_block

#method_before
@Override
public ListenableFuture<ControllerResult> prefetchFromSearch(@NonNull final String query, @Nullable final Bundle extras) {
    return sendCommand(COMMAND_CODE_SESSION_PREFETCH_FROM_SEARCH, new SessionCommand() {

        @Override
        public void run(IMediaSession2 iSession2, int seq) throws RemoteException {
            iSession2.prefetchFromSearch(mControllerStub, seq, query, extras);
        }
    });
}
#method_after
@Override
public ListenableFuture<ControllerResult> prefetchFromSearch(@NonNull final String query, @Nullable final Bundle extras) {
    return dispatchRemoteSessionTask(COMMAND_CODE_SESSION_PREFETCH_FROM_SEARCH, new RemoteSessionTask() {

        @Override
        public void run(IMediaSession2 iSession2, int seq) throws RemoteException {
            iSession2.prefetchFromSearch(mControllerStub, seq, query, extras);
        }
    });
}
#end_block

#method_before
@Override
public ListenableFuture<ControllerResult> prefetchFromUri(@NonNull final Uri uri, @Nullable final Bundle extras) {
    return sendCommand(COMMAND_CODE_SESSION_PREFETCH_FROM_URI, new SessionCommand() {

        @Override
        public void run(IMediaSession2 iSession2, int seq) throws RemoteException {
            iSession2.prefetchFromUri(mControllerStub, seq, uri, extras);
        }
    });
}
#method_after
@Override
public ListenableFuture<ControllerResult> prefetchFromUri(@NonNull final Uri uri, @Nullable final Bundle extras) {
    return dispatchRemoteSessionTask(COMMAND_CODE_SESSION_PREFETCH_FROM_URI, new RemoteSessionTask() {

        @Override
        public void run(IMediaSession2 iSession2, int seq) throws RemoteException {
            iSession2.prefetchFromUri(mControllerStub, seq, uri, extras);
        }
    });
}
#end_block

#method_before
@Override
public ListenableFuture<ControllerResult> setVolumeTo(final int value, @VolumeFlags final int flags) {
    return sendCommand(COMMAND_CODE_VOLUME_SET_VOLUME, new SessionCommand() {

        @Override
        public void run(IMediaSession2 iSession2, int seq) throws RemoteException {
            iSession2.setVolumeTo(mControllerStub, seq, value, flags);
        }
    });
}
#method_after
@Override
public ListenableFuture<ControllerResult> setVolumeTo(final int value, @VolumeFlags final int flags) {
    return dispatchRemoteSessionTask(COMMAND_CODE_VOLUME_SET_VOLUME, new RemoteSessionTask() {

        @Override
        public void run(IMediaSession2 iSession2, int seq) throws RemoteException {
            iSession2.setVolumeTo(mControllerStub, seq, value, flags);
        }
    });
}
#end_block

#method_before
@Override
public ListenableFuture<ControllerResult> adjustVolume(@VolumeDirection final int direction, @VolumeFlags final int flags) {
    return sendCommand(COMMAND_CODE_VOLUME_ADJUST_VOLUME, new SessionCommand() {

        @Override
        public void run(IMediaSession2 iSession2, int seq) throws RemoteException {
            iSession2.adjustVolume(mControllerStub, seq, direction, flags);
        }
    });
}
#method_after
@Override
public ListenableFuture<ControllerResult> adjustVolume(@VolumeDirection final int direction, @VolumeFlags final int flags) {
    return dispatchRemoteSessionTask(COMMAND_CODE_VOLUME_ADJUST_VOLUME, new RemoteSessionTask() {

        @Override
        public void run(IMediaSession2 iSession2, int seq) throws RemoteException {
            iSession2.adjustVolume(mControllerStub, seq, direction, flags);
        }
    });
}
#end_block

#method_before
@Override
public ListenableFuture<ControllerResult> setPlaybackSpeed(final float speed) {
    return sendCommand(COMMAND_CODE_PLAYER_SET_SPEED, new SessionCommand() {

        @Override
        public void run(IMediaSession2 iSession2, int seq) throws RemoteException {
            iSession2.setPlaybackSpeed(mControllerStub, seq, speed);
        }
    });
}
#method_after
@Override
public ListenableFuture<ControllerResult> setPlaybackSpeed(final float speed) {
    return dispatchRemoteSessionTask(COMMAND_CODE_PLAYER_SET_SPEED, new RemoteSessionTask() {

        @Override
        public void run(IMediaSession2 iSession2, int seq) throws RemoteException {
            iSession2.setPlaybackSpeed(mControllerStub, seq, speed);
        }
    });
}
#end_block

#method_before
@Override
public ListenableFuture<ControllerResult> setRating(@NonNull final String mediaId, @NonNull final Rating2 rating) {
    return sendCommand(COMMAND_CODE_SESSION_SET_RATING, new SessionCommand() {

        @Override
        public void run(IMediaSession2 iSession2, int seq) throws RemoteException {
            iSession2.setRating(mControllerStub, seq, mediaId, (ParcelImpl) ParcelUtils.toParcelable(rating));
        }
    });
}
#method_after
@Override
public ListenableFuture<ControllerResult> setRating(@NonNull final String mediaId, @NonNull final Rating2 rating) {
    return dispatchRemoteSessionTask(COMMAND_CODE_SESSION_SET_RATING, new RemoteSessionTask() {

        @Override
        public void run(IMediaSession2 iSession2, int seq) throws RemoteException {
            iSession2.setRating(mControllerStub, seq, mediaId, (ParcelImpl) ParcelUtils.toParcelable(rating));
        }
    });
}
#end_block

#method_before
@Override
public ListenableFuture<ControllerResult> sendCustomCommand(@NonNull final SessionCommand2 command, @Nullable final Bundle args) {
    return sendCommand(command, new SessionCommand() {

        @Override
        public void run(IMediaSession2 iSession2, int seq) throws RemoteException {
            iSession2.sendCustomCommand(mControllerStub, seq, (ParcelImpl) ParcelUtils.toParcelable(command), args);
        }
    });
}
#method_after
@Override
public ListenableFuture<ControllerResult> sendCustomCommand(@NonNull final SessionCommand2 command, @Nullable final Bundle args) {
    return dispatchRemoteSessionTask(command, new RemoteSessionTask() {

        @Override
        public void run(IMediaSession2 iSession2, int seq) throws RemoteException {
            iSession2.onCustomCommand(mControllerStub, seq, (ParcelImpl) ParcelUtils.toParcelable(command), args);
        }
    });
}
#end_block

#method_before
@Override
public ListenableFuture<ControllerResult> setPlaylist(@NonNull final List<MediaItem2> list, @Nullable final MediaMetadata2 metadata) {
    return sendCommand(COMMAND_CODE_PLAYER_SET_PLAYLIST, new SessionCommand() {

        @Override
        public void run(IMediaSession2 iSession2, int seq) throws RemoteException {
            iSession2.setPlaylist(mControllerStub, seq, new ParcelImplListSlice(MediaUtils2.convertMediaItem2ListToParcelImplList(list)), (metadata == null) ? null : metadata.toBundle());
        }
    });
}
#method_after
@Override
public ListenableFuture<ControllerResult> setPlaylist(@NonNull final List<MediaItem2> list, @Nullable final MediaMetadata2 metadata) {
    return dispatchRemoteSessionTask(COMMAND_CODE_PLAYER_SET_PLAYLIST, new RemoteSessionTask() {

        @Override
        public void run(IMediaSession2 iSession2, int seq) throws RemoteException {
            iSession2.setPlaylist(mControllerStub, seq, MediaUtils2.convertMediaItem2ListToParcelImplListSlice(list), (metadata == null) ? null : metadata.toBundle());
        }
    });
}
#end_block

#method_before
@Override
public ListenableFuture<ControllerResult> setMediaItem(final MediaItem2 item) {
    return sendCommand(COMMAND_CODE_PLAYER_SET_MEDIA_ITEM, new SessionCommand() {

        @Override
        public void run(IMediaSession2 iSession2, int seq) throws RemoteException {
            iSession2.setMediaItem(mControllerStub, seq, (ParcelImpl) ParcelUtils.toParcelable(item));
        }
    });
}
#method_after
@Override
public ListenableFuture<ControllerResult> setMediaItem(final MediaItem2 item) {
    return dispatchRemoteSessionTask(COMMAND_CODE_PLAYER_SET_MEDIA_ITEM, new RemoteSessionTask() {

        @Override
        public void run(IMediaSession2 iSession2, int seq) throws RemoteException {
            iSession2.setMediaItem(mControllerStub, seq, (ParcelImpl) ParcelUtils.toParcelable(item));
        }
    });
}
#end_block

#method_before
@Override
public ListenableFuture<ControllerResult> updatePlaylistMetadata(@Nullable final MediaMetadata2 metadata) {
    return sendCommand(COMMAND_CODE_PLAYER_UPDATE_LIST_METADATA, new SessionCommand() {

        @Override
        public void run(IMediaSession2 iSession2, int seq) throws RemoteException {
            iSession2.updatePlaylistMetadata(mControllerStub, seq, (metadata == null) ? null : metadata.toBundle());
        }
    });
}
#method_after
@Override
public ListenableFuture<ControllerResult> updatePlaylistMetadata(@Nullable final MediaMetadata2 metadata) {
    return dispatchRemoteSessionTask(COMMAND_CODE_PLAYER_UPDATE_LIST_METADATA, new RemoteSessionTask() {

        @Override
        public void run(IMediaSession2 iSession2, int seq) throws RemoteException {
            iSession2.updatePlaylistMetadata(mControllerStub, seq, (metadata == null) ? null : metadata.toBundle());
        }
    });
}
#end_block

#method_before
@Override
public ListenableFuture<ControllerResult> addPlaylistItem(final int index, @NonNull final MediaItem2 item) {
    return sendCommand(COMMAND_CODE_PLAYER_ADD_PLAYLIST_ITEM, new SessionCommand() {

        @Override
        public void run(IMediaSession2 iSession2, int seq) throws RemoteException {
            iSession2.addPlaylistItem(mControllerStub, seq, index, (ParcelImpl) ParcelUtils.toParcelable(item));
        }
    });
}
#method_after
@Override
public ListenableFuture<ControllerResult> addPlaylistItem(final int index, @NonNull final MediaItem2 item) {
    return dispatchRemoteSessionTask(COMMAND_CODE_PLAYER_ADD_PLAYLIST_ITEM, new RemoteSessionTask() {

        @Override
        public void run(IMediaSession2 iSession2, int seq) throws RemoteException {
            iSession2.addPlaylistItem(mControllerStub, seq, index, (ParcelImpl) ParcelUtils.toParcelable(item));
        }
    });
}
#end_block

#method_before
@Override
public ListenableFuture<ControllerResult> removePlaylistItem(@NonNull final MediaItem2 item) {
    return sendCommand(COMMAND_CODE_PLAYER_REMOVE_PLAYLIST_ITEM, new SessionCommand() {

        @Override
        public void run(IMediaSession2 iSession2, int seq) throws RemoteException {
            iSession2.removePlaylistItem(mControllerStub, seq, (ParcelImpl) ParcelUtils.toParcelable(item));
        }
    });
}
#method_after
@Override
public ListenableFuture<ControllerResult> removePlaylistItem(@NonNull final MediaItem2 item) {
    return dispatchRemoteSessionTask(COMMAND_CODE_PLAYER_REMOVE_PLAYLIST_ITEM, new RemoteSessionTask() {

        @Override
        public void run(IMediaSession2 iSession2, int seq) throws RemoteException {
            iSession2.removePlaylistItem(mControllerStub, seq, (ParcelImpl) ParcelUtils.toParcelable(item));
        }
    });
}
#end_block

#method_before
@Override
public ListenableFuture<ControllerResult> replacePlaylistItem(final int index, @NonNull final MediaItem2 item) {
    return sendCommand(COMMAND_CODE_PLAYER_REPLACE_PLAYLIST_ITEM, new SessionCommand() {

        @Override
        public void run(IMediaSession2 iSession2, int seq) throws RemoteException {
            iSession2.replacePlaylistItem(mControllerStub, seq, index, (ParcelImpl) ParcelUtils.toParcelable(item));
        }
    });
}
#method_after
@Override
public ListenableFuture<ControllerResult> replacePlaylistItem(final int index, @NonNull final MediaItem2 item) {
    return dispatchRemoteSessionTask(COMMAND_CODE_PLAYER_REPLACE_PLAYLIST_ITEM, new RemoteSessionTask() {

        @Override
        public void run(IMediaSession2 iSession2, int seq) throws RemoteException {
            iSession2.replacePlaylistItem(mControllerStub, seq, index, (ParcelImpl) ParcelUtils.toParcelable(item));
        }
    });
}
#end_block

#method_before
@Override
public ListenableFuture<ControllerResult> skipToPreviousItem() {
    return sendCommand(COMMAND_CODE_PLAYER_SKIP_TO_PREVIOUS_PLAYLIST_ITEM, new SessionCommand() {

        @Override
        public void run(IMediaSession2 iSession2, int seq) throws RemoteException {
            iSession2.skipToPreviousItem(mControllerStub, seq);
        }
    });
}
#method_after
@Override
public ListenableFuture<ControllerResult> skipToPreviousItem() {
    return dispatchRemoteSessionTask(COMMAND_CODE_PLAYER_SKIP_TO_PREVIOUS_PLAYLIST_ITEM, new RemoteSessionTask() {

        @Override
        public void run(IMediaSession2 iSession2, int seq) throws RemoteException {
            iSession2.skipToPreviousItem(mControllerStub, seq);
        }
    });
}
#end_block

#method_before
@Override
public ListenableFuture<ControllerResult> skipToNextItem() {
    return sendCommand(COMMAND_CODE_PLAYER_SKIP_TO_NEXT_PLAYLIST_ITEM, new SessionCommand() {

        @Override
        public void run(IMediaSession2 iSession2, int seq) throws RemoteException {
            iSession2.skipToNextItem(mControllerStub, seq);
        }
    });
}
#method_after
@Override
public ListenableFuture<ControllerResult> skipToNextItem() {
    return dispatchRemoteSessionTask(COMMAND_CODE_PLAYER_SKIP_TO_NEXT_PLAYLIST_ITEM, new RemoteSessionTask() {

        @Override
        public void run(IMediaSession2 iSession2, int seq) throws RemoteException {
            iSession2.skipToNextItem(mControllerStub, seq);
        }
    });
}
#end_block

#method_before
@Override
public ListenableFuture<ControllerResult> skipToPlaylistItem(@NonNull final MediaItem2 item) {
    return sendCommand(COMMAND_CODE_PLAYER_SKIP_TO_PLAYLIST_ITEM, new SessionCommand() {

        @Override
        public void run(IMediaSession2 iSession2, int seq) throws RemoteException {
            iSession2.skipToPlaylistItem(mControllerStub, seq, (ParcelImpl) ParcelUtils.toParcelable(item));
        }
    });
}
#method_after
@Override
public ListenableFuture<ControllerResult> skipToPlaylistItem(@NonNull final MediaItem2 item) {
    return dispatchRemoteSessionTask(COMMAND_CODE_PLAYER_SKIP_TO_PLAYLIST_ITEM, new RemoteSessionTask() {

        @Override
        public void run(IMediaSession2 iSession2, int seq) throws RemoteException {
            iSession2.skipToPlaylistItem(mControllerStub, seq, (ParcelImpl) ParcelUtils.toParcelable(item));
        }
    });
}
#end_block

#method_before
@Override
public ListenableFuture<ControllerResult> setRepeatMode(final int repeatMode) {
    return sendCommand(COMMAND_CODE_PLAYER_SET_REPEAT_MODE, new SessionCommand() {

        @Override
        public void run(IMediaSession2 iSession2, int seq) throws RemoteException {
            iSession2.setRepeatMode(mControllerStub, seq, repeatMode);
        }
    });
}
#method_after
@Override
public ListenableFuture<ControllerResult> setRepeatMode(final int repeatMode) {
    return dispatchRemoteSessionTask(COMMAND_CODE_PLAYER_SET_REPEAT_MODE, new RemoteSessionTask() {

        @Override
        public void run(IMediaSession2 iSession2, int seq) throws RemoteException {
            iSession2.setRepeatMode(mControllerStub, seq, repeatMode);
        }
    });
}
#end_block

#method_before
@Override
public ListenableFuture<ControllerResult> setShuffleMode(final int shuffleMode) {
    return sendCommand(COMMAND_CODE_PLAYER_SET_SHUFFLE_MODE, new SessionCommand() {

        @Override
        public void run(IMediaSession2 iSession2, int seq) throws RemoteException {
            iSession2.setShuffleMode(mControllerStub, seq, shuffleMode);
        }
    });
}
#method_after
@Override
public ListenableFuture<ControllerResult> setShuffleMode(final int shuffleMode) {
    return dispatchRemoteSessionTask(COMMAND_CODE_PLAYER_SET_SHUFFLE_MODE, new RemoteSessionTask() {

        @Override
        public void run(IMediaSession2 iSession2, int seq) throws RemoteException {
            iSession2.setShuffleMode(mControllerStub, seq, shuffleMode);
        }
    });
}
#end_block

#method_before
@Override
public ListenableFuture<ControllerResult> subscribeRoutesInfo() {
    return sendCommand(COMMAND_CODE_SESSION_SUBSCRIBE_ROUTES_INFO, new SessionCommand() {

        @Override
        public void run(IMediaSession2 iSession2, int seq) throws RemoteException {
            iSession2.subscribeRoutesInfo(mControllerStub, seq);
        }
    });
}
#method_after
@Override
public ListenableFuture<ControllerResult> subscribeRoutesInfo() {
    return dispatchRemoteSessionTask(COMMAND_CODE_SESSION_SUBSCRIBE_ROUTES_INFO, new RemoteSessionTask() {

        @Override
        public void run(IMediaSession2 iSession2, int seq) throws RemoteException {
            iSession2.subscribeRoutesInfo(mControllerStub, seq);
        }
    });
}
#end_block

#method_before
@Override
public ListenableFuture<ControllerResult> unsubscribeRoutesInfo() {
    return sendCommand(COMMAND_CODE_SESSION_UNSUBSCRIBE_ROUTES_INFO, new SessionCommand() {

        @Override
        public void run(IMediaSession2 iSession2, int seq) throws RemoteException {
            iSession2.unsubscribeRoutesInfo(mControllerStub, seq);
        }
    });
}
#method_after
@Override
public ListenableFuture<ControllerResult> unsubscribeRoutesInfo() {
    return dispatchRemoteSessionTask(COMMAND_CODE_SESSION_UNSUBSCRIBE_ROUTES_INFO, new RemoteSessionTask() {

        @Override
        public void run(IMediaSession2 iSession2, int seq) throws RemoteException {
            iSession2.unsubscribeRoutesInfo(mControllerStub, seq);
        }
    });
}
#end_block

#method_before
@Override
public ListenableFuture<ControllerResult> selectRoute(@NonNull final Bundle route) {
    return sendCommand(COMMAND_CODE_SESSION_SELECT_ROUTE, new SessionCommand() {

        @Override
        public void run(IMediaSession2 iSession2, int seq) throws RemoteException {
            iSession2.selectRoute(mControllerStub, seq, route);
        }
    });
}
#method_after
@Override
public ListenableFuture<ControllerResult> selectRoute(@NonNull final Bundle route) {
    return dispatchRemoteSessionTask(COMMAND_CODE_SESSION_SELECT_ROUTE, new RemoteSessionTask() {

        @Override
        public void run(IMediaSession2 iSession2, int seq) throws RemoteException {
            iSession2.selectRoute(mControllerStub, seq, route);
        }
    });
}
#end_block

#method_before
@Override
public void close() {
    synchronized (mLock) {
        if (isClosed()) {
            return;
        }
        synchronized (MediaSession2ImplBase.class) {
            SESSION_ID_LIST.remove(mSessionId);
        }
        mPlayer.unregisterPlayerCallback(mPlayerCallback);
        mSessionCompat.release();
        mCallback.onSessionClosed(mInstance);
        notifyToAllControllers(new NotifyRunnable() {

            @Override
            public void run(ControllerCb callback) throws RemoteException {
                callback.onDisconnected();
            }
        });
        mHandler.removeCallbacksAndMessages(null);
        if (mHandlerThread.isAlive()) {
            if (Build.VERSION.SDK_INT >= 18) {
                mHandlerThread.quitSafely();
            } else {
                mHandlerThread.quit();
            }
        }
    }
}
#method_after
@Override
public void close() {
    synchronized (mLock) {
        if (isClosed()) {
            return;
        }
        synchronized (MediaSession2ImplBase.class) {
            SESSION_ID_LIST.remove(mSessionId);
        }
        mPlayer.unregisterPlayerCallback(mPlayerCallback);
        mSessionCompat.release();
        mCallback.onSessionClosed(mInstance);
        dispatchRemoteControllerCallbackTask(new RemoteControllerCallbackTask() {

            @Override
            public void run(ControllerCb callback) throws RemoteException {
                callback.onDisconnected();
            }
        });
        mHandler.removeCallbacksAndMessages(null);
        if (mHandlerThread.isAlive()) {
            if (Build.VERSION.SDK_INT >= 18) {
                mHandlerThread.quitSafely();
            } else {
                mHandlerThread.quit();
            }
        }
    }
}
#end_block

#method_before
@Override
public ListenableFuture<SessionResult> setCustomLayout(@NonNull ControllerInfo controller, @NonNull final List<MediaSession2.CommandButton> layout) {
    if (controller == null) {
        throw new IllegalArgumentException("controller shouldn't be null");
    }
    if (layout == null) {
        throw new IllegalArgumentException("layout shouldn't be null");
    }
    return sendCommand(controller, new ControllerCommand() {

        @Override
        public void run(int seq, ControllerCb controller) throws RemoteException {
            controller.setCustomLayout(seq, layout);
        }
    });
}
#method_after
@Override
public ListenableFuture<SessionResult> setCustomLayout(@NonNull ControllerInfo controller, @NonNull final List<MediaSession2.CommandButton> layout) {
    if (controller == null) {
        throw new IllegalArgumentException("controller shouldn't be null");
    }
    if (layout == null) {
        throw new IllegalArgumentException("layout shouldn't be null");
    }
    return dispatchRemoteControllerTask(controller, new RemoteControllerTask() {

        @Override
        public void run(ControllerCb controller, int seq) throws RemoteException {
            controller.setCustomLayout(seq, layout);
        }
    });
}
#end_block

#method_before
@Override
public void setAllowedCommands(@NonNull ControllerInfo controller, @NonNull final SessionCommandGroup2 commands) {
    if (controller == null) {
        throw new IllegalArgumentException("controller shouldn't be null");
    }
    if (commands == null) {
        throw new IllegalArgumentException("commands shouldn't be null");
    }
    if (mSession2Stub.getConnectedControllersManager().isConnected(controller)) {
        mSession2Stub.getConnectedControllersManager().updateAllowedCommands(controller, commands);
        notifyToController(controller, new NotifyRunnable() {

            @Override
            public void run(ControllerCb callback) throws RemoteException {
                callback.onAllowedCommandsChanged(commands);
            }
        });
    } else {
        mSessionLegacyStub.getConnectedControllersManager().updateAllowedCommands(controller, commands);
    }
}
#method_after
@Override
public void setAllowedCommands(@NonNull ControllerInfo controller, @NonNull final SessionCommandGroup2 commands) {
    if (controller == null) {
        throw new IllegalArgumentException("controller shouldn't be null");
    }
    if (commands == null) {
        throw new IllegalArgumentException("commands shouldn't be null");
    }
    if (mSession2Stub.getConnectedControllersManager().isConnected(controller)) {
        mSession2Stub.getConnectedControllersManager().updateAllowedCommands(controller, commands);
        dispatchRemoteControllerCallbackTask(controller, new RemoteControllerCallbackTask() {

            @Override
            public void run(ControllerCb callback) throws RemoteException {
                callback.onAllowedCommandsChanged(commands);
            }
        });
    } else {
        mSessionLegacyStub.getConnectedControllersManager().updateAllowedCommands(controller, commands);
    }
}
#end_block

#method_before
@Override
public void broadcastCustomCommand(@NonNull final SessionCommand2 command, @Nullable final Bundle args) {
    if (command == null) {
        throw new IllegalArgumentException("command shouldn't be null");
    }
    broadcastCommand(new ControllerCommand() {

        @Override
        public void run(int seq, ControllerCb controller) throws RemoteException {
            controller.sendCustomCommand(seq, command, args);
        }
    });
}
#method_after
@Override
public void broadcastCustomCommand(@NonNull final SessionCommand2 command, @Nullable final Bundle args) {
    if (command == null) {
        throw new IllegalArgumentException("command shouldn't be null");
    }
    dispatchRemoteControllerTask(new RemoteControllerTask() {

        @Override
        public void run(ControllerCb controller, int seq) throws RemoteException {
            controller.sendCustomCommand(seq, command, args);
        }
    });
}
#end_block

#method_before
@Override
public ListenableFuture<SessionResult> sendCustomCommand(@NonNull ControllerInfo controller, @NonNull final SessionCommand2 command, @Nullable final Bundle args) {
    if (controller == null) {
        throw new IllegalArgumentException("controller shouldn't be null");
    }
    if (command == null) {
        throw new IllegalArgumentException("command shouldn't be null");
    }
    return sendCommand(controller, new ControllerCommand() {

        @Override
        public void run(int seq, ControllerCb controller) throws RemoteException {
            controller.sendCustomCommand(seq, command, args);
        }
    });
}
#method_after
@Override
public ListenableFuture<SessionResult> sendCustomCommand(@NonNull ControllerInfo controller, @NonNull final SessionCommand2 command, @Nullable final Bundle args) {
    if (controller == null) {
        throw new IllegalArgumentException("controller shouldn't be null");
    }
    if (command == null) {
        throw new IllegalArgumentException("command shouldn't be null");
    }
    return dispatchRemoteControllerTask(controller, new RemoteControllerTask() {

        @Override
        public void run(ControllerCb controller, int seq) throws RemoteException {
            controller.sendCustomCommand(seq, command, args);
        }
    });
}
#end_block

#method_before
@Override
public ListenableFuture<PlayerResult> play() {
    return executeCommand(new PlayerCommand<ListenableFuture<PlayerResult>>() {

        @Override
        public ListenableFuture<PlayerResult> run(SessionPlayer2 player) throws Exception {
            if (player.getPlayerState() != PLAYER_STATE_IDLE) {
                return player.play();
            }
            final ListenableFuture<PlayerResult> prepareFuture = player.prefetch();
            final ListenableFuture<PlayerResult> playFuture = player.play();
            if (prepareFuture == null || playFuture == null) {
                // Let executeCommand() handle such cases.
                return null;
            }
            return XMediaPlayer.CombindedCommandResultFuture.create(DIRECT_EXECUTOR, prepareFuture, playFuture);
        }
    });
}
#method_after
@Override
public ListenableFuture<PlayerResult> play() {
    return dispatchPlayerTask(new PlayerTask<ListenableFuture<PlayerResult>>() {

        @Override
        public ListenableFuture<PlayerResult> run(SessionPlayer2 player) throws Exception {
            if (player.getPlayerState() != PLAYER_STATE_IDLE) {
                return player.play();
            }
            final ListenableFuture<PlayerResult> prepareFuture = player.prepare();
            final ListenableFuture<PlayerResult> playFuture = player.play();
            if (prepareFuture == null || playFuture == null) {
                // Let dispatchPlayerTask() handle such cases.
                return null;
            }
            return XMediaPlayer.CombindedCommandResultFuture.create(DIRECT_EXECUTOR, prepareFuture, playFuture);
        }
    });
}
#end_block

#method_before
@Override
public ListenableFuture<PlayerResult> pause() {
    return executeCommand(new PlayerCommand<ListenableFuture<PlayerResult>>() {

        @Override
        public ListenableFuture<PlayerResult> run(SessionPlayer2 player) throws Exception {
            return player.pause();
        }
    });
}
#method_after
@Override
public ListenableFuture<PlayerResult> pause() {
    return dispatchPlayerTask(new PlayerTask<ListenableFuture<PlayerResult>>() {

        @Override
        public ListenableFuture<PlayerResult> run(SessionPlayer2 player) throws Exception {
            return player.pause();
        }
    });
}
#end_block

#method_before
@Override
public ListenableFuture<PlayerResult> prefetch() {
    return executeCommand(new PlayerCommand<ListenableFuture<PlayerResult>>() {

        @Override
        public ListenableFuture<PlayerResult> run(SessionPlayer2 player) throws Exception {
            return player.prefetch();
        }
    });
}
#method_after
@Override
public ListenableFuture<PlayerResult> prefetch() {
    return dispatchPlayerTask(new PlayerTask<ListenableFuture<PlayerResult>>() {

        @Override
        public ListenableFuture<PlayerResult> run(SessionPlayer2 player) throws Exception {
            return player.prepare();
        }
    });
}
#end_block

#method_before
@Override
public ListenableFuture<PlayerResult> seekTo(final long pos) {
    return executeCommand(new PlayerCommand<ListenableFuture<PlayerResult>>() {

        @Override
        public ListenableFuture<PlayerResult> run(SessionPlayer2 player) throws Exception {
            return player.seekTo(pos);
        }
    });
}
#method_after
@Override
public ListenableFuture<PlayerResult> seekTo(final long pos) {
    return dispatchPlayerTask(new PlayerTask<ListenableFuture<PlayerResult>>() {

        @Override
        public ListenableFuture<PlayerResult> run(SessionPlayer2 player) throws Exception {
            return player.seekTo(pos);
        }
    });
}
#end_block

#method_before
@Override
public void notifyRoutesInfoChanged(@NonNull ControllerInfo controller, @Nullable final List<Bundle> routes) {
    notifyToController(controller, new NotifyRunnable() {

        @Override
        public void run(ControllerCb callback) throws RemoteException {
            callback.onRoutesInfoChanged(routes);
        }
    });
}
#method_after
@Override
public void notifyRoutesInfoChanged(@NonNull ControllerInfo controller, @Nullable final List<Bundle> routes) {
    dispatchRemoteControllerCallbackTask(controller, new RemoteControllerCallbackTask() {

        @Override
        public void run(ControllerCb callback) throws RemoteException {
            callback.onRoutesInfoChanged(routes);
        }
    });
}
#end_block

#method_before
@Override
@SessionPlayer2.PlayerState
public int getPlayerState() {
    return executeCommand(new PlayerCommand<Integer>() {

        @Override
        public Integer run(SessionPlayer2 player) throws Exception {
            return player.getPlayerState();
        }
    }, SessionPlayer2.PLAYER_STATE_ERROR);
}
#method_after
@Override
@SessionPlayer2.PlayerState
public int getPlayerState() {
    return dispatchPlayerTask(new PlayerTask<Integer>() {

        @Override
        public Integer run(SessionPlayer2 player) throws Exception {
            return player.getPlayerState();
        }
    }, SessionPlayer2.PLAYER_STATE_ERROR);
}
#end_block

#method_before
@Override
public long getCurrentPosition() {
    return executeCommand(new PlayerCommand<Long>() {

        @Override
        public Long run(SessionPlayer2 player) throws Exception {
            if (isInPlaybackState(player)) {
                return player.getCurrentPosition();
            }
            return null;
        }
    }, SessionPlayer2.UNKNOWN_TIME);
}
#method_after
@Override
public long getCurrentPosition() {
    return dispatchPlayerTask(new PlayerTask<Long>() {

        @Override
        public Long run(SessionPlayer2 player) throws Exception {
            if (isInPlaybackState(player)) {
                return player.getCurrentPosition();
            }
            return null;
        }
    }, SessionPlayer2.UNKNOWN_TIME);
}
#end_block

#method_before
@Override
public long getDuration() {
    return executeCommand(new PlayerCommand<Long>() {

        @Override
        public Long run(SessionPlayer2 player) throws Exception {
            if (isInPlaybackState(player)) {
                return player.getDuration();
            }
            return null;
        }
    }, SessionPlayer2.UNKNOWN_TIME);
}
#method_after
@Override
public long getDuration() {
    return dispatchPlayerTask(new PlayerTask<Long>() {

        @Override
        public Long run(SessionPlayer2 player) throws Exception {
            if (isInPlaybackState(player)) {
                return player.getDuration();
            }
            return null;
        }
    }, SessionPlayer2.UNKNOWN_TIME);
}
#end_block

#method_before
@Override
public long getBufferedPosition() {
    return executeCommand(new PlayerCommand<Long>() {

        @Override
        public Long run(SessionPlayer2 player) throws Exception {
            if (isInPlaybackState(player)) {
                return player.getBufferedPosition();
            }
            return null;
        }
    }, SessionPlayer2.UNKNOWN_TIME);
}
#method_after
@Override
public long getBufferedPosition() {
    return dispatchPlayerTask(new PlayerTask<Long>() {

        @Override
        public Long run(SessionPlayer2 player) throws Exception {
            if (isInPlaybackState(player)) {
                return player.getBufferedPosition();
            }
            return null;
        }
    }, SessionPlayer2.UNKNOWN_TIME);
}
#end_block

#method_before
@Override
@SessionPlayer2.BuffState
public int getBufferingState() {
    return executeCommand(new PlayerCommand<Integer>() {

        @Override
        public Integer run(SessionPlayer2 player) throws Exception {
            return player.getBufferingState();
        }
    }, SessionPlayer2.BUFFERING_STATE_UNKNOWN);
}
#method_after
@Override
@SessionPlayer2.BuffState
public int getBufferingState() {
    return dispatchPlayerTask(new PlayerTask<Integer>() {

        @Override
        public Integer run(SessionPlayer2 player) throws Exception {
            return player.getBufferingState();
        }
    }, SessionPlayer2.BUFFERING_STATE_UNKNOWN);
}
#end_block

#method_before
@Override
public float getPlaybackSpeed() {
    return executeCommand(new PlayerCommand<Float>() {

        @Override
        public Float run(SessionPlayer2 player) throws Exception {
            if (isInPlaybackState(player)) {
                return player.getPlaybackSpeed();
            }
            return null;
        }
    }, 1.0f);
}
#method_after
@Override
public float getPlaybackSpeed() {
    return dispatchPlayerTask(new PlayerTask<Float>() {

        @Override
        public Float run(SessionPlayer2 player) throws Exception {
            if (isInPlaybackState(player)) {
                return player.getPlaybackSpeed();
            }
            return null;
        }
    }, 1.0f);
}
#end_block

#method_before
@Override
public ListenableFuture<PlayerResult> setPlaybackSpeed(final float speed) {
    return executeCommand(new PlayerCommand<ListenableFuture<PlayerResult>>() {

        @Override
        public ListenableFuture<PlayerResult> run(SessionPlayer2 player) throws Exception {
            return player.setPlaybackSpeed(speed);
        }
    });
}
#method_after
@Override
public ListenableFuture<PlayerResult> setPlaybackSpeed(final float speed) {
    return dispatchPlayerTask(new PlayerTask<ListenableFuture<PlayerResult>>() {

        @Override
        public ListenableFuture<PlayerResult> run(SessionPlayer2 player) throws Exception {
            return player.setPlaybackSpeed(speed);
        }
    });
}
#end_block

#method_before
@Override
public List<MediaItem2> getPlaylist() {
    return executeCommand(new PlayerCommand<List<MediaItem2>>() {

        @Override
        public List<MediaItem2> run(SessionPlayer2 player) throws Exception {
            return player.getPlaylist();
        }
    }, null);
}
#method_after
@Override
public List<MediaItem2> getPlaylist() {
    return dispatchPlayerTask(new PlayerTask<List<MediaItem2>>() {

        @Override
        public List<MediaItem2> run(SessionPlayer2 player) throws Exception {
            return player.getPlaylist();
        }
    }, null);
}
#end_block

#method_before
@Override
public ListenableFuture<PlayerResult> setPlaylist(@NonNull final List<MediaItem2> list, @Nullable final MediaMetadata2 metadata) {
    return executeCommand(new PlayerCommand<ListenableFuture<PlayerResult>>() {

        @Override
        public ListenableFuture<PlayerResult> run(SessionPlayer2 player) throws Exception {
            if (list == null) {
                throw new IllegalArgumentException("list shouldn't be null");
            }
            return player.setPlaylist(list, metadata);
        }
    });
}
#method_after
@Override
public ListenableFuture<PlayerResult> setPlaylist(@NonNull final List<MediaItem2> list, @Nullable final MediaMetadata2 metadata) {
    return dispatchPlayerTask(new PlayerTask<ListenableFuture<PlayerResult>>() {

        @Override
        public ListenableFuture<PlayerResult> run(SessionPlayer2 player) throws Exception {
            if (list == null) {
                throw new IllegalArgumentException("list shouldn't be null");
            }
            return player.setPlaylist(list, metadata);
        }
    });
}
#end_block

#method_before
@Override
public ListenableFuture<PlayerResult> setMediaItem(@NonNull final MediaItem2 item) {
    return executeCommand(new PlayerCommand<ListenableFuture<PlayerResult>>() {

        @Override
        public ListenableFuture<PlayerResult> run(SessionPlayer2 player) throws Exception {
            if (item == null) {
                throw new IllegalArgumentException("item shouldn't be null");
            }
            return player.setMediaItem(item);
        }
    });
}
#method_after
@Override
public ListenableFuture<PlayerResult> setMediaItem(@NonNull final MediaItem2 item) {
    return dispatchPlayerTask(new PlayerTask<ListenableFuture<PlayerResult>>() {

        @Override
        public ListenableFuture<PlayerResult> run(SessionPlayer2 player) throws Exception {
            if (item == null) {
                throw new IllegalArgumentException("item shouldn't be null");
            }
            return player.setMediaItem(item);
        }
    });
}
#end_block

#method_before
@Override
public ListenableFuture<PlayerResult> skipToPlaylistItem(@NonNull final MediaItem2 item) {
    return executeCommand(new PlayerCommand<ListenableFuture<PlayerResult>>() {

        @Override
        public ListenableFuture<PlayerResult> run(SessionPlayer2 player) throws Exception {
            if (item == null) {
                throw new IllegalArgumentException("item shouldn't be null");
            }
            return player.skipToPlaylistItem(item);
        }
    });
}
#method_after
@Override
public ListenableFuture<PlayerResult> skipToPlaylistItem(@NonNull final MediaItem2 item) {
    return dispatchPlayerTask(new PlayerTask<ListenableFuture<PlayerResult>>() {

        @Override
        public ListenableFuture<PlayerResult> run(SessionPlayer2 player) throws Exception {
            if (item == null) {
                throw new IllegalArgumentException("item shouldn't be null");
            }
            return player.skipToPlaylistItem(item);
        }
    });
}
#end_block

#method_before
@Override
public ListenableFuture<PlayerResult> skipToPreviousItem() {
    return executeCommand(new PlayerCommand<ListenableFuture<PlayerResult>>() {

        @Override
        public ListenableFuture<PlayerResult> run(SessionPlayer2 player) throws Exception {
            return player.skipToPreviousPlaylistItem();
        }
    });
}
#method_after
@Override
public ListenableFuture<PlayerResult> skipToPreviousItem() {
    return dispatchPlayerTask(new PlayerTask<ListenableFuture<PlayerResult>>() {

        @Override
        public ListenableFuture<PlayerResult> run(SessionPlayer2 player) throws Exception {
            return player.skipToPreviousPlaylistItem();
        }
    });
}
#end_block

#method_before
@Override
public ListenableFuture<PlayerResult> skipToNextItem() {
    return executeCommand(new PlayerCommand<ListenableFuture<PlayerResult>>() {

        @Override
        public ListenableFuture<PlayerResult> run(SessionPlayer2 player) throws Exception {
            return player.skipToNextPlaylistItem();
        }
    });
}
#method_after
@Override
public ListenableFuture<PlayerResult> skipToNextItem() {
    return dispatchPlayerTask(new PlayerTask<ListenableFuture<PlayerResult>>() {

        @Override
        public ListenableFuture<PlayerResult> run(SessionPlayer2 player) throws Exception {
            return player.skipToNextPlaylistItem();
        }
    });
}
#end_block

#method_before
@Override
public MediaMetadata2 getPlaylistMetadata() {
    return executeCommand(new PlayerCommand<MediaMetadata2>() {

        @Override
        public MediaMetadata2 run(SessionPlayer2 player) throws Exception {
            return player.getPlaylistMetadata();
        }
    }, null);
}
#method_after
@Override
public MediaMetadata2 getPlaylistMetadata() {
    return dispatchPlayerTask(new PlayerTask<MediaMetadata2>() {

        @Override
        public MediaMetadata2 run(SessionPlayer2 player) throws Exception {
            return player.getPlaylistMetadata();
        }
    }, null);
}
#end_block

#method_before
@Override
public ListenableFuture<PlayerResult> addPlaylistItem(final int index, @NonNull final MediaItem2 item) {
    return executeCommand(new PlayerCommand<ListenableFuture<PlayerResult>>() {

        @Override
        public ListenableFuture<PlayerResult> run(SessionPlayer2 player) throws Exception {
            if (index < 0) {
                throw new IllegalArgumentException("index shouldn't be negative");
            }
            if (item == null) {
                throw new IllegalArgumentException("item shouldn't be null");
            }
            return player.addPlaylistItem(index, item);
        }
    });
}
#method_after
@Override
public ListenableFuture<PlayerResult> addPlaylistItem(final int index, @NonNull final MediaItem2 item) {
    return dispatchPlayerTask(new PlayerTask<ListenableFuture<PlayerResult>>() {

        @Override
        public ListenableFuture<PlayerResult> run(SessionPlayer2 player) throws Exception {
            if (index < 0) {
                throw new IllegalArgumentException("index shouldn't be negative");
            }
            if (item == null) {
                throw new IllegalArgumentException("item shouldn't be null");
            }
            return player.addPlaylistItem(index, item);
        }
    });
}
#end_block

#method_before
@Override
public ListenableFuture<PlayerResult> removePlaylistItem(@NonNull final MediaItem2 item) {
    return executeCommand(new PlayerCommand<ListenableFuture<PlayerResult>>() {

        @Override
        public ListenableFuture<PlayerResult> run(SessionPlayer2 player) throws Exception {
            if (item == null) {
                throw new IllegalArgumentException("item shouldn't be null");
            }
            return player.removePlaylistItem(item);
        }
    });
}
#method_after
@Override
public ListenableFuture<PlayerResult> removePlaylistItem(@NonNull final MediaItem2 item) {
    return dispatchPlayerTask(new PlayerTask<ListenableFuture<PlayerResult>>() {

        @Override
        public ListenableFuture<PlayerResult> run(SessionPlayer2 player) throws Exception {
            if (item == null) {
                throw new IllegalArgumentException("item shouldn't be null");
            }
            return player.removePlaylistItem(item);
        }
    });
}
#end_block

#method_before
@Override
public ListenableFuture<PlayerResult> replacePlaylistItem(final int index, @NonNull final MediaItem2 item) {
    return executeCommand(new PlayerCommand<ListenableFuture<PlayerResult>>() {

        @Override
        public ListenableFuture<PlayerResult> run(SessionPlayer2 player) throws Exception {
            if (index < 0) {
                throw new IllegalArgumentException("index shouldn't be negative");
            }
            if (item == null) {
                throw new IllegalArgumentException("item shouldn't be null");
            }
            return player.replacePlaylistItem(index, item);
        }
    });
}
#method_after
@Override
public ListenableFuture<PlayerResult> replacePlaylistItem(final int index, @NonNull final MediaItem2 item) {
    return dispatchPlayerTask(new PlayerTask<ListenableFuture<PlayerResult>>() {

        @Override
        public ListenableFuture<PlayerResult> run(SessionPlayer2 player) throws Exception {
            if (index < 0) {
                throw new IllegalArgumentException("index shouldn't be negative");
            }
            if (item == null) {
                throw new IllegalArgumentException("item shouldn't be null");
            }
            return player.replacePlaylistItem(index, item);
        }
    });
}
#end_block

#method_before
@Override
public MediaItem2 getCurrentMediaItem() {
    return executeCommand(new PlayerCommand<MediaItem2>() {

        @Override
        public MediaItem2 run(SessionPlayer2 player) throws Exception {
            return player.getCurrentMediaItem();
        }
    }, null);
}
#method_after
@Override
public MediaItem2 getCurrentMediaItem() {
    return dispatchPlayerTask(new PlayerTask<MediaItem2>() {

        @Override
        public MediaItem2 run(SessionPlayer2 player) throws Exception {
            return player.getCurrentMediaItem();
        }
    }, null);
}
#end_block

#method_before
@Override
public ListenableFuture<PlayerResult> updatePlaylistMetadata(@Nullable final MediaMetadata2 metadata) {
    return executeCommand(new PlayerCommand<ListenableFuture<PlayerResult>>() {

        @Override
        public ListenableFuture<PlayerResult> run(SessionPlayer2 player) throws Exception {
            return player.updatePlaylistMetadata(metadata);
        }
    });
}
#method_after
@Override
public ListenableFuture<PlayerResult> updatePlaylistMetadata(@Nullable final MediaMetadata2 metadata) {
    return dispatchPlayerTask(new PlayerTask<ListenableFuture<PlayerResult>>() {

        @Override
        public ListenableFuture<PlayerResult> run(SessionPlayer2 player) throws Exception {
            return player.updatePlaylistMetadata(metadata);
        }
    });
}
#end_block

#method_before
@Override
@SessionPlayer2.RepeatMode
public int getRepeatMode() {
    return executeCommand(new PlayerCommand<Integer>() {

        @Override
        public Integer run(SessionPlayer2 player) throws Exception {
            return player.getRepeatMode();
        }
    }, SessionPlayer2.REPEAT_MODE_NONE);
}
#method_after
@Override
@SessionPlayer2.RepeatMode
public int getRepeatMode() {
    return dispatchPlayerTask(new PlayerTask<Integer>() {

        @Override
        public Integer run(SessionPlayer2 player) throws Exception {
            return player.getRepeatMode();
        }
    }, SessionPlayer2.REPEAT_MODE_NONE);
}
#end_block

#method_before
@Override
public ListenableFuture<PlayerResult> setRepeatMode(@SessionPlayer2.RepeatMode final int repeatMode) {
    return executeCommand(new PlayerCommand<ListenableFuture<PlayerResult>>() {

        @Override
        public ListenableFuture<PlayerResult> run(SessionPlayer2 player) throws Exception {
            return player.setRepeatMode(repeatMode);
        }
    });
}
#method_after
@Override
public ListenableFuture<PlayerResult> setRepeatMode(@SessionPlayer2.RepeatMode final int repeatMode) {
    return dispatchPlayerTask(new PlayerTask<ListenableFuture<PlayerResult>>() {

        @Override
        public ListenableFuture<PlayerResult> run(SessionPlayer2 player) throws Exception {
            return player.setRepeatMode(repeatMode);
        }
    });
}
#end_block

#method_before
@Override
@SessionPlayer2.ShuffleMode
public int getShuffleMode() {
    return executeCommand(new PlayerCommand<Integer>() {

        @Override
        public Integer run(SessionPlayer2 player) throws Exception {
            return player.getShuffleMode();
        }
    }, SessionPlayer2.SHUFFLE_MODE_NONE);
}
#method_after
@Override
@SessionPlayer2.ShuffleMode
public int getShuffleMode() {
    return dispatchPlayerTask(new PlayerTask<Integer>() {

        @Override
        public Integer run(SessionPlayer2 player) throws Exception {
            return player.getShuffleMode();
        }
    }, SessionPlayer2.SHUFFLE_MODE_NONE);
}
#end_block

#method_before
@Override
public ListenableFuture<PlayerResult> setShuffleMode(@SessionPlayer2.ShuffleMode final int shuffleMode) {
    return executeCommand(new PlayerCommand<ListenableFuture<PlayerResult>>() {

        @Override
        public ListenableFuture<PlayerResult> run(SessionPlayer2 player) throws Exception {
            return player.setShuffleMode(shuffleMode);
        }
    });
}
#method_after
@Override
public ListenableFuture<PlayerResult> setShuffleMode(@SessionPlayer2.ShuffleMode final int shuffleMode) {
    return dispatchPlayerTask(new PlayerTask<ListenableFuture<PlayerResult>>() {

        @Override
        public ListenableFuture<PlayerResult> run(SessionPlayer2 player) throws Exception {
            return player.setShuffleMode(shuffleMode);
        }
    });
}
#end_block

#method_before
@SuppressLint("WrongConstant")
private void notifyPlayerUpdatedNotLocked(SessionPlayer2 oldPlayer) {
    // Tells the playlist change first, to current item can change be notified with an item
    // within the playlist.
    List<MediaItem2> oldPlaylist = oldPlayer.getPlaylist();
    final List<MediaItem2> newPlaylist = getPlaylistOrNull();
    if (!ObjectsCompat.equals(oldPlaylist, newPlaylist)) {
        notifyToAllControllers(new NotifyRunnable() {

            @Override
            public void run(ControllerCb callback) throws RemoteException {
                callback.onPlaylistChanged(newPlaylist, getPlaylistMetadata());
            }
        });
    } else {
        MediaMetadata2 oldMetadata = oldPlayer.getPlaylistMetadata();
        final MediaMetadata2 newMetadata = getPlaylistMetadata();
        if (!ObjectsCompat.equals(oldMetadata, newMetadata)) {
            notifyToAllControllers(new NotifyRunnable() {

                @Override
                public void run(ControllerCb callback) throws RemoteException {
                    callback.onPlaylistMetadataChanged(newMetadata);
                }
            });
        }
    }
    MediaItem2 oldCurrentItem = oldPlayer.getCurrentMediaItem();
    final MediaItem2 newCurrentItem = getCurrentMediaItemOrNull();
    if (!ObjectsCompat.equals(oldCurrentItem, newCurrentItem)) {
        notifyToAllControllers(new NotifyRunnable() {

            @Override
            public void run(ControllerCb callback) throws RemoteException {
                callback.onCurrentMediaItemChanged(newCurrentItem);
            }
        });
    }
    @SessionPlayer2.RepeatMode
    final int repeatMode = getRepeatMode();
    if (oldPlayer.getRepeatMode() != repeatMode) {
        notifyToAllControllers(new NotifyRunnable() {

            @Override
            public void run(ControllerCb callback) throws RemoteException {
                callback.onRepeatModeChanged(repeatMode);
            }
        });
    }
    @SessionPlayer2.ShuffleMode
    final int shuffleMode = getShuffleMode();
    if (oldPlayer.getShuffleMode() != shuffleMode) {
        notifyToAllControllers(new NotifyRunnable() {

            @Override
            public void run(ControllerCb callback) throws RemoteException {
                callback.onShuffleModeChanged(shuffleMode);
            }
        });
    }
    // Always forcefully send the player state and buffered state to send the current position
    // and buffered position.
    final long currentTimeMs = SystemClock.elapsedRealtime();
    final long positionMs = getCurrentPosition();
    final int playerState = getPlayerState();
    notifyToAllControllers(new NotifyRunnable() {

        @Override
        public void run(ControllerCb callback) throws RemoteException {
            callback.onPlayerStateChanged(currentTimeMs, positionMs, playerState);
        }
    });
    final MediaItem2 item = getCurrentMediaItemOrNull();
    if (item != null) {
        final int bufferingState = getBufferingState();
        final long bufferedPositionMs = getBufferedPosition();
        notifyToAllControllers(new NotifyRunnable() {

            @Override
            public void run(ControllerCb callback) throws RemoteException {
                callback.onBufferingStateChanged(item, bufferingState, bufferedPositionMs);
            }
        });
    }
    final float speed = getPlaybackSpeed();
    if (speed != oldPlayer.getPlaybackSpeed()) {
        notifyToAllControllers(new NotifyRunnable() {

            @Override
            public void run(ControllerCb callback) throws RemoteException {
                callback.onPlaybackSpeedChanged(currentTimeMs, positionMs, speed);
            }
        });
    }
// Note: AudioInfo is updated outside of this API.
}
#method_after
@SuppressLint("WrongConstant")
private void notifyPlayerUpdatedNotLocked(SessionPlayer2 oldPlayer) {
    // Tells the playlist change first, to current item can change be notified with an item
    // within the playlist.
    List<MediaItem2> oldPlaylist = oldPlayer.getPlaylist();
    final List<MediaItem2> newPlaylist = getPlaylistOrNull();
    if (!ObjectsCompat.equals(oldPlaylist, newPlaylist)) {
        dispatchRemoteControllerCallbackTask(new RemoteControllerCallbackTask() {

            @Override
            public void run(ControllerCb callback) throws RemoteException {
                callback.onPlaylistChanged(newPlaylist, getPlaylistMetadata());
            }
        });
    } else {
        MediaMetadata2 oldMetadata = oldPlayer.getPlaylistMetadata();
        final MediaMetadata2 newMetadata = getPlaylistMetadata();
        if (!ObjectsCompat.equals(oldMetadata, newMetadata)) {
            dispatchRemoteControllerCallbackTask(new RemoteControllerCallbackTask() {

                @Override
                public void run(ControllerCb callback) throws RemoteException {
                    callback.onPlaylistMetadataChanged(newMetadata);
                }
            });
        }
    }
    MediaItem2 oldCurrentItem = oldPlayer.getCurrentMediaItem();
    final MediaItem2 newCurrentItem = getCurrentMediaItemOrNull();
    if (!ObjectsCompat.equals(oldCurrentItem, newCurrentItem)) {
        dispatchRemoteControllerCallbackTask(new RemoteControllerCallbackTask() {

            @Override
            public void run(ControllerCb callback) throws RemoteException {
                callback.onCurrentMediaItemChanged(newCurrentItem);
            }
        });
    }
    @SessionPlayer2.RepeatMode
    final int repeatMode = getRepeatMode();
    if (oldPlayer.getRepeatMode() != repeatMode) {
        dispatchRemoteControllerCallbackTask(new RemoteControllerCallbackTask() {

            @Override
            public void run(ControllerCb callback) throws RemoteException {
                callback.onRepeatModeChanged(repeatMode);
            }
        });
    }
    @SessionPlayer2.ShuffleMode
    final int shuffleMode = getShuffleMode();
    if (oldPlayer.getShuffleMode() != shuffleMode) {
        dispatchRemoteControllerCallbackTask(new RemoteControllerCallbackTask() {

            @Override
            public void run(ControllerCb callback) throws RemoteException {
                callback.onShuffleModeChanged(shuffleMode);
            }
        });
    }
    // Always forcefully send the player state and buffered state to send the current position
    // and buffered position.
    final long currentTimeMs = SystemClock.elapsedRealtime();
    final long positionMs = getCurrentPosition();
    final int playerState = getPlayerState();
    dispatchRemoteControllerCallbackTask(new RemoteControllerCallbackTask() {

        @Override
        public void run(ControllerCb callback) throws RemoteException {
            callback.onPlayerStateChanged(currentTimeMs, positionMs, playerState);
        }
    });
    final MediaItem2 item = getCurrentMediaItemOrNull();
    if (item != null) {
        final int bufferingState = getBufferingState();
        final long bufferedPositionMs = getBufferedPosition();
        dispatchRemoteControllerCallbackTask(new RemoteControllerCallbackTask() {

            @Override
            public void run(ControllerCb callback) throws RemoteException {
                callback.onBufferingStateChanged(item, bufferingState, bufferedPositionMs);
            }
        });
    }
    final float speed = getPlaybackSpeed();
    if (speed != oldPlayer.getPlaybackSpeed()) {
        dispatchRemoteControllerCallbackTask(new RemoteControllerCallbackTask() {

            @Override
            public void run(ControllerCb callback) throws RemoteException {
                callback.onPlaybackSpeedChanged(currentTimeMs, positionMs, speed);
            }
        });
    }
// Note: AudioInfo is updated outside of this API.
}
#end_block

#method_before
@SuppressWarnings("WeakerAccess")
/* synthetic access */
void notifyPlaybackInfoChangedNotLocked(final PlaybackInfo info) {
    notifyToAllControllers(new NotifyRunnable() {

        @Override
        public void run(ControllerCb callback) throws RemoteException {
            callback.onPlaybackInfoChanged(info);
        }
    });
}
#method_after
@SuppressWarnings("WeakerAccess")
/* synthetic access */
void notifyPlaybackInfoChangedNotLocked(final PlaybackInfo info) {
    dispatchRemoteControllerCallbackTask(new RemoteControllerCallbackTask() {

        @Override
        public void run(ControllerCb callback) throws RemoteException {
            callback.onPlaybackInfoChanged(info);
        }
    });
}
#end_block

#method_before
@Override
public void onCurrentMediaItemChanged(final SessionPlayer2 player, final MediaItem2 item) {
    final MediaSession2ImplBase session = getSession();
    if (session == null || session.getPlayer() != player || player == null) {
        return;
    }
    // Note: No sanity check whether the item is in the playlist.
    updateDurationIfNeeded(player, item);
    session.notifyToAllControllers(new NotifyRunnable() {

        @Override
        public void run(ControllerCb callback) throws RemoteException {
            callback.onCurrentMediaItemChanged(item);
        }
    });
}
#method_after
@Override
public void onCurrentMediaItemChanged(final SessionPlayer2 player, final MediaItem2 item) {
    final MediaSession2ImplBase session = getSession();
    if (session == null || session.getPlayer() != player || player == null) {
        return;
    }
    // Note: No sanity check whether the item is in the playlist.
    updateDurationIfNeeded(player, item);
    session.dispatchRemoteControllerCallbackTask(new RemoteControllerCallbackTask() {

        @Override
        public void run(ControllerCb callback) throws RemoteException {
            callback.onCurrentMediaItemChanged(item);
        }
    });
}
#end_block

#method_before
@Override
public void onPlayerStateChanged(final SessionPlayer2 player, final int state) {
    final MediaSession2ImplBase session = getSession();
    if (session == null || session.getPlayer() != player || player == null) {
        return;
    }
    session.getCallback().onPlayerStateChanged(session.getInstance(), state);
    updateDurationIfNeeded(player, player.getCurrentMediaItem());
    session.notifyToAllControllers(new NotifyRunnable() {

        @Override
        public void run(ControllerCb callback) throws RemoteException {
            callback.onPlayerStateChanged(SystemClock.elapsedRealtime(), player.getCurrentPosition(), state);
        }
    });
}
#method_after
@Override
public void onPlayerStateChanged(final SessionPlayer2 player, final int state) {
    final MediaSession2ImplBase session = getSession();
    if (session == null || session.getPlayer() != player || player == null) {
        return;
    }
    session.getCallback().onPlayerStateChanged(session.getInstance(), state);
    updateDurationIfNeeded(player, player.getCurrentMediaItem());
    session.dispatchRemoteControllerCallbackTask(new RemoteControllerCallbackTask() {

        @Override
        public void run(ControllerCb callback) throws RemoteException {
            callback.onPlayerStateChanged(SystemClock.elapsedRealtime(), player.getCurrentPosition(), state);
        }
    });
}
#end_block

#method_before
@Override
public void onBufferingStateChanged(final SessionPlayer2 player, final MediaItem2 item, final int state) {
    updateDurationIfNeeded(player, item);
    notifyToAllControllers(player, new NotifyRunnable() {

        @Override
        public void run(ControllerCb callback) throws RemoteException {
            callback.onBufferingStateChanged(item, state, player.getBufferedPosition());
        }
    });
}
#method_after
@Override
public void onBufferingStateChanged(final SessionPlayer2 player, final MediaItem2 item, final int state) {
    updateDurationIfNeeded(player, item);
    dispatchRemoteControllerTask(player, new RemoteControllerCallbackTask() {

        @Override
        public void run(ControllerCb callback) throws RemoteException {
            callback.onBufferingStateChanged(item, state, player.getBufferedPosition());
        }
    });
}
#end_block

#method_before
@Override
public void onPlaybackSpeedChanged(final SessionPlayer2 player, final float speed) {
    notifyToAllControllers(player, new NotifyRunnable() {

        @Override
        public void run(ControllerCb callback) throws RemoteException {
            callback.onPlaybackSpeedChanged(SystemClock.elapsedRealtime(), player.getCurrentPosition(), speed);
        }
    });
}
#method_after
@Override
public void onPlaybackSpeedChanged(final SessionPlayer2 player, final float speed) {
    dispatchRemoteControllerTask(player, new RemoteControllerCallbackTask() {

        @Override
        public void run(ControllerCb callback) throws RemoteException {
            callback.onPlaybackSpeedChanged(SystemClock.elapsedRealtime(), player.getCurrentPosition(), speed);
        }
    });
}
#end_block

#method_before
@Override
public void onSeekCompleted(final SessionPlayer2 player, final long position) {
    notifyToAllControllers(player, new NotifyRunnable() {

        @Override
        public void run(ControllerCb callback) throws RemoteException {
            callback.onSeekCompleted(SystemClock.elapsedRealtime(), player.getCurrentPosition(), position);
        }
    });
}
#method_after
@Override
public void onSeekCompleted(final SessionPlayer2 player, final long position) {
    dispatchRemoteControllerTask(player, new RemoteControllerCallbackTask() {

        @Override
        public void run(ControllerCb callback) throws RemoteException {
            callback.onSeekCompleted(SystemClock.elapsedRealtime(), player.getCurrentPosition(), position);
        }
    });
}
#end_block

#method_before
@Override
public void onPlaylistChanged(final SessionPlayer2 player, final List<MediaItem2> list, final MediaMetadata2 metadata) {
    notifyToAllControllers(player, new NotifyRunnable() {

        @Override
        public void run(ControllerCb callback) throws RemoteException {
            callback.onPlaylistChanged(list, metadata);
        }
    });
}
#method_after
@Override
public void onPlaylistChanged(final SessionPlayer2 player, final List<MediaItem2> list, final MediaMetadata2 metadata) {
    dispatchRemoteControllerTask(player, new RemoteControllerCallbackTask() {

        @Override
        public void run(ControllerCb callback) throws RemoteException {
            callback.onPlaylistChanged(list, metadata);
        }
    });
}
#end_block

#method_before
@Override
public void onPlaylistMetadataChanged(final SessionPlayer2 player, final MediaMetadata2 metadata) {
    notifyToAllControllers(player, new NotifyRunnable() {

        @Override
        public void run(ControllerCb callback) throws RemoteException {
            callback.onPlaylistMetadataChanged(metadata);
        }
    });
}
#method_after
@Override
public void onPlaylistMetadataChanged(final SessionPlayer2 player, final MediaMetadata2 metadata) {
    dispatchRemoteControllerTask(player, new RemoteControllerCallbackTask() {

        @Override
        public void run(ControllerCb callback) throws RemoteException {
            callback.onPlaylistMetadataChanged(metadata);
        }
    });
}
#end_block

#method_before
@Override
public void onRepeatModeChanged(final SessionPlayer2 player, final int repeatMode) {
    notifyToAllControllers(player, new NotifyRunnable() {

        @Override
        public void run(ControllerCb callback) throws RemoteException {
            callback.onRepeatModeChanged(repeatMode);
        }
    });
}
#method_after
@Override
public void onRepeatModeChanged(final SessionPlayer2 player, final int repeatMode) {
    dispatchRemoteControllerTask(player, new RemoteControllerCallbackTask() {

        @Override
        public void run(ControllerCb callback) throws RemoteException {
            callback.onRepeatModeChanged(repeatMode);
        }
    });
}
#end_block

#method_before
@Override
public void onShuffleModeChanged(final SessionPlayer2 player, final int shuffleMode) {
    notifyToAllControllers(player, new NotifyRunnable() {

        @Override
        public void run(ControllerCb callback) throws RemoteException {
            callback.onShuffleModeChanged(shuffleMode);
        }
    });
}
#method_after
@Override
public void onShuffleModeChanged(final SessionPlayer2 player, final int shuffleMode) {
    dispatchRemoteControllerTask(player, new RemoteControllerCallbackTask() {

        @Override
        public void run(ControllerCb callback) throws RemoteException {
            callback.onShuffleModeChanged(shuffleMode);
        }
    });
}
#end_block

#method_before
@Override
public void onPlaybackCompleted(SessionPlayer2 player) {
    notifyToAllControllers(player, new NotifyRunnable() {

        @Override
        public void run(ControllerCb callback) throws RemoteException {
            callback.onPlaybackCompleted();
        }
    });
}
#method_after
@Override
public void onPlaybackCompleted(SessionPlayer2 player) {
    dispatchRemoteControllerTask(player, new RemoteControllerCallbackTask() {

        @Override
        public void run(ControllerCb callback) throws RemoteException {
            callback.onPlaybackCompleted();
        }
    });
}
#end_block

#method_before
private void updateDurationIfNeeded(@NonNull final SessionPlayer2 player, @Nullable final MediaItem2 item) {
    if (item == null) {
        return;
    }
    if (!item.equals(player.getCurrentMediaItem())) {
        return;
    }
    final long duration = player.getDuration();
    if (duration <= 0 || duration == UNKNOWN_TIME) {
        return;
    }
    MediaMetadata2 metadata = item.getMetadata();
    if (metadata != null) {
        if (!metadata.containsKey(MediaMetadata2.METADATA_KEY_DURATION)) {
            metadata = new MediaMetadata2.Builder(metadata).putLong(MediaMetadata2.METADATA_KEY_DURATION, duration).build();
        } else {
            long durationFromMetadata = metadata.getLong(MediaMetadata2.METADATA_KEY_DURATION);
            if (duration == durationFromMetadata) {
                return;
            }
            // Warns developers about the mismatch. Don't log media item here to keep
            // metadata secure.
            Log.w(TAG, "duration mismatch for an item." + " duration from player=" + duration + " duration from metadata=" + durationFromMetadata + ". May be a timing issue?");
        // Trust duration in the metadata set by developer.
        // In theory, duration may differ if the current item has been
        // changed before the getDuration(). So it's better not touch
        // duration set by developer.
        }
    } else {
        metadata = new MediaMetadata2.Builder().putLong(MediaMetadata2.METADATA_KEY_DURATION, duration).putString(MediaMetadata2.METADATA_KEY_MEDIA_ID, item.getMediaId()).build();
    }
    if (metadata != null) {
        item.setMetadata(metadata);
        notifyToAllControllers(player, new NotifyRunnable() {

            @Override
            public void run(ControllerCb callback) throws RemoteException {
                callback.onPlaylistChanged(player.getPlaylist(), player.getPlaylistMetadata());
            }
        });
    }
}
#method_after
private void updateDurationIfNeeded(@NonNull final SessionPlayer2 player, @Nullable final MediaItem2 item) {
    if (item == null) {
        return;
    }
    if (!item.equals(player.getCurrentMediaItem())) {
        return;
    }
    final long duration = player.getDuration();
    if (duration <= 0 || duration == UNKNOWN_TIME) {
        return;
    }
    MediaMetadata2 metadata = item.getMetadata();
    if (metadata != null) {
        if (!metadata.containsKey(MediaMetadata2.METADATA_KEY_DURATION)) {
            metadata = new MediaMetadata2.Builder(metadata).putLong(MediaMetadata2.METADATA_KEY_DURATION, duration).build();
        } else {
            long durationFromMetadata = metadata.getLong(MediaMetadata2.METADATA_KEY_DURATION);
            if (duration == durationFromMetadata) {
                return;
            }
            // Warns developers about the mismatch. Don't log media item here to keep
            // metadata secure.
            Log.w(TAG, "duration mismatch for an item." + " duration from player=" + duration + " duration from metadata=" + durationFromMetadata + ". May be a timing issue?");
        // Trust duration in the metadata set by developer.
        // In theory, duration may differ if the current item has been
        // changed before the getDuration(). So it's better not touch
        // duration set by developer.
        }
    } else {
        metadata = new MediaMetadata2.Builder().putLong(MediaMetadata2.METADATA_KEY_DURATION, duration).putString(MediaMetadata2.METADATA_KEY_MEDIA_ID, item.getMediaId()).build();
    }
    if (metadata != null) {
        item.setMetadata(metadata);
        dispatchRemoteControllerTask(player, new RemoteControllerCallbackTask() {

            @Override
            public void run(ControllerCb callback) throws RemoteException {
                callback.onPlaylistChanged(player.getPlaylist(), player.getPlaylistMetadata());
            }
        });
    }
}
#end_block

#method_before
@Override
public void waitForConnect(boolean expect) throws InterruptedException {
    if (expect) {
        assertTrue(connectLatch.await(MediaSession2TestBase.WAIT_TIME_MS, TimeUnit.MILLISECONDS));
    } else {
        assertFalse(connectLatch.await(MediaSession2TestBase.TIMEOUT_MS, TimeUnit.MILLISECONDS));
    }
}
#method_after
@Override
public void waitForConnect(boolean expect) throws InterruptedException {
    if (expect) {
        assertTrue(connectLatch.await(MediaSession2TestBase.TIMEOUT_MS, TimeUnit.MILLISECONDS));
    } else {
        assertFalse(connectLatch.await(MediaSession2TestBase.TIMEOUT_MS, TimeUnit.MILLISECONDS));
    }
}
#end_block

#method_before
@Override
public void waitForDisconnect(boolean expect) throws InterruptedException {
    if (expect) {
        assertTrue(disconnectLatch.await(MediaSession2TestBase.WAIT_TIME_MS, TimeUnit.MILLISECONDS));
    } else {
        assertFalse(disconnectLatch.await(MediaSession2TestBase.TIMEOUT_MS, TimeUnit.MILLISECONDS));
    }
}
#method_after
@Override
public void waitForDisconnect(boolean expect) throws InterruptedException {
    if (expect) {
        assertTrue(disconnectLatch.await(MediaSession2TestBase.TIMEOUT_MS, TimeUnit.MILLISECONDS));
    } else {
        assertFalse(disconnectLatch.await(MediaSession2TestBase.TIMEOUT_MS, TimeUnit.MILLISECONDS));
    }
}
#end_block

#method_before
@Override
public void onLoadChildren(final String parentId, final Result<List<MediaItem>> result, final Bundle options) {
    result.detach();
    final ControllerInfo controller = getCurrentController();
    mLibrarySessionImpl.getCallbackExecutor().execute(new Runnable() {

        @Override
        public void run() {
            if (!getConnectedControllersManager().isAllowedCommand(controller, SessionCommand2.COMMAND_CODE_LIBRARY_GET_CHILDREN)) {
                if (DEBUG) {
                    Log.d(TAG, "Command MBC.subscribe() from " + controller + " was rejected" + " by " + mLibrarySessionImpl);
                }
                result.sendError(null);
                return;
            }
            if (options != null) {
                options.setClassLoader(mLibrarySessionImpl.getContext().getClassLoader());
                try {
                    int page = options.getInt(EXTRA_PAGE);
                    int pageSize = options.getInt(EXTRA_PAGE_SIZE);
                    if (page > 0 && pageSize > 0) {
                        // Requesting the list of children through pagination.
                        LibraryParams params = MediaUtils2.convertToLibraryParams(mLibrarySessionImpl.getContext(), options);
                        LibraryResult libraryResult = mLibrarySessionImpl.getCallback().onGetChildren(mLibrarySessionImpl.getInstance(), controller, parentId, page, pageSize, params);
                        if (libraryResult == null || libraryResult.getResultCode() != RESULT_CODE_SUCCESS) {
                            result.sendResult(null);
                        } else {
                            result.sendResult(MediaUtils2.convertToMediaItemList(libraryResult.getMediaItems()));
                        }
                        return;
                    }
                // Cannot distinguish onLoadChildren() why it's called either by
                // {@link MediaBrowserCompat#subscribe()} or
                // {@link MediaBrowserServiceCompat#notifyChildrenChanged}.
                } catch (BadParcelableException e) {
                // pass-through.
                }
            }
            // A MediaBrowserCompat called loadChildren with no pagination option.
            LibraryResult libraryResult = mLibrarySessionImpl.getCallback().onGetChildren(mLibrarySessionImpl.getInstance(), controller, parentId, 0, /* page */
            Integer.MAX_VALUE, /* pageSize*/
            null);
            if (libraryResult == null || libraryResult.getResultCode() != RESULT_CODE_SUCCESS) {
                result.sendResult(null);
            } else {
                result.sendResult(MediaUtils2.convertToMediaItemList(libraryResult.getMediaItems()));
            }
        }
    });
}
#method_after
@Override
public void onLoadChildren(final String parentId, final Result<List<MediaItem>> result, final Bundle options) {
    result.detach();
    final ControllerInfo controller = getCurrentController();
    mLibrarySessionImpl.getCallbackExecutor().execute(new Runnable() {

        @Override
        public void run() {
            if (!getConnectedControllersManager().isAllowedCommand(controller, SessionCommand2.COMMAND_CODE_LIBRARY_GET_CHILDREN)) {
                if (DEBUG) {
                    Log.d(TAG, "Command MBC.subscribe() from " + controller + " was rejected" + " by " + mLibrarySessionImpl);
                }
                result.sendError(null);
                return;
            }
            if (options != null) {
                options.setClassLoader(mLibrarySessionImpl.getContext().getClassLoader());
                try {
                    int page = options.getInt(EXTRA_PAGE);
                    int pageSize = options.getInt(EXTRA_PAGE_SIZE);
                    if (page > 0 && pageSize > 0) {
                        // Requesting the list of children through pagination.
                        LibraryParams params = MediaUtils2.convertToLibraryParams(mLibrarySessionImpl.getContext(), options);
                        LibraryResult libraryResult = mLibrarySessionImpl.getCallback().onGetChildren(mLibrarySessionImpl.getInstance(), controller, parentId, page, pageSize, params);
                        if (libraryResult == null || libraryResult.getResultCode() != RESULT_CODE_SUCCESS) {
                            result.sendResult(null);
                        } else {
                            result.sendResult(MediaUtils2.truncateListBySize(MediaUtils2.convertToMediaItemList(libraryResult.getMediaItems()), TRANSACTION_SIZE_LIMIT_IN_BYTES));
                        }
                        return;
                    }
                // Cannot distinguish onLoadChildren() why it's called either by
                // {@link MediaBrowserCompat#subscribe()} or
                // {@link MediaBrowserServiceCompat#notifyChildrenChanged}.
                } catch (BadParcelableException e) {
                // pass-through.
                }
            }
            // A MediaBrowserCompat called loadChildren with no pagination option.
            LibraryResult libraryResult = mLibrarySessionImpl.getCallback().onGetChildren(mLibrarySessionImpl.getInstance(), controller, parentId, 0, /* page */
            Integer.MAX_VALUE, /* pageSize*/
            null);
            if (libraryResult == null || libraryResult.getResultCode() != RESULT_CODE_SUCCESS) {
                result.sendResult(null);
            } else {
                result.sendResult(MediaUtils2.truncateListBySize(MediaUtils2.convertToMediaItemList(libraryResult.getMediaItems()), TRANSACTION_SIZE_LIMIT_IN_BYTES));
            }
        }
    });
}
#end_block

#method_before
@Override
void onSearchResultChanged(String query, int itemCount, LibraryParams params) throws RemoteException {
    // In MediaLibrarySession/MediaBrowser2, we have two different APIs for getting size of
    // search result (and also starting search) and getting result.
    // However, MediaBrowserService2/MediaBrowserCompat only have one search API for getting
    // search result.
    final List<SearchRequest> searchRequests = new ArrayList<>();
    synchronized (mLock) {
        for (int i = mSearchRequests.size() - 1; i >= 0; i--) {
            SearchRequest iter = mSearchRequests.get(i);
            if (ObjectsCompat.equals(mRemoteUserInfo, iter.mRemoteUserInfo) && iter.mQuery.equals(query)) {
                searchRequests.add(iter);
                mSearchRequests.remove(i);
            }
        }
        if (searchRequests.size() == 0) {
            if (DEBUG) {
                Log.d(TAG, "search() hasn't called by " + mRemoteUserInfo + " with query=" + query);
            }
            return;
        }
    }
    mLibrarySessionImpl.getCallbackExecutor().execute(new Runnable() {

        @Override
        public void run() {
            for (int i = 0; i < searchRequests.size(); i++) {
                SearchRequest request = searchRequests.get(i);
                int page = 0;
                int pageSize = 0;
                if (request.mExtras != null) {
                    try {
                        request.mExtras.setClassLoader(mLibrarySessionImpl.getContext().getClassLoader());
                        page = request.mExtras.getInt(MediaBrowserCompat.EXTRA_PAGE, -1);
                        pageSize = request.mExtras.getInt(MediaBrowserCompat.EXTRA_PAGE_SIZE, -1);
                    } catch (BadParcelableException e) {
                        request.mResult.sendResult(null);
                        return;
                    }
                }
                if (page < 0 || pageSize < 1) {
                    page = 0;
                    pageSize = Integer.MAX_VALUE;
                }
                LibraryParams params = MediaUtils2.convertToLibraryParams(mLibrarySessionImpl.getContext(), request.mExtras);
                LibraryResult libraryResult = mLibrarySessionImpl.getCallback().onGetSearchResult(mLibrarySessionImpl.getInstance(), request.mController, request.mQuery, page, pageSize, params);
                if (libraryResult == null || libraryResult.getResultCode() != RESULT_CODE_SUCCESS) {
                    request.mResult.sendResult(null);
                } else {
                    request.mResult.sendResult(MediaUtils2.convertToMediaItemList(libraryResult.getMediaItems()));
                }
            }
        }
    });
}
#method_after
@Override
void onSearchResultChanged(String query, int itemCount, LibraryParams params) throws RemoteException {
    // In MediaLibrarySession/MediaBrowser2, we have two different APIs for getting size of
    // search result (and also starting search) and getting result.
    // However, MediaBrowserService2/MediaBrowserCompat only have one search API for getting
    // search result.
    final List<SearchRequest> searchRequests = new ArrayList<>();
    synchronized (mLock) {
        for (int i = mSearchRequests.size() - 1; i >= 0; i--) {
            SearchRequest iter = mSearchRequests.get(i);
            if (ObjectsCompat.equals(mRemoteUserInfo, iter.mRemoteUserInfo) && iter.mQuery.equals(query)) {
                searchRequests.add(iter);
                mSearchRequests.remove(i);
            }
        }
        if (searchRequests.size() == 0) {
            if (DEBUG) {
                Log.d(TAG, "search() hasn't called by " + mRemoteUserInfo + " with query=" + query);
            }
            return;
        }
    }
    mLibrarySessionImpl.getCallbackExecutor().execute(new Runnable() {

        @Override
        public void run() {
            for (int i = 0; i < searchRequests.size(); i++) {
                SearchRequest request = searchRequests.get(i);
                int page = 0;
                int pageSize = 0;
                if (request.mExtras != null) {
                    try {
                        request.mExtras.setClassLoader(mLibrarySessionImpl.getContext().getClassLoader());
                        page = request.mExtras.getInt(MediaBrowserCompat.EXTRA_PAGE, -1);
                        pageSize = request.mExtras.getInt(MediaBrowserCompat.EXTRA_PAGE_SIZE, -1);
                    } catch (BadParcelableException e) {
                        request.mResult.sendResult(null);
                        return;
                    }
                }
                if (page < 0 || pageSize < 1) {
                    page = 0;
                    pageSize = Integer.MAX_VALUE;
                }
                LibraryParams params = MediaUtils2.convertToLibraryParams(mLibrarySessionImpl.getContext(), request.mExtras);
                LibraryResult libraryResult = mLibrarySessionImpl.getCallback().onGetSearchResult(mLibrarySessionImpl.getInstance(), request.mController, request.mQuery, page, pageSize, params);
                if (libraryResult == null || libraryResult.getResultCode() != RESULT_CODE_SUCCESS) {
                    request.mResult.sendResult(null);
                } else {
                    request.mResult.sendResult(MediaUtils2.truncateListBySize(MediaUtils2.convertToMediaItemList(libraryResult.getMediaItems()), TRANSACTION_SIZE_LIMIT_IN_BYTES));
                }
            }
        }
    });
}
#end_block

#method_before
@Test
public void testOnGetRootCalledByGetLibraryRoot() throws InterruptedException {
    prepareLooper();
    final String testMediaId = "testOnGetRootCalledByGetLibraryRoot";
    final Bundle testExtras = new Bundle();
    testExtras.putString(testMediaId, testMediaId);
    final LibraryParams testParams = new LibraryParams.Builder().setSuggested(true).setExtras(testExtras).build();
    final CountDownLatch latch = new CountDownLatch(1);
    MockMediaBrowserServiceCompat.setMediaBrowserServiceProxy(new Proxy() {

        @Override
        public BrowserRoot onGetRoot(String clientPackageName, int clientUid, Bundle rootHints) {
            assertEquals(CLIENT_PACKAGE_NAME, clientPackageName);
            if (rootHints.keySet().contains(testMediaId)) {
                assertLibraryParamsWithBundle(testParams, rootHints);
                // This should happen because getLibraryRoot() is called with testExtras.
                latch.countDown();
            }
            // For other random connection requests.
            return new BrowserRoot("rootId", null);
        }
    });
    RemoteMediaBrowser2 browser = new RemoteMediaBrowser2(mContext, mToken, true);
    browser.getLibraryRoot(testParams);
    assertTrue(latch.await(WAIT_TIME_MS, TimeUnit.MILLISECONDS));
}
#method_after
@Test
public void testOnGetRootCalledByGetLibraryRoot() throws InterruptedException {
    prepareLooper();
    final String testMediaId = "testOnGetRootCalledByGetLibraryRoot";
    final Bundle testExtras = new Bundle();
    testExtras.putString(testMediaId, testMediaId);
    final LibraryParams testParams = new LibraryParams.Builder().setSuggested(true).setExtras(testExtras).build();
    final CountDownLatch latch = new CountDownLatch(1);
    MockMediaBrowserServiceCompat.setMediaBrowserServiceProxy(new Proxy() {

        @Override
        public BrowserRoot onGetRoot(String clientPackageName, int clientUid, Bundle rootHints) {
            assertEquals(CLIENT_PACKAGE_NAME, clientPackageName);
            if (rootHints.keySet().contains(testMediaId)) {
                assertLibraryParamsWithBundle(testParams, rootHints);
                // This should happen because getLibraryRoot() is called with testExtras.
                latch.countDown();
            }
            // For other random connection requests.
            return new BrowserRoot("rootId", null);
        }
    });
    RemoteMediaBrowser2 browser = new RemoteMediaBrowser2(mContext, mToken, true);
    browser.getLibraryRoot(testParams);
    assertTrue(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
}
#end_block

#method_before
@Test
public void testOnLoadItemCalledByGetItem() throws InterruptedException {
    prepareLooper();
    final String testMediaId = "test_media_item";
    final MediaItem testItem = createMediaItem(testMediaId);
    final CountDownLatch latch = new CountDownLatch(1);
    MockMediaBrowserServiceCompat.setMediaBrowserServiceProxy(new Proxy() {

        @Override
        public void onLoadItem(String itemId, Result<MediaItem> result) {
            assertEquals(testMediaId, itemId);
            result.sendResult(testItem);
            latch.countDown();
        }
    });
    RemoteMediaBrowser2 browser = new RemoteMediaBrowser2(mContext, mToken, true);
    browser.getItem(testMediaId);
    assertTrue(latch.await(WAIT_TIME_MS, TimeUnit.MILLISECONDS));
}
#method_after
@Test
public void testOnLoadItemCalledByGetItem() throws InterruptedException {
    prepareLooper();
    final String testMediaId = "test_media_item";
    final MediaItem testItem = createMediaItem(testMediaId);
    final CountDownLatch latch = new CountDownLatch(1);
    MockMediaBrowserServiceCompat.setMediaBrowserServiceProxy(new Proxy() {

        @Override
        public void onLoadItem(String itemId, Result<MediaItem> result) {
            assertEquals(testMediaId, itemId);
            result.sendResult(testItem);
            latch.countDown();
        }
    });
    RemoteMediaBrowser2 browser = new RemoteMediaBrowser2(mContext, mToken, true);
    browser.getItem(testMediaId);
    assertTrue(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
}
#end_block

#method_before
@Test
public void testOnLoadChildrenWithoutOptionsCalledByGetChildren() throws InterruptedException {
    prepareLooper();
    final String testParentId = "test_media_parent";
    final int testPage = 2;
    final int testPageSize = 4;
    final List<MediaItem> testFullMediaItemList = createMediaItems((testPage + 1) * testPageSize);
    final CountDownLatch latch = new CountDownLatch(1);
    MockMediaBrowserServiceCompat.setMediaBrowserServiceProxy(new Proxy() {

        @Override
        public void onLoadChildren(String parentId, Result<List<MediaItem>> result) {
            assertEquals(testParentId, parentId);
            result.sendResult(testFullMediaItemList);
            latch.countDown();
        }
    });
    RemoteMediaBrowser2 browser = new RemoteMediaBrowser2(mContext, mToken, true);
    browser.getChildren(testParentId, testPage, testPageSize, null);
    assertTrue(latch.await(WAIT_TIME_MS, TimeUnit.MILLISECONDS));
}
#method_after
@Test
public void testOnLoadChildrenWithoutOptionsCalledByGetChildren() throws InterruptedException {
    prepareLooper();
    final String testParentId = "test_media_parent";
    final int testPage = 2;
    final int testPageSize = 4;
    final List<MediaItem> testFullMediaItemList = createMediaItems((testPage + 1) * testPageSize);
    final CountDownLatch latch = new CountDownLatch(1);
    MockMediaBrowserServiceCompat.setMediaBrowserServiceProxy(new Proxy() {

        @Override
        public void onLoadChildren(String parentId, Result<List<MediaItem>> result) {
            assertEquals(testParentId, parentId);
            result.sendResult(testFullMediaItemList);
            latch.countDown();
        }
    });
    RemoteMediaBrowser2 browser = new RemoteMediaBrowser2(mContext, mToken, true);
    browser.getChildren(testParentId, testPage, testPageSize, null);
    assertTrue(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
}
#end_block

#method_before
@Test
public void testOnLoadChildrenWithOptionsCalledByGetChildren() throws InterruptedException {
    prepareLooper();
    final String testParentId = "test_media_parent";
    final int testPage = 2;
    final int testPageSize = 4;
    final List<MediaItem> testMediaItemList = createMediaItems(testPageSize);
    final CountDownLatch latch = new CountDownLatch(1);
    MockMediaBrowserServiceCompat.setMediaBrowserServiceProxy(new Proxy() {

        @Override
        public void onLoadChildren(String parentId, Result<List<MediaItem>> result) {
            fail("This isn't expected to be called");
        }

        @Override
        public void onLoadChildren(String parentId, Result<List<MediaItem>> result, Bundle options) {
            assertEquals(testParentId, parentId);
            assertEquals(testPage, options.getInt(MediaBrowserCompat.EXTRA_PAGE));
            assertEquals(testPageSize, options.getInt(MediaBrowserCompat.EXTRA_PAGE_SIZE));
            assertEquals(2, options.keySet().size());
            result.sendResult(testMediaItemList);
            latch.countDown();
        }
    });
    RemoteMediaBrowser2 browser = new RemoteMediaBrowser2(mContext, mToken, true);
    browser.getChildren(testParentId, testPage, testPageSize, null);
    assertTrue(latch.await(WAIT_TIME_MS, TimeUnit.MILLISECONDS));
}
#method_after
@Test
public void testOnLoadChildrenWithOptionsCalledByGetChildren() throws InterruptedException {
    prepareLooper();
    final String testParentId = "test_media_parent";
    final int testPage = 2;
    final int testPageSize = 4;
    final List<MediaItem> testMediaItemList = createMediaItems(testPageSize);
    final CountDownLatch latch = new CountDownLatch(1);
    MockMediaBrowserServiceCompat.setMediaBrowserServiceProxy(new Proxy() {

        @Override
        public void onLoadChildren(String parentId, Result<List<MediaItem>> result) {
            fail("This isn't expected to be called");
        }

        @Override
        public void onLoadChildren(String parentId, Result<List<MediaItem>> result, Bundle options) {
            assertEquals(testParentId, parentId);
            assertEquals(testPage, options.getInt(MediaBrowserCompat.EXTRA_PAGE));
            assertEquals(testPageSize, options.getInt(MediaBrowserCompat.EXTRA_PAGE_SIZE));
            assertEquals(2, options.keySet().size());
            result.sendResult(testMediaItemList);
            latch.countDown();
        }
    });
    RemoteMediaBrowser2 browser = new RemoteMediaBrowser2(mContext, mToken, true);
    browser.getChildren(testParentId, testPage, testPageSize, null);
    assertTrue(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
}
#end_block

#method_before
@Test
public void testOnLoadChildrenCalledBySubscribe() throws InterruptedException {
    prepareLooper();
    final String testParentId = "testOnLoadChildrenCalledBySubscribe";
    final LibraryParams testParams = createLibraryParams();
    final CountDownLatch subscribeLatch = new CountDownLatch(1);
    MockMediaBrowserServiceCompat.setMediaBrowserServiceProxy(new Proxy() {

        @Override
        public void onLoadChildren(String parentId, Result<List<MediaItem>> result, Bundle option) {
            assertEquals(testParentId, parentId);
            assertLibraryParamsWithBundle(testParams, option);
            result.sendResult(null);
            subscribeLatch.countDown();
        }
    });
    RemoteMediaBrowser2 browser = new RemoteMediaBrowser2(mContext, mToken, true);
    browser.subscribe(testParentId, testParams);
    assertTrue(subscribeLatch.await(WAIT_TIME_MS, TimeUnit.MILLISECONDS));
}
#method_after
@Test
public void testOnLoadChildrenCalledBySubscribe() throws InterruptedException {
    prepareLooper();
    final String testParentId = "testOnLoadChildrenCalledBySubscribe";
    final LibraryParams testParams = createLibraryParams();
    final CountDownLatch subscribeLatch = new CountDownLatch(1);
    MockMediaBrowserServiceCompat.setMediaBrowserServiceProxy(new Proxy() {

        @Override
        public void onLoadChildren(String parentId, Result<List<MediaItem>> result, Bundle option) {
            assertEquals(testParentId, parentId);
            assertLibraryParamsWithBundle(testParams, option);
            result.sendResult(null);
            subscribeLatch.countDown();
        }
    });
    RemoteMediaBrowser2 browser = new RemoteMediaBrowser2(mContext, mToken, true);
    browser.subscribe(testParentId, testParams);
    assertTrue(subscribeLatch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
}
#end_block

#method_before
@Test
public void testOnSearchCalledBySearch() throws InterruptedException {
    prepareLooper();
    final String testQuery = "search_query";
    final int testPage = 2;
    final int testPageSize = 4;
    final LibraryParams testParams = createLibraryParams();
    final List<MediaItem> testFullSearchResult = createMediaItems((testPage + 1) * testPageSize + 3);
    final CountDownLatch latch = new CountDownLatch(1);
    MockMediaBrowserServiceCompat.setMediaBrowserServiceProxy(new Proxy() {

        @Override
        public void onSearch(String query, Bundle extras, Result<List<MediaItem>> result) {
            assertEquals(testQuery, query);
            assertLibraryParamsWithBundle(testParams, extras);
            result.sendResult(testFullSearchResult);
            latch.countDown();
        }
    });
    RemoteMediaBrowser2 browser = new RemoteMediaBrowser2(mContext, mToken, true);
    browser.search(testQuery, testParams);
    assertTrue(latch.await(WAIT_TIME_MS, TimeUnit.MILLISECONDS));
}
#method_after
@Test
public void testOnSearchCalledBySearch() throws InterruptedException {
    prepareLooper();
    final String testQuery = "search_query";
    final int testPage = 2;
    final int testPageSize = 4;
    final LibraryParams testParams = createLibraryParams();
    final List<MediaItem> testFullSearchResult = createMediaItems((testPage + 1) * testPageSize + 3);
    final CountDownLatch latch = new CountDownLatch(1);
    MockMediaBrowserServiceCompat.setMediaBrowserServiceProxy(new Proxy() {

        @Override
        public void onSearch(String query, Bundle extras, Result<List<MediaItem>> result) {
            assertEquals(testQuery, query);
            assertLibraryParamsWithBundle(testParams, extras);
            result.sendResult(testFullSearchResult);
            latch.countDown();
        }
    });
    RemoteMediaBrowser2 browser = new RemoteMediaBrowser2(mContext, mToken, true);
    browser.search(testQuery, testParams);
    assertTrue(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
}
#end_block

#method_before
@Test
public void testOnSearchCalledByGetSearchResult() throws InterruptedException {
    prepareLooper();
    final String testQuery = "search_query";
    final int testPage = 2;
    final int testPageSize = 4;
    final LibraryParams testParams = createLibraryParams();
    final CountDownLatch latch = new CountDownLatch(1);
    MockMediaBrowserServiceCompat.setMediaBrowserServiceProxy(new Proxy() {

        @Override
        public void onSearch(String query, Bundle extras, Result<List<MediaItem>> result) {
            assertEquals(testQuery, query);
            assertLibraryParamsWithBundle(testParams, extras);
            assertEquals(testPage, extras.getInt(MediaBrowserCompat.EXTRA_PAGE));
            assertEquals(testPageSize, extras.getInt(MediaBrowserCompat.EXTRA_PAGE_SIZE));
            result.sendResult(null);
            latch.countDown();
        }
    });
    RemoteMediaBrowser2 browser = new RemoteMediaBrowser2(mContext, mToken, true);
    browser.getSearchResult(testQuery, testPage, testPageSize, testParams);
    assertTrue(latch.await(WAIT_TIME_MS, TimeUnit.MILLISECONDS));
}
#method_after
@Test
public void testOnSearchCalledByGetSearchResult() throws InterruptedException {
    prepareLooper();
    final String testQuery = "search_query";
    final int testPage = 2;
    final int testPageSize = 4;
    final LibraryParams testParams = createLibraryParams();
    final CountDownLatch latch = new CountDownLatch(1);
    MockMediaBrowserServiceCompat.setMediaBrowserServiceProxy(new Proxy() {

        @Override
        public void onSearch(String query, Bundle extras, Result<List<MediaItem>> result) {
            assertEquals(testQuery, query);
            assertLibraryParamsWithBundle(testParams, extras);
            assertEquals(testPage, extras.getInt(MediaBrowserCompat.EXTRA_PAGE));
            assertEquals(testPageSize, extras.getInt(MediaBrowserCompat.EXTRA_PAGE_SIZE));
            result.sendResult(null);
            latch.countDown();
        }
    });
    RemoteMediaBrowser2 browser = new RemoteMediaBrowser2(mContext, mToken, true);
    browser.getSearchResult(testQuery, testPage, testPageSize, testParams);
    assertTrue(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
}
#end_block

#method_before
@SuppressWarnings("WeakerAccess")
static /* synthetic access */
void sendLibraryResult(@NonNull ControllerInfo controller, int seq, @NonNull LibraryResult result) {
    try {
        controller.getControllerCb().onLibraryResult(seq, result);
    } catch (RemoteException e) {
        Log.w(TAG, "Exception in " + controller.toString(), e);
    }
}
#method_after
@SuppressWarnings("WeakerAccess")
static /* synthetic access */
void sendLibraryResult(@NonNull ControllerInfo controller, int seq, int resultCode) {
    sendLibraryResult(controller, seq, new LibraryResult(resultCode));
}
#end_block

#method_before
void connect(final IMediaController2 caller, final String callingPackage, final int pid, final int uid) {
    MediaSessionManager.RemoteUserInfo remoteUserInfo = new MediaSessionManager.RemoteUserInfo(callingPackage, pid, uid);
    final ControllerInfo controllerInfo = new ControllerInfo(remoteUserInfo, mSessionManager.isTrustedForMediaControl(remoteUserInfo), new Controller2Cb(caller));
    mSessionImpl.getCallbackExecutor().execute(new Runnable() {

        @Override
        public void run() {
            if (mSessionImpl.isClosed()) {
                return;
            }
            final IBinder callbackBinder = ((Controller2Cb) controllerInfo.getControllerCb()).getCallbackBinder();
            synchronized (mLock) {
                // Keep connecting controllers.
                // This helps sessions to call APIs in the onConnect()
                // (e.g. setCustomLayout()) instead of pending them.
                mConnectingControllers.add(callbackBinder);
            }
            SessionCommandGroup2 allowedCommands = mSessionImpl.getCallback().onConnect(mSessionImpl.getInstance(), controllerInfo);
            // Don't reject connection for the request from trusted app.
            // Otherwise server will fail to retrieve session's information to dispatch
            // media keys to.
            boolean accept = allowedCommands != null || controllerInfo.isTrusted();
            if (accept) {
                if (DEBUG) {
                    Log.d(TAG, "Accepting connection, controllerInfo=" + controllerInfo + " allowedCommands=" + allowedCommands);
                }
                if (allowedCommands == null) {
                    // For trusted apps, send non-null allowed commands to keep
                    // connection.
                    allowedCommands = new SessionCommandGroup2();
                }
                synchronized (mLock) {
                    mConnectingControllers.remove(callbackBinder);
                    mConnectedControllersManager.addController(callbackBinder, controllerInfo, allowedCommands);
                }
                // If connection is accepted, notify the current state to the controller.
                // It's needed because we cannot call synchronous calls between
                // session/controller.
                // Note: We're doing this after the onConnectionChanged(), but there's no
                // guarantee that events here are notified after the onConnected()
                // because IMediaController2 is oneway (i.e. async call) and Stub will
                // use thread poll for incoming calls.
                final int playerState = mSessionImpl.getPlayerState();
                final ParcelImpl currentItem = (ParcelImpl) ParcelUtils.toParcelable(mSessionImpl.getCurrentMediaItem());
                final long positionEventTimeMs = SystemClock.elapsedRealtime();
                final long positionMs = mSessionImpl.getCurrentPosition();
                final float playbackSpeed = mSessionImpl.getPlaybackSpeed();
                final long bufferedPositionMs = mSessionImpl.getBufferedPosition();
                final ParcelImpl playbackInfo = (ParcelImpl) ParcelUtils.toParcelable(mSessionImpl.getPlaybackInfo());
                final int repeatMode = mSessionImpl.getRepeatMode();
                final int shuffleMode = mSessionImpl.getShuffleMode();
                final PendingIntent sessionActivity = mSessionImpl.getSessionActivity();
                final List<MediaItem2> playlist = allowedCommands.hasCommand(SessionCommand2.COMMAND_CODE_PLAYER_GET_PLAYLIST) ? mSessionImpl.getPlaylist() : null;
                final List<ParcelImpl> playlistParcel = MediaUtils2.convertMediaItem2ListToParcelImplList(playlist);
                // another thread.
                if (mSessionImpl.isClosed()) {
                    return;
                }
                try {
                    caller.onConnected(MediaSession2Stub.this, (ParcelImpl) ParcelUtils.toParcelable(allowedCommands), playerState, currentItem, positionEventTimeMs, positionMs, playbackSpeed, bufferedPositionMs, playbackInfo, repeatMode, shuffleMode, playlistParcel, sessionActivity);
                } catch (RemoteException e) {
                // Controller may be died prematurely.
                }
            } else {
                synchronized (mLock) {
                    mConnectingControllers.remove(callbackBinder);
                }
                if (DEBUG) {
                    Log.d(TAG, "Rejecting connection, controllerInfo=" + controllerInfo);
                }
                try {
                    caller.onDisconnected();
                } catch (RemoteException e) {
                // Controller may be died prematurely.
                // Not an issue because we'll ignore it anyway.
                }
            }
        }
    });
}
#method_after
void connect(final IMediaController2 caller, final String callingPackage, final int pid, final int uid) {
    MediaSessionManager.RemoteUserInfo remoteUserInfo = new MediaSessionManager.RemoteUserInfo(callingPackage, pid, uid);
    final ControllerInfo controllerInfo = new ControllerInfo(remoteUserInfo, mSessionManager.isTrustedForMediaControl(remoteUserInfo), new Controller2Cb(caller));
    mSessionImpl.getCallbackExecutor().execute(new Runnable() {

        @Override
        public void run() {
            if (mSessionImpl.isClosed()) {
                return;
            }
            final IBinder callbackBinder = ((Controller2Cb) controllerInfo.getControllerCb()).getCallbackBinder();
            synchronized (mLock) {
                // Keep connecting controllers.
                // This helps sessions to call APIs in the onConnect()
                // (e.g. setCustomLayout()) instead of pending them.
                mConnectingControllers.add(callbackBinder);
            }
            SessionCommandGroup2 allowedCommands = mSessionImpl.getCallback().onConnect(mSessionImpl.getInstance(), controllerInfo);
            // Don't reject connection for the request from trusted app.
            // Otherwise server will fail to retrieve session's information to dispatch
            // media keys to.
            boolean accept = allowedCommands != null || controllerInfo.isTrusted();
            if (accept) {
                if (DEBUG) {
                    Log.d(TAG, "Accepting connection, controllerInfo=" + controllerInfo + " allowedCommands=" + allowedCommands);
                }
                if (allowedCommands == null) {
                    // For trusted apps, send non-null allowed commands to keep
                    // connection.
                    allowedCommands = new SessionCommandGroup2();
                }
                synchronized (mLock) {
                    mConnectingControllers.remove(callbackBinder);
                    mConnectedControllersManager.addController(callbackBinder, controllerInfo, allowedCommands);
                }
                // If connection is accepted, notify the current state to the controller.
                // It's needed because we cannot call synchronous calls between
                // session/controller.
                // Note: We're doing this after the onConnectionChanged(), but there's no
                // guarantee that events here are notified after the onConnected()
                // because IMediaController2 is oneway (i.e. async call) and Stub will
                // use thread poll for incoming calls.
                final int playerState = mSessionImpl.getPlayerState();
                final ParcelImpl currentItem = (ParcelImpl) ParcelUtils.toParcelable(mSessionImpl.getCurrentMediaItem());
                final long positionEventTimeMs = SystemClock.elapsedRealtime();
                final long positionMs = mSessionImpl.getCurrentPosition();
                final float playbackSpeed = mSessionImpl.getPlaybackSpeed();
                final long bufferedPositionMs = mSessionImpl.getBufferedPosition();
                final ParcelImpl playbackInfo = (ParcelImpl) ParcelUtils.toParcelable(mSessionImpl.getPlaybackInfo());
                final int repeatMode = mSessionImpl.getRepeatMode();
                final int shuffleMode = mSessionImpl.getShuffleMode();
                final PendingIntent sessionActivity = mSessionImpl.getSessionActivity();
                final List<MediaItem2> playlist = allowedCommands.hasCommand(SessionCommand2.COMMAND_CODE_PLAYER_GET_PLAYLIST) ? mSessionImpl.getPlaylist() : null;
                final ParcelImplListSlice playlistSlice = MediaUtils2.convertMediaItem2ListToParcelImplListSlice(playlist);
                // another thread.
                if (mSessionImpl.isClosed()) {
                    return;
                }
                try {
                    caller.onConnected(MediaSession2Stub.this, (ParcelImpl) ParcelUtils.toParcelable(allowedCommands), playerState, currentItem, positionEventTimeMs, positionMs, playbackSpeed, bufferedPositionMs, playbackInfo, repeatMode, shuffleMode, playlistSlice, sessionActivity);
                } catch (RemoteException e) {
                // Controller may be died prematurely.
                }
            } else {
                synchronized (mLock) {
                    mConnectingControllers.remove(callbackBinder);
                }
                if (DEBUG) {
                    Log.d(TAG, "Rejecting connection, controllerInfo=" + controllerInfo);
                }
                try {
                    caller.onDisconnected();
                } catch (RemoteException e) {
                // Controller may be died prematurely.
                // Not an issue because we'll ignore it anyway.
                }
            }
        }
    });
}
#end_block

#method_before
@Override
public void setVolumeTo(final IMediaController2 caller, int seq, final int value, final int flags) throws RuntimeException {
    onSessionCommand(caller, seq, SessionCommand2.COMMAND_CODE_VOLUME_SET_VOLUME, new CallbackCommand() {

        @Override
        public int run(ControllerInfo controller) {
            MediaSessionCompat sessionCompat = mSessionImpl.getSessionCompat();
            if (sessionCompat != null) {
                sessionCompat.getController().setVolumeTo(value, flags);
            }
            // TODO: Handle remote player case
            return RESULT_CODE_SUCCESS;
        }
    });
}
#method_after
@Override
public void setVolumeTo(final IMediaController2 caller, int seq, final int value, final int flags) throws RuntimeException {
    dispatchSessionTask(caller, seq, SessionCommand2.COMMAND_CODE_VOLUME_SET_VOLUME, new SessionCallbackTask<Integer>() {

        @Override
        public Integer run(ControllerInfo controller) {
            MediaSessionCompat sessionCompat = mSessionImpl.getSessionCompat();
            if (sessionCompat != null) {
                sessionCompat.getController().setVolumeTo(value, flags);
            }
            // TODO: Handle remote player case
            return RESULT_CODE_SUCCESS;
        }
    });
}
#end_block

#method_before
@Override
public void adjustVolume(IMediaController2 caller, int seq, final int direction, final int flags) throws RuntimeException {
    onSessionCommand(caller, seq, SessionCommand2.COMMAND_CODE_VOLUME_ADJUST_VOLUME, new CallbackCommand() {

        @Override
        public int run(ControllerInfo controller) {
            MediaSessionCompat sessionCompat = mSessionImpl.getSessionCompat();
            if (sessionCompat != null) {
                sessionCompat.getController().adjustVolume(direction, flags);
            }
            // TODO: Handle remote player case
            return RESULT_CODE_SUCCESS;
        }
    });
}
#method_after
@Override
public void adjustVolume(IMediaController2 caller, int seq, final int direction, final int flags) throws RuntimeException {
    dispatchSessionTask(caller, seq, SessionCommand2.COMMAND_CODE_VOLUME_ADJUST_VOLUME, new SessionCallbackTask<Integer>() {

        @Override
        public Integer run(ControllerInfo controller) {
            MediaSessionCompat sessionCompat = mSessionImpl.getSessionCompat();
            if (sessionCompat != null) {
                sessionCompat.getController().adjustVolume(direction, flags);
            }
            // TODO: Handle remote player case
            return RESULT_CODE_SUCCESS;
        }
    });
}
#end_block

#method_before
@Override
public void play(IMediaController2 caller, int seq) throws RuntimeException {
    onSessionCommand(caller, seq, SessionCommand2.COMMAND_CODE_PLAYER_PLAY, new PlayerCommand() {

        @Override
        public ListenableFuture<PlayerResult> run(ControllerInfo controller) {
            return mSessionImpl.play();
        }
    });
}
#method_after
@Override
public void play(IMediaController2 caller, int seq) throws RuntimeException {
    dispatchSessionTask(caller, seq, SessionCommand2.COMMAND_CODE_PLAYER_PLAY, new SessionPlayerTask() {

        @Override
        public ListenableFuture<PlayerResult> run(ControllerInfo controller) {
            return mSessionImpl.play();
        }
    });
}
#end_block

#method_before
@Override
public void pause(IMediaController2 caller, int seq) throws RuntimeException {
    onSessionCommand(caller, seq, SessionCommand2.COMMAND_CODE_PLAYER_PAUSE, new PlayerCommand() {

        @Override
        public ListenableFuture<PlayerResult> run(ControllerInfo controller) {
            return mSessionImpl.pause();
        }
    });
}
#method_after
@Override
public void pause(IMediaController2 caller, int seq) throws RuntimeException {
    dispatchSessionTask(caller, seq, SessionCommand2.COMMAND_CODE_PLAYER_PAUSE, new SessionPlayerTask() {

        @Override
        public ListenableFuture<PlayerResult> run(ControllerInfo controller) {
            return mSessionImpl.pause();
        }
    });
}
#end_block

#method_before
@Override
public void prefetch(IMediaController2 caller, int seq) throws RuntimeException {
    onSessionCommand(caller, seq, SessionCommand2.COMMAND_CODE_PLAYER_PREFETCH, new PlayerCommand() {

        @Override
        public ListenableFuture<PlayerResult> run(ControllerInfo controller) {
            return mSessionImpl.prefetch();
        }
    });
}
#method_after
@Override
public void prefetch(IMediaController2 caller, int seq) throws RuntimeException {
    dispatchSessionTask(caller, seq, SessionCommand2.COMMAND_CODE_PLAYER_PREFETCH, new SessionPlayerTask() {

        @Override
        public ListenableFuture<PlayerResult> run(ControllerInfo controller) {
            return mSessionImpl.prefetch();
        }
    });
}
#end_block

#method_before
@Override
public void fastForward(IMediaController2 caller, int seq) {
    onSessionCommand(caller, seq, SessionCommand2.COMMAND_CODE_SESSION_FAST_FORWARD, new CallbackCommand() {

        @Override
        public int run(ControllerInfo controller) {
            return mSessionImpl.getCallback().onFastForward(mSessionImpl.getInstance(), controller);
        }
    });
}
#method_after
@Override
public void fastForward(IMediaController2 caller, int seq) {
    dispatchSessionTask(caller, seq, SessionCommand2.COMMAND_CODE_SESSION_FAST_FORWARD, new SessionCallbackTask<Integer>() {

        @Override
        public Integer run(ControllerInfo controller) {
            return mSessionImpl.getCallback().onFastForward(mSessionImpl.getInstance(), controller);
        }
    });
}
#end_block

#method_before
@Override
public void rewind(IMediaController2 caller, int seq) {
    onSessionCommand(caller, seq, SessionCommand2.COMMAND_CODE_SESSION_REWIND, new CallbackCommand() {

        @Override
        public int run(ControllerInfo controller) {
            return mSessionImpl.getCallback().onRewind(mSessionImpl.getInstance(), controller);
        }
    });
}
#method_after
@Override
public void rewind(IMediaController2 caller, int seq) {
    dispatchSessionTask(caller, seq, SessionCommand2.COMMAND_CODE_SESSION_REWIND, new SessionCallbackTask<Integer>() {

        @Override
        public Integer run(ControllerInfo controller) {
            return mSessionImpl.getCallback().onRewind(mSessionImpl.getInstance(), controller);
        }
    });
}
#end_block

#method_before
@Override
public void seekTo(IMediaController2 caller, int seq, final long pos) throws RuntimeException {
    onSessionCommand(caller, seq, SessionCommand2.COMMAND_CODE_PLAYER_SEEK_TO, new PlayerCommand() {

        @Override
        public ListenableFuture<PlayerResult> run(ControllerInfo controller) {
            return mSessionImpl.seekTo(pos);
        }
    });
}
#method_after
@Override
public void seekTo(IMediaController2 caller, int seq, final long pos) throws RuntimeException {
    dispatchSessionTask(caller, seq, SessionCommand2.COMMAND_CODE_PLAYER_SEEK_TO, new SessionPlayerTask() {

        @Override
        public ListenableFuture<PlayerResult> run(ControllerInfo controller) {
            return mSessionImpl.seekTo(pos);
        }
    });
}
#end_block

#method_before
@Override
public void prefetchFromUri(final IMediaController2 caller, int seq, final Uri uri, final Bundle extras) {
    onSessionCommand(caller, seq, SessionCommand2.COMMAND_CODE_SESSION_PREFETCH_FROM_URI, new CallbackCommand() {

        @Override
        public int run(ControllerInfo controller) {
            if (uri == null) {
                Log.w(TAG, "prefetchFromUri(): Ignoring null uri from " + controller);
                return RESULT_CODE_BAD_VALUE;
            }
            return mSessionImpl.getCallback().onPrefetchFromUri(mSessionImpl.getInstance(), controller, uri, extras);
        }
    });
}
#method_after
@Override
public void prefetchFromUri(final IMediaController2 caller, int seq, final Uri uri, final Bundle extras) {
    dispatchSessionTask(caller, seq, SessionCommand2.COMMAND_CODE_SESSION_PREFETCH_FROM_URI, new SessionCallbackTask<Integer>() {

        @Override
        public Integer run(ControllerInfo controller) {
            if (uri == null) {
                Log.w(TAG, "prefetchFromUri(): Ignoring null uri from " + controller);
                return RESULT_CODE_BAD_VALUE;
            }
            return mSessionImpl.getCallback().onPrefetchFromUri(mSessionImpl.getInstance(), controller, uri, extras);
        }
    });
}
#end_block

#method_before
@Override
public void prefetchFromSearch(final IMediaController2 caller, int seq, final String query, final Bundle extras) {
    onSessionCommand(caller, seq, SessionCommand2.COMMAND_CODE_SESSION_PREFETCH_FROM_SEARCH, new CallbackCommand() {

        @Override
        public int run(ControllerInfo controller) {
            if (TextUtils.isEmpty(query)) {
                Log.w(TAG, "prefetchFromSearch(): Ignoring empty query from " + controller);
                return RESULT_CODE_BAD_VALUE;
            }
            return mSessionImpl.getCallback().onPrefetchFromSearch(mSessionImpl.getInstance(), controller, query, extras);
        }
    });
}
#method_after
@Override
public void prefetchFromSearch(final IMediaController2 caller, int seq, final String query, final Bundle extras) {
    dispatchSessionTask(caller, seq, SessionCommand2.COMMAND_CODE_SESSION_PREFETCH_FROM_SEARCH, new SessionCallbackTask<Integer>() {

        @Override
        public Integer run(ControllerInfo controller) {
            if (TextUtils.isEmpty(query)) {
                Log.w(TAG, "prefetchFromSearch(): Ignoring empty query from " + controller);
                return RESULT_CODE_BAD_VALUE;
            }
            return mSessionImpl.getCallback().onPrefetchFromSearch(mSessionImpl.getInstance(), controller, query, extras);
        }
    });
}
#end_block

#method_before
@Override
public void prefetchFromMediaId(final IMediaController2 caller, int seq, final String mediaId, final Bundle extras) {
    onSessionCommand(caller, seq, SessionCommand2.COMMAND_CODE_SESSION_PREFETCH_FROM_MEDIA_ID, new CallbackCommand() {

        @Override
        public int run(ControllerInfo controller) {
            if (mediaId == null) {
                Log.w(TAG, "prefetchFromMediaId(): Ignoring null mediaId from " + controller);
                return RESULT_CODE_BAD_VALUE;
            }
            return mSessionImpl.getCallback().onPrefetchFromMediaId(mSessionImpl.getInstance(), controller, mediaId, extras);
        }
    });
}
#method_after
@Override
public void prefetchFromMediaId(final IMediaController2 caller, int seq, final String mediaId, final Bundle extras) {
    dispatchSessionTask(caller, seq, SessionCommand2.COMMAND_CODE_SESSION_PREFETCH_FROM_MEDIA_ID, new SessionCallbackTask<Integer>() {

        @Override
        public Integer run(ControllerInfo controller) {
            if (mediaId == null) {
                Log.w(TAG, "prefetchFromMediaId(): Ignoring null mediaId from " + controller);
                return RESULT_CODE_BAD_VALUE;
            }
            return mSessionImpl.getCallback().onPrefetchFromMediaId(mSessionImpl.getInstance(), controller, mediaId, extras);
        }
    });
}
#end_block

#method_before
@Override
public void playFromUri(final IMediaController2 caller, int seq, final Uri uri, final Bundle extras) {
    onSessionCommand(caller, seq, SessionCommand2.COMMAND_CODE_SESSION_PLAY_FROM_URI, new CallbackCommand() {

        @Override
        public int run(ControllerInfo controller) {
            if (uri == null) {
                Log.w(TAG, "playFromUri(): Ignoring null uri from " + controller);
                return RESULT_CODE_BAD_VALUE;
            }
            return mSessionImpl.getCallback().onPlayFromUri(mSessionImpl.getInstance(), controller, uri, extras);
        }
    });
}
#method_after
@Override
public void playFromUri(final IMediaController2 caller, int seq, final Uri uri, final Bundle extras) {
    dispatchSessionTask(caller, seq, SessionCommand2.COMMAND_CODE_SESSION_PLAY_FROM_URI, new SessionCallbackTask<Integer>() {

        @Override
        public Integer run(ControllerInfo controller) {
            if (uri == null) {
                Log.w(TAG, "playFromUri(): Ignoring null uri from " + controller);
                return RESULT_CODE_BAD_VALUE;
            }
            return mSessionImpl.getCallback().onPlayFromUri(mSessionImpl.getInstance(), controller, uri, extras);
        }
    });
}
#end_block

#method_before
@Override
public void playFromSearch(final IMediaController2 caller, int seq, final String query, final Bundle extras) {
    onSessionCommand(caller, seq, SessionCommand2.COMMAND_CODE_SESSION_PLAY_FROM_SEARCH, new CallbackCommand() {

        @Override
        public int run(ControllerInfo controller) {
            if (TextUtils.isEmpty(query)) {
                Log.w(TAG, "playFromSearch(): Ignoring empty query from " + controller);
                return RESULT_CODE_BAD_VALUE;
            }
            return mSessionImpl.getCallback().onPlayFromSearch(mSessionImpl.getInstance(), controller, query, extras);
        }
    });
}
#method_after
@Override
public void playFromSearch(final IMediaController2 caller, int seq, final String query, final Bundle extras) {
    dispatchSessionTask(caller, seq, SessionCommand2.COMMAND_CODE_SESSION_PLAY_FROM_SEARCH, new SessionCallbackTask<Integer>() {

        @Override
        public Integer run(ControllerInfo controller) {
            if (TextUtils.isEmpty(query)) {
                Log.w(TAG, "playFromSearch(): Ignoring empty query from " + controller);
                return RESULT_CODE_BAD_VALUE;
            }
            return mSessionImpl.getCallback().onPlayFromSearch(mSessionImpl.getInstance(), controller, query, extras);
        }
    });
}
#end_block

#method_before
@Override
public void playFromMediaId(final IMediaController2 caller, int seq, final String mediaId, final Bundle extras) {
    onSessionCommand(caller, seq, SessionCommand2.COMMAND_CODE_SESSION_PLAY_FROM_MEDIA_ID, new CallbackCommand() {

        @Override
        public int run(ControllerInfo controller) {
            if (mediaId == null) {
                Log.w(TAG, "playFromMediaId(): Ignoring null mediaId from " + controller);
                return RESULT_CODE_BAD_VALUE;
            }
            return mSessionImpl.getCallback().onPlayFromMediaId(mSessionImpl.getInstance(), controller, mediaId, extras);
        }
    });
}
#method_after
@Override
public void playFromMediaId(final IMediaController2 caller, int seq, final String mediaId, final Bundle extras) {
    dispatchSessionTask(caller, seq, SessionCommand2.COMMAND_CODE_SESSION_PLAY_FROM_MEDIA_ID, new SessionCallbackTask<Integer>() {

        @Override
        public Integer run(ControllerInfo controller) {
            if (mediaId == null) {
                Log.w(TAG, "playFromMediaId(): Ignoring null mediaId from " + controller);
                return RESULT_CODE_BAD_VALUE;
            }
            return mSessionImpl.getCallback().onPlayFromMediaId(mSessionImpl.getInstance(), controller, mediaId, extras);
        }
    });
}
#end_block

#method_before
@Override
public void setRating(final IMediaController2 caller, int seq, final String mediaId, final ParcelImpl rating) {
    final Rating2 rating2 = ParcelUtils.fromParcelable(rating);
    onSessionCommand(caller, seq, SessionCommand2.COMMAND_CODE_SESSION_SET_RATING, new CallbackCommand() {

        @Override
        public int run(ControllerInfo controller) {
            if (mediaId == null) {
                Log.w(TAG, "setRating(): Ignoring null mediaId from " + controller);
                return RESULT_CODE_BAD_VALUE;
            }
            if (rating2 == null) {
                Log.w(TAG, "setRating(): Ignoring null ratingBundle from " + controller);
                return RESULT_CODE_BAD_VALUE;
            }
            return mSessionImpl.getCallback().onSetRating(mSessionImpl.getInstance(), controller, mediaId, rating2);
        }
    });
}
#method_after
@Override
public void setRating(final IMediaController2 caller, int seq, final String mediaId, final ParcelImpl rating) {
    final Rating2 rating2 = ParcelUtils.fromParcelable(rating);
    dispatchSessionTask(caller, seq, SessionCommand2.COMMAND_CODE_SESSION_SET_RATING, new SessionCallbackTask<Integer>() {

        @Override
        public Integer run(ControllerInfo controller) {
            if (mediaId == null) {
                Log.w(TAG, "setRating(): Ignoring null mediaId from " + controller);
                return RESULT_CODE_BAD_VALUE;
            }
            if (rating2 == null) {
                Log.w(TAG, "setRating(): Ignoring null ratingBundle from " + controller);
                return RESULT_CODE_BAD_VALUE;
            }
            return mSessionImpl.getCallback().onSetRating(mSessionImpl.getInstance(), controller, mediaId, rating2);
        }
    });
}
#end_block

#method_before
@Override
public void setPlaybackSpeed(final IMediaController2 caller, int seq, final float speed) {
    onSessionCommand(caller, seq, SessionCommand2.COMMAND_CODE_PLAYER_SET_SPEED, new PlayerCommand() {

        @Override
        public ListenableFuture<PlayerResult> run(ControllerInfo controller) {
            return mSessionImpl.setPlaybackSpeed(speed);
        }
    });
}
#method_after
@Override
public void setPlaybackSpeed(final IMediaController2 caller, int seq, final float speed) {
    dispatchSessionTask(caller, seq, SessionCommand2.COMMAND_CODE_PLAYER_SET_SPEED, new SessionPlayerTask() {

        @Override
        public ListenableFuture<PlayerResult> run(ControllerInfo controller) {
            return mSessionImpl.setPlaybackSpeed(speed);
        }
    });
}
#end_block

#method_before
@Override
public void setPlaylist(final IMediaController2 caller, int seq, final ParcelImplListSlice listSlice, final Bundle metadata) {
    onSessionCommand(caller, seq, SessionCommand2.COMMAND_CODE_PLAYER_SET_PLAYLIST, new PlayerCommand() {

        @Override
        public ListenableFuture<PlayerResult> run(ControllerInfo controller) {
            if (listSlice == null || listSlice.getList() == null) {
                Log.w(TAG, "setPlaylist(): Ignoring null playlist from " + controller);
                return PlayerResult.createFuture(RESULT_CODE_BAD_VALUE);
            }
            List<ParcelImpl> playlist = listSlice.getList();
            List<MediaItem2> list = new ArrayList<>();
            for (int i = 0; i < playlist.size(); i++) {
                MediaItem2 item = convertMediaItem2OnExecutor(controller, playlist.get(i));
                if (item != null) {
                    list.add(item);
                }
            }
            return mSessionImpl.setPlaylist(list, MediaMetadata2.fromBundle(metadata));
        }
    });
}
#method_after
@Override
public void setPlaylist(final IMediaController2 caller, int seq, final ParcelImplListSlice listSlice, final Bundle metadata) {
    dispatchSessionTask(caller, seq, SessionCommand2.COMMAND_CODE_PLAYER_SET_PLAYLIST, new SessionPlayerTask() {

        @Override
        public ListenableFuture<PlayerResult> run(ControllerInfo controller) {
            if (listSlice == null) {
                Log.w(TAG, "setPlaylist(): Ignoring null playlist from " + controller);
                return PlayerResult.createFuture(RESULT_CODE_BAD_VALUE);
            }
            List<ParcelImpl> playlist = listSlice.getList();
            List<MediaItem2> list = new ArrayList<>();
            for (int i = 0; i < playlist.size(); i++) {
                MediaItem2 item = convertMediaItem2OnExecutor(controller, playlist.get(i));
                if (item != null) {
                    list.add(item);
                }
            }
            return mSessionImpl.setPlaylist(list, MediaMetadata2.fromBundle(metadata));
        }
    });
}
#end_block

#method_before
@Override
public void setMediaItem(final IMediaController2 caller, int seq, final ParcelImpl mediaItem) {
    onSessionCommand(caller, seq, SessionCommand2.COMMAND_CODE_PLAYER_SET_MEDIA_ITEM, new PlayerCommand() {

        @Override
        public ListenableFuture<PlayerResult> run(ControllerInfo controller) {
            if (mediaItem == null) {
                Log.w(TAG, "setMediaItem(): Ignoring null item from " + controller);
                return PlayerResult.createFuture(RESULT_CODE_BAD_VALUE);
            }
            MediaItem2 item = convertMediaItem2OnExecutor(controller, mediaItem);
            if (item == null) {
                return PlayerResult.createFuture(RESULT_CODE_BAD_VALUE);
            }
            return mSessionImpl.setMediaItem(item);
        }
    });
}
#method_after
@Override
public void setMediaItem(final IMediaController2 caller, int seq, final ParcelImpl mediaItem) {
    dispatchSessionTask(caller, seq, SessionCommand2.COMMAND_CODE_PLAYER_SET_MEDIA_ITEM, new SessionPlayerTask() {

        @Override
        public ListenableFuture<PlayerResult> run(ControllerInfo controller) {
            if (mediaItem == null) {
                Log.w(TAG, "setMediaItem(): Ignoring null item from " + controller);
                return PlayerResult.createFuture(RESULT_CODE_BAD_VALUE);
            }
            MediaItem2 item = convertMediaItem2OnExecutor(controller, mediaItem);
            if (item == null) {
                return PlayerResult.createFuture(RESULT_CODE_BAD_VALUE);
            }
            return mSessionImpl.setMediaItem(item);
        }
    });
}
#end_block

#method_before
@Override
public void updatePlaylistMetadata(final IMediaController2 caller, int seq, final Bundle metadata) {
    onSessionCommand(caller, seq, SessionCommand2.COMMAND_CODE_PLAYER_UPDATE_LIST_METADATA, new PlayerCommand() {

        @Override
        public ListenableFuture<PlayerResult> run(ControllerInfo controller) {
            return mSessionImpl.updatePlaylistMetadata(MediaMetadata2.fromBundle(metadata));
        }
    });
}
#method_after
@Override
public void updatePlaylistMetadata(final IMediaController2 caller, int seq, final Bundle metadata) {
    dispatchSessionTask(caller, seq, SessionCommand2.COMMAND_CODE_PLAYER_UPDATE_LIST_METADATA, new SessionPlayerTask() {

        @Override
        public ListenableFuture<PlayerResult> run(ControllerInfo controller) {
            return mSessionImpl.updatePlaylistMetadata(MediaMetadata2.fromBundle(metadata));
        }
    });
}
#end_block

#method_before
@Override
public void addPlaylistItem(IMediaController2 caller, int seq, final int index, final ParcelImpl mediaItem) {
    onSessionCommand(caller, seq, SessionCommand2.COMMAND_CODE_PLAYER_ADD_PLAYLIST_ITEM, new PlayerCommand() {

        @Override
        public ListenableFuture<PlayerResult> run(ControllerInfo controller) {
            if (mediaItem == null) {
                Log.w(TAG, "addPlaylistItem(): Ignoring null item from " + controller);
                return PlayerResult.createFuture(RESULT_CODE_BAD_VALUE);
            }
            MediaItem2 item = convertMediaItem2OnExecutor(controller, mediaItem);
            if (item == null) {
                return PlayerResult.createFuture(RESULT_CODE_BAD_VALUE);
            }
            return mSessionImpl.addPlaylistItem(index, item);
        }
    });
}
#method_after
@Override
public void addPlaylistItem(IMediaController2 caller, int seq, final int index, final ParcelImpl mediaItem) {
    dispatchSessionTask(caller, seq, SessionCommand2.COMMAND_CODE_PLAYER_ADD_PLAYLIST_ITEM, new SessionPlayerTask() {

        @Override
        public ListenableFuture<PlayerResult> run(ControllerInfo controller) {
            if (mediaItem == null) {
                Log.w(TAG, "addPlaylistItem(): Ignoring null item from " + controller);
                return PlayerResult.createFuture(RESULT_CODE_BAD_VALUE);
            }
            MediaItem2 item = convertMediaItem2OnExecutor(controller, mediaItem);
            if (item == null) {
                return PlayerResult.createFuture(RESULT_CODE_BAD_VALUE);
            }
            return mSessionImpl.addPlaylistItem(index, item);
        }
    });
}
#end_block

#method_before
@Override
public void removePlaylistItem(IMediaController2 caller, int seq, final ParcelImpl mediaItem) {
    onSessionCommand(caller, seq, SessionCommand2.COMMAND_CODE_PLAYER_REMOVE_PLAYLIST_ITEM, new PlayerCommand() {

        @Override
        public ListenableFuture<PlayerResult> run(ControllerInfo controller) {
            MediaItem2 item = ParcelUtils.fromParcelable(mediaItem);
            // Note: MediaItem2 has hidden UUID to identify it across the processes.
            return mSessionImpl.removePlaylistItem(item);
        }
    });
}
#method_after
@Override
public void removePlaylistItem(IMediaController2 caller, int seq, final ParcelImpl mediaItem) {
    dispatchSessionTask(caller, seq, SessionCommand2.COMMAND_CODE_PLAYER_REMOVE_PLAYLIST_ITEM, new SessionPlayerTask() {

        @Override
        public ListenableFuture<PlayerResult> run(ControllerInfo controller) {
            MediaItem2 item = ParcelUtils.fromParcelable(mediaItem);
            // Note: MediaItem2 has hidden UUID to identify it across the processes.
            return mSessionImpl.removePlaylistItem(item);
        }
    });
}
#end_block

#method_before
@Override
public void replacePlaylistItem(IMediaController2 caller, int seq, final int index, final ParcelImpl mediaItem) {
    onSessionCommand(caller, seq, SessionCommand2.COMMAND_CODE_PLAYER_REPLACE_PLAYLIST_ITEM, new PlayerCommand() {

        @Override
        public ListenableFuture<PlayerResult> run(ControllerInfo controller) {
            if (mediaItem == null) {
                Log.w(TAG, "replacePlaylistItem(): Ignoring null item from " + controller);
                return PlayerResult.createFuture(RESULT_CODE_BAD_VALUE);
            }
            MediaItem2 item = convertMediaItem2OnExecutor(controller, mediaItem);
            if (item == null) {
                return PlayerResult.createFuture(RESULT_CODE_BAD_VALUE);
            }
            return mSessionImpl.replacePlaylistItem(index, item);
        }
    });
}
#method_after
@Override
public void replacePlaylistItem(IMediaController2 caller, int seq, final int index, final ParcelImpl mediaItem) {
    dispatchSessionTask(caller, seq, SessionCommand2.COMMAND_CODE_PLAYER_REPLACE_PLAYLIST_ITEM, new SessionPlayerTask() {

        @Override
        public ListenableFuture<PlayerResult> run(ControllerInfo controller) {
            if (mediaItem == null) {
                Log.w(TAG, "replacePlaylistItem(): Ignoring null item from " + controller);
                return PlayerResult.createFuture(RESULT_CODE_BAD_VALUE);
            }
            MediaItem2 item = convertMediaItem2OnExecutor(controller, mediaItem);
            if (item == null) {
                return PlayerResult.createFuture(RESULT_CODE_BAD_VALUE);
            }
            return mSessionImpl.replacePlaylistItem(index, item);
        }
    });
}
#end_block

#method_before
@Override
public void skipToPlaylistItem(IMediaController2 caller, int seq, final ParcelImpl mediaItem) {
    onSessionCommand(caller, seq, SessionCommand2.COMMAND_CODE_PLAYER_SKIP_TO_PLAYLIST_ITEM, new PlayerCommand() {

        @Override
        public ListenableFuture<PlayerResult> run(ControllerInfo controller) {
            if (mediaItem == null) {
                Log.w(TAG, "skipToPlaylistItem(): Ignoring null mediaItem from " + controller);
                return PlayerResult.createFuture(RESULT_CODE_BAD_VALUE);
            }
            // Note: MediaItem2 has hidden UUID to identify it across the processes.
            return mSessionImpl.skipToPlaylistItem((MediaItem2) ParcelUtils.fromParcelable(mediaItem));
        }
    });
}
#method_after
@Override
public void skipToPlaylistItem(IMediaController2 caller, int seq, final ParcelImpl mediaItem) {
    dispatchSessionTask(caller, seq, SessionCommand2.COMMAND_CODE_PLAYER_SKIP_TO_PLAYLIST_ITEM, new SessionPlayerTask() {

        @Override
        public ListenableFuture<PlayerResult> run(ControllerInfo controller) {
            if (mediaItem == null) {
                Log.w(TAG, "skipToPlaylistItem(): Ignoring null mediaItem from " + controller);
                return PlayerResult.createFuture(RESULT_CODE_BAD_VALUE);
            }
            // Note: MediaItem2 has hidden UUID to identify it across the processes.
            return mSessionImpl.skipToPlaylistItem((MediaItem2) ParcelUtils.fromParcelable(mediaItem));
        }
    });
}
#end_block

#method_before
@Override
public void skipToPreviousItem(IMediaController2 caller, int seq) {
    onSessionCommand(caller, seq, SessionCommand2.COMMAND_CODE_PLAYER_SKIP_TO_PREVIOUS_PLAYLIST_ITEM, new PlayerCommand() {

        @Override
        public ListenableFuture<PlayerResult> run(ControllerInfo controller) {
            return mSessionImpl.skipToPreviousItem();
        }
    });
}
#method_after
@Override
public void skipToPreviousItem(IMediaController2 caller, int seq) {
    dispatchSessionTask(caller, seq, SessionCommand2.COMMAND_CODE_PLAYER_SKIP_TO_PREVIOUS_PLAYLIST_ITEM, new SessionPlayerTask() {

        @Override
        public ListenableFuture<PlayerResult> run(ControllerInfo controller) {
            return mSessionImpl.skipToPreviousItem();
        }
    });
}
#end_block

#method_before
@Override
public void skipToNextItem(IMediaController2 caller, int seq) {
    onSessionCommand(caller, seq, SessionCommand2.COMMAND_CODE_PLAYER_SKIP_TO_NEXT_PLAYLIST_ITEM, new PlayerCommand() {

        @Override
        public ListenableFuture<PlayerResult> run(ControllerInfo controller) {
            return mSessionImpl.skipToNextItem();
        }
    });
}
#method_after
@Override
public void skipToNextItem(IMediaController2 caller, int seq) {
    dispatchSessionTask(caller, seq, SessionCommand2.COMMAND_CODE_PLAYER_SKIP_TO_NEXT_PLAYLIST_ITEM, new SessionPlayerTask() {

        @Override
        public ListenableFuture<PlayerResult> run(ControllerInfo controller) {
            return mSessionImpl.skipToNextItem();
        }
    });
}
#end_block

#method_before
@Override
public void setRepeatMode(IMediaController2 caller, int seq, final int repeatMode) {
    onSessionCommand(caller, seq, SessionCommand2.COMMAND_CODE_PLAYER_SET_REPEAT_MODE, new PlayerCommand() {

        @Override
        public ListenableFuture<PlayerResult> run(ControllerInfo controller) {
            return mSessionImpl.setRepeatMode(repeatMode);
        }
    });
}
#method_after
@Override
public void setRepeatMode(IMediaController2 caller, int seq, final int repeatMode) {
    dispatchSessionTask(caller, seq, SessionCommand2.COMMAND_CODE_PLAYER_SET_REPEAT_MODE, new SessionPlayerTask() {

        @Override
        public ListenableFuture<PlayerResult> run(ControllerInfo controller) {
            return mSessionImpl.setRepeatMode(repeatMode);
        }
    });
}
#end_block

#method_before
@Override
public void setShuffleMode(IMediaController2 caller, int seq, final int shuffleMode) {
    onSessionCommand(caller, seq, SessionCommand2.COMMAND_CODE_PLAYER_SET_SHUFFLE_MODE, new PlayerCommand() {

        @Override
        public ListenableFuture<PlayerResult> run(ControllerInfo controller) {
            return mSessionImpl.setShuffleMode(shuffleMode);
        }
    });
}
#method_after
@Override
public void setShuffleMode(IMediaController2 caller, int seq, final int shuffleMode) {
    dispatchSessionTask(caller, seq, SessionCommand2.COMMAND_CODE_PLAYER_SET_SHUFFLE_MODE, new SessionPlayerTask() {

        @Override
        public ListenableFuture<PlayerResult> run(ControllerInfo controller) {
            return mSessionImpl.setShuffleMode(shuffleMode);
        }
    });
}
#end_block

#method_before
@Override
public void subscribeRoutesInfo(IMediaController2 caller, int seq) {
    onSessionCommand(caller, seq, SessionCommand2.COMMAND_CODE_SESSION_SUBSCRIBE_ROUTES_INFO, new CallbackCommand() {

        @Override
        public int run(ControllerInfo controller) {
            return mSessionImpl.getCallback().onSubscribeRoutesInfo(mSessionImpl.getInstance(), controller);
        }
    });
}
#method_after
@Override
public void subscribeRoutesInfo(IMediaController2 caller, int seq) {
    dispatchSessionTask(caller, seq, SessionCommand2.COMMAND_CODE_SESSION_SUBSCRIBE_ROUTES_INFO, new SessionCallbackTask<Integer>() {

        @Override
        public Integer run(ControllerInfo controller) {
            return mSessionImpl.getCallback().onSubscribeRoutesInfo(mSessionImpl.getInstance(), controller);
        }
    });
}
#end_block

#method_before
@Override
public void unsubscribeRoutesInfo(IMediaController2 caller, int seq) {
    onSessionCommand(caller, seq, SessionCommand2.COMMAND_CODE_SESSION_UNSUBSCRIBE_ROUTES_INFO, new CallbackCommand() {

        @Override
        public int run(ControllerInfo controller) {
            return mSessionImpl.getCallback().onUnsubscribeRoutesInfo(mSessionImpl.getInstance(), controller);
        }
    });
}
#method_after
@Override
public void unsubscribeRoutesInfo(IMediaController2 caller, int seq) {
    dispatchSessionTask(caller, seq, SessionCommand2.COMMAND_CODE_SESSION_UNSUBSCRIBE_ROUTES_INFO, new SessionCallbackTask<Integer>() {

        @Override
        public Integer run(ControllerInfo controller) {
            return mSessionImpl.getCallback().onUnsubscribeRoutesInfo(mSessionImpl.getInstance(), controller);
        }
    });
}
#end_block

#method_before
@Override
public void selectRoute(IMediaController2 caller, int seq, final Bundle route) {
    if (MediaUtils2.isUnparcelableBundle(route)) {
        throw new RuntimeException("Unexpected route bundle: " + route);
    }
    onSessionCommand(caller, seq, SessionCommand2.COMMAND_CODE_SESSION_UNSUBSCRIBE_ROUTES_INFO, new CallbackCommand() {

        @Override
        public int run(ControllerInfo controller) {
            return mSessionImpl.getCallback().onSelectRoute(mSessionImpl.getInstance(), controller, route);
        }
    });
}
#method_after
@Override
public void selectRoute(IMediaController2 caller, int seq, final Bundle route) {
    if (MediaUtils2.isUnparcelableBundle(route)) {
        throw new RuntimeException("Unexpected route bundle: " + route);
    }
    dispatchSessionTask(caller, seq, SessionCommand2.COMMAND_CODE_SESSION_UNSUBSCRIBE_ROUTES_INFO, new SessionCallbackTask<Integer>() {

        @Override
        public Integer run(ControllerInfo controller) {
            return mSessionImpl.getCallback().onSelectRoute(mSessionImpl.getInstance(), controller, route);
        }
    });
}
#end_block

#method_before
@Override
public void getLibraryRoot(final IMediaController2 caller, int seq, final ParcelImpl libraryParams) throws RuntimeException {
    onLibraryCommand(caller, seq, SessionCommand2.COMMAND_CODE_LIBRARY_GET_LIBRARY_ROOT, new LibraryCallbackCommand() {

        @Override
        public LibraryResult run(ControllerInfo controller) {
            return getLibrarySession().onGetLibraryRootOnExecutor(controller, (LibraryParams) ParcelUtils.fromParcelable(libraryParams));
        }
    });
}
#method_after
@Override
public void getLibraryRoot(final IMediaController2 caller, int seq, final ParcelImpl libraryParams) throws RuntimeException {
    dispatchLibrarySessionTask(caller, seq, SessionCommand2.COMMAND_CODE_LIBRARY_GET_LIBRARY_ROOT, new LibrarySessionCallbackTask<LibraryResult>() {

        @Override
        public LibraryResult run(ControllerInfo controller) {
            return getLibrarySession().onGetLibraryRootOnExecutor(controller, (LibraryParams) ParcelUtils.fromParcelable(libraryParams));
        }
    });
}
#end_block

#method_before
@Override
public void getItem(final IMediaController2 caller, int seq, final String mediaId) throws RuntimeException {
    onLibraryCommand(caller, seq, SessionCommand2.COMMAND_CODE_LIBRARY_GET_ITEM, new LibraryCallbackCommand() {

        @Override
        public LibraryResult run(ControllerInfo controller) {
            if (mediaId == null) {
                Log.w(TAG, "getItem(): Ignoring null mediaId from " + controller);
                return new LibraryResult(RESULT_CODE_BAD_VALUE);
            }
            return getLibrarySession().onGetItemOnExecutor(controller, mediaId);
        }
    });
}
#method_after
@Override
public void getItem(final IMediaController2 caller, int seq, final String mediaId) throws RuntimeException {
    dispatchLibrarySessionTask(caller, seq, SessionCommand2.COMMAND_CODE_LIBRARY_GET_ITEM, new LibrarySessionCallbackTask<LibraryResult>() {

        @Override
        public LibraryResult run(ControllerInfo controller) {
            if (mediaId == null) {
                Log.w(TAG, "getItem(): Ignoring null mediaId from " + controller);
                return new LibraryResult(RESULT_CODE_BAD_VALUE);
            }
            return getLibrarySession().onGetItemOnExecutor(controller, mediaId);
        }
    });
}
#end_block

#method_before
@Override
public void getChildren(final IMediaController2 caller, int seq, final String parentId, final int page, final int pageSize, final ParcelImpl libraryParams) throws RuntimeException {
    onLibraryCommand(caller, seq, SessionCommand2.COMMAND_CODE_LIBRARY_GET_CHILDREN, new LibraryCallbackCommand() {

        @Override
        public LibraryResult run(ControllerInfo controller) {
            if (parentId == null) {
                Log.w(TAG, "getChildren(): Ignoring null parentId from " + controller);
                return new LibraryResult(LibraryResult.RESULT_CODE_BAD_VALUE);
            }
            if (page < 0) {
                Log.w(TAG, "getChildren(): Ignoring negative page from " + controller);
                return new LibraryResult(LibraryResult.RESULT_CODE_BAD_VALUE);
            }
            if (pageSize < 1) {
                Log.w(TAG, "getChildren(): Ignoring pageSize less than 1 from " + controller);
                return new LibraryResult(LibraryResult.RESULT_CODE_BAD_VALUE);
            }
            return getLibrarySession().onGetChildrenOnExecutor(controller, parentId, page, pageSize, (LibraryParams) ParcelUtils.fromParcelable(libraryParams));
        }
    });
}
#method_after
@Override
public void getChildren(final IMediaController2 caller, int seq, final String parentId, final int page, final int pageSize, final ParcelImpl libraryParams) throws RuntimeException {
    dispatchLibrarySessionTask(caller, seq, SessionCommand2.COMMAND_CODE_LIBRARY_GET_CHILDREN, new LibrarySessionCallbackTask<LibraryResult>() {

        @Override
        public LibraryResult run(ControllerInfo controller) {
            if (parentId == null) {
                Log.w(TAG, "getChildren(): Ignoring null parentId from " + controller);
                return new LibraryResult(LibraryResult.RESULT_CODE_BAD_VALUE);
            }
            if (page < 0) {
                Log.w(TAG, "getChildren(): Ignoring negative page from " + controller);
                return new LibraryResult(LibraryResult.RESULT_CODE_BAD_VALUE);
            }
            if (pageSize < 1) {
                Log.w(TAG, "getChildren(): Ignoring pageSize less than 1 from " + controller);
                return new LibraryResult(LibraryResult.RESULT_CODE_BAD_VALUE);
            }
            return getLibrarySession().onGetChildrenOnExecutor(controller, parentId, page, pageSize, (LibraryParams) ParcelUtils.fromParcelable(libraryParams));
        }
    });
}
#end_block

#method_before
@Override
public void search(IMediaController2 caller, int seq, final String query, final ParcelImpl libraryParams) {
    onLibraryCommand(caller, seq, SessionCommand2.COMMAND_CODE_LIBRARY_SEARCH, new LibraryCallbackCommand() {

        @Override
        public int runReturnsCode(ControllerInfo controller) {
            if (TextUtils.isEmpty(query)) {
                Log.w(TAG, "search(): Ignoring empty query from " + controller);
                return LibraryResult.RESULT_CODE_BAD_VALUE;
            }
            return getLibrarySession().onSearchOnExecutor(controller, query, (LibraryParams) ParcelUtils.fromParcelable(libraryParams));
        }
    });
}
#method_after
@Override
public void search(IMediaController2 caller, int seq, final String query, final ParcelImpl libraryParams) {
    dispatchLibrarySessionTask(caller, seq, SessionCommand2.COMMAND_CODE_LIBRARY_SEARCH, new LibrarySessionCallbackTask<Integer>() {

        @Override
        public Integer run(ControllerInfo controller) {
            if (TextUtils.isEmpty(query)) {
                Log.w(TAG, "search(): Ignoring empty query from " + controller);
                return LibraryResult.RESULT_CODE_BAD_VALUE;
            }
            return getLibrarySession().onSearchOnExecutor(controller, query, (LibraryParams) ParcelUtils.fromParcelable(libraryParams));
        }
    });
}
#end_block

#method_before
@Override
public void getSearchResult(final IMediaController2 caller, int seq, final String query, final int page, final int pageSize, final ParcelImpl libraryParams) {
    onLibraryCommand(caller, seq, SessionCommand2.COMMAND_CODE_LIBRARY_GET_SEARCH_RESULT, new LibraryCallbackCommand() {

        @Override
        public LibraryResult run(ControllerInfo controller) {
            if (TextUtils.isEmpty(query)) {
                Log.w(TAG, "getSearchResult(): Ignoring empty query from " + controller);
                return new LibraryResult(LibraryResult.RESULT_CODE_BAD_VALUE);
            }
            if (page < 0) {
                Log.w(TAG, "getSearchResult(): Ignoring negative page from " + controller);
                return new LibraryResult(LibraryResult.RESULT_CODE_BAD_VALUE);
            }
            if (pageSize < 1) {
                Log.w(TAG, "getSearchResult(): Ignoring pageSize less than 1 from " + controller);
                return new LibraryResult(LibraryResult.RESULT_CODE_BAD_VALUE);
            }
            return getLibrarySession().onGetSearchResultOnExecutor(controller, query, page, pageSize, (LibraryParams) ParcelUtils.fromParcelable(libraryParams));
        }
    });
}
#method_after
@Override
public void getSearchResult(final IMediaController2 caller, int seq, final String query, final int page, final int pageSize, final ParcelImpl libraryParams) {
    dispatchLibrarySessionTask(caller, seq, SessionCommand2.COMMAND_CODE_LIBRARY_GET_SEARCH_RESULT, new LibrarySessionCallbackTask<LibraryResult>() {

        @Override
        public LibraryResult run(ControllerInfo controller) {
            if (TextUtils.isEmpty(query)) {
                Log.w(TAG, "getSearchResult(): Ignoring empty query from " + controller);
                return new LibraryResult(LibraryResult.RESULT_CODE_BAD_VALUE);
            }
            if (page < 0) {
                Log.w(TAG, "getSearchResult(): Ignoring negative page from " + controller);
                return new LibraryResult(LibraryResult.RESULT_CODE_BAD_VALUE);
            }
            if (pageSize < 1) {
                Log.w(TAG, "getSearchResult(): Ignoring pageSize less than 1 from " + controller);
                return new LibraryResult(LibraryResult.RESULT_CODE_BAD_VALUE);
            }
            return getLibrarySession().onGetSearchResultOnExecutor(controller, query, page, pageSize, (LibraryParams) ParcelUtils.fromParcelable(libraryParams));
        }
    });
}
#end_block

#method_before
@Override
public void subscribe(final IMediaController2 caller, int seq, final String parentId, final ParcelImpl libraryParams) {
    onLibraryCommand(caller, seq, SessionCommand2.COMMAND_CODE_LIBRARY_SUBSCRIBE, new LibraryCallbackCommand() {

        @Override
        public int runReturnsCode(ControllerInfo controller) {
            if (parentId == null) {
                Log.w(TAG, "subscribe(): Ignoring null parentId from " + controller);
                return LibraryResult.RESULT_CODE_BAD_VALUE;
            }
            return getLibrarySession().onSubscribeOnExecutor(controller, parentId, (LibraryParams) ParcelUtils.fromParcelable(libraryParams));
        }
    });
}
#method_after
@Override
public void subscribe(final IMediaController2 caller, int seq, final String parentId, final ParcelImpl libraryParams) {
    dispatchLibrarySessionTask(caller, seq, SessionCommand2.COMMAND_CODE_LIBRARY_SUBSCRIBE, new LibrarySessionCallbackTask<Integer>() {

        @Override
        public Integer run(ControllerInfo controller) {
            if (parentId == null) {
                Log.w(TAG, "subscribe(): Ignoring null parentId from " + controller);
                return LibraryResult.RESULT_CODE_BAD_VALUE;
            }
            return getLibrarySession().onSubscribeOnExecutor(controller, parentId, (LibraryParams) ParcelUtils.fromParcelable(libraryParams));
        }
    });
}
#end_block

#method_before
@Override
public void unsubscribe(final IMediaController2 caller, int seq, final String parentId) {
    onLibraryCommand(caller, seq, SessionCommand2.COMMAND_CODE_LIBRARY_UNSUBSCRIBE, new LibraryCallbackCommand() {

        @Override
        public int runReturnsCode(ControllerInfo controller) {
            if (parentId == null) {
                Log.w(TAG, "unsubscribe(): Ignoring null parentId from " + controller);
                return LibraryResult.RESULT_CODE_BAD_VALUE;
            }
            return getLibrarySession().onUnsubscribeOnExecutor(controller, parentId);
        }
    });
}
#method_after
@Override
public void unsubscribe(final IMediaController2 caller, int seq, final String parentId) {
    dispatchLibrarySessionTask(caller, seq, SessionCommand2.COMMAND_CODE_LIBRARY_UNSUBSCRIBE, new LibrarySessionCallbackTask<Integer>() {

        @Override
        public Integer run(ControllerInfo controller) {
            if (parentId == null) {
                Log.w(TAG, "unsubscribe(): Ignoring null parentId from " + controller);
                return LibraryResult.RESULT_CODE_BAD_VALUE;
            }
            return getLibrarySession().onUnsubscribeOnExecutor(controller, parentId);
        }
    });
}
#end_block

#method_before
@Override
void onPlaylistChanged(List<MediaItem2> playlist, MediaMetadata2 metadata) throws RemoteException {
    ControllerInfo controller = mConnectedControllersManager.getController(getCallbackBinder());
    if (mConnectedControllersManager.isAllowedCommand(controller, SessionCommand2.COMMAND_CODE_PLAYER_GET_PLAYLIST)) {
        mIControllerCallback.onPlaylistChanged(MediaUtils2.convertMediaItem2ListToParcelImplList(playlist), metadata == null ? null : metadata.toBundle());
    } else if (mConnectedControllersManager.isAllowedCommand(controller, SessionCommand2.COMMAND_CODE_PLAYER_GET_PLAYLIST_METADATA)) {
        mIControllerCallback.onPlaylistMetadataChanged(metadata.toBundle());
    }
}
#method_after
@Override
void onPlaylistChanged(List<MediaItem2> playlist, MediaMetadata2 metadata) throws RemoteException {
    ControllerInfo controller = mConnectedControllersManager.getController(getCallbackBinder());
    if (mConnectedControllersManager.isAllowedCommand(controller, SessionCommand2.COMMAND_CODE_PLAYER_GET_PLAYLIST)) {
        mIControllerCallback.onPlaylistChanged(MediaUtils2.convertMediaItem2ListToParcelImplListSlice(playlist), metadata == null ? null : metadata.toBundle());
    } else if (mConnectedControllersManager.isAllowedCommand(controller, SessionCommand2.COMMAND_CODE_PLAYER_GET_PLAYLIST_METADATA)) {
        mIControllerCallback.onPlaylistMetadataChanged(metadata.toBundle());
    }
}
#end_block

#method_before
@Override
public boolean set(T value) {
    return super.set(value);
}
#method_after
@Override
public boolean set(@Nullable T value) {
    return super.set(value);
}
#end_block

#method_before
public T getResultWhenClosed() {
    return mResultWhenClosed;
}
#method_after
@NonNull
public T getResultWhenClosed() {
    return mResultWhenClosed;
}
#end_block

#method_before
static ListenableFuture<BrowserResult> createFutureWithResult(@ResultCode int resultCode) {
    ResolvableFuture<BrowserResult> result = ResolvableFuture.create().create();
    result.set(new BrowserResult(resultCode));
    return result;
}
#method_after
static ListenableFuture<BrowserResult> createFutureWithResult(@ResultCode int resultCode) {
    ResolvableFuture<BrowserResult> result = ResolvableFuture.create();
    result.set(new BrowserResult(resultCode));
    return result;
}
#end_block

#method_before
@Nullable
public List<MediaItem2> getMediaItems() {
    return mItems;
}
#method_after
@Nullable
public List<MediaItem2> getMediaItems() {
    return mItemList;
}
#end_block

#method_before
public static LibraryParams createLibraryParams() {
    String caller = Thread.currentThread().getStackTrace()[2].getMethodName();
    Bundle extras = new Bundle();
    extras.putString(caller, caller);
    return new LibraryParams.Builder().setExtras(extras).build();
}
#method_after
public static LibraryParams createLibraryParams() {
    String callingTestName = Thread.currentThread().getStackTrace()[3].getMethodName();
    Bundle extras = new Bundle();
    extras.putString(callingTestName, callingTestName);
    return new LibraryParams.Builder().setExtras(extras).build();
}
#end_block

#method_before
public static LibraryParams createLibraryParams() {
    String caller = Thread.currentThread().getStackTrace()[2].getMethodName();
    Bundle extras = new Bundle();
    extras.putString(caller, caller);
    return new LibraryParams.Builder().setExtras(extras).build();
}
#method_after
public static LibraryParams createLibraryParams() {
    String callingTestName = Thread.currentThread().getStackTrace()[3].getMethodName();
    Bundle extras = new Bundle();
    extras.putString(callingTestName, callingTestName);
    return new LibraryParams.Builder().setExtras(extras).build();
}
#end_block

#method_before
@Override
public void notifyChildrenChanged(final String parentId, final int itemCount, final LibraryParams params) {
    if (TextUtils.isEmpty(parentId)) {
        throw new IllegalArgumentException("query shouldn't be empty");
    }
    if (itemCount < 0) {
        throw new IllegalArgumentException("itemCount shouldn't be negative");
    }
    notifyToAllControllers(new NotifyRunnable() {

        @Override
        public void run(ControllerCb callback) throws RemoteException {
            if (isSubscribed(callback, parentId)) {
                callback.onChildrenChanged(parentId, itemCount, params);
            }
        }
    });
}
#method_after
@Override
public void notifyChildrenChanged(final String parentId, final int itemCount, final LibraryParams params) {
    if (TextUtils.isEmpty(parentId)) {
        throw new IllegalArgumentException("query shouldn't be empty");
    }
    if (itemCount < 0) {
        throw new IllegalArgumentException("itemCount shouldn't be negative");
    }
    dispatchRemoteControllerCallbackTask(new RemoteControllerCallbackTask() {

        @Override
        public void run(ControllerCb callback) throws RemoteException {
            if (isSubscribed(callback, parentId)) {
                callback.onChildrenChanged(parentId, itemCount, params);
            }
        }
    });
}
#end_block

#method_before
@Override
public void notifyChildrenChanged(final ControllerInfo controller, final String parentId, final int itemCount, final LibraryParams params) {
    if (controller == null) {
        throw new IllegalArgumentException("controller shouldn't be null");
    }
    if (TextUtils.isEmpty(parentId)) {
        throw new IllegalArgumentException("query shouldn't be empty");
    }
    if (itemCount < 0) {
        throw new IllegalArgumentException("itemCount shouldn't be negative");
    }
    notifyToController(controller, new NotifyRunnable() {

        @Override
        public void run(ControllerCb callback) throws RemoteException {
            if (!isSubscribed(callback, parentId)) {
                if (DEBUG) {
                    Log.d(TAG, "Skipping notifyChildrenChanged() to " + controller + " because it hasn't subscribed");
                    dumpSubscription();
                }
                return;
            }
            callback.onChildrenChanged(parentId, itemCount, params);
        }
    });
}
#method_after
@Override
public void notifyChildrenChanged(final ControllerInfo controller, final String parentId, final int itemCount, final LibraryParams params) {
    if (controller == null) {
        throw new IllegalArgumentException("controller shouldn't be null");
    }
    if (TextUtils.isEmpty(parentId)) {
        throw new IllegalArgumentException("query shouldn't be empty");
    }
    if (itemCount < 0) {
        throw new IllegalArgumentException("itemCount shouldn't be negative");
    }
    dispatchRemoteControllerCallbackTask(controller, new RemoteControllerCallbackTask() {

        @Override
        public void run(ControllerCb callback) throws RemoteException {
            if (!isSubscribed(callback, parentId)) {
                if (DEBUG) {
                    Log.d(TAG, "Skipping notifyChildrenChanged() to " + controller + " because it hasn't subscribed");
                    dumpSubscription();
                }
                return;
            }
            callback.onChildrenChanged(parentId, itemCount, params);
        }
    });
}
#end_block

#method_before
@Override
public void notifySearchResultChanged(ControllerInfo controller, final String query, final int itemCount, final LibraryParams params) {
    if (controller == null) {
        throw new IllegalArgumentException("controller shouldn't be null");
    }
    if (TextUtils.isEmpty(query)) {
        throw new IllegalArgumentException("query shouldn't be empty");
    }
    notifyToController(controller, new NotifyRunnable() {

        @Override
        public void run(ControllerCb callback) throws RemoteException {
            callback.onSearchResultChanged(query, itemCount, params);
        }
    });
}
#method_after
@Override
public void notifySearchResultChanged(ControllerInfo controller, final String query, final int itemCount, final LibraryParams params) {
    if (controller == null) {
        throw new IllegalArgumentException("controller shouldn't be null");
    }
    if (TextUtils.isEmpty(query)) {
        throw new IllegalArgumentException("query shouldn't be empty");
    }
    dispatchRemoteControllerCallbackTask(controller, new RemoteControllerCallbackTask() {

        @Override
        public void run(ControllerCb callback) throws RemoteException {
            callback.onSearchResultChanged(query, itemCount, params);
        }
    });
}
#end_block

#method_before
private LibraryResult ensureNonNullResultWithValidList(LibraryResult returnedResult, int pageSize) {
    returnedResult = ensureNonNullResult(returnedResult);
    if (returnedResult != null && returnedResult.getResultCode() == RESULT_CODE_SUCCESS) {
        if (returnedResult.getMediaItems() == null) {
            if (THROW_EXCEPTION_FOR_INVALID_RETURN) {
                throw new RuntimeException("List shouldn't be null for the success");
            }
            return new LibraryResult(RESULT_CODE_UNKNOWN_ERROR);
        }
        if (returnedResult.getMediaItems().size() > pageSize) {
            if (THROW_EXCEPTION_FOR_INVALID_RETURN) {
                throw new RuntimeException("List shouldn't contain items more than pageSize" + ", size=" + returnedResult.getMediaItems().size() + ", pageSize" + pageSize);
            }
            return new LibraryResult(RESULT_CODE_UNKNOWN_ERROR);
        }
    }
    return returnedResult;
}
#method_after
private LibraryResult ensureNonNullResultWithValidList(LibraryResult returnedResult, int pageSize) {
    returnedResult = ensureNonNullResult(returnedResult);
    if (returnedResult.getResultCode() == RESULT_CODE_SUCCESS) {
        if (returnedResult.getMediaItems() == null) {
            if (THROW_EXCEPTION_FOR_INVALID_RETURN) {
                throw new RuntimeException("List shouldn't be null for the success");
            }
            return new LibraryResult(RESULT_CODE_UNKNOWN_ERROR);
        }
        if (returnedResult.getMediaItems().size() > pageSize) {
            if (THROW_EXCEPTION_FOR_INVALID_RETURN) {
                throw new RuntimeException("List shouldn't contain items more than pageSize" + ", size=" + returnedResult.getMediaItems().size() + ", pageSize" + pageSize);
            }
            return new LibraryResult(RESULT_CODE_UNKNOWN_ERROR);
        }
    }
    return returnedResult;
}
#end_block

#method_before
private LibraryResult ensureNonNullResultWithValidItem(LibraryResult returnedResult) {
    returnedResult = ensureNonNullResult(returnedResult);
    if (returnedResult != null && returnedResult.getResultCode() == RESULT_CODE_SUCCESS) {
        if (returnedResult.getMediaItem() == null) {
            if (THROW_EXCEPTION_FOR_INVALID_RETURN) {
                throw new RuntimeException("Item shouldn't be null for the success");
            }
            return new LibraryResult(RESULT_CODE_UNKNOWN_ERROR);
        }
    }
    return returnedResult;
}
#method_after
private LibraryResult ensureNonNullResultWithValidItem(LibraryResult returnedResult) {
    returnedResult = ensureNonNullResult(returnedResult);
    if (returnedResult.getResultCode() == RESULT_CODE_SUCCESS) {
        if (returnedResult.getMediaItem() == null) {
            if (THROW_EXCEPTION_FOR_INVALID_RETURN) {
                throw new RuntimeException("Item shouldn't be null for the success");
            }
            return new LibraryResult(RESULT_CODE_UNKNOWN_ERROR);
        }
    }
    return returnedResult;
}
#end_block

#method_before
public static LibraryParams createLibraryParams() {
    String caller = Thread.currentThread().getStackTrace()[2].getMethodName();
    Bundle extras = new Bundle();
    extras.putString(caller, caller);
    return new LibraryParams.Builder().setExtras(extras).build();
}
#method_after
public static LibraryParams createLibraryParams() {
    String callingTestName = Thread.currentThread().getStackTrace()[3].getMethodName();
    Bundle extras = new Bundle();
    extras.putString(callingTestName, callingTestName);
    return new LibraryParams.Builder().setExtras(extras).build();
}
#end_block

#method_before
public static void assertLibraryParamsEquals(LibraryParams a, LibraryParams b) {
    if (a == null || b == null) {
        assertEquals(a, b);
    } else {
        assertTrue(TestUtils.equals(a.getExtras(), b.getExtras()));
    }
}
#method_after
public static void assertLibraryParamsEquals(LibraryParams a, LibraryParams b) {
    if (a == null || b == null) {
        assertEquals(a, b);
    } else {
        assertEquals(a.isSuggested(), b.isSuggested());
        assertEquals(a.isOffline(), b.isOffline());
        assertEquals(a.isRecent(), b.isRecent());
        assertTrue(TestUtils.equals(a.getExtras(), b.getExtras()));
    }
}
#end_block

#method_before
public void postAndSync(final Runnable runnable) throws InterruptedException {
    if (getLooper() == Looper.myLooper()) {
        runnable.run();
    } else {
        final CountDownLatch latch = new CountDownLatch(1);
        post(new Runnable() {

            @Override
            public void run() {
                runnable.run();
                latch.countDown();
            }
        });
        assertTrue(latch.await(WAIT_TIME_MS, TimeUnit.MILLISECONDS));
    }
}
#method_after
public void postAndSync(final Runnable runnable) throws InterruptedException {
    if (getLooper() == Looper.myLooper()) {
        runnable.run();
    } else {
        final CountDownLatch latch = new CountDownLatch(1);
        post(new Runnable() {

            @Override
            public void run() {
                runnable.run();
                latch.countDown();
            }
        });
        assertTrue(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
    }
}
#end_block

#method_before
@Override
public LibraryResult onGetChildren(MediaLibrarySession session, ControllerInfo controller, String parentId, int page, int pageSize, LibraryParams params) {
    assertLibraryParams(params);
    if (PARENT_ID.equals(parentId)) {
        return new LibraryResult(RESULT_CODE_SUCCESS, getPaginatedResult(GET_CHILDREN_RESULT, page, pageSize), null);
    } else if (PARENT_ID_ERROR.equals(parentId)) {
        return new LibraryResult(RESULT_CODE_BAD_VALUE);
    }
    // Includes the case of PARENT_ID_NO_CHILDREN.
    return new LibraryResult(RESULT_CODE_SUCCESS, new ArrayList<MediaItem2>(), null);
}
#method_after
@Override
public LibraryResult onGetChildren(MediaLibrarySession session, ControllerInfo controller, String parentId, int page, int pageSize, LibraryParams params) {
    assertLibraryParams(params);
    if (PARENT_ID.equals(parentId)) {
        return new LibraryResult(RESULT_CODE_SUCCESS, getPaginatedResult(GET_CHILDREN_RESULT, page, pageSize), null);
    } else if (PARENT_ID_LONG_LIST.equals(parentId)) {
        List<MediaItem2> list = new ArrayList<>(LONG_LIST_COUNT);
        MediaItem2.Builder builder = new MediaItem2.Builder(0);
        for (int i = 0; i < LONG_LIST_COUNT; i++) {
            list.add(builder.setMediaId(TestUtils.getMediaIdInDummyList(i)).build());
        }
        return new LibraryResult(RESULT_CODE_SUCCESS, list, null);
    } else if (PARENT_ID_ERROR.equals(parentId)) {
        return new LibraryResult(RESULT_CODE_BAD_VALUE);
    }
    // Includes the case of PARENT_ID_NO_CHILDREN.
    return new LibraryResult(RESULT_CODE_SUCCESS, new ArrayList<MediaItem2>(), null);
}
#end_block

#method_before
@Override
public int onSearch(MediaLibrarySession session, final ControllerInfo controllerInfo, final String query, final LibraryParams params) {
    assertLibraryParams(params);
    if (SEARCH_QUERY.equals(query)) {
        mSession.notifySearchResultChanged(controllerInfo, query, SEARCH_RESULT_COUNT, params);
    } else if (SEARCH_QUERY_TAKES_TIME.equals(query)) {
        // Searching takes some time. Notify after 5 seconds.
        Executors.newSingleThreadScheduledExecutor().schedule(new Runnable() {

            @Override
            public void run() {
                mSession.notifySearchResultChanged(controllerInfo, query, SEARCH_RESULT_COUNT, params);
            }
        }, SEARCH_TIME_IN_MS, TimeUnit.MILLISECONDS);
    } else {
        // SEARCH_QUERY_EMPTY_RESULT and SEARCH_QUERY_ERROR will be handled here.
        mSession.notifySearchResultChanged(controllerInfo, query, 0, params);
    }
    return RESULT_CODE_SUCCESS;
}
#method_after
@Override
public int onSearch(MediaLibrarySession session, final ControllerInfo controllerInfo, final String query, final LibraryParams params) {
    assertLibraryParams(params);
    if (SEARCH_QUERY.equals(query)) {
        mSession.notifySearchResultChanged(controllerInfo, query, SEARCH_RESULT_COUNT, params);
    } else if (SEARCH_QUERY_LONG_LIST.equals(query)) {
        mSession.notifySearchResultChanged(controllerInfo, query, LONG_LIST_COUNT, params);
    } else if (SEARCH_QUERY_TAKES_TIME.equals(query)) {
        // Searching takes some time. Notify after 5 seconds.
        Executors.newSingleThreadScheduledExecutor().schedule(new Runnable() {

            @Override
            public void run() {
                mSession.notifySearchResultChanged(controllerInfo, query, SEARCH_RESULT_COUNT, params);
            }
        }, SEARCH_TIME_IN_MS, TimeUnit.MILLISECONDS);
    } else {
        // SEARCH_QUERY_EMPTY_RESULT and SEARCH_QUERY_ERROR will be handled here.
        mSession.notifySearchResultChanged(controllerInfo, query, 0, params);
    }
    return RESULT_CODE_SUCCESS;
}
#end_block

#method_before
@Override
public LibraryResult onGetSearchResult(MediaLibrarySession session, ControllerInfo controllerInfo, String query, int page, int pageSize, LibraryParams params) {
    assertLibraryParams(params);
    if (SEARCH_QUERY.equals(query)) {
        return new LibraryResult(RESULT_CODE_SUCCESS, getPaginatedResult(SEARCH_RESULT, page, pageSize), null);
    } else if (SEARCH_QUERY_EMPTY_RESULT.equals(query)) {
        return new LibraryResult(RESULT_CODE_SUCCESS, new ArrayList<MediaItem2>(), null);
    } else {
        // SEARCH_QUERY_ERROR will be handled here.
        return new LibraryResult(RESULT_CODE_BAD_VALUE);
    }
}
#method_after
@Override
public LibraryResult onGetSearchResult(MediaLibrarySession session, ControllerInfo controllerInfo, String query, int page, int pageSize, LibraryParams params) {
    assertLibraryParams(params);
    if (SEARCH_QUERY.equals(query)) {
        return new LibraryResult(RESULT_CODE_SUCCESS, getPaginatedResult(SEARCH_RESULT, page, pageSize), null);
    } else if (SEARCH_QUERY_LONG_LIST.equals(query)) {
        List<MediaItem2> list = new ArrayList<>(LONG_LIST_COUNT);
        MediaItem2.Builder builder = new MediaItem2.Builder(0);
        for (int i = 0; i < LONG_LIST_COUNT; i++) {
            list.add(builder.setMediaId(TestUtils.getMediaIdInDummyList(i)).build());
        }
        return new LibraryResult(RESULT_CODE_SUCCESS, list, null);
    } else if (SEARCH_QUERY_EMPTY_RESULT.equals(query)) {
        return new LibraryResult(RESULT_CODE_SUCCESS, new ArrayList<MediaItem2>(), null);
    } else {
        // SEARCH_QUERY_ERROR will be handled here.
        return new LibraryResult(RESULT_CODE_BAD_VALUE);
    }
}
#end_block

#method_before
@Override
public void onBufferingStateChanged(ParcelImpl item, @BuffState int state, long bufferedPositionMs) {
    final MediaController2ImplBase controller;
    try {
        controller = getController();
    } catch (IllegalStateException e) {
        Log.w(TAG, "Don't fail silently here. Highly likely a bug");
        return;
    }
    controller.notifyBufferingStateChanged((MediaItem2) ParcelUtils.fromParcelable(item), state, bufferedPositionMs);
}
#method_after
@Override
public void onBufferingStateChanged(ParcelImpl item, @BuffState int state, long bufferedPositionMs) {
    final MediaController2ImplBase controller;
    try {
        controller = getController();
    } catch (IllegalStateException e) {
        Log.w(TAG, "Don't fail silently here. Highly likely a bug");
        return;
    }
    MediaItem2 item2 = (item == null) ? null : (MediaItem2) ParcelUtils.fromParcelable(item);
    if (item2 == null) {
        Log.w(TAG, "onBufferingStateChanged(): Ignoring null item");
        return;
    }
    controller.notifyBufferingStateChanged(item2, state, bufferedPositionMs);
}
#end_block

#method_before
@Override
public void onPlaylistChanged(List<ParcelImpl> parcelList, Bundle metadataBundle) {
    final MediaController2ImplBase controller;
    try {
        controller = getController();
    } catch (IllegalStateException e) {
        Log.w(TAG, "Don't fail silently here. Highly likely a bug");
        return;
    }
    if (parcelList == null) {
        Log.w(TAG, "onPlaylistChanged(): Ignoring null playlist from " + controller);
        return;
    }
    List<MediaItem2> playlist = new ArrayList<>();
    for (ParcelImpl parcelImpl : parcelList) {
        MediaItem2 item = ParcelUtils.fromParcelable(parcelImpl);
        if (item == null) {
            Log.w(TAG, "onPlaylistChanged(): Ignoring null item in playlist");
        } else {
            playlist.add(item);
        }
    }
    MediaMetadata2 metadata = MediaMetadata2.fromBundle(metadataBundle);
    controller.notifyPlaylistChanges(playlist, metadata);
}
#method_after
@Override
public void onPlaylistChanged(ParcelImplListSlice listSlice, Bundle metadataBundle) {
    final MediaController2ImplBase controller;
    try {
        controller = getController();
    } catch (IllegalStateException e) {
        Log.w(TAG, "Don't fail silently here. Highly likely a bug");
        return;
    }
    List<MediaItem2> playlist = MediaUtils2.convertParcelImplListSliceToMediaItem2List(listSlice);
    if (playlist == null) {
        Log.w(TAG, "onPlaylistChanged(): Ignoring null playlist");
        return;
    }
    MediaMetadata2 metadata = MediaMetadata2.fromBundle(metadataBundle);
    controller.notifyPlaylistChanges(playlist, metadata);
}
#end_block

#method_before
@Override
public void onConnected(IMediaSession2 sessionBinder, ParcelImpl commandGroup, int playerState, ParcelImpl currentItem, long positionEventTimeMs, long positionMs, float playbackSpeed, long bufferedPositionMs, ParcelImpl playbackInfo, int shuffleMode, int repeatMode, List<ParcelImpl> playlistParcel, PendingIntent sessionActivity) {
    final MediaController2ImplBase controller = mController.get();
    if (controller == null) {
        if (DEBUG) {
            Log.d(TAG, "onConnected after MediaController2.close()");
        }
        return;
    }
    List<MediaItem2> itemList = null;
    if (playlistParcel != null) {
        itemList = new ArrayList<>();
        for (int i = 0; i < playlistParcel.size(); i++) {
            MediaItem2 item = ParcelUtils.fromParcelable(playlistParcel.get(i));
            if (item != null) {
                itemList.add(item);
            }
        }
    }
    controller.onConnectedNotLocked(sessionBinder, (SessionCommandGroup2) ParcelUtils.fromParcelable(commandGroup), playerState, (MediaItem2) ParcelUtils.fromParcelable(currentItem), positionEventTimeMs, positionMs, playbackSpeed, bufferedPositionMs, (PlaybackInfo) ParcelUtils.fromParcelable(playbackInfo), repeatMode, shuffleMode, itemList, sessionActivity);
}
#method_after
@Override
public void onConnected(IMediaSession2 sessionBinder, ParcelImpl commandGroup, int playerState, ParcelImpl currentItem, long positionEventTimeMs, long positionMs, float playbackSpeed, long bufferedPositionMs, ParcelImpl playbackInfo, int shuffleMode, int repeatMode, ParcelImplListSlice listSlice, PendingIntent sessionActivity) {
    final MediaController2ImplBase controller = mController.get();
    if (controller == null) {
        if (DEBUG) {
            Log.d(TAG, "onConnected after MediaController2.close()");
        }
        return;
    }
    List<MediaItem2> itemList = MediaUtils2.convertParcelImplListSliceToMediaItem2List(listSlice);
    controller.onConnectedNotLocked(sessionBinder, (SessionCommandGroup2) ParcelUtils.fromParcelable(commandGroup), playerState, (MediaItem2) ParcelUtils.fromParcelable(currentItem), positionEventTimeMs, positionMs, playbackSpeed, bufferedPositionMs, (PlaybackInfo) ParcelUtils.fromParcelable(playbackInfo), repeatMode, shuffleMode, itemList, sessionActivity);
}
#end_block

#method_before
public static MediaItem2 convertToMediaItem2(MediaItem item) {
    if (item == null || item.getMediaId() == null) {
        return null;
    }
    MediaMetadata2 metadata2 = convertToMediaMetadata2(item.getDescription());
    return new MediaItem2.Builder(item.getFlags()).setMediaId(item.getMediaId()).setMetadata(metadata2).build();
}
#method_after
public static MediaItem2 convertToMediaItem2(MediaItem item) {
    if (item == null) {
        return null;
    }
    MediaMetadata2 metadata2 = convertToMediaMetadata2(item.getDescription());
    return new MediaItem2.Builder(item.getFlags()).setMediaId(item.getMediaId()).setMetadata(metadata2).build();
}
#end_block

#method_before
public static MediaItem2 convertToMediaItem2(@NonNull QueueItem item) {
    if (item == null) {
        throw new IllegalArgumentException("item shouldn't be null");
    }
    // descriptionCompat cannot be null
    MediaDescriptionCompat descriptionCompat = item.getDescription();
    MediaMetadata2 metadata2 = convertToMediaMetadata2(descriptionCompat);
    return new MediaItem2.Builder(FLAG_PLAYABLE).setMetadata(metadata2).setUuid(createUuidByQueueIdAndMediaId(item.getQueueId(), descriptionCompat.getMediaId())).build();
}
#method_after
public static MediaItem2 convertToMediaItem2(QueueItem item) {
    if (item == null) {
        return null;
    }
    // descriptionCompat cannot be null
    MediaDescriptionCompat descriptionCompat = item.getDescription();
    MediaMetadata2 metadata2 = convertToMediaMetadata2(descriptionCompat);
    return new MediaItem2.Builder(FLAG_PLAYABLE).setMetadata(metadata2).setUuid(createUuidByQueueIdAndMediaId(item.getQueueId(), descriptionCompat.getMediaId())).build();
}
#end_block

#method_before
public static MediaItem2 convertToMediaItem2(MediaMetadataCompat metadataCompat) {
    MediaMetadata2 metadata2 = convertToMediaMetadata2(metadataCompat);
    if (metadata2 == null || metadata2.getMediaId() == null) {
        return null;
    }
    return new MediaItem2.Builder(FLAG_PLAYABLE).setMetadata(metadata2).build();
}
#method_after
public static MediaItem2 convertToMediaItem2(MediaMetadataCompat metadataCompat) {
    MediaMetadata2 metadata2 = convertToMediaMetadata2(metadataCompat);
    if (metadata2 == null) {
        return null;
    }
    return new MediaItem2.Builder(FLAG_PLAYABLE).setMetadata(metadata2).build();
}
#end_block

#method_before
public static MediaItem2 convertToMediaItem2(MediaDescriptionCompat descriptionCompat) {
    MediaMetadata2 metadata2 = convertToMediaMetadata2(descriptionCompat);
    if (metadata2 == null || metadata2.getMediaId() == null) {
        return null;
    }
    return new MediaItem2.Builder(FLAG_PLAYABLE).setMetadata(metadata2).build();
}
#method_after
public static MediaItem2 convertToMediaItem2(MediaDescriptionCompat descriptionCompat) {
    MediaMetadata2 metadata2 = convertToMediaMetadata2(descriptionCompat);
    if (metadata2 == null) {
        return null;
    }
    return new MediaItem2.Builder(FLAG_PLAYABLE).setMetadata(metadata2).build();
}
#end_block

#method_before
public static List<MediaItem2> convertQueueItemListToMediaItem2List(List<QueueItem> items) {
    if (items == null) {
        return null;
    }
    List<MediaItem2> result = new ArrayList<>();
    for (int i = 0; i < items.size(); i++) {
        result.add(convertToMediaItem2(items.get(i)));
    }
    return result;
}
#method_after
public static List<MediaItem2> convertQueueItemListToMediaItem2List(List<QueueItem> items) {
    if (items == null) {
        return null;
    }
    List<MediaItem2> result = new ArrayList<>();
    for (int i = 0; i < items.size(); i++) {
        MediaItem2 item = convertToMediaItem2(items.get(i));
        if (item != null) {
            result.add(item);
        }
    }
    return result;
}
#end_block

#method_before
public static QueueItem convertToQueueItem(MediaItem2 item) {
    MediaDescriptionCompat description = (item.getMetadata() == null) ? new MediaDescriptionCompat.Builder().setMediaId(item.getMediaId()).build() : convertToMediaMetadataCompat(item.getMetadata()).getDescription();
    return new QueueItem(description, item.getUuid().getMostSignificantBits());
}
#method_after
public static QueueItem convertToQueueItem(MediaItem2 item) {
    if (item == null) {
        return null;
    }
    MediaDescriptionCompat description = (item.getMetadata() == null) ? new MediaDescriptionCompat.Builder().setMediaId(item.getMediaId()).build() : convertToMediaMetadataCompat(item.getMetadata()).getDescription();
    return new QueueItem(description, item.getUuid().getMostSignificantBits());
}
#end_block

#method_before
public static List<QueueItem> convertToQueueItemList(List<MediaItem2> items) {
    if (items == null) {
        return null;
    }
    List<QueueItem> result = new ArrayList<>();
    for (int i = 0; i < items.size(); i++) {
        result.add(convertToQueueItem(items.get(i)));
    }
    return result;
}
#method_after
public static List<QueueItem> convertToQueueItemList(List<MediaItem2> items) {
    if (items == null) {
        return null;
    }
    List<QueueItem> result = new ArrayList<>();
    for (int i = 0; i < items.size(); i++) {
        QueueItem queueItem = convertToQueueItem(items.get(i));
        if (queueItem != null) {
            result.add(queueItem);
        }
    }
    return result;
}
#end_block

#method_before
public static int convertToPlayerState(int playbackStateCompatState) {
    switch(playbackStateCompatState) {
        case PlaybackStateCompat.STATE_ERROR:
            return SessionPlayer2.PLAYER_STATE_ERROR;
        case PlaybackStateCompat.STATE_NONE:
            return SessionPlayer2.PLAYER_STATE_IDLE;
        case PlaybackStateCompat.STATE_PAUSED:
        case PlaybackStateCompat.STATE_STOPPED:
        case // means paused for buffering.
        PlaybackStateCompat.STATE_BUFFERING:
            return SessionPlayer2.PLAYER_STATE_PAUSED;
        case PlaybackStateCompat.STATE_FAST_FORWARDING:
        case PlaybackStateCompat.STATE_PLAYING:
        case PlaybackStateCompat.STATE_REWINDING:
        case PlaybackStateCompat.STATE_SKIPPING_TO_NEXT:
        case PlaybackStateCompat.STATE_SKIPPING_TO_PREVIOUS:
        case PlaybackStateCompat.STATE_SKIPPING_TO_QUEUE_ITEM:
        case // Note: there's no perfect match for this.
        PlaybackStateCompat.STATE_CONNECTING:
            return SessionPlayer2.PLAYER_STATE_PLAYING;
    }
    return SessionPlayer2.PLAYER_STATE_ERROR;
}
#method_after
public static int convertToPlayerState(PlaybackStateCompat state) {
    if (state == null) {
        return SessionPlayer2.PLAYER_STATE_IDLE;
    }
    switch(state.getState()) {
        case PlaybackStateCompat.STATE_ERROR:
            return SessionPlayer2.PLAYER_STATE_ERROR;
        case PlaybackStateCompat.STATE_NONE:
            return SessionPlayer2.PLAYER_STATE_IDLE;
        case PlaybackStateCompat.STATE_PAUSED:
        case PlaybackStateCompat.STATE_STOPPED:
        case // means paused for buffering.
        PlaybackStateCompat.STATE_BUFFERING:
            return SessionPlayer2.PLAYER_STATE_PAUSED;
        case PlaybackStateCompat.STATE_FAST_FORWARDING:
        case PlaybackStateCompat.STATE_PLAYING:
        case PlaybackStateCompat.STATE_REWINDING:
        case PlaybackStateCompat.STATE_SKIPPING_TO_NEXT:
        case PlaybackStateCompat.STATE_SKIPPING_TO_PREVIOUS:
        case PlaybackStateCompat.STATE_SKIPPING_TO_QUEUE_ITEM:
        case // Note: there's no perfect match for this.
        PlaybackStateCompat.STATE_CONNECTING:
            return SessionPlayer2.PLAYER_STATE_PLAYING;
    }
    return SessionPlayer2.PLAYER_STATE_ERROR;
}
#end_block

#method_before
@NonNull
public CommandButton build() {
    return new CommandButton(mCommand, mIconResId, mDisplayName, mExtras, mEnabled);
}
#method_after
@Override
@NonNull
public MediaSession2 build() {
    if (mCallbackExecutor == null) {
        mCallbackExecutor = ContextCompat.getMainExecutor(mContext);
    }
    if (mCallback == null) {
        mCallback = new SessionCallback() {
        };
    }
    return new MediaSession2(mContext, mId, mPlayer, mSessionActivity, mCallbackExecutor, mCallback);
}
#end_block

#method_before
public LibraryParams build() {
    return new LibraryParams(mBundle, mRecent, mOffline, mSuggested);
}
#method_after
@Override
@NonNull
public MediaLibrarySession build() {
    if (mCallbackExecutor == null) {
        mCallbackExecutor = ContextCompat.getMainExecutor(mContext);
    }
    if (mCallback == null) {
        mCallback = new MediaLibrarySession.MediaLibrarySessionCallback() {
        };
    }
    return new MediaLibrarySession(mContext, mId, mPlayer, mSessionActivity, mCallbackExecutor, mCallback);
}
#end_block

#method_before
/**
 * Notify all controllers that subscribed to the parent about change in the parent's
 * children, regardless of the extra bundle supplied by
 * {@link MediaBrowser2#subscribe(String, LibraryParams)}.
 *  @param parentId parent id
 * @param itemCount number of children
 * @param params library params
 */
public void notifyChildrenChanged(@NonNull String parentId, int itemCount, @Nullable LibraryParams params) {
    getImpl().notifyChildrenChanged(parentId, itemCount, params);
}
#method_after
/**
 * Notify all controllers that subscribed to the parent about change in the parent's
 * children, regardless of the library params supplied by
 * {@link MediaBrowser2#subscribe(String, LibraryParams)}.
 *  @param parentId parent id
 * @param itemCount number of children
 * @param params library params
 */
public void notifyChildrenChanged(@NonNull String parentId, int itemCount, @Nullable LibraryParams params) {
    getImpl().notifyChildrenChanged(parentId, itemCount, params);
}
#end_block

#method_before
private static boolean convertToBoolean(Integer a) {
    return a == 0 ? false : true;
}
#method_after
private static boolean convertToBoolean(int a) {
    return a == 0 ? false : true;
}
#end_block

#method_before
List<MediaItem2> getMediaItems() {
    return mItems;
}
#method_after
List<MediaItem2> getMediaItems() {
    return mItemList;
}
#end_block

#method_before
@Test
public void testGetLibraryRoot() throws Exception {
    prepareLooper();
    final LibraryParams params = MediaTestUtils.createLibraryParams();
    MediaBrowser2 browser = createBrowser();
    setExpectedLibraryParam(browser, params);
    BrowserResult result = browser.getLibraryRoot(params).get(WAIT_TIME_MS, TimeUnit.MILLISECONDS);
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    MediaMetadata2 metadata = result.getMediaItem().getMetadata();
    assertEquals(ROOT_ID, metadata.getString(MediaMetadata2.METADATA_KEY_MEDIA_ID));
    assertTrue(TestUtils.equals(ROOT_EXTRAS, result.getLibraryParams().getExtras()));
}
#method_after
@Test
public void testGetLibraryRoot() throws Exception {
    prepareLooper();
    final LibraryParams params = new LibraryParams.Builder().setOffline(true).setRecent(true).setExtras(new Bundle()).build();
    MediaBrowser2 browser = createBrowser();
    setExpectedLibraryParam(browser, params);
    BrowserResult result = browser.getLibraryRoot(params).get(TIMEOUT_MS, TimeUnit.MILLISECONDS);
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    MediaMetadata2 metadata = result.getMediaItem().getMetadata();
    assertEquals(ROOT_ID, metadata.getString(MediaMetadata2.METADATA_KEY_MEDIA_ID));
    assertTrue(TestUtils.equals(ROOT_EXTRAS, result.getLibraryParams().getExtras()));
}
#end_block

#method_before
@Test
public void testGetItem() throws Exception {
    prepareLooper();
    final String mediaId = MediaBrowser2Constants.MEDIA_ID_GET_ITEM;
    BrowserResult result = createBrowser().getItem(mediaId).get(WAIT_TIME_MS, TimeUnit.MILLISECONDS);
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertMediaItemWithId(mediaId, result.getMediaItem());
}
#method_after
@Test
public void testGetItem() throws Exception {
    prepareLooper();
    final String mediaId = MediaBrowser2Constants.MEDIA_ID_GET_ITEM;
    BrowserResult result = createBrowser().getItem(mediaId).get(TIMEOUT_MS, TimeUnit.MILLISECONDS);
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertMediaItemWithId(mediaId, result.getMediaItem());
}
#end_block

#method_before
@Test
public void testGetItem_nullResult() throws Exception {
    prepareLooper();
    final String mediaId = "random_media_id";
    BrowserResult result = createBrowser().getItem(mediaId).get(WAIT_TIME_MS, TimeUnit.MILLISECONDS);
    assertNotEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertNull(result.getMediaItem());
}
#method_after
@Test
public void testGetItem_nullResult() throws Exception {
    prepareLooper();
    final String mediaId = "random_media_id";
    BrowserResult result = createBrowser().getItem(mediaId).get(TIMEOUT_MS, TimeUnit.MILLISECONDS);
    assertNotEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertNull(result.getMediaItem());
}
#end_block

#method_before
@Test
public void testGetChildren() throws Exception {
    prepareLooper();
    final String parentId = MediaBrowser2Constants.PARENT_ID;
    final int page = 4;
    final int pageSize = 10;
    final LibraryParams params = createLibraryParams();
    MediaBrowser2 browser = createBrowser();
    setExpectedLibraryParam(browser, params);
    BrowserResult result = browser.getChildren(parentId, page, pageSize, params).get(WAIT_TIME_MS, TimeUnit.MILLISECONDS);
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertNull(result.getLibraryParams());
    MediaTestUtils.assertPaginatedListWithIds(MediaBrowser2Constants.GET_CHILDREN_RESULT, page, pageSize, result.getMediaItems());
}
#method_after
@Test
public void testGetChildren() throws Exception {
    prepareLooper();
    final String parentId = MediaBrowser2Constants.PARENT_ID;
    final int page = 4;
    final int pageSize = 10;
    final LibraryParams params = createLibraryParams();
    MediaBrowser2 browser = createBrowser();
    setExpectedLibraryParam(browser, params);
    BrowserResult result = browser.getChildren(parentId, page, pageSize, params).get(TIMEOUT_MS, TimeUnit.MILLISECONDS);
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertNull(result.getLibraryParams());
    MediaTestUtils.assertPaginatedListWithIds(MediaBrowser2Constants.GET_CHILDREN_RESULT, page, pageSize, result.getMediaItems());
}
#end_block

#method_before
@Test
public void testGetChildren_emptyResult() throws Exception {
    prepareLooper();
    final String parentId = MediaBrowser2Constants.PARENT_ID_NO_CHILDREN;
    MediaBrowser2 browser = createBrowser();
    BrowserResult result = browser.getChildren(parentId, 1, 1, null).get(WAIT_TIME_MS, TimeUnit.MILLISECONDS);
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertEquals(0, result.getMediaItems().size());
}
#method_after
@Test
public void testGetChildren_emptyResult() throws Exception {
    prepareLooper();
    final String parentId = MediaBrowser2Constants.PARENT_ID_NO_CHILDREN;
    MediaBrowser2 browser = createBrowser();
    BrowserResult result = browser.getChildren(parentId, 1, 1, null).get(TIMEOUT_MS, TimeUnit.MILLISECONDS);
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertEquals(0, result.getMediaItems().size());
}
#end_block

#method_before
@Test
public void testGetChildren_nullResult() throws Exception {
    prepareLooper();
    final String parentId = MediaBrowser2Constants.PARENT_ID_ERROR;
    MediaBrowser2 browser = createBrowser();
    BrowserResult result = browser.getChildren(parentId, 1, 1, null).get(WAIT_TIME_MS, TimeUnit.MILLISECONDS);
    assertNotEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertNull(result.getMediaItems());
}
#method_after
@Test
public void testGetChildren_nullResult() throws Exception {
    prepareLooper();
    final String parentId = MediaBrowser2Constants.PARENT_ID_ERROR;
    MediaBrowser2 browser = createBrowser();
    BrowserResult result = browser.getChildren(parentId, 1, 1, null).get(TIMEOUT_MS, TimeUnit.MILLISECONDS);
    assertNotEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertNull(result.getMediaItems());
}
#end_block

#method_before
@Test
public void testSearchCallbacks() throws Exception {
    prepareLooper();
    final String query = MediaBrowser2Constants.SEARCH_QUERY;
    final int page = 4;
    final int pageSize = 10;
    final LibraryParams testParams = createLibraryParams();
    final CountDownLatch latchForSearch = new CountDownLatch(1);
    final BrowserCallback callback = new BrowserCallback() {

        @Override
        public void onSearchResultChanged(MediaBrowser2 browser, String queryOut, int itemCount, LibraryParams params) {
            assertEquals(query, queryOut);
            assertLibraryParamsEquals(testParams, params);
            assertEquals(MediaBrowser2Constants.SEARCH_RESULT_COUNT, itemCount);
            latchForSearch.countDown();
        }
    };
    // Request the search.
    MediaBrowser2 browser = createBrowser(callback);
    setExpectedLibraryParam(browser, testParams);
    BrowserResult result = browser.search(query, testParams).get(WAIT_TIME_MS, TimeUnit.MILLISECONDS);
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    // Get the search result.
    result = browser.getSearchResult(query, page, pageSize, testParams).get(WAIT_TIME_MS, TimeUnit.MILLISECONDS);
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertPaginatedListWithIds(MediaBrowser2Constants.SEARCH_RESULT, page, pageSize, result.getMediaItems());
}
#method_after
@Test
public void testSearchCallbacks() throws Exception {
    prepareLooper();
    final String query = MediaBrowser2Constants.SEARCH_QUERY;
    final int page = 4;
    final int pageSize = 10;
    final LibraryParams testParams = createLibraryParams();
    final CountDownLatch latchForSearch = new CountDownLatch(1);
    final BrowserCallback callback = new BrowserCallback() {

        @Override
        public void onSearchResultChanged(MediaBrowser2 browser, String queryOut, int itemCount, LibraryParams params) {
            assertEquals(query, queryOut);
            assertLibraryParamsEquals(testParams, params);
            assertEquals(MediaBrowser2Constants.SEARCH_RESULT_COUNT, itemCount);
            latchForSearch.countDown();
        }
    };
    // Request the search.
    MediaBrowser2 browser = createBrowser(callback);
    setExpectedLibraryParam(browser, testParams);
    BrowserResult result = browser.search(query, testParams).get(TIMEOUT_MS, TimeUnit.MILLISECONDS);
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    // Get the search result.
    result = browser.getSearchResult(query, page, pageSize, testParams).get(TIMEOUT_MS, TimeUnit.MILLISECONDS);
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertPaginatedListWithIds(MediaBrowser2Constants.SEARCH_RESULT, page, pageSize, result.getMediaItems());
}
#end_block

#method_before
@Test
@LargeTest
public void testOnSearchResultChanged_searchTakesTime() throws Exception {
    prepareLooper();
    final String query = MediaBrowser2Constants.SEARCH_QUERY_TAKES_TIME;
    final LibraryParams testParams = createLibraryParams();
    final CountDownLatch latch = new CountDownLatch(1);
    final BrowserCallback callback = new BrowserCallback() {

        @Override
        public void onSearchResultChanged(MediaBrowser2 browser, String queryOut, int itemCount, LibraryParams params) {
            assertEquals(query, queryOut);
            assertTrue(TestUtils.equals(testParams, params));
            assertEquals(MediaBrowser2Constants.SEARCH_RESULT_COUNT, itemCount);
            latch.countDown();
        }
    };
    MediaBrowser2 browser = createBrowser(callback);
    setExpectedLibraryParam(browser, testParams);
    BrowserResult result = browser.search(query, testParams).get(MediaBrowser2Constants.SEARCH_TIME_IN_MS + WAIT_TIME_MS, TimeUnit.MILLISECONDS);
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
}
#method_after
@Test
@LargeTest
public void testOnSearchResultChanged_searchTakesTime() throws Exception {
    prepareLooper();
    final String query = MediaBrowser2Constants.SEARCH_QUERY_TAKES_TIME;
    final LibraryParams testParams = createLibraryParams();
    final CountDownLatch latch = new CountDownLatch(1);
    final BrowserCallback callback = new BrowserCallback() {

        @Override
        public void onSearchResultChanged(MediaBrowser2 browser, String queryOut, int itemCount, LibraryParams params) {
            assertEquals(query, queryOut);
            assertTrue(TestUtils.equals(testParams, params));
            assertEquals(MediaBrowser2Constants.SEARCH_RESULT_COUNT, itemCount);
            latch.countDown();
        }
    };
    MediaBrowser2 browser = createBrowser(callback);
    setExpectedLibraryParam(browser, testParams);
    BrowserResult result = browser.search(query, testParams).get(MediaBrowser2Constants.SEARCH_TIME_IN_MS + TIMEOUT_MS, TimeUnit.MILLISECONDS);
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
}
#end_block

#method_before
@Test
public void testOnSearchResultChanged_emptyResult() throws Exception {
    prepareLooper();
    final String query = MediaBrowser2Constants.SEARCH_QUERY_EMPTY_RESULT;
    final LibraryParams testParams = createLibraryParams();
    final CountDownLatch latch = new CountDownLatch(1);
    final BrowserCallback callback = new BrowserCallback() {

        @Override
        public void onSearchResultChanged(MediaBrowser2 browser, String queryOut, int itemCount, LibraryParams params) {
            assertEquals(query, queryOut);
            assertLibraryParamsEquals(testParams, params);
            assertEquals(0, itemCount);
            latch.countDown();
        }
    };
    MediaBrowser2 browser = createBrowser(callback);
    setExpectedLibraryParam(browser, testParams);
    BrowserResult result = browser.search(query, testParams).get(WAIT_TIME_MS, TimeUnit.MILLISECONDS);
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
}
#method_after
@Test
public void testOnSearchResultChanged_emptyResult() throws Exception {
    prepareLooper();
    final String query = MediaBrowser2Constants.SEARCH_QUERY_EMPTY_RESULT;
    final LibraryParams testParams = createLibraryParams();
    final CountDownLatch latch = new CountDownLatch(1);
    final BrowserCallback callback = new BrowserCallback() {

        @Override
        public void onSearchResultChanged(MediaBrowser2 browser, String queryOut, int itemCount, LibraryParams params) {
            assertEquals(query, queryOut);
            assertLibraryParamsEquals(testParams, params);
            assertEquals(0, itemCount);
            latch.countDown();
        }
    };
    MediaBrowser2 browser = createBrowser(callback);
    setExpectedLibraryParam(browser, testParams);
    BrowserResult result = browser.search(query, testParams).get(TIMEOUT_MS, TimeUnit.MILLISECONDS);
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
}
#end_block

#method_before
@Test
public void testOnChildrenChanged_calledWhenSubscribed() throws Exception {
    // This test uses MediaLibrarySession.notifyChildrenChanged().
    prepareLooper();
    final String expectedParentId = SUBSCRIBE_ID_NOTIFY_CHILDREN_CHANGED_TO_ALL;
    final CountDownLatch latch = new CountDownLatch(1);
    final BrowserCallback controllerCallbackProxy = new BrowserCallback() {

        @Override
        public void onChildrenChanged(MediaBrowser2 browser, String parentId, int itemCount, LibraryParams params) {
            assertEquals(expectedParentId, parentId);
            assertEquals(NOTIFY_CHILDREN_CHANGED_ITEM_COUNT, itemCount);
            assertLibraryParamsWithBundle(params, NOTIFY_CHILDREN_CHANGED_EXTRAS);
            latch.countDown();
        }
    };
    BrowserResult result = createBrowser(controllerCallbackProxy).subscribe(expectedParentId, null).get(WAIT_TIME_MS, TimeUnit.MILLISECONDS);
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    // The MediaLibrarySession in MockMediaLibraryService2 is supposed to call
    // notifyChildrenChanged() in its callback onSubscribe().
    assertTrue(latch.await(WAIT_TIME_MS, TimeUnit.MILLISECONDS));
}
#method_after
@Test
public void testOnChildrenChanged_calledWhenSubscribed() throws Exception {
    // This test uses MediaLibrarySession.notifyChildrenChanged().
    prepareLooper();
    final String expectedParentId = SUBSCRIBE_ID_NOTIFY_CHILDREN_CHANGED_TO_ALL;
    final CountDownLatch latch = new CountDownLatch(1);
    final BrowserCallback controllerCallbackProxy = new BrowserCallback() {

        @Override
        public void onChildrenChanged(MediaBrowser2 browser, String parentId, int itemCount, LibraryParams params) {
            assertEquals(expectedParentId, parentId);
            assertEquals(NOTIFY_CHILDREN_CHANGED_ITEM_COUNT, itemCount);
            assertLibraryParamsWithBundle(params, NOTIFY_CHILDREN_CHANGED_EXTRAS);
            latch.countDown();
        }
    };
    BrowserResult result = createBrowser(controllerCallbackProxy).subscribe(expectedParentId, null).get(TIMEOUT_MS, TimeUnit.MILLISECONDS);
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    // The MediaLibrarySession in MockMediaLibraryService2 is supposed to call
    // notifyChildrenChanged() in its callback onSubscribe().
    assertTrue(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
}
#end_block

#method_before
@Test
public void testOnChildrenChanged_calledWhenSubscribed2() throws Exception {
    // This test uses MediaLibrarySession.notifyChildrenChanged(ControllerInfo).
    prepareLooper();
    final String expectedParentId = SUBSCRIBE_ID_NOTIFY_CHILDREN_CHANGED_TO_ONE;
    final CountDownLatch latch = new CountDownLatch(1);
    final BrowserCallback controllerCallbackProxy = new BrowserCallback() {

        @Override
        public void onChildrenChanged(MediaBrowser2 browser, String parentId, int itemCount, LibraryParams params) {
            assertEquals(expectedParentId, parentId);
            assertEquals(NOTIFY_CHILDREN_CHANGED_ITEM_COUNT, itemCount);
            assertLibraryParamsWithBundle(params, NOTIFY_CHILDREN_CHANGED_EXTRAS);
            latch.countDown();
        }
    };
    BrowserResult result = createBrowser(controllerCallbackProxy).subscribe(expectedParentId, null).get(WAIT_TIME_MS, TimeUnit.MILLISECONDS);
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    // The MediaLibrarySession in MockMediaLibraryService2 is supposed to call
    // notifyChildrenChanged(ControllerInfo) in its callback onSubscribe().
    assertTrue(latch.await(WAIT_TIME_MS, TimeUnit.MILLISECONDS));
}
#method_after
@Test
public void testOnChildrenChanged_calledWhenSubscribed2() throws Exception {
    // This test uses MediaLibrarySession.notifyChildrenChanged(ControllerInfo).
    prepareLooper();
    final String expectedParentId = SUBSCRIBE_ID_NOTIFY_CHILDREN_CHANGED_TO_ONE;
    final CountDownLatch latch = new CountDownLatch(1);
    final BrowserCallback controllerCallbackProxy = new BrowserCallback() {

        @Override
        public void onChildrenChanged(MediaBrowser2 browser, String parentId, int itemCount, LibraryParams params) {
            assertEquals(expectedParentId, parentId);
            assertEquals(NOTIFY_CHILDREN_CHANGED_ITEM_COUNT, itemCount);
            assertLibraryParamsWithBundle(params, NOTIFY_CHILDREN_CHANGED_EXTRAS);
            latch.countDown();
        }
    };
    BrowserResult result = createBrowser(controllerCallbackProxy).subscribe(expectedParentId, null).get(TIMEOUT_MS, TimeUnit.MILLISECONDS);
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    // The MediaLibrarySession in MockMediaLibraryService2 is supposed to call
    // notifyChildrenChanged(ControllerInfo) in its callback onSubscribe().
    assertTrue(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
}
#end_block

#method_before
@Test
public void testOnChildrenChanged_notCalledWhenNotSubscribed() throws Exception {
    // This test uses MediaLibrarySession.notifyChildrenChanged().
    prepareLooper();
    final String subscribedMediaId = SUBSCRIBE_ID_NOTIFY_CHILDREN_CHANGED_TO_ALL_WITH_NON_SUBSCRIBED_ID;
    final CountDownLatch latch = new CountDownLatch(1);
    final BrowserCallback controllerCallbackProxy = new BrowserCallback() {

        @Override
        public void onChildrenChanged(MediaBrowser2 browser, String parentId, int itemCount, LibraryParams params) {
            // Unexpected call.
            fail();
            latch.countDown();
        }
    };
    BrowserResult result = createBrowser(controllerCallbackProxy).subscribe(subscribedMediaId, null).get(WAIT_TIME_MS, TimeUnit.MILLISECONDS);
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    // The MediaLibrarySession in MockMediaLibraryService2 is supposed to call
    // notifyChildrenChanged() in its callback onSubscribe(), but with a different media ID.
    // Therefore, onChildrenChanged() should not be called.
    assertFalse(latch.await(WAIT_TIME_MS, TimeUnit.MILLISECONDS));
}
#method_after
@Test
public void testOnChildrenChanged_notCalledWhenNotSubscribed() throws Exception {
    // This test uses MediaLibrarySession.notifyChildrenChanged().
    prepareLooper();
    final String subscribedMediaId = SUBSCRIBE_ID_NOTIFY_CHILDREN_CHANGED_TO_ALL_WITH_NON_SUBSCRIBED_ID;
    final CountDownLatch latch = new CountDownLatch(1);
    final BrowserCallback controllerCallbackProxy = new BrowserCallback() {

        @Override
        public void onChildrenChanged(MediaBrowser2 browser, String parentId, int itemCount, LibraryParams params) {
            // Unexpected call.
            fail();
            latch.countDown();
        }
    };
    BrowserResult result = createBrowser(controllerCallbackProxy).subscribe(subscribedMediaId, null).get(TIMEOUT_MS, TimeUnit.MILLISECONDS);
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    // The MediaLibrarySession in MockMediaLibraryService2 is supposed to call
    // notifyChildrenChanged() in its callback onSubscribe(), but with a different media ID.
    // Therefore, onChildrenChanged() should not be called.
    assertFalse(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
}
#end_block

#method_before
@Test
public void testOnChildrenChanged_notCalledWhenNotSubscribed2() throws Exception {
    // This test uses MediaLibrarySession.notifyChildrenChanged(ControllerInfo).
    prepareLooper();
    final String subscribedMediaId = SUBSCRIBE_ID_NOTIFY_CHILDREN_CHANGED_TO_ONE_WITH_NON_SUBSCRIBED_ID;
    final CountDownLatch latch = new CountDownLatch(1);
    final BrowserCallback controllerCallbackProxy = new BrowserCallback() {

        @Override
        public void onChildrenChanged(MediaBrowser2 browser, String parentId, int itemCount, LibraryParams params) {
            // Unexpected call.
            fail();
            latch.countDown();
        }
    };
    BrowserResult result = createBrowser(controllerCallbackProxy).subscribe(subscribedMediaId, null).get(WAIT_TIME_MS, TimeUnit.MILLISECONDS);
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    // The MediaLibrarySession in MockMediaLibraryService2 is supposed to call
    // notifyChildrenChanged(ControllerInfo) in its callback onSubscribe(),
    // but with a different media ID.
    // Therefore, onChildrenChanged() should not be called.
    assertFalse(latch.await(WAIT_TIME_MS, TimeUnit.MILLISECONDS));
}
#method_after
@Test
public void testOnChildrenChanged_notCalledWhenNotSubscribed2() throws Exception {
    // This test uses MediaLibrarySession.notifyChildrenChanged(ControllerInfo).
    prepareLooper();
    final String subscribedMediaId = SUBSCRIBE_ID_NOTIFY_CHILDREN_CHANGED_TO_ONE_WITH_NON_SUBSCRIBED_ID;
    final CountDownLatch latch = new CountDownLatch(1);
    final BrowserCallback controllerCallbackProxy = new BrowserCallback() {

        @Override
        public void onChildrenChanged(MediaBrowser2 browser, String parentId, int itemCount, LibraryParams params) {
            // Unexpected call.
            fail();
            latch.countDown();
        }
    };
    BrowserResult result = createBrowser(controllerCallbackProxy).subscribe(subscribedMediaId, null).get(TIMEOUT_MS, TimeUnit.MILLISECONDS);
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    // The MediaLibrarySession in MockMediaLibraryService2 is supposed to call
    // notifyChildrenChanged(ControllerInfo) in its callback onSubscribe(),
    // but with a different media ID.
    // Therefore, onChildrenChanged() should not be called.
    assertFalse(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
}
#end_block

#method_before
@Override
public void waitForConnect(boolean expect) throws InterruptedException {
    if (expect) {
        assertTrue(connectLatch.await(WAIT_TIME_MS, TimeUnit.MILLISECONDS));
    } else {
        assertFalse(connectLatch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
    }
}
#method_after
@Override
public void waitForConnect(boolean expect) throws InterruptedException {
    if (expect) {
        assertTrue(connectLatch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
    } else {
        assertFalse(connectLatch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
    }
}
#end_block

#method_before
@Override
public void waitForDisconnect(boolean expect) throws InterruptedException {
    if (expect) {
        assertTrue(disconnectLatch.await(WAIT_TIME_MS, TimeUnit.MILLISECONDS));
    } else {
        assertFalse(disconnectLatch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
    }
}
#method_after
@Override
public void waitForDisconnect(boolean expect) throws InterruptedException {
    if (expect) {
        assertTrue(disconnectLatch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
    } else {
        assertFalse(disconnectLatch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
    }
}
#end_block

#method_before
@Test
public void testGetLibraryRoot() throws Exception {
    prepareLooper();
    final LibraryParams params = TestUtils.createLibraryParams();
    MockMediaLibraryService2.setAssertLibraryParams(params);
    BrowserResult result = createBrowser().getLibraryRoot(params).get(WAIT_TIME_MS, TimeUnit.MILLISECONDS);
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertMediaItemEquals(MockMediaLibraryService2.ROOT_ITEM, result.getMediaItem());
    assertLibraryParamsEquals(MockMediaLibraryService2.ROOT_PARAMS, result.getLibraryParams());
}
#method_after
@Test
public void testGetLibraryRoot() throws Exception {
    prepareLooper();
    final LibraryParams params = TestUtils.createLibraryParams();
    MockMediaLibraryService2.setAssertLibraryParams(params);
    BrowserResult result = createBrowser().getLibraryRoot(params).get(TIMEOUT_MS, TimeUnit.MILLISECONDS);
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertMediaItemEquals(MockMediaLibraryService2.ROOT_ITEM, result.getMediaItem());
    assertLibraryParamsEquals(MockMediaLibraryService2.ROOT_PARAMS, result.getLibraryParams());
}
#end_block

#method_before
@Test
public void testGetItem() throws Exception {
    prepareLooper();
    final String mediaId = MockMediaLibraryService2.MEDIA_ID_GET_ITEM;
    BrowserResult result = createBrowser().getItem(mediaId).get(WAIT_TIME_MS, TimeUnit.MILLISECONDS);
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertMediaItemWithId(mediaId, result.getMediaItem());
}
#method_after
@Test
public void testGetItem() throws Exception {
    prepareLooper();
    final String mediaId = MockMediaLibraryService2.MEDIA_ID_GET_ITEM;
    BrowserResult result = createBrowser().getItem(mediaId).get(TIMEOUT_MS, TimeUnit.MILLISECONDS);
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertMediaItemWithId(mediaId, result.getMediaItem());
}
#end_block

#method_before
@Test
public void testGetItemNullResult() throws Exception {
    prepareLooper();
    final String mediaId = "random_media_id";
    BrowserResult result = createBrowser().getItem(mediaId).get(WAIT_TIME_MS, TimeUnit.MILLISECONDS);
    assertNotEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertNull(result.getMediaItem());
}
#method_after
@Test
public void testGetItemNullResult() throws Exception {
    prepareLooper();
    final String mediaId = "random_media_id";
    BrowserResult result = createBrowser().getItem(mediaId).get(TIMEOUT_MS, TimeUnit.MILLISECONDS);
    assertNotEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertNull(result.getMediaItem());
}
#end_block

#method_before
@Test
public void testGetChildren() throws Exception {
    prepareLooper();
    final String parentId = MockMediaLibraryService2.PARENT_ID;
    final int page = 4;
    final int pageSize = 10;
    final LibraryParams params = TestUtils.createLibraryParams();
    MockMediaLibraryService2.setAssertLibraryParams(params);
    BrowserResult result = createBrowser().getChildren(parentId, page, pageSize, params).get(WAIT_TIME_MS, TimeUnit.MILLISECONDS);
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    TestUtils.assertPaginatedListEquals(MockMediaLibraryService2.GET_CHILDREN_RESULT, page, pageSize, result.getMediaItems());
}
#method_after
@Test
public void testGetChildren() throws Exception {
    prepareLooper();
    final String parentId = MockMediaLibraryService2.PARENT_ID;
    final int page = 4;
    final int pageSize = 10;
    final LibraryParams params = TestUtils.createLibraryParams();
    MockMediaLibraryService2.setAssertLibraryParams(params);
    BrowserResult result = createBrowser().getChildren(parentId, page, pageSize, params).get(TIMEOUT_MS, TimeUnit.MILLISECONDS);
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    TestUtils.assertPaginatedListEquals(MockMediaLibraryService2.GET_CHILDREN_RESULT, page, pageSize, result.getMediaItems());
}
#end_block

#method_before
@Test
public void testGetChildrenEmptyResult() throws Exception {
    prepareLooper();
    final String parentId = MockMediaLibraryService2.PARENT_ID_NO_CHILDREN;
    BrowserResult result = createBrowser().getChildren(parentId, 1, 1, null).get(WAIT_TIME_MS, TimeUnit.MILLISECONDS);
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertEquals(0, result.getMediaItems().size());
}
#method_after
@Test
public void testGetChildrenEmptyResult() throws Exception {
    prepareLooper();
    final String parentId = MockMediaLibraryService2.PARENT_ID_NO_CHILDREN;
    BrowserResult result = createBrowser().getChildren(parentId, 1, 1, null).get(TIMEOUT_MS, TimeUnit.MILLISECONDS);
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertEquals(0, result.getMediaItems().size());
}
#end_block

#method_before
@Test
public void testGetChildrenNullResult() throws Exception {
    prepareLooper();
    final String parentId = MockMediaLibraryService2.PARENT_ID_ERROR;
    BrowserResult result = createBrowser().getChildren(parentId, 1, 1, null).get(WAIT_TIME_MS, TimeUnit.MILLISECONDS);
    assertNotEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertNull(result.getMediaItems());
}
#method_after
@Test
public void testGetChildrenNullResult() throws Exception {
    prepareLooper();
    final String parentId = MockMediaLibraryService2.PARENT_ID_ERROR;
    BrowserResult result = createBrowser().getChildren(parentId, 1, 1, null).get(TIMEOUT_MS, TimeUnit.MILLISECONDS);
    assertNotEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertNull(result.getMediaItems());
}
#end_block

#method_before
@Test
public void testSearch() throws Exception {
    prepareLooper();
    final String query = MockMediaLibraryService2.SEARCH_QUERY;
    final int page = 4;
    final int pageSize = 10;
    final LibraryParams params = TestUtils.createLibraryParams();
    final CountDownLatch latchForSearch = new CountDownLatch(1);
    final BrowserCallback callback = new BrowserCallback() {

        @Override
        public void onSearchResultChanged(MediaBrowser2 browser, String queryOut, int itemCount, LibraryParams paramsOut) {
            assertEquals(query, queryOut);
            assertLibraryParamsEquals(params, paramsOut);
            assertEquals(MockMediaLibraryService2.SEARCH_RESULT_COUNT, itemCount);
            latchForSearch.countDown();
        }
    };
    // Request the search.
    MockMediaLibraryService2.setAssertLibraryParams(params);
    MediaBrowser2 browser = createBrowser(callback);
    BrowserResult result = browser.search(query, params).get(WAIT_TIME_MS, TimeUnit.MILLISECONDS);
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertTrue(latchForSearch.await(WAIT_TIME_MS, TimeUnit.MILLISECONDS));
    // Get the search result.
    result = browser.getSearchResult(query, page, pageSize, params).get(WAIT_TIME_MS, TimeUnit.MILLISECONDS);
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    TestUtils.assertPaginatedListEquals(MockMediaLibraryService2.SEARCH_RESULT, page, pageSize, result.getMediaItems());
}
#method_after
@Test
public void testSearch() throws Exception {
    prepareLooper();
    final String query = MockMediaLibraryService2.SEARCH_QUERY;
    final int page = 4;
    final int pageSize = 10;
    final LibraryParams params = TestUtils.createLibraryParams();
    final CountDownLatch latchForSearch = new CountDownLatch(1);
    final BrowserCallback callback = new BrowserCallback() {

        @Override
        public void onSearchResultChanged(MediaBrowser2 browser, String queryOut, int itemCount, LibraryParams paramsOut) {
            assertEquals(query, queryOut);
            assertLibraryParamsEquals(params, paramsOut);
            assertEquals(MockMediaLibraryService2.SEARCH_RESULT_COUNT, itemCount);
            latchForSearch.countDown();
        }
    };
    // Request the search.
    MockMediaLibraryService2.setAssertLibraryParams(params);
    MediaBrowser2 browser = createBrowser(callback);
    BrowserResult result = browser.search(query, params).get(TIMEOUT_MS, TimeUnit.MILLISECONDS);
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertTrue(latchForSearch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
    // Get the search result.
    result = browser.getSearchResult(query, page, pageSize, params).get(TIMEOUT_MS, TimeUnit.MILLISECONDS);
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    TestUtils.assertPaginatedListEquals(MockMediaLibraryService2.SEARCH_RESULT, page, pageSize, result.getMediaItems());
}
#end_block

#method_before
@Test
@LargeTest
public void testSearchTakesTime() throws Exception {
    prepareLooper();
    final String query = MockMediaLibraryService2.SEARCH_QUERY_TAKES_TIME;
    final LibraryParams params = createLibraryParams();
    final CountDownLatch latch = new CountDownLatch(1);
    final BrowserCallback callback = new BrowserCallback() {

        @Override
        public void onSearchResultChanged(MediaBrowser2 browser, String queryOut, int itemCount, LibraryParams paramsOut) {
            assertEquals(query, queryOut);
            assertLibraryParamsEquals(params, paramsOut);
            assertEquals(MockMediaLibraryService2.SEARCH_RESULT_COUNT, itemCount);
            latch.countDown();
        }
    };
    MockMediaLibraryService2.setAssertLibraryParams(params);
    BrowserResult result = createBrowser(callback).search(query, params).get(WAIT_TIME_MS, TimeUnit.MILLISECONDS);
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertTrue(latch.await(MockMediaLibraryService2.SEARCH_TIME_IN_MS + WAIT_TIME_MS, TimeUnit.MILLISECONDS));
}
#method_after
@Test
@LargeTest
public void testSearchTakesTime() throws Exception {
    prepareLooper();
    final String query = MockMediaLibraryService2.SEARCH_QUERY_TAKES_TIME;
    final LibraryParams params = createLibraryParams();
    final CountDownLatch latch = new CountDownLatch(1);
    final BrowserCallback callback = new BrowserCallback() {

        @Override
        public void onSearchResultChanged(MediaBrowser2 browser, String queryOut, int itemCount, LibraryParams paramsOut) {
            assertEquals(query, queryOut);
            assertLibraryParamsEquals(params, paramsOut);
            assertEquals(MockMediaLibraryService2.SEARCH_RESULT_COUNT, itemCount);
            latch.countDown();
        }
    };
    MockMediaLibraryService2.setAssertLibraryParams(params);
    BrowserResult result = createBrowser(callback).search(query, params).get(TIMEOUT_MS, TimeUnit.MILLISECONDS);
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertTrue(latch.await(MockMediaLibraryService2.SEARCH_TIME_IN_MS + TIMEOUT_MS, TimeUnit.MILLISECONDS));
}
#end_block

#method_before
@Test
public void testSearchEmptyResult() throws Exception {
    prepareLooper();
    final String query = MockMediaLibraryService2.SEARCH_QUERY_EMPTY_RESULT;
    final LibraryParams params = TestUtils.createLibraryParams();
    final CountDownLatch latch = new CountDownLatch(1);
    final BrowserCallback callback = new BrowserCallback() {

        @Override
        public void onSearchResultChanged(MediaBrowser2 browser, String queryOut, int itemCount, LibraryParams paramsOut) {
            assertEquals(query, queryOut);
            assertLibraryParamsEquals(params, paramsOut);
            assertEquals(0, itemCount);
            latch.countDown();
        }
    };
    MockMediaLibraryService2.setAssertLibraryParams(params);
    BrowserResult result = createBrowser(callback).search(query, params).get(WAIT_TIME_MS, TimeUnit.MILLISECONDS);
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertTrue(latch.await(WAIT_TIME_MS, TimeUnit.MILLISECONDS));
}
#method_after
@Test
public void testSearchEmptyResult() throws Exception {
    prepareLooper();
    final String query = MockMediaLibraryService2.SEARCH_QUERY_EMPTY_RESULT;
    final LibraryParams params = TestUtils.createLibraryParams();
    final CountDownLatch latch = new CountDownLatch(1);
    final BrowserCallback callback = new BrowserCallback() {

        @Override
        public void onSearchResultChanged(MediaBrowser2 browser, String queryOut, int itemCount, LibraryParams paramsOut) {
            assertEquals(query, queryOut);
            assertLibraryParamsEquals(params, paramsOut);
            assertEquals(0, itemCount);
            latch.countDown();
        }
    };
    MockMediaLibraryService2.setAssertLibraryParams(params);
    BrowserResult result = createBrowser(callback).search(query, params).get(TIMEOUT_MS, TimeUnit.MILLISECONDS);
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertTrue(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
}
#end_block

#method_before
@Test
public void testSubscribe() throws Exception {
    prepareLooper();
    final String testParentId = "testSubscribeId";
    final LibraryParams params = createLibraryParams();
    final MediaLibrarySessionCallback callback = new MediaLibrarySessionCallback() {

        @Override
        public int onSubscribe(@NonNull MediaLibraryService2.MediaLibrarySession session, @NonNull MediaSession2.ControllerInfo info, @NonNull String parentId, @Nullable LibraryParams paramsOut) {
            if (Process.myUid() == info.getUid()) {
                assertEquals(testParentId, parentId);
                assertLibraryParamsEquals(params, paramsOut);
                return RESULT_CODE_SUCCESS;
            }
            return RESULT_CODE_PERMISSION_DENIED;
        }
    };
    TestServiceRegistry.getInstance().setSessionCallback(callback);
    MockMediaLibraryService2.setAssertLibraryParams(params);
    BrowserResult result = createBrowser().subscribe(testParentId, params).get(WAIT_TIME_MS, TimeUnit.MILLISECONDS);
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertNull(result.getMediaItems());
}
#method_after
@Test
public void testSubscribe() throws Exception {
    prepareLooper();
    final String testParentId = "testSubscribeId";
    final LibraryParams params = createLibraryParams();
    final MediaLibrarySessionCallback callback = new MediaLibrarySessionCallback() {

        @Override
        public int onSubscribe(@NonNull MediaLibraryService2.MediaLibrarySession session, @NonNull MediaSession2.ControllerInfo info, @NonNull String parentId, @Nullable LibraryParams paramsOut) {
            if (Process.myUid() == info.getUid()) {
                assertEquals(testParentId, parentId);
                assertLibraryParamsEquals(params, paramsOut);
                return RESULT_CODE_SUCCESS;
            }
            return RESULT_CODE_PERMISSION_DENIED;
        }
    };
    TestServiceRegistry.getInstance().setSessionCallback(callback);
    MockMediaLibraryService2.setAssertLibraryParams(params);
    BrowserResult result = createBrowser().subscribe(testParentId, params).get(TIMEOUT_MS, TimeUnit.MILLISECONDS);
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertNull(result.getMediaItems());
}
#end_block

#method_before
@Test
public void testUnsubscribe() throws Exception {
    prepareLooper();
    final String testParentId = "testUnsubscribeId";
    final MediaLibrarySessionCallback callback = new MediaLibrarySessionCallback() {

        @Override
        public int onUnsubscribe(@NonNull MediaLibrarySession session, @NonNull ControllerInfo info, @NonNull String parentId) {
            if (Process.myUid() == info.getUid()) {
                assertEquals(testParentId, parentId);
                return RESULT_CODE_SUCCESS;
            }
            return RESULT_CODE_PERMISSION_DENIED;
        }
    };
    TestServiceRegistry.getInstance().setSessionCallback(callback);
    BrowserResult result = createBrowser().unsubscribe(testParentId).get(WAIT_TIME_MS, TimeUnit.MILLISECONDS);
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertNull(result.getMediaItems());
}
#method_after
@Test
public void testUnsubscribe() throws Exception {
    prepareLooper();
    final String testParentId = "testUnsubscribeId";
    final MediaLibrarySessionCallback callback = new MediaLibrarySessionCallback() {

        @Override
        public int onUnsubscribe(@NonNull MediaLibrarySession session, @NonNull ControllerInfo info, @NonNull String parentId) {
            if (Process.myUid() == info.getUid()) {
                assertEquals(testParentId, parentId);
                return RESULT_CODE_SUCCESS;
            }
            return RESULT_CODE_PERMISSION_DENIED;
        }
    };
    TestServiceRegistry.getInstance().setSessionCallback(callback);
    BrowserResult result = createBrowser().unsubscribe(testParentId).get(TIMEOUT_MS, TimeUnit.MILLISECONDS);
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertNull(result.getMediaItems());
}
#end_block

#method_before
@Test
public void testBrowserCallback_onChildrenChangedIsNotCalledWhenNotSubscribed() throws Exception {
    // This test uses MediaLibrarySession.notifyChildrenChanged().
    prepareLooper();
    final String subscribedMediaId = "subscribedMediaId";
    final String anotherMediaId = "anotherMediaId";
    final int testChildrenCount = 101;
    final MediaLibrarySessionCallback sessionCallback = new MediaLibrarySessionCallback() {

        @Override
        public int onSubscribe(@NonNull MediaLibrarySession session, @NonNull ControllerInfo controller, @NonNull String parentId, @Nullable LibraryParams params) {
            if (Process.myUid() == controller.getUid()) {
                // Shouldn't trigger onChildrenChanged() for the browser,
                // because the browser didn't subscribe this media id.
                session.notifyChildrenChanged(anotherMediaId, testChildrenCount, null);
            }
            return RESULT_CODE_SUCCESS;
        }

        @Override
        public LibraryResult onGetChildren(MediaLibrarySession session, ControllerInfo controller, String parentId, int page, int pageSize, LibraryParams params) {
            // This wouldn't be called at all.
            return new LibraryResult(RESULT_CODE_SUCCESS, TestUtils.createPlaylist(testChildrenCount), null);
        }
    };
    final CountDownLatch latch = new CountDownLatch(1);
    final BrowserCallback controllerCallbackProxy = new BrowserCallback() {

        @Override
        public void onChildrenChanged(MediaBrowser2 browser, String parentId, int itemCount, LibraryParams params) {
            // Unexpected call.
            fail();
            latch.countDown();
        }
    };
    TestServiceRegistry.getInstance().setSessionCallback(sessionCallback);
    BrowserResult result = createBrowser(controllerCallbackProxy).subscribe(subscribedMediaId, null).get(WAIT_TIME_MS, TimeUnit.MILLISECONDS);
    // Subscribe itself is success because onSubscribe() returned SUCCESS.
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    // notifyChildrenChanged() in onSubscribe() should fail onChildrenChanged() should not be
    // called, because the ID hasn't been subscribed.
    assertFalse(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
}
#method_after
@Test
public void testBrowserCallback_onChildrenChangedIsNotCalledWhenNotSubscribed() throws Exception {
    // This test uses MediaLibrarySession.notifyChildrenChanged().
    prepareLooper();
    final String subscribedMediaId = "subscribedMediaId";
    final String anotherMediaId = "anotherMediaId";
    final int testChildrenCount = 101;
    final MediaLibrarySessionCallback sessionCallback = new MediaLibrarySessionCallback() {

        @Override
        public int onSubscribe(@NonNull MediaLibrarySession session, @NonNull ControllerInfo controller, @NonNull String parentId, @Nullable LibraryParams params) {
            if (Process.myUid() == controller.getUid()) {
                // Shouldn't trigger onChildrenChanged() for the browser,
                // because the browser didn't subscribe this media id.
                session.notifyChildrenChanged(anotherMediaId, testChildrenCount, null);
            }
            return RESULT_CODE_SUCCESS;
        }

        @Override
        public LibraryResult onGetChildren(MediaLibrarySession session, ControllerInfo controller, String parentId, int page, int pageSize, LibraryParams params) {
            // This wouldn't be called at all.
            return new LibraryResult(RESULT_CODE_SUCCESS, TestUtils.createPlaylist(testChildrenCount), null);
        }
    };
    final CountDownLatch latch = new CountDownLatch(1);
    final BrowserCallback controllerCallbackProxy = new BrowserCallback() {

        @Override
        public void onChildrenChanged(MediaBrowser2 browser, String parentId, int itemCount, LibraryParams params) {
            // Unexpected call.
            fail();
            latch.countDown();
        }
    };
    TestServiceRegistry.getInstance().setSessionCallback(sessionCallback);
    BrowserResult result = createBrowser(controllerCallbackProxy).subscribe(subscribedMediaId, null).get(TIMEOUT_MS, TimeUnit.MILLISECONDS);
    // Subscribe itself is success because onSubscribe() returned SUCCESS.
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    // notifyChildrenChanged() in onSubscribe() should fail onChildrenChanged() should not be
    // called, because the ID hasn't been subscribed.
    assertFalse(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
}
#end_block

#method_before
@Test
public void testBrowserCallback_onChildrenChangedIsCalledWhenSubscribed() throws InterruptedException {
    // This test uses MediaLibrarySession.notifyChildrenChanged().
    prepareLooper();
    final String expectedParentId = "expectedParentId";
    final int testChildrenCount = 101;
    final LibraryParams testParams = createLibraryParams();
    final CountDownLatch latch = new CountDownLatch(1);
    final MediaLibrarySessionCallback sessionCallback = new MediaLibrarySessionCallback() {

        @Override
        public int onSubscribe(@NonNull MediaLibrarySession session, @NonNull ControllerInfo controller, @NonNull String parentId, @Nullable LibraryParams params) {
            if (Process.myUid() == controller.getUid()) {
                // Should trigger onChildrenChanged() for the browser.
                session.notifyChildrenChanged(expectedParentId, testChildrenCount, params);
            }
            return RESULT_CODE_SUCCESS;
        }

        @Override
        public LibraryResult onGetChildren(MediaLibrarySession session, ControllerInfo controller, String parentId, int page, int pageSize, LibraryParams params) {
            return new LibraryResult(RESULT_CODE_SUCCESS, TestUtils.createPlaylist(testChildrenCount), null);
        }
    };
    final BrowserCallback controllerCallbackProxy = new BrowserCallback() {

        @Override
        public void onChildrenChanged(MediaBrowser2 browser, String parentId, int itemCount, LibraryParams params) {
            assertEquals(expectedParentId, parentId);
            assertEquals(testChildrenCount, itemCount);
            assertLibraryParamsEquals(testParams, params);
            latch.countDown();
        }
    };
    TestServiceRegistry.getInstance().setSessionCallback(sessionCallback);
    MockMediaLibraryService2.setAssertLibraryParams(testParams);
    createBrowser(controllerCallbackProxy).subscribe(expectedParentId, testParams);
    // onChildrenChanged() should be called.
    assertTrue(latch.await(WAIT_TIME_MS, TimeUnit.MILLISECONDS));
}
#method_after
@Test
public void testBrowserCallback_onChildrenChangedIsCalledWhenSubscribed() throws InterruptedException {
    // This test uses MediaLibrarySession.notifyChildrenChanged().
    prepareLooper();
    final String expectedParentId = "expectedParentId";
    final int testChildrenCount = 101;
    final LibraryParams testParams = createLibraryParams();
    final CountDownLatch latch = new CountDownLatch(1);
    final MediaLibrarySessionCallback sessionCallback = new MediaLibrarySessionCallback() {

        @Override
        public int onSubscribe(@NonNull MediaLibrarySession session, @NonNull ControllerInfo controller, @NonNull String parentId, @Nullable LibraryParams params) {
            if (Process.myUid() == controller.getUid()) {
                // Should trigger onChildrenChanged() for the browser.
                session.notifyChildrenChanged(expectedParentId, testChildrenCount, params);
            }
            return RESULT_CODE_SUCCESS;
        }

        @Override
        public LibraryResult onGetChildren(MediaLibrarySession session, ControllerInfo controller, String parentId, int page, int pageSize, LibraryParams params) {
            return new LibraryResult(RESULT_CODE_SUCCESS, TestUtils.createPlaylist(testChildrenCount), null);
        }
    };
    final BrowserCallback controllerCallbackProxy = new BrowserCallback() {

        @Override
        public void onChildrenChanged(MediaBrowser2 browser, String parentId, int itemCount, LibraryParams params) {
            assertEquals(expectedParentId, parentId);
            assertEquals(testChildrenCount, itemCount);
            assertLibraryParamsEquals(testParams, params);
            latch.countDown();
        }
    };
    TestServiceRegistry.getInstance().setSessionCallback(sessionCallback);
    MockMediaLibraryService2.setAssertLibraryParams(testParams);
    createBrowser(controllerCallbackProxy).subscribe(expectedParentId, testParams);
    // onChildrenChanged() should be called.
    assertTrue(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
}
#end_block

#method_before
@Test
public void testBrowserCallback_onChildrenChangedIsNotCalledWhenNotSubscribed2() throws Exception {
    // This test uses MediaLibrarySession.notifyChildrenChanged(ControllerInfo).
    prepareLooper();
    final String subscribedMediaId = "subscribedMediaId";
    final String anotherMediaId = "anotherMediaId";
    final int testChildrenCount = 101;
    final MediaLibrarySessionCallback sessionCallback = new MediaLibrarySessionCallback() {

        @Override
        public int onSubscribe(@NonNull MediaLibrarySession session, @NonNull ControllerInfo controller, @NonNull String parentId, @Nullable LibraryParams params) {
            if (Process.myUid() == controller.getUid()) {
                // Shouldn't trigger onChildrenChanged() for the browser,
                // because the browser didn't subscribe this media id.
                session.notifyChildrenChanged(controller, anotherMediaId, testChildrenCount, null);
            }
            return RESULT_CODE_SUCCESS;
        }

        @Override
        public LibraryResult onGetChildren(MediaLibrarySession session, ControllerInfo controller, String parentId, int page, int pageSize, LibraryParams params) {
            return new LibraryResult(RESULT_CODE_SUCCESS, TestUtils.createPlaylist(testChildrenCount), null);
        }
    };
    final CountDownLatch latch = new CountDownLatch(1);
    final BrowserCallback controllerCallbackProxy = new BrowserCallback() {

        @Override
        public void onChildrenChanged(MediaBrowser2 browser, String parentId, int itemCount, LibraryParams params) {
            // Unexpected call.
            fail();
            latch.countDown();
        }
    };
    TestServiceRegistry.getInstance().setSessionCallback(sessionCallback);
    BrowserResult result = createBrowser(controllerCallbackProxy).subscribe(subscribedMediaId, null).get(WAIT_TIME_MS, TimeUnit.MILLISECONDS);
    // onSubscribe() always returns SUCCESS, so success is expected.
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    // But onChildrenChanged() wouldn't be called because notifyChildrenChanged() fails.
    assertFalse(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
}
#method_after
@Test
public void testBrowserCallback_onChildrenChangedIsNotCalledWhenNotSubscribed2() throws Exception {
    // This test uses MediaLibrarySession.notifyChildrenChanged(ControllerInfo).
    prepareLooper();
    final String subscribedMediaId = "subscribedMediaId";
    final String anotherMediaId = "anotherMediaId";
    final int testChildrenCount = 101;
    final MediaLibrarySessionCallback sessionCallback = new MediaLibrarySessionCallback() {

        @Override
        public int onSubscribe(@NonNull MediaLibrarySession session, @NonNull ControllerInfo controller, @NonNull String parentId, @Nullable LibraryParams params) {
            if (Process.myUid() == controller.getUid()) {
                // Shouldn't trigger onChildrenChanged() for the browser,
                // because the browser didn't subscribe this media id.
                session.notifyChildrenChanged(controller, anotherMediaId, testChildrenCount, null);
            }
            return RESULT_CODE_SUCCESS;
        }

        @Override
        public LibraryResult onGetChildren(MediaLibrarySession session, ControllerInfo controller, String parentId, int page, int pageSize, LibraryParams params) {
            return new LibraryResult(RESULT_CODE_SUCCESS, TestUtils.createPlaylist(testChildrenCount), null);
        }
    };
    final CountDownLatch latch = new CountDownLatch(1);
    final BrowserCallback controllerCallbackProxy = new BrowserCallback() {

        @Override
        public void onChildrenChanged(MediaBrowser2 browser, String parentId, int itemCount, LibraryParams params) {
            // Unexpected call.
            fail();
            latch.countDown();
        }
    };
    TestServiceRegistry.getInstance().setSessionCallback(sessionCallback);
    BrowserResult result = createBrowser(controllerCallbackProxy).subscribe(subscribedMediaId, null).get(TIMEOUT_MS, TimeUnit.MILLISECONDS);
    // onSubscribe() always returns SUCCESS, so success is expected.
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    // But onChildrenChanged() wouldn't be called because notifyChildrenChanged() fails.
    assertFalse(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
}
#end_block

#method_before
@Test
public void testBrowserCallback_onChildrenChangedIsCalledWhenSubscribed2() throws InterruptedException {
    // This test uses MediaLibrarySession.notifyChildrenChanged(ControllerInfo).
    prepareLooper();
    final String expectedParentId = "expectedParentId";
    final int testChildrenCount = 101;
    final LibraryParams testParams = createLibraryParams();
    final CountDownLatch latch = new CountDownLatch(1);
    final MediaLibrarySessionCallback sessionCallback = new MediaLibrarySessionCallback() {

        @Override
        public int onSubscribe(@NonNull MediaLibrarySession session, @NonNull ControllerInfo controller, @NonNull String parentId, @Nullable LibraryParams params) {
            if (Process.myUid() == controller.getUid()) {
                // Should trigger onChildrenChanged() for the browser.
                session.notifyChildrenChanged(controller, expectedParentId, testChildrenCount, testParams);
            }
            return RESULT_CODE_SUCCESS;
        }

        @Override
        public LibraryResult onGetChildren(MediaLibrarySession session, ControllerInfo controller, String parentId, int page, int pageSize, LibraryParams params) {
            return new LibraryResult(RESULT_CODE_SUCCESS, TestUtils.createPlaylist(testChildrenCount), null);
        }
    };
    final BrowserCallback controllerCallbackProxy = new BrowserCallback() {

        @Override
        public void onChildrenChanged(MediaBrowser2 browser, String parentId, int itemCount, LibraryParams params) {
            assertEquals(expectedParentId, parentId);
            assertEquals(testChildrenCount, itemCount);
            assertLibraryParamsEquals(testParams, params);
            latch.countDown();
        }
    };
    TestServiceRegistry.getInstance().setSessionCallback(sessionCallback);
    createBrowser(controllerCallbackProxy).subscribe(expectedParentId, null);
    // onChildrenChanged() should be called.
    assertTrue(latch.await(WAIT_TIME_MS, TimeUnit.MILLISECONDS));
}
#method_after
@Test
public void testBrowserCallback_onChildrenChangedIsCalledWhenSubscribed2() throws InterruptedException {
    // This test uses MediaLibrarySession.notifyChildrenChanged(ControllerInfo).
    prepareLooper();
    final String expectedParentId = "expectedParentId";
    final int testChildrenCount = 101;
    final LibraryParams testParams = createLibraryParams();
    final CountDownLatch latch = new CountDownLatch(1);
    final MediaLibrarySessionCallback sessionCallback = new MediaLibrarySessionCallback() {

        @Override
        public int onSubscribe(@NonNull MediaLibrarySession session, @NonNull ControllerInfo controller, @NonNull String parentId, @Nullable LibraryParams params) {
            if (Process.myUid() == controller.getUid()) {
                // Should trigger onChildrenChanged() for the browser.
                session.notifyChildrenChanged(controller, expectedParentId, testChildrenCount, testParams);
            }
            return RESULT_CODE_SUCCESS;
        }

        @Override
        public LibraryResult onGetChildren(MediaLibrarySession session, ControllerInfo controller, String parentId, int page, int pageSize, LibraryParams params) {
            return new LibraryResult(RESULT_CODE_SUCCESS, TestUtils.createPlaylist(testChildrenCount), null);
        }
    };
    final BrowserCallback controllerCallbackProxy = new BrowserCallback() {

        @Override
        public void onChildrenChanged(MediaBrowser2 browser, String parentId, int itemCount, LibraryParams params) {
            assertEquals(expectedParentId, parentId);
            assertEquals(testChildrenCount, itemCount);
            assertLibraryParamsEquals(testParams, params);
            latch.countDown();
        }
    };
    TestServiceRegistry.getInstance().setSessionCallback(sessionCallback);
    createBrowser(controllerCallbackProxy).subscribe(expectedParentId, null);
    // onChildrenChanged() should be called.
    assertTrue(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
}
#end_block

#method_before
@Override
public ListenableFuture<BrowserResult> getLibraryRoot(final LibraryParams params) {
    return sendCommand(COMMAND_CODE_LIBRARY_GET_LIBRARY_ROOT, new SessionCommand() {

        @Override
        public void run(IMediaSession2 iSession2, int seq) throws RemoteException {
            iSession2.getLibraryRoot(mControllerStub, seq, (ParcelImpl) ParcelUtils.toParcelable(params));
        }
    });
}
#method_after
@Override
public ListenableFuture<BrowserResult> getLibraryRoot(final LibraryParams params) {
    return dispatchRemoteLibrarySessionTask(COMMAND_CODE_LIBRARY_GET_LIBRARY_ROOT, new RemoteLibrarySessionTask() {

        @Override
        public void run(IMediaSession2 iSession2, int seq) throws RemoteException {
            iSession2.getLibraryRoot(mControllerStub, seq, (ParcelImpl) ParcelUtils.toParcelable(params));
        }
    });
}
#end_block

#method_before
@Override
public ListenableFuture<BrowserResult> subscribe(final String parentId, final LibraryParams params) {
    return sendCommand(COMMAND_CODE_LIBRARY_SUBSCRIBE, new SessionCommand() {

        @Override
        public void run(IMediaSession2 iSession2, int seq) throws RemoteException {
            iSession2.subscribe(mControllerStub, seq, parentId, (ParcelImpl) ParcelUtils.toParcelable(params));
        }
    });
}
#method_after
@Override
public ListenableFuture<BrowserResult> subscribe(final String parentId, final LibraryParams params) {
    return dispatchRemoteLibrarySessionTask(COMMAND_CODE_LIBRARY_SUBSCRIBE, new RemoteLibrarySessionTask() {

        @Override
        public void run(IMediaSession2 iSession2, int seq) throws RemoteException {
            iSession2.subscribe(mControllerStub, seq, parentId, (ParcelImpl) ParcelUtils.toParcelable(params));
        }
    });
}
#end_block

#method_before
@Override
public ListenableFuture<BrowserResult> unsubscribe(final String parentId) {
    return sendCommand(COMMAND_CODE_LIBRARY_UNSUBSCRIBE, new SessionCommand() {

        @Override
        public void run(IMediaSession2 iSession2, int seq) throws RemoteException {
            iSession2.unsubscribe(mControllerStub, seq, parentId);
        }
    });
}
#method_after
@Override
public ListenableFuture<BrowserResult> unsubscribe(final String parentId) {
    return dispatchRemoteLibrarySessionTask(COMMAND_CODE_LIBRARY_UNSUBSCRIBE, new RemoteLibrarySessionTask() {

        @Override
        public void run(IMediaSession2 iSession2, int seq) throws RemoteException {
            iSession2.unsubscribe(mControllerStub, seq, parentId);
        }
    });
}
#end_block

#method_before
@Override
public ListenableFuture<BrowserResult> getChildren(final String parentId, final int page, final int pageSize, final LibraryParams params) {
    return sendCommand(COMMAND_CODE_LIBRARY_GET_CHILDREN, new SessionCommand() {

        @Override
        public void run(IMediaSession2 iSession2, int seq) throws RemoteException {
            iSession2.getChildren(mControllerStub, seq, parentId, page, pageSize, (ParcelImpl) ParcelUtils.toParcelable(params));
        }
    });
}
#method_after
@Override
public ListenableFuture<BrowserResult> getChildren(final String parentId, final int page, final int pageSize, final LibraryParams params) {
    return dispatchRemoteLibrarySessionTask(COMMAND_CODE_LIBRARY_GET_CHILDREN, new RemoteLibrarySessionTask() {

        @Override
        public void run(IMediaSession2 iSession2, int seq) throws RemoteException {
            iSession2.getChildren(mControllerStub, seq, parentId, page, pageSize, (ParcelImpl) ParcelUtils.toParcelable(params));
        }
    });
}
#end_block

#method_before
@Override
public ListenableFuture<BrowserResult> getItem(final String mediaId) {
    return sendCommand(COMMAND_CODE_LIBRARY_GET_ITEM, new SessionCommand() {

        @Override
        public void run(IMediaSession2 iSession2, int seq) throws RemoteException {
            iSession2.getItem(mControllerStub, seq, mediaId);
        }
    });
}
#method_after
@Override
public ListenableFuture<BrowserResult> getItem(final String mediaId) {
    return dispatchRemoteLibrarySessionTask(COMMAND_CODE_LIBRARY_GET_ITEM, new RemoteLibrarySessionTask() {

        @Override
        public void run(IMediaSession2 iSession2, int seq) throws RemoteException {
            iSession2.getItem(mControllerStub, seq, mediaId);
        }
    });
}
#end_block

#method_before
@Override
public ListenableFuture<BrowserResult> search(final String query, final LibraryParams params) {
    return sendCommand(COMMAND_CODE_LIBRARY_SEARCH, new SessionCommand() {

        @Override
        public void run(IMediaSession2 iSession2, int seq) throws RemoteException {
            iSession2.search(mControllerStub, seq, query, (ParcelImpl) ParcelUtils.toParcelable(params));
        }
    });
}
#method_after
@Override
public ListenableFuture<BrowserResult> search(final String query, final LibraryParams params) {
    return dispatchRemoteLibrarySessionTask(COMMAND_CODE_LIBRARY_SEARCH, new RemoteLibrarySessionTask() {

        @Override
        public void run(IMediaSession2 iSession2, int seq) throws RemoteException {
            iSession2.search(mControllerStub, seq, query, (ParcelImpl) ParcelUtils.toParcelable(params));
        }
    });
}
#end_block

#method_before
@Override
public ListenableFuture<BrowserResult> getSearchResult(final String query, final int page, final int pageSize, final LibraryParams params) {
    return sendCommand(COMMAND_CODE_LIBRARY_GET_SEARCH_RESULT, new SessionCommand() {

        @Override
        public void run(IMediaSession2 iSession2, int seq) throws RemoteException {
            iSession2.getSearchResult(mControllerStub, seq, query, page, pageSize, (ParcelImpl) ParcelUtils.toParcelable(params));
        }
    });
}
#method_after
@Override
public ListenableFuture<BrowserResult> getSearchResult(final String query, final int page, final int pageSize, final LibraryParams params) {
    return dispatchRemoteLibrarySessionTask(COMMAND_CODE_LIBRARY_GET_SEARCH_RESULT, new RemoteLibrarySessionTask() {

        @Override
        public void run(IMediaSession2 iSession2, int seq) throws RemoteException {
            iSession2.getSearchResult(mControllerStub, seq, query, page, pageSize, (ParcelImpl) ParcelUtils.toParcelable(params));
        }
    });
}
#end_block

#method_before
@Test
public void testGetLibraryRoot() throws Exception {
    prepareLooper();
    final String testMediaId = "testGetLibraryRoot";
    final Bundle testExtra = new Bundle();
    testExtra.putString(testMediaId, testMediaId);
    final LibraryParams testParams = new LibraryParams.Builder().setExtras(testExtra).setOffline(true).setRecent(true).setSuggested(true).build();
    final BrowserRoot browserRootWithoutParam = new BrowserRoot(testMediaId, null);
    final Bundle testReturnedExtra = new Bundle(testExtra);
    testReturnedExtra.putBoolean(BrowserRoot.EXTRA_OFFLINE, true);
    final BrowserRoot browserRootWithParam = new BrowserRoot(testMediaId, testReturnedExtra);
    MockMediaBrowserServiceCompat.setMediaBrowserServiceProxy(new Proxy() {

        @Override
        public BrowserRoot onGetRoot(String clientPackageName, int clientUid, Bundle rootHints) {
            assertEquals(mContext.getPackageName(), clientPackageName);
            if (rootHints.keySet().contains(testMediaId)) {
                // This should happen because getLibraryRoot() is called with testExtras.
                return browserRootWithParam;
            }
            // This shouldn't be happen for getLibraryRoot(testParams)
            return browserRootWithoutParam;
        }
    });
    MediaBrowser2 browser = createBrowser(null);
    BrowserResult result = browser.getLibraryRoot(testParams).get(WAIT_TIME_MS, TimeUnit.MILLISECONDS);
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertMediaItemWithId(testMediaId, result.getMediaItem());
    assertEquals(testReturnedExtra.getBoolean(BrowserRoot.EXTRA_RECENT), result.getLibraryParams().isRecent());
    assertEquals(testReturnedExtra.getBoolean(BrowserRoot.EXTRA_OFFLINE), result.getLibraryParams().isOffline());
    assertEquals(testReturnedExtra.getBoolean(BrowserRoot.EXTRA_SUGGESTED), result.getLibraryParams().isSuggested());
    // Note that TestUtils#equals() cannot be used for this because
    // MediaBrowserServiceCompat adds extra_client_version to the rootHints.
    assertTrue(TestUtils.contains(result.getLibraryParams().getExtras(), testExtra));
}
#method_after
@Test
public void testGetLibraryRoot() throws Exception {
    prepareLooper();
    final String testMediaId = "testGetLibraryRoot";
    final Bundle testExtra = new Bundle();
    testExtra.putString(testMediaId, testMediaId);
    final LibraryParams testParams = new LibraryParams.Builder().setExtras(testExtra).setOffline(true).setRecent(true).setSuggested(true).build();
    final BrowserRoot browserRootWithoutParam = new BrowserRoot(testMediaId, null);
    final Bundle testReturnedExtra = new Bundle(testExtra);
    testReturnedExtra.putBoolean(BrowserRoot.EXTRA_OFFLINE, true);
    final BrowserRoot browserRootWithParam = new BrowserRoot(testMediaId, testReturnedExtra);
    MockMediaBrowserServiceCompat.setMediaBrowserServiceProxy(new Proxy() {

        @Override
        public BrowserRoot onGetRoot(String clientPackageName, int clientUid, Bundle rootHints) {
            assertEquals(mContext.getPackageName(), clientPackageName);
            if (rootHints.keySet().contains(testMediaId)) {
                // This should happen because getLibraryRoot() is called with testExtras.
                return browserRootWithParam;
            }
            // This shouldn't be happen for getLibraryRoot(testParams)
            return browserRootWithoutParam;
        }
    });
    MediaBrowser2 browser = createBrowser(null);
    BrowserResult result = browser.getLibraryRoot(testParams).get(TIMEOUT_MS, TimeUnit.MILLISECONDS);
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertMediaItemWithId(testMediaId, result.getMediaItem());
    assertEquals(testReturnedExtra.getBoolean(BrowserRoot.EXTRA_RECENT), result.getLibraryParams().isRecent());
    assertEquals(testReturnedExtra.getBoolean(BrowserRoot.EXTRA_OFFLINE), result.getLibraryParams().isOffline());
    assertEquals(testReturnedExtra.getBoolean(BrowserRoot.EXTRA_SUGGESTED), result.getLibraryParams().isSuggested());
    // Note that TestUtils#equals() cannot be used for this because
    // MediaBrowserServiceCompat adds extra_client_version to the rootHints.
    assertTrue(TestUtils.contains(result.getLibraryParams().getExtras(), testExtra));
}
#end_block

#method_before
@Test
public void testGetItem() throws Exception {
    prepareLooper();
    final String testMediaId = "test_media_item";
    final MediaItem testItem = createMediaItem(testMediaId);
    MockMediaBrowserServiceCompat.setMediaBrowserServiceProxy(new Proxy() {

        @Override
        public void onLoadItem(String itemId, Result<MediaItem> result) {
            assertEquals(testMediaId, itemId);
            result.sendResult(testItem);
        }
    });
    MediaBrowser2 browser = createBrowser(null);
    BrowserResult result = browser.getItem(testMediaId).get(WAIT_TIME_MS, TimeUnit.MILLISECONDS);
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertItemEquals(testItem, result.getMediaItem());
}
#method_after
@Test
public void testGetItem() throws Exception {
    prepareLooper();
    final String testMediaId = "test_media_item";
    final MediaItem testItem = createMediaItem(testMediaId);
    MockMediaBrowserServiceCompat.setMediaBrowserServiceProxy(new Proxy() {

        @Override
        public void onLoadItem(String itemId, Result<MediaItem> result) {
            assertEquals(testMediaId, itemId);
            result.sendResult(testItem);
        }
    });
    MediaBrowser2 browser = createBrowser(null);
    BrowserResult result = browser.getItem(testMediaId).get(TIMEOUT_MS, TimeUnit.MILLISECONDS);
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertItemEquals(testItem, result.getMediaItem());
}
#end_block

#method_before
@Test
public void testGetItem_nullResult() throws Exception {
    prepareLooper();
    final String testMediaId = "test_media_item";
    MockMediaBrowserServiceCompat.setMediaBrowserServiceProxy(new Proxy() {

        @Override
        public void onLoadItem(String itemId, Result<MediaItem> result) {
            assertEquals(testMediaId, itemId);
            result.sendResult(null);
        }
    });
    MediaBrowser2 browser = createBrowser(null);
    BrowserResult result = browser.getItem(testMediaId).get(WAIT_TIME_MS, TimeUnit.MILLISECONDS);
    assertNotEquals(RESULT_CODE_SUCCESS, result.getResultCode());
}
#method_after
@Test
public void testGetItem_nullResult() throws Exception {
    prepareLooper();
    final String testMediaId = "test_media_item";
    MockMediaBrowserServiceCompat.setMediaBrowserServiceProxy(new Proxy() {

        @Override
        public void onLoadItem(String itemId, Result<MediaItem> result) {
            assertEquals(testMediaId, itemId);
            result.sendResult(null);
        }
    });
    MediaBrowser2 browser = createBrowser(null);
    BrowserResult result = browser.getItem(testMediaId).get(TIMEOUT_MS, TimeUnit.MILLISECONDS);
    assertNotEquals(RESULT_CODE_SUCCESS, result.getResultCode());
}
#end_block

#method_before
@Test
public void testGetChildren_onLoadChildrenWithoutOptions() throws Exception {
    prepareLooper();
    final String testParentId = "test_media_parent";
    final int testPage = 2;
    final int testPageSize = 4;
    final List<MediaItem> testFullMediaItemList = createMediaItems((testPage + 1) * testPageSize);
    final List<MediaItem> testPaginatedMediaItemList = testFullMediaItemList.subList(testPage * testPageSize, Math.min((testPage + 1) * testPageSize, testFullMediaItemList.size()));
    MockMediaBrowserServiceCompat.setMediaBrowserServiceProxy(new Proxy() {

        @Override
        public void onLoadChildren(String parentId, Result<List<MediaItem>> result) {
            result.sendResult(testFullMediaItemList);
        }
    });
    MediaBrowser2 browser = createBrowser(null);
    ListenableFuture<BrowserResult> future = browser.getChildren(testParentId, testPage, testPageSize, null);
    BrowserResult result = future.get(WAIT_TIME_MS, TimeUnit.MILLISECONDS);
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertItemsEquals(testPaginatedMediaItemList, result.getMediaItems());
}
#method_after
@Test
public void testGetChildren_onLoadChildrenWithoutOptions() throws Exception {
    prepareLooper();
    final String testParentId = "test_media_parent";
    final int testPage = 2;
    final int testPageSize = 4;
    final List<MediaItem> testFullMediaItemList = createMediaItems((testPage + 1) * testPageSize);
    final List<MediaItem> testPaginatedMediaItemList = testFullMediaItemList.subList(testPage * testPageSize, Math.min((testPage + 1) * testPageSize, testFullMediaItemList.size()));
    MockMediaBrowserServiceCompat.setMediaBrowserServiceProxy(new Proxy() {

        @Override
        public void onLoadChildren(String parentId, Result<List<MediaItem>> result) {
            result.sendResult(testFullMediaItemList);
        }
    });
    MediaBrowser2 browser = createBrowser(null);
    ListenableFuture<BrowserResult> future = browser.getChildren(testParentId, testPage, testPageSize, null);
    BrowserResult result = future.get(TIMEOUT_MS, TimeUnit.MILLISECONDS);
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertItemsEquals(testPaginatedMediaItemList, result.getMediaItems());
}
#end_block

#method_before
@Test
public void testGetChildren_withoutOption() throws Exception {
    prepareLooper();
    final String testParentId = "test_media_parent";
    final int testPage = 2;
    final int testPageSize = 4;
    final List<MediaItem> testMediaItemList = createMediaItems(testPageSize);
    MockMediaBrowserServiceCompat.setMediaBrowserServiceProxy(new Proxy() {

        @Override
        public void onLoadChildren(String parentId, Result<List<MediaItem>> result) {
            fail("This isn't expected to be called");
        }

        @Override
        public void onLoadChildren(String parentId, Result<List<MediaItem>> result, Bundle options) {
            assertEquals(testParentId, parentId);
            assertEquals(testPage, options.getInt(MediaBrowserCompat.EXTRA_PAGE));
            assertEquals(testPageSize, options.getInt(MediaBrowserCompat.EXTRA_PAGE_SIZE));
            assertEquals(2, options.keySet().size());
            result.sendResult(testMediaItemList);
        }
    });
    MediaBrowser2 browser = createBrowser(null);
    BrowserResult result = browser.getChildren(testParentId, testPage, testPageSize, null).get(WAIT_TIME_MS, TimeUnit.MILLISECONDS);
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertItemsEquals(testMediaItemList, result.getMediaItems());
    assertNull(result.getLibraryParams());
}
#method_after
@Test
public void testGetChildren_withoutOption() throws Exception {
    prepareLooper();
    final String testParentId = "test_media_parent";
    final int testPage = 2;
    final int testPageSize = 4;
    final List<MediaItem> testMediaItemList = createMediaItems(testPageSize);
    MockMediaBrowserServiceCompat.setMediaBrowserServiceProxy(new Proxy() {

        @Override
        public void onLoadChildren(String parentId, Result<List<MediaItem>> result) {
            fail("This isn't expected to be called");
        }

        @Override
        public void onLoadChildren(String parentId, Result<List<MediaItem>> result, Bundle options) {
            assertEquals(testParentId, parentId);
            assertEquals(testPage, options.getInt(MediaBrowserCompat.EXTRA_PAGE));
            assertEquals(testPageSize, options.getInt(MediaBrowserCompat.EXTRA_PAGE_SIZE));
            assertEquals(2, options.keySet().size());
            result.sendResult(testMediaItemList);
        }
    });
    MediaBrowser2 browser = createBrowser(null);
    BrowserResult result = browser.getChildren(testParentId, testPage, testPageSize, null).get(TIMEOUT_MS, TimeUnit.MILLISECONDS);
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertItemsEquals(testMediaItemList, result.getMediaItems());
    assertNull(result.getLibraryParams());
}
#end_block

#method_before
@Test
public void testGetChildren_withOption() throws Exception {
    prepareLooper();
    final String testParentId = "test_media_parent";
    final int testPage = 2;
    final int testPageSize = 4;
    final LibraryParams testParams = createLibraryParams();
    final List<MediaItem> testMediaItemList = createMediaItems(testPageSize / 2);
    MockMediaBrowserServiceCompat.setMediaBrowserServiceProxy(new Proxy() {

        @Override
        public void onLoadChildren(String parentId, Result<List<MediaItem>> result, Bundle options) {
            assertEquals(testParentId, parentId);
            assertEquals(testPage, options.getInt(MediaBrowserCompat.EXTRA_PAGE));
            assertEquals(testPageSize, options.getInt(MediaBrowserCompat.EXTRA_PAGE_SIZE));
            assertTrue(TestUtils.contains(options, testParams.getExtras()));
            result.sendResult(testMediaItemList);
        }
    });
    MediaBrowser2 browser = createBrowser(null);
    BrowserResult result = browser.getChildren(testParentId, testPage, testPageSize, testParams).get(WAIT_TIME_MS, TimeUnit.MILLISECONDS);
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertItemsEquals(testMediaItemList, result.getMediaItems());
    assertNull(result.getLibraryParams());
}
#method_after
@Test
public void testGetChildren_withOption() throws Exception {
    prepareLooper();
    final String testParentId = "test_media_parent";
    final int testPage = 2;
    final int testPageSize = 4;
    final LibraryParams testParams = createLibraryParams();
    final List<MediaItem> testMediaItemList = createMediaItems(testPageSize / 2);
    MockMediaBrowserServiceCompat.setMediaBrowserServiceProxy(new Proxy() {

        @Override
        public void onLoadChildren(String parentId, Result<List<MediaItem>> result, Bundle options) {
            assertEquals(testParentId, parentId);
            assertEquals(testPage, options.getInt(MediaBrowserCompat.EXTRA_PAGE));
            assertEquals(testPageSize, options.getInt(MediaBrowserCompat.EXTRA_PAGE_SIZE));
            assertTrue(TestUtils.contains(options, testParams.getExtras()));
            result.sendResult(testMediaItemList);
        }
    });
    MediaBrowser2 browser = createBrowser(null);
    BrowserResult result = browser.getChildren(testParentId, testPage, testPageSize, testParams).get(TIMEOUT_MS, TimeUnit.MILLISECONDS);
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertItemsEquals(testMediaItemList, result.getMediaItems());
    assertNull(result.getLibraryParams());
}
#end_block

#method_before
@Test
public void testGetChildren_nullResult() throws Exception {
    prepareLooper();
    final String testParentId = "test_media_parent";
    final int testPage = 2;
    final int testPageSize = 4;
    MockMediaBrowserServiceCompat.setMediaBrowserServiceProxy(new Proxy() {

        @Override
        public void onLoadChildren(String parentId, Result<List<MediaItem>> result, Bundle options) {
            assertEquals(testParentId, parentId);
            assertEquals(testPage, options.getInt(MediaBrowserCompat.EXTRA_PAGE));
            assertEquals(testPageSize, options.getInt(MediaBrowserCompat.EXTRA_PAGE_SIZE));
            result.sendResult(null);
        }
    });
    MediaBrowser2 browser = createBrowser(null);
    BrowserResult result = browser.getChildren(testParentId, testPage, testPageSize, null).get(WAIT_TIME_MS, TimeUnit.MILLISECONDS);
    assertNotEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertNull(result.getLibraryParams());
}
#method_after
@Test
public void testGetChildren_nullResult() throws Exception {
    prepareLooper();
    final String testParentId = "test_media_parent";
    final int testPage = 2;
    final int testPageSize = 4;
    MockMediaBrowserServiceCompat.setMediaBrowserServiceProxy(new Proxy() {

        @Override
        public void onLoadChildren(String parentId, Result<List<MediaItem>> result, Bundle options) {
            assertEquals(testParentId, parentId);
            assertEquals(testPage, options.getInt(MediaBrowserCompat.EXTRA_PAGE));
            assertEquals(testPageSize, options.getInt(MediaBrowserCompat.EXTRA_PAGE_SIZE));
            result.sendResult(null);
        }
    });
    MediaBrowser2 browser = createBrowser(null);
    BrowserResult result = browser.getChildren(testParentId, testPage, testPageSize, null).get(TIMEOUT_MS, TimeUnit.MILLISECONDS);
    assertNotEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertNull(result.getLibraryParams());
}
#end_block

#method_before
@Test
public void testSearch() throws Exception {
    prepareLooper();
    final String testQuery = "search_query";
    final int testPage = 2;
    final int testPageSize = 4;
    final LibraryParams testParams = createLibraryParams();
    final List<MediaItem> testFullSearchResult = createMediaItems((testPage + 1) * testPageSize + 3);
    final List<MediaItem> testPaginatedSearchResult = testFullSearchResult.subList(testPage * testPageSize, Math.min((testPage + 1) * testPageSize, testFullSearchResult.size()));
    MockMediaBrowserServiceCompat.setMediaBrowserServiceProxy(new Proxy() {

        @Override
        public void onSearch(String query, Bundle extras, Result<List<MediaItem>> result) {
            assertEquals(testQuery, query);
            assertTrue(TestUtils.contains(extras, testParams.getExtras()));
            if (extras != null && extras.getInt(MediaBrowserCompat.EXTRA_PAGE, -1) >= 0) {
                assertEquals(testPage, extras.getInt(MediaBrowserCompat.EXTRA_PAGE));
                assertEquals(testPageSize, extras.getInt(MediaBrowserCompat.EXTRA_PAGE_SIZE));
                result.sendResult(testPaginatedSearchResult);
            } else {
                result.sendResult(testFullSearchResult);
            }
        }
    });
    final CountDownLatch latch = new CountDownLatch(1);
    MediaBrowser2 browser = createBrowser(new BrowserCallback() {

        @Override
        public void onSearchResultChanged(MediaBrowser2 browser, String query, int itemCount, LibraryParams params) {
            assertEquals(testQuery, query);
            assertEquals(testFullSearchResult.size(), itemCount);
            assertNull(params);
            latch.countDown();
        }
    });
    BrowserResult result = browser.search(testQuery, testParams).get(WAIT_TIME_MS, TimeUnit.MILLISECONDS);
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertTrue(latch.await(WAIT_TIME_MS, TimeUnit.MILLISECONDS));
    result = browser.getSearchResult(testQuery, testPage, testPageSize, testParams).get(WAIT_TIME_MS, TimeUnit.MILLISECONDS);
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertItemsEquals(testPaginatedSearchResult, result.getMediaItems());
}
#method_after
@Test
public void testSearch() throws Exception {
    prepareLooper();
    final String testQuery = "search_query";
    final int testPage = 2;
    final int testPageSize = 4;
    final LibraryParams testParams = createLibraryParams();
    final List<MediaItem> testFullSearchResult = createMediaItems((testPage + 1) * testPageSize + 3);
    final List<MediaItem> testPaginatedSearchResult = testFullSearchResult.subList(testPage * testPageSize, Math.min((testPage + 1) * testPageSize, testFullSearchResult.size()));
    MockMediaBrowserServiceCompat.setMediaBrowserServiceProxy(new Proxy() {

        @Override
        public void onSearch(String query, Bundle extras, Result<List<MediaItem>> result) {
            assertEquals(testQuery, query);
            assertTrue(TestUtils.contains(extras, testParams.getExtras()));
            if (extras != null && extras.getInt(MediaBrowserCompat.EXTRA_PAGE, -1) >= 0) {
                assertEquals(testPage, extras.getInt(MediaBrowserCompat.EXTRA_PAGE));
                assertEquals(testPageSize, extras.getInt(MediaBrowserCompat.EXTRA_PAGE_SIZE));
                result.sendResult(testPaginatedSearchResult);
            } else {
                result.sendResult(testFullSearchResult);
            }
        }
    });
    final CountDownLatch latch = new CountDownLatch(1);
    MediaBrowser2 browser = createBrowser(new BrowserCallback() {

        @Override
        public void onSearchResultChanged(MediaBrowser2 browser, String query, int itemCount, LibraryParams params) {
            assertEquals(testQuery, query);
            assertEquals(testFullSearchResult.size(), itemCount);
            assertNull(params);
            latch.countDown();
        }
    });
    BrowserResult result = browser.search(testQuery, testParams).get(TIMEOUT_MS, TimeUnit.MILLISECONDS);
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertTrue(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
    result = browser.getSearchResult(testQuery, testPage, testPageSize, testParams).get(TIMEOUT_MS, TimeUnit.MILLISECONDS);
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertItemsEquals(testPaginatedSearchResult, result.getMediaItems());
}
#end_block

#method_before
@Test
public void testSearch_nullResult() throws Exception {
    prepareLooper();
    final String testQuery = "search_query";
    final int testPage = 2;
    final int testPageSize = 4;
    MockMediaBrowserServiceCompat.setMediaBrowserServiceProxy(new Proxy() {

        @Override
        public void onSearch(String query, Bundle extras, Result<List<MediaItem>> result) {
            result.sendResult(null);
        }
    });
    final CountDownLatch latch = new CountDownLatch(1);
    MediaBrowser2 browser = createBrowser(new BrowserCallback() {

        @Override
        public void onSearchResultChanged(MediaBrowser2 browser, String query, int itemCount, LibraryParams params) {
            assertEquals(testQuery, query);
            assertEquals(0, itemCount);
            latch.countDown();
        }
    });
    BrowserResult result = browser.search(testQuery, null).get(WAIT_TIME_MS, TimeUnit.MILLISECONDS);
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertTrue(latch.await(WAIT_TIME_MS, TimeUnit.MILLISECONDS));
    result = browser.getSearchResult(testQuery, testPage, testPageSize, null).get(WAIT_TIME_MS, TimeUnit.MILLISECONDS);
    assertNotEquals(RESULT_CODE_SUCCESS, result.getResultCode());
}
#method_after
@Test
public void testSearch_nullResult() throws Exception {
    prepareLooper();
    final String testQuery = "search_query";
    final int testPage = 2;
    final int testPageSize = 4;
    MockMediaBrowserServiceCompat.setMediaBrowserServiceProxy(new Proxy() {

        @Override
        public void onSearch(String query, Bundle extras, Result<List<MediaItem>> result) {
            result.sendResult(null);
        }
    });
    final CountDownLatch latch = new CountDownLatch(1);
    MediaBrowser2 browser = createBrowser(new BrowserCallback() {

        @Override
        public void onSearchResultChanged(MediaBrowser2 browser, String query, int itemCount, LibraryParams params) {
            assertEquals(testQuery, query);
            assertEquals(0, itemCount);
            latch.countDown();
        }
    });
    BrowserResult result = browser.search(testQuery, null).get(TIMEOUT_MS, TimeUnit.MILLISECONDS);
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertTrue(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
    result = browser.getSearchResult(testQuery, testPage, testPageSize, null).get(TIMEOUT_MS, TimeUnit.MILLISECONDS);
    assertNotEquals(RESULT_CODE_SUCCESS, result.getResultCode());
}
#end_block

#method_before
@Test
public void testSubscribeAndUnsubscribe() throws Exception {
    prepareLooper();
    final String testParentId = "testSubscribe";
    final LibraryParams testParams = createLibraryParams();
    final List<MediaItem> testFullMediaItemList = createMediaItems(4);
    final CountDownLatch subscribeLatch = new CountDownLatch(1);
    final CountDownLatch latch = new CountDownLatch(2);
    MockMediaBrowserServiceCompat.setMediaBrowserServiceProxy(new Proxy() {

        @Override
        public void onLoadChildren(String parentId, Result<List<MediaItem>> result, Bundle option) {
            // Called by subscribe and notifyChildrenChanged()
            assertEquals(testParentId, parentId);
            assertTrue(TestUtils.equals(testParams.getExtras(), option));
            result.sendResult(testFullMediaItemList);
            // onLoadChildren() again for getting list of children.
            if (subscribeLatch.getCount() > 0) {
                subscribeLatch.countDown();
            }
        }
    });
    MediaBrowser2 browser = createBrowser(new MediaBrowser2.BrowserCallback() {

        @Override
        public void onChildrenChanged(MediaBrowser2 browser, String parentId, int itemCount, LibraryParams params) {
            // Triggered by both subscribe and notifyChildrenChanged().
            // Shouldn't be called after the unsubscribe().
            assertNotEquals(0, latch.getCount());
            assertEquals(testParentId, parentId);
            assertEquals(testFullMediaItemList.size(), itemCount);
            assertNull(params);
            latch.countDown();
        }
    });
    BrowserResult result = browser.subscribe(testParentId, testParams).get(WAIT_TIME_MS, TimeUnit.MILLISECONDS);
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertTrue(subscribeLatch.await(WAIT_TIME_MS, TimeUnit.MILLISECONDS));
    MockMediaBrowserServiceCompat.getInstance().notifyChildrenChanged(testParentId);
    assertTrue(latch.await(WAIT_TIME_MS, TimeUnit.MILLISECONDS));
    result = browser.unsubscribe(testParentId).get(WAIT_TIME_MS, TimeUnit.MILLISECONDS);
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    // Unsubscribe takes some time. Wait for some time.
    Thread.sleep(WAIT_TIME_MS);
    MockMediaBrowserServiceCompat.getInstance().notifyChildrenChanged(testParentId);
    // This shouldn't trigger browser's onChildrenChanged().
    // Wait for some time. Exception will be thrown in the callback if error happens.
    Thread.sleep(WAIT_TIME_MS);
}
#method_after
@Test
public void testSubscribeAndUnsubscribe() throws Exception {
    prepareLooper();
    final String testParentId = "testSubscribe";
    final LibraryParams testParams = createLibraryParams();
    final List<MediaItem> testFullMediaItemList = createMediaItems(4);
    final CountDownLatch subscribeLatch = new CountDownLatch(1);
    final CountDownLatch latch = new CountDownLatch(2);
    MockMediaBrowserServiceCompat.setMediaBrowserServiceProxy(new Proxy() {

        @Override
        public void onLoadChildren(String parentId, Result<List<MediaItem>> result, Bundle option) {
            // Called by subscribe and notifyChildrenChanged()
            assertEquals(testParentId, parentId);
            assertTrue(TestUtils.equals(testParams.getExtras(), option));
            result.sendResult(testFullMediaItemList);
            // onLoadChildren() again for getting list of children.
            if (subscribeLatch.getCount() > 0) {
                subscribeLatch.countDown();
            }
        }
    });
    MediaBrowser2 browser = createBrowser(new MediaBrowser2.BrowserCallback() {

        @Override
        public void onChildrenChanged(MediaBrowser2 browser, String parentId, int itemCount, LibraryParams params) {
            // Triggered by both subscribe and notifyChildrenChanged().
            // Shouldn't be called after the unsubscribe().
            assertNotEquals(0, latch.getCount());
            assertEquals(testParentId, parentId);
            assertEquals(testFullMediaItemList.size(), itemCount);
            assertNull(params);
            latch.countDown();
        }
    });
    BrowserResult result = browser.subscribe(testParentId, testParams).get(TIMEOUT_MS, TimeUnit.MILLISECONDS);
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertTrue(subscribeLatch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
    MockMediaBrowserServiceCompat.getInstance().notifyChildrenChanged(testParentId);
    assertTrue(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
    result = browser.unsubscribe(testParentId).get(TIMEOUT_MS, TimeUnit.MILLISECONDS);
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    // Unsubscribe takes some time. Wait for some time.
    Thread.sleep(TIMEOUT_MS);
    MockMediaBrowserServiceCompat.getInstance().notifyChildrenChanged(testParentId);
    // This shouldn't trigger browser's onChildrenChanged().
    // Wait for some time. Exception will be thrown in the callback if error happens.
    Thread.sleep(TIMEOUT_MS);
}
#end_block

#method_before
@Override
public void onCommand(final String commandName, final Bundle args, final ResultReceiver cb) {
    if (commandName == null) {
        return;
    }
    final SessionCommand2 command = new SessionCommand2(commandName, null);
    onSessionCommand(command, new SessionRunnable() {

        @Override
        public void run(final ControllerInfo controller) throws RemoteException {
            SessionResult result = mSessionImpl.getCallback().onCustomCommand(mSessionImpl.getInstance(), controller, command, args);
            if (cb != null) {
                cb.send(result.getResultCode(), result.getCustomCommandResult());
            }
        }
    });
}
#method_after
@Override
public void onCommand(final String commandName, final Bundle args, final ResultReceiver cb) {
    if (commandName == null) {
        return;
    }
    final SessionCommand2 command = new SessionCommand2(commandName, null);
    dispatchSessionTask(command, new SessionTask() {

        @Override
        public void run(final ControllerInfo controller) throws RemoteException {
            SessionResult result = mSessionImpl.getCallback().onCustomCommand(mSessionImpl.getInstance(), controller, command, args);
            if (cb != null) {
                cb.send(result.getResultCode(), result.getCustomCommandResult());
            }
        }
    });
}
#end_block

#method_before
@Override
public void onPrepare() {
    onSessionCommand(SessionCommand2.COMMAND_CODE_PLAYER_PREFETCH, new SessionRunnable() {

        @Override
        public void run(ControllerInfo controller) throws RemoteException {
            mSessionImpl.prefetch();
        }
    });
}
#method_after
@Override
public void onPrepare() {
    dispatchSessionTask(SessionCommand2.COMMAND_CODE_PLAYER_PREFETCH, new SessionTask() {

        @Override
        public void run(ControllerInfo controller) throws RemoteException {
            mSessionImpl.prefetch();
        }
    });
}
#end_block

#method_before
@Override
public void onPrepareFromMediaId(final String mediaId, final Bundle extras) {
    if (mediaId == null) {
        return;
    }
    onSessionCommand(SessionCommand2.COMMAND_CODE_SESSION_PREFETCH_FROM_MEDIA_ID, new SessionRunnable() {

        @Override
        public void run(ControllerInfo controller) throws RemoteException {
            mSessionImpl.getCallback().onPrefetchFromMediaId(mSessionImpl.getInstance(), controller, mediaId, extras);
        }
    });
}
#method_after
@Override
public void onPrepareFromMediaId(final String mediaId, final Bundle extras) {
    if (mediaId == null) {
        return;
    }
    dispatchSessionTask(SessionCommand2.COMMAND_CODE_SESSION_PREFETCH_FROM_MEDIA_ID, new SessionTask() {

        @Override
        public void run(ControllerInfo controller) throws RemoteException {
            mSessionImpl.getCallback().onPrefetchFromMediaId(mSessionImpl.getInstance(), controller, mediaId, extras);
        }
    });
}
#end_block

#method_before
@Override
public void onPrepareFromSearch(final String query, final Bundle extras) {
    if (query == null) {
        return;
    }
    onSessionCommand(SessionCommand2.COMMAND_CODE_SESSION_PREFETCH_FROM_SEARCH, new SessionRunnable() {

        @Override
        public void run(ControllerInfo controller) throws RemoteException {
            mSessionImpl.getCallback().onPrefetchFromSearch(mSessionImpl.getInstance(), controller, query, extras);
        }
    });
}
#method_after
@Override
public void onPrepareFromSearch(final String query, final Bundle extras) {
    if (query == null) {
        return;
    }
    dispatchSessionTask(SessionCommand2.COMMAND_CODE_SESSION_PREFETCH_FROM_SEARCH, new SessionTask() {

        @Override
        public void run(ControllerInfo controller) throws RemoteException {
            mSessionImpl.getCallback().onPrefetchFromSearch(mSessionImpl.getInstance(), controller, query, extras);
        }
    });
}
#end_block

#method_before
@Override
public void onPrepareFromUri(final Uri uri, final Bundle extras) {
    if (uri == null) {
        return;
    }
    onSessionCommand(SessionCommand2.COMMAND_CODE_SESSION_PREFETCH_FROM_URI, new SessionRunnable() {

        @Override
        public void run(ControllerInfo controller) throws RemoteException {
            mSessionImpl.getCallback().onPrefetchFromUri(mSessionImpl.getInstance(), controller, uri, extras);
        }
    });
}
#method_after
@Override
public void onPrepareFromUri(final Uri uri, final Bundle extras) {
    if (uri == null) {
        return;
    }
    dispatchSessionTask(SessionCommand2.COMMAND_CODE_SESSION_PREFETCH_FROM_URI, new SessionTask() {

        @Override
        public void run(ControllerInfo controller) throws RemoteException {
            mSessionImpl.getCallback().onPrefetchFromUri(mSessionImpl.getInstance(), controller, uri, extras);
        }
    });
}
#end_block

#method_before
@Override
public void onPlay() {
    onSessionCommand(SessionCommand2.COMMAND_CODE_PLAYER_PLAY, new SessionRunnable() {

        @Override
        public void run(ControllerInfo controller) throws RemoteException {
            mSessionImpl.play();
        }
    });
}
#method_after
@Override
public void onPlay() {
    dispatchSessionTask(SessionCommand2.COMMAND_CODE_PLAYER_PLAY, new SessionTask() {

        @Override
        public void run(ControllerInfo controller) throws RemoteException {
            mSessionImpl.play();
        }
    });
}
#end_block

#method_before
@Override
public void onPlayFromMediaId(final String mediaId, final Bundle extras) {
    if (mediaId == null) {
        return;
    }
    onSessionCommand(SessionCommand2.COMMAND_CODE_SESSION_PLAY_FROM_MEDIA_ID, new SessionRunnable() {

        @Override
        public void run(ControllerInfo controller) throws RemoteException {
            mSessionImpl.getCallback().onPlayFromMediaId(mSessionImpl.getInstance(), controller, mediaId, extras);
        }
    });
}
#method_after
@Override
public void onPlayFromMediaId(final String mediaId, final Bundle extras) {
    if (mediaId == null) {
        return;
    }
    dispatchSessionTask(SessionCommand2.COMMAND_CODE_SESSION_PLAY_FROM_MEDIA_ID, new SessionTask() {

        @Override
        public void run(ControllerInfo controller) throws RemoteException {
            mSessionImpl.getCallback().onPlayFromMediaId(mSessionImpl.getInstance(), controller, mediaId, extras);
        }
    });
}
#end_block

#method_before
@Override
public void onPlayFromSearch(final String query, final Bundle extras) {
    if (query == null) {
        return;
    }
    onSessionCommand(SessionCommand2.COMMAND_CODE_SESSION_PLAY_FROM_SEARCH, new SessionRunnable() {

        @Override
        public void run(ControllerInfo controller) throws RemoteException {
            mSessionImpl.getCallback().onPlayFromSearch(mSessionImpl.getInstance(), controller, query, extras);
        }
    });
}
#method_after
@Override
public void onPlayFromSearch(final String query, final Bundle extras) {
    if (query == null) {
        return;
    }
    dispatchSessionTask(SessionCommand2.COMMAND_CODE_SESSION_PLAY_FROM_SEARCH, new SessionTask() {

        @Override
        public void run(ControllerInfo controller) throws RemoteException {
            mSessionImpl.getCallback().onPlayFromSearch(mSessionImpl.getInstance(), controller, query, extras);
        }
    });
}
#end_block

#method_before
@Override
public void onPlayFromUri(final Uri uri, final Bundle extras) {
    if (uri == null) {
        return;
    }
    onSessionCommand(SessionCommand2.COMMAND_CODE_SESSION_PLAY_FROM_URI, new SessionRunnable() {

        @Override
        public void run(ControllerInfo controller) throws RemoteException {
            mSessionImpl.getCallback().onPlayFromUri(mSessionImpl.getInstance(), controller, uri, extras);
        }
    });
}
#method_after
@Override
public void onPlayFromUri(final Uri uri, final Bundle extras) {
    if (uri == null) {
        return;
    }
    dispatchSessionTask(SessionCommand2.COMMAND_CODE_SESSION_PLAY_FROM_URI, new SessionTask() {

        @Override
        public void run(ControllerInfo controller) throws RemoteException {
            mSessionImpl.getCallback().onPlayFromUri(mSessionImpl.getInstance(), controller, uri, extras);
        }
    });
}
#end_block

#method_before
@Override
public void onPause() {
    onSessionCommand(SessionCommand2.COMMAND_CODE_PLAYER_PAUSE, new SessionRunnable() {

        @Override
        public void run(ControllerInfo controller) throws RemoteException {
            mSessionImpl.pause();
        }
    });
}
#method_after
@Override
public void onPause() {
    dispatchSessionTask(SessionCommand2.COMMAND_CODE_PLAYER_PAUSE, new SessionTask() {

        @Override
        public void run(ControllerInfo controller) throws RemoteException {
            mSessionImpl.pause();
        }
    });
}
#end_block

#method_before
@Override
public void onStop() {
    // Here, we don't call SessionPlayer2#reset() since it may result removing
    // all callbacks from the player. Instead, we pause and seek to zero.
    // Here, we check both permissions: Pause / SeekTo.
    onSessionCommand(SessionCommand2.COMMAND_CODE_PLAYER_PAUSE, new SessionRunnable() {

        @Override
        public void run(ControllerInfo controller) throws RemoteException {
            handleCommandOnExecutor(controller, null, SessionCommand2.COMMAND_CODE_PLAYER_SEEK_TO, new SessionRunnable() {

                @Override
                public void run(ControllerInfo controller) throws RemoteException {
                    mSessionImpl.pause();
                    mSessionImpl.seekTo(0);
                }
            });
        }
    });
}
#method_after
@Override
public void onStop() {
    // Here, we don't call SessionPlayer2#reset() since it may result removing
    // all callbacks from the player. Instead, we pause and seek to zero.
    // Here, we check both permissions: Pause / SeekTo.
    dispatchSessionTask(SessionCommand2.COMMAND_CODE_PLAYER_PAUSE, new SessionTask() {

        @Override
        public void run(ControllerInfo controller) throws RemoteException {
            handleTaskOnExecutor(controller, null, SessionCommand2.COMMAND_CODE_PLAYER_SEEK_TO, new SessionTask() {

                @Override
                public void run(ControllerInfo controller) throws RemoteException {
                    mSessionImpl.pause();
                    mSessionImpl.seekTo(0);
                }
            });
        }
    });
}
#end_block

#method_before
@Override
public void onSeekTo(final long pos) {
    onSessionCommand(SessionCommand2.COMMAND_CODE_PLAYER_SEEK_TO, new SessionRunnable() {

        @Override
        public void run(ControllerInfo controller) throws RemoteException {
            mSessionImpl.seekTo(pos);
        }
    });
}
#method_after
@Override
public void onSeekTo(final long pos) {
    dispatchSessionTask(SessionCommand2.COMMAND_CODE_PLAYER_SEEK_TO, new SessionTask() {

        @Override
        public void run(ControllerInfo controller) throws RemoteException {
            mSessionImpl.seekTo(pos);
        }
    });
}
#end_block

#method_before
@Override
public void onSkipToNext() {
    onSessionCommand(SessionCommand2.COMMAND_CODE_PLAYER_SKIP_TO_NEXT_PLAYLIST_ITEM, new SessionRunnable() {

        @Override
        public void run(ControllerInfo controller) throws RemoteException {
            mSessionImpl.skipToNextItem();
        }
    });
}
#method_after
@Override
public void onSkipToNext() {
    dispatchSessionTask(SessionCommand2.COMMAND_CODE_PLAYER_SKIP_TO_NEXT_PLAYLIST_ITEM, new SessionTask() {

        @Override
        public void run(ControllerInfo controller) throws RemoteException {
            mSessionImpl.skipToNextItem();
        }
    });
}
#end_block

#method_before
@Override
public void onSkipToPrevious() {
    onSessionCommand(SessionCommand2.COMMAND_CODE_PLAYER_SKIP_TO_PREVIOUS_PLAYLIST_ITEM, new SessionRunnable() {

        @Override
        public void run(ControllerInfo controller) throws RemoteException {
            mSessionImpl.skipToPreviousItem();
        }
    });
}
#method_after
@Override
public void onSkipToPrevious() {
    dispatchSessionTask(SessionCommand2.COMMAND_CODE_PLAYER_SKIP_TO_PREVIOUS_PLAYLIST_ITEM, new SessionTask() {

        @Override
        public void run(ControllerInfo controller) throws RemoteException {
            mSessionImpl.skipToPreviousItem();
        }
    });
}
#end_block

#method_before
@Override
public void onSkipToQueueItem(final long id) {
    onSessionCommand(SessionCommand2.COMMAND_CODE_PLAYER_SKIP_TO_PLAYLIST_ITEM, new SessionRunnable() {

        @Override
        public void run(ControllerInfo controller) throws RemoteException {
            List<MediaItem2> playlist = mSessionImpl.getPlayer().getPlaylist();
            if (playlist == null) {
                return;
            }
            for (int i = 0; i < playlist.size(); i++) {
                MediaItem2 item = playlist.get(i);
                if (item != null && item.getUuid().getMostSignificantBits() == id) {
                    mSessionImpl.skipToPlaylistItem(item);
                    break;
                }
            }
        }
    });
}
#method_after
@Override
public void onSkipToQueueItem(final long id) {
    dispatchSessionTask(SessionCommand2.COMMAND_CODE_PLAYER_SKIP_TO_PLAYLIST_ITEM, new SessionTask() {

        @Override
        public void run(ControllerInfo controller) throws RemoteException {
            List<MediaItem2> playlist = mSessionImpl.getPlayer().getPlaylist();
            if (playlist == null) {
                return;
            }
            for (int i = 0; i < playlist.size(); i++) {
                MediaItem2 item = playlist.get(i);
                if (item != null && item.getUuid().getMostSignificantBits() == id) {
                    mSessionImpl.skipToPlaylistItem(item);
                    break;
                }
            }
        }
    });
}
#end_block

#method_before
@Override
public void onFastForward() {
    onSessionCommand(SessionCommand2.COMMAND_CODE_SESSION_FAST_FORWARD, new SessionRunnable() {

        @Override
        public void run(ControllerInfo controller) throws RemoteException {
            mSessionImpl.getCallback().onFastForward(mSessionImpl.getInstance(), controller);
        }
    });
}
#method_after
@Override
public void onFastForward() {
    dispatchSessionTask(SessionCommand2.COMMAND_CODE_SESSION_FAST_FORWARD, new SessionTask() {

        @Override
        public void run(ControllerInfo controller) throws RemoteException {
            mSessionImpl.getCallback().onFastForward(mSessionImpl.getInstance(), controller);
        }
    });
}
#end_block

#method_before
@Override
public void onRewind() {
    onSessionCommand(SessionCommand2.COMMAND_CODE_SESSION_REWIND, new SessionRunnable() {

        @Override
        public void run(ControllerInfo controller) throws RemoteException {
            mSessionImpl.getCallback().onRewind(mSessionImpl.getInstance(), controller);
        }
    });
}
#method_after
@Override
public void onRewind() {
    dispatchSessionTask(SessionCommand2.COMMAND_CODE_SESSION_REWIND, new SessionTask() {

        @Override
        public void run(ControllerInfo controller) throws RemoteException {
            mSessionImpl.getCallback().onRewind(mSessionImpl.getInstance(), controller);
        }
    });
}
#end_block

#method_before
@Override
public void onSetRating(final RatingCompat rating, Bundle extras) {
    if (rating == null) {
        return;
    }
    // extras is ignored.
    onSessionCommand(SessionCommand2.COMMAND_CODE_SESSION_SET_RATING, new SessionRunnable() {

        @Override
        public void run(ControllerInfo controller) throws RemoteException {
            MediaItem2 currentItem = mSessionImpl.getCurrentMediaItem();
            if (currentItem == null) {
                return;
            }
            mSessionImpl.getCallback().onSetRating(mSessionImpl.getInstance(), controller, currentItem.getMediaId(), MediaUtils2.convertToRating2(rating));
        }
    });
}
#method_after
@Override
public void onSetRating(final RatingCompat rating, Bundle extras) {
    if (rating == null) {
        return;
    }
    // extras is ignored.
    dispatchSessionTask(SessionCommand2.COMMAND_CODE_SESSION_SET_RATING, new SessionTask() {

        @Override
        public void run(ControllerInfo controller) throws RemoteException {
            MediaItem2 currentItem = mSessionImpl.getCurrentMediaItem();
            if (currentItem == null) {
                return;
            }
            mSessionImpl.getCallback().onSetRating(mSessionImpl.getInstance(), controller, currentItem.getMediaId(), MediaUtils2.convertToRating2(rating));
        }
    });
}
#end_block

#method_before
@Override
public void onSetRepeatMode(final int repeatMode) {
    onSessionCommand(SessionCommand2.COMMAND_CODE_PLAYER_SET_REPEAT_MODE, new SessionRunnable() {

        @Override
        public void run(ControllerInfo controller) throws RemoteException {
            mSessionImpl.setRepeatMode(repeatMode);
        }
    });
}
#method_after
@Override
public void onSetRepeatMode(final int repeatMode) {
    dispatchSessionTask(SessionCommand2.COMMAND_CODE_PLAYER_SET_REPEAT_MODE, new SessionTask() {

        @Override
        public void run(ControllerInfo controller) throws RemoteException {
            mSessionImpl.setRepeatMode(repeatMode);
        }
    });
}
#end_block

#method_before
@Override
public void onSetShuffleMode(final int shuffleMode) {
    onSessionCommand(SessionCommand2.COMMAND_CODE_PLAYER_SET_SHUFFLE_MODE, new SessionRunnable() {

        @Override
        public void run(ControllerInfo controller) throws RemoteException {
            mSessionImpl.setShuffleMode(shuffleMode);
        }
    });
}
#method_after
@Override
public void onSetShuffleMode(final int shuffleMode) {
    dispatchSessionTask(SessionCommand2.COMMAND_CODE_PLAYER_SET_SHUFFLE_MODE, new SessionTask() {

        @Override
        public void run(ControllerInfo controller) throws RemoteException {
            mSessionImpl.setShuffleMode(shuffleMode);
        }
    });
}
#end_block

#method_before
@Override
public void onAddQueueItem(final MediaDescriptionCompat description) {
    if (description == null) {
        return;
    }
    onSessionCommand(SessionCommand2.COMMAND_CODE_PLAYER_ADD_PLAYLIST_ITEM, new SessionRunnable() {

        @Override
        public void run(ControllerInfo controller) throws RemoteException {
            // Add the item at the end of the playlist.
            mSessionImpl.addPlaylistItem(Integer.MAX_VALUE, MediaUtils2.convertToMediaItem2(description));
        }
    });
}
#method_after
@Override
public void onAddQueueItem(final MediaDescriptionCompat description) {
    if (description == null) {
        return;
    }
    dispatchSessionTask(SessionCommand2.COMMAND_CODE_PLAYER_ADD_PLAYLIST_ITEM, new SessionTask() {

        @Override
        public void run(ControllerInfo controller) throws RemoteException {
            // Add the item at the end of the playlist.
            mSessionImpl.addPlaylistItem(Integer.MAX_VALUE, MediaUtils2.convertToMediaItem2(description));
        }
    });
}
#end_block

#method_before
@Override
public void onAddQueueItem(final MediaDescriptionCompat description, final int index) {
    if (description == null) {
        return;
    }
    onSessionCommand(SessionCommand2.COMMAND_CODE_PLAYER_ADD_PLAYLIST_ITEM, new SessionRunnable() {

        @Override
        public void run(ControllerInfo controller) throws RemoteException {
            mSessionImpl.addPlaylistItem(index, MediaUtils2.convertToMediaItem2(description));
        }
    });
}
#method_after
@Override
public void onAddQueueItem(final MediaDescriptionCompat description, final int index) {
    if (description == null) {
        return;
    }
    dispatchSessionTask(SessionCommand2.COMMAND_CODE_PLAYER_ADD_PLAYLIST_ITEM, new SessionTask() {

        @Override
        public void run(ControllerInfo controller) throws RemoteException {
            mSessionImpl.addPlaylistItem(index, MediaUtils2.convertToMediaItem2(description));
        }
    });
}
#end_block

#method_before
@Override
public void onRemoveQueueItem(final MediaDescriptionCompat description) {
    if (description == null) {
        return;
    }
    onSessionCommand(SessionCommand2.COMMAND_CODE_PLAYER_REMOVE_PLAYLIST_ITEM, new SessionRunnable() {

        @Override
        public void run(ControllerInfo controller) throws RemoteException {
            // Note: Here we cannot simply call
            // removePlaylistItem(MediaUtils2.convertToMediaItem2(description)),
            // because the result of the method will have different UUID.
            List<MediaItem2> playlist = mSessionImpl.getPlaylist();
            for (int i = 0; i < playlist.size(); i++) {
                MediaItem2 item = playlist.get(i);
                if (TextUtils.equals(item.getMediaId(), description.getMediaId())) {
                    mSessionImpl.removePlaylistItem(item);
                    return;
                }
            }
        }
    });
}
#method_after
@Override
public void onRemoveQueueItem(final MediaDescriptionCompat description) {
    if (description == null) {
        return;
    }
    dispatchSessionTask(SessionCommand2.COMMAND_CODE_PLAYER_REMOVE_PLAYLIST_ITEM, new SessionTask() {

        @Override
        public void run(ControllerInfo controller) throws RemoteException {
            // Note: Here we cannot simply call
            // removePlaylistItem(MediaUtils2.convertToMediaItem2(description)),
            // because the result of the method will have different UUID.
            List<MediaItem2> playlist = mSessionImpl.getPlaylist();
            for (int i = 0; i < playlist.size(); i++) {
                MediaItem2 item = playlist.get(i);
                if (TextUtils.equals(item.getMediaId(), description.getMediaId())) {
                    mSessionImpl.removePlaylistItem(item);
                    return;
                }
            }
        }
    });
}
#end_block

#method_before
@Override
void onPlaylistChanged(List<MediaItem2> playlist, MediaMetadata2 metadata) throws RemoteException {
    mSessionImpl.getSessionCompat().setQueue(MediaUtils2.convertToQueueItemList(playlist));
    onPlaylistMetadataChanged(metadata);
}
#method_after
@Override
void onPlaylistChanged(List<MediaItem2> playlist, MediaMetadata2 metadata) throws RemoteException {
    if (Build.VERSION.SDK_INT < 21) {
        // In order to avoid TransactionTooLargeException for below API 21,
        // we need to cut the list so that it doesn't exceed the binder transaction limit.
        List<QueueItem> queueItemList = MediaUtils2.convertToQueueItemList(playlist);
        List<QueueItem> truncatedList = MediaUtils2.truncateListBySize(queueItemList, TRANSACTION_SIZE_LIMIT_IN_BYTES);
        if (truncatedList.size() != playlist.size()) {
            Log.i(TAG, "Sending " + truncatedList.size() + " items out of " + playlist.size());
        }
        mSessionImpl.getSessionCompat().setQueue(truncatedList);
    } else {
        // Framework MediaSession#setQueue() uses ParceledListSlice,
        // which means we can safely send long lists.
        mSessionImpl.getSessionCompat().setQueue(MediaUtils2.convertToQueueItemList(playlist));
    }
    onPlaylistMetadataChanged(metadata);
}
#end_block

#method_before
@Test
public void testSingleItemUidRangeAllowed() {
    new UidRange(123, 123);
    new UidRange(0, 0);
    new UidRange(Integer.MAX_VALUE, Integer.MAX_VALUE);
}
#method_after
/*
   * UidRange is no longer passed to netd. UID ranges between the framework and netd are passed as
   * UidRangeParcel objects.
   */
@Test
public void testSingleItemUidRangeAllowed() {
    new UidRange(123, 123);
    new UidRange(0, 0);
    new UidRange(Integer.MAX_VALUE, Integer.MAX_VALUE);
}
#end_block

#method_before
@Override
public void setAllowOnlyVpnForUids(boolean add, UidRange[] uidRanges) throws ServiceSpecificException {
    mContext.enforceCallingOrSelfPermission(NETWORK_STACK, TAG);
    try {
        mNetdService.networkRejectNonSecureVpn(add, UidRange.toParcelArray(uidRanges));
    } catch (ServiceSpecificException e) {
        Log.w(TAG, "setAllowOnlyVpnForUids(" + add + ", " + Arrays.toString(uidRanges) + ")" + ": netd command failed", e);
        throw e;
    } catch (RemoteException e) {
        Log.w(TAG, "setAllowOnlyVpnForUids(" + add + ", " + Arrays.toString(uidRanges) + ")" + ": netd command failed", e);
        throw e.rethrowAsRuntimeException();
    }
}
#method_after
@Override
public void setAllowOnlyVpnForUids(boolean add, UidRange[] uidRanges) throws ServiceSpecificException {
    mContext.enforceCallingOrSelfPermission(NETWORK_STACK, TAG);
    try {
        mNetdService.networkRejectNonSecureVpn(add, uidRanges);
    } catch (ServiceSpecificException e) {
        Log.w(TAG, "setAllowOnlyVpnForUids(" + add + ", " + Arrays.toString(uidRanges) + ")" + ": netd command failed", e);
        throw e;
    } catch (RemoteException e) {
        Log.w(TAG, "setAllowOnlyVpnForUids(" + add + ", " + Arrays.toString(uidRanges) + ")" + ": netd command failed", e);
        throw e.rethrowAsRuntimeException();
    }
}
#end_block

#method_before
@Override
public void addVpnUidRanges(int netId, UidRange[] ranges) {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    try {
        mNetdService.networkAddUidRanges(netId, UidRange.toParcelArray(ranges));
    } catch (RemoteException | ServiceSpecificException e) {
        throw new IllegalStateException(e);
    }
}
#method_after
@Override
public void addVpnUidRanges(int netId, UidRange[] ranges) {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    try {
        mNetdService.networkAddUidRanges(netId, ranges);
    } catch (RemoteException | ServiceSpecificException e) {
        throw new IllegalStateException(e);
    }
}
#end_block

#method_before
@Override
public void removeVpnUidRanges(int netId, UidRange[] ranges) {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    try {
        mNetdService.networkRemoveUidRanges(netId, UidRange.toParcelArray(ranges));
    } catch (RemoteException | ServiceSpecificException e) {
        throw new IllegalStateException(e);
    }
}
#method_after
@Override
public void removeVpnUidRanges(int netId, UidRange[] ranges) {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    try {
        mNetdService.networkRemoveUidRanges(netId, ranges);
    } catch (RemoteException | ServiceSpecificException e) {
        throw new IllegalStateException(e);
    }
}
#end_block

#method_before
private void closeSocketsForFirewallChainLocked(int chain, String chainName) {
    // UID ranges to close sockets on.
    UidRange[] ranges;
    // UID ranges whose sockets we won't touch.
    int[] exemptUids;
    int numUids = 0;
    if (getFirewallType(chain) == FIREWALL_TYPE_WHITELIST) {
        // Close all sockets on all non-system UIDs...
        ranges = new UidRange[] { // specify their ranges here.
        new UidRange(Process.FIRST_APPLICATION_UID, Integer.MAX_VALUE) };
        // ... except for the UIDs that have allow rules.
        synchronized (mRulesLock) {
            final SparseIntArray rules = getUidFirewallRulesLR(chain);
            exemptUids = new int[rules.size()];
            for (int i = 0; i < exemptUids.length; i++) {
                if (rules.valueAt(i) == NetworkPolicyManager.FIREWALL_RULE_ALLOW) {
                    exemptUids[numUids] = rules.keyAt(i);
                    numUids++;
                }
            }
        }
        // fix setFirewallEnabled to grab mQuotaLock and clear rules.
        if (numUids != exemptUids.length) {
            exemptUids = Arrays.copyOf(exemptUids, numUids);
        }
    } else {
        // Close sockets for every UID that has a deny rule...
        synchronized (mRulesLock) {
            final SparseIntArray rules = getUidFirewallRulesLR(chain);
            ranges = new UidRange[rules.size()];
            for (int i = 0; i < ranges.length; i++) {
                if (rules.valueAt(i) == NetworkPolicyManager.FIREWALL_RULE_DENY) {
                    int uid = rules.keyAt(i);
                    ranges[numUids] = new UidRange(uid, uid);
                    numUids++;
                }
            }
        }
        // As above; usually numUids == ranges.length, but not always.
        if (numUids != ranges.length) {
            ranges = Arrays.copyOf(ranges, numUids);
        }
        // ... with no exceptions.
        exemptUids = new int[0];
    }
    try {
        mNetdService.socketDestroy(UidRange.toParcelArray(ranges), exemptUids);
    } catch (RemoteException | ServiceSpecificException e) {
        Slog.e(TAG, "Error closing sockets after enabling chain " + chainName + ": " + e);
    }
}
#method_after
private void closeSocketsForFirewallChainLocked(int chain, String chainName) {
    // UID ranges to close sockets on.
    UidRange[] ranges;
    // UID ranges whose sockets we won't touch.
    int[] exemptUids;
    int numUids = 0;
    if (getFirewallType(chain) == FIREWALL_TYPE_WHITELIST) {
        // Close all sockets on all non-system UIDs...
        ranges = new UidRange[] { // specify their ranges here.
        new UidRange(Process.FIRST_APPLICATION_UID, Integer.MAX_VALUE) };
        // ... except for the UIDs that have allow rules.
        synchronized (mRulesLock) {
            final SparseIntArray rules = getUidFirewallRulesLR(chain);
            exemptUids = new int[rules.size()];
            for (int i = 0; i < exemptUids.length; i++) {
                if (rules.valueAt(i) == NetworkPolicyManager.FIREWALL_RULE_ALLOW) {
                    exemptUids[numUids] = rules.keyAt(i);
                    numUids++;
                }
            }
        }
        // fix setFirewallEnabled to grab mQuotaLock and clear rules.
        if (numUids != exemptUids.length) {
            exemptUids = Arrays.copyOf(exemptUids, numUids);
        }
    } else {
        // Close sockets for every UID that has a deny rule...
        synchronized (mRulesLock) {
            final SparseIntArray rules = getUidFirewallRulesLR(chain);
            ranges = new UidRange[rules.size()];
            for (int i = 0; i < ranges.length; i++) {
                if (rules.valueAt(i) == NetworkPolicyManager.FIREWALL_RULE_DENY) {
                    int uid = rules.keyAt(i);
                    ranges[numUids] = new UidRange(uid, uid);
                    numUids++;
                }
            }
        }
        // As above; usually numUids == ranges.length, but not always.
        if (numUids != ranges.length) {
            ranges = Arrays.copyOf(ranges, numUids);
        }
        // ... with no exceptions.
        exemptUids = new int[0];
    }
    try {
        mNetdService.socketDestroy(ranges, exemptUids);
    } catch (RemoteException | ServiceSpecificException e) {
        Slog.e(TAG, "Error closing sockets after enabling chain " + chainName + ": " + e);
    }
}
#end_block

#method_before
@Override
public void addInterfaceToLocalNetwork(String iface, List<RouteInfo> routes) {
    modifyInterfaceInNetwork(MODIFY_OPERATION_ADD, INetd.NETID_LOCAL, iface);
    for (RouteInfo route : routes) {
        if (!route.isDefaultRoute()) {
            modifyRoute(MODIFY_OPERATION_ADD, INetd.NETID_LOCAL, route);
        }
    }
}
#method_after
@Override
public void addInterfaceToLocalNetwork(String iface, List<RouteInfo> routes) {
    modifyInterfaceInNetwork(MODIFY_OPERATION_ADD, INetd.LOCAL_NET_ID, iface);
    for (RouteInfo route : routes) {
        if (!route.isDefaultRoute()) {
            modifyRoute(MODIFY_OPERATION_ADD, INetd.LOCAL_NET_ID, route);
        }
    }
}
#end_block

#method_before
@Override
public void removeInterfaceFromLocalNetwork(String iface) {
    modifyInterfaceInNetwork(MODIFY_OPERATION_REMOVE, INetd.NETID_LOCAL, iface);
}
#method_after
@Override
public void removeInterfaceFromLocalNetwork(String iface) {
    modifyInterfaceInNetwork(MODIFY_OPERATION_REMOVE, INetd.LOCAL_NET_ID, iface);
}
#end_block

#method_before
@Override
public int removeRoutesFromLocalNetwork(List<RouteInfo> routes) {
    int failures = 0;
    for (RouteInfo route : routes) {
        try {
            modifyRoute(MODIFY_OPERATION_REMOVE, INetd.NETID_LOCAL, route);
        } catch (IllegalStateException e) {
            failures++;
        }
    }
    return failures;
}
#method_after
@Override
public int removeRoutesFromLocalNetwork(List<RouteInfo> routes) {
    int failures = 0;
    for (RouteInfo route : routes) {
        try {
            modifyRoute(MODIFY_OPERATION_REMOVE, INetd.LOCAL_NET_ID, route);
        } catch (IllegalStateException e) {
            failures++;
        }
    }
    return failures;
}
#end_block

#method_before
private void updateMtu(LinkProperties newLp, LinkProperties oldLp) {
    final String iface = newLp.getInterfaceName();
    final int mtu = newLp.getMtu();
    if (oldLp == null && mtu == 0) {
        // Silently ignore unset MTU value.
        return;
    }
    if (oldLp != null && newLp.isIdenticalMtu(oldLp)) {
        if (VDBG)
            log("identical MTU - not setting");
        return;
    }
    if (LinkProperties.isValidMtu(mtu, newLp.hasGlobalIPv6Address()) == false) {
        if (mtu != 0)
            loge("Unexpected mtu value: " + mtu + ", " + iface);
        return;
    }
    // Cannot set MTU without interface name
    if (TextUtils.isEmpty(iface)) {
        loge("Setting MTU size with null iface.");
        return;
    }
    try {
        if (VDBG || DEBUG)
            log("Setting MTU size: " + iface + ", " + mtu);
        mNMS.setMtu(iface, mtu);
    } catch (Exception e) {
        Slog.e(TAG, "exception in setMtu()" + e);
    }
}
#method_after
private void updateMtu(LinkProperties newLp, LinkProperties oldLp) {
    final String iface = newLp.getInterfaceName();
    final int mtu = newLp.getMtu();
    if (oldLp == null && mtu == 0) {
        // Silently ignore unset MTU value.
        return;
    }
    if (oldLp != null && newLp.isIdenticalMtu(oldLp)) {
        if (VDBG)
            log("identical MTU - not setting");
        return;
    }
    if (LinkProperties.isValidMtu(mtu, newLp.hasGlobalIPv6Address()) == false) {
        if (mtu != 0)
            loge("Unexpected mtu value: " + mtu + ", " + iface);
        return;
    }
    // Cannot set MTU without interface name
    if (TextUtils.isEmpty(iface)) {
        loge("Setting MTU size with null iface.");
        return;
    }
    try {
        if (VDBG || DDBG)
            log("Setting MTU size: " + iface + ", " + mtu);
        mNMS.setMtu(iface, mtu);
    } catch (Exception e) {
        Slog.e(TAG, "exception in setMtu()" + e);
    }
}
#end_block

#method_before
private void updateTcpBufferSizes(NetworkAgentInfo nai) {
    if (isDefaultNetwork(nai) == false) {
        return;
    }
    String tcpBufferSizes = nai.linkProperties.getTcpBufferSizes();
    String[] values = null;
    if (tcpBufferSizes != null) {
        values = tcpBufferSizes.split(",");
    }
    if (values == null || values.length != 6) {
        if (DBG)
            log("Invalid tcpBufferSizes string: " + tcpBufferSizes + ", using defaults");
        tcpBufferSizes = DEFAULT_TCP_BUFFER_SIZES;
        values = tcpBufferSizes.split(",");
    }
    if (tcpBufferSizes.equals(mCurrentTcpBufferSizes))
        return;
    try {
        if (VDBG || DEBUG)
            Slog.d(TAG, "Setting tx/rx TCP buffers to " + tcpBufferSizes);
        final String prefix = "/sys/kernel/ipv4/tcp_";
        FileUtils.stringToFile(prefix + "rmem_min", values[0]);
        FileUtils.stringToFile(prefix + "rmem_def", values[1]);
        FileUtils.stringToFile(prefix + "rmem_max", values[2]);
        FileUtils.stringToFile(prefix + "wmem_min", values[3]);
        FileUtils.stringToFile(prefix + "wmem_def", values[4]);
        FileUtils.stringToFile(prefix + "wmem_max", values[5]);
        mCurrentTcpBufferSizes = tcpBufferSizes;
    } catch (IOException e) {
        loge("Can't set TCP buffer sizes:" + e);
    }
    Integer rwndValue = Settings.Global.getInt(mContext.getContentResolver(), Settings.Global.TCP_DEFAULT_INIT_RWND, mSystemProperties.getInt("net.tcp.default_init_rwnd", 0));
    final String sysctlKey = "sys.sysctl.tcp_def_init_rwnd";
    if (rwndValue != 0) {
        mSystemProperties.set(sysctlKey, rwndValue.toString());
    }
}
#method_after
private void updateTcpBufferSizes(NetworkAgentInfo nai) {
    if (isDefaultNetwork(nai) == false) {
        return;
    }
    String tcpBufferSizes = nai.linkProperties.getTcpBufferSizes();
    String[] values = null;
    if (tcpBufferSizes != null) {
        values = tcpBufferSizes.split(",");
    }
    if (values == null || values.length != 6) {
        if (DBG)
            log("Invalid tcpBufferSizes string: " + tcpBufferSizes + ", using defaults");
        tcpBufferSizes = DEFAULT_TCP_BUFFER_SIZES;
        values = tcpBufferSizes.split(",");
    }
    if (tcpBufferSizes.equals(mCurrentTcpBufferSizes))
        return;
    try {
        if (VDBG || DDBG)
            Slog.d(TAG, "Setting tx/rx TCP buffers to " + tcpBufferSizes);
        final String prefix = "/sys/kernel/ipv4/tcp_";
        FileUtils.stringToFile(prefix + "rmem_min", values[0]);
        FileUtils.stringToFile(prefix + "rmem_def", values[1]);
        FileUtils.stringToFile(prefix + "rmem_max", values[2]);
        FileUtils.stringToFile(prefix + "wmem_min", values[3]);
        FileUtils.stringToFile(prefix + "wmem_def", values[4]);
        FileUtils.stringToFile(prefix + "wmem_max", values[5]);
        mCurrentTcpBufferSizes = tcpBufferSizes;
    } catch (IOException e) {
        loge("Can't set TCP buffer sizes:" + e);
    }
    Integer rwndValue = Settings.Global.getInt(mContext.getContentResolver(), Settings.Global.TCP_DEFAULT_INIT_RWND, mSystemProperties.getInt("net.tcp.default_init_rwnd", 0));
    final String sysctlKey = "sys.sysctl.tcp_def_init_rwnd";
    if (rwndValue != 0) {
        mSystemProperties.set(sysctlKey, rwndValue.toString());
    }
}
#end_block

#method_before
private void handleRemoveNetworkRequest(final NetworkRequestInfo nri) {
    nri.unlinkDeathRecipient();
    mNetworkRequests.remove(nri.request);
    synchronized (mUidToNetworkRequestCount) {
        int requests = mUidToNetworkRequestCount.get(nri.mUid, 0);
        if (requests < 1) {
            Slog.wtf(TAG, "BUG: too small request count " + requests + " for UID " + nri.mUid);
        } else if (requests == 1) {
            mUidToNetworkRequestCount.removeAt(mUidToNetworkRequestCount.indexOfKey(nri.mUid));
        } else {
            mUidToNetworkRequestCount.put(nri.mUid, requests - 1);
        }
    }
    mNetworkRequestInfoLogs.log("RELEASE " + nri);
    if (nri.request.isRequest()) {
        boolean wasKept = false;
        NetworkAgentInfo nai = getNetworkForRequest(nri.request.requestId);
        if (nai != null) {
            boolean wasBackgroundNetwork = nai.isBackgroundNetwork();
            nai.removeRequest(nri.request.requestId);
            if (VDBG || DEBUG) {
                log(" Removing from current network " + nai.name() + ", leaving " + nai.numNetworkRequests() + " requests.");
            }
            // If there are still lingered requests on this network, don't tear it down,
            // but resume lingering instead.
            updateLingerState(nai, SystemClock.elapsedRealtime());
            if (unneeded(nai, UnneededFor.TEARDOWN)) {
                if (DBG)
                    log("no live requests for " + nai.name() + "; disconnecting");
                teardownUnneededNetwork(nai);
            } else {
                wasKept = true;
            }
            clearNetworkForRequest(nri.request.requestId);
            if (!wasBackgroundNetwork && nai.isBackgroundNetwork()) {
                // Went from foreground to background.
                updateCapabilities(nai.getCurrentScore(), nai, nai.networkCapabilities);
            }
        }
        // phantom disconnect for this type.
        if (nri.request.legacyType != TYPE_NONE && nai != null) {
            boolean doRemove = true;
            if (wasKept) {
                // same legacy type - if so, don't remove the nai
                for (int i = 0; i < nai.numNetworkRequests(); i++) {
                    NetworkRequest otherRequest = nai.requestAt(i);
                    if (otherRequest.legacyType == nri.request.legacyType && otherRequest.isRequest()) {
                        if (DBG)
                            log(" still have other legacy request - leaving");
                        doRemove = false;
                    }
                }
            }
            if (doRemove) {
                mLegacyTypeTracker.remove(nri.request.legacyType, nai, false);
            }
        }
        for (NetworkFactoryInfo nfi : mNetworkFactoryInfos.values()) {
            nfi.asyncChannel.sendMessage(android.net.NetworkFactory.CMD_CANCEL_REQUEST, nri.request);
        }
    } else {
        // if this listen request applies and remove it.
        for (NetworkAgentInfo nai : mNetworkAgentInfos.values()) {
            nai.removeRequest(nri.request.requestId);
            if (nri.request.networkCapabilities.hasSignalStrength() && nai.satisfiesImmutableCapabilitiesOf(nri.request)) {
                updateSignalStrengthThresholds(nai, "RELEASE", nri.request);
            }
        }
    }
}
#method_after
private void handleRemoveNetworkRequest(final NetworkRequestInfo nri) {
    nri.unlinkDeathRecipient();
    mNetworkRequests.remove(nri.request);
    synchronized (mUidToNetworkRequestCount) {
        int requests = mUidToNetworkRequestCount.get(nri.mUid, 0);
        if (requests < 1) {
            Slog.wtf(TAG, "BUG: too small request count " + requests + " for UID " + nri.mUid);
        } else if (requests == 1) {
            mUidToNetworkRequestCount.removeAt(mUidToNetworkRequestCount.indexOfKey(nri.mUid));
        } else {
            mUidToNetworkRequestCount.put(nri.mUid, requests - 1);
        }
    }
    mNetworkRequestInfoLogs.log("RELEASE " + nri);
    if (nri.request.isRequest()) {
        boolean wasKept = false;
        NetworkAgentInfo nai = getNetworkForRequest(nri.request.requestId);
        if (nai != null) {
            boolean wasBackgroundNetwork = nai.isBackgroundNetwork();
            nai.removeRequest(nri.request.requestId);
            if (VDBG || DDBG) {
                log(" Removing from current network " + nai.name() + ", leaving " + nai.numNetworkRequests() + " requests.");
            }
            // If there are still lingered requests on this network, don't tear it down,
            // but resume lingering instead.
            updateLingerState(nai, SystemClock.elapsedRealtime());
            if (unneeded(nai, UnneededFor.TEARDOWN)) {
                if (DBG)
                    log("no live requests for " + nai.name() + "; disconnecting");
                teardownUnneededNetwork(nai);
            } else {
                wasKept = true;
            }
            clearNetworkForRequest(nri.request.requestId);
            if (!wasBackgroundNetwork && nai.isBackgroundNetwork()) {
                // Went from foreground to background.
                updateCapabilities(nai.getCurrentScore(), nai, nai.networkCapabilities);
            }
        }
        // phantom disconnect for this type.
        if (nri.request.legacyType != TYPE_NONE && nai != null) {
            boolean doRemove = true;
            if (wasKept) {
                // same legacy type - if so, don't remove the nai
                for (int i = 0; i < nai.numNetworkRequests(); i++) {
                    NetworkRequest otherRequest = nai.requestAt(i);
                    if (otherRequest.legacyType == nri.request.legacyType && otherRequest.isRequest()) {
                        if (DBG)
                            log(" still have other legacy request - leaving");
                        doRemove = false;
                    }
                }
            }
            if (doRemove) {
                mLegacyTypeTracker.remove(nri.request.legacyType, nai, false);
            }
        }
        for (NetworkFactoryInfo nfi : mNetworkFactoryInfos.values()) {
            nfi.asyncChannel.sendMessage(android.net.NetworkFactory.CMD_CANCEL_REQUEST, nri.request);
        }
    } else {
        // if this listen request applies and remove it.
        for (NetworkAgentInfo nai : mNetworkAgentInfos.values()) {
            nai.removeRequest(nri.request.requestId);
            if (nri.request.networkCapabilities.hasSignalStrength() && nai.satisfiesImmutableCapabilitiesOf(nri.request)) {
                updateSignalStrengthThresholds(nai, "RELEASE", nri.request);
            }
        }
    }
}
#end_block

#method_before
private void handlePromptUnvalidated(Network network) {
    if (VDBG || DEBUG)
        log("handlePromptUnvalidated " + network);
    NetworkAgentInfo nai = getNetworkAgentInfoForNetwork(network);
    // Also don't prompt on captive portals because we're already prompting the user to sign in.
    if (nai == null || nai.everValidated || nai.everCaptivePortalDetected || !nai.networkMisc.explicitlySelected || nai.networkMisc.acceptUnvalidated) {
        return;
    }
    showValidationNotification(nai, NotificationType.NO_INTERNET);
}
#method_after
private void handlePromptUnvalidated(Network network) {
    if (VDBG || DDBG)
        log("handlePromptUnvalidated " + network);
    NetworkAgentInfo nai = getNetworkAgentInfoForNetwork(network);
    // Also don't prompt on captive portals because we're already prompting the user to sign in.
    if (nai == null || nai.everValidated || nai.everCaptivePortalDetected || !nai.networkMisc.explicitlySelected || nai.networkMisc.acceptUnvalidated) {
        return;
    }
    showValidationNotification(nai, NotificationType.NO_INTERNET);
}
#end_block

#method_before
private boolean updateRoutes(LinkProperties newLp, LinkProperties oldLp, int netId) {
    // Compare the route diff to determine which routes should be added and removed.
    CompareResult<RouteInfo> routeDiff = new CompareResult<RouteInfo>(oldLp != null ? oldLp.getAllRoutes() : null, newLp != null ? newLp.getAllRoutes() : null);
    // do this twice, adding non-next-hop routes first, then routes they are dependent on
    for (RouteInfo route : routeDiff.added) {
        if (route.hasGateway())
            continue;
        if (VDBG || DEBUG)
            log("Adding Route [" + route + "] to network " + netId);
        try {
            mNMS.addRoute(netId, route);
        } catch (Exception e) {
            if ((route.getDestination().getAddress() instanceof Inet4Address) || VDBG) {
                loge("Exception in addRoute for non-gateway: " + e);
            }
        }
    }
    for (RouteInfo route : routeDiff.added) {
        if (route.hasGateway() == false)
            continue;
        if (VDBG || DEBUG)
            log("Adding Route [" + route + "] to network " + netId);
        try {
            mNMS.addRoute(netId, route);
        } catch (Exception e) {
            if ((route.getGateway() instanceof Inet4Address) || VDBG) {
                loge("Exception in addRoute for gateway: " + e);
            }
        }
    }
    for (RouteInfo route : routeDiff.removed) {
        if (VDBG || DEBUG)
            log("Removing Route [" + route + "] from network " + netId);
        try {
            mNMS.removeRoute(netId, route);
        } catch (Exception e) {
            loge("Exception in removeRoute: " + e);
        }
    }
    return !routeDiff.added.isEmpty() || !routeDiff.removed.isEmpty();
}
#method_after
private boolean updateRoutes(LinkProperties newLp, LinkProperties oldLp, int netId) {
    // Compare the route diff to determine which routes should be added and removed.
    CompareResult<RouteInfo> routeDiff = new CompareResult<RouteInfo>(oldLp != null ? oldLp.getAllRoutes() : null, newLp != null ? newLp.getAllRoutes() : null);
    // do this twice, adding non-next-hop routes first, then routes they are dependent on
    for (RouteInfo route : routeDiff.added) {
        if (route.hasGateway())
            continue;
        if (VDBG || DDBG)
            log("Adding Route [" + route + "] to network " + netId);
        try {
            mNMS.addRoute(netId, route);
        } catch (Exception e) {
            if ((route.getDestination().getAddress() instanceof Inet4Address) || VDBG) {
                loge("Exception in addRoute for non-gateway: " + e);
            }
        }
    }
    for (RouteInfo route : routeDiff.added) {
        if (route.hasGateway() == false)
            continue;
        if (VDBG || DDBG)
            log("Adding Route [" + route + "] to network " + netId);
        try {
            mNMS.addRoute(netId, route);
        } catch (Exception e) {
            if ((route.getGateway() instanceof Inet4Address) || VDBG) {
                loge("Exception in addRoute for gateway: " + e);
            }
        }
    }
    for (RouteInfo route : routeDiff.removed) {
        if (VDBG || DDBG)
            log("Removing Route [" + route + "] from network " + netId);
        try {
            mNMS.removeRoute(netId, route);
        } catch (Exception e) {
            loge("Exception in removeRoute: " + e);
        }
    }
    return !routeDiff.added.isEmpty() || !routeDiff.removed.isEmpty();
}
#end_block

#method_before
public void handleUpdateLinkProperties(NetworkAgentInfo nai, LinkProperties newLp) {
    if (getNetworkAgentInfoForNetId(nai.network.netId) != nai) {
        // Ignore updates for disconnected networks
        return;
    }
    // newLp is already a defensive copy.
    newLp.ensureDirectlyConnectedRoutes();
    if (VDBG || DEBUG) {
        log("Update of LinkProperties for " + nai.name() + "; created=" + nai.created + "; everConnected=" + nai.everConnected);
    }
    LinkProperties oldLp = nai.linkProperties;
    synchronized (nai) {
        nai.linkProperties = newLp;
    }
    if (nai.everConnected) {
        updateLinkProperties(nai, oldLp);
    }
}
#method_after
public void handleUpdateLinkProperties(NetworkAgentInfo nai, LinkProperties newLp) {
    if (getNetworkAgentInfoForNetId(nai.network.netId) != nai) {
        // Ignore updates for disconnected networks
        return;
    }
    // newLp is already a defensive copy.
    newLp.ensureDirectlyConnectedRoutes();
    if (VDBG || DDBG) {
        log("Update of LinkProperties for " + nai.name() + "; created=" + nai.created + "; everConnected=" + nai.everConnected);
    }
    LinkProperties oldLp = nai.linkProperties;
    synchronized (nai) {
        nai.linkProperties = newLp;
    }
    if (nai.everConnected) {
        updateLinkProperties(nai, oldLp);
    }
}
#end_block

#method_before
private void sendUpdatedScoreToFactories(NetworkRequest networkRequest, int score) {
    if (VDBG || DEBUG) {
        log("sending new Min Network Score(" + score + "): " + networkRequest.toString());
    }
    for (NetworkFactoryInfo nfi : mNetworkFactoryInfos.values()) {
        nfi.asyncChannel.sendMessage(android.net.NetworkFactory.CMD_REQUEST_NETWORK, score, 0, networkRequest);
    }
}
#method_after
private void sendUpdatedScoreToFactories(NetworkRequest networkRequest, int score) {
    if (VDBG || DDBG) {
        log("sending new Min Network Score(" + score + "): " + networkRequest.toString());
    }
    for (NetworkFactoryInfo nfi : mNetworkFactoryInfos.values()) {
        nfi.asyncChannel.sendMessage(android.net.NetworkFactory.CMD_REQUEST_NETWORK, score, 0, networkRequest);
    }
}
#end_block

#method_before
private void callCallbackForRequest(NetworkRequestInfo nri, NetworkAgentInfo networkAgent, int notificationType, int arg1) {
    if (nri.messenger == null) {
        // Default request has no msgr
        return;
    }
    Bundle bundle = new Bundle();
    // TODO: check if defensive copies of data is needed.
    putParcelable(bundle, new NetworkRequest(nri.request));
    Message msg = Message.obtain();
    if (notificationType != ConnectivityManager.CALLBACK_UNAVAIL) {
        putParcelable(bundle, networkAgent.network);
    }
    switch(notificationType) {
        case ConnectivityManager.CALLBACK_AVAILABLE:
            {
                putParcelable(bundle, new NetworkCapabilities(networkAgent.networkCapabilities));
                putParcelable(bundle, new LinkProperties(networkAgent.linkProperties));
                break;
            }
        case ConnectivityManager.CALLBACK_LOSING:
            {
                msg.arg1 = arg1;
                break;
            }
        case ConnectivityManager.CALLBACK_CAP_CHANGED:
            {
                // networkAgent can't be null as it has been accessed a few lines above.
                final NetworkCapabilities nc = networkCapabilitiesRestrictedForCallerPermissions(networkAgent.networkCapabilities, nri.mPid, nri.mUid);
                putParcelable(bundle, nc);
                break;
            }
        case ConnectivityManager.CALLBACK_IP_CHANGED:
            {
                putParcelable(bundle, new LinkProperties(networkAgent.linkProperties));
                break;
            }
    }
    msg.what = notificationType;
    msg.setData(bundle);
    try {
        if (VDBG || (DEBUG && nri.request.isRequest())) {
            String notification = ConnectivityManager.getCallbackName(notificationType);
            log("sending notification " + notification + " for " + nri.request);
        }
        nri.messenger.send(msg);
    } catch (RemoteException e) {
        // may occur naturally in the race of binder death.
        loge("RemoteException caught trying to send a callback msg for " + nri.request);
    }
}
#method_after
private void callCallbackForRequest(NetworkRequestInfo nri, NetworkAgentInfo networkAgent, int notificationType, int arg1) {
    if (nri.messenger == null) {
        // Default request has no msgr
        return;
    }
    Bundle bundle = new Bundle();
    // TODO: check if defensive copies of data is needed.
    putParcelable(bundle, new NetworkRequest(nri.request));
    Message msg = Message.obtain();
    if (notificationType != ConnectivityManager.CALLBACK_UNAVAIL) {
        putParcelable(bundle, networkAgent.network);
    }
    switch(notificationType) {
        case ConnectivityManager.CALLBACK_AVAILABLE:
            {
                putParcelable(bundle, new NetworkCapabilities(networkAgent.networkCapabilities));
                putParcelable(bundle, new LinkProperties(networkAgent.linkProperties));
                break;
            }
        case ConnectivityManager.CALLBACK_LOSING:
            {
                msg.arg1 = arg1;
                break;
            }
        case ConnectivityManager.CALLBACK_CAP_CHANGED:
            {
                // networkAgent can't be null as it has been accessed a few lines above.
                final NetworkCapabilities nc = networkCapabilitiesRestrictedForCallerPermissions(networkAgent.networkCapabilities, nri.mPid, nri.mUid);
                putParcelable(bundle, nc);
                break;
            }
        case ConnectivityManager.CALLBACK_IP_CHANGED:
            {
                putParcelable(bundle, new LinkProperties(networkAgent.linkProperties));
                break;
            }
    }
    msg.what = notificationType;
    msg.setData(bundle);
    try {
        if (VDBG) {
            String notification = ConnectivityManager.getCallbackName(notificationType);
            log("sending notification " + notification + " for " + nri.request);
        }
        nri.messenger.send(msg);
    } catch (RemoteException e) {
        // may occur naturally in the race of binder death.
        loge("RemoteException caught trying to send a callback msg for " + nri.request);
    }
}
#end_block

#method_before
// Handles a network appearing or improving its score.
// 
// - Evaluates all current NetworkRequests that can be
// satisfied by newNetwork, and reassigns to newNetwork
// any such requests for which newNetwork is the best.
// 
// - Lingers any validated Networks that as a result are no longer
// needed. A network is needed if it is the best network for
// one or more NetworkRequests, or if it is a VPN.
// 
// - Tears down newNetwork if it just became validated
// but turns out to be unneeded.
// 
// - If reapUnvalidatedNetworks==REAP, tears down unvalidated
// networks that have no chance (i.e. even if validated)
// of becoming the highest scoring network.
// 
// NOTE: This function only adds NetworkRequests that "newNetwork" could satisfy,
// it does not remove NetworkRequests that other Networks could better satisfy.
// If you need to handle decreases in score, use {@link rematchAllNetworksAndRequests}.
// This function should be used when possible instead of {@code rematchAllNetworksAndRequests}
// as it performs better by a factor of the number of Networks.
// 
// @param newNetwork is the network to be matched against NetworkRequests.
// @param reapUnvalidatedNetworks indicates if an additional pass over all networks should be
// performed to tear down unvalidated networks that have no chance (i.e. even if
private void rematchNetworkAndRequests(NetworkAgentInfo newNetwork, ReapUnvalidatedNetworks reapUnvalidatedNetworks, long now) {
    if (!newNetwork.everConnected)
        return;
    boolean keep = newNetwork.isVPN();
    boolean isNewDefault = false;
    NetworkAgentInfo oldDefaultNetwork = null;
    final boolean wasBackgroundNetwork = newNetwork.isBackgroundNetwork();
    final int score = newNetwork.getCurrentScore();
    if (VDBG || DEBUG)
        log("rematching " + newNetwork.name());
    // Find and migrate to this Network any NetworkRequests for
    // which this network is now the best.
    ArrayList<NetworkAgentInfo> affectedNetworks = new ArrayList<>();
    ArrayList<NetworkRequestInfo> addedRequests = new ArrayList<>();
    NetworkCapabilities nc = newNetwork.networkCapabilities;
    if (VDBG)
        log(" network has: " + nc);
    for (NetworkRequestInfo nri : mNetworkRequests.values()) {
        // requests or not, and doesn't affect the network's score.
        if (nri.request.isListen())
            continue;
        final NetworkAgentInfo currentNetwork = getNetworkForRequest(nri.request.requestId);
        final boolean satisfies = newNetwork.satisfies(nri.request);
        if (newNetwork == currentNetwork && satisfies) {
            if (VDBG) {
                log("Network " + newNetwork.name() + " was already satisfying" + " request " + nri.request.requestId + ". No change.");
            }
            keep = true;
            continue;
        }
        // check if it satisfies the NetworkCapabilities
        if (VDBG)
            log("  checking if request is satisfied: " + nri.request);
        if (satisfies) {
            // this request
            if (VDBG || DEBUG) {
                log("currentScore = " + (currentNetwork != null ? currentNetwork.getCurrentScore() : 0) + ", newScore = " + score);
            }
            if (currentNetwork == null || currentNetwork.getCurrentScore() < score) {
                if (VDBG)
                    log("rematch for " + newNetwork.name());
                if (currentNetwork != null) {
                    if (VDBG || DEBUG) {
                        log("   accepting network in place of " + currentNetwork.name());
                    }
                    currentNetwork.removeRequest(nri.request.requestId);
                    currentNetwork.lingerRequest(nri.request, now, mLingerDelayMs);
                    affectedNetworks.add(currentNetwork);
                } else {
                    if (VDBG || DEBUG)
                        log("   accepting network in place of null");
                }
                newNetwork.unlingerRequest(nri.request);
                setNetworkForRequest(nri.request.requestId, newNetwork);
                if (!newNetwork.addRequest(nri.request)) {
                    Slog.wtf(TAG, "BUG: " + newNetwork.name() + " already has " + nri.request);
                }
                addedRequests.add(nri);
                keep = true;
                // Tell NetworkFactories about the new score, so they can stop
                // trying to connect if they know they cannot match it.
                // TODO - this could get expensive if we have a lot of requests for this
                // network.  Think about if there is a way to reduce this.  Push
                // netid->request mapping to each factory?
                sendUpdatedScoreToFactories(nri.request, score);
                if (isDefaultRequest(nri)) {
                    isNewDefault = true;
                    oldDefaultNetwork = currentNetwork;
                    if (currentNetwork != null) {
                        mLingerMonitor.noteLingerDefaultNetwork(currentNetwork, newNetwork);
                    }
                }
            }
        } else if (newNetwork.isSatisfyingRequest(nri.request.requestId)) {
            // longer satisfies "nri" when "currentNetwork" does not equal "newNetwork".
            if (DBG) {
                log("Network " + newNetwork.name() + " stopped satisfying" + " request " + nri.request.requestId);
            }
            newNetwork.removeRequest(nri.request.requestId);
            if (currentNetwork == newNetwork) {
                clearNetworkForRequest(nri.request.requestId);
                sendUpdatedScoreToFactories(nri.request, 0);
            } else {
                Slog.wtf(TAG, "BUG: Removing request " + nri.request.requestId + " from " + newNetwork.name() + " without updating mNetworkForRequestId or factories!");
            }
            // TODO: Technically, sending CALLBACK_LOST here is
            // incorrect if there is a replacement network currently
            // connected that can satisfy nri, which is a request
            // (not a listen). However, the only capability that can both
            // a) be requested and b) change is NET_CAPABILITY_TRUSTED,
            // so this code is only incorrect for a network that loses
            // the TRUSTED capability, which is a rare case.
            callCallbackForRequest(nri, newNetwork, ConnectivityManager.CALLBACK_LOST, 0);
        }
    }
    if (isNewDefault) {
        updateDataActivityTracking(newNetwork, oldDefaultNetwork);
        // Notify system services that this network is up.
        makeDefault(newNetwork);
        // Log 0 -> X and Y -> X default network transitions, where X is the new default.
        metricsLogger().defaultNetworkMetrics().logDefaultNetworkEvent(now, newNetwork, oldDefaultNetwork);
        // Have a new default network, release the transition wakelock in
        scheduleReleaseNetworkTransitionWakelock();
    }
    if (!newNetwork.networkCapabilities.equalRequestableCapabilities(nc)) {
        Slog.wtf(TAG, String.format("BUG: %s changed requestable capabilities during rematch: %s -> %s", newNetwork.name(), nc, newNetwork.networkCapabilities));
    }
    if (newNetwork.getCurrentScore() != score) {
        Slog.wtf(TAG, String.format("BUG: %s changed score during rematch: %d -> %d", newNetwork.name(), score, newNetwork.getCurrentScore()));
    }
    // Second pass: process all listens.
    if (wasBackgroundNetwork != newNetwork.isBackgroundNetwork()) {
        // If the network went from background to foreground or vice versa, we need to update
        // its foreground state. It is safe to do this after rematching the requests because
        // NET_CAPABILITY_FOREGROUND does not affect requests, as is not a requestable
        // capability and does not affect the network's score (see the Slog.wtf call above).
        updateCapabilities(score, newNetwork, newNetwork.networkCapabilities);
    } else {
        processListenRequests(newNetwork, false);
    }
    // before LegacyTypeTracker sends legacy broadcasts
    for (NetworkRequestInfo nri : addedRequests) notifyNetworkAvailable(newNetwork, nri);
    // available callback for newNetwork.
    for (NetworkAgentInfo nai : affectedNetworks) {
        updateLingerState(nai, now);
    }
    // Possibly unlinger newNetwork. Unlingering a network does not send any callbacks so it
    // does not need to be done in any particular order.
    updateLingerState(newNetwork, now);
    if (isNewDefault) {
        // the new one connected.
        if (oldDefaultNetwork != null) {
            mLegacyTypeTracker.remove(oldDefaultNetwork.networkInfo.getType(), oldDefaultNetwork, true);
        }
        mDefaultInetConditionPublished = newNetwork.lastValidated ? 100 : 0;
        mLegacyTypeTracker.add(newNetwork.networkInfo.getType(), newNetwork);
        notifyLockdownVpn(newNetwork);
    }
    if (keep) {
        // TODO: Avoid redoing this; this must only be done once when a network comes online.
        try {
            final IBatteryStats bs = BatteryStatsService.getService();
            final int type = newNetwork.networkInfo.getType();
            final String baseIface = newNetwork.linkProperties.getInterfaceName();
            bs.noteNetworkInterfaceType(baseIface, type);
            for (LinkProperties stacked : newNetwork.linkProperties.getStackedLinks()) {
                final String stackedIface = stacked.getInterfaceName();
                bs.noteNetworkInterfaceType(stackedIface, type);
            }
        } catch (RemoteException ignored) {
        }
        // This is on top of the multiple intent sequencing referenced in the todo above.
        for (int i = 0; i < newNetwork.numNetworkRequests(); i++) {
            NetworkRequest nr = newNetwork.requestAt(i);
            if (nr.legacyType != TYPE_NONE && nr.isRequest()) {
                // legacy type tracker filters out repeat adds
                mLegacyTypeTracker.add(nr.legacyType, newNetwork);
            }
        }
        // newNetwork to the tracker explicitly (it's a no-op if it has already been added).
        if (newNetwork.isVPN()) {
            mLegacyTypeTracker.add(TYPE_VPN, newNetwork);
        }
    }
    if (reapUnvalidatedNetworks == ReapUnvalidatedNetworks.REAP) {
        for (NetworkAgentInfo nai : mNetworkAgentInfos.values()) {
            if (unneeded(nai, UnneededFor.TEARDOWN)) {
                if (nai.getLingerExpiry() > 0) {
                    // This network has active linger timers and no requests, but is not
                    // lingering. Linger it.
                    // 
                    // One way (the only way?) this can happen if this network is unvalidated
                    // and became unneeded due to another network improving its score to the
                    // point where this network will no longer be able to satisfy any requests
                    // even if it validates.
                    updateLingerState(nai, now);
                } else {
                    if (DBG)
                        log("Reaping " + nai.name());
                    teardownUnneededNetwork(nai);
                }
            }
        }
    }
}
#method_after
// Handles a network appearing or improving its score.
// 
// - Evaluates all current NetworkRequests that can be
// satisfied by newNetwork, and reassigns to newNetwork
// any such requests for which newNetwork is the best.
// 
// - Lingers any validated Networks that as a result are no longer
// needed. A network is needed if it is the best network for
// one or more NetworkRequests, or if it is a VPN.
// 
// - Tears down newNetwork if it just became validated
// but turns out to be unneeded.
// 
// - If reapUnvalidatedNetworks==REAP, tears down unvalidated
// networks that have no chance (i.e. even if validated)
// of becoming the highest scoring network.
// 
// NOTE: This function only adds NetworkRequests that "newNetwork" could satisfy,
// it does not remove NetworkRequests that other Networks could better satisfy.
// If you need to handle decreases in score, use {@link rematchAllNetworksAndRequests}.
// This function should be used when possible instead of {@code rematchAllNetworksAndRequests}
// as it performs better by a factor of the number of Networks.
// 
// @param newNetwork is the network to be matched against NetworkRequests.
// @param reapUnvalidatedNetworks indicates if an additional pass over all networks should be
// performed to tear down unvalidated networks that have no chance (i.e. even if
private void rematchNetworkAndRequests(NetworkAgentInfo newNetwork, ReapUnvalidatedNetworks reapUnvalidatedNetworks, long now) {
    if (!newNetwork.everConnected)
        return;
    boolean keep = newNetwork.isVPN();
    boolean isNewDefault = false;
    NetworkAgentInfo oldDefaultNetwork = null;
    final boolean wasBackgroundNetwork = newNetwork.isBackgroundNetwork();
    final int score = newNetwork.getCurrentScore();
    if (VDBG || DDBG)
        log("rematching " + newNetwork.name());
    // Find and migrate to this Network any NetworkRequests for
    // which this network is now the best.
    ArrayList<NetworkAgentInfo> affectedNetworks = new ArrayList<>();
    ArrayList<NetworkRequestInfo> addedRequests = new ArrayList<>();
    NetworkCapabilities nc = newNetwork.networkCapabilities;
    if (VDBG)
        log(" network has: " + nc);
    for (NetworkRequestInfo nri : mNetworkRequests.values()) {
        // requests or not, and doesn't affect the network's score.
        if (nri.request.isListen())
            continue;
        final NetworkAgentInfo currentNetwork = getNetworkForRequest(nri.request.requestId);
        final boolean satisfies = newNetwork.satisfies(nri.request);
        if (newNetwork == currentNetwork && satisfies) {
            if (VDBG) {
                log("Network " + newNetwork.name() + " was already satisfying" + " request " + nri.request.requestId + ". No change.");
            }
            keep = true;
            continue;
        }
        // check if it satisfies the NetworkCapabilities
        if (VDBG)
            log("  checking if request is satisfied: " + nri.request);
        if (satisfies) {
            // this request
            if (VDBG || DDBG) {
                log("currentScore = " + (currentNetwork != null ? currentNetwork.getCurrentScore() : 0) + ", newScore = " + score);
            }
            if (currentNetwork == null || currentNetwork.getCurrentScore() < score) {
                if (VDBG)
                    log("rematch for " + newNetwork.name());
                if (currentNetwork != null) {
                    if (VDBG || DDBG) {
                        log("   accepting network in place of " + currentNetwork.name());
                    }
                    currentNetwork.removeRequest(nri.request.requestId);
                    currentNetwork.lingerRequest(nri.request, now, mLingerDelayMs);
                    affectedNetworks.add(currentNetwork);
                } else {
                    if (VDBG || DDBG)
                        log("   accepting network in place of null");
                }
                newNetwork.unlingerRequest(nri.request);
                setNetworkForRequest(nri.request.requestId, newNetwork);
                if (!newNetwork.addRequest(nri.request)) {
                    Slog.wtf(TAG, "BUG: " + newNetwork.name() + " already has " + nri.request);
                }
                addedRequests.add(nri);
                keep = true;
                // Tell NetworkFactories about the new score, so they can stop
                // trying to connect if they know they cannot match it.
                // TODO - this could get expensive if we have a lot of requests for this
                // network.  Think about if there is a way to reduce this.  Push
                // netid->request mapping to each factory?
                sendUpdatedScoreToFactories(nri.request, score);
                if (isDefaultRequest(nri)) {
                    isNewDefault = true;
                    oldDefaultNetwork = currentNetwork;
                    if (currentNetwork != null) {
                        mLingerMonitor.noteLingerDefaultNetwork(currentNetwork, newNetwork);
                    }
                }
            }
        } else if (newNetwork.isSatisfyingRequest(nri.request.requestId)) {
            // longer satisfies "nri" when "currentNetwork" does not equal "newNetwork".
            if (DBG) {
                log("Network " + newNetwork.name() + " stopped satisfying" + " request " + nri.request.requestId);
            }
            newNetwork.removeRequest(nri.request.requestId);
            if (currentNetwork == newNetwork) {
                clearNetworkForRequest(nri.request.requestId);
                sendUpdatedScoreToFactories(nri.request, 0);
            } else {
                Slog.wtf(TAG, "BUG: Removing request " + nri.request.requestId + " from " + newNetwork.name() + " without updating mNetworkForRequestId or factories!");
            }
            // TODO: Technically, sending CALLBACK_LOST here is
            // incorrect if there is a replacement network currently
            // connected that can satisfy nri, which is a request
            // (not a listen). However, the only capability that can both
            // a) be requested and b) change is NET_CAPABILITY_TRUSTED,
            // so this code is only incorrect for a network that loses
            // the TRUSTED capability, which is a rare case.
            callCallbackForRequest(nri, newNetwork, ConnectivityManager.CALLBACK_LOST, 0);
        }
    }
    if (isNewDefault) {
        updateDataActivityTracking(newNetwork, oldDefaultNetwork);
        // Notify system services that this network is up.
        makeDefault(newNetwork);
        // Log 0 -> X and Y -> X default network transitions, where X is the new default.
        metricsLogger().defaultNetworkMetrics().logDefaultNetworkEvent(now, newNetwork, oldDefaultNetwork);
        // Have a new default network, release the transition wakelock in
        scheduleReleaseNetworkTransitionWakelock();
    }
    if (!newNetwork.networkCapabilities.equalRequestableCapabilities(nc)) {
        Slog.wtf(TAG, String.format("BUG: %s changed requestable capabilities during rematch: %s -> %s", newNetwork.name(), nc, newNetwork.networkCapabilities));
    }
    if (newNetwork.getCurrentScore() != score) {
        Slog.wtf(TAG, String.format("BUG: %s changed score during rematch: %d -> %d", newNetwork.name(), score, newNetwork.getCurrentScore()));
    }
    // Second pass: process all listens.
    if (wasBackgroundNetwork != newNetwork.isBackgroundNetwork()) {
        // If the network went from background to foreground or vice versa, we need to update
        // its foreground state. It is safe to do this after rematching the requests because
        // NET_CAPABILITY_FOREGROUND does not affect requests, as is not a requestable
        // capability and does not affect the network's score (see the Slog.wtf call above).
        updateCapabilities(score, newNetwork, newNetwork.networkCapabilities);
    } else {
        processListenRequests(newNetwork, false);
    }
    // before LegacyTypeTracker sends legacy broadcasts
    for (NetworkRequestInfo nri : addedRequests) notifyNetworkAvailable(newNetwork, nri);
    // available callback for newNetwork.
    for (NetworkAgentInfo nai : affectedNetworks) {
        updateLingerState(nai, now);
    }
    // Possibly unlinger newNetwork. Unlingering a network does not send any callbacks so it
    // does not need to be done in any particular order.
    updateLingerState(newNetwork, now);
    if (isNewDefault) {
        // the new one connected.
        if (oldDefaultNetwork != null) {
            mLegacyTypeTracker.remove(oldDefaultNetwork.networkInfo.getType(), oldDefaultNetwork, true);
        }
        mDefaultInetConditionPublished = newNetwork.lastValidated ? 100 : 0;
        mLegacyTypeTracker.add(newNetwork.networkInfo.getType(), newNetwork);
        notifyLockdownVpn(newNetwork);
    }
    if (keep) {
        // TODO: Avoid redoing this; this must only be done once when a network comes online.
        try {
            final IBatteryStats bs = BatteryStatsService.getService();
            final int type = newNetwork.networkInfo.getType();
            final String baseIface = newNetwork.linkProperties.getInterfaceName();
            bs.noteNetworkInterfaceType(baseIface, type);
            for (LinkProperties stacked : newNetwork.linkProperties.getStackedLinks()) {
                final String stackedIface = stacked.getInterfaceName();
                bs.noteNetworkInterfaceType(stackedIface, type);
            }
        } catch (RemoteException ignored) {
        }
        // This is on top of the multiple intent sequencing referenced in the todo above.
        for (int i = 0; i < newNetwork.numNetworkRequests(); i++) {
            NetworkRequest nr = newNetwork.requestAt(i);
            if (nr.legacyType != TYPE_NONE && nr.isRequest()) {
                // legacy type tracker filters out repeat adds
                mLegacyTypeTracker.add(nr.legacyType, newNetwork);
            }
        }
        // newNetwork to the tracker explicitly (it's a no-op if it has already been added).
        if (newNetwork.isVPN()) {
            mLegacyTypeTracker.add(TYPE_VPN, newNetwork);
        }
    }
    if (reapUnvalidatedNetworks == ReapUnvalidatedNetworks.REAP) {
        for (NetworkAgentInfo nai : mNetworkAgentInfos.values()) {
            if (unneeded(nai, UnneededFor.TEARDOWN)) {
                if (nai.getLingerExpiry() > 0) {
                    // This network has active linger timers and no requests, but is not
                    // lingering. Linger it.
                    // 
                    // One way (the only way?) this can happen if this network is unvalidated
                    // and became unneeded due to another network improving its score to the
                    // point where this network will no longer be able to satisfy any requests
                    // even if it validates.
                    updateLingerState(nai, now);
                } else {
                    if (DBG)
                        log("Reaping " + nai.name());
                    teardownUnneededNetwork(nai);
                }
            }
        }
    }
}
#end_block

#method_before
private void updateNetworkScore(NetworkAgentInfo nai, int score) {
    if (VDBG || DEBUG)
        log("updateNetworkScore for " + nai.name() + " to " + score);
    if (score < 0) {
        loge("updateNetworkScore for " + nai.name() + " got a negative score (" + score + ").  Bumping score to min of 0");
        score = 0;
    }
    final int oldScore = nai.getCurrentScore();
    nai.setCurrentScore(score);
    rematchAllNetworksAndRequests(nai, oldScore);
    sendUpdatedScoreToFactories(nai);
}
#method_after
private void updateNetworkScore(NetworkAgentInfo nai, int score) {
    if (VDBG || DDBG)
        log("updateNetworkScore for " + nai.name() + " to " + score);
    if (score < 0) {
        loge("updateNetworkScore for " + nai.name() + " got a negative score (" + score + ").  Bumping score to min of 0");
        score = 0;
    }
    final int oldScore = nai.getCurrentScore();
    nai.setCurrentScore(score);
    rematchAllNetworksAndRequests(nai, oldScore);
    sendUpdatedScoreToFactories(nai);
}
#end_block

#method_before
protected void notifyNetworkCallbacks(NetworkAgentInfo networkAgent, int notifyType, int arg1) {
    if (VDBG || DEBUG) {
        String notification = ConnectivityManager.getCallbackName(notifyType);
        log("notifyType " + notification + " for " + networkAgent.name());
    }
    for (int i = 0; i < networkAgent.numNetworkRequests(); i++) {
        NetworkRequest nr = networkAgent.requestAt(i);
        NetworkRequestInfo nri = mNetworkRequests.get(nr);
        if (VDBG)
            log(" sending notification for " + nr);
        // a network that no longer satisfies the listen?
        if (nri.mPendingIntent == null) {
            callCallbackForRequest(nri, networkAgent, notifyType, arg1);
        } else {
            sendPendingIntentForRequest(nri, networkAgent, notifyType);
        }
    }
}
#method_after
protected void notifyNetworkCallbacks(NetworkAgentInfo networkAgent, int notifyType, int arg1) {
    if (VDBG || DDBG) {
        String notification = ConnectivityManager.getCallbackName(notifyType);
        log("notifyType " + notification + " for " + networkAgent.name());
    }
    for (int i = 0; i < networkAgent.numNetworkRequests(); i++) {
        NetworkRequest nr = networkAgent.requestAt(i);
        NetworkRequestInfo nri = mNetworkRequests.get(nr);
        if (VDBG)
            log(" sending notification for " + nr);
        // a network that no longer satisfies the listen?
        if (nri.mPendingIntent == null) {
            callCallbackForRequest(nri, networkAgent, notifyType, arg1);
        } else {
            sendPendingIntentForRequest(nri, networkAgent, notifyType);
        }
    }
}
#end_block

#method_before
// BEGIN Android-removed: retrieveFirstDayOfWeek() and retrieveMinimalDaysInFirstWeek().
/*
    public static int retrieveFirstDayOfWeek(Locale locale) {
        LocaleServiceProviderPool pool =
                LocaleServiceProviderPool.getPool(CalendarDataProvider.class);
        Integer value = pool.getLocalizedObject(CalendarWeekParameterGetter.INSTANCE,
                                                locale, FIRST_DAY_OF_WEEK);
        return (value != null && (value >= SUNDAY && value <= SATURDAY)) ? value : SUNDAY;
    }

    public static int retrieveMinimalDaysInFirstWeek(Locale locale) {
        LocaleServiceProviderPool pool =
                LocaleServiceProviderPool.getPool(CalendarDataProvider.class);
        Integer value = pool.getLocalizedObject(CalendarWeekParameterGetter.INSTANCE,
                                                locale, MINIMAL_DAYS_IN_FIRST_WEEK);
        return (value != null && (value >= 1 && value <= 7)) ? value : 1;
    }
    */
// END Android-removed: retrieveFirstDayOfWeek and retrieveMinimalDaysInFirstWeek.
// Android-note: use libcore.icu.LocaleData or android.icu.util.Calendar.WeekData instead.
// BEGIN Android-changed: Implement on top of ICU.
public static String retrieveFieldValueName(String id, int field, int value, int style, Locale locale) {
    if (field == Calendar.ERA) {
        // For era the field value does not always equal the index into the names array.
        switch(normalizeCalendarType(id)) {
            // These calendars have only one era, but represented it by the value 1.
            case BUDDHIST_CALENDAR:
            case ISLAMIC_CALENDAR:
                value -= 1;
                break;
            case JAPANESE_CALENDAR:
                // CLDR contains full data for historical eras, java.time only supports the 4
                // modern eras and numbers the modern eras starting with 1 (MEIJI). There are
                // 232 historical eras in CLDR/ICU so to get the real offset, we add 231.
                value += 231;
                break;
            default:
                // Other eras use 0-based values (e.g. 0=BCE, 1=CE for gregorian).
                break;
        }
    }
    if (value < 0) {
        return null;
    }
    String[] names = getNames(id, field, style, locale);
    if (value >= names.length) {
        return null;
    }
    return names[value];
}
#method_after
// BEGIN Android-removed: Dead code, unused on Android.
// Clients should use libcore.icu.LocaleData or android.icu.util.Calendar.WeekData instead.
/*
    public static int retrieveFirstDayOfWeek(Locale locale) {
        LocaleServiceProviderPool pool =
                LocaleServiceProviderPool.getPool(CalendarDataProvider.class);
        Integer value = pool.getLocalizedObject(CalendarWeekParameterGetter.INSTANCE,
                                                locale, FIRST_DAY_OF_WEEK);
        return (value != null && (value >= SUNDAY && value <= SATURDAY)) ? value : SUNDAY;
    }

    public static int retrieveMinimalDaysInFirstWeek(Locale locale) {
        LocaleServiceProviderPool pool =
                LocaleServiceProviderPool.getPool(CalendarDataProvider.class);
        Integer value = pool.getLocalizedObject(CalendarWeekParameterGetter.INSTANCE,
                                                locale, MINIMAL_DAYS_IN_FIRST_WEEK);
        return (value != null && (value >= 1 && value <= 7)) ? value : 1;
    }
    */
// END Android-removed: Dead code, unused on Android.
// BEGIN Android-changed: Implement on top of ICU.
public static String retrieveFieldValueName(String id, int field, int value, int style, Locale locale) {
    if (field == Calendar.ERA) {
        // For era the field value does not always equal the index into the names array.
        switch(normalizeCalendarType(id)) {
            // These calendars have only one era, but represented it by the value 1.
            case BUDDHIST_CALENDAR:
            case ISLAMIC_CALENDAR:
                value -= 1;
                break;
            case JAPANESE_CALENDAR:
                // CLDR contains full data for historical eras, java.time only supports the 4
                // modern eras and numbers the modern eras starting with 1 (MEIJI). There are
                // 232 historical eras in CLDR/ICU so to get the real offset, we add 231.
                value += 231;
                break;
            default:
                // Other eras use 0-based values (e.g. 0=BCE, 1=CE for gregorian).
                break;
        }
    }
    if (value < 0) {
        return null;
    }
    String[] names = getNames(id, field, style, locale);
    if (value >= names.length) {
        return null;
    }
    return names[value];
}
#end_block

#method_before
public static Uri getContentUri(String volumeName) {
    return Uri.parse(CONTENT_AUTHORITY_SLASH + volumeName + "/video/media");
}
#method_after
public static Uri getContentUri(String volumeName) {
    return Uri.parse(CONTENT_AUTHORITY_SLASH + volumeName + "/images/media");
}
#end_block

#method_before
public static Bitmap getThumbnail(ContentResolver cr, long origId, int kind, BitmapFactory.Options options) {
    return InternalThumbnails.getThumbnail(cr, origId, InternalThumbnails.DEFAULT_GROUP_ID, kind, options, EXTERNAL_CONTENT_URI, true);
}
#method_after
public static Bitmap getThumbnail(ContentResolver cr, long origId, int kind, BitmapFactory.Options options) {
    return InternalThumbnails.getThumbnail(cr, origId, InternalThumbnails.DEFAULT_GROUP_ID, kind, options, EXTERNAL_CONTENT_URI, false);
}
#end_block

#method_before
public static Bitmap getThumbnail(ContentResolver cr, long origId, long groupId, int kind, BitmapFactory.Options options) {
    return InternalThumbnails.getThumbnail(cr, origId, groupId, kind, options, EXTERNAL_CONTENT_URI, true);
}
#method_after
public static Bitmap getThumbnail(ContentResolver cr, long origId, long groupId, int kind, BitmapFactory.Options options) {
    return InternalThumbnails.getThumbnail(cr, origId, groupId, kind, options, EXTERNAL_CONTENT_URI, false);
}
#end_block

#method_before
public static Uri getContentUri(String volumeName) {
    return Uri.parse(CONTENT_AUTHORITY_SLASH + volumeName + "/video/thumbnails");
}
#method_after
public static Uri getContentUri(String volumeName) {
    return Uri.parse(CONTENT_AUTHORITY_SLASH + volumeName + "/images/thumbnails");
}
#end_block

#method_before
public static Uri getContentUri(String volumeName) {
    return Uri.parse(CONTENT_AUTHORITY_SLASH + volumeName + "/video/media");
}
#method_after
public static Uri getContentUri(String volumeName) {
    return Uri.parse(CONTENT_AUTHORITY_SLASH + volumeName + "/audio/media");
}
#end_block

#method_before
public static final Uri getContentUri(String volumeName, long playlistId) {
    return Uri.parse(CONTENT_AUTHORITY_SLASH + volumeName + "/audio/playlists/" + playlistId + "/members");
}
#method_after
public static final Uri getContentUri(String volumeName, long genreId) {
    return Uri.parse(CONTENT_AUTHORITY_SLASH + volumeName + "/audio/genres/" + genreId + "/members");
}
#end_block

#method_before
public static void cancelThumbnailRequest(ContentResolver cr, long origId, long groupId) {
    InternalThumbnails.cancelThumbnailRequest(cr, origId, EXTERNAL_CONTENT_URI, groupId);
}
#method_after
public static void cancelThumbnailRequest(ContentResolver cr, long origId) {
    InternalThumbnails.cancelThumbnailRequest(cr, origId, EXTERNAL_CONTENT_URI, InternalThumbnails.DEFAULT_GROUP_ID);
}
#end_block

#method_before
public static Bitmap getThumbnail(ContentResolver cr, long origId, long groupId, int kind, BitmapFactory.Options options) {
    return InternalThumbnails.getThumbnail(cr, origId, groupId, kind, options, EXTERNAL_CONTENT_URI, true);
}
#method_after
public static Bitmap getThumbnail(ContentResolver cr, long origId, int kind, BitmapFactory.Options options) {
    return InternalThumbnails.getThumbnail(cr, origId, InternalThumbnails.DEFAULT_GROUP_ID, kind, options, EXTERNAL_CONTENT_URI, true);
}
#end_block

#method_before
private void startTrackingTable(SupportSQLiteDatabase writableDb, int tableId) {
    writableDb.execSQL("INSERT OR IGNORE INTO " + UPDATE_TABLE_NAME + " VALUES(" + tableId + ", 0)");
    final String tableName = mShadowTableLookup.get(tableId, mTableNames[tableId]);
    StringBuilder stringBuilder = new StringBuilder();
    for (String trigger : TRIGGERS) {
        stringBuilder.setLength(0);
        stringBuilder.append("CREATE TEMP TRIGGER IF NOT EXISTS ");
        appendTriggerName(stringBuilder, tableName, trigger);
        stringBuilder.append(" AFTER ").append(trigger).append(" ON `").append(tableName).append("` BEGIN UPDATE ").append(UPDATE_TABLE_NAME).append(" SET ").append(INVALIDATED_COLUMN_NAME).append(" = 1").append(" WHERE ").append(TABLE_ID_COLUMN_NAME).append(" = ").append(tableId).append("; END");
        writableDb.execSQL(stringBuilder.toString());
    }
}
#method_after
private void startTrackingTable(SupportSQLiteDatabase writableDb, int tableId) {
    writableDb.execSQL("INSERT OR IGNORE INTO " + UPDATE_TABLE_NAME + " VALUES(" + tableId + ", 0)");
    final String tableName = mShadowTableLookup.get(tableId, mTableNames[tableId]);
    StringBuilder stringBuilder = new StringBuilder();
    for (String trigger : TRIGGERS) {
        stringBuilder.setLength(0);
        stringBuilder.append("CREATE TEMP TRIGGER IF NOT EXISTS ");
        appendTriggerName(stringBuilder, tableName, trigger);
        stringBuilder.append(" AFTER ").append(trigger).append(" ON `").append(tableName).append("` BEGIN UPDATE ").append(UPDATE_TABLE_NAME).append(" SET ").append(INVALIDATED_COLUMN_NAME).append(" = 1").append(" WHERE ").append(TABLE_ID_COLUMN_NAME).append(" = ").append(tableId).append(" AND ").append(INVALIDATED_COLUMN_NAME).append(" = 0").append("; END");
        writableDb.execSQL(stringBuilder.toString());
    }
}
#end_block

#method_before
void notifyByTableVersions(boolean[] tableInvalidStatus) {
    Set<String> invalidatedTables = null;
    final int size = mTableIds.length;
    for (int index = 0; index < size; index++) {
        final int tableId = mTableIds[index];
        if (tableInvalidStatus[tableId]) {
            if (size == 1) {
                // Optimization for a single-table observer
                invalidatedTables = mSingleTableSet;
            } else {
                if (invalidatedTables == null) {
                    invalidatedTables = new ArraySet<>(size);
                }
                invalidatedTables.add(mTableNames[index]);
            }
        }
    }
    if (invalidatedTables != null) {
        mObserver.onInvalidated(invalidatedTables);
    }
}
#method_after
void notifyByTableVersions(BitSet tableInvalidStatus) {
    Set<String> invalidatedTables = null;
    final int size = mTableIds.length;
    for (int index = 0; index < size; index++) {
        final int tableId = mTableIds[index];
        if (tableInvalidStatus.get(tableId)) {
            if (size == 1) {
                // Optimization for a single-table observer
                invalidatedTables = mSingleTableSet;
            } else {
                if (invalidatedTables == null) {
                    invalidatedTables = new ArraySet<>(size);
                }
                invalidatedTables.add(mTableNames[index]);
            }
        }
    }
    if (invalidatedTables != null) {
        mObserver.onInvalidated(invalidatedTables);
    }
}
#end_block

#method_before
@Test
public void refreshCheckTasks() throws Exception {
    when(mRoomDatabase.query(anyString())).thenReturn(mock(Cursor.class));
    mTracker.refreshVersionsAsync();
    mTracker.refreshVersionsAsync();
    verify(mTaskExecutorRule.getTaskExecutor()).executeOnDiskIO(mTracker.mRefreshRunnable);
    drainTasks();
    reset(mTaskExecutorRule.getTaskExecutor());
    mTracker.refreshVersionsAsync();
    verify(mTaskExecutorRule.getTaskExecutor()).executeOnDiskIO(mTracker.mRefreshRunnable);
}
#method_after
@Test
public void refreshCheckTasks() throws Exception {
    when(mRoomDatabase.query(any(SimpleSQLiteQuery.class))).thenReturn(mock(Cursor.class));
    mTracker.refreshVersionsAsync();
    mTracker.refreshVersionsAsync();
    verify(mTaskExecutorRule.getTaskExecutor()).executeOnDiskIO(mTracker.mRefreshRunnable);
    drainTasks();
    reset(mTaskExecutorRule.getTaskExecutor());
    mTracker.refreshVersionsAsync();
    verify(mTaskExecutorRule.getTaskExecutor()).executeOnDiskIO(mTracker.mRefreshRunnable);
}
#end_block

#method_before
@Test
public void createTriggerOnShadowTable() {
    LatchObserver observer = new LatchObserver(1, "C");
    String[] triggers = new String[] { "UPDATE", "DELETE", "INSERT" };
    ArgumentCaptor<String> sqlArgCaptor;
    List<String> sqlCaptorValues;
    mTracker.addObserver(observer);
    sqlArgCaptor = ArgumentCaptor.forClass(String.class);
    verify(mSqliteDb, times(4)).execSQL(sqlArgCaptor.capture());
    sqlCaptorValues = sqlArgCaptor.getAllValues();
    assertThat(sqlCaptorValues.get(0), is("INSERT OR IGNORE INTO room_table_modification_log VALUES(3, 0)"));
    for (int i = 0; i < triggers.length; i++) {
        assertThat(sqlCaptorValues.get(i + 1), is("CREATE TEMP TRIGGER IF NOT EXISTS " + "`room_table_modification_trigger_d_" + triggers[i] + "` AFTER " + triggers[i] + " ON `d` BEGIN UPDATE room_table_modification_log " + "SET invalidated = 1 WHERE table_id = 3; END"));
    }
    reset(mSqliteDb);
    mTracker.removeObserver(observer);
    sqlArgCaptor = ArgumentCaptor.forClass(String.class);
    verify(mSqliteDb, times(3)).execSQL(sqlArgCaptor.capture());
    sqlCaptorValues = sqlArgCaptor.getAllValues();
    for (int i = 0; i < triggers.length; i++) {
        assertThat(sqlCaptorValues.get(i), is("DROP TRIGGER IF EXISTS `room_table_modification_trigger_d_" + triggers[i] + "`"));
    }
}
#method_after
@Test
public void createTriggerOnShadowTable() {
    LatchObserver observer = new LatchObserver(1, "C");
    String[] triggers = new String[] { "UPDATE", "DELETE", "INSERT" };
    ArgumentCaptor<String> sqlArgCaptor;
    List<String> sqlCaptorValues;
    mTracker.addObserver(observer);
    sqlArgCaptor = ArgumentCaptor.forClass(String.class);
    verify(mSqliteDb, times(4)).execSQL(sqlArgCaptor.capture());
    sqlCaptorValues = sqlArgCaptor.getAllValues();
    assertThat(sqlCaptorValues.get(0), is("INSERT OR IGNORE INTO room_table_modification_log VALUES(3, 0)"));
    for (int i = 0; i < triggers.length; i++) {
        assertThat(sqlCaptorValues.get(i + 1), is("CREATE TEMP TRIGGER IF NOT EXISTS " + "`room_table_modification_trigger_d_" + triggers[i] + "` AFTER " + triggers[i] + " ON `d` BEGIN UPDATE room_table_modification_log " + "SET invalidated = 1 WHERE table_id = 3 AND invalidated = 0; END"));
    }
    reset(mSqliteDb);
    mTracker.removeObserver(observer);
    sqlArgCaptor = ArgumentCaptor.forClass(String.class);
    verify(mSqliteDb, times(3)).execSQL(sqlArgCaptor.capture());
    sqlCaptorValues = sqlArgCaptor.getAllValues();
    for (int i = 0; i < triggers.length; i++) {
        assertThat(sqlCaptorValues.get(i), is("DROP TRIGGER IF EXISTS `room_table_modification_trigger_d_" + triggers[i] + "`"));
    }
}
#end_block

#method_before
private void setInvalidatedTables(int... tableIds) throws InterruptedException {
    // mockito does not like multi-threaded access so before setting versions, make sure we
    // sync background tasks.
    drainTasks();
    Cursor cursor = createCursorWithValues(tableIds);
    doReturn(cursor).when(mRoomDatabase).query(Mockito.eq(InvalidationTracker.SELECT_UPDATED_TABLES_SQL));
}
#method_after
private void setInvalidatedTables(int... tableIds) throws InterruptedException {
    // mockito does not like multi-threaded access so before setting versions, make sure we
    // sync background tasks.
    drainTasks();
    Cursor cursor = createCursorWithValues(tableIds);
    doReturn(cursor).when(mRoomDatabase).query(argThat(new ArgumentMatcher<SimpleSQLiteQuery>() {

        @Override
        public boolean matches(SimpleSQLiteQuery argument) {
            return argument.getSql().equals(InvalidationTracker.SELECT_UPDATED_TABLES_SQL);
        }
    }));
}
#end_block

#method_before
public void seekTo(long position, @MediaPlayer2.SeekMode int mode) {
    mPlayer.setSeekParameters(ExoPlayerUtils.getSeekParameters(mode));
    MediaItem2 mediaItem2 = mMediaItemQueue.getCurrentMediaItem();
    if (mediaItem2 != null) {
        if (mediaItem2.getStartPosition() > position || mediaItem2.getEndPosition() < position) {
            throw new IllegalArgumentException("Requested seek position is out of range : " + position);
        }
        position -= mediaItem2.getStartPosition();
    }
    mPlayer.seekTo(position);
}
#method_after
public void seekTo(long position, @MediaPlayer2.SeekMode int mode) {
    mPlayer.setSeekParameters(ExoPlayerUtils.getSeekParameters(mode));
    MediaItem2 mediaItem2 = mMediaItemQueue.getCurrentMediaItem();
    if (mediaItem2 != null) {
        Preconditions.checkArgument(mediaItem2.getStartPosition() <= position && mediaItem2.getEndPosition() >= position, "Requested seek position is out of range : " + position);
        position -= mediaItem2.getStartPosition();
    }
    mPlayer.seekTo(position);
}
#end_block

#method_before
synchronized void seekTo(long msec, int mode) {
    MediaItem2 current = getFirst().getDSD();
    if (current.getStartPosition() > msec || current.getEndPosition() < msec) {
        throw new IllegalArgumentException("Requested seek position is out of range : " + msec);
    }
    getCurrentPlayer().seekTo(msec, mode);
}
#method_after
synchronized void seekTo(long msec, int mode) {
    MediaItem2 current = getFirst().getDSD();
    Preconditions.checkArgument(current.getStartPosition() <= msec && current.getEndPosition() >= msec, "Requested seek position is out of range : " + msec);
    getCurrentPlayer().seekTo(msec, mode);
}
#end_block

#method_before
@Parameterized.Parameters(name = "config:{0},reverseScroll:{1}")
public static List<Object[]> getParams() {
    List<Object[]> result = new ArrayList<>();
    List<Config> configs = createBaseVariations();
    for (Config config : configs) {
        for (boolean reverseScroll : new boolean[] { false, true }) {
            result.add(new Object[] { config, reverseScroll });
        }
    }
    return result;
}
#method_after
@Parameterized.Parameters(name = "config:{0},reverseScroll:{1},mChildSize:{2}")
public static List<Object[]> getParams() {
    List<Object[]> result = new ArrayList<>();
    List<Config> configs = createBaseVariations();
    for (Config config : configs) {
        for (boolean reverseScroll : new boolean[] { false, true }) {
            for (ChildSize childSize : ChildSize.values()) {
                result.add(new Object[] { config, reverseScroll, childSize });
            }
        }
    }
    return result;
}
#end_block

#method_before
@Test
public void snapOnScrollSameView() throws Throwable {
    final Config config = (Config) mConfig.clone();
    setupByConfig(config, true, new RecyclerView.LayoutParams(MATCH_PARENT, MATCH_PARENT), new RecyclerView.LayoutParams(MATCH_PARENT, MATCH_PARENT));
    setupSnapHelper();
    // Record the current center view.
    TextView view = (TextView) findCenterView(mLayoutManager);
    assertCenterAligned(view);
    int scrollDistance = (getViewDimension(view) / 2) - 1;
    int scrollDist = mReverseScroll ? -scrollDistance : scrollDistance;
    mLayoutManager.expectIdleState(3);
    smoothScrollBy(scrollDist);
    mLayoutManager.waitForSnap(10);
    // Views have not changed
    View viewAfterFling = findCenterView(mLayoutManager);
    assertSame("The view should NOT have scrolled", view, viewAfterFling);
    assertCenterAligned(viewAfterFling);
}
#method_after
@Test
public void snapOnScrollSameView() throws Throwable {
    final Config config = (Config) mConfig.clone();
    setupByConfig(config, true, getChildLayoutParams(), getParentLayoutParams());
    setupSnapHelper();
    // Record the current center view.
    TextView view = (TextView) findCenterView(mLayoutManager);
    assertCenterAligned(view);
    int scrollDistance = (getViewDimension(view) / 2) - 1;
    int scrollDist = mReverseScroll ? -scrollDistance : scrollDistance;
    mLayoutManager.expectIdleState(2);
    smoothScrollBy(scrollDist);
    mLayoutManager.waitForSnap(10);
    // Views have not changed
    View viewAfterFling = findCenterView(mLayoutManager);
    assertSame("The view should NOT have scrolled", view, viewAfterFling);
    assertCenterAligned(viewAfterFling);
}
#end_block

#method_before
@Test
public void snapOnScrollNextView() throws Throwable {
    final Config config = (Config) mConfig.clone();
    setupByConfig(config, true, new RecyclerView.LayoutParams(MATCH_PARENT, MATCH_PARENT), new RecyclerView.LayoutParams(MATCH_PARENT, MATCH_PARENT));
    setupSnapHelper();
    // Record the current center view.
    View view = findCenterView(mLayoutManager);
    assertCenterAligned(view);
    int scrollDistance = (getViewDimension(view) / 2) + 1;
    int scrollDist = mReverseScroll ? -scrollDistance : scrollDistance;
    mLayoutManager.expectIdleState(3);
    smoothScrollBy(scrollDist);
    mLayoutManager.waitForSnap(10);
    // Views have not changed
    View viewAfterFling = findCenterView(mLayoutManager);
    assertNotSame("The view should have scrolled", view, viewAfterFling);
    int expectedPosition = mConfig.mItemCount / 2 + (mConfig.mReverseLayout ? (mReverseScroll ? 1 : -1) : (mReverseScroll ? -1 : 1));
    assertEquals(expectedPosition, mLayoutManager.getPosition(viewAfterFling));
    assertCenterAligned(viewAfterFling);
}
#method_after
@Test
public void snapOnScrollNextView() throws Throwable {
    final Config config = (Config) mConfig.clone();
    setupByConfig(config, true, getChildLayoutParams(), getParentLayoutParams());
    setupSnapHelper();
    // Record the current center view.
    View view = findCenterView(mLayoutManager);
    assertCenterAligned(view);
    int scrollDistance = (getViewDimension(view) / 2) + 1;
    int scrollDist = mReverseScroll ? -scrollDistance : scrollDistance;
    mLayoutManager.expectIdleState(2);
    smoothScrollBy(scrollDist);
    mLayoutManager.waitForSnap(10);
    // Views have not changed
    View viewAfterFling = findCenterView(mLayoutManager);
    assertNotSame("The view should have scrolled", view, viewAfterFling);
    int expectedPosition = mConfig.mItemCount / 2 + (mConfig.mReverseLayout ? (mReverseScroll ? 1 : -1) : (mReverseScroll ? -1 : 1));
    assertEquals(expectedPosition, mLayoutManager.getPosition(viewAfterFling));
    assertCenterAligned(viewAfterFling);
}
#end_block

#method_before
@Test
public void snapOnFlingSameView() throws Throwable {
    final Config config = (Config) mConfig.clone();
    setupByConfig(config, true, new RecyclerView.LayoutParams(MATCH_PARENT, MATCH_PARENT), new RecyclerView.LayoutParams(MATCH_PARENT, MATCH_PARENT));
    setupSnapHelper();
    // Record the current center view.
    View view = findCenterView(mLayoutManager);
    assertCenterAligned(view);
    // Velocity small enough to not scroll to the next view.
    int velocity = (int) (1.000001 * mRecyclerView.getMinFlingVelocity());
    int velocityDir = mReverseScroll ? -velocity : velocity;
    mLayoutManager.expectIdleState(2);
    // Scroll at one pixel in the correct direction to allow fling snapping to the next view.
    mActivityRule.runOnUiThread(new Runnable() {

        @Override
        public void run() {
            mRecyclerView.scrollBy(mReverseScroll ? -1 : 1, mReverseScroll ? -1 : 1);
        }
    });
    waitForIdleScroll(mRecyclerView);
    assertTrue(fling(velocityDir, velocityDir));
    // Wait for two settling scrolls: the initial one and the corrective one.
    waitForIdleScroll(mRecyclerView);
    mLayoutManager.waitForSnap(100);
    View viewAfterFling = findCenterView(mLayoutManager);
    assertSame("The view should NOT have scrolled", view, viewAfterFling);
    assertCenterAligned(viewAfterFling);
}
#method_after
@Test
public void snapOnFlingSameView() throws Throwable {
    final Config config = (Config) mConfig.clone();
    setupByConfig(config, true, getChildLayoutParams(), getParentLayoutParams());
    setupSnapHelper();
    // Record the current center view.
    View view = findCenterView(mLayoutManager);
    assertCenterAligned(view);
    // Velocity small enough to not scroll to the next view.
    int velocity = (int) (1.000001 * mRecyclerView.getMinFlingVelocity());
    int velocityDir = mReverseScroll ? -velocity : velocity;
    mLayoutManager.expectIdleState(2);
    // Scroll at one pixel in the correct direction to allow fling snapping to the next view.
    mActivityRule.runOnUiThread(new Runnable() {

        @Override
        public void run() {
            mRecyclerView.scrollBy(mReverseScroll ? -1 : 1, mReverseScroll ? -1 : 1);
        }
    });
    waitForIdleScroll(mRecyclerView);
    assertTrue(fling(velocityDir, velocityDir));
    // Wait for two settling scrolls: the initial one and the corrective one.
    waitForIdleScroll(mRecyclerView);
    mLayoutManager.waitForSnap(100);
    View viewAfterFling = findCenterView(mLayoutManager);
    assertSame("The view should NOT have scrolled", view, viewAfterFling);
    assertCenterAligned(viewAfterFling);
}
#end_block

#method_before
@Test
public void snapOnFlingNextView() throws Throwable {
    final Config config = (Config) mConfig.clone();
    setupByConfig(config, true, new RecyclerView.LayoutParams(MATCH_PARENT, MATCH_PARENT), new RecyclerView.LayoutParams(MATCH_PARENT, MATCH_PARENT));
    setupSnapHelper();
    runSnapOnMaxFlingNextView((int) (0.2 * mRecyclerView.getMaxFlingVelocity()));
}
#method_after
@Test
public void snapOnFlingNextView() throws Throwable {
    final Config config = (Config) mConfig.clone();
    setupByConfig(config, true, getChildLayoutParams(), getParentLayoutParams());
    setupSnapHelper();
    runSnapOnMaxFlingNextView((int) (0.2 * mRecyclerView.getMaxFlingVelocity()));
}
#end_block

#method_before
@Test
public void snapOnMaxFlingNextView() throws Throwable {
    final Config config = (Config) mConfig.clone();
    setupByConfig(config, true, new RecyclerView.LayoutParams(MATCH_PARENT, MATCH_PARENT), new RecyclerView.LayoutParams(MATCH_PARENT, MATCH_PARENT));
    setupSnapHelper();
    runSnapOnMaxFlingNextView(mRecyclerView.getMaxFlingVelocity());
}
#method_after
@Test
public void snapOnMaxFlingNextView() throws Throwable {
    final Config config = (Config) mConfig.clone();
    setupByConfig(config, true, getChildLayoutParams(), getParentLayoutParams());
    setupSnapHelper();
    runSnapOnMaxFlingNextView(mRecyclerView.getMaxFlingVelocity());
}
#end_block

#method_before
private void setupSnapHelper() throws Throwable {
    SnapHelper snapHelper = new PagerSnapHelper();
    mLayoutManager.expectIdleState(1);
    snapHelper.attachToRecyclerView(mRecyclerView);
    mLayoutManager.expectLayouts(1);
    scrollToPositionWithOffset(mConfig.mItemCount / 2, getScrollOffset());
    mLayoutManager.waitForLayout(2);
    View view = findCenterView(mLayoutManager);
    int scrollDistance = distFromCenter(view) / 2;
    if (scrollDistance == 0) {
        return;
    }
    int scrollDist = mReverseScroll ? -scrollDistance : scrollDistance;
    mLayoutManager.expectIdleState(2);
    smoothScrollBy(scrollDist);
    mLayoutManager.waitForSnap(10);
}
#method_after
private void setupSnapHelper() throws Throwable {
    SnapHelper snapHelper = new PagerSnapHelper();
    // Do we expect a snap when attaching the SnapHelper?
    View centerView = findCenterView(mLayoutManager);
    boolean expectSnap = distFromCenter(centerView) != 0;
    mLayoutManager.expectIdleState(1);
    snapHelper.attachToRecyclerView(mRecyclerView);
    if (expectSnap) {
        mLayoutManager.waitForSnap(2);
    }
    mLayoutManager.expectLayouts(1);
    scrollToPositionWithOffset(mConfig.mItemCount / 2, getScrollOffset());
    mLayoutManager.waitForLayout(2);
}
#end_block

#method_before
private int getScrollOffset() {
    RecyclerView.LayoutParams params = mTestAdapter.mLayoutParams;
    if (params == null) {
        return 0;
    }
    if (mConfig.mOrientation == HORIZONTAL && params.width == MATCH_PARENT || mConfig.mOrientation == VERTICAL && params.height == MATCH_PARENT) {
        return 0;
    }
    // In reverse layouts, the rounding error of x/2 ends up on the other side of the center
    // Instead of fixing all asserts, just move the rounding error to the same side as without
    // reverse layout.
    int reverseAdjustment = mConfig.mReverseLayout ? 1 : 0;
    if (mConfig.mOrientation == HORIZONTAL) {
        return (mRecyclerView.getWidth() - params.width + reverseAdjustment) / 2;
    } else {
        return (mRecyclerView.getHeight() - params.height + reverseAdjustment) / 2;
    }
}
#method_after
private int getScrollOffset() {
    RecyclerView.LayoutParams params = mTestAdapter.mLayoutParams;
    if (params == null) {
        return 0;
    }
    if (mConfig.mOrientation == HORIZONTAL && params.width == MATCH_PARENT || mConfig.mOrientation == VERTICAL && params.height == MATCH_PARENT) {
        return 0;
    }
    // In reverse layouts, the rounding error of x/2 ends up on the other side of the center
    // Instead of fixing all asserts, just move the rounding error to the same side as without
    // reverse layout.
    int reverseAdjustment = (mConfig.mReverseLayout ? 1 : 0) * // we need to subtract the adjustment rather than add it
    (mChildSize == ChildSize.LARGER ? -1 : 1);
    if (mConfig.mOrientation == HORIZONTAL) {
        return (mRecyclerView.getWidth() - params.width + reverseAdjustment) / 2;
    } else {
        return (mRecyclerView.getHeight() - params.height + reverseAdjustment) / 2;
    }
}
#end_block

#method_before
@Override
public int findTargetSnapPosition(RecyclerView.LayoutManager layoutManager, int velocityX, int velocityY) {
    final int itemCount = layoutManager.getItemCount();
    if (itemCount == 0) {
        return RecyclerView.NO_POSITION;
    }
    final OrientationHelper orientationHelper = getOrientationHelper(layoutManager);
    if (orientationHelper == null) {
        return RecyclerView.NO_POSITION;
    }
    // A child that is exactly in the center is eligible for both before and after
    View closestChildBeforeCenter = null;
    int distanceBefore = Integer.MIN_VALUE;
    View closestChildAfterCenter = null;
    int distanceAfter = Integer.MAX_VALUE;
    // Find the first view before the center, and the first view after the center
    final int childCount = layoutManager.getChildCount();
    for (int i = 0; i < childCount; i++) {
        final View child = layoutManager.getChildAt(i);
        if (child == null) {
            continue;
        }
        final int distance = distanceToCenter(layoutManager, child, orientationHelper);
        if (distance <= 0 && distance > distanceBefore) {
            // Child is before the center and closer then the previous best
            distanceBefore = distance;
            closestChildBeforeCenter = child;
        }
        if (distance >= 0 && distance < distanceAfter) {
            // Child is after the center and closer then the previous best
            distanceAfter = distance;
            closestChildAfterCenter = child;
        }
    }
    // Return the position of the first child from the center, in the direction of the fling
    final boolean forwardDirection = isForwardFling(layoutManager, velocityX, velocityY);
    if (forwardDirection && closestChildAfterCenter != null) {
        return layoutManager.getPosition(closestChildAfterCenter);
    } else if (!forwardDirection && closestChildBeforeCenter != null) {
        return layoutManager.getPosition(closestChildBeforeCenter);
    }
    // There is no child in the direction of the fling. Either it doesn't exist (start/end of
    // the list), or it is not yet attached (very rare case when children are larger then the
    // viewport). Extrapolate from the child that is visible to get the position of the view to
    // snap to.
    View visibleView = forwardDirection ? closestChildBeforeCenter : closestChildAfterCenter;
    if (visibleView == null) {
        return RecyclerView.NO_POSITION;
    }
    int visiblePosition = layoutManager.getPosition(visibleView);
    int snapToPosition = isReverseLayout(layoutManager) ? (forwardDirection ? visiblePosition - 1 : visiblePosition) : (forwardDirection ? visiblePosition + 1 : visiblePosition);
    if (snapToPosition < 0 || snapToPosition >= itemCount) {
        return RecyclerView.NO_POSITION;
    }
    return snapToPosition;
}
#method_after
@Override
public int findTargetSnapPosition(RecyclerView.LayoutManager layoutManager, int velocityX, int velocityY) {
    final int itemCount = layoutManager.getItemCount();
    if (itemCount == 0) {
        return RecyclerView.NO_POSITION;
    }
    final OrientationHelper orientationHelper = getOrientationHelper(layoutManager);
    if (orientationHelper == null) {
        return RecyclerView.NO_POSITION;
    }
    // A child that is exactly in the center is eligible for both before and after
    View closestChildBeforeCenter = null;
    int distanceBefore = Integer.MIN_VALUE;
    View closestChildAfterCenter = null;
    int distanceAfter = Integer.MAX_VALUE;
    // Find the first view before the center, and the first view after the center
    final int childCount = layoutManager.getChildCount();
    for (int i = 0; i < childCount; i++) {
        final View child = layoutManager.getChildAt(i);
        if (child == null) {
            continue;
        }
        final int distance = distanceToCenter(layoutManager, child, orientationHelper);
        if (distance <= 0 && distance > distanceBefore) {
            // Child is before the center and closer then the previous best
            distanceBefore = distance;
            closestChildBeforeCenter = child;
        }
        if (distance >= 0 && distance < distanceAfter) {
            // Child is after the center and closer then the previous best
            distanceAfter = distance;
            closestChildAfterCenter = child;
        }
    }
    // Return the position of the first child from the center, in the direction of the fling
    final boolean forwardDirection = isForwardFling(layoutManager, velocityX, velocityY);
    if (forwardDirection && closestChildAfterCenter != null) {
        return layoutManager.getPosition(closestChildAfterCenter);
    } else if (!forwardDirection && closestChildBeforeCenter != null) {
        return layoutManager.getPosition(closestChildBeforeCenter);
    }
    // There is no child in the direction of the fling. Either it doesn't exist (start/end of
    // the list), or it is not yet attached (very rare case when children are larger then the
    // viewport). Extrapolate from the child that is visible to get the position of the view to
    // snap to.
    View visibleView = forwardDirection ? closestChildBeforeCenter : closestChildAfterCenter;
    if (visibleView == null) {
        return RecyclerView.NO_POSITION;
    }
    int visiblePosition = layoutManager.getPosition(visibleView);
    int snapToPosition = visiblePosition + (isReverseLayout(layoutManager) == forwardDirection ? -1 : +1);
    if (snapToPosition < 0 || snapToPosition >= itemCount) {
        return RecyclerView.NO_POSITION;
    }
    return snapToPosition;
}
#end_block

#method_before
@Override
public void writeToParcel(Parcel out, int flags) {
    out.writeInt(allowBypass ? 1 : 0);
    out.writeInt(explicitlySelected ? 1 : 0);
    out.writeInt(acceptUnvalidated ? 1 : 0);
    out.writeString(subscriberId);
    out.writeInt(provisioningNotificationDisabled ? 1 : 0);
    out.writeInt(disable464xlat ? 1 : 0);
}
#method_after
@Override
public void writeToParcel(Parcel out, int flags) {
    out.writeInt(allowBypass ? 1 : 0);
    out.writeInt(explicitlySelected ? 1 : 0);
    out.writeInt(acceptUnvalidated ? 1 : 0);
    out.writeString(subscriberId);
    out.writeInt(provisioningNotificationDisabled ? 1 : 0);
    out.writeInt(skip464xlat ? 1 : 0);
}
#end_block

#method_before
public static boolean requiresClat(NetworkAgentInfo nai) {
    // TODO: migrate to NetworkCapabilities.TRANSPORT_*.
    final boolean supported = ArrayUtils.contains(NETWORK_TYPES, nai.networkInfo.getType());
    final boolean connected = ArrayUtils.contains(NETWORK_STATES, nai.networkInfo.getState());
    // We only run clat on networks that don't have a native IPv4 address.
    final boolean hasIPv4Address = (nai.linkProperties != null) && nai.linkProperties.hasIPv4Address();
    return supported && connected && !hasIPv4Address && !nai.networkMisc.disable464xlat;
}
#method_after
public static boolean requiresClat(NetworkAgentInfo nai) {
    // TODO: migrate to NetworkCapabilities.TRANSPORT_*.
    final boolean supported = ArrayUtils.contains(NETWORK_TYPES, nai.networkInfo.getType());
    final boolean connected = ArrayUtils.contains(NETWORK_STATES, nai.networkInfo.getState());
    // We only run clat on networks that don't have a native IPv4 address.
    final boolean hasIPv4Address = (nai.linkProperties != null) && nai.linkProperties.hasIPv4Address();
    final boolean skip464xlat = (nai.networkMisc != null) && nai.networkMisc.skip464xlat;
    return supported && connected && !hasIPv4Address && !skip464xlat;
}
#end_block

#method_before
@Override
public ListenableFuture<ControllerResult> setPlaylist(@NonNull final List<MediaItem2> list, @Nullable final MediaMetadata2 metadata) {
    return dispatchRemoteSessionTask(COMMAND_CODE_PLAYER_SET_PLAYLIST, new RemoteSessionTask() {

        @Override
        public void run(IMediaSession2 iSession2, int seq) throws RemoteException {
            iSession2.setPlaylist(mControllerStub, seq, new ParcelImplListSlice(MediaUtils2.convertMediaItem2ListToParcelImplList(list)), (metadata == null) ? null : metadata.toBundle());
        }
    });
}
#method_after
@Override
public ListenableFuture<ControllerResult> setPlaylist(@NonNull final List<MediaItem2> list, @Nullable final MediaMetadata2 metadata) {
    return dispatchRemoteSessionTask(COMMAND_CODE_PLAYER_SET_PLAYLIST, new RemoteSessionTask() {

        @Override
        public void run(IMediaSession2 iSession2, int seq) throws RemoteException {
            iSession2.setPlaylist(mControllerStub, seq, MediaUtils2.convertMediaItem2ListToParcelImplListSlice(list), (metadata == null) ? null : metadata.toBundle());
        }
    });
}
#end_block

#method_before
@Override
public void onCommand(final String commandName, final Bundle args, final ResultReceiver cb) {
    if (commandName == null) {
        return;
    }
    final SessionCommand2 command = new SessionCommand2(commandName, null);
    onSessionTask(command, new SessionTask() {

        @Override
        public void run(final ControllerInfo controller) throws RemoteException {
            SessionResult result = mSessionImpl.getCallback().onCustomCommand(mSessionImpl.getInstance(), controller, command, args);
            if (cb != null) {
                cb.send(result.getResultCode(), result.getCustomCommandResult());
            }
        }
    });
}
#method_after
@Override
public void onCommand(final String commandName, final Bundle args, final ResultReceiver cb) {
    if (commandName == null) {
        return;
    }
    final SessionCommand2 command = new SessionCommand2(commandName, null);
    dispatchSessionTask(command, new SessionTask() {

        @Override
        public void run(final ControllerInfo controller) throws RemoteException {
            SessionResult result = mSessionImpl.getCallback().onCustomCommand(mSessionImpl.getInstance(), controller, command, args);
            if (cb != null) {
                cb.send(result.getResultCode(), result.getCustomCommandResult());
            }
        }
    });
}
#end_block

#method_before
@Override
public void onPrepare() {
    onSessionTask(SessionCommand2.COMMAND_CODE_PLAYER_PREFETCH, new SessionTask() {

        @Override
        public void run(ControllerInfo controller) throws RemoteException {
            mSessionImpl.prefetch();
        }
    });
}
#method_after
@Override
public void onPrepare() {
    dispatchSessionTask(SessionCommand2.COMMAND_CODE_PLAYER_PREFETCH, new SessionTask() {

        @Override
        public void run(ControllerInfo controller) throws RemoteException {
            mSessionImpl.prefetch();
        }
    });
}
#end_block

#method_before
@Override
public void onPrepareFromMediaId(final String mediaId, final Bundle extras) {
    if (mediaId == null) {
        return;
    }
    onSessionTask(SessionCommand2.COMMAND_CODE_SESSION_PREFETCH_FROM_MEDIA_ID, new SessionTask() {

        @Override
        public void run(ControllerInfo controller) throws RemoteException {
            mSessionImpl.getCallback().onPrefetchFromMediaId(mSessionImpl.getInstance(), controller, mediaId, extras);
        }
    });
}
#method_after
@Override
public void onPrepareFromMediaId(final String mediaId, final Bundle extras) {
    if (mediaId == null) {
        return;
    }
    dispatchSessionTask(SessionCommand2.COMMAND_CODE_SESSION_PREFETCH_FROM_MEDIA_ID, new SessionTask() {

        @Override
        public void run(ControllerInfo controller) throws RemoteException {
            mSessionImpl.getCallback().onPrefetchFromMediaId(mSessionImpl.getInstance(), controller, mediaId, extras);
        }
    });
}
#end_block

#method_before
@Override
public void onPrepareFromSearch(final String query, final Bundle extras) {
    if (query == null) {
        return;
    }
    onSessionTask(SessionCommand2.COMMAND_CODE_SESSION_PREFETCH_FROM_SEARCH, new SessionTask() {

        @Override
        public void run(ControllerInfo controller) throws RemoteException {
            mSessionImpl.getCallback().onPrefetchFromSearch(mSessionImpl.getInstance(), controller, query, extras);
        }
    });
}
#method_after
@Override
public void onPrepareFromSearch(final String query, final Bundle extras) {
    if (query == null) {
        return;
    }
    dispatchSessionTask(SessionCommand2.COMMAND_CODE_SESSION_PREFETCH_FROM_SEARCH, new SessionTask() {

        @Override
        public void run(ControllerInfo controller) throws RemoteException {
            mSessionImpl.getCallback().onPrefetchFromSearch(mSessionImpl.getInstance(), controller, query, extras);
        }
    });
}
#end_block

#method_before
@Override
public void onPrepareFromUri(final Uri uri, final Bundle extras) {
    if (uri == null) {
        return;
    }
    onSessionTask(SessionCommand2.COMMAND_CODE_SESSION_PREFETCH_FROM_URI, new SessionTask() {

        @Override
        public void run(ControllerInfo controller) throws RemoteException {
            mSessionImpl.getCallback().onPrefetchFromUri(mSessionImpl.getInstance(), controller, uri, extras);
        }
    });
}
#method_after
@Override
public void onPrepareFromUri(final Uri uri, final Bundle extras) {
    if (uri == null) {
        return;
    }
    dispatchSessionTask(SessionCommand2.COMMAND_CODE_SESSION_PREFETCH_FROM_URI, new SessionTask() {

        @Override
        public void run(ControllerInfo controller) throws RemoteException {
            mSessionImpl.getCallback().onPrefetchFromUri(mSessionImpl.getInstance(), controller, uri, extras);
        }
    });
}
#end_block

#method_before
@Override
public void onPlay() {
    onSessionTask(SessionCommand2.COMMAND_CODE_PLAYER_PLAY, new SessionTask() {

        @Override
        public void run(ControllerInfo controller) throws RemoteException {
            mSessionImpl.play();
        }
    });
}
#method_after
@Override
public void onPlay() {
    dispatchSessionTask(SessionCommand2.COMMAND_CODE_PLAYER_PLAY, new SessionTask() {

        @Override
        public void run(ControllerInfo controller) throws RemoteException {
            mSessionImpl.play();
        }
    });
}
#end_block

#method_before
@Override
public void onPlayFromMediaId(final String mediaId, final Bundle extras) {
    if (mediaId == null) {
        return;
    }
    onSessionTask(SessionCommand2.COMMAND_CODE_SESSION_PLAY_FROM_MEDIA_ID, new SessionTask() {

        @Override
        public void run(ControllerInfo controller) throws RemoteException {
            mSessionImpl.getCallback().onPlayFromMediaId(mSessionImpl.getInstance(), controller, mediaId, extras);
        }
    });
}
#method_after
@Override
public void onPlayFromMediaId(final String mediaId, final Bundle extras) {
    if (mediaId == null) {
        return;
    }
    dispatchSessionTask(SessionCommand2.COMMAND_CODE_SESSION_PLAY_FROM_MEDIA_ID, new SessionTask() {

        @Override
        public void run(ControllerInfo controller) throws RemoteException {
            mSessionImpl.getCallback().onPlayFromMediaId(mSessionImpl.getInstance(), controller, mediaId, extras);
        }
    });
}
#end_block

#method_before
@Override
public void onPlayFromSearch(final String query, final Bundle extras) {
    if (query == null) {
        return;
    }
    onSessionTask(SessionCommand2.COMMAND_CODE_SESSION_PLAY_FROM_SEARCH, new SessionTask() {

        @Override
        public void run(ControllerInfo controller) throws RemoteException {
            mSessionImpl.getCallback().onPlayFromSearch(mSessionImpl.getInstance(), controller, query, extras);
        }
    });
}
#method_after
@Override
public void onPlayFromSearch(final String query, final Bundle extras) {
    if (query == null) {
        return;
    }
    dispatchSessionTask(SessionCommand2.COMMAND_CODE_SESSION_PLAY_FROM_SEARCH, new SessionTask() {

        @Override
        public void run(ControllerInfo controller) throws RemoteException {
            mSessionImpl.getCallback().onPlayFromSearch(mSessionImpl.getInstance(), controller, query, extras);
        }
    });
}
#end_block

#method_before
@Override
public void onPlayFromUri(final Uri uri, final Bundle extras) {
    if (uri == null) {
        return;
    }
    onSessionTask(SessionCommand2.COMMAND_CODE_SESSION_PLAY_FROM_URI, new SessionTask() {

        @Override
        public void run(ControllerInfo controller) throws RemoteException {
            mSessionImpl.getCallback().onPlayFromUri(mSessionImpl.getInstance(), controller, uri, extras);
        }
    });
}
#method_after
@Override
public void onPlayFromUri(final Uri uri, final Bundle extras) {
    if (uri == null) {
        return;
    }
    dispatchSessionTask(SessionCommand2.COMMAND_CODE_SESSION_PLAY_FROM_URI, new SessionTask() {

        @Override
        public void run(ControllerInfo controller) throws RemoteException {
            mSessionImpl.getCallback().onPlayFromUri(mSessionImpl.getInstance(), controller, uri, extras);
        }
    });
}
#end_block

#method_before
@Override
public void onPause() {
    onSessionTask(SessionCommand2.COMMAND_CODE_PLAYER_PAUSE, new SessionTask() {

        @Override
        public void run(ControllerInfo controller) throws RemoteException {
            mSessionImpl.pause();
        }
    });
}
#method_after
@Override
public void onPause() {
    dispatchSessionTask(SessionCommand2.COMMAND_CODE_PLAYER_PAUSE, new SessionTask() {

        @Override
        public void run(ControllerInfo controller) throws RemoteException {
            mSessionImpl.pause();
        }
    });
}
#end_block

#method_before
@Override
public void onStop() {
    // Here, we don't call SessionPlayer2#reset() since it may result removing
    // all callbacks from the player. Instead, we pause and seek to zero.
    // Here, we check both permissions: Pause / SeekTo.
    onSessionTask(SessionCommand2.COMMAND_CODE_PLAYER_PAUSE, new SessionTask() {

        @Override
        public void run(ControllerInfo controller) throws RemoteException {
            handleTaskOnExecutor(controller, null, SessionCommand2.COMMAND_CODE_PLAYER_SEEK_TO, new SessionTask() {

                @Override
                public void run(ControllerInfo controller) throws RemoteException {
                    mSessionImpl.pause();
                    mSessionImpl.seekTo(0);
                }
            });
        }
    });
}
#method_after
@Override
public void onStop() {
    // Here, we don't call SessionPlayer2#reset() since it may result removing
    // all callbacks from the player. Instead, we pause and seek to zero.
    // Here, we check both permissions: Pause / SeekTo.
    dispatchSessionTask(SessionCommand2.COMMAND_CODE_PLAYER_PAUSE, new SessionTask() {

        @Override
        public void run(ControllerInfo controller) throws RemoteException {
            handleTaskOnExecutor(controller, null, SessionCommand2.COMMAND_CODE_PLAYER_SEEK_TO, new SessionTask() {

                @Override
                public void run(ControllerInfo controller) throws RemoteException {
                    mSessionImpl.pause();
                    mSessionImpl.seekTo(0);
                }
            });
        }
    });
}
#end_block

#method_before
@Override
public void onSeekTo(final long pos) {
    onSessionTask(SessionCommand2.COMMAND_CODE_PLAYER_SEEK_TO, new SessionTask() {

        @Override
        public void run(ControllerInfo controller) throws RemoteException {
            mSessionImpl.seekTo(pos);
        }
    });
}
#method_after
@Override
public void onSeekTo(final long pos) {
    dispatchSessionTask(SessionCommand2.COMMAND_CODE_PLAYER_SEEK_TO, new SessionTask() {

        @Override
        public void run(ControllerInfo controller) throws RemoteException {
            mSessionImpl.seekTo(pos);
        }
    });
}
#end_block

#method_before
@Override
public void onSkipToNext() {
    onSessionTask(SessionCommand2.COMMAND_CODE_PLAYER_SKIP_TO_NEXT_PLAYLIST_ITEM, new SessionTask() {

        @Override
        public void run(ControllerInfo controller) throws RemoteException {
            mSessionImpl.skipToNextItem();
        }
    });
}
#method_after
@Override
public void onSkipToNext() {
    dispatchSessionTask(SessionCommand2.COMMAND_CODE_PLAYER_SKIP_TO_NEXT_PLAYLIST_ITEM, new SessionTask() {

        @Override
        public void run(ControllerInfo controller) throws RemoteException {
            mSessionImpl.skipToNextItem();
        }
    });
}
#end_block

#method_before
@Override
public void onSkipToPrevious() {
    onSessionTask(SessionCommand2.COMMAND_CODE_PLAYER_SKIP_TO_PREVIOUS_PLAYLIST_ITEM, new SessionTask() {

        @Override
        public void run(ControllerInfo controller) throws RemoteException {
            mSessionImpl.skipToPreviousItem();
        }
    });
}
#method_after
@Override
public void onSkipToPrevious() {
    dispatchSessionTask(SessionCommand2.COMMAND_CODE_PLAYER_SKIP_TO_PREVIOUS_PLAYLIST_ITEM, new SessionTask() {

        @Override
        public void run(ControllerInfo controller) throws RemoteException {
            mSessionImpl.skipToPreviousItem();
        }
    });
}
#end_block

#method_before
@Override
public void onSkipToQueueItem(final long id) {
    onSessionTask(SessionCommand2.COMMAND_CODE_PLAYER_SKIP_TO_PLAYLIST_ITEM, new SessionTask() {

        @Override
        public void run(ControllerInfo controller) throws RemoteException {
            List<MediaItem2> playlist = mSessionImpl.getPlayer().getPlaylist();
            if (playlist == null) {
                return;
            }
            for (int i = 0; i < playlist.size(); i++) {
                MediaItem2 item = playlist.get(i);
                if (item != null && item.getUuid().getMostSignificantBits() == id) {
                    mSessionImpl.skipToPlaylistItem(item);
                    break;
                }
            }
        }
    });
}
#method_after
@Override
public void onSkipToQueueItem(final long id) {
    dispatchSessionTask(SessionCommand2.COMMAND_CODE_PLAYER_SKIP_TO_PLAYLIST_ITEM, new SessionTask() {

        @Override
        public void run(ControllerInfo controller) throws RemoteException {
            List<MediaItem2> playlist = mSessionImpl.getPlayer().getPlaylist();
            if (playlist == null) {
                return;
            }
            for (int i = 0; i < playlist.size(); i++) {
                MediaItem2 item = playlist.get(i);
                if (item != null && item.getUuid().getMostSignificantBits() == id) {
                    mSessionImpl.skipToPlaylistItem(item);
                    break;
                }
            }
        }
    });
}
#end_block

#method_before
@Override
public void onFastForward() {
    onSessionTask(SessionCommand2.COMMAND_CODE_SESSION_FAST_FORWARD, new SessionTask() {

        @Override
        public void run(ControllerInfo controller) throws RemoteException {
            mSessionImpl.getCallback().onFastForward(mSessionImpl.getInstance(), controller);
        }
    });
}
#method_after
@Override
public void onFastForward() {
    dispatchSessionTask(SessionCommand2.COMMAND_CODE_SESSION_FAST_FORWARD, new SessionTask() {

        @Override
        public void run(ControllerInfo controller) throws RemoteException {
            mSessionImpl.getCallback().onFastForward(mSessionImpl.getInstance(), controller);
        }
    });
}
#end_block

#method_before
@Override
public void onRewind() {
    onSessionTask(SessionCommand2.COMMAND_CODE_SESSION_REWIND, new SessionTask() {

        @Override
        public void run(ControllerInfo controller) throws RemoteException {
            mSessionImpl.getCallback().onRewind(mSessionImpl.getInstance(), controller);
        }
    });
}
#method_after
@Override
public void onRewind() {
    dispatchSessionTask(SessionCommand2.COMMAND_CODE_SESSION_REWIND, new SessionTask() {

        @Override
        public void run(ControllerInfo controller) throws RemoteException {
            mSessionImpl.getCallback().onRewind(mSessionImpl.getInstance(), controller);
        }
    });
}
#end_block

#method_before
@Override
public void onSetRating(final RatingCompat rating, Bundle extras) {
    if (rating == null) {
        return;
    }
    // extras is ignored.
    onSessionTask(SessionCommand2.COMMAND_CODE_SESSION_SET_RATING, new SessionTask() {

        @Override
        public void run(ControllerInfo controller) throws RemoteException {
            MediaItem2 currentItem = mSessionImpl.getCurrentMediaItem();
            if (currentItem == null) {
                return;
            }
            mSessionImpl.getCallback().onSetRating(mSessionImpl.getInstance(), controller, currentItem.getMediaId(), MediaUtils2.convertToRating2(rating));
        }
    });
}
#method_after
@Override
public void onSetRating(final RatingCompat rating, Bundle extras) {
    if (rating == null) {
        return;
    }
    // extras is ignored.
    dispatchSessionTask(SessionCommand2.COMMAND_CODE_SESSION_SET_RATING, new SessionTask() {

        @Override
        public void run(ControllerInfo controller) throws RemoteException {
            MediaItem2 currentItem = mSessionImpl.getCurrentMediaItem();
            if (currentItem == null) {
                return;
            }
            mSessionImpl.getCallback().onSetRating(mSessionImpl.getInstance(), controller, currentItem.getMediaId(), MediaUtils2.convertToRating2(rating));
        }
    });
}
#end_block

#method_before
@Override
public void onSetRepeatMode(final int repeatMode) {
    onSessionTask(SessionCommand2.COMMAND_CODE_PLAYER_SET_REPEAT_MODE, new SessionTask() {

        @Override
        public void run(ControllerInfo controller) throws RemoteException {
            mSessionImpl.setRepeatMode(repeatMode);
        }
    });
}
#method_after
@Override
public void onSetRepeatMode(final int repeatMode) {
    dispatchSessionTask(SessionCommand2.COMMAND_CODE_PLAYER_SET_REPEAT_MODE, new SessionTask() {

        @Override
        public void run(ControllerInfo controller) throws RemoteException {
            mSessionImpl.setRepeatMode(repeatMode);
        }
    });
}
#end_block

#method_before
@Override
public void onSetShuffleMode(final int shuffleMode) {
    onSessionTask(SessionCommand2.COMMAND_CODE_PLAYER_SET_SHUFFLE_MODE, new SessionTask() {

        @Override
        public void run(ControllerInfo controller) throws RemoteException {
            mSessionImpl.setShuffleMode(shuffleMode);
        }
    });
}
#method_after
@Override
public void onSetShuffleMode(final int shuffleMode) {
    dispatchSessionTask(SessionCommand2.COMMAND_CODE_PLAYER_SET_SHUFFLE_MODE, new SessionTask() {

        @Override
        public void run(ControllerInfo controller) throws RemoteException {
            mSessionImpl.setShuffleMode(shuffleMode);
        }
    });
}
#end_block

#method_before
@Override
public void onAddQueueItem(final MediaDescriptionCompat description) {
    if (description == null) {
        return;
    }
    onSessionTask(SessionCommand2.COMMAND_CODE_PLAYER_ADD_PLAYLIST_ITEM, new SessionTask() {

        @Override
        public void run(ControllerInfo controller) throws RemoteException {
            // Add the item at the end of the playlist.
            mSessionImpl.addPlaylistItem(Integer.MAX_VALUE, MediaUtils2.convertToMediaItem2(description));
        }
    });
}
#method_after
@Override
public void onAddQueueItem(final MediaDescriptionCompat description) {
    if (description == null) {
        return;
    }
    dispatchSessionTask(SessionCommand2.COMMAND_CODE_PLAYER_ADD_PLAYLIST_ITEM, new SessionTask() {

        @Override
        public void run(ControllerInfo controller) throws RemoteException {
            // Add the item at the end of the playlist.
            mSessionImpl.addPlaylistItem(Integer.MAX_VALUE, MediaUtils2.convertToMediaItem2(description));
        }
    });
}
#end_block

#method_before
@Override
public void onAddQueueItem(final MediaDescriptionCompat description, final int index) {
    if (description == null) {
        return;
    }
    onSessionTask(SessionCommand2.COMMAND_CODE_PLAYER_ADD_PLAYLIST_ITEM, new SessionTask() {

        @Override
        public void run(ControllerInfo controller) throws RemoteException {
            mSessionImpl.addPlaylistItem(index, MediaUtils2.convertToMediaItem2(description));
        }
    });
}
#method_after
@Override
public void onAddQueueItem(final MediaDescriptionCompat description, final int index) {
    if (description == null) {
        return;
    }
    dispatchSessionTask(SessionCommand2.COMMAND_CODE_PLAYER_ADD_PLAYLIST_ITEM, new SessionTask() {

        @Override
        public void run(ControllerInfo controller) throws RemoteException {
            mSessionImpl.addPlaylistItem(index, MediaUtils2.convertToMediaItem2(description));
        }
    });
}
#end_block

#method_before
@Override
public void onRemoveQueueItem(final MediaDescriptionCompat description) {
    if (description == null) {
        return;
    }
    onSessionTask(SessionCommand2.COMMAND_CODE_PLAYER_REMOVE_PLAYLIST_ITEM, new SessionTask() {

        @Override
        public void run(ControllerInfo controller) throws RemoteException {
            // Note: Here we cannot simply call
            // removePlaylistItem(MediaUtils2.convertToMediaItem2(description)),
            // because the result of the method will have different UUID.
            List<MediaItem2> playlist = mSessionImpl.getPlaylist();
            for (int i = 0; i < playlist.size(); i++) {
                MediaItem2 item = playlist.get(i);
                if (TextUtils.equals(item.getMediaId(), description.getMediaId())) {
                    mSessionImpl.removePlaylistItem(item);
                    return;
                }
            }
        }
    });
}
#method_after
@Override
public void onRemoveQueueItem(final MediaDescriptionCompat description) {
    if (description == null) {
        return;
    }
    dispatchSessionTask(SessionCommand2.COMMAND_CODE_PLAYER_REMOVE_PLAYLIST_ITEM, new SessionTask() {

        @Override
        public void run(ControllerInfo controller) throws RemoteException {
            // Note: Here we cannot simply call
            // removePlaylistItem(MediaUtils2.convertToMediaItem2(description)),
            // because the result of the method will have different UUID.
            List<MediaItem2> playlist = mSessionImpl.getPlaylist();
            for (int i = 0; i < playlist.size(); i++) {
                MediaItem2 item = playlist.get(i);
                if (TextUtils.equals(item.getMediaId(), description.getMediaId())) {
                    mSessionImpl.removePlaylistItem(item);
                    return;
                }
            }
        }
    });
}
#end_block

#method_before
@Override
void onPlaylistChanged(List<MediaItem2> playlist, MediaMetadata2 metadata) throws RemoteException {
    mSessionImpl.getSessionCompat().setQueue(MediaUtils2.convertToQueueItemList(playlist));
    onPlaylistMetadataChanged(metadata);
}
#method_after
@Override
void onPlaylistChanged(List<MediaItem2> playlist, MediaMetadata2 metadata) throws RemoteException {
    if (Build.VERSION.SDK_INT < 21) {
        // In order to avoid TransactionTooLargeException for below API 21,
        // we need to cut the list so that it doesn't exceed the binder transaction limit.
        List<QueueItem> queueItemList = MediaUtils2.convertToQueueItemList(playlist);
        List<QueueItem> truncatedList = MediaUtils2.truncateListBySize(queueItemList, TRANSACTION_SIZE_LIMIT_IN_BYTES);
        if (truncatedList.size() != playlist.size()) {
            Log.i(TAG, "Sending " + truncatedList.size() + " items out of " + playlist.size());
        }
        mSessionImpl.getSessionCompat().setQueue(truncatedList);
    } else {
        // Framework MediaSession#setQueue() uses ParceledListSlice,
        // which means we can safely send long lists.
        mSessionImpl.getSessionCompat().setQueue(MediaUtils2.convertToQueueItemList(playlist));
    }
    onPlaylistMetadataChanged(metadata);
}
#end_block

#method_before
@Override
public void notifyChildrenChanged(final String parentId, final int itemCount, final Bundle extras) {
    if (TextUtils.isEmpty(parentId)) {
        throw new IllegalArgumentException("query shouldn't be empty");
    }
    if (itemCount < 0) {
        throw new IllegalArgumentException("itemCount shouldn't be negative");
    }
    dispatchRemoteControllerNotifyTask(new RemoteControllerNotifyTask() {

        @Override
        public void run(ControllerCb callback) throws RemoteException {
            if (isSubscribed(callback, parentId)) {
                callback.onChildrenChanged(parentId, itemCount, extras);
            }
        }
    });
}
#method_after
@Override
public void notifyChildrenChanged(final String parentId, final int itemCount, final Bundle extras) {
    if (TextUtils.isEmpty(parentId)) {
        throw new IllegalArgumentException("query shouldn't be empty");
    }
    if (itemCount < 0) {
        throw new IllegalArgumentException("itemCount shouldn't be negative");
    }
    dispatchRemoteControllerCallbackTask(new RemoteControllerCallbackTask() {

        @Override
        public void run(ControllerCb callback) throws RemoteException {
            if (isSubscribed(callback, parentId)) {
                callback.onChildrenChanged(parentId, itemCount, extras);
            }
        }
    });
}
#end_block

#method_before
@Override
public void notifyChildrenChanged(final ControllerInfo controller, final String parentId, final int itemCount, final Bundle extras) {
    if (controller == null) {
        throw new IllegalArgumentException("controller shouldn't be null");
    }
    if (TextUtils.isEmpty(parentId)) {
        throw new IllegalArgumentException("query shouldn't be empty");
    }
    if (itemCount < 0) {
        throw new IllegalArgumentException("itemCount shouldn't be negative");
    }
    dispatchRemoteControllerNotifyTask(controller, new RemoteControllerNotifyTask() {

        @Override
        public void run(ControllerCb callback) throws RemoteException {
            if (!isSubscribed(callback, parentId)) {
                if (DEBUG) {
                    Log.d(TAG, "Skipping notifyChildrenChanged() to " + controller + " because it hasn't subscribed");
                    dumpSubscription();
                }
                return;
            }
            callback.onChildrenChanged(parentId, itemCount, extras);
        }
    });
}
#method_after
@Override
public void notifyChildrenChanged(final ControllerInfo controller, final String parentId, final int itemCount, final Bundle extras) {
    if (controller == null) {
        throw new IllegalArgumentException("controller shouldn't be null");
    }
    if (TextUtils.isEmpty(parentId)) {
        throw new IllegalArgumentException("query shouldn't be empty");
    }
    if (itemCount < 0) {
        throw new IllegalArgumentException("itemCount shouldn't be negative");
    }
    dispatchRemoteControllerCallbackTask(controller, new RemoteControllerCallbackTask() {

        @Override
        public void run(ControllerCb callback) throws RemoteException {
            if (!isSubscribed(callback, parentId)) {
                if (DEBUG) {
                    Log.d(TAG, "Skipping notifyChildrenChanged() to " + controller + " because it hasn't subscribed");
                    dumpSubscription();
                }
                return;
            }
            callback.onChildrenChanged(parentId, itemCount, extras);
        }
    });
}
#end_block

#method_before
@Override
public void notifySearchResultChanged(ControllerInfo controller, final String query, final int itemCount, final Bundle extras) {
    if (controller == null) {
        throw new IllegalArgumentException("controller shouldn't be null");
    }
    if (TextUtils.isEmpty(query)) {
        throw new IllegalArgumentException("query shouldn't be empty");
    }
    dispatchRemoteControllerNotifyTask(controller, new RemoteControllerNotifyTask() {

        @Override
        public void run(ControllerCb callback) throws RemoteException {
            callback.onSearchResultChanged(query, itemCount, extras);
        }
    });
}
#method_after
@Override
public void notifySearchResultChanged(ControllerInfo controller, final String query, final int itemCount, final Bundle extras) {
    if (controller == null) {
        throw new IllegalArgumentException("controller shouldn't be null");
    }
    if (TextUtils.isEmpty(query)) {
        throw new IllegalArgumentException("query shouldn't be empty");
    }
    dispatchRemoteControllerCallbackTask(controller, new RemoteControllerCallbackTask() {

        @Override
        public void run(ControllerCb callback) throws RemoteException {
            callback.onSearchResultChanged(query, itemCount, extras);
        }
    });
}
#end_block

#method_before
@Override
public void onGetLibraryRootOnExecutor(ControllerInfo controller, final Bundle rootHints) {
    final LibraryRoot root = getCallback().onGetLibraryRoot(getInstance(), controller, rootHints);
    dispatchRemoteControllerNotifyTask(controller, new RemoteControllerNotifyTask() {

        @Override
        public void run(ControllerCb callback) throws RemoteException {
            callback.onGetLibraryRootDone(rootHints, root == null ? null : root.getRootId(), root == null ? null : root.getExtras());
        }
    });
}
#method_after
@Override
public void onGetLibraryRootOnExecutor(ControllerInfo controller, final Bundle rootHints) {
    final LibraryRoot root = getCallback().onGetLibraryRoot(getInstance(), controller, rootHints);
    dispatchRemoteControllerCallbackTask(controller, new RemoteControllerCallbackTask() {

        @Override
        public void run(ControllerCb callback) throws RemoteException {
            callback.onGetLibraryRootDone(rootHints, root == null ? null : root.getRootId(), root == null ? null : root.getExtras());
        }
    });
}
#end_block

#method_before
@Override
public void onGetItemOnExecutor(ControllerInfo controller, final String mediaId) {
    final MediaItem2 result = getCallback().onGetItem(getInstance(), controller, mediaId);
    dispatchRemoteControllerNotifyTask(controller, new RemoteControllerNotifyTask() {

        @Override
        public void run(ControllerCb callback) throws RemoteException {
            callback.onGetItemDone(mediaId, result);
        }
    });
}
#method_after
@Override
public void onGetItemOnExecutor(ControllerInfo controller, final String mediaId) {
    final MediaItem2 result = getCallback().onGetItem(getInstance(), controller, mediaId);
    dispatchRemoteControllerCallbackTask(controller, new RemoteControllerCallbackTask() {

        @Override
        public void run(ControllerCb callback) throws RemoteException {
            callback.onGetItemDone(mediaId, result);
        }
    });
}
#end_block

#method_before
@Override
public void onGetChildrenOnExecutor(ControllerInfo controller, final String parentId, final int page, final int pageSize, final Bundle extras) {
    final List<MediaItem2> result = getCallback().onGetChildren(getInstance(), controller, parentId, page, pageSize, extras);
    if (result != null && result.size() > pageSize) {
        throw new IllegalArgumentException("onGetChildren() shouldn't return media items " + "more than pageSize. result.size()=" + result.size() + " pageSize=" + pageSize);
    }
    dispatchRemoteControllerNotifyTask(controller, new RemoteControllerNotifyTask() {

        @Override
        public void run(ControllerCb callback) throws RemoteException {
            callback.onGetChildrenDone(parentId, page, pageSize, result, extras);
        }
    });
}
#method_after
@Override
public void onGetChildrenOnExecutor(ControllerInfo controller, final String parentId, final int page, final int pageSize, final Bundle extras) {
    final List<MediaItem2> result = getCallback().onGetChildren(getInstance(), controller, parentId, page, pageSize, extras);
    if (result != null && result.size() > pageSize) {
        throw new IllegalArgumentException("onGetChildren() shouldn't return media items " + "more than pageSize. result.size()=" + result.size() + " pageSize=" + pageSize);
    }
    dispatchRemoteControllerCallbackTask(controller, new RemoteControllerCallbackTask() {

        @Override
        public void run(ControllerCb callback) throws RemoteException {
            callback.onGetChildrenDone(parentId, page, pageSize, result, extras);
        }
    });
}
#end_block

#method_before
@Override
public void onGetSearchResultOnExecutor(ControllerInfo controller, final String query, final int page, final int pageSize, final Bundle extras) {
    final List<MediaItem2> result = getCallback().onGetSearchResult(getInstance(), controller, query, page, pageSize, extras);
    if (result != null && result.size() > pageSize) {
        throw new IllegalArgumentException("onGetSearchResult() shouldn't return media " + "items more than pageSize. result.size()=" + result.size() + " pageSize=" + pageSize);
    }
    dispatchRemoteControllerNotifyTask(controller, new RemoteControllerNotifyTask() {

        @Override
        public void run(ControllerCb callback) throws RemoteException {
            callback.onGetSearchResultDone(query, page, pageSize, result, extras);
        }
    });
}
#method_after
@Override
public void onGetSearchResultOnExecutor(ControllerInfo controller, final String query, final int page, final int pageSize, final Bundle extras) {
    final List<MediaItem2> result = getCallback().onGetSearchResult(getInstance(), controller, query, page, pageSize, extras);
    if (result != null && result.size() > pageSize) {
        throw new IllegalArgumentException("onGetSearchResult() shouldn't return media " + "items more than pageSize. result.size()=" + result.size() + " pageSize=" + pageSize);
    }
    dispatchRemoteControllerCallbackTask(controller, new RemoteControllerCallbackTask() {

        @Override
        public void run(ControllerCb callback) throws RemoteException {
            callback.onGetSearchResultDone(query, page, pageSize, result, extras);
        }
    });
}
#end_block

#method_before
@Override
public void close() {
    synchronized (mLock) {
        if (isClosed()) {
            return;
        }
        synchronized (MediaSession2ImplBase.class) {
            SESSION_ID_LIST.remove(mSessionId);
        }
        mPlayer.unregisterPlayerCallback(mPlayerCallback);
        mSessionCompat.release();
        mCallback.onSessionClosed(mInstance);
        dispatchRemoteControllerNotifyTask(new RemoteControllerNotifyTask() {

            @Override
            public void run(ControllerCb callback) throws RemoteException {
                callback.onDisconnected();
            }
        });
        mHandler.removeCallbacksAndMessages(null);
        if (mHandlerThread.isAlive()) {
            if (Build.VERSION.SDK_INT >= 18) {
                mHandlerThread.quitSafely();
            } else {
                mHandlerThread.quit();
            }
        }
    }
}
#method_after
@Override
public void close() {
    synchronized (mLock) {
        if (isClosed()) {
            return;
        }
        synchronized (MediaSession2ImplBase.class) {
            SESSION_ID_LIST.remove(mSessionId);
        }
        mPlayer.unregisterPlayerCallback(mPlayerCallback);
        mSessionCompat.release();
        mCallback.onSessionClosed(mInstance);
        dispatchRemoteControllerCallbackTask(new RemoteControllerCallbackTask() {

            @Override
            public void run(ControllerCb callback) throws RemoteException {
                callback.onDisconnected();
            }
        });
        mHandler.removeCallbacksAndMessages(null);
        if (mHandlerThread.isAlive()) {
            if (Build.VERSION.SDK_INT >= 18) {
                mHandlerThread.quitSafely();
            } else {
                mHandlerThread.quit();
            }
        }
    }
}
#end_block

#method_before
@Override
public ListenableFuture<SessionResult> setCustomLayout(@NonNull ControllerInfo controller, @NonNull final List<MediaSession2.CommandButton> layout) {
    if (controller == null) {
        throw new IllegalArgumentException("controller shouldn't be null");
    }
    if (layout == null) {
        throw new IllegalArgumentException("layout shouldn't be null");
    }
    return dispatchRemoteControllerTask(controller, new RemoteControllerTask() {

        @Override
        public void run(int seq, ControllerCb controller) throws RemoteException {
            controller.setCustomLayout(seq, layout);
        }
    });
}
#method_after
@Override
public ListenableFuture<SessionResult> setCustomLayout(@NonNull ControllerInfo controller, @NonNull final List<MediaSession2.CommandButton> layout) {
    if (controller == null) {
        throw new IllegalArgumentException("controller shouldn't be null");
    }
    if (layout == null) {
        throw new IllegalArgumentException("layout shouldn't be null");
    }
    return dispatchRemoteControllerTask(controller, new RemoteControllerTask() {

        @Override
        public void run(ControllerCb controller, int seq) throws RemoteException {
            controller.setCustomLayout(seq, layout);
        }
    });
}
#end_block

#method_before
@Override
public void setAllowedCommands(@NonNull ControllerInfo controller, @NonNull final SessionCommandGroup2 commands) {
    if (controller == null) {
        throw new IllegalArgumentException("controller shouldn't be null");
    }
    if (commands == null) {
        throw new IllegalArgumentException("commands shouldn't be null");
    }
    if (mSession2Stub.getConnectedControllersManager().isConnected(controller)) {
        mSession2Stub.getConnectedControllersManager().updateAllowedCommands(controller, commands);
        dispatchRemoteControllerNotifyTask(controller, new RemoteControllerNotifyTask() {

            @Override
            public void run(ControllerCb callback) throws RemoteException {
                callback.onAllowedCommandsChanged(commands);
            }
        });
    } else {
        mSessionLegacyStub.getConnectedControllersManager().updateAllowedCommands(controller, commands);
    }
}
#method_after
@Override
public void setAllowedCommands(@NonNull ControllerInfo controller, @NonNull final SessionCommandGroup2 commands) {
    if (controller == null) {
        throw new IllegalArgumentException("controller shouldn't be null");
    }
    if (commands == null) {
        throw new IllegalArgumentException("commands shouldn't be null");
    }
    if (mSession2Stub.getConnectedControllersManager().isConnected(controller)) {
        mSession2Stub.getConnectedControllersManager().updateAllowedCommands(controller, commands);
        dispatchRemoteControllerCallbackTask(controller, new RemoteControllerCallbackTask() {

            @Override
            public void run(ControllerCb callback) throws RemoteException {
                callback.onAllowedCommandsChanged(commands);
            }
        });
    } else {
        mSessionLegacyStub.getConnectedControllersManager().updateAllowedCommands(controller, commands);
    }
}
#end_block

#method_before
@Override
public void broadcastCustomCommand(@NonNull final SessionCommand2 command, @Nullable final Bundle args) {
    if (command == null) {
        throw new IllegalArgumentException("command shouldn't be null");
    }
    dispatchRemoteControllerTask(new RemoteControllerTask() {

        @Override
        public void run(int seq, ControllerCb controller) throws RemoteException {
            controller.sendCustomCommand(seq, command, args);
        }
    });
}
#method_after
@Override
public void broadcastCustomCommand(@NonNull final SessionCommand2 command, @Nullable final Bundle args) {
    if (command == null) {
        throw new IllegalArgumentException("command shouldn't be null");
    }
    dispatchRemoteControllerTask(new RemoteControllerTask() {

        @Override
        public void run(ControllerCb controller, int seq) throws RemoteException {
            controller.sendCustomCommand(seq, command, args);
        }
    });
}
#end_block

#method_before
@Override
public ListenableFuture<SessionResult> sendCustomCommand(@NonNull ControllerInfo controller, @NonNull final SessionCommand2 command, @Nullable final Bundle args) {
    if (controller == null) {
        throw new IllegalArgumentException("controller shouldn't be null");
    }
    if (command == null) {
        throw new IllegalArgumentException("command shouldn't be null");
    }
    return dispatchRemoteControllerTask(controller, new RemoteControllerTask() {

        @Override
        public void run(int seq, ControllerCb controller) throws RemoteException {
            controller.sendCustomCommand(seq, command, args);
        }
    });
}
#method_after
@Override
public ListenableFuture<SessionResult> sendCustomCommand(@NonNull ControllerInfo controller, @NonNull final SessionCommand2 command, @Nullable final Bundle args) {
    if (controller == null) {
        throw new IllegalArgumentException("controller shouldn't be null");
    }
    if (command == null) {
        throw new IllegalArgumentException("command shouldn't be null");
    }
    return dispatchRemoteControllerTask(controller, new RemoteControllerTask() {

        @Override
        public void run(ControllerCb controller, int seq) throws RemoteException {
            controller.sendCustomCommand(seq, command, args);
        }
    });
}
#end_block

#method_before
@Override
public void notifyRoutesInfoChanged(@NonNull ControllerInfo controller, @Nullable final List<Bundle> routes) {
    dispatchRemoteControllerNotifyTask(controller, new RemoteControllerNotifyTask() {

        @Override
        public void run(ControllerCb callback) throws RemoteException {
            callback.onRoutesInfoChanged(routes);
        }
    });
}
#method_after
@Override
public void notifyRoutesInfoChanged(@NonNull ControllerInfo controller, @Nullable final List<Bundle> routes) {
    dispatchRemoteControllerCallbackTask(controller, new RemoteControllerCallbackTask() {

        @Override
        public void run(ControllerCb callback) throws RemoteException {
            callback.onRoutesInfoChanged(routes);
        }
    });
}
#end_block

#method_before
@Override
@SessionPlayer2.PlayerState
public int getPlayerState() {
    return executeCommand(new PlayerTask<Integer>() {

        @Override
        public Integer run(SessionPlayer2 player) throws Exception {
            return player.getPlayerState();
        }
    }, SessionPlayer2.PLAYER_STATE_ERROR);
}
#method_after
@Override
@SessionPlayer2.PlayerState
public int getPlayerState() {
    return dispatchPlayerTask(new PlayerTask<Integer>() {

        @Override
        public Integer run(SessionPlayer2 player) throws Exception {
            return player.getPlayerState();
        }
    }, SessionPlayer2.PLAYER_STATE_ERROR);
}
#end_block

#method_before
@Override
public long getCurrentPosition() {
    return executeCommand(new PlayerTask<Long>() {

        @Override
        public Long run(SessionPlayer2 player) throws Exception {
            if (isInPlaybackState(player)) {
                return player.getCurrentPosition();
            }
            return null;
        }
    }, SessionPlayer2.UNKNOWN_TIME);
}
#method_after
@Override
public long getCurrentPosition() {
    return dispatchPlayerTask(new PlayerTask<Long>() {

        @Override
        public Long run(SessionPlayer2 player) throws Exception {
            if (isInPlaybackState(player)) {
                return player.getCurrentPosition();
            }
            return null;
        }
    }, SessionPlayer2.UNKNOWN_TIME);
}
#end_block

#method_before
@Override
public long getDuration() {
    return executeCommand(new PlayerTask<Long>() {

        @Override
        public Long run(SessionPlayer2 player) throws Exception {
            if (isInPlaybackState(player)) {
                return player.getDuration();
            }
            return null;
        }
    }, SessionPlayer2.UNKNOWN_TIME);
}
#method_after
@Override
public long getDuration() {
    return dispatchPlayerTask(new PlayerTask<Long>() {

        @Override
        public Long run(SessionPlayer2 player) throws Exception {
            if (isInPlaybackState(player)) {
                return player.getDuration();
            }
            return null;
        }
    }, SessionPlayer2.UNKNOWN_TIME);
}
#end_block

#method_before
@Override
public long getBufferedPosition() {
    return executeCommand(new PlayerTask<Long>() {

        @Override
        public Long run(SessionPlayer2 player) throws Exception {
            if (isInPlaybackState(player)) {
                return player.getBufferedPosition();
            }
            return null;
        }
    }, SessionPlayer2.UNKNOWN_TIME);
}
#method_after
@Override
public long getBufferedPosition() {
    return dispatchPlayerTask(new PlayerTask<Long>() {

        @Override
        public Long run(SessionPlayer2 player) throws Exception {
            if (isInPlaybackState(player)) {
                return player.getBufferedPosition();
            }
            return null;
        }
    }, SessionPlayer2.UNKNOWN_TIME);
}
#end_block

#method_before
@Override
@SessionPlayer2.BuffState
public int getBufferingState() {
    return executeCommand(new PlayerTask<Integer>() {

        @Override
        public Integer run(SessionPlayer2 player) throws Exception {
            return player.getBufferingState();
        }
    }, SessionPlayer2.BUFFERING_STATE_UNKNOWN);
}
#method_after
@Override
@SessionPlayer2.BuffState
public int getBufferingState() {
    return dispatchPlayerTask(new PlayerTask<Integer>() {

        @Override
        public Integer run(SessionPlayer2 player) throws Exception {
            return player.getBufferingState();
        }
    }, SessionPlayer2.BUFFERING_STATE_UNKNOWN);
}
#end_block

#method_before
@Override
public float getPlaybackSpeed() {
    return executeCommand(new PlayerTask<Float>() {

        @Override
        public Float run(SessionPlayer2 player) throws Exception {
            if (isInPlaybackState(player)) {
                return player.getPlaybackSpeed();
            }
            return null;
        }
    }, 1.0f);
}
#method_after
@Override
public float getPlaybackSpeed() {
    return dispatchPlayerTask(new PlayerTask<Float>() {

        @Override
        public Float run(SessionPlayer2 player) throws Exception {
            if (isInPlaybackState(player)) {
                return player.getPlaybackSpeed();
            }
            return null;
        }
    }, 1.0f);
}
#end_block

#method_before
@Override
public List<MediaItem2> getPlaylist() {
    return executeCommand(new PlayerTask<List<MediaItem2>>() {

        @Override
        public List<MediaItem2> run(SessionPlayer2 player) throws Exception {
            return player.getPlaylist();
        }
    }, null);
}
#method_after
@Override
public List<MediaItem2> getPlaylist() {
    return dispatchPlayerTask(new PlayerTask<List<MediaItem2>>() {

        @Override
        public List<MediaItem2> run(SessionPlayer2 player) throws Exception {
            return player.getPlaylist();
        }
    }, null);
}
#end_block

#method_before
@Override
public MediaMetadata2 getPlaylistMetadata() {
    return executeCommand(new PlayerTask<MediaMetadata2>() {

        @Override
        public MediaMetadata2 run(SessionPlayer2 player) throws Exception {
            return player.getPlaylistMetadata();
        }
    }, null);
}
#method_after
@Override
public MediaMetadata2 getPlaylistMetadata() {
    return dispatchPlayerTask(new PlayerTask<MediaMetadata2>() {

        @Override
        public MediaMetadata2 run(SessionPlayer2 player) throws Exception {
            return player.getPlaylistMetadata();
        }
    }, null);
}
#end_block

#method_before
@Override
public MediaItem2 getCurrentMediaItem() {
    return executeCommand(new PlayerTask<MediaItem2>() {

        @Override
        public MediaItem2 run(SessionPlayer2 player) throws Exception {
            return player.getCurrentMediaItem();
        }
    }, null);
}
#method_after
@Override
public MediaItem2 getCurrentMediaItem() {
    return dispatchPlayerTask(new PlayerTask<MediaItem2>() {

        @Override
        public MediaItem2 run(SessionPlayer2 player) throws Exception {
            return player.getCurrentMediaItem();
        }
    }, null);
}
#end_block

#method_before
@Override
@SessionPlayer2.RepeatMode
public int getRepeatMode() {
    return executeCommand(new PlayerTask<Integer>() {

        @Override
        public Integer run(SessionPlayer2 player) throws Exception {
            return player.getRepeatMode();
        }
    }, SessionPlayer2.REPEAT_MODE_NONE);
}
#method_after
@Override
@SessionPlayer2.RepeatMode
public int getRepeatMode() {
    return dispatchPlayerTask(new PlayerTask<Integer>() {

        @Override
        public Integer run(SessionPlayer2 player) throws Exception {
            return player.getRepeatMode();
        }
    }, SessionPlayer2.REPEAT_MODE_NONE);
}
#end_block

#method_before
@Override
@SessionPlayer2.ShuffleMode
public int getShuffleMode() {
    return executeCommand(new PlayerTask<Integer>() {

        @Override
        public Integer run(SessionPlayer2 player) throws Exception {
            return player.getShuffleMode();
        }
    }, SessionPlayer2.SHUFFLE_MODE_NONE);
}
#method_after
@Override
@SessionPlayer2.ShuffleMode
public int getShuffleMode() {
    return dispatchPlayerTask(new PlayerTask<Integer>() {

        @Override
        public Integer run(SessionPlayer2 player) throws Exception {
            return player.getShuffleMode();
        }
    }, SessionPlayer2.SHUFFLE_MODE_NONE);
}
#end_block

#method_before
private ListenableFuture<PlayerResult> dispatchPlayerTask(@NonNull PlayerTask<ListenableFuture<PlayerResult>> command) {
    ResolvableFuture<PlayerResult> result = ResolvableFuture.create();
    result.set(new PlayerResult(RESULT_CODE_INVALID_STATE, null));
    return executeCommand(command, result);
}
#method_after
private ListenableFuture<PlayerResult> dispatchPlayerTask(@NonNull PlayerTask<ListenableFuture<PlayerResult>> command) {
    ResolvableFuture<PlayerResult> result = ResolvableFuture.create();
    result.set(new PlayerResult(RESULT_CODE_INVALID_STATE, null));
    return dispatchPlayerTask(command, result);
}
#end_block

#method_before
private ListenableFuture<PlayerResult> dispatchPlayerTask(@NonNull PlayerTask<ListenableFuture<PlayerResult>> command) {
    ResolvableFuture<PlayerResult> result = ResolvableFuture.create();
    result.set(new PlayerResult(RESULT_CODE_INVALID_STATE, null));
    return executeCommand(command, result);
}
#method_after
private <T> T dispatchPlayerTask(@NonNull PlayerTask<T> command, T defaultResult) {
    final SessionPlayer2 player;
    synchronized (mLock) {
        player = mPlayer;
    }
    try {
        if (!isClosed()) {
            T result = command.run(player);
            if (result != null) {
                return result;
            }
        } else if (DEBUG) {
            Log.d(TAG, "API calls after the close()", new IllegalStateException());
        }
    } catch (Exception e) {
    }
    return defaultResult;
}
#end_block

#method_before
@SuppressLint("WrongConstant")
private void notifyPlayerUpdatedNotLocked(SessionPlayer2 oldPlayer) {
    // Tells the playlist change first, to current item can change be notified with an item
    // within the playlist.
    List<MediaItem2> oldPlaylist = oldPlayer.getPlaylist();
    final List<MediaItem2> newPlaylist = getPlaylistOrNull();
    if (!ObjectsCompat.equals(oldPlaylist, newPlaylist)) {
        dispatchRemoteControllerNotifyTask(new RemoteControllerNotifyTask() {

            @Override
            public void run(ControllerCb callback) throws RemoteException {
                callback.onPlaylistChanged(newPlaylist, getPlaylistMetadata());
            }
        });
    } else {
        MediaMetadata2 oldMetadata = oldPlayer.getPlaylistMetadata();
        final MediaMetadata2 newMetadata = getPlaylistMetadata();
        if (!ObjectsCompat.equals(oldMetadata, newMetadata)) {
            dispatchRemoteControllerNotifyTask(new RemoteControllerNotifyTask() {

                @Override
                public void run(ControllerCb callback) throws RemoteException {
                    callback.onPlaylistMetadataChanged(newMetadata);
                }
            });
        }
    }
    MediaItem2 oldCurrentItem = oldPlayer.getCurrentMediaItem();
    final MediaItem2 newCurrentItem = getCurrentMediaItemOrNull();
    if (!ObjectsCompat.equals(oldCurrentItem, newCurrentItem)) {
        dispatchRemoteControllerNotifyTask(new RemoteControllerNotifyTask() {

            @Override
            public void run(ControllerCb callback) throws RemoteException {
                callback.onCurrentMediaItemChanged(newCurrentItem);
            }
        });
    }
    @SessionPlayer2.RepeatMode
    final int repeatMode = getRepeatMode();
    if (oldPlayer.getRepeatMode() != repeatMode) {
        dispatchRemoteControllerNotifyTask(new RemoteControllerNotifyTask() {

            @Override
            public void run(ControllerCb callback) throws RemoteException {
                callback.onRepeatModeChanged(repeatMode);
            }
        });
    }
    @SessionPlayer2.ShuffleMode
    final int shuffleMode = getShuffleMode();
    if (oldPlayer.getShuffleMode() != shuffleMode) {
        dispatchRemoteControllerNotifyTask(new RemoteControllerNotifyTask() {

            @Override
            public void run(ControllerCb callback) throws RemoteException {
                callback.onShuffleModeChanged(shuffleMode);
            }
        });
    }
    // Always forcefully send the player state and buffered state to send the current position
    // and buffered position.
    final long currentTimeMs = SystemClock.elapsedRealtime();
    final long positionMs = getCurrentPosition();
    final int playerState = getPlayerState();
    dispatchRemoteControllerNotifyTask(new RemoteControllerNotifyTask() {

        @Override
        public void run(ControllerCb callback) throws RemoteException {
            callback.onPlayerStateChanged(currentTimeMs, positionMs, playerState);
        }
    });
    final MediaItem2 item = getCurrentMediaItemOrNull();
    if (item != null) {
        final int bufferingState = getBufferingState();
        final long bufferedPositionMs = getBufferedPosition();
        dispatchRemoteControllerNotifyTask(new RemoteControllerNotifyTask() {

            @Override
            public void run(ControllerCb callback) throws RemoteException {
                callback.onBufferingStateChanged(item, bufferingState, bufferedPositionMs);
            }
        });
    }
    final float speed = getPlaybackSpeed();
    if (speed != oldPlayer.getPlaybackSpeed()) {
        dispatchRemoteControllerNotifyTask(new RemoteControllerNotifyTask() {

            @Override
            public void run(ControllerCb callback) throws RemoteException {
                callback.onPlaybackSpeedChanged(currentTimeMs, positionMs, speed);
            }
        });
    }
// Note: AudioInfo is updated outside of this API.
}
#method_after
@SuppressLint("WrongConstant")
private void notifyPlayerUpdatedNotLocked(SessionPlayer2 oldPlayer) {
    // Tells the playlist change first, to current item can change be notified with an item
    // within the playlist.
    List<MediaItem2> oldPlaylist = oldPlayer.getPlaylist();
    final List<MediaItem2> newPlaylist = getPlaylistOrNull();
    if (!ObjectsCompat.equals(oldPlaylist, newPlaylist)) {
        dispatchRemoteControllerCallbackTask(new RemoteControllerCallbackTask() {

            @Override
            public void run(ControllerCb callback) throws RemoteException {
                callback.onPlaylistChanged(newPlaylist, getPlaylistMetadata());
            }
        });
    } else {
        MediaMetadata2 oldMetadata = oldPlayer.getPlaylistMetadata();
        final MediaMetadata2 newMetadata = getPlaylistMetadata();
        if (!ObjectsCompat.equals(oldMetadata, newMetadata)) {
            dispatchRemoteControllerCallbackTask(new RemoteControllerCallbackTask() {

                @Override
                public void run(ControllerCb callback) throws RemoteException {
                    callback.onPlaylistMetadataChanged(newMetadata);
                }
            });
        }
    }
    MediaItem2 oldCurrentItem = oldPlayer.getCurrentMediaItem();
    final MediaItem2 newCurrentItem = getCurrentMediaItemOrNull();
    if (!ObjectsCompat.equals(oldCurrentItem, newCurrentItem)) {
        dispatchRemoteControllerCallbackTask(new RemoteControllerCallbackTask() {

            @Override
            public void run(ControllerCb callback) throws RemoteException {
                callback.onCurrentMediaItemChanged(newCurrentItem);
            }
        });
    }
    @SessionPlayer2.RepeatMode
    final int repeatMode = getRepeatMode();
    if (oldPlayer.getRepeatMode() != repeatMode) {
        dispatchRemoteControllerCallbackTask(new RemoteControllerCallbackTask() {

            @Override
            public void run(ControllerCb callback) throws RemoteException {
                callback.onRepeatModeChanged(repeatMode);
            }
        });
    }
    @SessionPlayer2.ShuffleMode
    final int shuffleMode = getShuffleMode();
    if (oldPlayer.getShuffleMode() != shuffleMode) {
        dispatchRemoteControllerCallbackTask(new RemoteControllerCallbackTask() {

            @Override
            public void run(ControllerCb callback) throws RemoteException {
                callback.onShuffleModeChanged(shuffleMode);
            }
        });
    }
    // Always forcefully send the player state and buffered state to send the current position
    // and buffered position.
    final long currentTimeMs = SystemClock.elapsedRealtime();
    final long positionMs = getCurrentPosition();
    final int playerState = getPlayerState();
    dispatchRemoteControllerCallbackTask(new RemoteControllerCallbackTask() {

        @Override
        public void run(ControllerCb callback) throws RemoteException {
            callback.onPlayerStateChanged(currentTimeMs, positionMs, playerState);
        }
    });
    final MediaItem2 item = getCurrentMediaItemOrNull();
    if (item != null) {
        final int bufferingState = getBufferingState();
        final long bufferedPositionMs = getBufferedPosition();
        dispatchRemoteControllerCallbackTask(new RemoteControllerCallbackTask() {

            @Override
            public void run(ControllerCb callback) throws RemoteException {
                callback.onBufferingStateChanged(item, bufferingState, bufferedPositionMs);
            }
        });
    }
    final float speed = getPlaybackSpeed();
    if (speed != oldPlayer.getPlaybackSpeed()) {
        dispatchRemoteControllerCallbackTask(new RemoteControllerCallbackTask() {

            @Override
            public void run(ControllerCb callback) throws RemoteException {
                callback.onPlaybackSpeedChanged(currentTimeMs, positionMs, speed);
            }
        });
    }
// Note: AudioInfo is updated outside of this API.
}
#end_block

#method_before
@SuppressWarnings("WeakerAccess")
/* synthetic access */
void notifyPlaybackInfoChangedNotLocked(final PlaybackInfo info) {
    dispatchRemoteControllerNotifyTask(new RemoteControllerNotifyTask() {

        @Override
        public void run(ControllerCb callback) throws RemoteException {
            callback.onPlaybackInfoChanged(info);
        }
    });
}
#method_after
@SuppressWarnings("WeakerAccess")
/* synthetic access */
void notifyPlaybackInfoChangedNotLocked(final PlaybackInfo info) {
    dispatchRemoteControllerCallbackTask(new RemoteControllerCallbackTask() {

        @Override
        public void run(ControllerCb callback) throws RemoteException {
            callback.onPlaybackInfoChanged(info);
        }
    });
}
#end_block

#method_before
private ListenableFuture<SessionResult> dispatchRemoteControllerTask(@NonNull ControllerInfo controller, @NonNull RemoteControllerTask command) {
    if (!isConnected(controller)) {
        return SessionResult.createFutureWithResult(RESULT_CODE_DISCONNECTED);
    }
    try {
        final ListenableFuture<SessionResult> result;
        final int seq;
        final SequencedFutureManager manager = mSession2Stub.getConnectedControllersManager().getSequencedFutureManager(controller);
        if (manager != null) {
            result = manager.createSequencedFuture();
            seq = ((SequencedFuture<SessionResult>) result).getSequenceNumber();
        } else {
            // Can be null in two cases. Use the 0 as sequence number in both cases because
            // Case 1) Controller is from the legacy stub
            // -> Sequence number isn't needed, so 0 is OK
            // Case 2) Controller is removed after the connection check above
            // -> Call will fail below or ignored by the controller, so 0 is OK.
            seq = 0;
            result = SessionResult.createFutureWithResult(RESULT_CODE_SUCCESS);
        }
        command.run(seq, controller.getControllerCb());
        return result;
    } catch (DeadObjectException e) {
        onDeadObjectException(controller, e);
        return SessionResult.createFutureWithResult(RESULT_CODE_DISCONNECTED);
    } catch (RemoteException e) {
        // Currently it's TransactionTooLargeException or DeadSystemException.
        // We'd better to leave log for those cases because
        // - TransactionTooLargeException means that we may need to fix our code.
        // (e.g. add pagination or special way to deliver Bitmap)
        // - DeadSystemException means that errors around it can be ignored.
        Log.w(TAG, "Exception in " + controller.toString(), e);
        return SessionResult.createFutureWithResult(RESULT_CODE_UNKNOWN_ERROR);
    }
}
#method_after
private ListenableFuture<SessionResult> dispatchRemoteControllerTask(@NonNull ControllerInfo controller, @NonNull RemoteControllerTask task) {
    if (!isConnected(controller)) {
        return SessionResult.createFutureWithResult(RESULT_CODE_DISCONNECTED);
    }
    try {
        final ListenableFuture<SessionResult> future;
        final int seq;
        final SequencedFutureManager manager = mSession2Stub.getConnectedControllersManager().getSequencedFutureManager(controller);
        if (manager != null) {
            future = manager.createSequencedFuture();
            seq = ((SequencedFuture<SessionResult>) future).getSequenceNumber();
        } else {
            // Can be null in two cases. Use the 0 as sequence number in both cases because
            // Case 1) Controller is from the legacy stub
            // -> Sequence number isn't needed, so 0 is OK
            // Case 2) Controller is removed after the connection check above
            // -> Call will fail below or ignored by the controller, so 0 is OK.
            seq = 0;
            future = SessionResult.createFutureWithResult(RESULT_CODE_SUCCESS);
        }
        task.run(controller.getControllerCb(), seq);
        return future;
    } catch (DeadObjectException e) {
        onDeadObjectException(controller, e);
        return SessionResult.createFutureWithResult(RESULT_CODE_DISCONNECTED);
    } catch (RemoteException e) {
        // Currently it's TransactionTooLargeException or DeadSystemException.
        // We'd better to leave log for those cases because
        // - TransactionTooLargeException means that we may need to fix our code.
        // (e.g. add pagination or special way to deliver Bitmap)
        // - DeadSystemException means that errors around it can be ignored.
        Log.w(TAG, "Exception in " + controller.toString(), e);
    }
    return SessionResult.createFutureWithResult(RESULT_CODE_UNKNOWN_ERROR);
}
#end_block

#method_before
private void dispatchRemoteControllerTask(@NonNull RemoteControllerTask command) {
    List<ControllerInfo> controllers = mSession2Stub.getConnectedControllersManager().getConnectedControllers();
    controllers.add(mSessionLegacyStub.getControllersForAll());
    for (int i = 0; i < controllers.size(); i++) {
        ControllerInfo controller = controllers.get(i);
        try {
            final SequencedFutureManager manager = mSession2Stub.getConnectedControllersManager().getSequencedFutureManager(controller);
            final int seq;
            if (manager != null) {
                seq = manager.obtainNextSequenceNumber();
            // Can be null in two cases. Use the 0 as sequence number in both cases because
            // Case 1) Controller is from the legacy stub
            // -> Sequence number isn't needed, so 0 is OK
            // Case 2) Controller is removed after the connection check above
            // -> Call will fail below or ignored by the controller, so 0 is OK.
            } else {
                seq = 0;
            }
            command.run(seq, controller.getControllerCb());
        } catch (DeadObjectException e) {
            onDeadObjectException(controller, e);
        } catch (RemoteException e) {
            // Currently it's TransactionTooLargeException or DeadSystemException.
            // We'd better to leave log for those cases because
            // - TransactionTooLargeException means that we may need to fix our code.
            // (e.g. add pagination or special way to deliver Bitmap)
            // - DeadSystemException means that errors around it can be ignored.
            Log.w(TAG, "Exception in " + controller.toString(), e);
        }
    }
}
#method_after
void dispatchRemoteControllerTask(@NonNull RemoteControllerTask task) {
    List<ControllerInfo> controllers = mSession2Stub.getConnectedControllersManager().getConnectedControllers();
    controllers.add(mSessionLegacyStub.getControllersForAll());
    for (int i = 0; i < controllers.size(); i++) {
        ControllerInfo controller = controllers.get(i);
        try {
            final int seq;
            final SequencedFutureManager manager = mSession2Stub.getConnectedControllersManager().getSequencedFutureManager(controller);
            if (manager != null) {
                seq = manager.obtainNextSequenceNumber();
            } else {
                // Can be null in two cases. Use the 0 as sequence number in both cases because
                // Case 1) Controller is from the legacy stub
                // -> Sequence number isn't needed, so 0 is OK
                // Case 2) Controller is removed after the connection check above
                // -> Call will fail below or ignored by the controller, so 0 is OK.
                seq = 0;
            }
            task.run(controller.getControllerCb(), seq);
        } catch (DeadObjectException e) {
            onDeadObjectException(controller, e);
        } catch (RemoteException e) {
            // Currently it's TransactionTooLargeException or DeadSystemException.
            // We'd better to leave log for those cases because
            // - TransactionTooLargeException means that we may need to fix our code.
            // (e.g. add pagination or special way to deliver Bitmap)
            // - DeadSystemException means that errors around it can be ignored.
            Log.w(TAG, "Exception in " + controller.toString(), e);
        }
    }
}
#end_block

#method_before
@Override
public void onCurrentMediaItemChanged(final SessionPlayer2 player, final MediaItem2 item) {
    final MediaSession2ImplBase session = getSession();
    if (session == null || session.getPlayer() != player || player == null) {
        return;
    }
    // Note: No sanity check whether the item is in the playlist.
    updateDurationIfNeeded(player, item);
    session.dispatchRemoteControllerNotifyTask(new RemoteControllerNotifyTask() {

        @Override
        public void run(ControllerCb callback) throws RemoteException {
            callback.onCurrentMediaItemChanged(item);
        }
    });
}
#method_after
@Override
public void onCurrentMediaItemChanged(final SessionPlayer2 player, final MediaItem2 item) {
    final MediaSession2ImplBase session = getSession();
    if (session == null || session.getPlayer() != player || player == null) {
        return;
    }
    // Note: No sanity check whether the item is in the playlist.
    updateDurationIfNeeded(player, item);
    session.dispatchRemoteControllerCallbackTask(new RemoteControllerCallbackTask() {

        @Override
        public void run(ControllerCb callback) throws RemoteException {
            callback.onCurrentMediaItemChanged(item);
        }
    });
}
#end_block

#method_before
@Override
public void onPlayerStateChanged(final SessionPlayer2 player, final int state) {
    final MediaSession2ImplBase session = getSession();
    if (session == null || session.getPlayer() != player || player == null) {
        return;
    }
    session.getCallback().onPlayerStateChanged(session.getInstance(), state);
    updateDurationIfNeeded(player, player.getCurrentMediaItem());
    session.dispatchRemoteControllerNotifyTask(new RemoteControllerNotifyTask() {

        @Override
        public void run(ControllerCb callback) throws RemoteException {
            callback.onPlayerStateChanged(SystemClock.elapsedRealtime(), player.getCurrentPosition(), state);
        }
    });
}
#method_after
@Override
public void onPlayerStateChanged(final SessionPlayer2 player, final int state) {
    final MediaSession2ImplBase session = getSession();
    if (session == null || session.getPlayer() != player || player == null) {
        return;
    }
    session.getCallback().onPlayerStateChanged(session.getInstance(), state);
    updateDurationIfNeeded(player, player.getCurrentMediaItem());
    session.dispatchRemoteControllerCallbackTask(new RemoteControllerCallbackTask() {

        @Override
        public void run(ControllerCb callback) throws RemoteException {
            callback.onPlayerStateChanged(SystemClock.elapsedRealtime(), player.getCurrentPosition(), state);
        }
    });
}
#end_block

#method_before
@Override
public void onBufferingStateChanged(final SessionPlayer2 player, final MediaItem2 item, final int state) {
    updateDurationIfNeeded(player, item);
    notifyToAllControllers(player, new RemoteControllerNotifyTask() {

        @Override
        public void run(ControllerCb callback) throws RemoteException {
            callback.onBufferingStateChanged(item, state, player.getBufferedPosition());
        }
    });
}
#method_after
@Override
public void onBufferingStateChanged(final SessionPlayer2 player, final MediaItem2 item, final int state) {
    updateDurationIfNeeded(player, item);
    dispatchRemoteControllerTask(player, new RemoteControllerCallbackTask() {

        @Override
        public void run(ControllerCb callback) throws RemoteException {
            callback.onBufferingStateChanged(item, state, player.getBufferedPosition());
        }
    });
}
#end_block

#method_before
@Override
public void onPlaybackSpeedChanged(final SessionPlayer2 player, final float speed) {
    notifyToAllControllers(player, new RemoteControllerNotifyTask() {

        @Override
        public void run(ControllerCb callback) throws RemoteException {
            callback.onPlaybackSpeedChanged(SystemClock.elapsedRealtime(), player.getCurrentPosition(), speed);
        }
    });
}
#method_after
@Override
public void onPlaybackSpeedChanged(final SessionPlayer2 player, final float speed) {
    dispatchRemoteControllerTask(player, new RemoteControllerCallbackTask() {

        @Override
        public void run(ControllerCb callback) throws RemoteException {
            callback.onPlaybackSpeedChanged(SystemClock.elapsedRealtime(), player.getCurrentPosition(), speed);
        }
    });
}
#end_block

#method_before
@Override
public void onSeekCompleted(final SessionPlayer2 player, final long position) {
    notifyToAllControllers(player, new RemoteControllerNotifyTask() {

        @Override
        public void run(ControllerCb callback) throws RemoteException {
            callback.onSeekCompleted(SystemClock.elapsedRealtime(), player.getCurrentPosition(), position);
        }
    });
}
#method_after
@Override
public void onSeekCompleted(final SessionPlayer2 player, final long position) {
    dispatchRemoteControllerTask(player, new RemoteControllerCallbackTask() {

        @Override
        public void run(ControllerCb callback) throws RemoteException {
            callback.onSeekCompleted(SystemClock.elapsedRealtime(), player.getCurrentPosition(), position);
        }
    });
}
#end_block

#method_before
@Override
public void onPlaylistChanged(final SessionPlayer2 player, final List<MediaItem2> list, final MediaMetadata2 metadata) {
    notifyToAllControllers(player, new RemoteControllerNotifyTask() {

        @Override
        public void run(ControllerCb callback) throws RemoteException {
            callback.onPlaylistChanged(list, metadata);
        }
    });
}
#method_after
@Override
public void onPlaylistChanged(final SessionPlayer2 player, final List<MediaItem2> list, final MediaMetadata2 metadata) {
    dispatchRemoteControllerTask(player, new RemoteControllerCallbackTask() {

        @Override
        public void run(ControllerCb callback) throws RemoteException {
            callback.onPlaylistChanged(list, metadata);
        }
    });
}
#end_block

#method_before
@Override
public void onPlaylistMetadataChanged(final SessionPlayer2 player, final MediaMetadata2 metadata) {
    notifyToAllControllers(player, new RemoteControllerNotifyTask() {

        @Override
        public void run(ControllerCb callback) throws RemoteException {
            callback.onPlaylistMetadataChanged(metadata);
        }
    });
}
#method_after
@Override
public void onPlaylistMetadataChanged(final SessionPlayer2 player, final MediaMetadata2 metadata) {
    dispatchRemoteControllerTask(player, new RemoteControllerCallbackTask() {

        @Override
        public void run(ControllerCb callback) throws RemoteException {
            callback.onPlaylistMetadataChanged(metadata);
        }
    });
}
#end_block

#method_before
@Override
public void onRepeatModeChanged(final SessionPlayer2 player, final int repeatMode) {
    notifyToAllControllers(player, new RemoteControllerNotifyTask() {

        @Override
        public void run(ControllerCb callback) throws RemoteException {
            callback.onRepeatModeChanged(repeatMode);
        }
    });
}
#method_after
@Override
public void onRepeatModeChanged(final SessionPlayer2 player, final int repeatMode) {
    dispatchRemoteControllerTask(player, new RemoteControllerCallbackTask() {

        @Override
        public void run(ControllerCb callback) throws RemoteException {
            callback.onRepeatModeChanged(repeatMode);
        }
    });
}
#end_block

#method_before
@Override
public void onShuffleModeChanged(final SessionPlayer2 player, final int shuffleMode) {
    notifyToAllControllers(player, new RemoteControllerNotifyTask() {

        @Override
        public void run(ControllerCb callback) throws RemoteException {
            callback.onShuffleModeChanged(shuffleMode);
        }
    });
}
#method_after
@Override
public void onShuffleModeChanged(final SessionPlayer2 player, final int shuffleMode) {
    dispatchRemoteControllerTask(player, new RemoteControllerCallbackTask() {

        @Override
        public void run(ControllerCb callback) throws RemoteException {
            callback.onShuffleModeChanged(shuffleMode);
        }
    });
}
#end_block

#method_before
@Override
public void onPlaybackCompleted(SessionPlayer2 player) {
    notifyToAllControllers(player, new RemoteControllerNotifyTask() {

        @Override
        public void run(ControllerCb callback) throws RemoteException {
            callback.onPlaybackCompleted();
        }
    });
}
#method_after
@Override
public void onPlaybackCompleted(SessionPlayer2 player) {
    dispatchRemoteControllerTask(player, new RemoteControllerCallbackTask() {

        @Override
        public void run(ControllerCb callback) throws RemoteException {
            callback.onPlaybackCompleted();
        }
    });
}
#end_block

#method_before
private void updateDurationIfNeeded(@NonNull final SessionPlayer2 player, @Nullable final MediaItem2 item) {
    if (item == null) {
        return;
    }
    if (!item.equals(player.getCurrentMediaItem())) {
        return;
    }
    final long duration = player.getDuration();
    if (duration <= 0 || duration == UNKNOWN_TIME) {
        return;
    }
    MediaMetadata2 metadata = item.getMetadata();
    if (metadata != null) {
        if (!metadata.containsKey(MediaMetadata2.METADATA_KEY_DURATION)) {
            metadata = new MediaMetadata2.Builder(metadata).putLong(MediaMetadata2.METADATA_KEY_DURATION, duration).build();
        } else {
            long durationFromMetadata = metadata.getLong(MediaMetadata2.METADATA_KEY_DURATION);
            if (duration == durationFromMetadata) {
                return;
            }
            // Warns developers about the mismatch. Don't log media item here to keep
            // metadata secure.
            Log.w(TAG, "duration mismatch for an item." + " duration from player=" + duration + " duration from metadata=" + durationFromMetadata + ". May be a timing issue?");
        // Trust duration in the metadata set by developer.
        // In theory, duration may differ if the current item has been
        // changed before the getDuration(). So it's better not touch
        // duration set by developer.
        }
    } else {
        metadata = new MediaMetadata2.Builder().putLong(MediaMetadata2.METADATA_KEY_DURATION, duration).putString(MediaMetadata2.METADATA_KEY_MEDIA_ID, item.getMediaId()).build();
    }
    if (metadata != null) {
        item.setMetadata(metadata);
        notifyToAllControllers(player, new RemoteControllerNotifyTask() {

            @Override
            public void run(ControllerCb callback) throws RemoteException {
                callback.onPlaylistChanged(player.getPlaylist(), player.getPlaylistMetadata());
            }
        });
    }
}
#method_after
private void updateDurationIfNeeded(@NonNull final SessionPlayer2 player, @Nullable final MediaItem2 item) {
    if (item == null) {
        return;
    }
    if (!item.equals(player.getCurrentMediaItem())) {
        return;
    }
    final long duration = player.getDuration();
    if (duration <= 0 || duration == UNKNOWN_TIME) {
        return;
    }
    MediaMetadata2 metadata = item.getMetadata();
    if (metadata != null) {
        if (!metadata.containsKey(MediaMetadata2.METADATA_KEY_DURATION)) {
            metadata = new MediaMetadata2.Builder(metadata).putLong(MediaMetadata2.METADATA_KEY_DURATION, duration).build();
        } else {
            long durationFromMetadata = metadata.getLong(MediaMetadata2.METADATA_KEY_DURATION);
            if (duration == durationFromMetadata) {
                return;
            }
            // Warns developers about the mismatch. Don't log media item here to keep
            // metadata secure.
            Log.w(TAG, "duration mismatch for an item." + " duration from player=" + duration + " duration from metadata=" + durationFromMetadata + ". May be a timing issue?");
        // Trust duration in the metadata set by developer.
        // In theory, duration may differ if the current item has been
        // changed before the getDuration(). So it's better not touch
        // duration set by developer.
        }
    } else {
        metadata = new MediaMetadata2.Builder().putLong(MediaMetadata2.METADATA_KEY_DURATION, duration).putString(MediaMetadata2.METADATA_KEY_MEDIA_ID, item.getMediaId()).build();
    }
    if (metadata != null) {
        item.setMetadata(metadata);
        dispatchRemoteControllerTask(player, new RemoteControllerCallbackTask() {

            @Override
            public void run(ControllerCb callback) throws RemoteException {
                callback.onPlaylistChanged(player.getPlaylist(), player.getPlaylistMetadata());
            }
        });
    }
}
#end_block

#method_before
void connect(final IMediaController2 caller, final String callingPackage, final int pid, final int uid) {
    MediaSessionManager.RemoteUserInfo remoteUserInfo = new MediaSessionManager.RemoteUserInfo(callingPackage, pid, uid);
    final ControllerInfo controllerInfo = new ControllerInfo(remoteUserInfo, mSessionManager.isTrustedForMediaControl(remoteUserInfo), new Controller2Cb(caller));
    mSessionImpl.getCallbackExecutor().execute(new Runnable() {

        @Override
        public void run() {
            if (mSessionImpl.isClosed()) {
                return;
            }
            final IBinder callbackBinder = ((Controller2Cb) controllerInfo.getControllerCb()).getCallbackBinder();
            synchronized (mLock) {
                // Keep connecting controllers.
                // This helps sessions to call APIs in the onConnect()
                // (e.g. setCustomLayout()) instead of pending them.
                mConnectingControllers.add(callbackBinder);
            }
            SessionCommandGroup2 allowedCommands = mSessionImpl.getCallback().onConnect(mSessionImpl.getInstance(), controllerInfo);
            // Don't reject connection for the request from trusted app.
            // Otherwise server will fail to retrieve session's information to dispatch
            // media keys to.
            boolean accept = allowedCommands != null || controllerInfo.isTrusted();
            if (accept) {
                if (DEBUG) {
                    Log.d(TAG, "Accepting connection, controllerInfo=" + controllerInfo + " allowedCommands=" + allowedCommands);
                }
                if (allowedCommands == null) {
                    // For trusted apps, send non-null allowed commands to keep
                    // connection.
                    allowedCommands = new SessionCommandGroup2();
                }
                synchronized (mLock) {
                    mConnectingControllers.remove(callbackBinder);
                    mConnectedControllersManager.addController(callbackBinder, controllerInfo, allowedCommands);
                }
                // If connection is accepted, notify the current state to the controller.
                // It's needed because we cannot call synchronous calls between
                // session/controller.
                // Note: We're doing this after the onConnectionChanged(), but there's no
                // guarantee that events here are notified after the onConnected()
                // because IMediaController2 is oneway (i.e. async call) and Stub will
                // use thread poll for incoming calls.
                final int playerState = mSessionImpl.getPlayerState();
                final ParcelImpl currentItem = (ParcelImpl) ParcelUtils.toParcelable(mSessionImpl.getCurrentMediaItem());
                final long positionEventTimeMs = SystemClock.elapsedRealtime();
                final long positionMs = mSessionImpl.getCurrentPosition();
                final float playbackSpeed = mSessionImpl.getPlaybackSpeed();
                final long bufferedPositionMs = mSessionImpl.getBufferedPosition();
                final ParcelImpl playbackInfo = (ParcelImpl) ParcelUtils.toParcelable(mSessionImpl.getPlaybackInfo());
                final int repeatMode = mSessionImpl.getRepeatMode();
                final int shuffleMode = mSessionImpl.getShuffleMode();
                final PendingIntent sessionActivity = mSessionImpl.getSessionActivity();
                final List<MediaItem2> playlist = allowedCommands.hasCommand(SessionCommand2.COMMAND_CODE_PLAYER_GET_PLAYLIST) ? mSessionImpl.getPlaylist() : null;
                final List<ParcelImpl> playlistParcel = MediaUtils2.convertMediaItem2ListToParcelImplList(playlist);
                // another thread.
                if (mSessionImpl.isClosed()) {
                    return;
                }
                try {
                    caller.onConnected(MediaSession2Stub.this, (ParcelImpl) ParcelUtils.toParcelable(allowedCommands), playerState, currentItem, positionEventTimeMs, positionMs, playbackSpeed, bufferedPositionMs, playbackInfo, repeatMode, shuffleMode, playlistParcel, sessionActivity);
                } catch (RemoteException e) {
                // Controller may be died prematurely.
                }
            } else {
                synchronized (mLock) {
                    mConnectingControllers.remove(callbackBinder);
                }
                if (DEBUG) {
                    Log.d(TAG, "Rejecting connection, controllerInfo=" + controllerInfo);
                }
                try {
                    caller.onDisconnected();
                } catch (RemoteException e) {
                // Controller may be died prematurely.
                // Not an issue because we'll ignore it anyway.
                }
            }
        }
    });
}
#method_after
void connect(final IMediaController2 caller, final String callingPackage, final int pid, final int uid) {
    MediaSessionManager.RemoteUserInfo remoteUserInfo = new MediaSessionManager.RemoteUserInfo(callingPackage, pid, uid);
    final ControllerInfo controllerInfo = new ControllerInfo(remoteUserInfo, mSessionManager.isTrustedForMediaControl(remoteUserInfo), new Controller2Cb(caller));
    mSessionImpl.getCallbackExecutor().execute(new Runnable() {

        @Override
        public void run() {
            if (mSessionImpl.isClosed()) {
                return;
            }
            final IBinder callbackBinder = ((Controller2Cb) controllerInfo.getControllerCb()).getCallbackBinder();
            synchronized (mLock) {
                // Keep connecting controllers.
                // This helps sessions to call APIs in the onConnect()
                // (e.g. setCustomLayout()) instead of pending them.
                mConnectingControllers.add(callbackBinder);
            }
            SessionCommandGroup2 allowedCommands = mSessionImpl.getCallback().onConnect(mSessionImpl.getInstance(), controllerInfo);
            // Don't reject connection for the request from trusted app.
            // Otherwise server will fail to retrieve session's information to dispatch
            // media keys to.
            boolean accept = allowedCommands != null || controllerInfo.isTrusted();
            if (accept) {
                if (DEBUG) {
                    Log.d(TAG, "Accepting connection, controllerInfo=" + controllerInfo + " allowedCommands=" + allowedCommands);
                }
                if (allowedCommands == null) {
                    // For trusted apps, send non-null allowed commands to keep
                    // connection.
                    allowedCommands = new SessionCommandGroup2();
                }
                synchronized (mLock) {
                    mConnectingControllers.remove(callbackBinder);
                    mConnectedControllersManager.addController(callbackBinder, controllerInfo, allowedCommands);
                }
                // If connection is accepted, notify the current state to the controller.
                // It's needed because we cannot call synchronous calls between
                // session/controller.
                // Note: We're doing this after the onConnectionChanged(), but there's no
                // guarantee that events here are notified after the onConnected()
                // because IMediaController2 is oneway (i.e. async call) and Stub will
                // use thread poll for incoming calls.
                final int playerState = mSessionImpl.getPlayerState();
                final ParcelImpl currentItem = (ParcelImpl) ParcelUtils.toParcelable(mSessionImpl.getCurrentMediaItem());
                final long positionEventTimeMs = SystemClock.elapsedRealtime();
                final long positionMs = mSessionImpl.getCurrentPosition();
                final float playbackSpeed = mSessionImpl.getPlaybackSpeed();
                final long bufferedPositionMs = mSessionImpl.getBufferedPosition();
                final ParcelImpl playbackInfo = (ParcelImpl) ParcelUtils.toParcelable(mSessionImpl.getPlaybackInfo());
                final int repeatMode = mSessionImpl.getRepeatMode();
                final int shuffleMode = mSessionImpl.getShuffleMode();
                final PendingIntent sessionActivity = mSessionImpl.getSessionActivity();
                final List<MediaItem2> playlist = allowedCommands.hasCommand(SessionCommand2.COMMAND_CODE_PLAYER_GET_PLAYLIST) ? mSessionImpl.getPlaylist() : null;
                final ParcelImplListSlice playlistSlice = MediaUtils2.convertMediaItem2ListToParcelImplListSlice(playlist);
                // another thread.
                if (mSessionImpl.isClosed()) {
                    return;
                }
                try {
                    caller.onConnected(MediaSession2Stub.this, (ParcelImpl) ParcelUtils.toParcelable(allowedCommands), playerState, currentItem, positionEventTimeMs, positionMs, playbackSpeed, bufferedPositionMs, playbackInfo, repeatMode, shuffleMode, playlistSlice, sessionActivity);
                } catch (RemoteException e) {
                // Controller may be died prematurely.
                }
            } else {
                synchronized (mLock) {
                    mConnectingControllers.remove(callbackBinder);
                }
                if (DEBUG) {
                    Log.d(TAG, "Rejecting connection, controllerInfo=" + controllerInfo);
                }
                try {
                    caller.onDisconnected();
                } catch (RemoteException e) {
                // Controller may be died prematurely.
                // Not an issue because we'll ignore it anyway.
                }
            }
        }
    });
}
#end_block

#method_before
@Override
public void setVolumeTo(final IMediaController2 caller, int seq, final int value, final int flags) throws RuntimeException {
    onSessionTask(caller, seq, SessionCommand2.COMMAND_CODE_VOLUME_SET_VOLUME, new SessionTask<Integer>() {

        @Override
        public Integer run(ControllerInfo controller) {
            MediaSessionCompat sessionCompat = mSessionImpl.getSessionCompat();
            if (sessionCompat != null) {
                sessionCompat.getController().setVolumeTo(value, flags);
            }
            // TODO: Handle remote player case
            return RESULT_CODE_SUCCESS;
        }
    });
}
#method_after
@Override
public void setVolumeTo(final IMediaController2 caller, int seq, final int value, final int flags) throws RuntimeException {
    dispatchSessionTask(caller, seq, SessionCommand2.COMMAND_CODE_VOLUME_SET_VOLUME, new SessionCallbackTask<Integer>() {

        @Override
        public Integer run(ControllerInfo controller) {
            MediaSessionCompat sessionCompat = mSessionImpl.getSessionCompat();
            if (sessionCompat != null) {
                sessionCompat.getController().setVolumeTo(value, flags);
            }
            // TODO: Handle remote player case
            return RESULT_CODE_SUCCESS;
        }
    });
}
#end_block

#method_before
@Override
public void adjustVolume(IMediaController2 caller, int seq, final int direction, final int flags) throws RuntimeException {
    onSessionTask(caller, seq, SessionCommand2.COMMAND_CODE_VOLUME_ADJUST_VOLUME, new SessionTask<Integer>() {

        @Override
        public Integer run(ControllerInfo controller) {
            MediaSessionCompat sessionCompat = mSessionImpl.getSessionCompat();
            if (sessionCompat != null) {
                sessionCompat.getController().adjustVolume(direction, flags);
            }
            // TODO: Handle remote player case
            return RESULT_CODE_SUCCESS;
        }
    });
}
#method_after
@Override
public void adjustVolume(IMediaController2 caller, int seq, final int direction, final int flags) throws RuntimeException {
    dispatchSessionTask(caller, seq, SessionCommand2.COMMAND_CODE_VOLUME_ADJUST_VOLUME, new SessionCallbackTask<Integer>() {

        @Override
        public Integer run(ControllerInfo controller) {
            MediaSessionCompat sessionCompat = mSessionImpl.getSessionCompat();
            if (sessionCompat != null) {
                sessionCompat.getController().adjustVolume(direction, flags);
            }
            // TODO: Handle remote player case
            return RESULT_CODE_SUCCESS;
        }
    });
}
#end_block

#method_before
@Override
public void play(IMediaController2 caller, int seq) throws RuntimeException {
    onSessionTask(caller, seq, SessionCommand2.COMMAND_CODE_PLAYER_PLAY, new SessionTask<ListenableFuture<PlayerResult>>() {

        @Override
        public ListenableFuture<PlayerResult> run(ControllerInfo controller) {
            return mSessionImpl.play();
        }
    });
}
#method_after
@Override
public void play(IMediaController2 caller, int seq) throws RuntimeException {
    dispatchSessionTask(caller, seq, SessionCommand2.COMMAND_CODE_PLAYER_PLAY, new SessionPlayerTask() {

        @Override
        public ListenableFuture<PlayerResult> run(ControllerInfo controller) {
            return mSessionImpl.play();
        }
    });
}
#end_block

#method_before
@Override
public void pause(IMediaController2 caller, int seq) throws RuntimeException {
    onSessionTask(caller, seq, SessionCommand2.COMMAND_CODE_PLAYER_PAUSE, new SessionTask<ListenableFuture<PlayerResult>>() {

        @Override
        public ListenableFuture<PlayerResult> run(ControllerInfo controller) {
            return mSessionImpl.pause();
        }
    });
}
#method_after
@Override
public void pause(IMediaController2 caller, int seq) throws RuntimeException {
    dispatchSessionTask(caller, seq, SessionCommand2.COMMAND_CODE_PLAYER_PAUSE, new SessionPlayerTask() {

        @Override
        public ListenableFuture<PlayerResult> run(ControllerInfo controller) {
            return mSessionImpl.pause();
        }
    });
}
#end_block

#method_before
@Override
public void prefetch(IMediaController2 caller, int seq) throws RuntimeException {
    onSessionTask(caller, seq, SessionCommand2.COMMAND_CODE_PLAYER_PREFETCH, new SessionTask<ListenableFuture<PlayerResult>>() {

        @Override
        public ListenableFuture<PlayerResult> run(ControllerInfo controller) {
            return mSessionImpl.prefetch();
        }
    });
}
#method_after
@Override
public void prefetch(IMediaController2 caller, int seq) throws RuntimeException {
    dispatchSessionTask(caller, seq, SessionCommand2.COMMAND_CODE_PLAYER_PREFETCH, new SessionPlayerTask() {

        @Override
        public ListenableFuture<PlayerResult> run(ControllerInfo controller) {
            return mSessionImpl.prefetch();
        }
    });
}
#end_block

#method_before
@Override
public void fastForward(IMediaController2 caller, int seq) {
    onSessionTask(caller, seq, SessionCommand2.COMMAND_CODE_SESSION_FAST_FORWARD, new SessionTask<Integer>() {

        @Override
        public Integer run(ControllerInfo controller) {
            return mSessionImpl.getCallback().onFastForward(mSessionImpl.getInstance(), controller);
        }
    });
}
#method_after
@Override
public void fastForward(IMediaController2 caller, int seq) {
    dispatchSessionTask(caller, seq, SessionCommand2.COMMAND_CODE_SESSION_FAST_FORWARD, new SessionCallbackTask<Integer>() {

        @Override
        public Integer run(ControllerInfo controller) {
            return mSessionImpl.getCallback().onFastForward(mSessionImpl.getInstance(), controller);
        }
    });
}
#end_block

#method_before
@Override
public void rewind(IMediaController2 caller, int seq) {
    onSessionTask(caller, seq, SessionCommand2.COMMAND_CODE_SESSION_REWIND, new SessionTask<Integer>() {

        @Override
        public Integer run(ControllerInfo controller) {
            return mSessionImpl.getCallback().onRewind(mSessionImpl.getInstance(), controller);
        }
    });
}
#method_after
@Override
public void rewind(IMediaController2 caller, int seq) {
    dispatchSessionTask(caller, seq, SessionCommand2.COMMAND_CODE_SESSION_REWIND, new SessionCallbackTask<Integer>() {

        @Override
        public Integer run(ControllerInfo controller) {
            return mSessionImpl.getCallback().onRewind(mSessionImpl.getInstance(), controller);
        }
    });
}
#end_block

#method_before
@Override
public void seekTo(IMediaController2 caller, int seq, final long pos) throws RuntimeException {
    onSessionTask(caller, seq, SessionCommand2.COMMAND_CODE_PLAYER_SEEK_TO, new SessionTask<ListenableFuture<PlayerResult>>() {

        @Override
        public ListenableFuture<PlayerResult> run(ControllerInfo controller) {
            return mSessionImpl.seekTo(pos);
        }
    });
}
#method_after
@Override
public void seekTo(IMediaController2 caller, int seq, final long pos) throws RuntimeException {
    dispatchSessionTask(caller, seq, SessionCommand2.COMMAND_CODE_PLAYER_SEEK_TO, new SessionPlayerTask() {

        @Override
        public ListenableFuture<PlayerResult> run(ControllerInfo controller) {
            return mSessionImpl.seekTo(pos);
        }
    });
}
#end_block

#method_before
@Override
public void onCustomCommand(final IMediaController2 caller, final int seq, final ParcelImpl command, final Bundle args) {
    final SessionCommand2 sessionCommand = ParcelUtils.fromParcelable(command);
    onSessionTask(caller, seq, sessionCommand, new SessionTask<SessionResult>() {

        @Override
        public SessionResult run(final ControllerInfo controller) {
            SessionResult result = mSessionImpl.getCallback().onCustomCommand(mSessionImpl.getInstance(), controller, sessionCommand, args);
            if (result == null) {
                if (THROW_EXCEPTION_FOR_NULL_RESULT) {
                    throw new RuntimeException("SessionCallback#onCustomCommand has returned" + " null, command=" + sessionCommand);
                } else {
                    result = new SessionResult(RESULT_CODE_UNKNOWN_ERROR);
                }
            }
            return result;
        }
    });
}
#method_after
@Override
public void onCustomCommand(final IMediaController2 caller, final int seq, final ParcelImpl command, final Bundle args) {
    final SessionCommand2 sessionCommand = ParcelUtils.fromParcelable(command);
    dispatchSessionTask(caller, seq, sessionCommand, new SessionCallbackTask<SessionResult>() {

        @Override
        public SessionResult run(final ControllerInfo controller) {
            SessionResult result = mSessionImpl.getCallback().onCustomCommand(mSessionImpl.getInstance(), controller, sessionCommand, args);
            if (result == null) {
                if (THROW_EXCEPTION_FOR_NULL_RESULT) {
                    throw new RuntimeException("SessionCallback#onCustomCommand has returned" + " null, command=" + sessionCommand);
                } else {
                    result = new SessionResult(RESULT_CODE_UNKNOWN_ERROR);
                }
            }
            return result;
        }
    });
}
#end_block

#method_before
@Override
public void prefetchFromUri(final IMediaController2 caller, int seq, final Uri uri, final Bundle extras) {
    onSessionTask(caller, seq, SessionCommand2.COMMAND_CODE_SESSION_PREFETCH_FROM_URI, new SessionTask<Integer>() {

        @Override
        public Integer run(ControllerInfo controller) {
            if (uri == null) {
                Log.w(TAG, "prefetchFromUri(): Ignoring null uri from " + controller);
                return RESULT_CODE_BAD_VALUE;
            }
            return mSessionImpl.getCallback().onPrefetchFromUri(mSessionImpl.getInstance(), controller, uri, extras);
        }
    });
}
#method_after
@Override
public void prefetchFromUri(final IMediaController2 caller, int seq, final Uri uri, final Bundle extras) {
    dispatchSessionTask(caller, seq, SessionCommand2.COMMAND_CODE_SESSION_PREFETCH_FROM_URI, new SessionCallbackTask<Integer>() {

        @Override
        public Integer run(ControllerInfo controller) {
            if (uri == null) {
                Log.w(TAG, "prefetchFromUri(): Ignoring null uri from " + controller);
                return RESULT_CODE_BAD_VALUE;
            }
            return mSessionImpl.getCallback().onPrefetchFromUri(mSessionImpl.getInstance(), controller, uri, extras);
        }
    });
}
#end_block

#method_before
@Override
public void prefetchFromSearch(final IMediaController2 caller, int seq, final String query, final Bundle extras) {
    onSessionTask(caller, seq, SessionCommand2.COMMAND_CODE_SESSION_PREFETCH_FROM_SEARCH, new SessionTask<Integer>() {

        @Override
        public Integer run(ControllerInfo controller) {
            if (TextUtils.isEmpty(query)) {
                Log.w(TAG, "prefetchFromSearch(): Ignoring empty query from " + controller);
                return RESULT_CODE_BAD_VALUE;
            }
            return mSessionImpl.getCallback().onPrefetchFromSearch(mSessionImpl.getInstance(), controller, query, extras);
        }
    });
}
#method_after
@Override
public void prefetchFromSearch(final IMediaController2 caller, int seq, final String query, final Bundle extras) {
    dispatchSessionTask(caller, seq, SessionCommand2.COMMAND_CODE_SESSION_PREFETCH_FROM_SEARCH, new SessionCallbackTask<Integer>() {

        @Override
        public Integer run(ControllerInfo controller) {
            if (TextUtils.isEmpty(query)) {
                Log.w(TAG, "prefetchFromSearch(): Ignoring empty query from " + controller);
                return RESULT_CODE_BAD_VALUE;
            }
            return mSessionImpl.getCallback().onPrefetchFromSearch(mSessionImpl.getInstance(), controller, query, extras);
        }
    });
}
#end_block

#method_before
@Override
public void prefetchFromMediaId(final IMediaController2 caller, int seq, final String mediaId, final Bundle extras) {
    onSessionTask(caller, seq, SessionCommand2.COMMAND_CODE_SESSION_PREFETCH_FROM_MEDIA_ID, new SessionTask<Integer>() {

        @Override
        public Integer run(ControllerInfo controller) {
            if (mediaId == null) {
                Log.w(TAG, "prefetchFromMediaId(): Ignoring null mediaId from " + controller);
                return RESULT_CODE_BAD_VALUE;
            }
            return mSessionImpl.getCallback().onPrefetchFromMediaId(mSessionImpl.getInstance(), controller, mediaId, extras);
        }
    });
}
#method_after
@Override
public void prefetchFromMediaId(final IMediaController2 caller, int seq, final String mediaId, final Bundle extras) {
    dispatchSessionTask(caller, seq, SessionCommand2.COMMAND_CODE_SESSION_PREFETCH_FROM_MEDIA_ID, new SessionCallbackTask<Integer>() {

        @Override
        public Integer run(ControllerInfo controller) {
            if (mediaId == null) {
                Log.w(TAG, "prefetchFromMediaId(): Ignoring null mediaId from " + controller);
                return RESULT_CODE_BAD_VALUE;
            }
            return mSessionImpl.getCallback().onPrefetchFromMediaId(mSessionImpl.getInstance(), controller, mediaId, extras);
        }
    });
}
#end_block

#method_before
@Override
public void playFromUri(final IMediaController2 caller, int seq, final Uri uri, final Bundle extras) {
    onSessionTask(caller, seq, SessionCommand2.COMMAND_CODE_SESSION_PLAY_FROM_URI, new SessionTask<Integer>() {

        @Override
        public Integer run(ControllerInfo controller) {
            if (uri == null) {
                Log.w(TAG, "playFromUri(): Ignoring null uri from " + controller);
                return RESULT_CODE_BAD_VALUE;
            }
            return mSessionImpl.getCallback().onPlayFromUri(mSessionImpl.getInstance(), controller, uri, extras);
        }
    });
}
#method_after
@Override
public void playFromUri(final IMediaController2 caller, int seq, final Uri uri, final Bundle extras) {
    dispatchSessionTask(caller, seq, SessionCommand2.COMMAND_CODE_SESSION_PLAY_FROM_URI, new SessionCallbackTask<Integer>() {

        @Override
        public Integer run(ControllerInfo controller) {
            if (uri == null) {
                Log.w(TAG, "playFromUri(): Ignoring null uri from " + controller);
                return RESULT_CODE_BAD_VALUE;
            }
            return mSessionImpl.getCallback().onPlayFromUri(mSessionImpl.getInstance(), controller, uri, extras);
        }
    });
}
#end_block

#method_before
@Override
public void playFromSearch(final IMediaController2 caller, int seq, final String query, final Bundle extras) {
    onSessionTask(caller, seq, SessionCommand2.COMMAND_CODE_SESSION_PLAY_FROM_SEARCH, new SessionTask<Integer>() {

        @Override
        public Integer run(ControllerInfo controller) {
            if (TextUtils.isEmpty(query)) {
                Log.w(TAG, "playFromSearch(): Ignoring empty query from " + controller);
                return RESULT_CODE_BAD_VALUE;
            }
            return mSessionImpl.getCallback().onPlayFromSearch(mSessionImpl.getInstance(), controller, query, extras);
        }
    });
}
#method_after
@Override
public void playFromSearch(final IMediaController2 caller, int seq, final String query, final Bundle extras) {
    dispatchSessionTask(caller, seq, SessionCommand2.COMMAND_CODE_SESSION_PLAY_FROM_SEARCH, new SessionCallbackTask<Integer>() {

        @Override
        public Integer run(ControllerInfo controller) {
            if (TextUtils.isEmpty(query)) {
                Log.w(TAG, "playFromSearch(): Ignoring empty query from " + controller);
                return RESULT_CODE_BAD_VALUE;
            }
            return mSessionImpl.getCallback().onPlayFromSearch(mSessionImpl.getInstance(), controller, query, extras);
        }
    });
}
#end_block

#method_before
@Override
public void playFromMediaId(final IMediaController2 caller, int seq, final String mediaId, final Bundle extras) {
    onSessionTask(caller, seq, SessionCommand2.COMMAND_CODE_SESSION_PLAY_FROM_MEDIA_ID, new SessionTask<Integer>() {

        @Override
        public Integer run(ControllerInfo controller) {
            if (mediaId == null) {
                Log.w(TAG, "playFromMediaId(): Ignoring null mediaId from " + controller);
                return RESULT_CODE_BAD_VALUE;
            }
            return mSessionImpl.getCallback().onPlayFromMediaId(mSessionImpl.getInstance(), controller, mediaId, extras);
        }
    });
}
#method_after
@Override
public void playFromMediaId(final IMediaController2 caller, int seq, final String mediaId, final Bundle extras) {
    dispatchSessionTask(caller, seq, SessionCommand2.COMMAND_CODE_SESSION_PLAY_FROM_MEDIA_ID, new SessionCallbackTask<Integer>() {

        @Override
        public Integer run(ControllerInfo controller) {
            if (mediaId == null) {
                Log.w(TAG, "playFromMediaId(): Ignoring null mediaId from " + controller);
                return RESULT_CODE_BAD_VALUE;
            }
            return mSessionImpl.getCallback().onPlayFromMediaId(mSessionImpl.getInstance(), controller, mediaId, extras);
        }
    });
}
#end_block

#method_before
@Override
public void setRating(final IMediaController2 caller, int seq, final String mediaId, final ParcelImpl rating) {
    final Rating2 rating2 = ParcelUtils.fromParcelable(rating);
    onSessionTask(caller, seq, SessionCommand2.COMMAND_CODE_SESSION_SET_RATING, new SessionTask<Integer>() {

        @Override
        public Integer run(ControllerInfo controller) {
            if (mediaId == null) {
                Log.w(TAG, "setRating(): Ignoring null mediaId from " + controller);
                return RESULT_CODE_BAD_VALUE;
            }
            if (rating2 == null) {
                Log.w(TAG, "setRating(): Ignoring null ratingBundle from " + controller);
                return RESULT_CODE_BAD_VALUE;
            }
            return mSessionImpl.getCallback().onSetRating(mSessionImpl.getInstance(), controller, mediaId, rating2);
        }
    });
}
#method_after
@Override
public void setRating(final IMediaController2 caller, int seq, final String mediaId, final ParcelImpl rating) {
    final Rating2 rating2 = ParcelUtils.fromParcelable(rating);
    dispatchSessionTask(caller, seq, SessionCommand2.COMMAND_CODE_SESSION_SET_RATING, new SessionCallbackTask<Integer>() {

        @Override
        public Integer run(ControllerInfo controller) {
            if (mediaId == null) {
                Log.w(TAG, "setRating(): Ignoring null mediaId from " + controller);
                return RESULT_CODE_BAD_VALUE;
            }
            if (rating2 == null) {
                Log.w(TAG, "setRating(): Ignoring null ratingBundle from " + controller);
                return RESULT_CODE_BAD_VALUE;
            }
            return mSessionImpl.getCallback().onSetRating(mSessionImpl.getInstance(), controller, mediaId, rating2);
        }
    });
}
#end_block

#method_before
@Override
public void setPlaybackSpeed(final IMediaController2 caller, int seq, final float speed) {
    onSessionTask(caller, seq, SessionCommand2.COMMAND_CODE_PLAYER_SET_SPEED, new SessionTask<ListenableFuture<PlayerResult>>() {

        @Override
        public ListenableFuture<PlayerResult> run(ControllerInfo controller) {
            return mSessionImpl.setPlaybackSpeed(speed);
        }
    });
}
#method_after
@Override
public void setPlaybackSpeed(final IMediaController2 caller, int seq, final float speed) {
    dispatchSessionTask(caller, seq, SessionCommand2.COMMAND_CODE_PLAYER_SET_SPEED, new SessionPlayerTask() {

        @Override
        public ListenableFuture<PlayerResult> run(ControllerInfo controller) {
            return mSessionImpl.setPlaybackSpeed(speed);
        }
    });
}
#end_block

#method_before
@Override
public void setPlaylist(final IMediaController2 caller, int seq, final ParcelImplListSlice listSlice, final Bundle metadata) {
    onSessionTask(caller, seq, SessionCommand2.COMMAND_CODE_PLAYER_SET_PLAYLIST, new SessionTask<ListenableFuture<PlayerResult>>() {

        @Override
        public ListenableFuture<PlayerResult> run(ControllerInfo controller) {
            if (listSlice == null || listSlice.getList() == null) {
                Log.w(TAG, "setPlaylist(): Ignoring null playlist from " + controller);
                return PlayerResult.createFuture(RESULT_CODE_BAD_VALUE);
            }
            List<ParcelImpl> playlist = listSlice.getList();
            List<MediaItem2> list = new ArrayList<>();
            for (int i = 0; i < playlist.size(); i++) {
                MediaItem2 item = convertMediaItem2OnExecutor(controller, playlist.get(i));
                if (item != null) {
                    list.add(item);
                }
            }
            return mSessionImpl.setPlaylist(list, MediaMetadata2.fromBundle(metadata));
        }
    });
}
#method_after
@Override
public void setPlaylist(final IMediaController2 caller, int seq, final ParcelImplListSlice listSlice, final Bundle metadata) {
    dispatchSessionTask(caller, seq, SessionCommand2.COMMAND_CODE_PLAYER_SET_PLAYLIST, new SessionPlayerTask() {

        @Override
        public ListenableFuture<PlayerResult> run(ControllerInfo controller) {
            if (listSlice == null) {
                Log.w(TAG, "setPlaylist(): Ignoring null playlist from " + controller);
                return PlayerResult.createFuture(RESULT_CODE_BAD_VALUE);
            }
            List<ParcelImpl> playlist = listSlice.getList();
            List<MediaItem2> list = new ArrayList<>();
            for (int i = 0; i < playlist.size(); i++) {
                MediaItem2 item = convertMediaItem2OnExecutor(controller, playlist.get(i));
                if (item != null) {
                    list.add(item);
                }
            }
            return mSessionImpl.setPlaylist(list, MediaMetadata2.fromBundle(metadata));
        }
    });
}
#end_block

#method_before
@Override
public void setMediaItem(final IMediaController2 caller, int seq, final ParcelImpl mediaItem) {
    onSessionTask(caller, seq, SessionCommand2.COMMAND_CODE_PLAYER_SET_MEDIA_ITEM, new SessionTask<ListenableFuture<PlayerResult>>() {

        @Override
        public ListenableFuture<PlayerResult> run(ControllerInfo controller) {
            if (mediaItem == null) {
                Log.w(TAG, "setMediaItem(): Ignoring null item from " + controller);
                return PlayerResult.createFuture(RESULT_CODE_BAD_VALUE);
            }
            MediaItem2 item = convertMediaItem2OnExecutor(controller, mediaItem);
            if (item == null) {
                return PlayerResult.createFuture(RESULT_CODE_BAD_VALUE);
            }
            return mSessionImpl.setMediaItem(item);
        }
    });
}
#method_after
@Override
public void setMediaItem(final IMediaController2 caller, int seq, final ParcelImpl mediaItem) {
    dispatchSessionTask(caller, seq, SessionCommand2.COMMAND_CODE_PLAYER_SET_MEDIA_ITEM, new SessionPlayerTask() {

        @Override
        public ListenableFuture<PlayerResult> run(ControllerInfo controller) {
            if (mediaItem == null) {
                Log.w(TAG, "setMediaItem(): Ignoring null item from " + controller);
                return PlayerResult.createFuture(RESULT_CODE_BAD_VALUE);
            }
            MediaItem2 item = convertMediaItem2OnExecutor(controller, mediaItem);
            if (item == null) {
                return PlayerResult.createFuture(RESULT_CODE_BAD_VALUE);
            }
            return mSessionImpl.setMediaItem(item);
        }
    });
}
#end_block

#method_before
@Override
public void updatePlaylistMetadata(final IMediaController2 caller, int seq, final Bundle metadata) {
    onSessionTask(caller, seq, SessionCommand2.COMMAND_CODE_PLAYER_UPDATE_LIST_METADATA, new SessionTask<ListenableFuture<PlayerResult>>() {

        @Override
        public ListenableFuture<PlayerResult> run(ControllerInfo controller) {
            return mSessionImpl.updatePlaylistMetadata(MediaMetadata2.fromBundle(metadata));
        }
    });
}
#method_after
@Override
public void updatePlaylistMetadata(final IMediaController2 caller, int seq, final Bundle metadata) {
    dispatchSessionTask(caller, seq, SessionCommand2.COMMAND_CODE_PLAYER_UPDATE_LIST_METADATA, new SessionPlayerTask() {

        @Override
        public ListenableFuture<PlayerResult> run(ControllerInfo controller) {
            return mSessionImpl.updatePlaylistMetadata(MediaMetadata2.fromBundle(metadata));
        }
    });
}
#end_block

#method_before
@Override
public void addPlaylistItem(IMediaController2 caller, int seq, final int index, final ParcelImpl mediaItem) {
    onSessionTask(caller, seq, SessionCommand2.COMMAND_CODE_PLAYER_ADD_PLAYLIST_ITEM, new SessionTask<ListenableFuture<PlayerResult>>() {

        @Override
        public ListenableFuture<PlayerResult> run(ControllerInfo controller) {
            if (mediaItem == null) {
                Log.w(TAG, "addPlaylistItem(): Ignoring null item from " + controller);
                return PlayerResult.createFuture(RESULT_CODE_BAD_VALUE);
            }
            MediaItem2 item = convertMediaItem2OnExecutor(controller, mediaItem);
            if (item == null) {
                return PlayerResult.createFuture(RESULT_CODE_BAD_VALUE);
            }
            return mSessionImpl.addPlaylistItem(index, item);
        }
    });
}
#method_after
@Override
public void addPlaylistItem(IMediaController2 caller, int seq, final int index, final ParcelImpl mediaItem) {
    dispatchSessionTask(caller, seq, SessionCommand2.COMMAND_CODE_PLAYER_ADD_PLAYLIST_ITEM, new SessionPlayerTask() {

        @Override
        public ListenableFuture<PlayerResult> run(ControllerInfo controller) {
            if (mediaItem == null) {
                Log.w(TAG, "addPlaylistItem(): Ignoring null item from " + controller);
                return PlayerResult.createFuture(RESULT_CODE_BAD_VALUE);
            }
            MediaItem2 item = convertMediaItem2OnExecutor(controller, mediaItem);
            if (item == null) {
                return PlayerResult.createFuture(RESULT_CODE_BAD_VALUE);
            }
            return mSessionImpl.addPlaylistItem(index, item);
        }
    });
}
#end_block

#method_before
@Override
public void removePlaylistItem(IMediaController2 caller, int seq, final ParcelImpl mediaItem) {
    onSessionTask(caller, seq, SessionCommand2.COMMAND_CODE_PLAYER_REMOVE_PLAYLIST_ITEM, new SessionTask<ListenableFuture<PlayerResult>>() {

        @Override
        public ListenableFuture<PlayerResult> run(ControllerInfo controller) {
            MediaItem2 item = ParcelUtils.fromParcelable(mediaItem);
            // Note: MediaItem2 has hidden UUID to identify it across the processes.
            return mSessionImpl.removePlaylistItem(item);
        }
    });
}
#method_after
@Override
public void removePlaylistItem(IMediaController2 caller, int seq, final ParcelImpl mediaItem) {
    dispatchSessionTask(caller, seq, SessionCommand2.COMMAND_CODE_PLAYER_REMOVE_PLAYLIST_ITEM, new SessionPlayerTask() {

        @Override
        public ListenableFuture<PlayerResult> run(ControllerInfo controller) {
            MediaItem2 item = ParcelUtils.fromParcelable(mediaItem);
            // Note: MediaItem2 has hidden UUID to identify it across the processes.
            return mSessionImpl.removePlaylistItem(item);
        }
    });
}
#end_block

#method_before
@Override
public void replacePlaylistItem(IMediaController2 caller, int seq, final int index, final ParcelImpl mediaItem) {
    onSessionTask(caller, seq, SessionCommand2.COMMAND_CODE_PLAYER_REPLACE_PLAYLIST_ITEM, new SessionTask<ListenableFuture<PlayerResult>>() {

        @Override
        public ListenableFuture<PlayerResult> run(ControllerInfo controller) {
            if (mediaItem == null) {
                Log.w(TAG, "replacePlaylistItem(): Ignoring null item from " + controller);
                return PlayerResult.createFuture(RESULT_CODE_BAD_VALUE);
            }
            MediaItem2 item = convertMediaItem2OnExecutor(controller, mediaItem);
            if (item == null) {
                return PlayerResult.createFuture(RESULT_CODE_BAD_VALUE);
            }
            return mSessionImpl.replacePlaylistItem(index, item);
        }
    });
}
#method_after
@Override
public void replacePlaylistItem(IMediaController2 caller, int seq, final int index, final ParcelImpl mediaItem) {
    dispatchSessionTask(caller, seq, SessionCommand2.COMMAND_CODE_PLAYER_REPLACE_PLAYLIST_ITEM, new SessionPlayerTask() {

        @Override
        public ListenableFuture<PlayerResult> run(ControllerInfo controller) {
            if (mediaItem == null) {
                Log.w(TAG, "replacePlaylistItem(): Ignoring null item from " + controller);
                return PlayerResult.createFuture(RESULT_CODE_BAD_VALUE);
            }
            MediaItem2 item = convertMediaItem2OnExecutor(controller, mediaItem);
            if (item == null) {
                return PlayerResult.createFuture(RESULT_CODE_BAD_VALUE);
            }
            return mSessionImpl.replacePlaylistItem(index, item);
        }
    });
}
#end_block

#method_before
@Override
public void skipToPlaylistItem(IMediaController2 caller, int seq, final ParcelImpl mediaItem) {
    onSessionTask(caller, seq, SessionCommand2.COMMAND_CODE_PLAYER_SKIP_TO_PLAYLIST_ITEM, new SessionTask<ListenableFuture<PlayerResult>>() {

        @Override
        public ListenableFuture<PlayerResult> run(ControllerInfo controller) {
            if (mediaItem == null) {
                Log.w(TAG, "skipToPlaylistItem(): Ignoring null mediaItem from " + controller);
                return PlayerResult.createFuture(RESULT_CODE_BAD_VALUE);
            }
            // Note: MediaItem2 has hidden UUID to identify it across the processes.
            return mSessionImpl.skipToPlaylistItem((MediaItem2) ParcelUtils.fromParcelable(mediaItem));
        }
    });
}
#method_after
@Override
public void skipToPlaylistItem(IMediaController2 caller, int seq, final ParcelImpl mediaItem) {
    dispatchSessionTask(caller, seq, SessionCommand2.COMMAND_CODE_PLAYER_SKIP_TO_PLAYLIST_ITEM, new SessionPlayerTask() {

        @Override
        public ListenableFuture<PlayerResult> run(ControllerInfo controller) {
            if (mediaItem == null) {
                Log.w(TAG, "skipToPlaylistItem(): Ignoring null mediaItem from " + controller);
                return PlayerResult.createFuture(RESULT_CODE_BAD_VALUE);
            }
            // Note: MediaItem2 has hidden UUID to identify it across the processes.
            return mSessionImpl.skipToPlaylistItem((MediaItem2) ParcelUtils.fromParcelable(mediaItem));
        }
    });
}
#end_block

#method_before
@Override
public void skipToPreviousItem(IMediaController2 caller, int seq) {
    onSessionTask(caller, seq, SessionCommand2.COMMAND_CODE_PLAYER_SKIP_TO_PREVIOUS_PLAYLIST_ITEM, new SessionTask<ListenableFuture<PlayerResult>>() {

        @Override
        public ListenableFuture<PlayerResult> run(ControllerInfo controller) {
            return mSessionImpl.skipToPreviousItem();
        }
    });
}
#method_after
@Override
public void skipToPreviousItem(IMediaController2 caller, int seq) {
    dispatchSessionTask(caller, seq, SessionCommand2.COMMAND_CODE_PLAYER_SKIP_TO_PREVIOUS_PLAYLIST_ITEM, new SessionPlayerTask() {

        @Override
        public ListenableFuture<PlayerResult> run(ControllerInfo controller) {
            return mSessionImpl.skipToPreviousItem();
        }
    });
}
#end_block

#method_before
@Override
public void skipToNextItem(IMediaController2 caller, int seq) {
    onSessionTask(caller, seq, SessionCommand2.COMMAND_CODE_PLAYER_SKIP_TO_NEXT_PLAYLIST_ITEM, new SessionTask<ListenableFuture<PlayerResult>>() {

        @Override
        public ListenableFuture<PlayerResult> run(ControllerInfo controller) {
            return mSessionImpl.skipToNextItem();
        }
    });
}
#method_after
@Override
public void skipToNextItem(IMediaController2 caller, int seq) {
    dispatchSessionTask(caller, seq, SessionCommand2.COMMAND_CODE_PLAYER_SKIP_TO_NEXT_PLAYLIST_ITEM, new SessionPlayerTask() {

        @Override
        public ListenableFuture<PlayerResult> run(ControllerInfo controller) {
            return mSessionImpl.skipToNextItem();
        }
    });
}
#end_block

#method_before
@Override
public void setRepeatMode(IMediaController2 caller, int seq, final int repeatMode) {
    onSessionTask(caller, seq, SessionCommand2.COMMAND_CODE_PLAYER_SET_REPEAT_MODE, new SessionTask<ListenableFuture<PlayerResult>>() {

        @Override
        public ListenableFuture<PlayerResult> run(ControllerInfo controller) {
            return mSessionImpl.setRepeatMode(repeatMode);
        }
    });
}
#method_after
@Override
public void setRepeatMode(IMediaController2 caller, int seq, final int repeatMode) {
    dispatchSessionTask(caller, seq, SessionCommand2.COMMAND_CODE_PLAYER_SET_REPEAT_MODE, new SessionPlayerTask() {

        @Override
        public ListenableFuture<PlayerResult> run(ControllerInfo controller) {
            return mSessionImpl.setRepeatMode(repeatMode);
        }
    });
}
#end_block

#method_before
@Override
public void setShuffleMode(IMediaController2 caller, int seq, final int shuffleMode) {
    onSessionTask(caller, seq, SessionCommand2.COMMAND_CODE_PLAYER_SET_SHUFFLE_MODE, new SessionTask<ListenableFuture<PlayerResult>>() {

        @Override
        public ListenableFuture<PlayerResult> run(ControllerInfo controller) {
            return mSessionImpl.setShuffleMode(shuffleMode);
        }
    });
}
#method_after
@Override
public void setShuffleMode(IMediaController2 caller, int seq, final int shuffleMode) {
    dispatchSessionTask(caller, seq, SessionCommand2.COMMAND_CODE_PLAYER_SET_SHUFFLE_MODE, new SessionPlayerTask() {

        @Override
        public ListenableFuture<PlayerResult> run(ControllerInfo controller) {
            return mSessionImpl.setShuffleMode(shuffleMode);
        }
    });
}
#end_block

#method_before
@Override
public void subscribeRoutesInfo(IMediaController2 caller, int seq) {
    onSessionTask(caller, seq, SessionCommand2.COMMAND_CODE_SESSION_SUBSCRIBE_ROUTES_INFO, new SessionTask<Integer>() {

        @Override
        public Integer run(ControllerInfo controller) {
            return mSessionImpl.getCallback().onSubscribeRoutesInfo(mSessionImpl.getInstance(), controller);
        }
    });
}
#method_after
@Override
public void subscribeRoutesInfo(IMediaController2 caller, int seq) {
    dispatchSessionTask(caller, seq, SessionCommand2.COMMAND_CODE_SESSION_SUBSCRIBE_ROUTES_INFO, new SessionCallbackTask<Integer>() {

        @Override
        public Integer run(ControllerInfo controller) {
            return mSessionImpl.getCallback().onSubscribeRoutesInfo(mSessionImpl.getInstance(), controller);
        }
    });
}
#end_block

#method_before
@Override
public void unsubscribeRoutesInfo(IMediaController2 caller, int seq) {
    onSessionTask(caller, seq, SessionCommand2.COMMAND_CODE_SESSION_UNSUBSCRIBE_ROUTES_INFO, new SessionTask<Integer>() {

        @Override
        public Integer run(ControllerInfo controller) {
            return mSessionImpl.getCallback().onUnsubscribeRoutesInfo(mSessionImpl.getInstance(), controller);
        }
    });
}
#method_after
@Override
public void unsubscribeRoutesInfo(IMediaController2 caller, int seq) {
    dispatchSessionTask(caller, seq, SessionCommand2.COMMAND_CODE_SESSION_UNSUBSCRIBE_ROUTES_INFO, new SessionCallbackTask<Integer>() {

        @Override
        public Integer run(ControllerInfo controller) {
            return mSessionImpl.getCallback().onUnsubscribeRoutesInfo(mSessionImpl.getInstance(), controller);
        }
    });
}
#end_block

#method_before
@Override
public void selectRoute(IMediaController2 caller, int seq, final Bundle route) {
    if (MediaUtils2.isUnparcelableBundle(route)) {
        throw new RuntimeException("Unexpected route bundle: " + route);
    }
    onSessionTask(caller, seq, SessionCommand2.COMMAND_CODE_SESSION_UNSUBSCRIBE_ROUTES_INFO, new SessionTask<Integer>() {

        @Override
        public Integer run(ControllerInfo controller) {
            return mSessionImpl.getCallback().onSelectRoute(mSessionImpl.getInstance(), controller, route);
        }
    });
}
#method_after
@Override
public void selectRoute(IMediaController2 caller, int seq, final Bundle route) {
    if (MediaUtils2.isUnparcelableBundle(route)) {
        throw new RuntimeException("Unexpected route bundle: " + route);
    }
    dispatchSessionTask(caller, seq, SessionCommand2.COMMAND_CODE_SESSION_UNSUBSCRIBE_ROUTES_INFO, new SessionCallbackTask<Integer>() {

        @Override
        public Integer run(ControllerInfo controller) {
            return mSessionImpl.getCallback().onSelectRoute(mSessionImpl.getInstance(), controller, route);
        }
    });
}
#end_block

#method_before
@Override
public void getLibraryRoot(final IMediaController2 caller, final Bundle rootHints) throws RuntimeException {
    onLibrarySessionTask(caller, SessionCommand2.COMMAND_CODE_LIBRARY_GET_LIBRARY_ROOT, new SessionTask<Boolean>() {

        @Override
        public Boolean run(ControllerInfo controller) {
            getLibrarySession().onGetLibraryRootOnExecutor(controller, rootHints);
            return true;
        }
    });
}
#method_after
@Override
public void getLibraryRoot(final IMediaController2 caller, final Bundle rootHints) throws RuntimeException {
    dispatchLibrarySessionTask(caller, SessionCommand2.COMMAND_CODE_LIBRARY_GET_LIBRARY_ROOT, new SessionCallbackTask<Boolean>() {

        @Override
        public Boolean run(ControllerInfo controller) {
            getLibrarySession().onGetLibraryRootOnExecutor(controller, rootHints);
            return true;
        }
    });
}
#end_block

#method_before
@Override
public void getItem(final IMediaController2 caller, final String mediaId) throws RuntimeException {
    onLibrarySessionTask(caller, SessionCommand2.COMMAND_CODE_LIBRARY_GET_ITEM, new SessionTask<Boolean>() {

        @Override
        public Boolean run(ControllerInfo controller) {
            if (mediaId == null) {
                Log.w(TAG, "getItem(): Ignoring null mediaId from " + controller);
                return false;
            }
            getLibrarySession().onGetItemOnExecutor(controller, mediaId);
            return true;
        }
    });
}
#method_after
@Override
public void getItem(final IMediaController2 caller, final String mediaId) throws RuntimeException {
    dispatchLibrarySessionTask(caller, SessionCommand2.COMMAND_CODE_LIBRARY_GET_ITEM, new SessionCallbackTask<Boolean>() {

        @Override
        public Boolean run(ControllerInfo controller) {
            if (mediaId == null) {
                Log.w(TAG, "getItem(): Ignoring null mediaId from " + controller);
                return false;
            }
            getLibrarySession().onGetItemOnExecutor(controller, mediaId);
            return true;
        }
    });
}
#end_block

#method_before
@Override
public void getChildren(final IMediaController2 caller, final String parentId, final int page, final int pageSize, final Bundle extras) throws RuntimeException {
    onLibrarySessionTask(caller, SessionCommand2.COMMAND_CODE_LIBRARY_GET_CHILDREN, new SessionTask<Boolean>() {

        @Override
        public Boolean run(ControllerInfo controller) {
            if (parentId == null) {
                Log.w(TAG, "getChildren(): Ignoring null parentId from " + controller);
                return false;
            }
            if (page < 0) {
                Log.w(TAG, "getChildren(): Ignoring negative page from " + controller);
                return false;
            }
            if (pageSize < 1) {
                Log.w(TAG, "getChildren(): Ignoring pageSize less than 1 from " + controller);
                return false;
            }
            getLibrarySession().onGetChildrenOnExecutor(controller, parentId, page, pageSize, extras);
            return true;
        }
    });
}
#method_after
@Override
public void getChildren(final IMediaController2 caller, final String parentId, final int page, final int pageSize, final Bundle extras) throws RuntimeException {
    dispatchLibrarySessionTask(caller, SessionCommand2.COMMAND_CODE_LIBRARY_GET_CHILDREN, new SessionCallbackTask<Boolean>() {

        @Override
        public Boolean run(ControllerInfo controller) {
            if (parentId == null) {
                Log.w(TAG, "getChildren(): Ignoring null parentId from " + controller);
                return false;
            }
            if (page < 0) {
                Log.w(TAG, "getChildren(): Ignoring negative page from " + controller);
                return false;
            }
            if (pageSize < 1) {
                Log.w(TAG, "getChildren(): Ignoring pageSize less than 1 from " + controller);
                return false;
            }
            getLibrarySession().onGetChildrenOnExecutor(controller, parentId, page, pageSize, extras);
            return true;
        }
    });
}
#end_block

#method_before
@Override
public void search(IMediaController2 caller, final String query, final Bundle extras) {
    onLibrarySessionTask(caller, SessionCommand2.COMMAND_CODE_LIBRARY_SEARCH, new SessionTask<Boolean>() {

        @Override
        public Boolean run(ControllerInfo controller) {
            if (TextUtils.isEmpty(query)) {
                Log.w(TAG, "search(): Ignoring empty query from " + controller);
                return false;
            }
            getLibrarySession().onSearchOnExecutor(controller, query, extras);
            return true;
        }
    });
}
#method_after
@Override
public void search(IMediaController2 caller, final String query, final Bundle extras) {
    dispatchLibrarySessionTask(caller, SessionCommand2.COMMAND_CODE_LIBRARY_SEARCH, new SessionCallbackTask<Boolean>() {

        @Override
        public Boolean run(ControllerInfo controller) {
            if (TextUtils.isEmpty(query)) {
                Log.w(TAG, "search(): Ignoring empty query from " + controller);
                return false;
            }
            getLibrarySession().onSearchOnExecutor(controller, query, extras);
            return true;
        }
    });
}
#end_block

#method_before
@Override
public void getSearchResult(final IMediaController2 caller, final String query, final int page, final int pageSize, final Bundle extras) {
    onLibrarySessionTask(caller, SessionCommand2.COMMAND_CODE_LIBRARY_GET_SEARCH_RESULT, new SessionTask<Boolean>() {

        @Override
        public Boolean run(ControllerInfo controller) {
            if (TextUtils.isEmpty(query)) {
                Log.w(TAG, "getSearchResult(): Ignoring empty query from " + controller);
                return false;
            }
            if (page < 0) {
                Log.w(TAG, "getSearchResult(): Ignoring negative page from " + controller);
                return false;
            }
            if (pageSize < 1) {
                Log.w(TAG, "getSearchResult(): Ignoring pageSize less than 1 from " + controller);
                return false;
            }
            getLibrarySession().onGetSearchResultOnExecutor(controller, query, page, pageSize, extras);
            return true;
        }
    });
}
#method_after
@Override
public void getSearchResult(final IMediaController2 caller, final String query, final int page, final int pageSize, final Bundle extras) {
    dispatchLibrarySessionTask(caller, SessionCommand2.COMMAND_CODE_LIBRARY_GET_SEARCH_RESULT, new SessionCallbackTask<Boolean>() {

        @Override
        public Boolean run(ControllerInfo controller) {
            if (TextUtils.isEmpty(query)) {
                Log.w(TAG, "getSearchResult(): Ignoring empty query from " + controller);
                return false;
            }
            if (page < 0) {
                Log.w(TAG, "getSearchResult(): Ignoring negative page from " + controller);
                return false;
            }
            if (pageSize < 1) {
                Log.w(TAG, "getSearchResult(): Ignoring pageSize less than 1 from " + controller);
                return false;
            }
            getLibrarySession().onGetSearchResultOnExecutor(controller, query, page, pageSize, extras);
            return true;
        }
    });
}
#end_block

#method_before
@Override
public void subscribe(final IMediaController2 caller, final String parentId, final Bundle option) {
    onLibrarySessionTask(caller, SessionCommand2.COMMAND_CODE_LIBRARY_SUBSCRIBE, new SessionTask<Boolean>() {

        @Override
        public Boolean run(ControllerInfo controller) {
            if (parentId == null) {
                Log.w(TAG, "subscribe(): Ignoring null parentId from " + controller);
                return false;
            }
            getLibrarySession().onSubscribeOnExecutor(controller, parentId, option);
            return true;
        }
    });
}
#method_after
@Override
public void subscribe(final IMediaController2 caller, final String parentId, final Bundle option) {
    dispatchLibrarySessionTask(caller, SessionCommand2.COMMAND_CODE_LIBRARY_SUBSCRIBE, new SessionCallbackTask<Boolean>() {

        @Override
        public Boolean run(ControllerInfo controller) {
            if (parentId == null) {
                Log.w(TAG, "subscribe(): Ignoring null parentId from " + controller);
                return false;
            }
            getLibrarySession().onSubscribeOnExecutor(controller, parentId, option);
            return true;
        }
    });
}
#end_block

#method_before
@Override
public void unsubscribe(final IMediaController2 caller, final String parentId) {
    onLibrarySessionTask(caller, SessionCommand2.COMMAND_CODE_LIBRARY_UNSUBSCRIBE, new SessionTask<Boolean>() {

        @Override
        public Boolean run(ControllerInfo controller) {
            if (parentId == null) {
                Log.w(TAG, "unsubscribe(): Ignoring null parentId from " + controller);
                return false;
            }
            getLibrarySession().onUnsubscribeOnExecutor(controller, parentId);
            return true;
        }
    });
}
#method_after
@Override
public void unsubscribe(final IMediaController2 caller, final String parentId) {
    dispatchLibrarySessionTask(caller, SessionCommand2.COMMAND_CODE_LIBRARY_UNSUBSCRIBE, new SessionCallbackTask<Boolean>() {

        @Override
        public Boolean run(ControllerInfo controller) {
            if (parentId == null) {
                Log.w(TAG, "unsubscribe(): Ignoring null parentId from " + controller);
                return false;
            }
            getLibrarySession().onUnsubscribeOnExecutor(controller, parentId);
            return true;
        }
    });
}
#end_block

#method_before
@Override
void onPlaylistChanged(List<MediaItem2> playlist, MediaMetadata2 metadata) throws RemoteException {
    ControllerInfo controller = mConnectedControllersManager.getController(getCallbackBinder());
    if (mConnectedControllersManager.isAllowedCommand(controller, SessionCommand2.COMMAND_CODE_PLAYER_GET_PLAYLIST)) {
        mIControllerCallback.onPlaylistChanged(MediaUtils2.convertMediaItem2ListToParcelImplList(playlist), metadata == null ? null : metadata.toBundle());
    } else if (mConnectedControllersManager.isAllowedCommand(controller, SessionCommand2.COMMAND_CODE_PLAYER_GET_PLAYLIST_METADATA)) {
        mIControllerCallback.onPlaylistMetadataChanged(metadata.toBundle());
    }
}
#method_after
@Override
void onPlaylistChanged(List<MediaItem2> playlist, MediaMetadata2 metadata) throws RemoteException {
    ControllerInfo controller = mConnectedControllersManager.getController(getCallbackBinder());
    if (mConnectedControllersManager.isAllowedCommand(controller, SessionCommand2.COMMAND_CODE_PLAYER_GET_PLAYLIST)) {
        mIControllerCallback.onPlaylistChanged(MediaUtils2.convertMediaItem2ListToParcelImplListSlice(playlist), metadata == null ? null : metadata.toBundle());
    } else if (mConnectedControllersManager.isAllowedCommand(controller, SessionCommand2.COMMAND_CODE_PLAYER_GET_PLAYLIST_METADATA)) {
        mIControllerCallback.onPlaylistMetadataChanged(metadata.toBundle());
    }
}
#end_block

#method_before
@Override
void onGetChildrenDone(String parentId, int page, int pageSize, List<MediaItem2> result, Bundle extras) throws RemoteException {
    List<ParcelImpl> parcelList = MediaUtils2.convertMediaItem2ListToParcelImplList(result);
    mIControllerCallback.onGetChildrenDone(parentId, page, pageSize, parcelList, extras);
}
#method_after
@Override
void onGetChildrenDone(String parentId, int page, int pageSize, List<MediaItem2> result, Bundle extras) throws RemoteException {
    ParcelImplListSlice listSlice = MediaUtils2.convertMediaItem2ListToParcelImplListSlice(result);
    mIControllerCallback.onGetChildrenDone(parentId, page, pageSize, listSlice, extras);
}
#end_block

#method_before
@Override
protected int getHelpResource() {
    return R.string.help_url_icc_lock;
}
#method_after
@Override
public int getHelpResource() {
    return R.string.help_url_icc_lock;
}
#end_block

#method_before
private void iccLockChanged(boolean success, int attemptsRemaining) {
    if (DBG)
        Log.d(TAG, "iccLockChanged success: " + success);
    if (success) {
        mPinToggle.setChecked(mToState);
    } else {
        setRemainingAttempts(true, attemptsRemaining);
        createCustomTextToast(getPinPasswordErrorMessage(attemptsRemaining)).show();
    }
    mPinToggle.setEnabled(true);
    resetDialogState();
}
#method_after
private void iccLockChanged(boolean success, int attemptsRemaining, Throwable exception) {
    if (success) {
        mPinToggle.setChecked(mToState);
    } else {
        if (exception instanceof CommandException) {
            CommandException.Error err = ((CommandException) (exception)).getCommandError();
            if (err == CommandException.Error.PASSWORD_INCORRECT) {
                createCustomTextToast(getPinPasswordErrorMessage(attemptsRemaining));
            } else {
                if (mToState) {
                    Toast.makeText(getContext(), mRes.getString(R.string.sim_pin_enable_failed), Toast.LENGTH_LONG).show();
                } else {
                    Toast.makeText(getContext(), mRes.getString(R.string.sim_pin_disable_failed), Toast.LENGTH_LONG).show();
                }
            }
        }
    }
    mPinToggle.setEnabled(true);
    resetDialogState();
}
#end_block

#method_before
private Toast createCustomTextToast(String errorMessage) {
    Toast toast = Toast.makeText(getActivity().getApplicationContext(), errorMessage, Toast.LENGTH_LONG);
    toast.getWindowParams().type = WindowManager.LayoutParams.TYPE_STATUS_BAR_PANEL;
    return toast;
}
#method_after
private void createCustomTextToast(CharSequence errorMessage) {
    // Cannot overlay Toast on PUK unlock screen.
    // The window type of Toast is set by NotificationManagerService.
    // It can't be overwritten by LayoutParams.type.
    // Ovarlay a custom window with LayoutParams (TYPE_STATUS_BAR_PANEL) on PUK unlock screen.
    View v = ((LayoutInflater) getSystemService(Context.LAYOUT_INFLATER_SERVICE)).inflate(com.android.internal.R.layout.transient_notification, null);
    TextView tv = (TextView) v.findViewById(com.android.internal.R.id.message);
    tv.setText(errorMessage);
    final WindowManager.LayoutParams params = new WindowManager.LayoutParams();
    final Configuration config = v.getContext().getResources().getConfiguration();
    final int gravity = Gravity.getAbsoluteGravity(getContext().getResources().getInteger(com.android.internal.R.integer.config_toastDefaultGravity), config.getLayoutDirection());
    params.gravity = gravity;
    if ((gravity & Gravity.HORIZONTAL_GRAVITY_MASK) == Gravity.FILL_HORIZONTAL) {
        params.horizontalWeight = 1.0f;
    }
    if ((gravity & Gravity.VERTICAL_GRAVITY_MASK) == Gravity.FILL_VERTICAL) {
        params.verticalWeight = 1.0f;
    }
    params.y = getContext().getResources().getDimensionPixelSize(com.android.internal.R.dimen.toast_y_offset);
    params.height = WindowManager.LayoutParams.WRAP_CONTENT;
    params.width = WindowManager.LayoutParams.WRAP_CONTENT;
    params.format = PixelFormat.TRANSLUCENT;
    params.windowAnimations = com.android.internal.R.style.Animation_Toast;
    params.type = WindowManager.LayoutParams.TYPE_STATUS_BAR_PANEL;
    params.setTitle(errorMessage);
    params.flags = WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE;
    WindowManager wm = (WindowManager) getSystemService(Context.WINDOW_SERVICE);
    wm.addView(v, params);
    mHandler.postDelayed(new Runnable() {

        @Override
        public void run() {
            wm.removeViewImmediate(v);
        }
    }, LONG_DURATION_TIMEOUT);
}
#end_block

#method_before
private void iccPinChanged(boolean success, int attemptsRemaining) {
    if (DBG)
        Log.d(TAG, "iccPinChanged success: " + success);
    if (!success) {
        setRemainingAttempts(true, attemptsRemaining);
        createCustomTextToast(getPinPasswordErrorMessage(attemptsRemaining)).show();
    } else {
        Toast.makeText(getContext(), mRes.getString(R.string.sim_change_succeeded), Toast.LENGTH_SHORT).show();
    }
    resetDialogState();
}
#method_after
private void iccPinChanged(boolean success, int attemptsRemaining) {
    if (!success) {
        createCustomTextToast(getPinPasswordErrorMessage(attemptsRemaining));
    } else {
        Toast.makeText(getContext(), mRes.getString(R.string.sim_change_succeeded), Toast.LENGTH_SHORT).show();
    }
    resetDialogState();
}
#end_block

#method_before
private String getPinPasswordErrorMessage(int attemptsRemaining) {
    String displayMessage;
    if (attemptsRemaining == 0) {
        displayMessage = mRes.getString(R.string.wrong_pin_code_pukked);
    } else if (attemptsRemaining == 1) {
        displayMessage = mRes.getString(R.string.wrong_pin_code_one, attemptsRemaining);
    } else if (attemptsRemaining > 1) {
        displayMessage = mRes.getQuantityString(R.plurals.wrong_pin_code, attemptsRemaining, attemptsRemaining);
    } else {
        displayMessage = mRes.getString(R.string.pin_failed);
    }
    if (DBG)
        Log.d(TAG, "getPinPasswordErrorMessage:" + " attemptsRemaining=" + attemptsRemaining + " displayMessage=" + displayMessage);
    return displayMessage;
}
#method_after
private String getPinPasswordErrorMessage(int attemptsRemaining) {
    String displayMessage;
    if (attemptsRemaining == 0) {
        displayMessage = mRes.getString(R.string.wrong_pin_code_pukked);
    } else if (attemptsRemaining > 0) {
        displayMessage = mRes.getQuantityString(R.plurals.wrong_pin_code, attemptsRemaining, attemptsRemaining);
    } else {
        displayMessage = mRes.getString(R.string.pin_failed);
    }
    if (DBG)
        Log.d(TAG, "getPinPasswordErrorMessage:" + " attemptsRemaining=" + attemptsRemaining + " displayMessage=" + displayMessage);
    return displayMessage;
}
#end_block

#method_before
@NonNull
static Map<String, String> readStringMap(@NonNull Parcel in) {
    int size = in.readInt();
    Map<String, String> map = new HashMap<>();
    while (size-- > 0) {
        String key = in.readString();
        String value = in.readString();
        map.put(key, value);
    }
    return map;
}
#method_after
@NonNull
static Map<String, String> readStringMap(@NonNull Parcel in) {
    int size = in.readInt();
    Map<String, String> map = new HashMap<>(size);
    while (size-- > 0) {
        String key = in.readString();
        String value = in.readString();
        map.put(key, value);
    }
    return map;
}
#end_block

#method_before
@NonNull
static Map<String, Integer> readStringIntMap(@NonNull Parcel in) {
    int size = in.readInt();
    Map<String, Integer> map = new HashMap<>();
    while (size-- > 0) {
        String key = in.readString();
        int value = in.readInt();
        map.put(key, value);
    }
    return map;
}
#method_after
@NonNull
static Map<String, Integer> readStringIntMap(@NonNull Parcel in) {
    int size = in.readInt();
    Map<String, Integer> map = new HashMap<>(size);
    while (size-- > 0) {
        String key = in.readString();
        int value = in.readInt();
        map.put(key, value);
    }
    return map;
}
#end_block

#method_before
static <T> Set<T> createSet(@NonNull Parcel in, Parcelable.Creator<T> c) {
    int size = in.readInt();
    Set<T> set = new HashSet<>();
    while (size-- > 0) {
        set.add(in.readTypedObject(c));
    }
    return set;
}
#method_after
static <T> Set<T> createSet(@NonNull Parcel in, Parcelable.Creator<T> c) {
    int size = in.readInt();
    Set<T> set = new HashSet<>(size);
    while (size-- > 0) {
        set.add(in.readTypedObject(c));
    }
    return set;
}
#end_block

#method_before
static Set<Integer> createIntSet(@NonNull Parcel in) {
    int size = in.readInt();
    Set<Integer> set = new HashSet<>();
    while (size-- > 0) {
        set.add(in.readInt());
    }
    return set;
}
#method_after
static Set<Integer> createIntSet(@NonNull Parcel in) {
    int size = in.readInt();
    Set<Integer> set = new HashSet<>(size);
    while (size-- > 0) {
        set.add(in.readInt());
    }
    return set;
}
#end_block

#method_before
private static String safeMediaVolumeStateToString(Integer state) {
    switch(state) {
        case SAFE_MEDIA_VOLUME_NOT_CONFIGURED:
            return "SAFE_MEDIA_VOLUME_NOT_CONFIGURED";
        case SAFE_MEDIA_VOLUME_DISABLED:
            return "SAFE_MEDIA_VOLUME_DISABLED";
        case SAFE_MEDIA_VOLUME_INACTIVE:
            return "SAFE_MEDIA_VOLUME_INACTIVE";
        case SAFE_MEDIA_VOLUME_ACTIVE:
            return "SAFE_MEDIA_VOLUME_ACTIVE";
    }
    return null;
}
#method_after
private static String safeMediaVolumeStateToString(int state) {
    switch(state) {
        case SAFE_MEDIA_VOLUME_NOT_CONFIGURED:
            return "SAFE_MEDIA_VOLUME_NOT_CONFIGURED";
        case SAFE_MEDIA_VOLUME_DISABLED:
            return "SAFE_MEDIA_VOLUME_DISABLED";
        case SAFE_MEDIA_VOLUME_INACTIVE:
            return "SAFE_MEDIA_VOLUME_INACTIVE";
        case SAFE_MEDIA_VOLUME_ACTIVE:
            return "SAFE_MEDIA_VOLUME_ACTIVE";
    }
    return null;
}
#end_block

#method_before
@Override
public void onLinkPropertiesChanged(Network network, LinkProperties newLp) {
    handleLinkProp(network, newLp);
    if (mCallbackType == CALLBACK_LISTEN_ALL) {
        recomputeLocalPrefixes();
    }
}
#method_after
@Override
public void onLinkPropertiesChanged(Network network, LinkProperties newLp) {
    handleLinkProp(network, newLp);
    // So it's not useful to do this work for non-LISTEN_ALL callbacks.
    if (mCallbackType == CALLBACK_LISTEN_ALL) {
        recomputeLocalPrefixes();
    }
}
#end_block

#method_before
@Override
public void onLost(Network network) {
    handleLost(mCallbackType, network);
    if (mCallbackType == CALLBACK_LISTEN_ALL) {
        recomputeLocalPrefixes();
    }
}
#method_after
@Override
public void onLost(Network network) {
    handleLost(mCallbackType, network);
    // So it's not useful to do this work for non-LISTEN_ALL callbacks.
    if (mCallbackType == CALLBACK_LISTEN_ALL) {
        recomputeLocalPrefixes();
    }
}
#end_block

#method_before
@Test
public void testGetRoot() throws InterruptedException {
    prepareLooper();
    // The MockMediaLibraryService gives MediaBrowser2Constants.ROOT_ID as root ID, and
    // MediaBrowser2Constants.ROOT_EXTRAS as extras.
    connectAndWait();
    assertEquals(ROOT_ID, mBrowserCompat.getRoot());
    // Note: Cannot use equals() here because browser compat's extra contains server version,
    // extra binder, and extra messenger.
    assertTrue(TestUtils.contains(mBrowserCompat.getExtras(), ROOT_EXTRAS));
}
#method_after
@Test
public void testGetRoot() throws InterruptedException {
    prepareLooper();
    // The MockMediaLibraryService gives MediaBrowser2Constants.ROOT_ID as root ID, and
    // MediaBrowser2Constants.ROOT_EXTRAS as extras.
    sHandler.postAndSync(new Runnable() {

        @Override
        public void run() {
            mBrowserCompat = new MediaBrowserCompat(mContext, getServiceComponent(), mConnectionCallback, null);
        }
    });
    connectAndWait();
    assertEquals(ROOT_ID, mBrowserCompat.getRoot());
    // Note: Cannot use equals() here because browser compat's extra contains server version,
    // extra binder, and extra messenger.
    assertTrue(TestUtils.contains(mBrowserCompat.getExtras(), ROOT_EXTRAS));
}
#end_block

#method_before
@Test
public void testGetItem() throws InterruptedException {
    prepareLooper();
    final String mediaId = MEDIA_ID_GET_ITEM;
    connectAndWait();
    final CountDownLatch latch = new CountDownLatch(1);
    mBrowserCompat.getItem(mediaId, new ItemCallback() {

        @Override
        public void onItemLoaded(MediaItem item) {
            assertEquals(mediaId, item.getMediaId());
            assertNotNull(item);
            latch.countDown();
        }
    });
    assertTrue(latch.await(WAIT_TIME_MS, TimeUnit.MILLISECONDS));
}
#method_after
@Test
public void testGetItem() throws InterruptedException {
    prepareLooper();
    final String mediaId = MEDIA_ID_GET_ITEM;
    connectAndWait();
    final CountDownLatch latch = new CountDownLatch(1);
    mBrowserCompat.getItem(mediaId, new ItemCallback() {

        @Override
        public void onItemLoaded(MediaItem item) {
            assertEquals(mediaId, item.getMediaId());
            assertNotNull(item);
            latch.countDown();
        }
    });
    assertTrue(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
}
#end_block

#method_before
@Test
public void testGetItem_nullResult() throws InterruptedException {
    prepareLooper();
    final String mediaId = "random_media_id";
    connectAndWait();
    final CountDownLatch latch = new CountDownLatch(1);
    mBrowserCompat.getItem(mediaId, new ItemCallback() {

        @Override
        public void onItemLoaded(MediaItem item) {
            assertNull(item);
            latch.countDown();
        }

        @Override
        public void onError(String itemId) {
            fail();
        }
    });
    assertTrue(latch.await(WAIT_TIME_MS, TimeUnit.MILLISECONDS));
}
#method_after
@Test
public void testGetItem_nullResult() throws InterruptedException {
    prepareLooper();
    final String mediaId = "random_media_id";
    connectAndWait();
    final CountDownLatch latch = new CountDownLatch(1);
    mBrowserCompat.getItem(mediaId, new ItemCallback() {

        @Override
        public void onItemLoaded(MediaItem item) {
            assertNull(item);
            latch.countDown();
        }

        @Override
        public void onError(String itemId) {
            fail();
        }
    });
    assertTrue(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
}
#end_block

#method_before
@Test
public void testGetChildren() throws InterruptedException {
    prepareLooper();
    final String testParentId = PARENT_ID;
    connectAndWait();
    final CountDownLatch latch = new CountDownLatch(1);
    mBrowserCompat.subscribe(testParentId, new SubscriptionCallback() {

        @Override
        public void onChildrenLoaded(String parentId, List<MediaItem> children) {
            assertEquals(testParentId, parentId);
            assertNotNull(children);
            assertEquals(GET_CHILDREN_RESULT.size(), children.size());
            // Compare the given results with originals.
            for (int i = 0; i < children.size(); i++) {
                assertEquals(GET_CHILDREN_RESULT.get(i), children.get(i).getMediaId());
            }
            latch.countDown();
        }

        @Override
        public void onChildrenLoaded(String parentId, List<MediaItem> children, Bundle option) {
            fail();
        }
    });
    assertTrue(latch.await(WAIT_TIME_MS, TimeUnit.MILLISECONDS));
}
#method_after
@Test
public void testGetChildren() throws InterruptedException {
    prepareLooper();
    final String testParentId = PARENT_ID;
    connectAndWait();
    final CountDownLatch latch = new CountDownLatch(1);
    mBrowserCompat.subscribe(testParentId, new SubscriptionCallback() {

        @Override
        public void onChildrenLoaded(String parentId, List<MediaItem> children) {
            assertEquals(testParentId, parentId);
            assertNotNull(children);
            assertEquals(GET_CHILDREN_RESULT.size(), children.size());
            // Compare the given results with originals.
            for (int i = 0; i < children.size(); i++) {
                assertEquals(GET_CHILDREN_RESULT.get(i), children.get(i).getMediaId());
            }
            latch.countDown();
        }

        @Override
        public void onChildrenLoaded(String parentId, List<MediaItem> children, Bundle option) {
            fail();
        }
    });
    assertTrue(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
}
#end_block

#method_before
@Test
public void testGetChildren_withPagination() throws InterruptedException {
    prepareLooper();
    final String testParentId = PARENT_ID;
    final int page = 4;
    final int pageSize = 10;
    final Bundle extras = new Bundle();
    extras.putString(testParentId, testParentId);
    connectAndWait();
    final CountDownLatch latch = new CountDownLatch(1);
    final Bundle option = new Bundle();
    option.putInt(MediaBrowserCompat.EXTRA_PAGE, page);
    option.putInt(MediaBrowserCompat.EXTRA_PAGE_SIZE, pageSize);
    mBrowserCompat.subscribe(testParentId, option, new SubscriptionCallback() {

        @Override
        public void onChildrenLoaded(String parentId, List<MediaItem> children, Bundle options) {
            assertEquals(testParentId, parentId);
            assertEquals(page, option.getInt(MediaBrowserCompat.EXTRA_PAGE));
            assertEquals(pageSize, option.getInt(MediaBrowserCompat.EXTRA_PAGE_SIZE));
            assertNotNull(children);
            int fromIndex = page * pageSize;
            int toIndex = Math.min((page + 1) * pageSize, CHILDREN_COUNT);
            // Compare the given results with originals.
            for (int originalIndex = fromIndex; originalIndex < toIndex; originalIndex++) {
                int relativeIndex = originalIndex - fromIndex;
                assertEquals(GET_CHILDREN_RESULT.get(originalIndex), children.get(relativeIndex).getMediaId());
            }
            latch.countDown();
        }

        @Override
        public void onChildrenLoaded(String parentId, List<MediaItem> children) {
            fail();
        }
    });
    assertTrue(latch.await(WAIT_TIME_MS, TimeUnit.MILLISECONDS));
}
#method_after
@Test
public void testGetChildren_withPagination() throws InterruptedException {
    prepareLooper();
    final String testParentId = PARENT_ID;
    final int page = 4;
    final int pageSize = 10;
    final Bundle extras = new Bundle();
    extras.putString(testParentId, testParentId);
    connectAndWait();
    final CountDownLatch latch = new CountDownLatch(1);
    final Bundle option = new Bundle();
    option.putInt(MediaBrowserCompat.EXTRA_PAGE, page);
    option.putInt(MediaBrowserCompat.EXTRA_PAGE_SIZE, pageSize);
    mBrowserCompat.subscribe(testParentId, option, new SubscriptionCallback() {

        @Override
        public void onChildrenLoaded(String parentId, List<MediaItem> children, Bundle options) {
            assertEquals(testParentId, parentId);
            assertEquals(page, option.getInt(MediaBrowserCompat.EXTRA_PAGE));
            assertEquals(pageSize, option.getInt(MediaBrowserCompat.EXTRA_PAGE_SIZE));
            assertNotNull(children);
            int fromIndex = page * pageSize;
            int toIndex = Math.min((page + 1) * pageSize, CHILDREN_COUNT);
            // Compare the given results with originals.
            for (int originalIndex = fromIndex; originalIndex < toIndex; originalIndex++) {
                int relativeIndex = originalIndex - fromIndex;
                assertEquals(GET_CHILDREN_RESULT.get(originalIndex), children.get(relativeIndex).getMediaId());
            }
            latch.countDown();
        }

        @Override
        public void onChildrenLoaded(String parentId, List<MediaItem> children) {
            fail();
        }
    });
    assertTrue(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
}
#end_block

#method_before
@Test
public void testGetChildren_emptyResult() throws InterruptedException {
    prepareLooper();
    final String testParentId = PARENT_ID_NO_CHILDREN;
    connectAndWait();
    final CountDownLatch latch = new CountDownLatch(1);
    mBrowserCompat.subscribe(testParentId, new SubscriptionCallback() {

        @Override
        public void onChildrenLoaded(String parentId, List<MediaItem> children) {
            assertNotNull(children);
            assertEquals(0, children.size());
            latch.countDown();
        }
    });
    assertTrue(latch.await(WAIT_TIME_MS, TimeUnit.MILLISECONDS));
}
#method_after
@Test
public void testGetChildren_emptyResult() throws InterruptedException {
    prepareLooper();
    final String testParentId = PARENT_ID_NO_CHILDREN;
    connectAndWait();
    final CountDownLatch latch = new CountDownLatch(1);
    mBrowserCompat.subscribe(testParentId, new SubscriptionCallback() {

        @Override
        public void onChildrenLoaded(String parentId, List<MediaItem> children) {
            assertNotNull(children);
            assertEquals(0, children.size());
            latch.countDown();
        }
    });
    assertTrue(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
}
#end_block

#method_before
@Test
public void testGetChildren_nullResult() throws InterruptedException {
    prepareLooper();
    final String testParentId = PARENT_ID_ERROR;
    connectAndWait();
    final CountDownLatch latch = new CountDownLatch(1);
    mBrowserCompat.subscribe(testParentId, new SubscriptionCallback() {

        @Override
        public void onError(String parentId) {
            assertEquals(testParentId, parentId);
            latch.countDown();
        }

        @Override
        public void onChildrenLoaded(String parentId, List<MediaItem> children, Bundle options) {
            fail();
        }
    });
    assertTrue(latch.await(WAIT_TIME_MS, TimeUnit.MILLISECONDS));
}
#method_after
@Test
public void testGetChildren_nullResult() throws InterruptedException {
    prepareLooper();
    final String testParentId = PARENT_ID_ERROR;
    connectAndWait();
    final CountDownLatch latch = new CountDownLatch(1);
    mBrowserCompat.subscribe(testParentId, new SubscriptionCallback() {

        @Override
        public void onError(String parentId) {
            assertEquals(testParentId, parentId);
            latch.countDown();
        }

        @Override
        public void onChildrenLoaded(String parentId, List<MediaItem> children, Bundle options) {
            fail();
        }
    });
    assertTrue(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
}
#end_block

#method_before
@Test
public void testSearch() throws InterruptedException {
    prepareLooper();
    final String testQuery = SEARCH_QUERY;
    final int page = 4;
    final int pageSize = 10;
    final Bundle testExtras = new Bundle();
    testExtras.putString(testQuery, testQuery);
    testExtras.putInt(MediaBrowserCompat.EXTRA_PAGE, page);
    testExtras.putInt(MediaBrowserCompat.EXTRA_PAGE_SIZE, pageSize);
    connectAndWait();
    final CountDownLatch latch = new CountDownLatch(1);
    mBrowserCompat.search(testQuery, testExtras, new SearchCallback() {

        @Override
        public void onSearchResult(String query, Bundle extras, List<MediaItem> items) {
            assertEquals(testQuery, query);
            assertTrue(TestUtils.equals(testExtras, extras));
            int expectedSize = Math.max(Math.min(pageSize, SEARCH_RESULT_COUNT - pageSize * page), 0);
            assertEquals(expectedSize, items.size());
            int fromIndex = page * pageSize;
            int toIndex = Math.min((page + 1) * pageSize, SEARCH_RESULT_COUNT);
            // Compare the given results with originals.
            for (int originalIndex = fromIndex; originalIndex < toIndex; originalIndex++) {
                int relativeIndex = originalIndex - fromIndex;
                assertEquals(SEARCH_RESULT.get(originalIndex), items.get(relativeIndex).getMediaId());
            }
            latch.countDown();
        }
    });
    assertTrue(latch.await(WAIT_TIME_MS, TimeUnit.MILLISECONDS));
}
#method_after
@Test
public void testSearch() throws InterruptedException {
    prepareLooper();
    final String testQuery = SEARCH_QUERY;
    final int page = 4;
    final int pageSize = 10;
    final Bundle testExtras = new Bundle();
    testExtras.putString(testQuery, testQuery);
    testExtras.putInt(MediaBrowserCompat.EXTRA_PAGE, page);
    testExtras.putInt(MediaBrowserCompat.EXTRA_PAGE_SIZE, pageSize);
    connectAndWait();
    final CountDownLatch latch = new CountDownLatch(1);
    mBrowserCompat.search(testQuery, testExtras, new SearchCallback() {

        @Override
        public void onSearchResult(String query, Bundle extras, List<MediaItem> items) {
            assertEquals(testQuery, query);
            assertTrue(TestUtils.equals(testExtras, extras));
            int expectedSize = Math.max(Math.min(pageSize, SEARCH_RESULT_COUNT - pageSize * page), 0);
            assertEquals(expectedSize, items.size());
            int fromIndex = page * pageSize;
            int toIndex = Math.min((page + 1) * pageSize, SEARCH_RESULT_COUNT);
            // Compare the given results with originals.
            for (int originalIndex = fromIndex; originalIndex < toIndex; originalIndex++) {
                int relativeIndex = originalIndex - fromIndex;
                assertEquals(SEARCH_RESULT.get(originalIndex), items.get(relativeIndex).getMediaId());
            }
            latch.countDown();
        }
    });
    assertTrue(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
}
#end_block

#method_before
@Test
public void testSearch_emptyResult() throws InterruptedException {
    prepareLooper();
    final String testQuery = SEARCH_QUERY_EMPTY_RESULT;
    final Bundle testExtras = new Bundle();
    testExtras.putString(testQuery, testQuery);
    connectAndWait();
    final CountDownLatch latch = new CountDownLatch(1);
    mBrowserCompat.search(testQuery, testExtras, new SearchCallback() {

        @Override
        public void onSearchResult(String query, Bundle extras, List<MediaItem> items) {
            assertEquals(testQuery, query);
            assertTrue(TestUtils.equals(testExtras, extras));
            assertNotNull(items);
            assertEquals(0, items.size());
            latch.countDown();
        }
    });
    assertTrue(latch.await(WAIT_TIME_MS, TimeUnit.MILLISECONDS));
}
#method_after
@Test
public void testSearch_emptyResult() throws InterruptedException {
    prepareLooper();
    final String testQuery = SEARCH_QUERY_EMPTY_RESULT;
    final Bundle testExtras = new Bundle();
    testExtras.putString(testQuery, testQuery);
    connectAndWait();
    final CountDownLatch latch = new CountDownLatch(1);
    mBrowserCompat.search(testQuery, testExtras, new SearchCallback() {

        @Override
        public void onSearchResult(String query, Bundle extras, List<MediaItem> items) {
            assertEquals(testQuery, query);
            assertTrue(TestUtils.equals(testExtras, extras));
            assertNotNull(items);
            assertEquals(0, items.size());
            latch.countDown();
        }
    });
    assertTrue(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
}
#end_block

#method_before
@Test
public void testSearch_error() throws InterruptedException {
    prepareLooper();
    final String testQuery = SEARCH_QUERY_ERROR;
    final Bundle testExtras = new Bundle();
    testExtras.putString(testQuery, testQuery);
    connectAndWait();
    final CountDownLatch latch = new CountDownLatch(1);
    mBrowserCompat.search(testQuery, testExtras, new SearchCallback() {

        @Override
        public void onError(String query, Bundle extras) {
            assertEquals(testQuery, query);
            assertTrue(TestUtils.equals(testExtras, extras));
            latch.countDown();
        }

        @Override
        public void onSearchResult(String query, Bundle extras, List<MediaItem> items) {
            fail();
        }
    });
    assertTrue(latch.await(WAIT_TIME_MS, TimeUnit.MILLISECONDS));
}
#method_after
@Test
public void testSearch_error() throws InterruptedException {
    prepareLooper();
    final String testQuery = SEARCH_QUERY_ERROR;
    final Bundle testExtras = new Bundle();
    testExtras.putString(testQuery, testQuery);
    connectAndWait();
    final CountDownLatch latch = new CountDownLatch(1);
    mBrowserCompat.search(testQuery, testExtras, new SearchCallback() {

        @Override
        public void onError(String query, Bundle extras) {
            assertEquals(testQuery, query);
            assertTrue(TestUtils.equals(testExtras, extras));
            latch.countDown();
        }

        @Override
        public void onSearchResult(String query, Bundle extras, List<MediaItem> items) {
            fail();
        }
    });
    assertTrue(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
}
#end_block

#method_before
@Ignore("TODO: Split this test to here and MediaLibrarySessionLegacyCallbackTest.")
@Test
public void testNotifyChildrenChanged() throws InterruptedException {
// prepareLooper();
// final String testSubscribedParentId = "testNotifyChildrenChanged";
// final String testUnsubscribedParentId = "testNotifyChildrenChanged22";
// final Bundle testExtras = new Bundle();
// testExtras.putString(testSubscribedParentId, testSubscribedParentId);
// final List<MediaItem2> testList = TestUtils.createPlaylist(3);
// 
// final CountDownLatch subscribeLatch = new CountDownLatch(1);
// final MediaLibrarySessionCallback callback = new MediaLibrarySessionCallback() {
// @Override
// public void onSubscribe(@NonNull MediaLibrarySession session,
// @NonNull ControllerInfo info, @NonNull String parentId,
// @Nullable Bundle extras) {
// if (Process.myUid() == info.getUid()) {
// subscribeLatch.countDown();
// }
// }
// 
// @Override
// public List<MediaItem2> onGetChildren(MediaLibrarySession session,
// ControllerInfo controller, String parentId, int page, int pageSize,
// Bundle extras) {
// assertEquals(testSubscribedParentId, parentId);
// return testList;
// }
// };
// TestServiceRegistry.getInstance().setSessionCallback(callback);
// 
// connectAndWait();
// final CountDownLatch onChildrenLoadedLatch = new CountDownLatch(2);
// mBrowserCompat.subscribe(testSubscribedParentId, testExtras, new SubscriptionCallback() {
// @Override
// public void onChildrenLoaded(String parentId, List<MediaItem> children) {
// assertEquals(testSubscribedParentId, parentId);
// onChildrenLoadedLatch.countDown();
// }
// 
// @Override
// public void onChildrenLoaded(String parentId, List<MediaItem> children,
// Bundle options) {
// super.onChildrenLoaded(parentId, children, options);
// }
// });
// assertTrue(subscribeLatch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
// MediaLibrarySession librarySession = (MediaLibrarySession)
// TestServiceRegistry.getInstance().getServiceInstance().getSession();
// librarySession.notifyChildrenChanged(testSubscribedParentId, testList.size(), null);
// librarySession.notifyChildrenChanged(testUnsubscribedParentId, testList.size(), null);
// assertFalse(onChildrenLoadedLatch.await(WAIT_TIME_MS, TimeUnit.MILLISECONDS));
}
#method_after
@Ignore("TODO: Split this test to here and MediaLibrarySessionLegacyCallbackTest.")
@Test
public void testNotifyChildrenChanged() throws InterruptedException {
// prepareLooper();
// final String testSubscribedParentId = "testNotifyChildrenChanged";
// final String testUnsubscribedParentId = "testNotifyChildrenChanged22";
// final Bundle testExtras = new Bundle();
// testExtras.putString(testSubscribedParentId, testSubscribedParentId);
// final List<MediaItem2> testList = TestUtils.createPlaylist(3);
// 
// final CountDownLatch subscribeLatch = new CountDownLatch(1);
// final MediaLibrarySessionCallback callback = new MediaLibrarySessionCallback() {
// @Override
// public void onSubscribe(@NonNull MediaLibrarySession session,
// @NonNull ControllerInfo info, @NonNull String parentId,
// @Nullable Bundle extras) {
// if (Process.myUid() == info.getUid()) {
// subscribeLatch.countDown();
// }
// }
// 
// @Override
// public List<MediaItem2> onGetChildren(MediaLibrarySession session,
// ControllerInfo controller, String parentId, int page, int pageSize,
// Bundle extras) {
// assertEquals(testSubscribedParentId, parentId);
// return testList;
// }
// };
// TestServiceRegistry.getInstance().setSessionCallback(callback);
// 
// connectAndWait();
// final CountDownLatch onChildrenLoadedLatch = new CountDownLatch(2);
// mBrowserCompat.subscribe(testSubscribedParentId, testExtras, new SubscriptionCallback() {
// @Override
// public void onChildrenLoaded(String parentId, List<MediaItem> children) {
// assertEquals(testSubscribedParentId, parentId);
// onChildrenLoadedLatch.countDown();
// }
// 
// @Override
// public void onChildrenLoaded(String parentId, List<MediaItem> children,
// Bundle options) {
// super.onChildrenLoaded(parentId, children, options);
// }
// });
// assertTrue(subscribeLatch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
// MediaLibrarySession librarySession = (MediaLibrarySession)
// TestServiceRegistry.getInstance().getServiceInstance().getSession();
// librarySession.notifyChildrenChanged(testSubscribedParentId, testList.size(), null);
// librarySession.notifyChildrenChanged(testUnsubscribedParentId, testList.size(), null);
// assertFalse(onChildrenLoadedLatch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
}
#end_block

#method_before
@Test
public void testCustomAction() throws InterruptedException {
    prepareLooper();
    final Bundle testArgs = new Bundle();
    testArgs.putString("args_key", "args_value");
    connectAndWait();
    final CountDownLatch latch = new CountDownLatch(1);
    mBrowserCompat.sendCustomAction(CUSTOM_ACTION, testArgs, new CustomActionCallback() {

        @Override
        public void onResult(String action, Bundle extras, Bundle resultData) {
            assertEquals(CUSTOM_ACTION, action);
            assertTrue(TestUtils.equals(testArgs, extras));
            assertTrue(TestUtils.equals(CUSTOM_ACTION_EXTRAS, resultData));
            latch.countDown();
        }
    });
    assertTrue(latch.await(WAIT_TIME_MS, TimeUnit.MILLISECONDS));
}
#method_after
@Test
public void testCustomAction() throws InterruptedException {
    prepareLooper();
    final Bundle testArgs = new Bundle();
    testArgs.putString("args_key", "args_value");
    connectAndWait();
    final CountDownLatch latch = new CountDownLatch(1);
    mBrowserCompat.sendCustomAction(CUSTOM_ACTION, testArgs, new CustomActionCallback() {

        @Override
        public void onResult(String action, Bundle extras, Bundle resultData) {
            assertEquals(CUSTOM_ACTION, action);
            assertTrue(TestUtils.equals(testArgs, extras));
            assertTrue(TestUtils.equals(CUSTOM_ACTION_EXTRAS, resultData));
            latch.countDown();
        }
    });
    assertTrue(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
}
#end_block

#method_before
@Nullable
public PersistableBundle getConfigForSubId(int subId) {
    try {
        ICarrierConfigLoader loader = getICarrierConfigLoader();
        if (loader == null) {
            Rlog.w(TAG, "Error getting config for subId " + subId + " ICarrierConfigLoader is null");
            return null;
        }
        return loader.getConfigForSubId(subId);
    } catch (RemoteException ex) {
        Rlog.e(TAG, "Error getting config for subId " + subId + ": " + ex.toString());
    }
    return null;
}
#method_after
@Nullable
public PersistableBundle getConfigForSubId(int subId) {
    try {
        ICarrierConfigLoader loader = getICarrierConfigLoader();
        if (loader == null) {
            Rlog.w(TAG, "Error getting config for subId " + subId + " ICarrierConfigLoader is null");
            return null;
        }
        return loader.getConfigForSubId(subId, mContext.getOpPackageName());
    } catch (RemoteException ex) {
        Rlog.e(TAG, "Error getting config for subId " + subId + ": " + ex.toString());
    }
    return null;
}
#end_block

#method_before
@NonNull
public NavigationState build() {
    return new NavigationState(mSteps, mDestinations, mServiceStatus);
}
#method_after
@NonNull
public NavigationState build() {
    return new NavigationState(mSteps, mDestinations, mCurrentSegment, mServiceStatus);
}
#end_block

#method_before
@Override
public boolean equals(Object o) {
    if (this == o) {
        return true;
    }
    if (o == null || getClass() != o.getClass()) {
        return false;
    }
    NavigationState that = (NavigationState) o;
    return Objects.equals(getSteps(), that.getSteps()) && Objects.equals(getDestinations(), that.getDestinations()) && Objects.equals(getServiceStatus(), that.getServiceStatus());
}
#method_after
@Override
public boolean equals(Object o) {
    if (this == o) {
        return true;
    }
    if (o == null || getClass() != o.getClass()) {
        return false;
    }
    NavigationState that = (NavigationState) o;
    return Objects.equals(getSteps(), that.getSteps()) && Objects.equals(getDestinations(), that.getDestinations()) && Objects.equals(getCurrentSegment(), that.getCurrentSegment()) && Objects.equals(getServiceStatus(), that.getServiceStatus());
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hash(getSteps(), getDestinations(), getServiceStatus());
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(getSteps(), getDestinations(), getCurrentSegment(), getServiceStatus());
}
#end_block

#method_before
@Override
public String toString() {
    return String.format("{steps: %s, destinations: %s, serviceStatus: %s}", mSteps, mDestinations, mServiceStatus);
}
#method_after
@Override
public String toString() {
    return String.format("{steps: %s, destinations: %s, segment: %s, serviceStatus: %s}", mSteps, mDestinations, mCurrentSegment, mServiceStatus);
}
#end_block

#method_before
@Test
public void equalityTest() {
    // Testing empty nav state cases
    assertEquals(new NavigationState(), new NavigationState.Builder().build());
    assertEquals(new NavigationState(), new NavigationState.Builder().setServiceStatus(NavigationState.ServiceStatus.NORMAL).build());
    Destination destination = new Destination.Builder().build();
    Step step = new Step.Builder().build();
    NavigationState navState = new NavigationState.Builder().addDestination(destination).addStep(step).setServiceStatus(NavigationState.ServiceStatus.NORMAL).build();
    // Testing a few equality/inequality cases
    assertEquals(navState, new NavigationState.Builder().addDestination(destination).addStep(step).setServiceStatus(NavigationState.ServiceStatus.NORMAL).build());
    assertNotEquals(navState, new NavigationState.Builder().addStep(step).setServiceStatus(NavigationState.ServiceStatus.NORMAL).build());
    assertNotEquals(navState, new NavigationState.Builder().addStep(step).setServiceStatus(NavigationState.ServiceStatus.NORMAL).build());
    assertNotEquals(navState, new NavigationState.Builder().addDestination(destination).addDestination(destination).addStep(step).setServiceStatus(NavigationState.ServiceStatus.NORMAL).build());
    assertNotEquals(navState, new NavigationState.Builder().addDestination(destination).addStep(step).addStep(step).setServiceStatus(NavigationState.ServiceStatus.NORMAL).build());
    assertNotEquals(navState, new NavigationState.Builder().addDestination(destination).addStep(step).setServiceStatus(NavigationState.ServiceStatus.REROUTING).build());
    // Testing hashcode
    assertEquals(new NavigationState().hashCode(), new NavigationState.Builder().setServiceStatus(NavigationState.ServiceStatus.NORMAL).build().hashCode());
    assertEquals(navState.hashCode(), new NavigationState.Builder().addDestination(destination).addStep(step).setServiceStatus(NavigationState.ServiceStatus.NORMAL).build().hashCode());
}
#method_after
@Test
public void equalityTest() {
    // Testing empty nav state cases
    assertEquals(new NavigationState(), new NavigationState.Builder().build());
    assertEquals(new NavigationState(), new NavigationState.Builder().setServiceStatus(NavigationState.ServiceStatus.NORMAL).build());
    Destination destination = new Destination.Builder().build();
    Step step = new Step.Builder().build();
    NavigationState navState = new NavigationState.Builder().addDestination(destination).addStep(step).setServiceStatus(NavigationState.ServiceStatus.NORMAL).build();
    // Testing a few equality/inequality cases
    assertEquals(navState, new NavigationState.Builder().addDestination(destination).addStep(step).setServiceStatus(NavigationState.ServiceStatus.NORMAL).build());
    assertNotEquals(navState, new NavigationState.Builder().addStep(step).setServiceStatus(NavigationState.ServiceStatus.NORMAL).build());
    assertNotEquals(navState, new NavigationState.Builder().addDestination(destination).addDestination(destination).addStep(step).setServiceStatus(NavigationState.ServiceStatus.NORMAL).build());
    assertNotEquals(navState, new NavigationState.Builder().addDestination(destination).addStep(step).addStep(step).setServiceStatus(NavigationState.ServiceStatus.NORMAL).build());
    assertNotEquals(navState, new NavigationState.Builder().addDestination(destination).addStep(step).setServiceStatus(NavigationState.ServiceStatus.REROUTING).build());
    assertEquals(new NavigationState.Builder().setCurrentSegment(new Segment()).build(), new NavigationState.Builder().setCurrentSegment(new Segment()).build());
    assertNotEquals(new NavigationState.Builder().build(), new NavigationState.Builder().setCurrentSegment(new Segment()).build());
    assertNotEquals(new NavigationState.Builder().setCurrentSegment(new Segment("TEST")).build(), new NavigationState.Builder().setCurrentSegment(new Segment()).build());
    // Testing hashcode
    assertEquals(new NavigationState().hashCode(), new NavigationState.Builder().setServiceStatus(NavigationState.ServiceStatus.NORMAL).build().hashCode());
    assertEquals(navState.hashCode(), new NavigationState.Builder().addDestination(destination).addStep(step).setServiceStatus(NavigationState.ServiceStatus.NORMAL).build().hashCode());
}
#end_block

#method_before
private NavigationState createSampleState() {
    return new NavigationState.Builder().addStep(new Step.Builder().setManeuver(new Maneuver.Builder().setType(Maneuver.Type.DEPART).build()).setDistance(new Distance(10, "10", Distance.Unit.METERS)).addLane(new Lane.Builder().addDirection(new LaneDirection.Builder().setShape(LaneDirection.Shape.NORMAL_LEFT).setHighlighted(true).build()).addDirection(new LaneDirection.Builder().setShape(LaneDirection.Shape.STRAIGHT).setHighlighted(true).build()).build()).addLane(new Lane.Builder().addDirection(new LaneDirection.Builder().setShape(LaneDirection.Shape.SHARP_LEFT).build()).addDirection(new LaneDirection.Builder().setShape(LaneDirection.Shape.NORMAL_LEFT).build()).build()).build()).addStep(new Step.Builder().setManeuver(new Maneuver.Builder().setType(Maneuver.Type.ROUNDABOUT_EXIT).setRoundaboutExitNumber(2).build()).setDistance(new Distance(15, "15", Distance.Unit.METERS)).build()).addDestination(new Destination.Builder().setTitle("Home").setDistance(new Distance(1230, "1.2", Distance.Unit.KILOMETERS)).setLocation(new LatLng(37.4219999, -122.0840575)).build()).setServiceStatus(NavigationState.ServiceStatus.NORMAL).build();
}
#method_after
private NavigationState createSampleState() {
    return new NavigationState.Builder().addStep(new Step.Builder().setManeuver(new Maneuver.Builder().setType(Maneuver.Type.DEPART).build()).setDistance(new Distance(10, "10", Distance.Unit.METERS)).addLane(new Lane.Builder().addDirection(new LaneDirection.Builder().setShape(LaneDirection.Shape.NORMAL_LEFT).setHighlighted(true).build()).addDirection(new LaneDirection.Builder().setShape(LaneDirection.Shape.STRAIGHT).setHighlighted(true).build()).build()).addLane(new Lane.Builder().addDirection(new LaneDirection.Builder().setShape(LaneDirection.Shape.SHARP_LEFT).build()).addDirection(new LaneDirection.Builder().setShape(LaneDirection.Shape.NORMAL_LEFT).build()).build()).build()).addStep(new Step.Builder().setManeuver(new Maneuver.Builder().setType(Maneuver.Type.ROUNDABOUT_EXIT).setRoundaboutExitNumber(2).build()).setDistance(new Distance(15, "15", Distance.Unit.METERS)).build()).addDestination(new Destination.Builder().setTitle("Home").setDistance(new Distance(1230, "1.2", Distance.Unit.KILOMETERS)).setLocation(new LatLng(37.4219999, -122.0840575)).build()).setCurrentSegment(new Segment("Main St.")).setServiceStatus(NavigationState.ServiceStatus.NORMAL).build();
}
#end_block

#method_before
private void initialize(Context context, AttributeSet attrs) {
    mRecyclerView = new RecyclerView(context);
    mRecyclerView.setId(ViewCompat.generateViewId());
    mLayoutManager = new LinearLayoutManager(context);
    mRecyclerView.setLayoutManager(mLayoutManager);
    setOrientation(context, attrs);
    mRecyclerView.setLayoutParams(new ViewGroup.LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT));
    mRecyclerView.addOnChildAttachStateChangeListener(enforceChildFillListener());
    new PagerSnapHelper().attachToRecyclerView(mRecyclerView);
    mScrollEventAdapter = new ScrollEventAdapter(mLayoutManager);
    mRecyclerView.addOnScrollListener(mScrollEventAdapter);
    CompositeOnPageChangeListener dispatcher = new CompositeOnPageChangeListener(3);
    mScrollEventAdapter.setOnPageChangeListener(dispatcher);
    // Add mOnPageChangeListener before mExternalPageChangeListeners, because we need to update
    // internal state first
    dispatcher.addOnPageChangeListener(mOnPageChangeListener);
    dispatcher.addOnPageChangeListener(mExternalPageChangeListeners);
    // Add mPageTransformerAdapter after mExternalPageChangeListeners, because page transform
    // events must be fired after scroll events
    mPageTransformerAdapter = new PageTransformerAdapter(mLayoutManager);
    dispatcher.addOnPageChangeListener(mPageTransformerAdapter);
    attachViewToParent(mRecyclerView, 0, mRecyclerView.getLayoutParams());
}
#method_after
private void initialize(Context context, AttributeSet attrs) {
    mRecyclerView = new RecyclerView(context);
    mRecyclerView.setId(ViewCompat.generateViewId());
    mLayoutManager = new LinearLayoutManager(context);
    mRecyclerView.setLayoutManager(mLayoutManager);
    setOrientation(context, attrs);
    mRecyclerView.setLayoutParams(new ViewGroup.LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT));
    mRecyclerView.addOnChildAttachStateChangeListener(enforceChildFillListener());
    new PagerSnapHelper().attachToRecyclerView(mRecyclerView);
    mScrollEventAdapter = new ScrollEventAdapter(mLayoutManager);
    mRecyclerView.addOnScrollListener(mScrollEventAdapter);
    CompositeOnPageChangeListener dispatcher = new CompositeOnPageChangeListener(3);
    mScrollEventAdapter.setOnPageChangeListener(dispatcher);
    // Listener that updates mCurrentItem after swipes. Also triggered in other cases, but in
    // all those cases mCurrentItem will only be overwritten with the same value.
    final OnPageChangeListener currentItemUpdater = new OnPageChangeListener() {

        @Override
        public void onPageScrolled(int position, float positionOffset, int positionOffsetPx) {
        }

        @Override
        public void onPageSelected(int position) {
            mCurrentItem = position;
        }

        @Override
        public void onPageScrollStateChanged(int state) {
        }
    };
    // Add currentItemUpdater before mExternalPageChangeListeners, because we need to update
    // internal state first
    dispatcher.addOnPageChangeListener(currentItemUpdater);
    dispatcher.addOnPageChangeListener(mExternalPageChangeListeners);
    // Add mPageTransformerAdapter after mExternalPageChangeListeners, because page transform
    // events must be fired after scroll events
    mPageTransformerAdapter = new PageTransformerAdapter(mLayoutManager);
    dispatcher.addOnPageChangeListener(mPageTransformerAdapter);
    attachViewToParent(mRecyclerView, 0, mRecyclerView.getLayoutParams());
}
#end_block

#method_before
public void setCurrentItem(int item, boolean smoothScroll) {
    float previousItem = mCurrentItem;
    if (previousItem == item) {
        return;
    }
    mCurrentItem = item;
    if (!mScrollEventAdapter.isIdle()) {
        // Scroll in progress, overwrite previousItem with actual current position
        previousItem = mScrollEventAdapter.getRelativeScrollPosition();
    }
    mScrollEventAdapter.notifyProgrammaticScroll(item, smoothScroll);
    if (!smoothScroll) {
        mRecyclerView.scrollToPosition(item);
        return;
    }
    // For smooth scroll, pre-jump to nearby item for long jumps.
    if (Math.abs(item - previousItem) > 3) {
        mRecyclerView.scrollToPosition(item > previousItem ? item - 3 : item + 3);
        // TODO(b/114361680): call smoothScrollToPosition synchronously (blocked by b/114019007)
        mRecyclerView.post(new SmoothScrollToPosition(item));
    } else {
        mRecyclerView.smoothScrollToPosition(item);
    }
}
#method_after
public void setCurrentItem(int item, boolean smoothScroll) {
    if (item == mCurrentItem && mScrollEventAdapter.isIdle()) {
        // Already at the correct page
        return;
    }
    if (item == mCurrentItem && smoothScroll) {
        // because then we need to interrupt the current smooth scroll.
        return;
    }
    float previousItem = mCurrentItem;
    mCurrentItem = item;
    if (!mScrollEventAdapter.isIdle()) {
        // Scroll in progress, overwrite previousItem with actual current position
        previousItem = mScrollEventAdapter.getRelativeScrollPosition();
    }
    mScrollEventAdapter.notifyProgrammaticScroll(item, smoothScroll);
    if (!smoothScroll) {
        mRecyclerView.scrollToPosition(item);
        return;
    }
    // For smooth scroll, pre-jump to nearby item for long jumps.
    if (Math.abs(item - previousItem) > 3) {
        mRecyclerView.scrollToPosition(item > previousItem ? item - 3 : item + 3);
        // TODO(b/114361680): call smoothScrollToPosition synchronously (blocked by b/114019007)
        mRecyclerView.post(new SmoothScrollToPosition(item));
    } else {
        mRecyclerView.smoothScrollToPosition(item);
    }
}
#end_block

#method_before
private void swipeNext() {
    swipe(mActionNext);
}
#method_after
public void swipeNext() {
    swipe(mActionNext);
}
#end_block

#method_before
private void swipePrevious() {
    swipe(mActionPrevious);
}
#method_after
public void swipePrevious() {
    swipe(mActionPrevious);
}
#end_block

#method_before
private void swipe(ViewAction swipeAction) {
    onView(allOf(isDisplayed(), withId(R.id.text_view))).perform(swipeAction);
}
#method_after
private void swipe(ViewAction swipeAction) {
    onView(allOf(isDisplayed(), isAssignableFrom(ViewPager2.class))).perform(swipeAction);
}
#end_block

#method_before
@Test
public void test_orientation_noAttrs() {
    ViewPager2 viewPager = new ViewPager2(InstrumentationRegistry.getContext());
    assertThat(viewPager.getOrientation(), equalTo(ORIENTATION_HORIZONTAL));
}
#method_after
@Test
public void test_orientation_noAttrs() {
    ViewPager2 viewPager = new ViewPager2(InstrumentationRegistry.getContext());
    assertThat(viewPager.getOrientation(), equalTo(ViewPager2.ORIENTATION_HORIZONTAL));
}
#end_block

#method_before
@Test
public void test_orientation_nullAttrs() {
    ViewPager2 viewPager = new ViewPager2(InstrumentationRegistry.getContext(), null);
    assertThat(viewPager.getOrientation(), equalTo(ORIENTATION_HORIZONTAL));
}
#method_after
@Test
public void test_orientation_nullAttrs() {
    ViewPager2 viewPager = new ViewPager2(InstrumentationRegistry.getContext(), null);
    assertThat(viewPager.getOrientation(), equalTo(ViewPager2.ORIENTATION_HORIZONTAL));
}
#end_block

#method_before
@Test
public void test_orientation_default() {
    assertOrientationCorrect(R.layout.orientation_default, ORIENTATION_HORIZONTAL);
}
#method_after
@Test
public void test_orientation_default() {
    assertOrientationCorrect(R.layout.orientation_default, ViewPager2.ORIENTATION_HORIZONTAL);
}
#end_block

#method_before
@Test
public void test_orientation_horizontal() {
    assertOrientationCorrect(R.layout.orientation_horizontal, ORIENTATION_HORIZONTAL);
}
#method_after
@Test
public void test_orientation_horizontal() {
    assertOrientationCorrect(R.layout.orientation_horizontal, ViewPager2.ORIENTATION_HORIZONTAL);
}
#end_block

#method_before
@Test
public void test_orientation_vertical() {
    assertOrientationCorrect(R.layout.orientation_vertical, ORIENTATION_VERTICAL);
}
#method_after
@Test
public void test_orientation_vertical() {
    assertOrientationCorrect(R.layout.orientation_vertical, ViewPager2.ORIENTATION_VERTICAL);
}
#end_block

#method_before
@Test
public void test_valuesInSync() {
    assertThat(ORIENTATION_HORIZONTAL, allOf(is(0), is(RecyclerView.HORIZONTAL)));
    assertThat(ORIENTATION_VERTICAL, allOf(is(1), is(RecyclerView.VERTICAL)));
}
#method_after
@Test
public void test_valuesInSync() {
    assertThat(ViewPager2.ORIENTATION_HORIZONTAL, allOf(is(0), is(RecyclerView.HORIZONTAL)));
    assertThat(ViewPager2.ORIENTATION_VERTICAL, allOf(is(1), is(RecyclerView.VERTICAL)));
}
#end_block

#method_before
private void resetState() {
    mAdapterState = STATE_IDLE;
    mScrollState = ViewPager2.SCROLL_STATE_IDLE;
    mScrollValues.reset();
    mInitialPosition = NO_TARGET;
    mTarget = NO_TARGET;
    mDispatchSelected = false;
    mScrollHappened = false;
}
#method_after
private void resetState() {
    mAdapterState = STATE_IDLE;
    mScrollState = SCROLL_STATE_IDLE;
    mScrollValues.reset();
    mDragStartPosition = NO_POSITION;
    mTarget = NO_POSITION;
    mDispatchSelected = false;
    mScrollHappened = false;
}
#end_block

#method_before
@Override
public void onScrollStateChanged(@NonNull RecyclerView recyclerView, int newState) {
    if (mAdapterState == STATE_IDLE && newState == RecyclerView.SCROLL_STATE_DRAGGING) {
        mAdapterState = STATE_IN_PROGRESS_MANUAL_DRAG;
        dispatchStateChanged(ViewPager2.SCROLL_STATE_DRAGGING);
        mInitialPosition = getPosition();
        return;
    }
    if (mAdapterState == STATE_IN_PROGRESS_MANUAL_DRAG && newState == RecyclerView.SCROLL_STATE_SETTLING) {
        if (!mScrollHappened) {
            // Special case of dragging before first (or beyond last) page
            dispatchScrolled(getPosition(), 0f, 0);
        } else {
            dispatchStateChanged(ViewPager2.SCROLL_STATE_SETTLING);
            mDispatchSelected = true;
        }
        return;
    }
    if (mAdapterState == STATE_IN_PROGRESS_MANUAL_DRAG && newState == RecyclerView.SCROLL_STATE_IDLE) {
        if (!mScrollHappened) {
            // Special case of dragging before first (or beyond last) page
            dispatchStateChanged(ViewPager2.SCROLL_STATE_IDLE);
            resetState();
        }
        return;
    }
}
#method_after
@Override
public void onScrollStateChanged(@NonNull RecyclerView recyclerView, int newState) {
    // User started a drag (not dragging -> dragging)
    if (mAdapterState != STATE_IN_PROGRESS_MANUAL_DRAG && newState == RecyclerView.SCROLL_STATE_DRAGGING) {
        // Remember we're performing a drag
        mAdapterState = STATE_IN_PROGRESS_MANUAL_DRAG;
        if (mTarget != NO_POSITION) {
            // Target was set means programmatic scroll was in progress
            // Update "drag start page" to reflect the page that ViewPager2 thinks it is at
            mDragStartPosition = mTarget;
            // Reset target because drags have no target until released
            mTarget = NO_POSITION;
        } else {
            // ViewPager2 was at rest, set "drag start page" to current page
            mDragStartPosition = getPosition();
        }
        dispatchStateChanged(SCROLL_STATE_DRAGGING);
        return;
    }
    // Note that mAdapterState is not updated, to remember we were dragging when settling
    if (mAdapterState == STATE_IN_PROGRESS_MANUAL_DRAG && newState == RecyclerView.SCROLL_STATE_SETTLING) {
        if (!mScrollHappened) {
            // Pages didn't move during drag, so must be at the start or end of the list
            // ViewPager's contract requires at least one scroll event though
            dispatchScrolled(getPosition(), 0f, 0);
        } else {
            dispatchStateChanged(SCROLL_STATE_SETTLING);
            // Determine target page and dispatch onPageSelected on next scroll event
            mDispatchSelected = true;
            // Reset value to recognise if onPageSelected has been fired when going to idle
            mScrollHappened = false;
        }
        return;
    }
    // Drag has settled (dragging && settling -> idle)
    if (mAdapterState == STATE_IN_PROGRESS_MANUAL_DRAG && newState == RecyclerView.SCROLL_STATE_IDLE) {
        if (!mScrollHappened) {
            // Happens if there was no velocity or if it was the first or last page
            if (mDispatchSelected) {
                // Fire onPageSelected when snapped page is different from initial position
                // E.g.: smooth scroll from 0 to 1, interrupt with drag at 0.5, release at 0
                updateScrollEventValues();
                if (mDragStartPosition != mScrollValues.mPosition) {
                    dispatchSelected(mScrollValues.mPosition);
                }
            }
            // Normally idle is fired in onScrolled, but scroll did not happen
            dispatchStateChanged(SCROLL_STATE_IDLE);
            resetState();
        }
        return;
    }
}
#end_block

#method_before
@Override
public void onScrolled(@NonNull RecyclerView recyclerView, int dx, int dy) {
    mScrollHappened = true;
    ScrollEventValues values = updateScrollEventValues();
    if (mDispatchSelected) {
        mDispatchSelected = false;
        mTarget = (dx + dy > 0) ? values.mPosition + 1 : values.mPosition;
        if (mInitialPosition != mTarget) {
            dispatchSelected(mTarget);
        }
    }
    dispatchScrolled(values.mPosition, values.mOffset, values.mOffsetPx);
    if ((values.mPosition == mTarget || mTarget == NO_TARGET) && values.mOffsetPx == 0) {
        dispatchStateChanged(ViewPager2.SCROLL_STATE_IDLE);
        resetState();
    }
}
#method_after
@Override
public void onScrolled(@NonNull RecyclerView recyclerView, int dx, int dy) {
    mScrollHappened = true;
    ScrollEventValues values = updateScrollEventValues();
    if (mDispatchSelected) {
        // Drag started settling, need to calculate target page and dispatch onPageSelected now
        mDispatchSelected = false;
        mTarget = (dx + dy > 0) ? values.mPosition + 1 : values.mPosition;
        if (mDragStartPosition != mTarget) {
            dispatchSelected(mTarget);
        }
    }
    dispatchScrolled(values.mPosition, values.mOffset, values.mOffsetPx);
    if ((values.mPosition == mTarget || mTarget == NO_POSITION) && values.mOffsetPx == 0 && mScrollState != SCROLL_STATE_DRAGGING) {
        // When the target page is reached and the user is not dragging anymore, we're settled,
        // so go to idle.
        // Special case and a bit of a hack when there is no target: RecyclerView is being
        // initialized and fires a single scroll event. This flags mScrollHappened, so we need
        // to reset our state. However, we don't want to dispatch idle. But that won't happen;
        // because we were already idle.
        dispatchStateChanged(SCROLL_STATE_IDLE);
        resetState();
    }
}
#end_block

#method_before
private ScrollEventValues updateScrollEventValues() {
    ScrollEventValues values = mScrollValues;
    values.mPosition = mLayoutManager.findFirstVisibleItemPosition();
    if (values.mPosition == RecyclerView.NO_POSITION) {
        return values.reset();
    }
    View firstVisibleView = mLayoutManager.findViewByPosition(values.mPosition);
    if (firstVisibleView == null) {
        return values.reset();
    }
    boolean isHorizontal = mLayoutManager.getOrientation() == ViewPager2.ORIENTATION_HORIZONTAL;
    int start, sizePx;
    if (isHorizontal) {
        start = firstVisibleView.getLeft();
        sizePx = firstVisibleView.getWidth();
    } else {
        start = firstVisibleView.getTop();
        sizePx = firstVisibleView.getHeight();
    }
    values.mOffsetPx = -start;
    if (values.mOffsetPx < 0) {
        throw new IllegalStateException(String.format("Page can only be offset by a positive " + "amount, not by %d", values.mOffsetPx));
    }
    values.mOffset = sizePx == 0 ? 0 : (float) values.mOffsetPx / sizePx;
    return values;
}
#method_after
private ScrollEventValues updateScrollEventValues() {
    ScrollEventValues values = mScrollValues;
    values.mPosition = mLayoutManager.findFirstVisibleItemPosition();
    if (values.mPosition == RecyclerView.NO_POSITION) {
        return values.reset();
    }
    View firstVisibleView = mLayoutManager.findViewByPosition(values.mPosition);
    if (firstVisibleView == null) {
        return values.reset();
    }
    boolean isHorizontal = mLayoutManager.getOrientation() == ORIENTATION_HORIZONTAL;
    int start, sizePx;
    if (isHorizontal) {
        start = firstVisibleView.getLeft();
        sizePx = firstVisibleView.getWidth();
    } else {
        start = firstVisibleView.getTop();
        sizePx = firstVisibleView.getHeight();
    }
    values.mOffsetPx = -start;
    if (values.mOffsetPx < 0) {
        throw new IllegalStateException(String.format("Page can only be offset by a positive " + "amount, not by %d", values.mOffsetPx));
    }
    values.mOffset = sizePx == 0 ? 0 : (float) values.mOffsetPx / sizePx;
    return values;
}
#end_block

#method_before
public void notifyProgrammaticScroll(int target, boolean smooth) {
    mAdapterState = smooth ? STATE_IN_PROGRESS_SMOOTH_SCROLL : STATE_IN_PROGRESS_IMMEDIATE_SCROLL;
    mTarget = target;
    dispatchStateChanged(ViewPager2.SCROLL_STATE_SETTLING);
    dispatchSelected(target);
}
#method_after
public void notifyProgrammaticScroll(int target, boolean smooth) {
    mAdapterState = smooth ? STATE_IN_PROGRESS_SMOOTH_SCROLL : STATE_IN_PROGRESS_IMMEDIATE_SCROLL;
    boolean hasNewTarget = mTarget != target;
    mTarget = target;
    dispatchStateChanged(SCROLL_STATE_SETTLING);
    if (hasNewTarget) {
        dispatchSelected(target);
    }
}
#end_block

#method_before
private void dispatchStateChanged(@ViewPager2.ScrollState int state) {
    // simplifying the code of the class and enforcing the contract in one place.
    if (mAdapterState == STATE_IN_PROGRESS_IMMEDIATE_SCROLL && mScrollState == ViewPager2.SCROLL_STATE_IDLE) {
        return;
    }
    if (mScrollState == state) {
        return;
    }
    mScrollState = state;
    if (mListener != null) {
        mListener.onPageScrollStateChanged(state);
    }
}
#method_after
private void dispatchStateChanged(@ScrollState int state) {
    // simplifying the code of the class and enforcing the contract in one place.
    if (mAdapterState == STATE_IN_PROGRESS_IMMEDIATE_SCROLL && mScrollState == SCROLL_STATE_IDLE) {
        return;
    }
    if (mScrollState == state) {
        return;
    }
    mScrollState = state;
    if (mListener != null) {
        mListener.onPageScrollStateChanged(state);
    }
}
#end_block

#method_before
@Override
protected Tethering makeTethering() {
    mTethering = mock(Tethering.class);
    return mTethering;
}
#method_after
@Override
protected Tethering makeTethering() {
    return mock(Tethering.class);
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    mContext = InstrumentationRegistry.getContext();
    MockitoAnnotations.initMocks(this);
    when(mMetricsService.defaultNetworkMetrics()).thenReturn(mDefaultNetworkMetrics);
    // http://b/25897652 .
    if (Looper.myLooper() == null) {
        Looper.prepare();
    }
    mServiceContext = new MockContext(InstrumentationRegistry.getContext());
    LocalServices.removeServiceForTest(NetworkPolicyManagerInternal.class);
    LocalServices.addService(NetworkPolicyManagerInternal.class, mNPMI);
    mService = new WrappedConnectivityService(mServiceContext, mNetworkManagementService, mStatsService, mock(INetworkPolicyManager.class), mock(IpConnectivityLog.class));
    // Create local CM before sending system ready so that we can answer
    // getSystemService() correctly.
    mCm = new WrappedConnectivityManager(InstrumentationRegistry.getContext(), mService);
    mService.systemReady();
    mService.mockVpn(Process.myUid());
    mCm.bindProcessToNetwork(null);
    // Ensure that the default setting for Captive Portals is used for most tests
    setCaptivePortalMode(Settings.Global.CAPTIVE_PORTAL_MODE_PROMPT);
    setMobileDataAlwaysOn(false);
    setPrivateDnsSettings(PRIVATE_DNS_MODE_OFF, "ignored.example.com");
}
#method_after
@Before
public void setUp() throws Exception {
    mContext = InstrumentationRegistry.getContext();
    MockitoAnnotations.initMocks(this);
    when(mMetricsService.defaultNetworkMetrics()).thenReturn(mDefaultNetworkMetrics);
    // http://b/25897652 .
    if (Looper.myLooper() == null) {
        Looper.prepare();
    }
    FakeSettingsProvider.clearSettingsProvider();
    mServiceContext = new MockContext(InstrumentationRegistry.getContext(), new FakeSettingsProvider());
    LocalServices.removeServiceForTest(NetworkPolicyManagerInternal.class);
    LocalServices.addService(NetworkPolicyManagerInternal.class, mock(NetworkPolicyManagerInternal.class));
    mService = new WrappedConnectivityService(mServiceContext, mNetworkManagementService, mStatsService, mNpm, mock(IpConnectivityLog.class));
    final ArgumentCaptor<INetworkPolicyListener> policyListenerCaptor = ArgumentCaptor.forClass(INetworkPolicyListener.class);
    verify(mNpm).registerListener(policyListenerCaptor.capture());
    mPolicyListener = policyListenerCaptor.getValue();
    // Create local CM before sending system ready so that we can answer
    // getSystemService() correctly.
    mCm = new WrappedConnectivityManager(InstrumentationRegistry.getContext(), mService);
    mService.systemReady();
    mService.mockVpn(Process.myUid());
    mCm.bindProcessToNetwork(null);
    // Ensure that the default setting for Captive Portals is used for most tests
    setCaptivePortalMode(Settings.Global.CAPTIVE_PORTAL_MODE_PROMPT);
    setAlwaysOnNetworks(false);
    setPrivateDnsSettings(PRIVATE_DNS_MODE_OFF, "ignored.example.com");
}
#end_block

#method_before
@After
public void tearDown() throws Exception {
    setMobileDataAlwaysOn(false);
    if (mCellNetworkAgent != null) {
        mCellNetworkAgent.disconnect();
        mCellNetworkAgent = null;
    }
    if (mWiFiNetworkAgent != null) {
        mWiFiNetworkAgent.disconnect();
        mWiFiNetworkAgent = null;
    }
    if (mEthernetNetworkAgent != null) {
        mEthernetNetworkAgent.disconnect();
        mEthernetNetworkAgent = null;
    }
}
#method_after
@After
public void tearDown() throws Exception {
    setAlwaysOnNetworks(false);
    if (mCellNetworkAgent != null) {
        mCellNetworkAgent.disconnect();
        mCellNetworkAgent = null;
    }
    if (mWiFiNetworkAgent != null) {
        mWiFiNetworkAgent.disconnect();
        mWiFiNetworkAgent = null;
    }
    if (mEthernetNetworkAgent != null) {
        mEthernetNetworkAgent.disconnect();
        mEthernetNetworkAgent = null;
    }
    FakeSettingsProvider.clearSettingsProvider();
}
#end_block

#method_before
// Expects onAvailable and the callbacks that follow it. These are:
// - onSuspended, iff the network was suspended when the callbacks fire.
// - onCapabilitiesChanged.
// - onLinkPropertiesChanged.
// - onUpdateBlockedStatus.
// 
// @param agent the network to expect the callbacks on.
// @param expectSuspended whether to expect a SUSPENDED callback.
// @param expectValidated the expected value of the VALIDATED capability in the
// onCapabilitiesChanged callback.
void expectAvailableCallbacks(MockNetworkAgent agent, boolean expectSuspended, boolean expectValidated, int timeoutMs) {
    expectCallback(CallbackState.AVAILABLE, agent, timeoutMs);
    if (expectSuspended) {
        expectCallback(CallbackState.SUSPENDED, agent, timeoutMs);
    }
    if (expectValidated) {
        expectCapabilitiesWith(NET_CAPABILITY_VALIDATED, agent, timeoutMs);
    } else {
        expectCapabilitiesWithout(NET_CAPABILITY_VALIDATED, agent, timeoutMs);
    }
    expectCallback(CallbackState.LINK_PROPERTIES, agent, timeoutMs);
    expectCallback(CallbackState.BLOCKED_STATUS, agent, timeoutMs);
}
#method_after
// Expects onAvailable and the callbacks that follow it. These are:
// - onSuspended, iff the network was suspended when the callbacks fire.
// - onCapabilitiesChanged.
// - onLinkPropertiesChanged.
// - onBlockedStatusChanged.
// 
// @param agent the network to expect the callbacks on.
// @param expectSuspended whether to expect a SUSPENDED callback.
// @param expectValidated the expected value of the VALIDATED capability in the
// onCapabilitiesChanged callback.
void expectAvailableCallbacks(MockNetworkAgent agent, boolean expectSuspended, boolean expectValidated, boolean expectBlocked, int timeoutMs) {
    expectCallback(CallbackState.AVAILABLE, agent, timeoutMs);
    if (expectSuspended) {
        expectCallback(CallbackState.SUSPENDED, agent, timeoutMs);
    }
    if (expectValidated) {
        expectCapabilitiesWith(NET_CAPABILITY_VALIDATED, agent, timeoutMs);
    } else {
        expectCapabilitiesWithout(NET_CAPABILITY_VALIDATED, agent, timeoutMs);
    }
    expectCallback(CallbackState.LINK_PROPERTIES, agent, timeoutMs);
    expectBlockedStatusCallback(expectBlocked, agent);
}
#end_block

#method_before
void expectAvailableAndSuspendedCallbacks(MockNetworkAgent agent, boolean expectValidated) {
    expectAvailableCallbacks(agent, true, expectValidated, TEST_CALLBACK_TIMEOUT_MS);
}
#method_after
void expectAvailableAndSuspendedCallbacks(MockNetworkAgent agent, boolean expectValidated) {
    expectAvailableCallbacks(agent, true, expectValidated, false, TEST_CALLBACK_TIMEOUT_MS);
}
#end_block

#method_before
void expectAvailableCallbacksValidated(MockNetworkAgent agent) {
    expectAvailableCallbacks(agent, false, true, TEST_CALLBACK_TIMEOUT_MS);
}
#method_after
void expectAvailableCallbacksValidated(MockNetworkAgent agent) {
    expectAvailableCallbacks(agent, false, true, false, TEST_CALLBACK_TIMEOUT_MS);
}
#end_block

#method_before
void expectAvailableCallbacksUnvalidated(MockNetworkAgent agent) {
    expectAvailableCallbacks(agent, false, false, TEST_CALLBACK_TIMEOUT_MS);
}
#method_after
void expectAvailableCallbacksUnvalidated(MockNetworkAgent agent) {
    expectAvailableCallbacks(agent, false, false, false, TEST_CALLBACK_TIMEOUT_MS);
}
#end_block

#method_before
// Expects the available callbacks (where the onCapabilitiesChanged must contain the
// VALIDATED capability), plus another onCapabilitiesChanged which is identical to the
// one we just sent.
void expectAvailableDoubleValidatedCallbacks(MockNetworkAgent agent) {
    expectCallback(CallbackState.AVAILABLE, agent, TEST_CALLBACK_TIMEOUT_MS);
    NetworkCapabilities nc1 = expectCapabilitiesWith(NET_CAPABILITY_VALIDATED, agent);
    expectCallback(CallbackState.LINK_PROPERTIES, agent, TEST_CALLBACK_TIMEOUT_MS);
    expectCallback(CallbackState.BLOCKED_STATUS, agent, TIMEOUT_MS);
    NetworkCapabilities nc2 = expectCapabilitiesWith(NET_CAPABILITY_VALIDATED, agent);
    assertEquals(nc1, nc2);
}
#method_after
// Expects the available callbacks (where the onCapabilitiesChanged must contain the
// VALIDATED capability), plus another onCapabilitiesChanged which is identical to the
// one we just sent.
void expectAvailableDoubleValidatedCallbacks(MockNetworkAgent agent) {
    expectCallback(CallbackState.AVAILABLE, agent, TEST_CALLBACK_TIMEOUT_MS);
    NetworkCapabilities nc1 = expectCapabilitiesWith(NET_CAPABILITY_VALIDATED, agent);
    expectCallback(CallbackState.LINK_PROPERTIES, agent, TEST_CALLBACK_TIMEOUT_MS);
    // Implicitly check the network is allowed to use.
    // TODO: should we need to consider if network is in blocked status in this case?
    expectBlockedStatusCallback(false, agent);
    NetworkCapabilities nc2 = expectCapabilitiesWith(NET_CAPABILITY_VALIDATED, agent);
    assertEquals(nc1, nc2);
}
#end_block

#method_before
@Test
public void testNetworkGoesIntoBackgroundAfterLinger() {
    setMobileDataAlwaysOn(true);
    NetworkRequest request = new NetworkRequest.Builder().clearCapabilities().build();
    TestNetworkCallback callback = new TestNetworkCallback();
    mCm.registerNetworkCallback(request, callback);
    TestNetworkCallback defaultCallback = new TestNetworkCallback();
    mCm.registerDefaultNetworkCallback(defaultCallback);
    mCellNetworkAgent = new MockNetworkAgent(TRANSPORT_CELLULAR);
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    mCellNetworkAgent.connect(true);
    callback.expectAvailableThenValidatedCallbacks(mCellNetworkAgent);
    defaultCallback.expectAvailableThenValidatedCallbacks(mCellNetworkAgent);
    // Wifi comes up and cell lingers.
    mWiFiNetworkAgent.connect(true);
    defaultCallback.expectAvailableDoubleValidatedCallbacks(mWiFiNetworkAgent);
    callback.expectAvailableCallbacksUnvalidated(mWiFiNetworkAgent);
    callback.expectCallback(CallbackState.LOSING, mCellNetworkAgent);
    callback.expectCapabilitiesWith(NET_CAPABILITY_VALIDATED, mWiFiNetworkAgent);
    // File a request for cellular, then release it.
    NetworkRequest cellRequest = new NetworkRequest.Builder().addTransportType(TRANSPORT_CELLULAR).build();
    NetworkCallback noopCallback = new NetworkCallback();
    mCm.requestNetwork(cellRequest, noopCallback);
    mCm.unregisterNetworkCallback(noopCallback);
    callback.expectCallback(CallbackState.LOSING, mCellNetworkAgent);
    // Let linger run its course.
    callback.assertNoCallback();
    final int lingerTimeoutMs = TEST_LINGER_DELAY_MS + TEST_LINGER_DELAY_MS / 4;
    callback.expectCapabilitiesWithout(NET_CAPABILITY_FOREGROUND, mCellNetworkAgent, lingerTimeoutMs);
    // Clean up.
    mCm.unregisterNetworkCallback(defaultCallback);
    mCm.unregisterNetworkCallback(callback);
}
#method_after
@Test
public void testNetworkGoesIntoBackgroundAfterLinger() {
    setAlwaysOnNetworks(true);
    NetworkRequest request = new NetworkRequest.Builder().clearCapabilities().build();
    TestNetworkCallback callback = new TestNetworkCallback();
    mCm.registerNetworkCallback(request, callback);
    TestNetworkCallback defaultCallback = new TestNetworkCallback();
    mCm.registerDefaultNetworkCallback(defaultCallback);
    mCellNetworkAgent = new MockNetworkAgent(TRANSPORT_CELLULAR);
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    mCellNetworkAgent.connect(true);
    callback.expectAvailableThenValidatedCallbacks(mCellNetworkAgent);
    defaultCallback.expectAvailableThenValidatedCallbacks(mCellNetworkAgent);
    // Wifi comes up and cell lingers.
    mWiFiNetworkAgent.connect(true);
    defaultCallback.expectAvailableDoubleValidatedCallbacks(mWiFiNetworkAgent);
    callback.expectAvailableCallbacksUnvalidated(mWiFiNetworkAgent);
    callback.expectCallback(CallbackState.LOSING, mCellNetworkAgent);
    callback.expectCapabilitiesWith(NET_CAPABILITY_VALIDATED, mWiFiNetworkAgent);
    // File a request for cellular, then release it.
    NetworkRequest cellRequest = new NetworkRequest.Builder().addTransportType(TRANSPORT_CELLULAR).build();
    NetworkCallback noopCallback = new NetworkCallback();
    mCm.requestNetwork(cellRequest, noopCallback);
    mCm.unregisterNetworkCallback(noopCallback);
    callback.expectCallback(CallbackState.LOSING, mCellNetworkAgent);
    // Let linger run its course.
    callback.assertNoCallback();
    final int lingerTimeoutMs = TEST_LINGER_DELAY_MS + TEST_LINGER_DELAY_MS / 4;
    callback.expectCapabilitiesWithout(NET_CAPABILITY_FOREGROUND, mCellNetworkAgent, lingerTimeoutMs);
    // Clean up.
    mCm.unregisterNetworkCallback(defaultCallback);
    mCm.unregisterNetworkCallback(callback);
}
#end_block

#method_before
@Test
public void testBackgroundNetworks() throws Exception {
    // Create a background request. We can't do this ourselves because ConnectivityService
    // doesn't have an API for it. So just turn on mobile data always on.
    setMobileDataAlwaysOn(true);
    final NetworkRequest request = new NetworkRequest.Builder().build();
    final NetworkRequest fgRequest = new NetworkRequest.Builder().addCapability(NET_CAPABILITY_FOREGROUND).build();
    final TestNetworkCallback callback = new TestNetworkCallback();
    final TestNetworkCallback fgCallback = new TestNetworkCallback();
    mCm.registerNetworkCallback(request, callback);
    mCm.registerNetworkCallback(fgRequest, fgCallback);
    mCellNetworkAgent = new MockNetworkAgent(TRANSPORT_CELLULAR);
    mCellNetworkAgent.connect(true);
    callback.expectAvailableThenValidatedCallbacks(mCellNetworkAgent);
    fgCallback.expectAvailableThenValidatedCallbacks(mCellNetworkAgent);
    assertTrue(isForegroundNetwork(mCellNetworkAgent));
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    mWiFiNetworkAgent.connect(true);
    // When wifi connects, cell lingers.
    callback.expectAvailableCallbacksUnvalidated(mWiFiNetworkAgent);
    callback.expectCallback(CallbackState.LOSING, mCellNetworkAgent);
    callback.expectCapabilitiesWith(NET_CAPABILITY_VALIDATED, mWiFiNetworkAgent);
    fgCallback.expectAvailableCallbacksUnvalidated(mWiFiNetworkAgent);
    fgCallback.expectCallback(CallbackState.LOSING, mCellNetworkAgent);
    fgCallback.expectCapabilitiesWith(NET_CAPABILITY_VALIDATED, mWiFiNetworkAgent);
    assertTrue(isForegroundNetwork(mCellNetworkAgent));
    assertTrue(isForegroundNetwork(mWiFiNetworkAgent));
    // When lingering is complete, cell is still there but is now in the background.
    waitForIdle();
    int timeoutMs = TEST_LINGER_DELAY_MS + TEST_LINGER_DELAY_MS / 4;
    fgCallback.expectCallback(CallbackState.LOST, mCellNetworkAgent, timeoutMs);
    // Expect a network capabilities update sans FOREGROUND.
    callback.expectCapabilitiesWithout(NET_CAPABILITY_FOREGROUND, mCellNetworkAgent);
    assertFalse(isForegroundNetwork(mCellNetworkAgent));
    assertTrue(isForegroundNetwork(mWiFiNetworkAgent));
    // File a cell request and check that cell comes into the foreground.
    final NetworkRequest cellRequest = new NetworkRequest.Builder().addTransportType(TRANSPORT_CELLULAR).build();
    final TestNetworkCallback cellCallback = new TestNetworkCallback();
    mCm.requestNetwork(cellRequest, cellCallback);
    // NOTE: This request causes the network's capabilities to change. This
    // is currently delivered before the onAvailable() callbacks.
    // TODO: Fix this.
    cellCallback.expectCapabilitiesWith(NET_CAPABILITY_FOREGROUND, mCellNetworkAgent);
    cellCallback.expectAvailableCallbacksValidated(mCellNetworkAgent);
    fgCallback.expectAvailableCallbacksValidated(mCellNetworkAgent);
    // Expect a network capabilities update with FOREGROUND, because the most recent
    // request causes its state to change.
    callback.expectCapabilitiesWith(NET_CAPABILITY_FOREGROUND, mCellNetworkAgent);
    assertTrue(isForegroundNetwork(mCellNetworkAgent));
    assertTrue(isForegroundNetwork(mWiFiNetworkAgent));
    // Release the request. The network immediately goes into the background, since it was not
    // lingering.
    mCm.unregisterNetworkCallback(cellCallback);
    fgCallback.expectCallback(CallbackState.LOST, mCellNetworkAgent);
    // Expect a network capabilities update sans FOREGROUND.
    callback.expectCapabilitiesWithout(NET_CAPABILITY_FOREGROUND, mCellNetworkAgent);
    assertFalse(isForegroundNetwork(mCellNetworkAgent));
    assertTrue(isForegroundNetwork(mWiFiNetworkAgent));
    // Disconnect wifi and check that cell is foreground again.
    mWiFiNetworkAgent.disconnect();
    callback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    fgCallback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    fgCallback.expectAvailableCallbacksValidated(mCellNetworkAgent);
    assertTrue(isForegroundNetwork(mCellNetworkAgent));
    mCm.unregisterNetworkCallback(callback);
    mCm.unregisterNetworkCallback(fgCallback);
}
#method_after
@Test
public void testBackgroundNetworks() throws Exception {
    // Create a background request. We can't do this ourselves because ConnectivityService
    // doesn't have an API for it. So just turn on mobile data always on.
    setAlwaysOnNetworks(true);
    final NetworkRequest request = new NetworkRequest.Builder().build();
    final NetworkRequest fgRequest = new NetworkRequest.Builder().addCapability(NET_CAPABILITY_FOREGROUND).build();
    final TestNetworkCallback callback = new TestNetworkCallback();
    final TestNetworkCallback fgCallback = new TestNetworkCallback();
    mCm.registerNetworkCallback(request, callback);
    mCm.registerNetworkCallback(fgRequest, fgCallback);
    mCellNetworkAgent = new MockNetworkAgent(TRANSPORT_CELLULAR);
    mCellNetworkAgent.connect(true);
    callback.expectAvailableThenValidatedCallbacks(mCellNetworkAgent);
    fgCallback.expectAvailableThenValidatedCallbacks(mCellNetworkAgent);
    assertTrue(isForegroundNetwork(mCellNetworkAgent));
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    mWiFiNetworkAgent.connect(true);
    // When wifi connects, cell lingers.
    callback.expectAvailableCallbacksUnvalidated(mWiFiNetworkAgent);
    callback.expectCallback(CallbackState.LOSING, mCellNetworkAgent);
    callback.expectCapabilitiesWith(NET_CAPABILITY_VALIDATED, mWiFiNetworkAgent);
    fgCallback.expectAvailableCallbacksUnvalidated(mWiFiNetworkAgent);
    fgCallback.expectCallback(CallbackState.LOSING, mCellNetworkAgent);
    fgCallback.expectCapabilitiesWith(NET_CAPABILITY_VALIDATED, mWiFiNetworkAgent);
    assertTrue(isForegroundNetwork(mCellNetworkAgent));
    assertTrue(isForegroundNetwork(mWiFiNetworkAgent));
    // When lingering is complete, cell is still there but is now in the background.
    waitForIdle();
    int timeoutMs = TEST_LINGER_DELAY_MS + TEST_LINGER_DELAY_MS / 4;
    fgCallback.expectCallback(CallbackState.LOST, mCellNetworkAgent, timeoutMs);
    // Expect a network capabilities update sans FOREGROUND.
    callback.expectCapabilitiesWithout(NET_CAPABILITY_FOREGROUND, mCellNetworkAgent);
    assertFalse(isForegroundNetwork(mCellNetworkAgent));
    assertTrue(isForegroundNetwork(mWiFiNetworkAgent));
    // File a cell request and check that cell comes into the foreground.
    final NetworkRequest cellRequest = new NetworkRequest.Builder().addTransportType(TRANSPORT_CELLULAR).build();
    final TestNetworkCallback cellCallback = new TestNetworkCallback();
    mCm.requestNetwork(cellRequest, cellCallback);
    // NOTE: This request causes the network's capabilities to change. This
    // is currently delivered before the onAvailable() callbacks.
    // TODO: Fix this.
    cellCallback.expectCapabilitiesWith(NET_CAPABILITY_FOREGROUND, mCellNetworkAgent);
    cellCallback.expectAvailableCallbacksValidated(mCellNetworkAgent);
    fgCallback.expectAvailableCallbacksValidated(mCellNetworkAgent);
    // Expect a network capabilities update with FOREGROUND, because the most recent
    // request causes its state to change.
    callback.expectCapabilitiesWith(NET_CAPABILITY_FOREGROUND, mCellNetworkAgent);
    assertTrue(isForegroundNetwork(mCellNetworkAgent));
    assertTrue(isForegroundNetwork(mWiFiNetworkAgent));
    // Release the request. The network immediately goes into the background, since it was not
    // lingering.
    mCm.unregisterNetworkCallback(cellCallback);
    fgCallback.expectCallback(CallbackState.LOST, mCellNetworkAgent);
    // Expect a network capabilities update sans FOREGROUND.
    callback.expectCapabilitiesWithout(NET_CAPABILITY_FOREGROUND, mCellNetworkAgent);
    assertFalse(isForegroundNetwork(mCellNetworkAgent));
    assertTrue(isForegroundNetwork(mWiFiNetworkAgent));
    // Disconnect wifi and check that cell is foreground again.
    mWiFiNetworkAgent.disconnect();
    callback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    fgCallback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    fgCallback.expectAvailableCallbacksValidated(mCellNetworkAgent);
    assertTrue(isForegroundNetwork(mCellNetworkAgent));
    mCm.unregisterNetworkCallback(callback);
    mCm.unregisterNetworkCallback(fgCallback);
}
#end_block

#method_before
@Test
public void testMobileDataAlwaysOn() throws Exception {
    final TestNetworkCallback cellNetworkCallback = new TestNetworkCallback();
    final NetworkRequest cellRequest = new NetworkRequest.Builder().addTransportType(TRANSPORT_CELLULAR).build();
    mCm.registerNetworkCallback(cellRequest, cellNetworkCallback);
    final HandlerThread handlerThread = new HandlerThread("MobileDataAlwaysOnFactory");
    handlerThread.start();
    NetworkCapabilities filter = new NetworkCapabilities().addTransportType(TRANSPORT_CELLULAR).addCapability(NET_CAPABILITY_INTERNET);
    final MockNetworkFactory testFactory = new MockNetworkFactory(handlerThread.getLooper(), mServiceContext, "testFactory", filter);
    testFactory.setScoreFilter(40);
    // Register the factory and expect it to start looking for a network.
    testFactory.expectAddRequests(1);
    testFactory.register();
    testFactory.waitForNetworkRequests(1);
    assertTrue(testFactory.getMyStartRequested());
    // Bring up wifi. The factory stops looking for a network.
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    // Because the default request changes score twice.
    testFactory.expectAddRequests(2);
    mWiFiNetworkAgent.connect(true);
    testFactory.waitForNetworkRequests(1);
    assertFalse(testFactory.getMyStartRequested());
    ContentResolver cr = mServiceContext.getContentResolver();
    // Turn on mobile data always on. The factory starts looking again.
    testFactory.expectAddRequests(1);
    setMobileDataAlwaysOn(true);
    testFactory.waitForNetworkRequests(2);
    assertTrue(testFactory.getMyStartRequested());
    // Bring up cell data and check that the factory stops looking.
    assertLength(1, mCm.getAllNetworks());
    mCellNetworkAgent = new MockNetworkAgent(TRANSPORT_CELLULAR);
    // Because the cell request changes score twice.
    testFactory.expectAddRequests(2);
    mCellNetworkAgent.connect(true);
    cellNetworkCallback.expectAvailableThenValidatedCallbacks(mCellNetworkAgent);
    testFactory.waitForNetworkRequests(2);
    // Because the cell network outscores us.
    assertFalse(testFactory.getMyStartRequested());
    // Check that cell data stays up.
    waitForIdle();
    verifyActiveNetwork(TRANSPORT_WIFI);
    assertLength(2, mCm.getAllNetworks());
    // Turn off mobile data always on and expect the request to disappear...
    testFactory.expectRemoveRequests(1);
    setMobileDataAlwaysOn(false);
    testFactory.waitForNetworkRequests(1);
    // ...  and cell data to be torn down.
    cellNetworkCallback.expectCallback(CallbackState.LOST, mCellNetworkAgent);
    assertLength(1, mCm.getAllNetworks());
    testFactory.unregister();
    mCm.unregisterNetworkCallback(cellNetworkCallback);
    handlerThread.quit();
}
#method_after
@Test
public void testMobileDataAlwaysOn() throws Exception {
    final TestNetworkCallback cellNetworkCallback = new TestNetworkCallback();
    final NetworkRequest cellRequest = new NetworkRequest.Builder().addTransportType(TRANSPORT_CELLULAR).build();
    mCm.registerNetworkCallback(cellRequest, cellNetworkCallback);
    final HandlerThread handlerThread = new HandlerThread("MobileDataAlwaysOnFactory");
    handlerThread.start();
    NetworkCapabilities filter = new NetworkCapabilities().addTransportType(TRANSPORT_CELLULAR).addCapability(NET_CAPABILITY_INTERNET);
    final MockNetworkFactory testFactory = new MockNetworkFactory(handlerThread.getLooper(), mServiceContext, "testFactory", filter);
    testFactory.setScoreFilter(40);
    // Register the factory and expect it to start looking for a network.
    testFactory.expectAddRequests(1);
    testFactory.register();
    testFactory.waitForNetworkRequests(1);
    assertTrue(testFactory.getMyStartRequested());
    // Bring up wifi. The factory stops looking for a network.
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    // Because the default request changes score twice.
    testFactory.expectAddRequests(2);
    mWiFiNetworkAgent.connect(true);
    testFactory.waitForNetworkRequests(1);
    assertFalse(testFactory.getMyStartRequested());
    ContentResolver cr = mServiceContext.getContentResolver();
    // Turn on mobile data always on. The factory starts looking again.
    testFactory.expectAddRequests(1);
    setAlwaysOnNetworks(true);
    testFactory.waitForNetworkRequests(2);
    assertTrue(testFactory.getMyStartRequested());
    // Bring up cell data and check that the factory stops looking.
    assertLength(1, mCm.getAllNetworks());
    mCellNetworkAgent = new MockNetworkAgent(TRANSPORT_CELLULAR);
    // Because the cell request changes score twice.
    testFactory.expectAddRequests(2);
    mCellNetworkAgent.connect(true);
    cellNetworkCallback.expectAvailableThenValidatedCallbacks(mCellNetworkAgent);
    testFactory.waitForNetworkRequests(2);
    // Because the cell network outscores us.
    assertFalse(testFactory.getMyStartRequested());
    // Check that cell data stays up.
    waitForIdle();
    verifyActiveNetwork(TRANSPORT_WIFI);
    assertLength(2, mCm.getAllNetworks());
    // Turn off mobile data always on and expect the request to disappear...
    testFactory.expectRemoveRequests(1);
    setAlwaysOnNetworks(false);
    testFactory.waitForNetworkRequests(1);
    // ...  and cell data to be torn down.
    cellNetworkCallback.expectCallback(CallbackState.LOST, mCellNetworkAgent);
    assertLength(1, mCm.getAllNetworks());
    testFactory.unregister();
    mCm.unregisterNetworkCallback(cellNetworkCallback);
    handlerThread.quit();
}
#end_block

#method_before
@Test
public void testSatisfiedNetworkRequestDoesNotTriggerOnUnavailable() {
    NetworkRequest nr = new NetworkRequest.Builder().addTransportType(NetworkCapabilities.TRANSPORT_WIFI).build();
    final TestNetworkCallback networkCallback = new TestNetworkCallback();
    mCm.requestNetwork(nr, networkCallback, TEST_REQUEST_TIMEOUT_MS);
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    mWiFiNetworkAgent.connect(false);
    networkCallback.expectAvailableCallbacks(mWiFiNetworkAgent, false, false, TEST_CALLBACK_TIMEOUT_MS);
    // pass timeout and validate that UNAVAILABLE is not called
    networkCallback.assertNoCallback();
}
#method_after
@Test
public void testSatisfiedNetworkRequestDoesNotTriggerOnUnavailable() {
    NetworkRequest nr = new NetworkRequest.Builder().addTransportType(NetworkCapabilities.TRANSPORT_WIFI).build();
    final TestNetworkCallback networkCallback = new TestNetworkCallback();
    mCm.requestNetwork(nr, networkCallback, TEST_REQUEST_TIMEOUT_MS);
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    mWiFiNetworkAgent.connect(false);
    networkCallback.expectAvailableCallbacks(mWiFiNetworkAgent, false, false, false, TEST_CALLBACK_TIMEOUT_MS);
    // pass timeout and validate that UNAVAILABLE is not called
    networkCallback.assertNoCallback();
}
#end_block

#method_before
@Test
public void testSatisfiedThenLostNetworkRequestDoesNotTriggerOnUnavailable() {
    NetworkRequest nr = new NetworkRequest.Builder().addTransportType(NetworkCapabilities.TRANSPORT_WIFI).build();
    final TestNetworkCallback networkCallback = new TestNetworkCallback();
    mCm.requestNetwork(nr, networkCallback, TEST_REQUEST_TIMEOUT_MS);
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    mWiFiNetworkAgent.connect(false);
    networkCallback.expectAvailableCallbacks(mWiFiNetworkAgent, false, false, TEST_CALLBACK_TIMEOUT_MS);
    mWiFiNetworkAgent.disconnect();
    networkCallback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    // Validate that UNAVAILABLE is not called
    networkCallback.assertNoCallback();
}
#method_after
@Test
public void testSatisfiedThenLostNetworkRequestDoesNotTriggerOnUnavailable() {
    NetworkRequest nr = new NetworkRequest.Builder().addTransportType(NetworkCapabilities.TRANSPORT_WIFI).build();
    final TestNetworkCallback networkCallback = new TestNetworkCallback();
    mCm.requestNetwork(nr, networkCallback, TEST_REQUEST_TIMEOUT_MS);
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    mWiFiNetworkAgent.connect(false);
    networkCallback.expectAvailableCallbacks(mWiFiNetworkAgent, false, false, false, TEST_CALLBACK_TIMEOUT_MS);
    mWiFiNetworkAgent.disconnect();
    networkCallback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    // Validate that UNAVAILABLE is not called
    networkCallback.assertNoCallback();
}
#end_block

#method_before
@VisibleForTesting
protected Tethering makeTethering() {
    // TODO: Move other elements into @Overridden getters.
    final TetheringDependencies deps = new TetheringDependencies() {

        @Override
        public boolean isTetheringSupported() {
            return ConnectivityService.this.isTetheringSupported();
        }

        @Override
        public NetworkRequest getDefaultNetworkRequest() {
            return mDefaultRequest;
        }
    };
    return new Tethering(mContext, mNetd, mStatsService, mPolicyManager, IoThread.get().getLooper(), new MockableSystemProperties(), deps);
}
#method_after
@VisibleForTesting
protected Tethering makeTethering() {
    // TODO: Move other elements into @Overridden getters.
    final TetheringDependencies deps = new TetheringDependencies() {

        @Override
        public boolean isTetheringSupported() {
            return ConnectivityService.this.isTetheringSupported();
        }

        @Override
        public NetworkRequest getDefaultNetworkRequest() {
            return mDefaultRequest;
        }
    };
    return new Tethering(mContext, mNMS, mStatsService, mPolicyManager, IoThread.get().getLooper(), new MockableSystemProperties(), deps);
}
#end_block

#method_before
private void registerSettingsCallbacks() {
    // Watch for global HTTP proxy changes.
    mSettingsObserver.observe(Settings.Global.getUriFor(Settings.Global.HTTP_PROXY), EVENT_APPLY_GLOBAL_HTTP_PROXY);
    // Watch for whether or not to keep mobile data always on.
    mSettingsObserver.observe(Settings.Global.getUriFor(Settings.Global.MOBILE_DATA_ALWAYS_ON), EVENT_CONFIGURE_MOBILE_DATA_ALWAYS_ON);
}
#method_after
private void registerSettingsCallbacks() {
    // Watch for global HTTP proxy changes.
    mSettingsObserver.observe(Settings.Global.getUriFor(Settings.Global.HTTP_PROXY), EVENT_APPLY_GLOBAL_HTTP_PROXY);
    // Watch for whether or not to keep mobile data always on.
    mSettingsObserver.observe(Settings.Global.getUriFor(Settings.Global.MOBILE_DATA_ALWAYS_ON), EVENT_CONFIGURE_ALWAYS_ON_NETWORKS);
    // Watch for whether or not to keep wifi always on.
    mSettingsObserver.observe(Settings.Global.getUriFor(Settings.Global.WIFI_ALWAYS_REQUESTED), EVENT_CONFIGURE_ALWAYS_ON_NETWORKS);
}
#end_block

#method_before
private boolean isNetworkWithLinkPropertiesBlocked(LinkProperties lp, int uid, boolean ignoreBlocked) {
    // Networks aren't blocked when ignoring blocked status
    if (ignoreBlocked) {
        return false;
    }
    synchronized (mVpns) {
        final Vpn vpn = mVpns.get(UserHandle.getUserId(uid));
        if (vpn != null && vpn.isBlockingUid(uid)) {
            return true;
        }
    }
    final String iface = (lp == null ? "" : lp.getInterfaceName());
    return mPolicyManagerInternal.isUidNetworkingBlocked(uid, iface);
}
#method_after
private boolean isNetworkWithLinkPropertiesBlocked(LinkProperties lp, int uid, boolean ignoreBlocked) {
    // Networks aren't blocked when ignoring blocked status
    if (ignoreBlocked) {
        return false;
    }
    // TODO: consider moving this check to NetworkPolicyManagerInternal.isUidNetworkingBlocked.
    if (isSystem(uid)) {
        return false;
    }
    synchronized (mVpns) {
        final Vpn vpn = mVpns.get(UserHandle.getUserId(uid));
        if (vpn != null && vpn.isBlockingUid(uid)) {
            return true;
        }
    }
    final String iface = (lp == null ? "" : lp.getInterfaceName());
    return mPolicyManagerInternal.isUidNetworkingBlocked(uid, iface);
}
#end_block

#method_before
@Override
public boolean requestRouteToHostAddress(int networkType, byte[] hostAddress) {
    enforceChangePermission();
    if (mProtectedNetworks.contains(networkType)) {
        enforceConnectivityInternalPermission();
    }
    InetAddress addr;
    try {
        addr = InetAddress.getByAddress(hostAddress);
    } catch (UnknownHostException e) {
        if (DBG)
            log("requestRouteToHostAddress got " + e.toString());
        return false;
    }
    if (!ConnectivityManager.isNetworkTypeValid(networkType)) {
        if (DBG)
            log("requestRouteToHostAddress on invalid network: " + networkType);
        return false;
    }
    NetworkAgentInfo nai = mLegacyTypeTracker.getNetworkForType(networkType);
    if (nai == null) {
        if (mLegacyTypeTracker.isTypeSupported(networkType) == false) {
            if (DBG)
                log("requestRouteToHostAddress on unsupported network: " + networkType);
        } else {
            if (DBG)
                log("requestRouteToHostAddress on down network: " + networkType);
        }
        return false;
    }
    DetailedState netState;
    synchronized (nai) {
        netState = nai.networkInfo.getDetailedState();
    }
    if (netState != DetailedState.CONNECTED && netState != DetailedState.CAPTIVE_PORTAL_CHECK) {
        if (VDBG) {
            log("requestRouteToHostAddress on down network " + "(" + networkType + ") - dropped" + " netState=" + netState);
        }
        return false;
    }
    final int uid = Binder.getCallingUid();
    final long token = Binder.clearCallingIdentity();
    try {
        LinkProperties lp;
        int netId;
        synchronized (nai) {
            lp = nai.linkProperties;
            netId = nai.network.netId;
        }
        boolean ok = addLegacyRouteToHost(lp, addr, netId, uid);
        if (DBG)
            log("requestRouteToHostAddress ok=" + ok);
        return ok;
    } finally {
        Binder.restoreCallingIdentity(token);
    }
}
#method_after
@Override
public boolean requestRouteToHostAddress(int networkType, byte[] hostAddress) {
    if (disallowedBecauseSystemCaller()) {
        return false;
    }
    enforceChangePermission();
    if (mProtectedNetworks.contains(networkType)) {
        enforceConnectivityInternalPermission();
    }
    InetAddress addr;
    try {
        addr = InetAddress.getByAddress(hostAddress);
    } catch (UnknownHostException e) {
        if (DBG)
            log("requestRouteToHostAddress got " + e.toString());
        return false;
    }
    if (!ConnectivityManager.isNetworkTypeValid(networkType)) {
        if (DBG)
            log("requestRouteToHostAddress on invalid network: " + networkType);
        return false;
    }
    NetworkAgentInfo nai = mLegacyTypeTracker.getNetworkForType(networkType);
    if (nai == null) {
        if (mLegacyTypeTracker.isTypeSupported(networkType) == false) {
            if (DBG)
                log("requestRouteToHostAddress on unsupported network: " + networkType);
        } else {
            if (DBG)
                log("requestRouteToHostAddress on down network: " + networkType);
        }
        return false;
    }
    DetailedState netState;
    synchronized (nai) {
        netState = nai.networkInfo.getDetailedState();
    }
    if (netState != DetailedState.CONNECTED && netState != DetailedState.CAPTIVE_PORTAL_CHECK) {
        if (VDBG) {
            log("requestRouteToHostAddress on down network " + "(" + networkType + ") - dropped" + " netState=" + netState);
        }
        return false;
    }
    final int uid = Binder.getCallingUid();
    final long token = Binder.clearCallingIdentity();
    try {
        LinkProperties lp;
        int netId;
        synchronized (nai) {
            lp = nai.linkProperties;
            netId = nai.network.netId;
        }
        boolean ok = addLegacyRouteToHost(lp, addr, netId, uid);
        if (DBG)
            log("requestRouteToHostAddress ok=" + ok);
        return ok;
    } finally {
        Binder.restoreCallingIdentity(token);
    }
}
#end_block

#method_before
private boolean addLegacyRouteToHost(LinkProperties lp, InetAddress addr, int netId, int uid) {
    RouteInfo bestRoute = RouteInfo.selectBestRoute(lp.getAllRoutes(), addr);
    if (bestRoute == null) {
        bestRoute = RouteInfo.makeHostRoute(addr, lp.getInterfaceName());
    } else {
        String iface = bestRoute.getInterface();
        if (bestRoute.getGateway().equals(addr)) {
            // if there is no better route, add the implied hostroute for our gateway
            bestRoute = RouteInfo.makeHostRoute(addr, iface);
        } else {
            // if we will connect to this through another route, add a direct route
            // to it's gateway
            bestRoute = RouteInfo.makeHostRoute(addr, bestRoute.getGateway(), iface);
        }
    }
    if (DBG)
        log("Adding legacy route " + bestRoute + " for UID/PID " + uid + "/" + Binder.getCallingPid());
    try {
        mNetd.addLegacyRouteForNetId(netId, bestRoute, uid);
    } catch (Exception e) {
        // never crash - catch them all
        if (DBG)
            loge("Exception trying to add a route: " + e);
        return false;
    }
    return true;
}
#method_after
private boolean addLegacyRouteToHost(LinkProperties lp, InetAddress addr, int netId, int uid) {
    RouteInfo bestRoute = RouteInfo.selectBestRoute(lp.getAllRoutes(), addr);
    if (bestRoute == null) {
        bestRoute = RouteInfo.makeHostRoute(addr, lp.getInterfaceName());
    } else {
        String iface = bestRoute.getInterface();
        if (bestRoute.getGateway().equals(addr)) {
            // if there is no better route, add the implied hostroute for our gateway
            bestRoute = RouteInfo.makeHostRoute(addr, iface);
        } else {
            // if we will connect to this through another route, add a direct route
            // to it's gateway
            bestRoute = RouteInfo.makeHostRoute(addr, bestRoute.getGateway(), iface);
        }
    }
    if (DBG)
        log("Adding legacy route " + bestRoute + " for UID/PID " + uid + "/" + Binder.getCallingPid());
    try {
        mNMS.addLegacyRouteForNetId(netId, bestRoute, uid);
    } catch (Exception e) {
        // never crash - catch them all
        if (DBG)
            loge("Exception trying to add a route: " + e);
        return false;
    }
    return true;
}
#end_block

#method_before
private void sendStickyBroadcast(Intent intent) {
    synchronized (this) {
        if (!mSystemReady) {
            mInitialBroadcast = new Intent(intent);
        }
        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
        if (VDBG) {
            log("sendStickyBroadcast: action=" + intent.getAction());
        }
        Bundle options = null;
        final long ident = Binder.clearCallingIdentity();
        if (ConnectivityManager.CONNECTIVITY_ACTION.equals(intent.getAction())) {
            final NetworkInfo ni = intent.getParcelableExtra(ConnectivityManager.EXTRA_NETWORK_INFO);
            if (ni.getType() == ConnectivityManager.TYPE_MOBILE_SUPL) {
                intent.setAction(ConnectivityManager.CONNECTIVITY_ACTION_SUPL);
                intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
            } else {
                BroadcastOptions opts = BroadcastOptions.makeBasic();
                opts.setMaxManifestReceiverApiLevel(Build.VERSION_CODES.M);
                options = opts.toBundle();
            }
            final IBatteryStats bs = BatteryStatsService.getService();
            try {
                bs.noteConnectivityChanged(intent.getIntExtra(ConnectivityManager.EXTRA_NETWORK_TYPE, ConnectivityManager.TYPE_NONE), ni.getState().toString());
            } catch (RemoteException e) {
            }
            intent.addFlags(Intent.FLAG_RECEIVER_VISIBLE_TO_INSTANT_APPS);
        }
        try {
            mContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL, options);
        } finally {
            Binder.restoreCallingIdentity(ident);
        }
    }
}
#method_after
private void sendStickyBroadcast(Intent intent) {
    synchronized (this) {
        if (!mSystemReady && intent.getAction().equals(ConnectivityManager.CONNECTIVITY_ACTION)) {
            mInitialBroadcast = new Intent(intent);
        }
        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
        if (VDBG) {
            log("sendStickyBroadcast: action=" + intent.getAction());
        }
        Bundle options = null;
        final long ident = Binder.clearCallingIdentity();
        if (ConnectivityManager.CONNECTIVITY_ACTION.equals(intent.getAction())) {
            final NetworkInfo ni = intent.getParcelableExtra(ConnectivityManager.EXTRA_NETWORK_INFO);
            if (ni.getType() == ConnectivityManager.TYPE_MOBILE_SUPL) {
                intent.setAction(ConnectivityManager.CONNECTIVITY_ACTION_SUPL);
                intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
            } else {
                BroadcastOptions opts = BroadcastOptions.makeBasic();
                opts.setMaxManifestReceiverApiLevel(Build.VERSION_CODES.M);
                options = opts.toBundle();
            }
            final IBatteryStats bs = BatteryStatsService.getService();
            try {
                bs.noteConnectivityChanged(intent.getIntExtra(ConnectivityManager.EXTRA_NETWORK_TYPE, ConnectivityManager.TYPE_NONE), ni.getState().toString());
            } catch (RemoteException e) {
            }
            intent.addFlags(Intent.FLAG_RECEIVER_VISIBLE_TO_INSTANT_APPS);
        }
        try {
            mContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL, options);
        } finally {
            Binder.restoreCallingIdentity(ident);
        }
    }
}
#end_block

#method_before
void systemReady() {
    loadGlobalProxy();
    registerNetdEventCallback();
    synchronized (this) {
        mSystemReady = true;
        if (mInitialBroadcast != null) {
            mContext.sendStickyBroadcastAsUser(mInitialBroadcast, UserHandle.ALL);
            mInitialBroadcast = null;
        }
    }
    // load the global proxy at startup
    mHandler.sendMessage(mHandler.obtainMessage(EVENT_APPLY_GLOBAL_HTTP_PROXY));
    // Try bringing up tracker, but KeyStore won't be ready yet for secondary users so wait
    // for user to unlock device too.
    updateLockdownVpn();
    // Configure whether mobile data is always on.
    mHandler.sendMessage(mHandler.obtainMessage(EVENT_CONFIGURE_MOBILE_DATA_ALWAYS_ON));
    mHandler.sendMessage(mHandler.obtainMessage(EVENT_SYSTEM_READY));
    mPermissionMonitor.startMonitoring();
}
#method_after
void systemReady() {
    mProxyTracker.loadGlobalProxy();
    registerNetdEventCallback();
    synchronized (this) {
        mSystemReady = true;
        if (mInitialBroadcast != null) {
            mContext.sendStickyBroadcastAsUser(mInitialBroadcast, UserHandle.ALL);
            mInitialBroadcast = null;
        }
    }
    // Try bringing up tracker, but KeyStore won't be ready yet for secondary users so wait
    // for user to unlock device too.
    updateLockdownVpn();
    // Create network requests for always-on networks.
    mHandler.sendMessage(mHandler.obtainMessage(EVENT_CONFIGURE_ALWAYS_ON_NETWORKS));
    mHandler.sendMessage(mHandler.obtainMessage(EVENT_SYSTEM_READY));
    mPermissionMonitor.startMonitoring();
}
#end_block

#method_before
private void setupDataActivityTracking(NetworkAgentInfo networkAgent) {
    final String iface = networkAgent.linkProperties.getInterfaceName();
    final int timeout;
    int type = ConnectivityManager.TYPE_NONE;
    if (networkAgent.networkCapabilities.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
        timeout = Settings.Global.getInt(mContext.getContentResolver(), Settings.Global.DATA_ACTIVITY_TIMEOUT_MOBILE, 10);
        type = ConnectivityManager.TYPE_MOBILE;
    } else if (networkAgent.networkCapabilities.hasTransport(NetworkCapabilities.TRANSPORT_WIFI)) {
        timeout = Settings.Global.getInt(mContext.getContentResolver(), Settings.Global.DATA_ACTIVITY_TIMEOUT_WIFI, 15);
        type = ConnectivityManager.TYPE_WIFI;
    } else {
        // do not track any other networks
        timeout = 0;
    }
    if (timeout > 0 && iface != null && type != ConnectivityManager.TYPE_NONE) {
        try {
            mNetd.addIdleTimer(iface, timeout, type);
        } catch (Exception e) {
            // You shall not crash!
            loge("Exception in setupDataActivityTracking " + e);
        }
    }
}
#method_after
private void setupDataActivityTracking(NetworkAgentInfo networkAgent) {
    final String iface = networkAgent.linkProperties.getInterfaceName();
    final int timeout;
    int type = ConnectivityManager.TYPE_NONE;
    if (networkAgent.networkCapabilities.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
        timeout = Settings.Global.getInt(mContext.getContentResolver(), Settings.Global.DATA_ACTIVITY_TIMEOUT_MOBILE, 10);
        type = ConnectivityManager.TYPE_MOBILE;
    } else if (networkAgent.networkCapabilities.hasTransport(NetworkCapabilities.TRANSPORT_WIFI)) {
        timeout = Settings.Global.getInt(mContext.getContentResolver(), Settings.Global.DATA_ACTIVITY_TIMEOUT_WIFI, 15);
        type = ConnectivityManager.TYPE_WIFI;
    } else {
        // do not track any other networks
        timeout = 0;
    }
    if (timeout > 0 && iface != null && type != ConnectivityManager.TYPE_NONE) {
        try {
            mNMS.addIdleTimer(iface, timeout, type);
        } catch (Exception e) {
            // You shall not crash!
            loge("Exception in setupDataActivityTracking " + e);
        }
    }
}
#end_block

#method_before
private void removeDataActivityTracking(NetworkAgentInfo networkAgent) {
    final String iface = networkAgent.linkProperties.getInterfaceName();
    final NetworkCapabilities caps = networkAgent.networkCapabilities;
    if (iface != null && (caps.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR) || caps.hasTransport(NetworkCapabilities.TRANSPORT_WIFI))) {
        try {
            // the call fails silently if no idle timer setup for this interface
            mNetd.removeIdleTimer(iface);
        } catch (Exception e) {
            loge("Exception in removeDataActivityTracking " + e);
        }
    }
}
#method_after
private void removeDataActivityTracking(NetworkAgentInfo networkAgent) {
    final String iface = networkAgent.linkProperties.getInterfaceName();
    final NetworkCapabilities caps = networkAgent.networkCapabilities;
    if (iface != null && (caps.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR) || caps.hasTransport(NetworkCapabilities.TRANSPORT_WIFI))) {
        try {
            // the call fails silently if no idle timer setup for this interface
            mNMS.removeIdleTimer(iface);
        } catch (Exception e) {
            loge("Exception in removeDataActivityTracking " + e);
        }
    }
}
#end_block

#method_before
private void updateMtu(LinkProperties newLp, LinkProperties oldLp) {
    final String iface = newLp.getInterfaceName();
    final int mtu = newLp.getMtu();
    if (oldLp == null && mtu == 0) {
        // Silently ignore unset MTU value.
        return;
    }
    if (oldLp != null && newLp.isIdenticalMtu(oldLp)) {
        if (VDBG)
            log("identical MTU - not setting");
        return;
    }
    if (LinkProperties.isValidMtu(mtu, newLp.hasGlobalIPv6Address()) == false) {
        if (mtu != 0)
            loge("Unexpected mtu value: " + mtu + ", " + iface);
        return;
    }
    // Cannot set MTU without interface name
    if (TextUtils.isEmpty(iface)) {
        loge("Setting MTU size with null iface.");
        return;
    }
    try {
        if (VDBG)
            log("Setting MTU size: " + iface + ", " + mtu);
        mNetd.setMtu(iface, mtu);
    } catch (Exception e) {
        Slog.e(TAG, "exception in setMtu()" + e);
    }
}
#method_after
private void updateMtu(LinkProperties newLp, LinkProperties oldLp) {
    final String iface = newLp.getInterfaceName();
    final int mtu = newLp.getMtu();
    if (oldLp == null && mtu == 0) {
        // Silently ignore unset MTU value.
        return;
    }
    if (oldLp != null && newLp.isIdenticalMtu(oldLp)) {
        if (VDBG)
            log("identical MTU - not setting");
        return;
    }
    if (LinkProperties.isValidMtu(mtu, newLp.hasGlobalIPv6Address()) == false) {
        if (mtu != 0)
            loge("Unexpected mtu value: " + mtu + ", " + iface);
        return;
    }
    // Cannot set MTU without interface name
    if (TextUtils.isEmpty(iface)) {
        loge("Setting MTU size with null iface.");
        return;
    }
    try {
        if (VDBG)
            log("Setting MTU size: " + iface + ", " + mtu);
        mNMS.setMtu(iface, mtu);
    } catch (Exception e) {
        Slog.e(TAG, "exception in setMtu()" + e);
    }
}
#end_block

#method_before
private void dumpNetworkDiagnostics(IndentingPrintWriter pw) {
    final List<NetworkDiagnostics> netDiags = new ArrayList<NetworkDiagnostics>();
    final long DIAG_TIME_MS = 5000;
    for (NetworkAgentInfo nai : mNetworkAgentInfos.values()) {
        // Start gathering diagnostic information.
        netDiags.add(new NetworkDiagnostics(nai.network, // Must be a copy.
        new LinkProperties(nai.linkProperties), DIAG_TIME_MS));
    }
    for (NetworkDiagnostics netDiag : netDiags) {
        pw.println();
        netDiag.waitForMeasurements();
        netDiag.dump(pw);
    }
}
#method_after
private void dumpNetworkDiagnostics(IndentingPrintWriter pw) {
    final List<NetworkDiagnostics> netDiags = new ArrayList<NetworkDiagnostics>();
    final long DIAG_TIME_MS = 5000;
    for (NetworkAgentInfo nai : networksSortedById()) {
        // Start gathering diagnostic information.
        netDiags.add(new NetworkDiagnostics(nai.network, // Must be a copy.
        new LinkProperties(nai.linkProperties), DIAG_TIME_MS));
    }
    for (NetworkDiagnostics netDiag : netDiags) {
        pw.println();
        netDiag.waitForMeasurements();
        netDiag.dump(pw);
    }
}
#end_block

#method_before
private void doDump(FileDescriptor fd, PrintWriter writer, String[] args, boolean asProto) {
    final IndentingPrintWriter pw = new IndentingPrintWriter(writer, "  ");
    if (!DumpUtils.checkDumpPermission(mContext, TAG, pw))
        return;
    if (asProto)
        return;
    if (ArrayUtils.contains(args, DIAG_ARG)) {
        dumpNetworkDiagnostics(pw);
        return;
    } else if (ArrayUtils.contains(args, TETHERING_ARG)) {
        mTethering.dump(fd, pw, args);
        return;
    }
    pw.print("NetworkFactories for:");
    for (NetworkFactoryInfo nfi : mNetworkFactoryInfos.values()) {
        pw.print(" " + nfi.name);
    }
    pw.println();
    pw.println();
    final NetworkAgentInfo defaultNai = getDefaultNetwork();
    pw.print("Active default network: ");
    if (defaultNai == null) {
        pw.println("none");
    } else {
        pw.println(defaultNai.network.netId);
    }
    pw.println();
    pw.println("Current Networks:");
    pw.increaseIndent();
    for (NetworkAgentInfo nai : mNetworkAgentInfos.values()) {
        pw.println(nai.toString());
        pw.increaseIndent();
        pw.println(String.format("Requests: REQUEST:%d LISTEN:%d BACKGROUND_REQUEST:%d total:%d", nai.numForegroundNetworkRequests(), nai.numNetworkRequests() - nai.numRequestNetworkRequests(), nai.numBackgroundNetworkRequests(), nai.numNetworkRequests()));
        pw.increaseIndent();
        for (int i = 0; i < nai.numNetworkRequests(); i++) {
            pw.println(nai.requestAt(i).toString());
        }
        pw.decreaseIndent();
        pw.println("Lingered:");
        pw.increaseIndent();
        nai.dumpLingerTimers(pw);
        pw.decreaseIndent();
        pw.decreaseIndent();
    }
    pw.decreaseIndent();
    pw.println();
    pw.print("Restrict background: ");
    pw.println(mRestrictBackground);
    pw.println();
    pw.println("Status for known UIDs:");
    pw.increaseIndent();
    final int size = mUidRules.size();
    for (int i = 0; i < size; i++) {
        final int uid = mUidRules.keyAt(i);
        pw.print("UID=");
        pw.print(uid);
        final int uidRules = mUidRules.get(uid, RULE_NONE);
        pw.print(" rules=");
        pw.print(uidRulesToString(uidRules));
        pw.println();
    }
    pw.println();
    pw.decreaseIndent();
    pw.println("Network Requests:");
    pw.increaseIndent();
    for (NetworkRequestInfo nri : mNetworkRequests.values()) {
        pw.println(nri.toString());
    }
    pw.println();
    pw.decreaseIndent();
    mLegacyTypeTracker.dump(pw);
    pw.println();
    mTethering.dump(fd, pw, args);
    pw.println();
    mKeepaliveTracker.dump(pw);
    pw.println();
    dumpAvoidBadWifiSettings(pw);
    pw.println();
    mMultipathPolicyTracker.dump(pw);
    if (ArrayUtils.contains(args, SHORT_ARG) == false) {
        pw.println();
        synchronized (mValidationLogs) {
            pw.println("mValidationLogs (most recent first):");
            for (ValidationLog p : mValidationLogs) {
                pw.println(p.mNetwork + " - " + p.mName);
                pw.increaseIndent();
                p.mLog.dump(fd, pw, args);
                pw.decreaseIndent();
            }
        }
        pw.println();
        pw.println("mNetworkRequestInfoLogs (most recent first):");
        pw.increaseIndent();
        mNetworkRequestInfoLogs.reverseDump(fd, pw, args);
        pw.decreaseIndent();
        pw.println();
        pw.println("mNetworkInfoBlockingLogs (most recent first):");
        pw.increaseIndent();
        mNetworkInfoBlockingLogs.reverseDump(fd, pw, args);
        pw.decreaseIndent();
        pw.println();
        pw.println("NetTransition WakeLock activity (most recent first):");
        pw.increaseIndent();
        pw.println("total acquisitions: " + mTotalWakelockAcquisitions);
        pw.println("total releases: " + mTotalWakelockReleases);
        pw.println("cumulative duration: " + (mTotalWakelockDurationMs / 1000) + "s");
        pw.println("longest duration: " + (mMaxWakelockDurationMs / 1000) + "s");
        if (mTotalWakelockAcquisitions > mTotalWakelockReleases) {
            long duration = SystemClock.elapsedRealtime() - mLastWakeLockAcquireTimestamp;
            pw.println("currently holding WakeLock for: " + (duration / 1000) + "s");
        }
        mWakelockLogs.reverseDump(fd, pw, args);
        pw.println();
        pw.println("bandwidth update requests (by uid):");
        pw.increaseIndent();
        synchronized (mBandwidthRequests) {
            for (int i = 0; i < mBandwidthRequests.size(); i++) {
                pw.println("[" + mBandwidthRequests.keyAt(i) + "]: " + mBandwidthRequests.valueAt(i));
            }
        }
        pw.decreaseIndent();
        pw.decreaseIndent();
    }
}
#method_after
private void doDump(FileDescriptor fd, PrintWriter writer, String[] args, boolean asProto) {
    final IndentingPrintWriter pw = new IndentingPrintWriter(writer, "  ");
    if (!DumpUtils.checkDumpPermission(mContext, TAG, pw))
        return;
    if (asProto)
        return;
    if (ArrayUtils.contains(args, DIAG_ARG)) {
        dumpNetworkDiagnostics(pw);
        return;
    } else if (ArrayUtils.contains(args, TETHERING_ARG)) {
        mTethering.dump(fd, pw, args);
        return;
    } else if (ArrayUtils.contains(args, NETWORK_ARG)) {
        dumpNetworks(pw);
        return;
    } else if (ArrayUtils.contains(args, REQUEST_ARG)) {
        dumpNetworkRequests(pw);
        return;
    }
    pw.print("NetworkFactories for:");
    for (NetworkFactoryInfo nfi : mNetworkFactoryInfos.values()) {
        pw.print(" " + nfi.name);
    }
    pw.println();
    pw.println();
    final NetworkAgentInfo defaultNai = getDefaultNetwork();
    pw.print("Active default network: ");
    if (defaultNai == null) {
        pw.println("none");
    } else {
        pw.println(defaultNai.network.netId);
    }
    pw.println();
    pw.println("Current Networks:");
    pw.increaseIndent();
    dumpNetworks(pw);
    pw.decreaseIndent();
    pw.println();
    pw.println("Network Requests:");
    pw.increaseIndent();
    dumpNetworkRequests(pw);
    pw.decreaseIndent();
    pw.println();
    mLegacyTypeTracker.dump(pw);
    pw.println();
    mTethering.dump(fd, pw, args);
    pw.println();
    mKeepaliveTracker.dump(pw);
    pw.println();
    dumpAvoidBadWifiSettings(pw);
    pw.println();
    mMultipathPolicyTracker.dump(pw);
    if (ArrayUtils.contains(args, SHORT_ARG) == false) {
        pw.println();
        synchronized (mValidationLogs) {
            pw.println("mValidationLogs (most recent first):");
            for (ValidationLog p : mValidationLogs) {
                pw.println(p.mNetwork + " - " + p.mName);
                pw.increaseIndent();
                p.mLog.dump(fd, pw, args);
                pw.decreaseIndent();
            }
        }
        pw.println();
        pw.println("mNetworkRequestInfoLogs (most recent first):");
        pw.increaseIndent();
        mNetworkRequestInfoLogs.reverseDump(fd, pw, args);
        pw.decreaseIndent();
        pw.println();
        pw.println("mNetworkInfoBlockingLogs (most recent first):");
        pw.increaseIndent();
        mNetworkInfoBlockingLogs.reverseDump(fd, pw, args);
        pw.decreaseIndent();
        pw.println();
        pw.println("NetTransition WakeLock activity (most recent first):");
        pw.increaseIndent();
        pw.println("total acquisitions: " + mTotalWakelockAcquisitions);
        pw.println("total releases: " + mTotalWakelockReleases);
        pw.println("cumulative duration: " + (mTotalWakelockDurationMs / 1000) + "s");
        pw.println("longest duration: " + (mMaxWakelockDurationMs / 1000) + "s");
        if (mTotalWakelockAcquisitions > mTotalWakelockReleases) {
            long duration = SystemClock.elapsedRealtime() - mLastWakeLockAcquireTimestamp;
            pw.println("currently holding WakeLock for: " + (duration / 1000) + "s");
        }
        mWakelockLogs.reverseDump(fd, pw, args);
        pw.println();
        pw.println("bandwidth update requests (by uid):");
        pw.increaseIndent();
        synchronized (mBandwidthRequests) {
            for (int i = 0; i < mBandwidthRequests.size(); i++) {
                pw.println("[" + mBandwidthRequests.keyAt(i) + "]: " + mBandwidthRequests.valueAt(i));
            }
        }
        pw.decreaseIndent();
        pw.decreaseIndent();
    }
}
#end_block

#method_before
// Destroys a network, remove references to it from the internal state managed by
// ConnectivityService, free its interfaces and clean up.
private void disconnectAndDestroyNetwork(NetworkAgentInfo nai) {
    if (DBG) {
        log(nai.name() + " got DISCONNECTED, was satisfying " + nai.numNetworkRequests());
    }
    // disconnect the channel.
    if (nai.networkInfo.isConnected()) {
        nai.networkInfo.setDetailedState(NetworkInfo.DetailedState.DISCONNECTED, null, null);
    }
    final boolean wasDefault = isDefaultNetwork(nai);
    if (wasDefault) {
        mDefaultInetConditionPublished = 0;
        // Log default network disconnection before required book-keeping.
        // Let rematchAllNetworksAndRequests() below record a new default network event
        // if there is a fallback. Taken together, the two form a X -> 0, 0 -> Y sequence
        // whose timestamps tell how long it takes to recover a default network.
        long now = SystemClock.elapsedRealtime();
        metricsLogger().defaultNetworkMetrics().logDefaultNetworkEvent(now, null, nai);
    }
    notifyIfacesChangedForNetworkStats();
    // TODO - we shouldn't send CALLBACK_LOST to requests that can be satisfied
    // by other networks that are already connected. Perhaps that can be done by
    // sending all CALLBACK_LOST messages (for requests, not listens) at the end
    // of rematchAllNetworksAndRequests
    notifyNetworkCallbacks(nai, ConnectivityManager.CALLBACK_LOST);
    mKeepaliveTracker.handleStopAllKeepalives(nai, ConnectivityManager.PacketKeepalive.ERROR_INVALID_NETWORK);
    for (String iface : nai.linkProperties.getAllInterfaceNames()) {
        // Disable wakeup packet monitoring for each interface.
        wakeupModifyInterface(iface, nai.networkCapabilities, false);
    }
    nai.networkMonitor.sendMessage(NetworkMonitor.CMD_NETWORK_DISCONNECTED);
    mNetworkAgentInfos.remove(nai.messenger);
    nai.maybeStopClat();
    synchronized (mNetworkForNetId) {
        // Remove the NetworkAgent, but don't mark the netId as
        // available until we've told netd to delete it below.
        mNetworkForNetId.remove(nai.network.netId);
    }
    // Remove all previously satisfied requests.
    for (int i = 0; i < nai.numNetworkRequests(); i++) {
        NetworkRequest request = nai.requestAt(i);
        NetworkAgentInfo currentNetwork = getNetworkForRequest(request.requestId);
        if (currentNetwork != null && currentNetwork.network.netId == nai.network.netId) {
            clearNetworkForRequest(request.requestId);
            sendUpdatedScoreToFactories(request, 0);
        }
    }
    nai.clearLingerState();
    if (nai.isSatisfyingRequest(mDefaultRequest.requestId)) {
        removeDataActivityTracking(nai);
        notifyLockdownVpn(nai);
        ensureNetworkTransitionWakelock(nai.name());
    }
    mLegacyTypeTracker.remove(nai, wasDefault);
    if (!nai.networkCapabilities.hasTransport(TRANSPORT_VPN)) {
        updateAllVpnsCapabilities();
    }
    rematchAllNetworksAndRequests(null, 0);
    mLingerMonitor.noteDisconnect(nai);
    if (nai.created) {
        // long time.
        try {
            mNetd.removeNetwork(nai.network.netId);
        } catch (Exception e) {
            loge("Exception removing network: " + e);
        }
        mDnsManager.removeNetwork(nai.network);
    }
    synchronized (mNetworkForNetId) {
        mNetIdInUse.delete(nai.network.netId);
    }
}
#method_after
// Destroys a network, remove references to it from the internal state managed by
// ConnectivityService, free its interfaces and clean up.
private void disconnectAndDestroyNetwork(NetworkAgentInfo nai) {
    if (DBG) {
        log(nai.name() + " got DISCONNECTED, was satisfying " + nai.numNetworkRequests());
    }
    // disconnect the channel.
    if (nai.networkInfo.isConnected()) {
        nai.networkInfo.setDetailedState(NetworkInfo.DetailedState.DISCONNECTED, null, null);
    }
    final boolean wasDefault = isDefaultNetwork(nai);
    if (wasDefault) {
        mDefaultInetConditionPublished = 0;
        // Log default network disconnection before required book-keeping.
        // Let rematchAllNetworksAndRequests() below record a new default network event
        // if there is a fallback. Taken together, the two form a X -> 0, 0 -> Y sequence
        // whose timestamps tell how long it takes to recover a default network.
        long now = SystemClock.elapsedRealtime();
        metricsLogger().defaultNetworkMetrics().logDefaultNetworkEvent(now, null, nai);
    }
    notifyIfacesChangedForNetworkStats();
    // TODO - we shouldn't send CALLBACK_LOST to requests that can be satisfied
    // by other networks that are already connected. Perhaps that can be done by
    // sending all CALLBACK_LOST messages (for requests, not listens) at the end
    // of rematchAllNetworksAndRequests
    notifyNetworkCallbacks(nai, ConnectivityManager.CALLBACK_LOST);
    mKeepaliveTracker.handleStopAllKeepalives(nai, ConnectivityManager.PacketKeepalive.ERROR_INVALID_NETWORK);
    for (String iface : nai.linkProperties.getAllInterfaceNames()) {
        // Disable wakeup packet monitoring for each interface.
        wakeupModifyInterface(iface, nai.networkCapabilities, false);
    }
    nai.networkMonitor.sendMessage(NetworkMonitor.CMD_NETWORK_DISCONNECTED);
    mNetworkAgentInfos.remove(nai.messenger);
    nai.maybeStopClat();
    synchronized (mNetworkForNetId) {
        // Remove the NetworkAgent, but don't mark the netId as
        // available until we've told netd to delete it below.
        mNetworkForNetId.remove(nai.network.netId);
    }
    // Remove all previously satisfied requests.
    for (int i = 0; i < nai.numNetworkRequests(); i++) {
        NetworkRequest request = nai.requestAt(i);
        NetworkAgentInfo currentNetwork = getNetworkForRequest(request.requestId);
        if (currentNetwork != null && currentNetwork.network.netId == nai.network.netId) {
            clearNetworkForRequest(request.requestId);
            sendUpdatedScoreToFactories(request, 0);
        }
    }
    nai.clearLingerState();
    if (nai.isSatisfyingRequest(mDefaultRequest.requestId)) {
        updateDataActivityTracking(null, /* newNetwork */
        nai);
        notifyLockdownVpn(nai);
        ensureNetworkTransitionWakelock(nai.name());
    }
    mLegacyTypeTracker.remove(nai, wasDefault);
    if (!nai.networkCapabilities.hasTransport(TRANSPORT_VPN)) {
        updateAllVpnsCapabilities();
    }
    rematchAllNetworksAndRequests(null, 0);
    mLingerMonitor.noteDisconnect(nai);
    if (nai.created) {
        // long time.
        try {
            mNMS.removeNetwork(nai.network.netId);
        } catch (Exception e) {
            loge("Exception removing network: " + e);
        }
        mDnsManager.removeNetwork(nai.network);
    }
    synchronized (mNetworkForNetId) {
        mNetIdInUse.delete(nai.network.netId);
    }
}
#end_block

#method_before
private void handleRemoveNetworkRequest(final NetworkRequestInfo nri) {
    nri.unlinkDeathRecipient();
    mNetworkRequests.remove(nri.request);
    synchronized (mUidToNetworkRequestCount) {
        int requests = mUidToNetworkRequestCount.get(nri.mUid, 0);
        if (requests < 1) {
            Slog.wtf(TAG, "BUG: too small request count " + requests + " for UID " + nri.mUid);
        } else if (requests == 1) {
            mUidToNetworkRequestCount.removeAt(mUidToNetworkRequestCount.indexOfKey(nri.mUid));
        } else {
            mUidToNetworkRequestCount.put(nri.mUid, requests - 1);
        }
    }
    mNetworkRequestInfoLogs.log("RELEASE " + nri);
    if (nri.request.isRequest()) {
        boolean wasKept = false;
        NetworkAgentInfo nai = getNetworkForRequest(nri.request.requestId);
        if (nai != null) {
            boolean wasBackgroundNetwork = nai.isBackgroundNetwork();
            nai.removeRequest(nri.request.requestId);
            if (VDBG) {
                log(" Removing from current network " + nai.name() + ", leaving " + nai.numNetworkRequests() + " requests.");
            }
            // If there are still lingered requests on this network, don't tear it down,
            // but resume lingering instead.
            updateLingerState(nai, SystemClock.elapsedRealtime());
            if (unneeded(nai, UnneededFor.TEARDOWN)) {
                if (DBG)
                    log("no live requests for " + nai.name() + "; disconnecting");
                teardownUnneededNetwork(nai);
            } else {
                wasKept = true;
            }
            clearNetworkForRequest(nri.request.requestId);
            if (!wasBackgroundNetwork && nai.isBackgroundNetwork()) {
                // Went from foreground to background.
                updateCapabilities(nai.getCurrentScore(), nai, nai.networkCapabilities);
            }
        }
        // network satisfying it, so this loop is wasteful
        for (NetworkAgentInfo otherNai : mNetworkAgentInfos.values()) {
            if (otherNai.isSatisfyingRequest(nri.request.requestId) && otherNai != nai) {
                Slog.wtf(TAG, "Request " + nri.request + " satisfied by " + otherNai.name() + ", but mNetworkAgentInfos says " + (nai != null ? nai.name() : "null"));
            }
        }
        // phantom disconnect for this type.
        if (nri.request.legacyType != TYPE_NONE && nai != null) {
            boolean doRemove = true;
            if (wasKept) {
                // same legacy type - if so, don't remove the nai
                for (int i = 0; i < nai.numNetworkRequests(); i++) {
                    NetworkRequest otherRequest = nai.requestAt(i);
                    if (otherRequest.legacyType == nri.request.legacyType && otherRequest.isRequest()) {
                        if (DBG)
                            log(" still have other legacy request - leaving");
                        doRemove = false;
                    }
                }
            }
            if (doRemove) {
                mLegacyTypeTracker.remove(nri.request.legacyType, nai, false);
            }
        }
        for (NetworkFactoryInfo nfi : mNetworkFactoryInfos.values()) {
            nfi.asyncChannel.sendMessage(android.net.NetworkFactory.CMD_CANCEL_REQUEST, nri.request);
        }
    } else {
        // if this listen request applies and remove it.
        for (NetworkAgentInfo nai : mNetworkAgentInfos.values()) {
            nai.removeRequest(nri.request.requestId);
            if (nri.request.networkCapabilities.hasSignalStrength() && nai.satisfiesImmutableCapabilitiesOf(nri.request)) {
                updateSignalStrengthThresholds(nai, "RELEASE", nri.request);
            }
        }
    }
}
#method_after
private void handleRemoveNetworkRequest(final NetworkRequestInfo nri) {
    nri.unlinkDeathRecipient();
    mNetworkRequests.remove(nri.request);
    synchronized (mUidToNetworkRequestCount) {
        int requests = mUidToNetworkRequestCount.get(nri.mUid, 0);
        if (requests < 1) {
            Slog.wtf(TAG, "BUG: too small request count " + requests + " for UID " + nri.mUid);
        } else if (requests == 1) {
            mUidToNetworkRequestCount.removeAt(mUidToNetworkRequestCount.indexOfKey(nri.mUid));
        } else {
            mUidToNetworkRequestCount.put(nri.mUid, requests - 1);
        }
    }
    mNetworkRequestInfoLogs.log("RELEASE " + nri);
    if (nri.request.isRequest()) {
        boolean wasKept = false;
        NetworkAgentInfo nai = getNetworkForRequest(nri.request.requestId);
        if (nai != null) {
            boolean wasBackgroundNetwork = nai.isBackgroundNetwork();
            nai.removeRequest(nri.request.requestId);
            if (VDBG) {
                log(" Removing from current network " + nai.name() + ", leaving " + nai.numNetworkRequests() + " requests.");
            }
            // If there are still lingered requests on this network, don't tear it down,
            // but resume lingering instead.
            updateLingerState(nai, SystemClock.elapsedRealtime());
            if (unneeded(nai, UnneededFor.TEARDOWN)) {
                if (DBG)
                    log("no live requests for " + nai.name() + "; disconnecting");
                teardownUnneededNetwork(nai);
            } else {
                wasKept = true;
            }
            clearNetworkForRequest(nri.request.requestId);
            if (!wasBackgroundNetwork && nai.isBackgroundNetwork()) {
                // Went from foreground to background.
                updateCapabilities(nai.getCurrentScore(), nai, nai.networkCapabilities);
            }
        }
        // phantom disconnect for this type.
        if (nri.request.legacyType != TYPE_NONE && nai != null) {
            boolean doRemove = true;
            if (wasKept) {
                // same legacy type - if so, don't remove the nai
                for (int i = 0; i < nai.numNetworkRequests(); i++) {
                    NetworkRequest otherRequest = nai.requestAt(i);
                    if (otherRequest.legacyType == nri.request.legacyType && otherRequest.isRequest()) {
                        if (DBG)
                            log(" still have other legacy request - leaving");
                        doRemove = false;
                    }
                }
            }
            if (doRemove) {
                mLegacyTypeTracker.remove(nri.request.legacyType, nai, false);
            }
        }
        for (NetworkFactoryInfo nfi : mNetworkFactoryInfos.values()) {
            nfi.asyncChannel.sendMessage(android.net.NetworkFactory.CMD_CANCEL_REQUEST, nri.request);
        }
    } else {
        // if this listen request applies and remove it.
        for (NetworkAgentInfo nai : mNetworkAgentInfos.values()) {
            nai.removeRequest(nri.request.requestId);
            if (nri.request.networkCapabilities.hasSignalStrength() && nai.satisfiesImmutableCapabilitiesOf(nri.request)) {
                updateSignalStrengthThresholds(nai, "RELEASE", nri.request);
            }
        }
    }
}
#end_block

#method_before
// TODO: Evaluate whether this is of interest to other consumers of
private void dumpAvoidBadWifiSettings(IndentingPrintWriter pw) {
    final boolean configRestrict = mMultinetworkPolicyTracker.configRestrictsAvoidBadWifi();
    if (!configRestrict) {
        pw.println("Bad Wi-Fi avoidance: unrestricted");
        return;
    }
    pw.println("Bad Wi-Fi avoidance: " + avoidBadWifi());
    pw.increaseIndent();
    pw.println("Config restrict:   " + configRestrict);
    final String value = mMultinetworkPolicyTracker.getAvoidBadWifiSetting();
    String description;
    // Can't use a switch statement because strings are legal case labels, but null is not.
    if ("0".equals(value)) {
        description = "get stuck";
    } else if (value == null) {
        description = "prompt";
    } else if ("1".equals(value)) {
        description = "avoid";
    } else {
        description = value + " (?)";
    }
    pw.println("User setting:      " + description);
    pw.println("Network overrides:");
    pw.increaseIndent();
    for (NetworkAgentInfo nai : mNetworkAgentInfos.values()) {
        if (nai.avoidUnvalidated) {
            pw.println(nai.name());
        }
    }
    pw.decreaseIndent();
    pw.decreaseIndent();
}
#method_after
// TODO: Evaluate whether this is of interest to other consumers of
private void dumpAvoidBadWifiSettings(IndentingPrintWriter pw) {
    final boolean configRestrict = mMultinetworkPolicyTracker.configRestrictsAvoidBadWifi();
    if (!configRestrict) {
        pw.println("Bad Wi-Fi avoidance: unrestricted");
        return;
    }
    pw.println("Bad Wi-Fi avoidance: " + avoidBadWifi());
    pw.increaseIndent();
    pw.println("Config restrict:   " + configRestrict);
    final String value = mMultinetworkPolicyTracker.getAvoidBadWifiSetting();
    String description;
    // Can't use a switch statement because strings are legal case labels, but null is not.
    if ("0".equals(value)) {
        description = "get stuck";
    } else if (value == null) {
        description = "prompt";
    } else if ("1".equals(value)) {
        description = "avoid";
    } else {
        description = value + " (?)";
    }
    pw.println("User setting:      " + description);
    pw.println("Network overrides:");
    pw.increaseIndent();
    for (NetworkAgentInfo nai : networksSortedById()) {
        if (nai.avoidUnvalidated) {
            pw.println(nai.name());
        }
    }
    pw.decreaseIndent();
    pw.decreaseIndent();
}
#end_block

#method_before
@Override
public void handleMessage(Message msg) {
    switch(msg.what) {
        case EVENT_EXPIRE_NET_TRANSITION_WAKELOCK:
        case EVENT_CLEAR_NET_TRANSITION_WAKELOCK:
            {
                handleReleaseNetworkTransitionWakelock(msg.what);
                break;
            }
        case EVENT_APPLY_GLOBAL_HTTP_PROXY:
            {
                handleDeprecatedGlobalHttpProxy();
                break;
            }
        case EVENT_PROXY_HAS_CHANGED:
            {
                handleApplyDefaultProxy((ProxyInfo) msg.obj);
                break;
            }
        case EVENT_REGISTER_NETWORK_FACTORY:
            {
                handleRegisterNetworkFactory((NetworkFactoryInfo) msg.obj);
                break;
            }
        case EVENT_UNREGISTER_NETWORK_FACTORY:
            {
                handleUnregisterNetworkFactory((Messenger) msg.obj);
                break;
            }
        case EVENT_REGISTER_NETWORK_AGENT:
            {
                handleRegisterNetworkAgent((NetworkAgentInfo) msg.obj);
                break;
            }
        case EVENT_REGISTER_NETWORK_REQUEST:
        case EVENT_REGISTER_NETWORK_LISTENER:
            {
                handleRegisterNetworkRequest((NetworkRequestInfo) msg.obj);
                break;
            }
        case EVENT_REGISTER_NETWORK_REQUEST_WITH_INTENT:
        case EVENT_REGISTER_NETWORK_LISTENER_WITH_INTENT:
            {
                handleRegisterNetworkRequestWithIntent(msg);
                break;
            }
        case EVENT_TIMEOUT_NETWORK_REQUEST:
            {
                NetworkRequestInfo nri = (NetworkRequestInfo) msg.obj;
                handleTimedOutNetworkRequest(nri);
                break;
            }
        case EVENT_RELEASE_NETWORK_REQUEST_WITH_INTENT:
            {
                handleReleaseNetworkRequestWithIntent((PendingIntent) msg.obj, msg.arg1);
                break;
            }
        case EVENT_RELEASE_NETWORK_REQUEST:
            {
                handleReleaseNetworkRequest((NetworkRequest) msg.obj, msg.arg1);
                break;
            }
        case EVENT_SET_ACCEPT_UNVALIDATED:
            {
                Network network = (Network) msg.obj;
                handleSetAcceptUnvalidated(network, toBool(msg.arg1), toBool(msg.arg2));
                break;
            }
        case EVENT_SET_AVOID_UNVALIDATED:
            {
                handleSetAvoidUnvalidated((Network) msg.obj);
                break;
            }
        case EVENT_PROMPT_UNVALIDATED:
            {
                handlePromptUnvalidated((Network) msg.obj);
                break;
            }
        case EVENT_CONFIGURE_MOBILE_DATA_ALWAYS_ON:
            {
                handleMobileDataAlwaysOn();
                break;
            }
        // Sent by KeepaliveTracker to process an app request on the state machine thread.
        case NetworkAgent.CMD_START_PACKET_KEEPALIVE:
            {
                mKeepaliveTracker.handleStartKeepalive(msg);
                break;
            }
        // Sent by KeepaliveTracker to process an app request on the state machine thread.
        case NetworkAgent.CMD_STOP_PACKET_KEEPALIVE:
            {
                NetworkAgentInfo nai = getNetworkAgentInfoForNetwork((Network) msg.obj);
                int slot = msg.arg1;
                int reason = msg.arg2;
                mKeepaliveTracker.handleStopKeepalive(nai, slot, reason);
                break;
            }
        case EVENT_SYSTEM_READY:
            {
                for (NetworkAgentInfo nai : mNetworkAgentInfos.values()) {
                    nai.networkMonitor.systemReady = true;
                }
                mMultipathPolicyTracker.start();
                break;
            }
        case EVENT_REVALIDATE_NETWORK:
            {
                handleReportNetworkConnectivity((Network) msg.obj, msg.arg1, toBool(msg.arg2));
                break;
            }
        case EVENT_PRIVATE_DNS_SETTINGS_CHANGED:
            handlePrivateDnsSettingsChanged();
            break;
        case EVENT_PRIVATE_DNS_VALIDATION_UPDATE:
            handlePrivateDnsValidationUpdate((PrivateDnsValidationUpdate) msg.obj);
            break;
        case EVENT_UID_RULES_CHANGED:
            handleUidRulesChanged(msg.arg1, msg.arg2);
            break;
        case EVENT_DATA_SAVER_CHANGED:
            handleRestrictBackgroundChanged(toBool(msg.arg1));
            break;
    }
}
#method_after
@Override
public void handleMessage(Message msg) {
    switch(msg.what) {
        case EVENT_EXPIRE_NET_TRANSITION_WAKELOCK:
        case EVENT_CLEAR_NET_TRANSITION_WAKELOCK:
            {
                handleReleaseNetworkTransitionWakelock(msg.what);
                break;
            }
        case EVENT_APPLY_GLOBAL_HTTP_PROXY:
            {
                mProxyTracker.loadDeprecatedGlobalHttpProxy();
                break;
            }
        case EVENT_PROXY_HAS_CHANGED:
            {
                handleApplyDefaultProxy((ProxyInfo) msg.obj);
                break;
            }
        case EVENT_REGISTER_NETWORK_FACTORY:
            {
                handleRegisterNetworkFactory((NetworkFactoryInfo) msg.obj);
                break;
            }
        case EVENT_UNREGISTER_NETWORK_FACTORY:
            {
                handleUnregisterNetworkFactory((Messenger) msg.obj);
                break;
            }
        case EVENT_REGISTER_NETWORK_AGENT:
            {
                handleRegisterNetworkAgent((NetworkAgentInfo) msg.obj);
                break;
            }
        case EVENT_REGISTER_NETWORK_REQUEST:
        case EVENT_REGISTER_NETWORK_LISTENER:
            {
                handleRegisterNetworkRequest((NetworkRequestInfo) msg.obj);
                break;
            }
        case EVENT_REGISTER_NETWORK_REQUEST_WITH_INTENT:
        case EVENT_REGISTER_NETWORK_LISTENER_WITH_INTENT:
            {
                handleRegisterNetworkRequestWithIntent(msg);
                break;
            }
        case EVENT_TIMEOUT_NETWORK_REQUEST:
            {
                NetworkRequestInfo nri = (NetworkRequestInfo) msg.obj;
                handleTimedOutNetworkRequest(nri);
                break;
            }
        case EVENT_RELEASE_NETWORK_REQUEST_WITH_INTENT:
            {
                handleReleaseNetworkRequestWithIntent((PendingIntent) msg.obj, msg.arg1);
                break;
            }
        case EVENT_RELEASE_NETWORK_REQUEST:
            {
                handleReleaseNetworkRequest((NetworkRequest) msg.obj, msg.arg1);
                break;
            }
        case EVENT_SET_ACCEPT_UNVALIDATED:
            {
                Network network = (Network) msg.obj;
                handleSetAcceptUnvalidated(network, toBool(msg.arg1), toBool(msg.arg2));
                break;
            }
        case EVENT_SET_AVOID_UNVALIDATED:
            {
                handleSetAvoidUnvalidated((Network) msg.obj);
                break;
            }
        case EVENT_PROMPT_UNVALIDATED:
            {
                handlePromptUnvalidated((Network) msg.obj);
                break;
            }
        case EVENT_CONFIGURE_ALWAYS_ON_NETWORKS:
            {
                handleConfigureAlwaysOnNetworks();
                break;
            }
        // Sent by KeepaliveTracker to process an app request on the state machine thread.
        case NetworkAgent.CMD_START_PACKET_KEEPALIVE:
            {
                mKeepaliveTracker.handleStartKeepalive(msg);
                break;
            }
        // Sent by KeepaliveTracker to process an app request on the state machine thread.
        case NetworkAgent.CMD_STOP_PACKET_KEEPALIVE:
            {
                NetworkAgentInfo nai = getNetworkAgentInfoForNetwork((Network) msg.obj);
                int slot = msg.arg1;
                int reason = msg.arg2;
                mKeepaliveTracker.handleStopKeepalive(nai, slot, reason);
                break;
            }
        case EVENT_SYSTEM_READY:
            {
                for (NetworkAgentInfo nai : mNetworkAgentInfos.values()) {
                    nai.networkMonitor.systemReady = true;
                }
                mMultipathPolicyTracker.start();
                break;
            }
        case EVENT_REVALIDATE_NETWORK:
            {
                handleReportNetworkConnectivity((Network) msg.obj, msg.arg1, toBool(msg.arg2));
                break;
            }
        case EVENT_PRIVATE_DNS_SETTINGS_CHANGED:
            handlePrivateDnsSettingsChanged();
            break;
        case EVENT_PRIVATE_DNS_VALIDATION_UPDATE:
            handlePrivateDnsValidationUpdate((PrivateDnsValidationUpdate) msg.obj);
            break;
    }
}
#end_block

#method_before
// If the proxy has changed from oldLp to newLp, resend proxy broadcast with default proxy.
// This method gets called when any network changes proxy, but the broadcast only ever contains
// the default proxy (even if it hasn't changed).
// TODO: Deprecate the broadcast extras as they aren't necessarily applicable in a multi-network
private void updateProxy(LinkProperties newLp, LinkProperties oldLp) {
    ProxyInfo newProxyInfo = newLp == null ? null : newLp.getHttpProxy();
    ProxyInfo oldProxyInfo = oldLp == null ? null : oldLp.getHttpProxy();
    if (!ProxyTracker.proxyInfoEqual(newProxyInfo, oldProxyInfo)) {
        mProxyTracker.sendProxyBroadcast(mProxyTracker.getDefaultProxy());
    }
}
#method_after
// If the proxy has changed from oldLp to newLp, resend proxy broadcast with default proxy.
// This method gets called when any network changes proxy, but the broadcast only ever contains
// the default proxy (even if it hasn't changed).
// TODO: Deprecate the broadcast extras as they aren't necessarily applicable in a multi-network
private void updateProxy(LinkProperties newLp, LinkProperties oldLp) {
    ProxyInfo newProxyInfo = newLp == null ? null : newLp.getHttpProxy();
    ProxyInfo oldProxyInfo = oldLp == null ? null : oldLp.getHttpProxy();
    if (!ProxyTracker.proxyInfoEqual(newProxyInfo, oldProxyInfo)) {
        mProxyTracker.sendProxyBroadcast();
    }
}
#end_block

#method_before
@Override
public boolean updateLockdownVpn() {
    if (Binder.getCallingUid() != Process.SYSTEM_UID) {
        Slog.w(TAG, "Lockdown VPN only available to AID_SYSTEM");
        return false;
    }
    synchronized (mVpns) {
        // Tear down existing lockdown if profile was removed
        mLockdownEnabled = LockdownVpnTracker.isEnabled();
        if (mLockdownEnabled) {
            byte[] profileTag = mKeyStore.get(Credentials.LOCKDOWN_VPN);
            if (profileTag == null) {
                Slog.e(TAG, "Lockdown VPN configured but cannot be read from keystore");
                return false;
            }
            String profileName = new String(profileTag);
            final VpnProfile profile = VpnProfile.decode(profileName, mKeyStore.get(Credentials.VPN + profileName));
            if (profile == null) {
                Slog.e(TAG, "Lockdown VPN configured invalid profile " + profileName);
                setLockdownTracker(null);
                return true;
            }
            int user = UserHandle.getUserId(Binder.getCallingUid());
            Vpn vpn = mVpns.get(user);
            if (vpn == null) {
                Slog.w(TAG, "VPN for user " + user + " not ready yet. Skipping lockdown");
                return false;
            }
            setLockdownTracker(new LockdownVpnTracker(mContext, mNetd, this, vpn, profile));
        } else {
            setLockdownTracker(null);
        }
    }
    return true;
}
#method_after
@Override
public boolean updateLockdownVpn() {
    if (Binder.getCallingUid() != Process.SYSTEM_UID) {
        Slog.w(TAG, "Lockdown VPN only available to AID_SYSTEM");
        return false;
    }
    synchronized (mVpns) {
        // Tear down existing lockdown if profile was removed
        mLockdownEnabled = LockdownVpnTracker.isEnabled();
        if (mLockdownEnabled) {
            byte[] profileTag = mKeyStore.get(Credentials.LOCKDOWN_VPN);
            if (profileTag == null) {
                Slog.e(TAG, "Lockdown VPN configured but cannot be read from keystore");
                return false;
            }
            String profileName = new String(profileTag);
            final VpnProfile profile = VpnProfile.decode(profileName, mKeyStore.get(Credentials.VPN + profileName));
            if (profile == null) {
                Slog.e(TAG, "Lockdown VPN configured invalid profile " + profileName);
                setLockdownTracker(null);
                return true;
            }
            int user = UserHandle.getUserId(Binder.getCallingUid());
            Vpn vpn = mVpns.get(user);
            if (vpn == null) {
                Slog.w(TAG, "VPN for user " + user + " not ready yet. Skipping lockdown");
                return false;
            }
            setLockdownTracker(new LockdownVpnTracker(mContext, mNMS, this, vpn, profile));
        } else {
            setLockdownTracker(null);
        }
    }
    return true;
}
#end_block

#method_before
@Override
public void setAirplaneMode(boolean enable) {
    enforceConnectivityInternalPermission();
    final long ident = Binder.clearCallingIdentity();
    try {
        final ContentResolver cr = mContext.getContentResolver();
        Settings.Global.putInt(cr, Settings.Global.AIRPLANE_MODE_ON, encodeBool(enable));
        Intent intent = new Intent(Intent.ACTION_AIRPLANE_MODE_CHANGED);
        intent.putExtra("state", enable);
        mContext.sendBroadcastAsUser(intent, UserHandle.ALL);
    } finally {
        Binder.restoreCallingIdentity(ident);
    }
}
#method_after
@Override
public void setAirplaneMode(boolean enable) {
    enforceNetworkStackSettingsOrSetup();
    final long ident = Binder.clearCallingIdentity();
    try {
        final ContentResolver cr = mContext.getContentResolver();
        Settings.Global.putInt(cr, Settings.Global.AIRPLANE_MODE_ON, encodeBool(enable));
        Intent intent = new Intent(Intent.ACTION_AIRPLANE_MODE_CHANGED);
        intent.putExtra("state", enable);
        mContext.sendBroadcastAsUser(intent, UserHandle.ALL);
    } finally {
        Binder.restoreCallingIdentity(ident);
    }
}
#end_block

#method_before
private void onUserStart(int userId) {
    synchronized (mVpns) {
        Vpn userVpn = mVpns.get(userId);
        if (userVpn != null) {
            loge("Starting user already has a VPN");
            return;
        }
        userVpn = new Vpn(mHandler.getLooper(), mContext, mNetd, userId);
        mVpns.put(userId, userVpn);
        if (mUserManager.getUserInfo(userId).isPrimary() && LockdownVpnTracker.isEnabled()) {
            updateLockdownVpn();
        }
    }
}
#method_after
private void onUserStart(int userId) {
    synchronized (mVpns) {
        Vpn userVpn = mVpns.get(userId);
        if (userVpn != null) {
            loge("Starting user already has a VPN");
            return;
        }
        userVpn = new Vpn(mHandler.getLooper(), mContext, mNMS, userId);
        mVpns.put(userId, userVpn);
        if (mUserManager.getUserInfo(userId).isPrimary() && LockdownVpnTracker.isEnabled()) {
            updateLockdownVpn();
        }
    }
}
#end_block

#method_before
private void enforceMeteredApnPolicy(NetworkCapabilities networkCapabilities) {
    final int uid = Binder.getCallingUid();
    if (networkCapabilities.hasCapability(NET_CAPABILITY_NOT_METERED)) {
        // Policy already enforced.
        return;
    }
    try {
        if (mPolicyManager.isUidNetworkingBlocked(uid, true)) {
            // If UID is restricted, don't allow them to bring up metered APNs.
            networkCapabilities.addCapability(NET_CAPABILITY_NOT_METERED);
        }
    } catch (RemoteException e) {
        log("isUidNetworkingBlocked failed: uid=" + uid + " e=" + e.toString());
        e.printStackTrace();
    }
}
#method_after
private void enforceMeteredApnPolicy(NetworkCapabilities networkCapabilities) {
    final int uid = Binder.getCallingUid();
    if (isSystem(uid)) {
        // Exemption for system uid.
        return;
    }
    if (networkCapabilities.hasCapability(NET_CAPABILITY_NOT_METERED)) {
        // Policy already enforced.
        return;
    }
    if (mPolicyManagerInternal.isUidRestrictedOnMeteredNetworks(uid)) {
        // If UID is restricted, don't allow them to bring up metered APNs.
        networkCapabilities.addCapability(NET_CAPABILITY_NOT_METERED);
    }
}
#end_block

#method_before
private void updateLinkProperties(NetworkAgentInfo networkAgent, LinkProperties oldLp) {
    LinkProperties newLp = new LinkProperties(networkAgent.linkProperties);
    int netId = networkAgent.network.netId;
    // we do anything else, make sure its LinkProperties are accurate.
    if (networkAgent.clatd != null) {
        networkAgent.clatd.fixupLinkProperties(oldLp, newLp);
    }
    updateInterfaces(newLp, oldLp, netId, networkAgent.networkCapabilities);
    updateMtu(newLp, oldLp);
    // TODO - figure out what to do for clat
    // for (LinkProperties lp : newLp.getStackedLinks()) {
    // updateMtu(lp, null);
    // }
    updateTcpBufferSizes(networkAgent);
    updateRoutes(newLp, oldLp, netId);
    updateDnses(newLp, oldLp, netId);
    // Make sure LinkProperties represents the latest private DNS status.
    // This does not need to be done before updateDnses because the
    // LinkProperties are not the source of the private DNS configuration.
    // updateDnses will fetch the private DNS configuration from DnsManager.
    mDnsManager.updatePrivateDnsStatus(netId, newLp);
    // Start or stop clat accordingly to network state.
    networkAgent.updateClat(mNetd);
    if (isDefaultNetwork(networkAgent)) {
        handleApplyDefaultProxy(newLp.getHttpProxy());
    } else {
        updateProxy(newLp, oldLp);
    }
    // TODO - move this check to cover the whole function
    if (!Objects.equals(newLp, oldLp)) {
        synchronized (networkAgent) {
            networkAgent.linkProperties = newLp;
        }
        notifyIfacesChangedForNetworkStats();
        notifyNetworkCallbacks(networkAgent, ConnectivityManager.CALLBACK_IP_CHANGED);
    }
    mKeepaliveTracker.handleCheckKeepalivesStillValid(networkAgent);
}
#method_after
private void updateLinkProperties(NetworkAgentInfo networkAgent, LinkProperties oldLp) {
    LinkProperties newLp = new LinkProperties(networkAgent.linkProperties);
    int netId = networkAgent.network.netId;
    // we do anything else, make sure its LinkProperties are accurate.
    if (networkAgent.clatd != null) {
        networkAgent.clatd.fixupLinkProperties(oldLp, newLp);
    }
    updateInterfaces(newLp, oldLp, netId, networkAgent.networkCapabilities);
    updateMtu(newLp, oldLp);
    // TODO - figure out what to do for clat
    // for (LinkProperties lp : newLp.getStackedLinks()) {
    // updateMtu(lp, null);
    // }
    updateTcpBufferSizes(networkAgent);
    updateRoutes(newLp, oldLp, netId);
    updateDnses(newLp, oldLp, netId);
    // Make sure LinkProperties represents the latest private DNS status.
    // This does not need to be done before updateDnses because the
    // LinkProperties are not the source of the private DNS configuration.
    // updateDnses will fetch the private DNS configuration from DnsManager.
    mDnsManager.updatePrivateDnsStatus(netId, newLp);
    // Start or stop clat accordingly to network state.
    networkAgent.updateClat(mNMS);
    if (isDefaultNetwork(networkAgent)) {
        handleApplyDefaultProxy(newLp.getHttpProxy());
    } else {
        updateProxy(newLp, oldLp);
    }
    // TODO - move this check to cover the whole function
    if (!Objects.equals(newLp, oldLp)) {
        synchronized (networkAgent) {
            networkAgent.linkProperties = newLp;
        }
        notifyIfacesChangedForNetworkStats();
        notifyNetworkCallbacks(networkAgent, ConnectivityManager.CALLBACK_IP_CHANGED);
    }
    mKeepaliveTracker.handleCheckKeepalivesStillValid(networkAgent);
}
#end_block

#method_before
private void wakeupModifyInterface(String iface, NetworkCapabilities caps, boolean add) {
    // marks on unsupported interfaces is harmless.
    if (!caps.hasTransport(NetworkCapabilities.TRANSPORT_WIFI)) {
        return;
    }
    int mark = mContext.getResources().getInteger(com.android.internal.R.integer.config_networkWakeupPacketMark);
    int mask = mContext.getResources().getInteger(com.android.internal.R.integer.config_networkWakeupPacketMask);
    // Don't install rules unless both values are nonzero.
    if (mark == 0 || mask == 0) {
        return;
    }
    final String prefix = "iface:" + iface;
    try {
        if (add) {
            mNetd.getNetdService().wakeupAddInterface(iface, prefix, mark, mask);
        } else {
            mNetd.getNetdService().wakeupDelInterface(iface, prefix, mark, mask);
        }
    } catch (Exception e) {
        loge("Exception modifying wakeup packet monitoring: " + e);
    }
}
#method_after
private void wakeupModifyInterface(String iface, NetworkCapabilities caps, boolean add) {
    // marks on unsupported interfaces is harmless.
    if (!caps.hasTransport(NetworkCapabilities.TRANSPORT_WIFI)) {
        return;
    }
    int mark = mContext.getResources().getInteger(com.android.internal.R.integer.config_networkWakeupPacketMark);
    int mask = mContext.getResources().getInteger(com.android.internal.R.integer.config_networkWakeupPacketMask);
    // Don't install rules unless both values are nonzero.
    if (mark == 0 || mask == 0) {
        return;
    }
    final String prefix = "iface:" + iface;
    try {
        if (add) {
            mNetd.wakeupAddInterface(iface, prefix, mark, mask);
        } else {
            mNetd.wakeupDelInterface(iface, prefix, mark, mask);
        }
    } catch (Exception e) {
        loge("Exception modifying wakeup packet monitoring: " + e);
    }
}
#end_block

#method_before
private void updateInterfaces(LinkProperties newLp, LinkProperties oldLp, int netId, NetworkCapabilities caps) {
    CompareResult<String> interfaceDiff = new CompareResult<>(oldLp != null ? oldLp.getAllInterfaceNames() : null, newLp != null ? newLp.getAllInterfaceNames() : null);
    for (String iface : interfaceDiff.added) {
        try {
            if (DBG)
                log("Adding iface " + iface + " to network " + netId);
            mNetd.addInterfaceToNetwork(iface, netId);
            wakeupModifyInterface(iface, caps, true);
        } catch (Exception e) {
            loge("Exception adding interface: " + e);
        }
    }
    for (String iface : interfaceDiff.removed) {
        try {
            if (DBG)
                log("Removing iface " + iface + " from network " + netId);
            wakeupModifyInterface(iface, caps, false);
            mNetd.removeInterfaceFromNetwork(iface, netId);
        } catch (Exception e) {
            loge("Exception removing interface: " + e);
        }
    }
}
#method_after
private void updateInterfaces(LinkProperties newLp, LinkProperties oldLp, int netId, NetworkCapabilities caps) {
    CompareResult<String> interfaceDiff = new CompareResult<>(oldLp != null ? oldLp.getAllInterfaceNames() : null, newLp != null ? newLp.getAllInterfaceNames() : null);
    for (String iface : interfaceDiff.added) {
        try {
            if (DBG)
                log("Adding iface " + iface + " to network " + netId);
            mNMS.addInterfaceToNetwork(iface, netId);
            wakeupModifyInterface(iface, caps, true);
        } catch (Exception e) {
            loge("Exception adding interface: " + e);
        }
    }
    for (String iface : interfaceDiff.removed) {
        try {
            if (DBG)
                log("Removing iface " + iface + " from network " + netId);
            wakeupModifyInterface(iface, caps, false);
            mNMS.removeInterfaceFromNetwork(iface, netId);
        } catch (Exception e) {
            loge("Exception removing interface: " + e);
        }
    }
}
#end_block

#method_before
private boolean updateRoutes(LinkProperties newLp, LinkProperties oldLp, int netId) {
    // Compare the route diff to determine which routes should be added and removed.
    CompareResult<RouteInfo> routeDiff = new CompareResult<RouteInfo>(oldLp != null ? oldLp.getAllRoutes() : null, newLp != null ? newLp.getAllRoutes() : null);
    // do this twice, adding non-next-hop routes first, then routes they are dependent on
    for (RouteInfo route : routeDiff.added) {
        if (route.hasGateway())
            continue;
        if (VDBG)
            log("Adding Route [" + route + "] to network " + netId);
        try {
            mNetd.addRoute(netId, route);
        } catch (Exception e) {
            if ((route.getDestination().getAddress() instanceof Inet4Address) || VDBG) {
                loge("Exception in addRoute for non-gateway: " + e);
            }
        }
    }
    for (RouteInfo route : routeDiff.added) {
        if (route.hasGateway() == false)
            continue;
        if (VDBG)
            log("Adding Route [" + route + "] to network " + netId);
        try {
            mNetd.addRoute(netId, route);
        } catch (Exception e) {
            if ((route.getGateway() instanceof Inet4Address) || VDBG) {
                loge("Exception in addRoute for gateway: " + e);
            }
        }
    }
    for (RouteInfo route : routeDiff.removed) {
        if (VDBG)
            log("Removing Route [" + route + "] from network " + netId);
        try {
            mNetd.removeRoute(netId, route);
        } catch (Exception e) {
            loge("Exception in removeRoute: " + e);
        }
    }
    return !routeDiff.added.isEmpty() || !routeDiff.removed.isEmpty();
}
#method_after
private boolean updateRoutes(LinkProperties newLp, LinkProperties oldLp, int netId) {
    // Compare the route diff to determine which routes should be added and removed.
    CompareResult<RouteInfo> routeDiff = new CompareResult<RouteInfo>(oldLp != null ? oldLp.getAllRoutes() : null, newLp != null ? newLp.getAllRoutes() : null);
    // do this twice, adding non-next-hop routes first, then routes they are dependent on
    for (RouteInfo route : routeDiff.added) {
        if (route.hasGateway())
            continue;
        if (VDBG)
            log("Adding Route [" + route + "] to network " + netId);
        try {
            mNMS.addRoute(netId, route);
        } catch (Exception e) {
            if ((route.getDestination().getAddress() instanceof Inet4Address) || VDBG) {
                loge("Exception in addRoute for non-gateway: " + e);
            }
        }
    }
    for (RouteInfo route : routeDiff.added) {
        if (route.hasGateway() == false)
            continue;
        if (VDBG)
            log("Adding Route [" + route + "] to network " + netId);
        try {
            mNMS.addRoute(netId, route);
        } catch (Exception e) {
            if ((route.getGateway() instanceof Inet4Address) || VDBG) {
                loge("Exception in addRoute for gateway: " + e);
            }
        }
    }
    for (RouteInfo route : routeDiff.removed) {
        if (VDBG)
            log("Removing Route [" + route + "] from network " + netId);
        try {
            mNMS.removeRoute(netId, route);
        } catch (Exception e) {
            loge("Exception in removeRoute: " + e);
        }
    }
    return !routeDiff.added.isEmpty() || !routeDiff.removed.isEmpty();
}
#end_block

#method_before
private String getNetworkPermission(NetworkCapabilities nc) {
    // TODO: make these permission strings AIDL constants instead.
    if (!nc.hasCapability(NET_CAPABILITY_NOT_RESTRICTED)) {
        return NetworkManagementService.PERMISSION_SYSTEM;
    }
    if (!nc.hasCapability(NET_CAPABILITY_FOREGROUND)) {
        return NetworkManagementService.PERMISSION_NETWORK;
    }
    return null;
}
#method_after
private int getNetworkPermission(NetworkCapabilities nc) {
    if (!nc.hasCapability(NET_CAPABILITY_NOT_RESTRICTED)) {
        return INetd.PERMISSION_SYSTEM;
    }
    if (!nc.hasCapability(NET_CAPABILITY_FOREGROUND)) {
        return INetd.PERMISSION_NETWORK;
    }
    return INetd.PERMISSION_NONE;
}
#end_block

#method_before
private void updateCapabilities(int oldScore, NetworkAgentInfo nai, NetworkCapabilities nc) {
    NetworkCapabilities newNc = mixInCapabilities(nai, nc);
    if (Objects.equals(nai.networkCapabilities, newNc))
        return;
    final String oldPermission = getNetworkPermission(nai.networkCapabilities);
    final String newPermission = getNetworkPermission(newNc);
    if (!Objects.equals(oldPermission, newPermission) && nai.created && !nai.isVPN()) {
        try {
            mNetd.setNetworkPermission(nai.network.netId, newPermission);
        } catch (RemoteException e) {
            loge("Exception in setNetworkPermission: " + e);
        }
    }
    final NetworkCapabilities prevNc;
    synchronized (nai) {
        prevNc = nai.networkCapabilities;
        nai.networkCapabilities = newNc;
    }
    updateUids(nai, prevNc, newNc);
    if (nai.getCurrentScore() == oldScore && newNc.equalRequestableCapabilities(prevNc)) {
        // If the requestable capabilities haven't changed, and the score hasn't changed, then
        // the change we're processing can't affect any requests, it can only affect the listens
        // on this network. We might have been called by rematchNetworkAndRequests when a
        // network changed foreground state.
        processListenRequests(nai, true);
    } else {
        // If the requestable capabilities have changed or the score changed, we can't have been
        // called by rematchNetworkAndRequests, so it's safe to start a rematch.
        rematchAllNetworksAndRequests(nai, oldScore);
        notifyNetworkCallbacks(nai, ConnectivityManager.CALLBACK_CAP_CHANGED);
    }
    if (prevNc != null) {
        final boolean oldMetered = !prevNc.hasCapability(NET_CAPABILITY_NOT_METERED);
        final boolean newMetered = !newNc.hasCapability(NET_CAPABILITY_NOT_METERED);
        final boolean meteredChanged = oldMetered != newMetered;
        if (meteredChanged) {
            maybeNotifyNetworkBlocked(BlockedStatusChangedReason.CAPABILITIES, nai, 0, RULE_NONE, oldMetered, false);
        }
        final boolean roamingChanged = prevNc.hasCapability(NET_CAPABILITY_NOT_ROAMING) != newNc.hasCapability(NET_CAPABILITY_NOT_ROAMING);
        // Report changes that are interesting for network statistics tracking.
        if (meteredChanged || roamingChanged) {
            notifyIfacesChangedForNetworkStats();
        }
    }
    if (!newNc.hasTransport(TRANSPORT_VPN)) {
        // Tell VPNs about updated capabilities, since they may need to
        // bubble those changes through.
        updateAllVpnsCapabilities();
    }
}
#method_after
private void updateCapabilities(int oldScore, NetworkAgentInfo nai, NetworkCapabilities nc) {
    NetworkCapabilities newNc = mixInCapabilities(nai, nc);
    if (Objects.equals(nai.networkCapabilities, newNc))
        return;
    final int oldPermission = getNetworkPermission(nai.networkCapabilities);
    final int newPermission = getNetworkPermission(newNc);
    if (oldPermission != newPermission && nai.created && !nai.isVPN()) {
        try {
            mNMS.setNetworkPermission(nai.network.netId, newPermission);
        } catch (RemoteException e) {
            loge("Exception in setNetworkPermission: " + e);
        }
    }
    final NetworkCapabilities prevNc;
    synchronized (nai) {
        prevNc = nai.networkCapabilities;
        nai.networkCapabilities = newNc;
    }
    updateUids(nai, prevNc, newNc);
    if (nai.getCurrentScore() == oldScore && newNc.equalRequestableCapabilities(prevNc)) {
        // If the requestable capabilities haven't changed, and the score hasn't changed, then
        // the change we're processing can't affect any requests, it can only affect the listens
        // on this network. We might have been called by rematchNetworkAndRequests when a
        // network changed foreground state.
        processListenRequests(nai, true);
    } else {
        // If the requestable capabilities have changed or the score changed, we can't have been
        // called by rematchNetworkAndRequests, so it's safe to start a rematch.
        rematchAllNetworksAndRequests(nai, oldScore);
        notifyNetworkCallbacks(nai, ConnectivityManager.CALLBACK_CAP_CHANGED);
    }
    // Report changes that are interesting for network statistics tracking.
    if (prevNc != null) {
        final boolean meteredChanged = prevNc.hasCapability(NET_CAPABILITY_NOT_METERED) != newNc.hasCapability(NET_CAPABILITY_NOT_METERED);
        final boolean roamingChanged = prevNc.hasCapability(NET_CAPABILITY_NOT_ROAMING) != newNc.hasCapability(NET_CAPABILITY_NOT_ROAMING);
        if (meteredChanged || roamingChanged) {
            notifyIfacesChangedForNetworkStats();
        }
    }
    if (!newNc.hasTransport(TRANSPORT_VPN)) {
        // Tell VPNs about updated capabilities, since they may need to
        // bubble those changes through.
        updateAllVpnsCapabilities();
    }
}
#end_block

#method_before
private void updateUids(NetworkAgentInfo nai, NetworkCapabilities prevNc, NetworkCapabilities newNc) {
    Set<UidRange> prevRanges = null == prevNc ? null : prevNc.getUids();
    Set<UidRange> newRanges = null == newNc ? null : newNc.getUids();
    if (null == prevRanges)
        prevRanges = new ArraySet<>();
    if (null == newRanges)
        newRanges = new ArraySet<>();
    final Set<UidRange> prevRangesCopy = new ArraySet<>(prevRanges);
    prevRanges.removeAll(newRanges);
    newRanges.removeAll(prevRangesCopy);
    try {
        if (!newRanges.isEmpty()) {
            final UidRange[] addedRangesArray = new UidRange[newRanges.size()];
            newRanges.toArray(addedRangesArray);
            mNetd.addVpnUidRanges(nai.network.netId, addedRangesArray);
        }
        if (!prevRanges.isEmpty()) {
            final UidRange[] removedRangesArray = new UidRange[prevRanges.size()];
            prevRanges.toArray(removedRangesArray);
            mNetd.removeVpnUidRanges(nai.network.netId, removedRangesArray);
        }
    } catch (Exception e) {
        // Never crash!
        loge("Exception in updateUids: " + e);
    }
}
#method_after
private void updateUids(NetworkAgentInfo nai, NetworkCapabilities prevNc, NetworkCapabilities newNc) {
    Set<UidRange> prevRanges = null == prevNc ? null : prevNc.getUids();
    Set<UidRange> newRanges = null == newNc ? null : newNc.getUids();
    if (null == prevRanges)
        prevRanges = new ArraySet<>();
    if (null == newRanges)
        newRanges = new ArraySet<>();
    final Set<UidRange> prevRangesCopy = new ArraySet<>(prevRanges);
    prevRanges.removeAll(newRanges);
    newRanges.removeAll(prevRangesCopy);
    try {
        if (!newRanges.isEmpty()) {
            final UidRange[] addedRangesArray = new UidRange[newRanges.size()];
            newRanges.toArray(addedRangesArray);
            mNMS.addVpnUidRanges(nai.network.netId, addedRangesArray);
        }
        if (!prevRanges.isEmpty()) {
            final UidRange[] removedRangesArray = new UidRange[prevRanges.size()];
            prevRanges.toArray(removedRangesArray);
            mNMS.removeVpnUidRanges(nai.network.netId, removedRangesArray);
        }
    } catch (Exception e) {
        // Never crash!
        loge("Exception in updateUids: " + e);
    }
}
#end_block

#method_before
private void callCallbackForRequest(NetworkRequestInfo nri, NetworkAgentInfo networkAgent, int notificationType, int arg1) {
    if (nri.messenger == null) {
        // Default request has no msgr
        return;
    }
    Bundle bundle = new Bundle();
    // TODO: check if defensive copies of data is needed.
    putParcelable(bundle, new NetworkRequest(nri.request));
    Message msg = Message.obtain();
    if (notificationType != ConnectivityManager.CALLBACK_UNAVAIL) {
        putParcelable(bundle, networkAgent.network);
    }
    switch(notificationType) {
        case ConnectivityManager.CALLBACK_AVAILABLE:
            {
                putParcelable(bundle, new NetworkCapabilities(networkAgent.networkCapabilities));
                putParcelable(bundle, new LinkProperties(networkAgent.linkProperties));
                // For this notification, arg1 contains the blocked status.
                msg.arg1 = arg1;
                break;
            }
        case ConnectivityManager.CALLBACK_LOSING:
            {
                msg.arg1 = arg1;
                break;
            }
        case ConnectivityManager.CALLBACK_CAP_CHANGED:
            {
                // networkAgent can't be null as it has been accessed a few lines above.
                final NetworkCapabilities nc = networkCapabilitiesRestrictedForCallerPermissions(networkAgent.networkCapabilities, nri.mPid, nri.mUid);
                putParcelable(bundle, nc);
                break;
            }
        case ConnectivityManager.CALLBACK_IP_CHANGED:
            {
                putParcelable(bundle, new LinkProperties(networkAgent.linkProperties));
                break;
            }
        case ConnectivityManager.CALLBACK_BLK_CHANGED:
            {
                msg.arg1 = arg1;
                break;
            }
    }
    msg.what = notificationType;
    msg.setData(bundle);
    try {
        if (VDBG) {
            String notification = ConnectivityManager.getCallbackName(notificationType);
            log("sending notification " + notification + " for " + nri.request);
        }
        nri.messenger.send(msg);
    } catch (RemoteException e) {
        // may occur naturally in the race of binder death.
        loge("RemoteException caught trying to send a callback msg for " + nri.request);
    }
}
#method_after
private void callCallbackForRequest(NetworkRequestInfo nri, NetworkAgentInfo networkAgent, int notificationType, int arg1) {
    if (nri.messenger == null) {
        // Default request has no msgr
        return;
    }
    Bundle bundle = new Bundle();
    // TODO: check if defensive copies of data is needed.
    putParcelable(bundle, new NetworkRequest(nri.request));
    Message msg = Message.obtain();
    if (notificationType != ConnectivityManager.CALLBACK_UNAVAIL) {
        putParcelable(bundle, networkAgent.network);
    }
    switch(notificationType) {
        case ConnectivityManager.CALLBACK_AVAILABLE:
            {
                putParcelable(bundle, new NetworkCapabilities(networkAgent.networkCapabilities));
                putParcelable(bundle, new LinkProperties(networkAgent.linkProperties));
                break;
            }
        case ConnectivityManager.CALLBACK_LOSING:
            {
                msg.arg1 = arg1;
                break;
            }
        case ConnectivityManager.CALLBACK_CAP_CHANGED:
            {
                // networkAgent can't be null as it has been accessed a few lines above.
                final NetworkCapabilities nc = networkCapabilitiesRestrictedForCallerPermissions(networkAgent.networkCapabilities, nri.mPid, nri.mUid);
                putParcelable(bundle, nc);
                break;
            }
        case ConnectivityManager.CALLBACK_IP_CHANGED:
            {
                putParcelable(bundle, new LinkProperties(networkAgent.linkProperties));
                break;
            }
    }
    msg.what = notificationType;
    msg.setData(bundle);
    try {
        if (VDBG) {
            String notification = ConnectivityManager.getCallbackName(notificationType);
            log("sending notification " + notification + " for " + nri.request);
        }
        nri.messenger.send(msg);
    } catch (RemoteException e) {
        // may occur naturally in the race of binder death.
        loge("RemoteException caught trying to send a callback msg for " + nri.request);
    }
}
#end_block

#method_before
private void makeDefault(NetworkAgentInfo newNetwork) {
    if (DBG)
        log("Switching to new default network: " + newNetwork);
    setupDataActivityTracking(newNetwork);
    try {
        mNetd.setDefaultNetId(newNetwork.network.netId);
    } catch (Exception e) {
        loge("Exception setting default network :" + e);
    }
    notifyLockdownVpn(newNetwork);
    handleApplyDefaultProxy(newNetwork.linkProperties.getHttpProxy());
    updateTcpBufferSizes(newNetwork);
    mDnsManager.setDefaultDnsSystemProperties(newNetwork.linkProperties.getDnsServers());
    notifyIfacesChangedForNetworkStats();
}
#method_after
private void makeDefault(NetworkAgentInfo newNetwork) {
    if (DBG)
        log("Switching to new default network: " + newNetwork);
    try {
        mNMS.setDefaultNetId(newNetwork.network.netId);
    } catch (Exception e) {
        loge("Exception setting default network :" + e);
    }
    notifyLockdownVpn(newNetwork);
    handleApplyDefaultProxy(newNetwork.linkProperties.getHttpProxy());
    updateTcpBufferSizes(newNetwork);
    mDnsManager.setDefaultDnsSystemProperties(newNetwork.linkProperties.getDnsServers());
    notifyIfacesChangedForNetworkStats();
}
#end_block

#method_before
// Handles a network appearing or improving its score.
// 
// - Evaluates all current NetworkRequests that can be
// satisfied by newNetwork, and reassigns to newNetwork
// any such requests for which newNetwork is the best.
// 
// - Lingers any validated Networks that as a result are no longer
// needed. A network is needed if it is the best network for
// one or more NetworkRequests, or if it is a VPN.
// 
// - Tears down newNetwork if it just became validated
// but turns out to be unneeded.
// 
// - If reapUnvalidatedNetworks==REAP, tears down unvalidated
// networks that have no chance (i.e. even if validated)
// of becoming the highest scoring network.
// 
// NOTE: This function only adds NetworkRequests that "newNetwork" could satisfy,
// it does not remove NetworkRequests that other Networks could better satisfy.
// If you need to handle decreases in score, use {@link rematchAllNetworksAndRequests}.
// This function should be used when possible instead of {@code rematchAllNetworksAndRequests}
// as it performs better by a factor of the number of Networks.
// 
// @param newNetwork is the network to be matched against NetworkRequests.
// @param reapUnvalidatedNetworks indicates if an additional pass over all networks should be
// performed to tear down unvalidated networks that have no chance (i.e. even if
private void rematchNetworkAndRequests(NetworkAgentInfo newNetwork, ReapUnvalidatedNetworks reapUnvalidatedNetworks, long now) {
    if (!newNetwork.everConnected)
        return;
    boolean keep = newNetwork.isVPN();
    boolean isNewDefault = false;
    NetworkAgentInfo oldDefaultNetwork = null;
    final boolean wasBackgroundNetwork = newNetwork.isBackgroundNetwork();
    final int score = newNetwork.getCurrentScore();
    if (VDBG)
        log("rematching " + newNetwork.name());
    // Find and migrate to this Network any NetworkRequests for
    // which this network is now the best.
    ArrayList<NetworkAgentInfo> affectedNetworks = new ArrayList<>();
    ArrayList<NetworkRequestInfo> addedRequests = new ArrayList<>();
    NetworkCapabilities nc = newNetwork.networkCapabilities;
    if (VDBG)
        log(" network has: " + nc);
    for (NetworkRequestInfo nri : mNetworkRequests.values()) {
        // requests or not, and doesn't affect the network's score.
        if (nri.request.isListen())
            continue;
        final NetworkAgentInfo currentNetwork = getNetworkForRequest(nri.request.requestId);
        final boolean satisfies = newNetwork.satisfies(nri.request);
        if (newNetwork == currentNetwork && satisfies) {
            if (VDBG) {
                log("Network " + newNetwork.name() + " was already satisfying" + " request " + nri.request.requestId + ". No change.");
            }
            keep = true;
            continue;
        }
        // check if it satisfies the NetworkCapabilities
        if (VDBG)
            log("  checking if request is satisfied: " + nri.request);
        if (satisfies) {
            // this request
            if (VDBG) {
                log("currentScore = " + (currentNetwork != null ? currentNetwork.getCurrentScore() : 0) + ", newScore = " + score);
            }
            if (currentNetwork == null || currentNetwork.getCurrentScore() < score) {
                if (VDBG)
                    log("rematch for " + newNetwork.name());
                if (currentNetwork != null) {
                    if (VDBG)
                        log("   accepting network in place of " + currentNetwork.name());
                    currentNetwork.removeRequest(nri.request.requestId);
                    currentNetwork.lingerRequest(nri.request, now, mLingerDelayMs);
                    affectedNetworks.add(currentNetwork);
                } else {
                    if (VDBG)
                        log("   accepting network in place of null");
                }
                newNetwork.unlingerRequest(nri.request);
                setNetworkForRequest(nri.request.requestId, newNetwork);
                if (!newNetwork.addRequest(nri.request)) {
                    Slog.wtf(TAG, "BUG: " + newNetwork.name() + " already has " + nri.request);
                }
                addedRequests.add(nri);
                keep = true;
                // Tell NetworkFactories about the new score, so they can stop
                // trying to connect if they know they cannot match it.
                // TODO - this could get expensive if we have a lot of requests for this
                // network.  Think about if there is a way to reduce this.  Push
                // netid->request mapping to each factory?
                sendUpdatedScoreToFactories(nri.request, score);
                if (isDefaultRequest(nri)) {
                    isNewDefault = true;
                    oldDefaultNetwork = currentNetwork;
                    if (currentNetwork != null) {
                        mLingerMonitor.noteLingerDefaultNetwork(currentNetwork, newNetwork);
                    }
                }
            }
        } else if (newNetwork.isSatisfyingRequest(nri.request.requestId)) {
            // longer satisfies "nri" when "currentNetwork" does not equal "newNetwork".
            if (DBG) {
                log("Network " + newNetwork.name() + " stopped satisfying" + " request " + nri.request.requestId);
            }
            newNetwork.removeRequest(nri.request.requestId);
            if (currentNetwork == newNetwork) {
                clearNetworkForRequest(nri.request.requestId);
                sendUpdatedScoreToFactories(nri.request, 0);
            } else {
                Slog.wtf(TAG, "BUG: Removing request " + nri.request.requestId + " from " + newNetwork.name() + " without updating mNetworkForRequestId or factories!");
            }
            // TODO: Technically, sending CALLBACK_LOST here is
            // incorrect if there is a replacement network currently
            // connected that can satisfy nri, which is a request
            // (not a listen). However, the only capability that can both
            // a) be requested and b) change is NET_CAPABILITY_TRUSTED,
            // so this code is only incorrect for a network that loses
            // the TRUSTED capability, which is a rare case.
            callCallbackForRequest(nri, newNetwork, ConnectivityManager.CALLBACK_LOST, 0);
        }
    }
    if (isNewDefault) {
        // Notify system services that this network is up.
        makeDefault(newNetwork);
        // Log 0 -> X and Y -> X default network transitions, where X is the new default.
        metricsLogger().defaultNetworkMetrics().logDefaultNetworkEvent(now, newNetwork, oldDefaultNetwork);
        // Have a new default network, release the transition wakelock in
        scheduleReleaseNetworkTransitionWakelock();
    }
    if (!newNetwork.networkCapabilities.equalRequestableCapabilities(nc)) {
        Slog.wtf(TAG, String.format("BUG: %s changed requestable capabilities during rematch: %s -> %s", newNetwork.name(), nc, newNetwork.networkCapabilities));
    }
    if (newNetwork.getCurrentScore() != score) {
        Slog.wtf(TAG, String.format("BUG: %s changed score during rematch: %d -> %d", newNetwork.name(), score, newNetwork.getCurrentScore()));
    }
    // Second pass: process all listens.
    if (wasBackgroundNetwork != newNetwork.isBackgroundNetwork()) {
        // If the network went from background to foreground or vice versa, we need to update
        // its foreground state. It is safe to do this after rematching the requests because
        // NET_CAPABILITY_FOREGROUND does not affect requests, as is not a requestable
        // capability and does not affect the network's score (see the Slog.wtf call above).
        updateCapabilities(score, newNetwork, newNetwork.networkCapabilities);
    } else {
        processListenRequests(newNetwork, false);
    }
    // before LegacyTypeTracker sends legacy broadcasts
    for (NetworkRequestInfo nri : addedRequests) notifyNetworkAvailable(newNetwork, nri);
    // available callback for newNetwork.
    for (NetworkAgentInfo nai : affectedNetworks) {
        updateLingerState(nai, now);
    }
    // Possibly unlinger newNetwork. Unlingering a network does not send any callbacks so it
    // does not need to be done in any particular order.
    updateLingerState(newNetwork, now);
    if (isNewDefault) {
        // the new one connected.
        if (oldDefaultNetwork != null) {
            mLegacyTypeTracker.remove(oldDefaultNetwork.networkInfo.getType(), oldDefaultNetwork, true);
        }
        mDefaultInetConditionPublished = newNetwork.lastValidated ? 100 : 0;
        mLegacyTypeTracker.add(newNetwork.networkInfo.getType(), newNetwork);
        notifyLockdownVpn(newNetwork);
    }
    if (keep) {
        // TODO: Avoid redoing this; this must only be done once when a network comes online.
        try {
            final IBatteryStats bs = BatteryStatsService.getService();
            final int type = newNetwork.networkInfo.getType();
            final String baseIface = newNetwork.linkProperties.getInterfaceName();
            bs.noteNetworkInterfaceType(baseIface, type);
            for (LinkProperties stacked : newNetwork.linkProperties.getStackedLinks()) {
                final String stackedIface = stacked.getInterfaceName();
                bs.noteNetworkInterfaceType(stackedIface, type);
            }
        } catch (RemoteException ignored) {
        }
        // This is on top of the multiple intent sequencing referenced in the todo above.
        for (int i = 0; i < newNetwork.numNetworkRequests(); i++) {
            NetworkRequest nr = newNetwork.requestAt(i);
            if (nr.legacyType != TYPE_NONE && nr.isRequest()) {
                // legacy type tracker filters out repeat adds
                mLegacyTypeTracker.add(nr.legacyType, newNetwork);
            }
        }
        // newNetwork to the tracker explicitly (it's a no-op if it has already been added).
        if (newNetwork.isVPN()) {
            mLegacyTypeTracker.add(TYPE_VPN, newNetwork);
        }
    }
    if (reapUnvalidatedNetworks == ReapUnvalidatedNetworks.REAP) {
        for (NetworkAgentInfo nai : mNetworkAgentInfos.values()) {
            if (unneeded(nai, UnneededFor.TEARDOWN)) {
                if (nai.getLingerExpiry() > 0) {
                    // This network has active linger timers and no requests, but is not
                    // lingering. Linger it.
                    // 
                    // One way (the only way?) this can happen if this network is unvalidated
                    // and became unneeded due to another network improving its score to the
                    // point where this network will no longer be able to satisfy any requests
                    // even if it validates.
                    updateLingerState(nai, now);
                } else {
                    if (DBG)
                        log("Reaping " + nai.name());
                    teardownUnneededNetwork(nai);
                }
            }
        }
    }
}
#method_after
// Handles a network appearing or improving its score.
// 
// - Evaluates all current NetworkRequests that can be
// satisfied by newNetwork, and reassigns to newNetwork
// any such requests for which newNetwork is the best.
// 
// - Lingers any validated Networks that as a result are no longer
// needed. A network is needed if it is the best network for
// one or more NetworkRequests, or if it is a VPN.
// 
// - Tears down newNetwork if it just became validated
// but turns out to be unneeded.
// 
// - If reapUnvalidatedNetworks==REAP, tears down unvalidated
// networks that have no chance (i.e. even if validated)
// of becoming the highest scoring network.
// 
// NOTE: This function only adds NetworkRequests that "newNetwork" could satisfy,
// it does not remove NetworkRequests that other Networks could better satisfy.
// If you need to handle decreases in score, use {@link rematchAllNetworksAndRequests}.
// This function should be used when possible instead of {@code rematchAllNetworksAndRequests}
// as it performs better by a factor of the number of Networks.
// 
// @param newNetwork is the network to be matched against NetworkRequests.
// @param reapUnvalidatedNetworks indicates if an additional pass over all networks should be
// performed to tear down unvalidated networks that have no chance (i.e. even if
private void rematchNetworkAndRequests(NetworkAgentInfo newNetwork, ReapUnvalidatedNetworks reapUnvalidatedNetworks, long now) {
    if (!newNetwork.everConnected)
        return;
    boolean keep = newNetwork.isVPN();
    boolean isNewDefault = false;
    NetworkAgentInfo oldDefaultNetwork = null;
    final boolean wasBackgroundNetwork = newNetwork.isBackgroundNetwork();
    final int score = newNetwork.getCurrentScore();
    if (VDBG)
        log("rematching " + newNetwork.name());
    // Find and migrate to this Network any NetworkRequests for
    // which this network is now the best.
    ArrayList<NetworkAgentInfo> affectedNetworks = new ArrayList<>();
    ArrayList<NetworkRequestInfo> addedRequests = new ArrayList<>();
    NetworkCapabilities nc = newNetwork.networkCapabilities;
    if (VDBG)
        log(" network has: " + nc);
    for (NetworkRequestInfo nri : mNetworkRequests.values()) {
        // requests or not, and doesn't affect the network's score.
        if (nri.request.isListen())
            continue;
        final NetworkAgentInfo currentNetwork = getNetworkForRequest(nri.request.requestId);
        final boolean satisfies = newNetwork.satisfies(nri.request);
        if (newNetwork == currentNetwork && satisfies) {
            if (VDBG) {
                log("Network " + newNetwork.name() + " was already satisfying" + " request " + nri.request.requestId + ". No change.");
            }
            keep = true;
            continue;
        }
        // check if it satisfies the NetworkCapabilities
        if (VDBG)
            log("  checking if request is satisfied: " + nri.request);
        if (satisfies) {
            // this request
            if (VDBG) {
                log("currentScore = " + (currentNetwork != null ? currentNetwork.getCurrentScore() : 0) + ", newScore = " + score);
            }
            if (currentNetwork == null || currentNetwork.getCurrentScore() < score) {
                if (VDBG)
                    log("rematch for " + newNetwork.name());
                if (currentNetwork != null) {
                    if (VDBG)
                        log("   accepting network in place of " + currentNetwork.name());
                    currentNetwork.removeRequest(nri.request.requestId);
                    currentNetwork.lingerRequest(nri.request, now, mLingerDelayMs);
                    affectedNetworks.add(currentNetwork);
                } else {
                    if (VDBG)
                        log("   accepting network in place of null");
                }
                newNetwork.unlingerRequest(nri.request);
                setNetworkForRequest(nri.request.requestId, newNetwork);
                if (!newNetwork.addRequest(nri.request)) {
                    Slog.wtf(TAG, "BUG: " + newNetwork.name() + " already has " + nri.request);
                }
                addedRequests.add(nri);
                keep = true;
                // Tell NetworkFactories about the new score, so they can stop
                // trying to connect if they know they cannot match it.
                // TODO - this could get expensive if we have a lot of requests for this
                // network.  Think about if there is a way to reduce this.  Push
                // netid->request mapping to each factory?
                sendUpdatedScoreToFactories(nri.request, score);
                if (isDefaultRequest(nri)) {
                    isNewDefault = true;
                    oldDefaultNetwork = currentNetwork;
                    if (currentNetwork != null) {
                        mLingerMonitor.noteLingerDefaultNetwork(currentNetwork, newNetwork);
                    }
                }
            }
        } else if (newNetwork.isSatisfyingRequest(nri.request.requestId)) {
            // longer satisfies "nri" when "currentNetwork" does not equal "newNetwork".
            if (DBG) {
                log("Network " + newNetwork.name() + " stopped satisfying" + " request " + nri.request.requestId);
            }
            newNetwork.removeRequest(nri.request.requestId);
            if (currentNetwork == newNetwork) {
                clearNetworkForRequest(nri.request.requestId);
                sendUpdatedScoreToFactories(nri.request, 0);
            } else {
                Slog.wtf(TAG, "BUG: Removing request " + nri.request.requestId + " from " + newNetwork.name() + " without updating mNetworkForRequestId or factories!");
            }
            // TODO: Technically, sending CALLBACK_LOST here is
            // incorrect if there is a replacement network currently
            // connected that can satisfy nri, which is a request
            // (not a listen). However, the only capability that can both
            // a) be requested and b) change is NET_CAPABILITY_TRUSTED,
            // so this code is only incorrect for a network that loses
            // the TRUSTED capability, which is a rare case.
            callCallbackForRequest(nri, newNetwork, ConnectivityManager.CALLBACK_LOST, 0);
        }
    }
    if (isNewDefault) {
        updateDataActivityTracking(newNetwork, oldDefaultNetwork);
        // Notify system services that this network is up.
        makeDefault(newNetwork);
        // Log 0 -> X and Y -> X default network transitions, where X is the new default.
        metricsLogger().defaultNetworkMetrics().logDefaultNetworkEvent(now, newNetwork, oldDefaultNetwork);
        // Have a new default network, release the transition wakelock in
        scheduleReleaseNetworkTransitionWakelock();
    }
    if (!newNetwork.networkCapabilities.equalRequestableCapabilities(nc)) {
        Slog.wtf(TAG, String.format("BUG: %s changed requestable capabilities during rematch: %s -> %s", newNetwork.name(), nc, newNetwork.networkCapabilities));
    }
    if (newNetwork.getCurrentScore() != score) {
        Slog.wtf(TAG, String.format("BUG: %s changed score during rematch: %d -> %d", newNetwork.name(), score, newNetwork.getCurrentScore()));
    }
    // Second pass: process all listens.
    if (wasBackgroundNetwork != newNetwork.isBackgroundNetwork()) {
        // If the network went from background to foreground or vice versa, we need to update
        // its foreground state. It is safe to do this after rematching the requests because
        // NET_CAPABILITY_FOREGROUND does not affect requests, as is not a requestable
        // capability and does not affect the network's score (see the Slog.wtf call above).
        updateCapabilities(score, newNetwork, newNetwork.networkCapabilities);
    } else {
        processListenRequests(newNetwork, false);
    }
    // before LegacyTypeTracker sends legacy broadcasts
    for (NetworkRequestInfo nri : addedRequests) notifyNetworkAvailable(newNetwork, nri);
    // available callback for newNetwork.
    for (NetworkAgentInfo nai : affectedNetworks) {
        updateLingerState(nai, now);
    }
    // Possibly unlinger newNetwork. Unlingering a network does not send any callbacks so it
    // does not need to be done in any particular order.
    updateLingerState(newNetwork, now);
    if (isNewDefault) {
        // the new one connected.
        if (oldDefaultNetwork != null) {
            mLegacyTypeTracker.remove(oldDefaultNetwork.networkInfo.getType(), oldDefaultNetwork, true);
        }
        mDefaultInetConditionPublished = newNetwork.lastValidated ? 100 : 0;
        mLegacyTypeTracker.add(newNetwork.networkInfo.getType(), newNetwork);
        notifyLockdownVpn(newNetwork);
    }
    if (keep) {
        // TODO: Avoid redoing this; this must only be done once when a network comes online.
        try {
            final IBatteryStats bs = BatteryStatsService.getService();
            final int type = newNetwork.networkInfo.getType();
            final String baseIface = newNetwork.linkProperties.getInterfaceName();
            bs.noteNetworkInterfaceType(baseIface, type);
            for (LinkProperties stacked : newNetwork.linkProperties.getStackedLinks()) {
                final String stackedIface = stacked.getInterfaceName();
                bs.noteNetworkInterfaceType(stackedIface, type);
            }
        } catch (RemoteException ignored) {
        }
        // This is on top of the multiple intent sequencing referenced in the todo above.
        for (int i = 0; i < newNetwork.numNetworkRequests(); i++) {
            NetworkRequest nr = newNetwork.requestAt(i);
            if (nr.legacyType != TYPE_NONE && nr.isRequest()) {
                // legacy type tracker filters out repeat adds
                mLegacyTypeTracker.add(nr.legacyType, newNetwork);
            }
        }
        // newNetwork to the tracker explicitly (it's a no-op if it has already been added).
        if (newNetwork.isVPN()) {
            mLegacyTypeTracker.add(TYPE_VPN, newNetwork);
        }
    }
    if (reapUnvalidatedNetworks == ReapUnvalidatedNetworks.REAP) {
        for (NetworkAgentInfo nai : mNetworkAgentInfos.values()) {
            if (unneeded(nai, UnneededFor.TEARDOWN)) {
                if (nai.getLingerExpiry() > 0) {
                    // This network has active linger timers and no requests, but is not
                    // lingering. Linger it.
                    // 
                    // One way (the only way?) this can happen if this network is unvalidated
                    // and became unneeded due to another network improving its score to the
                    // point where this network will no longer be able to satisfy any requests
                    // even if it validates.
                    updateLingerState(nai, now);
                } else {
                    if (DBG)
                        log("Reaping " + nai.name());
                    teardownUnneededNetwork(nai);
                }
            }
        }
    }
}
#end_block

#method_before
private void updateNetworkInfo(NetworkAgentInfo networkAgent, NetworkInfo newInfo) {
    final NetworkInfo.State state = newInfo.getState();
    NetworkInfo oldInfo = null;
    final int oldScore = networkAgent.getCurrentScore();
    synchronized (networkAgent) {
        oldInfo = networkAgent.networkInfo;
        networkAgent.networkInfo = newInfo;
    }
    notifyLockdownVpn(networkAgent);
    if (DBG) {
        log(networkAgent.name() + " EVENT_NETWORK_INFO_CHANGED, going from " + (oldInfo == null ? "null" : oldInfo.getState()) + " to " + state);
    }
    if (!networkAgent.created && (state == NetworkInfo.State.CONNECTED || (state == NetworkInfo.State.CONNECTING && networkAgent.isVPN()))) {
        // A network that has just connected has zero requests and is thus a foreground network.
        networkAgent.networkCapabilities.addCapability(NET_CAPABILITY_FOREGROUND);
        try {
            // This should never fail.  Specifying an already in use NetID will cause failure.
            if (networkAgent.isVPN()) {
                mNetd.createVirtualNetwork(networkAgent.network.netId, !networkAgent.linkProperties.getDnsServers().isEmpty(), (networkAgent.networkMisc == null || !networkAgent.networkMisc.allowBypass));
            } else {
                mNetd.createPhysicalNetwork(networkAgent.network.netId, getNetworkPermission(networkAgent.networkCapabilities));
            }
        } catch (Exception e) {
            loge("Error creating network " + networkAgent.network.netId + ": " + e.getMessage());
            return;
        }
        networkAgent.created = true;
    }
    if (!networkAgent.everConnected && state == NetworkInfo.State.CONNECTED) {
        networkAgent.everConnected = true;
        if (networkAgent.linkProperties == null) {
            Slog.wtf(TAG, networkAgent.name() + " connected with null LinkProperties");
        }
        handlePerNetworkPrivateDnsConfig(networkAgent, mDnsManager.getPrivateDnsConfig());
        updateLinkProperties(networkAgent, null);
        networkAgent.networkMonitor.sendMessage(NetworkMonitor.CMD_NETWORK_CONNECTED);
        scheduleUnvalidatedPrompt(networkAgent);
        if (networkAgent.isVPN()) {
            // Temporarily disable the default proxy (not global).
            synchronized (mProxyTracker.mProxyLock) {
                if (!mProxyTracker.mDefaultProxyDisabled) {
                    mProxyTracker.mDefaultProxyDisabled = true;
                    if (mProxyTracker.mGlobalProxy == null && mProxyTracker.mDefaultProxy != null) {
                        mProxyTracker.sendProxyBroadcast(null);
                    }
                }
            }
        // TODO: support proxy per network.
        }
        // Whether a particular NetworkRequest listen should cause signal strength thresholds to
        // be communicated to a particular NetworkAgent depends only on the network's immutable,
        // capabilities, so it only needs to be done once on initial connect, not every time the
        // network's capabilities change. Note that we do this before rematching the network,
        // so we could decide to tear it down immediately afterwards. That's fine though - on
        // disconnection NetworkAgents should stop any signal strength monitoring they have been
        // doing.
        updateSignalStrengthThresholds(networkAgent, "CONNECT", null);
        // Consider network even though it is not yet validated.
        final long now = SystemClock.elapsedRealtime();
        rematchNetworkAndRequests(networkAgent, ReapUnvalidatedNetworks.REAP, now);
        // This has to happen after matching the requests, because callbacks are just requests.
        notifyNetworkCallbacks(networkAgent, ConnectivityManager.CALLBACK_PRECHECK);
    } else if (state == NetworkInfo.State.DISCONNECTED) {
        networkAgent.asyncChannel.disconnect();
        if (networkAgent.isVPN()) {
            synchronized (mProxyTracker.mProxyLock) {
                if (mProxyTracker.mDefaultProxyDisabled) {
                    mProxyTracker.mDefaultProxyDisabled = false;
                    if (mProxyTracker.mGlobalProxy == null && mProxyTracker.mDefaultProxy != null) {
                        mProxyTracker.sendProxyBroadcast(mProxyTracker.mDefaultProxy);
                    }
                }
            }
            updateUids(networkAgent, networkAgent.networkCapabilities, null);
        }
        disconnectAndDestroyNetwork(networkAgent);
    } else if ((oldInfo != null && oldInfo.getState() == NetworkInfo.State.SUSPENDED) || state == NetworkInfo.State.SUSPENDED) {
        // going into or coming out of SUSPEND: re-score and notify
        if (networkAgent.getCurrentScore() != oldScore) {
            rematchAllNetworksAndRequests(networkAgent, oldScore);
        }
        updateCapabilities(networkAgent.getCurrentScore(), networkAgent, networkAgent.networkCapabilities);
        // TODO (b/73132094) : remove this call once the few users of onSuspended and
        // onResumed have been removed.
        notifyNetworkCallbacks(networkAgent, (state == NetworkInfo.State.SUSPENDED ? ConnectivityManager.CALLBACK_SUSPENDED : ConnectivityManager.CALLBACK_RESUMED));
        mLegacyTypeTracker.update(networkAgent);
    }
}
#method_after
private void updateNetworkInfo(NetworkAgentInfo networkAgent, NetworkInfo newInfo) {
    final NetworkInfo.State state = newInfo.getState();
    NetworkInfo oldInfo = null;
    final int oldScore = networkAgent.getCurrentScore();
    synchronized (networkAgent) {
        oldInfo = networkAgent.networkInfo;
        networkAgent.networkInfo = newInfo;
    }
    notifyLockdownVpn(networkAgent);
    if (DBG) {
        log(networkAgent.name() + " EVENT_NETWORK_INFO_CHANGED, going from " + (oldInfo == null ? "null" : oldInfo.getState()) + " to " + state);
    }
    if (!networkAgent.created && (state == NetworkInfo.State.CONNECTED || (state == NetworkInfo.State.CONNECTING && networkAgent.isVPN()))) {
        // A network that has just connected has zero requests and is thus a foreground network.
        networkAgent.networkCapabilities.addCapability(NET_CAPABILITY_FOREGROUND);
        try {
            // This should never fail.  Specifying an already in use NetID will cause failure.
            if (networkAgent.isVPN()) {
                mNMS.createVirtualNetwork(networkAgent.network.netId, !networkAgent.linkProperties.getDnsServers().isEmpty(), (networkAgent.networkMisc == null || !networkAgent.networkMisc.allowBypass));
            } else {
                mNMS.createPhysicalNetwork(networkAgent.network.netId, getNetworkPermission(networkAgent.networkCapabilities));
            }
        } catch (Exception e) {
            loge("Error creating network " + networkAgent.network.netId + ": " + e.getMessage());
            return;
        }
        networkAgent.created = true;
    }
    if (!networkAgent.everConnected && state == NetworkInfo.State.CONNECTED) {
        networkAgent.everConnected = true;
        if (networkAgent.linkProperties == null) {
            Slog.wtf(TAG, networkAgent.name() + " connected with null LinkProperties");
        }
        handlePerNetworkPrivateDnsConfig(networkAgent, mDnsManager.getPrivateDnsConfig());
        updateLinkProperties(networkAgent, null);
        networkAgent.networkMonitor.sendMessage(NetworkMonitor.CMD_NETWORK_CONNECTED);
        scheduleUnvalidatedPrompt(networkAgent);
        if (networkAgent.isVPN()) {
            // Temporarily disable the default proxy (not global).
            mProxyTracker.setDefaultProxyEnabled(false);
        // TODO: support proxy per network.
        }
        // Whether a particular NetworkRequest listen should cause signal strength thresholds to
        // be communicated to a particular NetworkAgent depends only on the network's immutable,
        // capabilities, so it only needs to be done once on initial connect, not every time the
        // network's capabilities change. Note that we do this before rematching the network,
        // so we could decide to tear it down immediately afterwards. That's fine though - on
        // disconnection NetworkAgents should stop any signal strength monitoring they have been
        // doing.
        updateSignalStrengthThresholds(networkAgent, "CONNECT", null);
        // Consider network even though it is not yet validated.
        final long now = SystemClock.elapsedRealtime();
        rematchNetworkAndRequests(networkAgent, ReapUnvalidatedNetworks.REAP, now);
        // This has to happen after matching the requests, because callbacks are just requests.
        notifyNetworkCallbacks(networkAgent, ConnectivityManager.CALLBACK_PRECHECK);
    } else if (state == NetworkInfo.State.DISCONNECTED) {
        networkAgent.asyncChannel.disconnect();
        if (networkAgent.isVPN()) {
            mProxyTracker.setDefaultProxyEnabled(true);
            updateUids(networkAgent, networkAgent.networkCapabilities, null);
        }
        disconnectAndDestroyNetwork(networkAgent);
    } else if ((oldInfo != null && oldInfo.getState() == NetworkInfo.State.SUSPENDED) || state == NetworkInfo.State.SUSPENDED) {
        // going into or coming out of SUSPEND: re-score and notify
        if (networkAgent.getCurrentScore() != oldScore) {
            rematchAllNetworksAndRequests(networkAgent, oldScore);
        }
        updateCapabilities(networkAgent.getCurrentScore(), networkAgent, networkAgent.networkCapabilities);
        // TODO (b/73132094) : remove this call once the few users of onSuspended and
        // onResumed have been removed.
        notifyNetworkCallbacks(networkAgent, (state == NetworkInfo.State.SUSPENDED ? ConnectivityManager.CALLBACK_SUSPENDED : ConnectivityManager.CALLBACK_RESUMED));
        mLegacyTypeTracker.update(networkAgent);
    }
}
#end_block

#method_before
// Notify only this one new request of the current state. Transfer all the
// current state by calling NetworkCapabilities and LinkProperties callbacks
// so that callers can be guaranteed to have as close to atomicity in state
protected void notifyNetworkAvailable(NetworkAgentInfo nai, NetworkRequestInfo nri) {
    mHandler.removeMessages(EVENT_TIMEOUT_NETWORK_REQUEST, nri);
    if (nri.mPendingIntent != null) {
        sendPendingIntentForRequest(nri, nai, ConnectivityManager.CALLBACK_AVAILABLE);
        // Attempt no subsequent state pushes where intents are involved.
        return;
    }
    final boolean metered = !nai.networkCapabilities.hasCapability(NetworkCapabilities.NET_CAPABILITY_NOT_METERED);
    final boolean blocked = isUidNetworkingWithVpnBlocked(nri.mUid, mUidRules.get(nri.mUid), metered, mRestrictBackground);
    callCallbackForRequest(nri, nai, ConnectivityManager.CALLBACK_AVAILABLE, blocked ? 1 : 0);
}
#method_after
// Notify only this one new request of the current state. Transfer all the
// current state by calling NetworkCapabilities and LinkProperties callbacks
// so that callers can be guaranteed to have as close to atomicity in state
protected void notifyNetworkAvailable(NetworkAgentInfo nai, NetworkRequestInfo nri) {
    mHandler.removeMessages(EVENT_TIMEOUT_NETWORK_REQUEST, nri);
    if (nri.mPendingIntent != null) {
        sendPendingIntentForRequest(nri, nai, ConnectivityManager.CALLBACK_AVAILABLE);
        // Attempt no subsequent state pushes where intents are involved.
        return;
    }
    callCallbackForRequest(nri, nai, ConnectivityManager.CALLBACK_AVAILABLE, 0);
}
#end_block

#method_before
/**
 * Exhaustively test isUidNetworkingBlocked to output the expected results based on external
 * conditions.
 */
@Test
public void testIsUidNetworkingBlocked() {
    final NetworkPolicyManagerInternal internal = LocalServices.getService(NetworkPolicyManagerInternal.class);
    assertFalse(internal.isUidNetworkingBlocked(SYSTEM_UID, RULE_NONE, false, false));
    assertFalse(internal.isUidNetworkingBlocked(SYSTEM_UID, RULE_NONE, false, true));
    assertFalse(internal.isUidNetworkingBlocked(SYSTEM_UID, RULE_NONE, true, false));
    assertFalse(internal.isUidNetworkingBlocked(SYSTEM_UID, RULE_NONE, true, true));
    assertFalse(internal.isUidNetworkingBlocked(SYSTEM_UID, RULE_ALLOW_METERED, false, false));
    assertFalse(internal.isUidNetworkingBlocked(SYSTEM_UID, RULE_ALLOW_METERED, false, true));
    assertFalse(internal.isUidNetworkingBlocked(SYSTEM_UID, RULE_ALLOW_METERED, true, false));
    assertFalse(internal.isUidNetworkingBlocked(SYSTEM_UID, RULE_ALLOW_METERED, true, true));
    assertFalse(internal.isUidNetworkingBlocked(SYSTEM_UID, RULE_TEMPORARY_ALLOW_METERED, false, false));
    assertFalse(internal.isUidNetworkingBlocked(SYSTEM_UID, RULE_TEMPORARY_ALLOW_METERED, false, true));
    assertFalse(internal.isUidNetworkingBlocked(SYSTEM_UID, RULE_TEMPORARY_ALLOW_METERED, true, false));
    assertFalse(internal.isUidNetworkingBlocked(SYSTEM_UID, RULE_TEMPORARY_ALLOW_METERED, true, true));
    assertFalse(internal.isUidNetworkingBlocked(SYSTEM_UID, RULE_REJECT_METERED, false, false));
    assertFalse(internal.isUidNetworkingBlocked(SYSTEM_UID, RULE_REJECT_METERED, false, true));
    assertFalse(internal.isUidNetworkingBlocked(SYSTEM_UID, RULE_REJECT_METERED, true, false));
    assertFalse(internal.isUidNetworkingBlocked(SYSTEM_UID, RULE_REJECT_METERED, true, true));
    assertFalse(internal.isUidNetworkingBlocked(SYSTEM_UID, RULE_ALLOW_ALL, false, false));
    assertFalse(internal.isUidNetworkingBlocked(SYSTEM_UID, RULE_ALLOW_ALL, false, true));
    assertFalse(internal.isUidNetworkingBlocked(SYSTEM_UID, RULE_ALLOW_ALL, true, false));
    assertFalse(internal.isUidNetworkingBlocked(SYSTEM_UID, RULE_ALLOW_ALL, true, true));
    assertFalse(internal.isUidNetworkingBlocked(SYSTEM_UID, RULE_REJECT_ALL, false, false));
    assertFalse(internal.isUidNetworkingBlocked(SYSTEM_UID, RULE_REJECT_ALL, false, true));
    assertFalse(internal.isUidNetworkingBlocked(SYSTEM_UID, RULE_REJECT_ALL, true, false));
    assertFalse(internal.isUidNetworkingBlocked(SYSTEM_UID, RULE_REJECT_ALL, true, true));
    assertFalse(internal.isUidNetworkingBlocked(UID_A, RULE_NONE, false, false));
    assertFalse(internal.isUidNetworkingBlocked(UID_A, RULE_NONE, false, true));
    assertFalse(internal.isUidNetworkingBlocked(UID_A, RULE_NONE, true, false));
    assertTrue(internal.isUidNetworkingBlocked(UID_A, RULE_NONE, true, true));
    assertFalse(internal.isUidNetworkingBlocked(UID_A, RULE_ALLOW_METERED, false, false));
    assertFalse(internal.isUidNetworkingBlocked(UID_A, RULE_ALLOW_METERED, false, true));
    assertFalse(internal.isUidNetworkingBlocked(UID_A, RULE_ALLOW_METERED, true, false));
    assertFalse(internal.isUidNetworkingBlocked(UID_A, RULE_ALLOW_METERED, true, true));
    assertFalse(internal.isUidNetworkingBlocked(UID_A, RULE_TEMPORARY_ALLOW_METERED, false, false));
    assertFalse(internal.isUidNetworkingBlocked(UID_A, RULE_TEMPORARY_ALLOW_METERED, false, true));
    assertFalse(internal.isUidNetworkingBlocked(UID_A, RULE_TEMPORARY_ALLOW_METERED, true, false));
    assertFalse(internal.isUidNetworkingBlocked(UID_A, RULE_TEMPORARY_ALLOW_METERED, true, true));
    assertFalse(internal.isUidNetworkingBlocked(UID_A, RULE_REJECT_METERED, false, false));
    assertFalse(internal.isUidNetworkingBlocked(UID_A, RULE_REJECT_METERED, false, true));
    assertTrue(internal.isUidNetworkingBlocked(UID_A, RULE_REJECT_METERED, true, false));
    assertTrue(internal.isUidNetworkingBlocked(UID_A, RULE_REJECT_METERED, true, true));
    assertFalse(internal.isUidNetworkingBlocked(UID_A, RULE_ALLOW_ALL, false, false));
    assertFalse(internal.isUidNetworkingBlocked(UID_A, RULE_ALLOW_ALL, false, true));
    assertFalse(internal.isUidNetworkingBlocked(UID_A, RULE_ALLOW_ALL, true, false));
    assertTrue(internal.isUidNetworkingBlocked(UID_A, RULE_ALLOW_ALL, true, true));
    assertTrue(internal.isUidNetworkingBlocked(UID_A, RULE_REJECT_ALL, false, false));
    assertTrue(internal.isUidNetworkingBlocked(UID_A, RULE_REJECT_ALL, false, true));
    assertTrue(internal.isUidNetworkingBlocked(UID_A, RULE_REJECT_ALL, true, false));
    assertTrue(internal.isUidNetworkingBlocked(UID_A, RULE_REJECT_ALL, true, true));
}
#method_after
@Test
public void testIsUidNetworkingBlocked() {
    final ArrayList<Pair<Boolean, Integer>> expectedBlockedStates = new ArrayList<>();
    // Metered network. Data saver on.
    expectedBlockedStates.add(new Pair<>(true, RULE_NONE));
    expectedBlockedStates.add(new Pair<>(false, RULE_ALLOW_METERED));
    expectedBlockedStates.add(new Pair<>(false, RULE_TEMPORARY_ALLOW_METERED));
    expectedBlockedStates.add(new Pair<>(true, RULE_REJECT_METERED));
    expectedBlockedStates.add(new Pair<>(true, RULE_ALLOW_ALL));
    expectedBlockedStates.add(new Pair<>(true, RULE_REJECT_ALL));
    verifyNetworkBlockedState(true, /* metered */
    true, /* backgroundRestricted */
    expectedBlockedStates);
    expectedBlockedStates.clear();
    // Metered network. Data saver off.
    expectedBlockedStates.add(new Pair<>(false, RULE_NONE));
    expectedBlockedStates.add(new Pair<>(false, RULE_ALLOW_METERED));
    expectedBlockedStates.add(new Pair<>(false, RULE_TEMPORARY_ALLOW_METERED));
    expectedBlockedStates.add(new Pair<>(true, RULE_REJECT_METERED));
    expectedBlockedStates.add(new Pair<>(false, RULE_ALLOW_ALL));
    expectedBlockedStates.add(new Pair<>(true, RULE_REJECT_ALL));
    verifyNetworkBlockedState(true, /* metered */
    false, /* backgroundRestricted */
    expectedBlockedStates);
    expectedBlockedStates.clear();
    // Non-metered network. Data saver on.
    expectedBlockedStates.add(new Pair<>(false, RULE_NONE));
    expectedBlockedStates.add(new Pair<>(false, RULE_ALLOW_METERED));
    expectedBlockedStates.add(new Pair<>(false, RULE_TEMPORARY_ALLOW_METERED));
    expectedBlockedStates.add(new Pair<>(false, RULE_REJECT_METERED));
    expectedBlockedStates.add(new Pair<>(false, RULE_ALLOW_ALL));
    expectedBlockedStates.add(new Pair<>(true, RULE_REJECT_ALL));
    verifyNetworkBlockedState(false, /* metered */
    true, /* backgroundRestricted */
    expectedBlockedStates);
    // Non-metered network. Data saver off. The result is the same as previous case since
    // the network is blocked only for RULE_REJECT_ALL regardless of data saver.
    verifyNetworkBlockedState(false, /* metered */
    false, /* backgroundRestricted */
    expectedBlockedStates);
    expectedBlockedStates.clear();
}
#end_block

#method_before
@Test
public void testCallbackRelease() throws Exception {
    ConnectivityManager manager = new ConnectivityManager(mCtx, mService);
    NetworkRequest request = makeRequest(1);
    NetworkCallback callback = mock(ConnectivityManager.NetworkCallback.class);
    Handler handler = new Handler(Looper.getMainLooper());
    ArgumentCaptor<Messenger> captor = ArgumentCaptor.forClass(Messenger.class);
    // register callback
    when(mService.requestNetwork(any(), captor.capture(), anyInt(), any(), anyInt())).thenReturn(request);
    manager.requestNetwork(request, callback, handler);
    // callback triggers
    captor.getValue().send(makeMessage(request, ConnectivityManager.CALLBACK_AVAILABLE));
    verify(callback, timeout(500).times(1)).onAvailable(any(Network.class), any(NetworkCapabilities.class), any(LinkProperties.class), any(boolean.class));
    // unregister callback
    manager.unregisterNetworkCallback(callback);
    verify(mService, times(1)).releaseNetworkRequest(request);
    // callback does not trigger anymore.
    captor.getValue().send(makeMessage(request, ConnectivityManager.CALLBACK_LOSING));
    verify(callback, timeout(500).times(0)).onLosing(any(), anyInt());
}
#method_after
@Test
public void testCallbackRelease() throws Exception {
    ConnectivityManager manager = new ConnectivityManager(mCtx, mService);
    NetworkRequest request = makeRequest(1);
    NetworkCallback callback = mock(ConnectivityManager.NetworkCallback.class);
    Handler handler = new Handler(Looper.getMainLooper());
    ArgumentCaptor<Messenger> captor = ArgumentCaptor.forClass(Messenger.class);
    // register callback
    when(mService.requestNetwork(any(), captor.capture(), anyInt(), any(), anyInt())).thenReturn(request);
    manager.requestNetwork(request, callback, handler);
    // callback triggers
    captor.getValue().send(makeMessage(request, ConnectivityManager.CALLBACK_AVAILABLE));
    verify(callback, timeout(500).times(1)).onAvailable(any(Network.class), any(NetworkCapabilities.class), any(LinkProperties.class), anyBoolean());
    // unregister callback
    manager.unregisterNetworkCallback(callback);
    verify(mService, times(1)).releaseNetworkRequest(request);
    // callback does not trigger anymore.
    captor.getValue().send(makeMessage(request, ConnectivityManager.CALLBACK_LOSING));
    verify(callback, timeout(500).times(0)).onLosing(any(), anyInt());
}
#end_block

#method_before
@Test
public void testCallbackRecycling() throws Exception {
    ConnectivityManager manager = new ConnectivityManager(mCtx, mService);
    NetworkRequest req1 = makeRequest(1);
    NetworkRequest req2 = makeRequest(2);
    NetworkCallback callback = mock(ConnectivityManager.NetworkCallback.class);
    Handler handler = new Handler(Looper.getMainLooper());
    ArgumentCaptor<Messenger> captor = ArgumentCaptor.forClass(Messenger.class);
    // register callback
    when(mService.requestNetwork(any(), captor.capture(), anyInt(), any(), anyInt())).thenReturn(req1);
    manager.requestNetwork(req1, callback, handler);
    // callback triggers
    captor.getValue().send(makeMessage(req1, ConnectivityManager.CALLBACK_AVAILABLE));
    verify(callback, timeout(100).times(1)).onAvailable(any(Network.class), any(NetworkCapabilities.class), any(LinkProperties.class), any(boolean.class));
    // unregister callback
    manager.unregisterNetworkCallback(callback);
    verify(mService, times(1)).releaseNetworkRequest(req1);
    // callback does not trigger anymore.
    captor.getValue().send(makeMessage(req1, ConnectivityManager.CALLBACK_LOSING));
    verify(callback, timeout(100).times(0)).onLosing(any(), anyInt());
    // callback can be registered again
    when(mService.requestNetwork(any(), captor.capture(), anyInt(), any(), anyInt())).thenReturn(req2);
    manager.requestNetwork(req2, callback, handler);
    // callback triggers
    captor.getValue().send(makeMessage(req2, ConnectivityManager.CALLBACK_LOST));
    verify(callback, timeout(100).times(1)).onLost(any());
    // unregister callback
    manager.unregisterNetworkCallback(callback);
    verify(mService, times(1)).releaseNetworkRequest(req2);
}
#method_after
@Test
public void testCallbackRecycling() throws Exception {
    ConnectivityManager manager = new ConnectivityManager(mCtx, mService);
    NetworkRequest req1 = makeRequest(1);
    NetworkRequest req2 = makeRequest(2);
    NetworkCallback callback = mock(ConnectivityManager.NetworkCallback.class);
    Handler handler = new Handler(Looper.getMainLooper());
    ArgumentCaptor<Messenger> captor = ArgumentCaptor.forClass(Messenger.class);
    // register callback
    when(mService.requestNetwork(any(), captor.capture(), anyInt(), any(), anyInt())).thenReturn(req1);
    manager.requestNetwork(req1, callback, handler);
    // callback triggers
    captor.getValue().send(makeMessage(req1, ConnectivityManager.CALLBACK_AVAILABLE));
    verify(callback, timeout(100).times(1)).onAvailable(any(Network.class), any(NetworkCapabilities.class), any(LinkProperties.class), anyBoolean());
    // unregister callback
    manager.unregisterNetworkCallback(callback);
    verify(mService, times(1)).releaseNetworkRequest(req1);
    // callback does not trigger anymore.
    captor.getValue().send(makeMessage(req1, ConnectivityManager.CALLBACK_LOSING));
    verify(callback, timeout(100).times(0)).onLosing(any(), anyInt());
    // callback can be registered again
    when(mService.requestNetwork(any(), captor.capture(), anyInt(), any(), anyInt())).thenReturn(req2);
    manager.requestNetwork(req2, callback, handler);
    // callback triggers
    captor.getValue().send(makeMessage(req2, ConnectivityManager.CALLBACK_LOST));
    verify(callback, timeout(100).times(1)).onLost(any());
    // unregister callback
    manager.unregisterNetworkCallback(callback);
    verify(mService, times(1)).releaseNetworkRequest(req2);
}
#end_block

#method_before
private static void doInstallation(Context mainContext, File sourceApk, File dataDir, String secondaryFolderName, String prefsKeyPrefix, boolean reinstallOnPatchRecoverableException) throws IOException, IllegalArgumentException, IllegalAccessException, NoSuchFieldException, InvocationTargetException, NoSuchMethodException, SecurityException, ClassNotFoundException, InstantiationException {
    synchronized (installedApk) {
        if (installedApk.contains(sourceApk)) {
            return;
        }
        installedApk.add(sourceApk);
        if (Build.VERSION.SDK_INT > MAX_SUPPORTED_SDK_VERSION) {
            Log.w(TAG, "MultiDex is not guaranteed to work in SDK version " + Build.VERSION.SDK_INT + ": SDK version higher than " + MAX_SUPPORTED_SDK_VERSION + " should be backed by " + "runtime with built-in multidex capabilty but it's not the " + "case here: java.vm.version=\"" + System.getProperty("java.vm.version") + "\"");
        }
        /* The patched class loader is expected to be a descendant of
             * dalvik.system.BaseDexClassLoader. We modify its
             * dalvik.system.DexPathList pathList field to append additional DEX
             * file entries.
             */
        ClassLoader loader = getDexClassloader(mainContext);
        if (loader == null) {
            Log.e(TAG, "Context class loader is null. Must be running in test mode. " + "Skip patching.");
            return;
        }
        try {
            clearOldDexDir(mainContext);
        } catch (Throwable t) {
            Log.w(TAG, "Something went wrong when trying to clear old MultiDex extraction, " + "continuing without cleaning.", t);
        }
        File dexDir = getDexDir(mainContext, dataDir, secondaryFolderName);
        // MultiDexExtractor is taking the file lock and keeping it until it is closed.
        // Keep it open during installSecondaryDexes and through forced extraction to ensure no
        // extraction or optimizing dexopt is running in parallel.
        MultiDexExtractor extractor = new MultiDexExtractor(sourceApk, dexDir);
        IOException closeException = null;
        try {
            List<? extends File> files = extractor.load(mainContext, prefsKeyPrefix, false);
            try {
                installSecondaryDexes(loader, dexDir, files);
            // Some IOException causes may be fixed by a clean extraction.
            } catch (IOException e) {
                if (!reinstallOnPatchRecoverableException) {
                    throw e;
                }
                Log.w(TAG, "Failed to install extracted secondary dex files, retrying with " + "forced extraction", e);
                files = extractor.load(mainContext, prefsKeyPrefix, true);
                installSecondaryDexes(loader, dexDir, files);
            }
        } finally {
            try {
                extractor.close();
            } catch (IOException e) {
                // Delay throw of close exception to ensure we don't override some exception
                // thrown during the try block.
                closeException = e;
            }
        }
        if (closeException != null) {
            throw closeException;
        }
    }
}
#method_after
private static void doInstallation(Context mainContext, File sourceApk, File dataDir, String secondaryFolderName, String prefsKeyPrefix, boolean reinstallOnPatchRecoverableException) throws IOException, IllegalArgumentException, IllegalAccessException, NoSuchFieldException, InvocationTargetException, NoSuchMethodException, SecurityException, ClassNotFoundException, InstantiationException {
    synchronized (installedApk) {
        if (installedApk.contains(sourceApk)) {
            return;
        }
        installedApk.add(sourceApk);
        if (Build.VERSION.SDK_INT > MAX_SUPPORTED_SDK_VERSION) {
            Log.w(TAG, "MultiDex is not guaranteed to work in SDK version " + Build.VERSION.SDK_INT + ": SDK version higher than " + MAX_SUPPORTED_SDK_VERSION + " should be backed by " + "runtime with built-in multidex capabilty but it's not the " + "case here: java.vm.version=\"" + System.getProperty("java.vm.version") + "\"");
        }
        /* The patched class loader is expected to be a ClassLoader capable of loading DEX
             * bytecode. We modify its pathList field to append additional DEX file entries.
             */
        ClassLoader loader = getDexClassloader(mainContext);
        if (loader == null) {
            return;
        }
        try {
            clearOldDexDir(mainContext);
        } catch (Throwable t) {
            Log.w(TAG, "Something went wrong when trying to clear old MultiDex extraction, " + "continuing without cleaning.", t);
        }
        File dexDir = getDexDir(mainContext, dataDir, secondaryFolderName);
        // MultiDexExtractor is taking the file lock and keeping it until it is closed.
        // Keep it open during installSecondaryDexes and through forced extraction to ensure no
        // extraction or optimizing dexopt is running in parallel.
        MultiDexExtractor extractor = new MultiDexExtractor(sourceApk, dexDir);
        IOException closeException = null;
        try {
            List<? extends File> files = extractor.load(mainContext, prefsKeyPrefix, false);
            try {
                installSecondaryDexes(loader, dexDir, files);
            // Some IOException causes may be fixed by a clean extraction.
            } catch (IOException e) {
                if (!reinstallOnPatchRecoverableException) {
                    throw e;
                }
                Log.w(TAG, "Failed to install extracted secondary dex files, retrying with " + "forced extraction", e);
                files = extractor.load(mainContext, prefsKeyPrefix, true);
                installSecondaryDexes(loader, dexDir, files);
            }
        } finally {
            try {
                extractor.close();
            } catch (IOException e) {
                // Delay throw of close exception to ensure we don't override some exception
                // thrown during the try block.
                closeException = e;
            }
        }
        if (closeException != null) {
            throw closeException;
        }
    }
}
#end_block

#method_before
private static ClassLoader getDexClassloader(Context context) {
    ClassLoader loader;
    try {
        loader = context.getClassLoader();
    } catch (RuntimeException e) {
        /* Ignore those exceptions so that we don't break tests relying on Context like
             * a android.test.mock.MockContext or a android.content.ContextWrapper with a
             * null base Context.
             */
        Log.w(TAG, "Failure while trying to obtain Context class loader. " + "Must be running in test mode. Skip patching.", e);
        return null;
    }
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.ICE_CREAM_SANDWICH) {
        if (!loader.getClass().isAssignableFrom(BaseDexClassLoader.class)) {
            return null;
        }
    } else {
        if (!loader.getClass().isAssignableFrom(DexClassLoader.class) || !loader.getClass().isAssignableFrom(PathClassLoader.class)) {
            return null;
        }
    }
    return loader;
}
#method_after
private static ClassLoader getDexClassloader(Context context) {
    ClassLoader loader;
    try {
        loader = context.getClassLoader();
    } catch (RuntimeException e) {
        /* Ignore those exceptions so that we don't break tests relying on Context like
             * a android.test.mock.MockContext or a android.content.ContextWrapper with a
             * null base Context.
             */
        Log.w(TAG, "Failure while trying to obtain Context class loader. " + "Must be running in test mode. Skip patching.", e);
        return null;
    }
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.ICE_CREAM_SANDWICH) {
        if (loader instanceof dalvik.system.BaseDexClassLoader) {
            return loader;
        }
    } else if (loader instanceof dalvik.system.DexClassLoader || loader instanceof dalvik.system.PathClassLoader) {
        return loader;
    }
    Log.e(TAG, "Context class loader is null or not dex-capable. " + "Must be running in test mode. Skip patching.");
    return null;
}
#end_block

#method_before
private void initialize(Context context, AttributeSet attrs) {
    mRecyclerView = new RecyclerView(context);
    mRecyclerView.setId(ViewCompat.generateViewId());
    mLayoutManager = new LinearLayoutManager(context);
    mRecyclerView.setLayoutManager(mLayoutManager);
    setOrientation(context, attrs);
    mRecyclerView.setLayoutParams(new ViewGroup.LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT));
    mRecyclerView.addOnChildAttachStateChangeListener(enforceChildFillListener());
    new PagerSnapHelper().attachToRecyclerView(mRecyclerView);
    mScrollEventAdapter = new ScrollEventAdapter(mLayoutManager);
    mRecyclerView.addOnScrollListener(mScrollEventAdapter);
    CompositeOnPageChangeListener dispatcher = new CompositeOnPageChangeListener(3);
    mScrollEventAdapter.setOnPageChangeListener(dispatcher);
    // / Listener that updates mCurrentItem after swipes. Will of course also update it in all
    // other cases, but we already know about those updates (as we triggered those ourselves).
    final OnPageChangeListener currentItemUpdater = new OnPageChangeListener() {

        @Override
        public void onPageScrolled(int position, float positionOffset, int positionOffsetPx) {
        }

        @Override
        public void onPageSelected(int position) {
            mCurrentItem = position;
        }

        @Override
        public void onPageScrollStateChanged(int state) {
        }
    };
    // Add currentItemUpdater before mExternalPageChangeListeners, because we need to update
    // internal state first
    dispatcher.addOnPageChangeListener(currentItemUpdater);
    dispatcher.addOnPageChangeListener(mExternalPageChangeListeners);
    // Add mPageTransformerAdapter after mExternalPageChangeListeners, because page transform
    // events must be fired after scroll events
    mPageTransformerAdapter = new PageTransformerAdapter(mLayoutManager);
    dispatcher.addOnPageChangeListener(mPageTransformerAdapter);
    attachViewToParent(mRecyclerView, 0, mRecyclerView.getLayoutParams());
}
#method_after
private void initialize(Context context, AttributeSet attrs) {
    mRecyclerView = new RecyclerView(context);
    mRecyclerView.setId(ViewCompat.generateViewId());
    mLayoutManager = new LinearLayoutManager(context);
    mRecyclerView.setLayoutManager(mLayoutManager);
    setOrientation(context, attrs);
    mRecyclerView.setLayoutParams(new ViewGroup.LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT));
    mRecyclerView.addOnChildAttachStateChangeListener(enforceChildFillListener());
    new PagerSnapHelper().attachToRecyclerView(mRecyclerView);
    mScrollEventAdapter = new ScrollEventAdapter(mLayoutManager);
    mRecyclerView.addOnScrollListener(mScrollEventAdapter);
    CompositeOnPageChangeListener dispatcher = new CompositeOnPageChangeListener(3);
    mScrollEventAdapter.setOnPageChangeListener(dispatcher);
    // Listener that updates mCurrentItem after swipes. Also triggered in other cases, but in
    // all those cases mCurrentItem will only be overwritten with the same value.
    final OnPageChangeListener currentItemUpdater = new OnPageChangeListener() {

        @Override
        public void onPageScrolled(int position, float positionOffset, int positionOffsetPx) {
        }

        @Override
        public void onPageSelected(int position) {
            mCurrentItem = position;
        }

        @Override
        public void onPageScrollStateChanged(int state) {
        }
    };
    // Add currentItemUpdater before mExternalPageChangeListeners, because we need to update
    // internal state first
    dispatcher.addOnPageChangeListener(currentItemUpdater);
    dispatcher.addOnPageChangeListener(mExternalPageChangeListeners);
    // Add mPageTransformerAdapter after mExternalPageChangeListeners, because page transform
    // events must be fired after scroll events
    mPageTransformerAdapter = new PageTransformerAdapter(mLayoutManager);
    dispatcher.addOnPageChangeListener(mPageTransformerAdapter);
    attachViewToParent(mRecyclerView, 0, mRecyclerView.getLayoutParams());
}
#end_block

#method_before
public void setCurrentItem(int item, boolean smoothScroll) {
    float previousItem = mCurrentItem;
    if (previousItem == item) {
        if (mScrollEventAdapter.isIdle() || smoothScroll) {
            return;
        }
    // Scroll to target already in progress, interrupt scroll
    }
    mCurrentItem = item;
    if (!mScrollEventAdapter.isIdle()) {
        // Scroll in progress, overwrite previousItem with actual current position
        previousItem = mScrollEventAdapter.getRelativeScrollPosition();
    }
    mScrollEventAdapter.notifyProgrammaticScroll(item, smoothScroll);
    if (!smoothScroll) {
        mRecyclerView.scrollToPosition(item);
        return;
    }
    // For smooth scroll, pre-jump to nearby item for long jumps.
    if (Math.abs(item - previousItem) > 3) {
        mRecyclerView.scrollToPosition(item > previousItem ? item - 3 : item + 3);
        // TODO(b/114361680): call smoothScrollToPosition synchronously (blocked by b/114019007)
        mRecyclerView.post(new SmoothScrollToPosition(item));
    } else {
        mRecyclerView.smoothScrollToPosition(item);
    }
}
#method_after
public void setCurrentItem(int item, boolean smoothScroll) {
    if (item == mCurrentItem && mScrollEventAdapter.isIdle()) {
        // Already at the correct page
        return;
    }
    if (item == mCurrentItem && smoothScroll) {
        // because then we need to interrupt the current smooth scroll.
        return;
    }
    float previousItem = mCurrentItem;
    mCurrentItem = item;
    if (!mScrollEventAdapter.isIdle()) {
        // Scroll in progress, overwrite previousItem with actual current position
        previousItem = mScrollEventAdapter.getRelativeScrollPosition();
    }
    mScrollEventAdapter.notifyProgrammaticScroll(item, smoothScroll);
    if (!smoothScroll) {
        mRecyclerView.scrollToPosition(item);
        return;
    }
    // For smooth scroll, pre-jump to nearby item for long jumps.
    if (Math.abs(item - previousItem) > 3) {
        mRecyclerView.scrollToPosition(item > previousItem ? item - 3 : item + 3);
        // TODO(b/114361680): call smoothScrollToPosition synchronously (blocked by b/114019007)
        mRecyclerView.post(new SmoothScrollToPosition(item));
    } else {
        mRecyclerView.smoothScrollToPosition(item);
    }
}
#end_block

#method_before
private void resetState() {
    mAdapterState = AdapterState.IDLE;
    mScrollState = ViewPager2.ScrollState.IDLE;
    mScrollValues.reset();
    mInitialPosition = NO_TARGET;
    mTarget = NO_TARGET;
    mDispatchSelected = false;
    mScrollHappened = false;
}
#method_after
private void resetState() {
    mAdapterState = AdapterState.IDLE;
    mScrollState = ViewPager2.ScrollState.IDLE;
    mScrollValues.reset();
    mDragStartPosition = NO_POSITION;
    mTarget = NO_POSITION;
    mDispatchSelected = false;
    mScrollHappened = false;
}
#end_block

#method_before
@Override
public void onScrollStateChanged(@NonNull RecyclerView recyclerView, int newState) {
    if (mAdapterState != AdapterState.IN_PROGRESS_MANUAL_DRAG && newState == RecyclerView.SCROLL_STATE_DRAGGING) {
        mAdapterState = AdapterState.IN_PROGRESS_MANUAL_DRAG;
        if (mTarget != NO_TARGET) {
            // Special case when a smooth scroll was going on
            mInitialPosition = mTarget;
            mTarget = NO_TARGET;
        } else {
            mInitialPosition = getPosition();
        }
        dispatchStateChanged(ViewPager2.ScrollState.DRAGGING);
        return;
    }
    if (mAdapterState == AdapterState.IN_PROGRESS_MANUAL_DRAG && newState == RecyclerView.SCROLL_STATE_SETTLING) {
        if (!mScrollHappened) {
            // Special case of dragging before first (or beyond last) page
            dispatchScrolled(getPosition(), 0f, 0);
        } else {
            dispatchStateChanged(ViewPager2.ScrollState.SETTLING);
            mDispatchSelected = true;
            mScrollHappened = false;
        }
        return;
    }
    if (mAdapterState == AdapterState.IN_PROGRESS_MANUAL_DRAG && newState == RecyclerView.SCROLL_STATE_IDLE) {
        if (!mScrollHappened) {
            // Special case if we were snapped at a page when going from dragging to settling
            if (mDispatchSelected) {
                // Special case when the snapped page is different from the initial position
                // E.g.: programmatic scroll from 0 to 1, interrupt with drag from 0.5 to 0
                updateScrollEventValues();
                if (mInitialPosition != mScrollValues.mPosition) {
                    dispatchSelected(mScrollValues.mPosition);
                }
            }
            dispatchStateChanged(ViewPager2.ScrollState.IDLE);
            resetState();
        }
        return;
    }
}
#method_after
@Override
public void onScrollStateChanged(@NonNull RecyclerView recyclerView, int newState) {
    // User started a drag (not dragging -> dragging)
    if (mAdapterState != AdapterState.IN_PROGRESS_MANUAL_DRAG && newState == RecyclerView.SCROLL_STATE_DRAGGING) {
        // Remember we're performing a drag
        mAdapterState = AdapterState.IN_PROGRESS_MANUAL_DRAG;
        if (mTarget != NO_POSITION) {
            // Target was set means programmatic scroll was in progress
            // Update "drag start page" to reflect the page that ViewPager2 thinks it is at
            mDragStartPosition = mTarget;
            // Reset target because drags have no target until released
            mTarget = NO_POSITION;
        } else {
            // ViewPager2 was at rest, set "drag start page" to current page
            mDragStartPosition = getPosition();
        }
        dispatchStateChanged(ViewPager2.ScrollState.DRAGGING);
        return;
    }
    // Note that mAdapterState is not updated, to remember we were dragging when settling
    if (mAdapterState == AdapterState.IN_PROGRESS_MANUAL_DRAG && newState == RecyclerView.SCROLL_STATE_SETTLING) {
        if (!mScrollHappened) {
            // Pages didn't move during drag, so must be at the start or end of the list
            // ViewPager's contract requires at least one scroll event though
            dispatchScrolled(getPosition(), 0f, 0);
        } else {
            dispatchStateChanged(ViewPager2.ScrollState.SETTLING);
            // Determine target page and dispatch onPageSelected on next scroll event
            mDispatchSelected = true;
            // Reset value to recognise if onPageSelected has been fired when going to idle
            mScrollHappened = false;
        }
        return;
    }
    // Drag has settled (dragging && settling -> idle)
    if (mAdapterState == AdapterState.IN_PROGRESS_MANUAL_DRAG && newState == RecyclerView.SCROLL_STATE_IDLE) {
        if (!mScrollHappened) {
            // Happens if there was no velocity or if it was the first or last page
            if (mDispatchSelected) {
                // Fire onPageSelected when snapped page is different from initial position
                // E.g.: smooth scroll from 0 to 1, interrupt with drag at 0.5, release at 0
                updateScrollEventValues();
                if (mDragStartPosition != mScrollValues.mPosition) {
                    dispatchSelected(mScrollValues.mPosition);
                }
            }
            // Normally idle is fired in onScrolled, but scroll did not happen
            dispatchStateChanged(ViewPager2.ScrollState.IDLE);
            resetState();
        }
        return;
    }
}
#end_block

#method_before
@Override
public void onScrolled(@NonNull RecyclerView recyclerView, int dx, int dy) {
    mScrollHappened = true;
    ScrollEventValues values = updateScrollEventValues();
    if (mDispatchSelected) {
        mDispatchSelected = false;
        mTarget = (dx + dy > 0) ? values.mPosition + 1 : values.mPosition;
        if (mInitialPosition != mTarget) {
            dispatchSelected(mTarget);
        }
    }
    dispatchScrolled(values.mPosition, values.mOffset, values.mOffsetPx);
    if ((values.mPosition == mTarget || mTarget == NO_TARGET) && values.mOffsetPx == 0 && mScrollState != ViewPager2.ScrollState.DRAGGING) {
        dispatchStateChanged(ViewPager2.ScrollState.IDLE);
        resetState();
    }
}
#method_after
@Override
public void onScrolled(@NonNull RecyclerView recyclerView, int dx, int dy) {
    mScrollHappened = true;
    ScrollEventValues values = updateScrollEventValues();
    if (mDispatchSelected) {
        // Drag started settling, need to calculate target page and dispatch onPageSelected now
        mDispatchSelected = false;
        mTarget = (dx + dy > 0) ? values.mPosition + 1 : values.mPosition;
        if (mDragStartPosition != mTarget) {
            dispatchSelected(mTarget);
        }
    }
    dispatchScrolled(values.mPosition, values.mOffset, values.mOffsetPx);
    if ((values.mPosition == mTarget || mTarget == NO_POSITION) && values.mOffsetPx == 0 && mScrollState != ViewPager2.ScrollState.DRAGGING) {
        // When the target page is reached and the user is not dragging anymore, we're settled,
        // so go to idle.
        // Special case and a bit of a hack when there is no target: RecyclerView is being
        // initialized and fires a single scroll event. This flags mScrollHappened, so we need
        // to reset our state. However, we don't want to dispatch idle. But that won't happen;
        // because we were already idle.
        dispatchStateChanged(ViewPager2.ScrollState.IDLE);
        resetState();
    }
}
#end_block

#method_before
public void testStringUri() {
    assertEquals("bob lee", Uri.parse("foo:bob%20lee").getSchemeSpecificPart());
    assertEquals("bob%20lee", Uri.parse("foo:bob%20lee").getEncodedSchemeSpecificPart());
    assertEquals("/bob%20lee", Uri.parse("foo:/bob%20lee").getEncodedPath());
    assertNull(Uri.parse("foo:bob%20lee").getPath());
    assertEquals("bob%20lee", Uri.parse("foo:?bob%20lee").getEncodedQuery());
    assertNull(Uri.parse("foo:bob%20lee").getEncodedQuery());
    assertNull(Uri.parse("foo:bar#?bob%20lee").getQuery());
    assertEquals("bob%20lee", Uri.parse("foo:#bob%20lee").getEncodedFragment());
    Uri uri = Uri.parse("http://localhost:42");
    assertEquals("localhost", uri.getHost());
    assertEquals(42, uri.getPort());
    uri = Uri.parse("http://bob@localhost:42");
    assertEquals("bob", uri.getUserInfo());
    assertEquals("localhost", uri.getHost());
    assertEquals(42, uri.getPort());
    uri = Uri.parse("http://bob%20lee@localhost:42");
    assertEquals("bob lee", uri.getUserInfo());
    assertEquals("bob%20lee", uri.getEncodedUserInfo());
    uri = Uri.parse("http://localhost");
    assertEquals("localhost", uri.getHost());
    assertEquals(-1, uri.getPort());
    uri = Uri.parse("http://a:a@example.com:a@example2.com/path");
    assertEquals("a:a@example.com:a@example2.com", uri.getAuthority());
    assertEquals("example2.com", uri.getHost());
    assertEquals(-1, uri.getPort());
    assertEquals("/path", uri.getPath());
    uri = Uri.parse("http://a.foo.com\\.example.com/path");
    assertEquals("a.foo.com", uri.getHost());
    assertEquals(-1, uri.getPort());
    assertEquals("\\.example.com/path", uri.getPath());
    uri = Uri.parse("https://[2001:db8::dead:e1f]/foo");
    assertEquals("[2001:db8::dead:e1f]", uri.getAuthority());
    assertNull(uri.getUserInfo());
    assertEquals("[2001:db8::dead:e1f]", uri.getHost());
    assertEquals(-1, uri.getPort());
    assertEquals("/foo", uri.getPath());
    assertEquals(null, uri.getFragment());
    assertEquals("//[2001:db8::dead:e1f]/foo", uri.getSchemeSpecificPart());
    uri = Uri.parse("https://[2001:db8::dead:e1f]/#foo");
    assertEquals("[2001:db8::dead:e1f]", uri.getAuthority());
    assertNull(uri.getUserInfo());
    assertEquals("[2001:db8::dead:e1f]", uri.getHost());
    assertEquals(-1, uri.getPort());
    assertEquals("/", uri.getPath());
    assertEquals("foo", uri.getFragment());
    assertEquals("//[2001:db8::dead:e1f]/", uri.getSchemeSpecificPart());
    uri = Uri.parse("https://some:user@[2001:db8::dead:e1f]:1234/foo?corge=thud&corge=garp#bar");
    assertEquals("some:user@[2001:db8::dead:e1f]:1234", uri.getAuthority());
    assertEquals("some:user", uri.getUserInfo());
    assertEquals("[2001:db8::dead:e1f]", uri.getHost());
    assertEquals(1234, uri.getPort());
    assertEquals("/foo", uri.getPath());
    assertEquals("bar", uri.getFragment());
    assertEquals("//some:user@[2001:db8::dead:e1f]:1234/foo?corge=thud&corge=garp", uri.getSchemeSpecificPart());
    assertEquals("corge=thud&corge=garp", uri.getQuery());
    assertEquals("thud", uri.getQueryParameter("corge"));
    assertEquals(new ArrayList<String>(Arrays.asList("thud", "garp")), new ArrayList<String>(uri.getQueryParameters("corge")));
}
#method_after
public void testStringUri() {
    assertEquals("bob lee", Uri.parse("foo:bob%20lee").getSchemeSpecificPart());
    assertEquals("bob%20lee", Uri.parse("foo:bob%20lee").getEncodedSchemeSpecificPart());
    assertEquals("/bob%20lee", Uri.parse("foo:/bob%20lee").getEncodedPath());
    assertNull(Uri.parse("foo:bob%20lee").getPath());
    assertEquals("bob%20lee", Uri.parse("foo:?bob%20lee").getEncodedQuery());
    assertNull(Uri.parse("foo:bob%20lee").getEncodedQuery());
    assertNull(Uri.parse("foo:bar#?bob%20lee").getQuery());
    assertEquals("bob%20lee", Uri.parse("foo:#bob%20lee").getEncodedFragment());
    Uri uri = Uri.parse("http://localhost:42");
    assertEquals("localhost", uri.getHost());
    assertEquals(42, uri.getPort());
    uri = Uri.parse("http://bob@localhost:42");
    assertEquals("bob", uri.getUserInfo());
    assertEquals("localhost", uri.getHost());
    assertEquals(42, uri.getPort());
    uri = Uri.parse("http://bob%20lee@localhost:42");
    assertEquals("bob lee", uri.getUserInfo());
    assertEquals("bob%20lee", uri.getEncodedUserInfo());
    uri = Uri.parse("http://localhost");
    assertEquals("localhost", uri.getHost());
    assertEquals(-1, uri.getPort());
    uri = Uri.parse("http://a:a@example.com:a@example2.com/path");
    assertEquals("a:a@example.com:a@example2.com", uri.getAuthority());
    assertEquals("example2.com", uri.getHost());
    assertEquals(-1, uri.getPort());
    assertEquals("/path", uri.getPath());
    uri = Uri.parse("http://a.foo.com\\.example.com/path");
    assertEquals("a.foo.com", uri.getHost());
    assertEquals(-1, uri.getPort());
    assertEquals("\\.example.com/path", uri.getPath());
    uri = Uri.parse("https://[2001:db8::dead:e1f]/foo");
    assertEquals("[2001:db8::dead:e1f]", uri.getAuthority());
    assertNull(uri.getUserInfo());
    assertEquals("[2001:db8::dead:e1f]", uri.getHost());
    assertEquals(-1, uri.getPort());
    assertEquals("/foo", uri.getPath());
    assertEquals(null, uri.getFragment());
    assertEquals("//[2001:db8::dead:e1f]/foo", uri.getSchemeSpecificPart());
    uri = Uri.parse("https://[2001:db8::dead:e1f]/#foo");
    assertEquals("[2001:db8::dead:e1f]", uri.getAuthority());
    assertNull(uri.getUserInfo());
    assertEquals("[2001:db8::dead:e1f]", uri.getHost());
    assertEquals(-1, uri.getPort());
    assertEquals("/", uri.getPath());
    assertEquals("foo", uri.getFragment());
    assertEquals("//[2001:db8::dead:e1f]/", uri.getSchemeSpecificPart());
    uri = Uri.parse("https://some:user@[2001:db8::dead:e1f]:1234/foo?corge=thud&corge=garp#bar");
    assertEquals("some:user@[2001:db8::dead:e1f]:1234", uri.getAuthority());
    assertEquals("some:user", uri.getUserInfo());
    assertEquals("[2001:db8::dead:e1f]", uri.getHost());
    assertEquals(1234, uri.getPort());
    assertEquals("/foo", uri.getPath());
    assertEquals("bar", uri.getFragment());
    assertEquals("//some:user@[2001:db8::dead:e1f]:1234/foo?corge=thud&corge=garp", uri.getSchemeSpecificPart());
    assertEquals("corge=thud&corge=garp", uri.getQuery());
    assertEquals("thud", uri.getQueryParameter("corge"));
    assertEquals(Arrays.asList("thud", "garp"), uri.getQueryParameters("corge"));
}
#end_block

#method_before
public Key<ApiCoverageExcludedEntity> getKey() {
    return Key.create(ApiCoverageExcludedEntity.class, this.getOfyId());
}
#method_after
public Key<ApiCoverageExcludedEntity> getKey() {
    return Key.create(ApiCoverageExcludedEntity.class, this.getObjectifyId());
}
#end_block

#method_before
public Key<ApiCoverageExcludedEntity> save() {
    this.id = this.getOfyId();
    this.updated = new Date();
    return ofy().save().entity(this).now();
}
#method_after
public Key<ApiCoverageExcludedEntity> save() {
    this.id = this.getObjectifyId();
    this.updated = new Date();
    return ofy().save().entity(this).now();
}
#end_block

#method_before
public static void saveAll(List<ApiCoverageExcludedEntity> apiCoverageExcludedEntityList) {
    List<ApiCoverageExcludedEntity> entityWithIdList = apiCoverageExcludedEntityList.stream().map(entity -> {
        entity.id = entity.getOfyId();
        entity.updated = new Date();
        return entity;
    }).collect(Collectors.toList());
    // You can't insert the entity list which are more than 500 at one time.
    partitionBasedOnSize(entityWithIdList, 450).stream().forEach(entityList -> {
        ofy().save().entities(entityList).now();
    });
}
#method_after
public static void saveAll(List<ApiCoverageExcludedEntity> apiCoverageExcludedEntityList) {
    List<ApiCoverageExcludedEntity> entityWithIdList = apiCoverageExcludedEntityList.stream().map(entity -> {
        entity.setId(entity.getObjectifyId());
        entity.setUpdated(new Date());
        return entity;
    }).collect(Collectors.toList());
    partitionBasedOnSize(entityWithIdList, maxNumEntitySize).stream().forEach(entityList -> {
        ofy().save().entities(entityList).now();
    });
}
#end_block

#method_before
@Override
public void contextInitialized(ServletContextEvent servletContextEvent) {
    ObjectifyService.init();
    ObjectifyService.register(ApiCoverageEntity.class);
    ObjectifyService.register(ApiCoverageExcludedEntity.class);
    ObjectifyService.register(CodeCoverageEntity.class);
    ObjectifyService.register(CoverageEntity.class);
    ObjectifyService.register(DeviceInfoEntity.class);
    ObjectifyService.register(TestCoverageStatusEntity.class);
    ObjectifyService.register(ProfilingPointEntity.class);
    ObjectifyService.register(ProfilingPointRunEntity.class);
    ObjectifyService.register(ProfilingPointSummaryEntity.class);
    ObjectifyService.register(TestEntity.class);
    ObjectifyService.register(TestPlanEntity.class);
    ObjectifyService.register(TestPlanRunEntity.class);
    ObjectifyService.register(TestRunEntity.class);
    ObjectifyService.register(TestCaseRunEntity.class);
    ObjectifyService.register(TestStatusEntity.class);
    ObjectifyService.register(TestSuiteFileEntity.class);
    ObjectifyService.register(TestSuiteResultEntity.class);
    ObjectifyService.register(RoleEntity.class);
    ObjectifyService.register(UserEntity.class);
    ObjectifyService.begin();
    logger.log(Level.INFO, "Value Initialized from context.");
    Properties systemConfigProp = new Properties();
    try {
        InputStream defaultInputStream = ObjectifyListener.class.getClassLoader().getResourceAsStream("config.properties");
        systemConfigProp.load(defaultInputStream);
        String roleList = systemConfigProp.getProperty("user.roleList");
        Supplier<Stream<String>> streamSupplier = () -> Arrays.stream(roleList.split(","));
        this.createRoles(streamSupplier.get());
        String adminEmail = systemConfigProp.getProperty("user.adminEmail");
        if (adminEmail.isEmpty()) {
            logger.log(Level.WARNING, "Admin email is not properly set. Check config file");
        } else {
            String adminName = systemConfigProp.getProperty("user.adminName");
            String adminCompany = systemConfigProp.getProperty("user.adminCompany");
            Optional<String> roleName = streamSupplier.get().filter(r -> r.equals("admin")).findFirst();
            this.createAdminUser(adminEmail, adminName, adminCompany, roleName.orElse("admin"));
        }
    } catch (FileNotFoundException e) {
        e.printStackTrace();
    } catch (IOException e) {
        e.printStackTrace();
    }
}
#method_after
@Override
public void contextInitialized(ServletContextEvent servletContextEvent) {
    ObjectifyService.init();
    ObjectifyService.register(BranchEntity.class);
    ObjectifyService.register(BuildTargetEntity.class);
    ObjectifyService.register(ApiCoverageEntity.class);
    ObjectifyService.register(ApiCoverageExcludedEntity.class);
    ObjectifyService.register(CodeCoverageEntity.class);
    ObjectifyService.register(CoverageEntity.class);
    ObjectifyService.register(DeviceInfoEntity.class);
    ObjectifyService.register(TestCoverageStatusEntity.class);
    ObjectifyService.register(ProfilingPointEntity.class);
    ObjectifyService.register(ProfilingPointRunEntity.class);
    ObjectifyService.register(ProfilingPointSummaryEntity.class);
    ObjectifyService.register(TestEntity.class);
    ObjectifyService.register(TestPlanEntity.class);
    ObjectifyService.register(TestPlanRunEntity.class);
    ObjectifyService.register(TestRunEntity.class);
    ObjectifyService.register(TestCaseRunEntity.class);
    ObjectifyService.register(TestStatusEntity.class);
    ObjectifyService.register(TestSuiteFileEntity.class);
    ObjectifyService.register(TestSuiteResultEntity.class);
    ObjectifyService.register(RoleEntity.class);
    ObjectifyService.register(UserEntity.class);
    ObjectifyService.begin();
    logger.log(Level.INFO, "Value Initialized from context.");
    Properties systemConfigProp = new Properties();
    try {
        InputStream defaultInputStream = ObjectifyListener.class.getClassLoader().getResourceAsStream("config.properties");
        systemConfigProp.load(defaultInputStream);
        String roleList = systemConfigProp.getProperty("user.roleList");
        Supplier<Stream<String>> streamSupplier = () -> Arrays.stream(roleList.split(","));
        this.createRoles(streamSupplier.get());
        String adminEmail = systemConfigProp.getProperty("user.adminEmail");
        if (adminEmail.isEmpty()) {
            logger.log(Level.WARNING, "Admin email is not properly set. Check config file");
        } else {
            String adminName = systemConfigProp.getProperty("user.adminName");
            String adminCompany = systemConfigProp.getProperty("user.adminCompany");
            Optional<String> roleName = streamSupplier.get().filter(r -> r.equals("admin")).findFirst();
            this.createAdminUser(adminEmail, adminName, adminCompany, roleName.orElse("admin"));
        }
    } catch (FileNotFoundException e) {
        e.printStackTrace();
    } catch (IOException e) {
        e.printStackTrace();
    }
}
#end_block

#method_before
@Override
public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {
    try {
        // Build a new authorized API client service.
        final NetHttpTransport HTTP_TRANSPORT = GoogleNetHttpTransport.newTrustedTransport();
        Sheets service = new Sheets.Builder(HTTP_TRANSPORT, JSON_FACTORY, getCredentials(HTTP_TRANSPORT)).setApplicationName(APPLICATION_NAME).build();
        ValueRange valueRange = service.spreadsheets().values().get(SPREAD_SHEET_ID, SPREAD_SHEET_RANGE).execute();
        List<ApiCoverageExcludedEntity> apiCoverageExcludedEntities = new ArrayList<>();
        List<List<Object>> values = valueRange.getValues();
        if (values == null || values.isEmpty()) {
            logger.log(Level.WARNING, "No data found in google spreadsheet.");
        } else {
            for (List row : values) {
                ApiCoverageExcludedEntity apiCoverageExcludedEntity = new ApiCoverageExcludedEntity(row.get(0).toString(), Double.parseDouble(row.get(1).toString()), row.get(2).toString(), row.get(3).toString(), row.get(4).toString());
                apiCoverageExcludedEntities.add(apiCoverageExcludedEntity);
            }
        }
        ApiCoverageExcludedEntity.saveAll(apiCoverageExcludedEntities);
    } catch (GeneralSecurityException gse) {
        logger.log(Level.SEVERE, gse.getMessage());
    }
}
#method_after
@Override
public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {
    try {
        // Build a new authorized API client service.
        final NetHttpTransport HTTP_TRANSPORT = GoogleNetHttpTransport.newTrustedTransport();
        Sheets service = new Sheets.Builder(HTTP_TRANSPORT, JSON_FACTORY, getCredentials(HTTP_TRANSPORT)).setApplicationName(APPLICATION_NAME).build();
        ValueRange valueRange = service.spreadsheets().values().get(SPREAD_SHEET_ID, SPREAD_SHEET_RANGE).execute();
        List<ApiCoverageExcludedEntity> apiCoverageExcludedEntities = new ArrayList<>();
        List<List<Object>> values = valueRange.getValues();
        if (values == null || values.isEmpty()) {
            logger.log(Level.WARNING, "No data found in google spreadsheet.");
        } else {
            for (List row : values) {
                ApiCoverageExcludedEntity apiCoverageExcludedEntity = new ApiCoverageExcludedEntity(row.get(0).toString(), row.get(1).toString(), row.get(2).toString(), row.get(3).toString(), row.get(4).toString());
                apiCoverageExcludedEntities.add(apiCoverageExcludedEntity);
            }
        }
        ApiCoverageExcludedEntity.saveAll(apiCoverageExcludedEntities);
    } catch (GeneralSecurityException gse) {
        logger.log(Level.SEVERE, gse.getMessage());
    }
}
#end_block

#method_before
private RequestDispatcher getCoverageDispatcher(HttpServletRequest request, HttpServletResponse response) {
    String COVERAGE_OVERVIEW_JSP = "WEB-INF/jsp/show_coverage_overview.jsp";
    RequestDispatcher dispatcher = null;
    boolean unfiltered = request.getParameter("unfiltered") != null;
    boolean showPresubmit = request.getParameter("showPresubmit") != null;
    boolean showPostsubmit = request.getParameter("showPostsubmit") != null;
    // If no params are specified, set to default of postsubmit-only.
    if (!(showPresubmit || showPostsubmit)) {
        showPostsubmit = true;
    }
    // If unfiltered, set showPre- and Post-submit to true for accurate UI.
    if (unfiltered) {
        showPostsubmit = true;
        showPresubmit = true;
    }
    // Add test names to list
    List<String> resultNames = Arrays.stream(VtsReportMessage.TestCaseResult.values()).map(testCaseResult -> testCaseResult.name()).collect(Collectors.toList());
    Map<String, String[]> parameterMap = request.getParameterMap();
    List<TestCoverageStatusEntity> testCoverageStatusEntityList = TestCoverageStatusEntity.getAllTestCoverage();
    List<com.googlecode.objectify.Key<TestRunEntity>> testRunEntityKeyList = new ArrayList<>();
    if (Objects.nonNull(parameterMap.get("branch")) || Objects.nonNull(parameterMap.get("device"))) {
        List<com.googlecode.objectify.Key<DeviceInfoEntity>> deviceInfoEntityKeyList = this.getDeviceInfoEntityKeyList(testCoverageStatusEntityList);
        Collection<DeviceInfoEntity> deviceInfoEntityMap = ofy().load().keys(() -> deviceInfoEntityKeyList.iterator()).values();
        Stream<DeviceInfoEntity> deviceInfoEntityStream = Stream.empty();
        if (Objects.nonNull(parameterMap.get("branch")) && Objects.nonNull(parameterMap.get("device"))) {
            String branch = parameterMap.get("branch")[0];
            String device = parameterMap.get("device")[0];
            deviceInfoEntityStream = deviceInfoEntityMap.stream().filter(isBranchAndDevice(branch, device));
        } else if (Objects.nonNull(parameterMap.get("branch"))) {
            System.out.println("deviceInfoEntityMap -=> " + deviceInfoEntityMap.size());
            String branch = parameterMap.get("branch")[0];
            System.out.println("branch => " + branch);
            deviceInfoEntityStream = deviceInfoEntityMap.stream().filter(isBranch(branch));
        } else if (Objects.nonNull(parameterMap.get("device"))) {
            String device = parameterMap.get("device")[0];
            deviceInfoEntityStream = deviceInfoEntityMap.stream().filter(isDevice(device));
        } else {
            logger.log(Level.WARNING, "unmet search condition!");
        }
        testRunEntityKeyList = deviceInfoEntityStream.map(deviceInfoEntity -> {
            com.googlecode.objectify.Key testKey = com.googlecode.objectify.Key.create(TestEntity.class, deviceInfoEntity.getParent().getParent().getName());
            return com.googlecode.objectify.Key.create(testKey, TestRunEntity.class, deviceInfoEntity.getParent().getId());
        }).collect(Collectors.toList());
        logger.log(Level.INFO, "testRunEntityKeyList size => " + testRunEntityKeyList.size());
    } else {
        testRunEntityKeyList = this.getTestRunEntityKeyList(testCoverageStatusEntityList);
    }
    Iterator<Key<TestRunEntity>> testRunEntityKeyIterator = testRunEntityKeyList.iterator();
    Map<Key<TestRunEntity>, TestRunEntity> keyTestRunEntityMap = ofy().load().keys(() -> testRunEntityKeyIterator);
    List<com.googlecode.objectify.Key<CodeCoverageEntity>> codeCoverageEntityKeyList = new ArrayList<>();
    Map<Long, TestRunEntity> testRunEntityMap = new HashMap<>();
    for (Map.Entry<com.googlecode.objectify.Key<TestRunEntity>, TestRunEntity> entry : keyTestRunEntityMap.entrySet()) {
        com.googlecode.objectify.Key codeCoverageEntityKey = com.googlecode.objectify.Key.create(entry.getKey(), CodeCoverageEntity.class, entry.getValue().getId());
        codeCoverageEntityKeyList.add(codeCoverageEntityKey);
        testRunEntityMap.put(entry.getValue().getId(), entry.getValue());
    }
    Map<com.googlecode.objectify.Key<CodeCoverageEntity>, CodeCoverageEntity> keyCodeCoverageEntityMap = ofy().load().keys(() -> codeCoverageEntityKeyList.iterator());
    Map<Long, CodeCoverageEntity> codeCoverageEntityMap = new HashMap<>();
    for (Map.Entry<com.googlecode.objectify.Key<CodeCoverageEntity>, CodeCoverageEntity> entry : keyCodeCoverageEntityMap.entrySet()) {
        codeCoverageEntityMap.put(entry.getValue().getId(), entry.getValue());
    }
    int coveredLines = 0;
    int uncoveredLines = 0;
    int passCount = 0;
    int failCount = 0;
    for (Map.Entry<Long, CodeCoverageEntity> entry : codeCoverageEntityMap.entrySet()) {
        TestRunEntity testRunEntity = testRunEntityMap.get(entry.getKey());
        CodeCoverageEntity codeCoverageEntity = entry.getValue();
        coveredLines += codeCoverageEntity.getCoveredLineCount();
        uncoveredLines += codeCoverageEntity.getTotalLineCount() - codeCoverageEntity.getCoveredLineCount();
        passCount += testRunEntity.getPassCount();
        failCount += testRunEntity.getFailCount();
    }
    FilterUtil.setAttributes(request, parameterMap);
    int[] testStats = new int[VtsReportMessage.TestCaseResult.values().length];
    testStats[VtsReportMessage.TestCaseResult.TEST_CASE_RESULT_PASS.getNumber()] = passCount;
    testStats[VtsReportMessage.TestCaseResult.TEST_CASE_RESULT_FAIL.getNumber()] = failCount;
    response.setStatus(HttpServletResponse.SC_OK);
    request.setAttribute("resultNames", resultNames);
    request.setAttribute("resultNamesJson", new Gson().toJson(resultNames));
    request.setAttribute("testRunEntityList", testRunEntityMap.values());
    request.setAttribute("codeCoverageEntityMap", codeCoverageEntityMap);
    request.setAttribute("coveredLines", new Gson().toJson(coveredLines));
    request.setAttribute("uncoveredLines", new Gson().toJson(uncoveredLines));
    request.setAttribute("testStats", new Gson().toJson(testStats));
    request.setAttribute("unfiltered", unfiltered);
    request.setAttribute("showPresubmit", showPresubmit);
    request.setAttribute("showPostsubmit", showPostsubmit);
    request.setAttribute("branches", new Gson().toJson(DeviceInfoEntity.getAllBranches()));
    request.setAttribute("devices", new Gson().toJson(DeviceInfoEntity.getAllBuildFlavors()));
    dispatcher = request.getRequestDispatcher(COVERAGE_OVERVIEW_JSP);
    return dispatcher;
}
#method_after
private RequestDispatcher getCoverageDispatcher(HttpServletRequest request, HttpServletResponse response) {
    String COVERAGE_OVERVIEW_JSP = "WEB-INF/jsp/show_coverage_overview.jsp";
    RequestDispatcher dispatcher = null;
    boolean unfiltered = request.getParameter("unfiltered") != null;
    boolean showPresubmit = request.getParameter("showPresubmit") != null;
    boolean showPostsubmit = request.getParameter("showPostsubmit") != null;
    // If no params are specified, set to default of postsubmit-only.
    if (!(showPresubmit || showPostsubmit)) {
        showPostsubmit = true;
    }
    // If unfiltered, set showPre- and Post-submit to true for accurate UI.
    if (unfiltered) {
        showPostsubmit = true;
        showPresubmit = true;
    }
    // Add test names to list
    List<String> resultNames = Arrays.stream(VtsReportMessage.TestCaseResult.values()).map(testCaseResult -> testCaseResult.name()).collect(Collectors.toList());
    Map<String, String[]> parameterMap = request.getParameterMap();
    List<TestCoverageStatusEntity> testCoverageStatusEntityList = TestCoverageStatusEntity.getAllTestCoverage();
    List<com.googlecode.objectify.Key<TestRunEntity>> testRunEntityKeyList = new ArrayList<>();
    if (Objects.nonNull(parameterMap.get("branch")) || Objects.nonNull(parameterMap.get("device"))) {
        List<com.googlecode.objectify.Key<DeviceInfoEntity>> deviceInfoEntityKeyList = TestCoverageStatusEntity.getDeviceInfoEntityKeyList(testCoverageStatusEntityList);
        Collection<DeviceInfoEntity> deviceInfoEntityMap = ofy().load().keys(() -> deviceInfoEntityKeyList.iterator()).values();
        Stream<DeviceInfoEntity> deviceInfoEntityStream = Stream.empty();
        if (Objects.nonNull(parameterMap.get("branch")) && Objects.nonNull(parameterMap.get("device"))) {
            String branch = parameterMap.get("branch")[0];
            String device = parameterMap.get("device")[0];
            deviceInfoEntityStream = deviceInfoEntityMap.stream().filter(isBranchAndDevice(branch, device));
        } else if (Objects.nonNull(parameterMap.get("branch"))) {
            String branch = parameterMap.get("branch")[0];
            deviceInfoEntityStream = deviceInfoEntityMap.stream().filter(isBranch(branch));
        } else if (Objects.nonNull(parameterMap.get("device"))) {
            String device = parameterMap.get("device")[0];
            deviceInfoEntityStream = deviceInfoEntityMap.stream().filter(isDevice(device));
        } else {
            logger.log(Level.WARNING, "unmet search condition!");
        }
        testRunEntityKeyList = deviceInfoEntityStream.map(deviceInfoEntity -> {
            com.googlecode.objectify.Key testKey = com.googlecode.objectify.Key.create(TestEntity.class, deviceInfoEntity.getParent().getParent().getName());
            return com.googlecode.objectify.Key.create(testKey, TestRunEntity.class, deviceInfoEntity.getParent().getId());
        }).collect(Collectors.toList());
        logger.log(Level.INFO, "testRunEntityKeyList size => " + testRunEntityKeyList.size());
    } else {
        testRunEntityKeyList = this.getTestRunEntityKeyList(testCoverageStatusEntityList);
    }
    Iterator<Key<TestRunEntity>> testRunEntityKeyIterator = testRunEntityKeyList.iterator();
    Map<Key<TestRunEntity>, TestRunEntity> keyTestRunEntityMap = ofy().load().keys(() -> testRunEntityKeyIterator);
    List<com.googlecode.objectify.Key<CodeCoverageEntity>> codeCoverageEntityKeyList = new ArrayList<>();
    Map<Long, TestRunEntity> testRunEntityMap = new HashMap<>();
    for (Map.Entry<com.googlecode.objectify.Key<TestRunEntity>, TestRunEntity> entry : keyTestRunEntityMap.entrySet()) {
        com.googlecode.objectify.Key codeCoverageEntityKey = com.googlecode.objectify.Key.create(entry.getKey(), CodeCoverageEntity.class, entry.getValue().getId());
        codeCoverageEntityKeyList.add(codeCoverageEntityKey);
        testRunEntityMap.put(entry.getValue().getId(), entry.getValue());
    }
    Map<com.googlecode.objectify.Key<CodeCoverageEntity>, CodeCoverageEntity> keyCodeCoverageEntityMap = ofy().load().keys(() -> codeCoverageEntityKeyList.iterator());
    Map<Long, CodeCoverageEntity> codeCoverageEntityMap = new HashMap<>();
    for (Map.Entry<com.googlecode.objectify.Key<CodeCoverageEntity>, CodeCoverageEntity> entry : keyCodeCoverageEntityMap.entrySet()) {
        codeCoverageEntityMap.put(entry.getValue().getId(), entry.getValue());
    }
    int coveredLines = 0;
    int uncoveredLines = 0;
    int passCount = 0;
    int failCount = 0;
    for (Map.Entry<Long, CodeCoverageEntity> entry : codeCoverageEntityMap.entrySet()) {
        TestRunEntity testRunEntity = testRunEntityMap.get(entry.getKey());
        CodeCoverageEntity codeCoverageEntity = entry.getValue();
        coveredLines += codeCoverageEntity.getCoveredLineCount();
        uncoveredLines += codeCoverageEntity.getTotalLineCount() - codeCoverageEntity.getCoveredLineCount();
        passCount += testRunEntity.getPassCount();
        failCount += testRunEntity.getFailCount();
    }
    FilterUtil.setAttributes(request, parameterMap);
    int[] testStats = new int[VtsReportMessage.TestCaseResult.values().length];
    testStats[VtsReportMessage.TestCaseResult.TEST_CASE_RESULT_PASS.getNumber()] = passCount;
    testStats[VtsReportMessage.TestCaseResult.TEST_CASE_RESULT_FAIL.getNumber()] = failCount;
    response.setStatus(HttpServletResponse.SC_OK);
    request.setAttribute("resultNames", resultNames);
    request.setAttribute("resultNamesJson", new Gson().toJson(resultNames));
    request.setAttribute("testRunEntityList", testRunEntityMap.values());
    request.setAttribute("codeCoverageEntityMap", codeCoverageEntityMap);
    request.setAttribute("coveredLines", new Gson().toJson(coveredLines));
    request.setAttribute("uncoveredLines", new Gson().toJson(uncoveredLines));
    request.setAttribute("testStats", new Gson().toJson(testStats));
    request.setAttribute("unfiltered", unfiltered);
    request.setAttribute("showPresubmit", showPresubmit);
    request.setAttribute("showPostsubmit", showPostsubmit);
    request.setAttribute("deviceOptions", TestCoverageStatusEntity.getDeviceSet(testCoverageStatusEntityList));
    request.setAttribute("branchOptions", TestCoverageStatusEntity.getBranchSet(testCoverageStatusEntityList));
    dispatcher = request.getRequestDispatcher(COVERAGE_OVERVIEW_JSP);
    return dispatcher;
}
#end_block

#method_before
@Override
public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {
    String pathInfo = request.getPathInfo();
    String json = "";
    if (Objects.nonNull(pathInfo)) {
        if (pathInfo.equalsIgnoreCase("/branch")) {
            json = new Gson().toJson(DeviceInfoEntity.getAllBranches());
        } else if (pathInfo.equalsIgnoreCase("/device")) {
            json = new Gson().toJson(DeviceInfoEntity.getAllBuildFlavors());
        } else {
            json = "{error: 'true', message: 'unexpected path!!!'}";
            logger.log(Level.INFO, "Path Info => " + pathInfo);
            logger.log(Level.WARNING, "Unknown path access!");
        }
    } else {
        json = "{error: 'true', message: 'the path info is not existed!!!'}";
    }
    response.setStatus(HttpServletResponse.SC_OK);
    response.setContentType("application/json");
    response.setCharacterEncoding("UTF-8");
    response.getWriter().write(json);
}
#method_after
@Override
public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {
    String pathInfo = request.getPathInfo();
    String json = "";
    if (Objects.nonNull(pathInfo)) {
        String schKey = Objects.isNull(request.getParameter("schKey")) ? "" : request.getParameter("schKey");
        if (pathInfo.equalsIgnoreCase("/branch")) {
            json = new Gson().toJson(BranchEntity.getByBranch(schKey));
        } else if (pathInfo.equalsIgnoreCase("/device")) {
            json = new Gson().toJson(BuildTargetEntity.getByBuildTarget(schKey));
        } else if (pathInfo.startsWith("/code/coverage/status/")) {
            List<TestCoverageStatusEntity> testCoverageStatusEntityList = TestCoverageStatusEntity.getAllTestCoverage();
            if (pathInfo.endsWith("branch")) {
                json = new Gson().toJson(TestCoverageStatusEntity.getBranchSet(testCoverageStatusEntityList));
            } else {
                json = new Gson().toJson(TestCoverageStatusEntity.getDeviceSet(testCoverageStatusEntityList));
            }
        } else {
            json = "{error: 'true', message: 'unexpected path!!!'}";
            logger.log(Level.INFO, "Path Info => " + pathInfo);
            logger.log(Level.WARNING, "Unknown path access!");
        }
    } else {
        json = "{error: 'true', message: 'the path info is not existed!!!'}";
    }
    response.setStatus(HttpServletResponse.SC_OK);
    response.setContentType("application/json");
    response.setCharacterEncoding("UTF-8");
    response.getWriter().write(json);
}
#end_block

#method_before
/**
 * Determines if the specified character (Unicode code point) is a
 * lowercase character.
 * <p>
 * A character is lowercase if its general category type, provided
 * by {@link Character#getType getType(codePoint)}, is
 * {@code LOWERCASE_LETTER}, or it has contributory property
 * Other_Lowercase as defined by the Unicode Standard.
 * <p>
 * The following are examples of lowercase characters:
 * <blockquote><pre>
 * a b c d e f g h i j k l m n o p q r s t u v w x y z
 * '&#92;u00DF' '&#92;u00E0' '&#92;u00E1' '&#92;u00E2' '&#92;u00E3' '&#92;u00E4' '&#92;u00E5' '&#92;u00E6'
 * '&#92;u00E7' '&#92;u00E8' '&#92;u00E9' '&#92;u00EA' '&#92;u00EB' '&#92;u00EC' '&#92;u00ED' '&#92;u00EE'
 * '&#92;u00EF' '&#92;u00F0' '&#92;u00F1' '&#92;u00F2' '&#92;u00F3' '&#92;u00F4' '&#92;u00F5' '&#92;u00F6'
 * '&#92;u00F8' '&#92;u00F9' '&#92;u00FA' '&#92;u00FB' '&#92;u00FC' '&#92;u00FD' '&#92;u00FE' '&#92;u00FF'
 * </pre></blockquote>
 * <p> Many other Unicode characters are lowercase too.
 *
 * @param   codePoint the character (Unicode code point) to be tested.
 * @return  {@code true} if the character is lowercase;
 *          {@code false} otherwise.
 * @see     Character#isLowerCase(int)
 * @see     Character#isTitleCase(int)
 * @see     Character#toLowerCase(int)
 * @see     Character#getType(int)
 * @since   1.5
 */
// BEGIN Android-changed: Use ICU.
// Reimplement isLowerCase() natively.
public static boolean isLowerCase(int codePoint) {
    return isLowerCaseImpl(codePoint);
}
#method_after
/**
 * Determines if the specified character (Unicode code point) is a
 * lowercase character.
 * <p>
 * A character is lowercase if its general category type, provided
 * by {@link Character#getType getType(codePoint)}, is
 * {@code LOWERCASE_LETTER}, or it has contributory property
 * Other_Lowercase as defined by the Unicode Standard.
 * <p>
 * The following are examples of lowercase characters:
 * <blockquote><pre>
 * a b c d e f g h i j k l m n o p q r s t u v w x y z
 * '&#92;u00DF' '&#92;u00E0' '&#92;u00E1' '&#92;u00E2' '&#92;u00E3' '&#92;u00E4' '&#92;u00E5' '&#92;u00E6'
 * '&#92;u00E7' '&#92;u00E8' '&#92;u00E9' '&#92;u00EA' '&#92;u00EB' '&#92;u00EC' '&#92;u00ED' '&#92;u00EE'
 * '&#92;u00EF' '&#92;u00F0' '&#92;u00F1' '&#92;u00F2' '&#92;u00F3' '&#92;u00F4' '&#92;u00F5' '&#92;u00F6'
 * '&#92;u00F8' '&#92;u00F9' '&#92;u00FA' '&#92;u00FB' '&#92;u00FC' '&#92;u00FD' '&#92;u00FE' '&#92;u00FF'
 * </pre></blockquote>
 * <p> Many other Unicode characters are lowercase too.
 *
 * @param   codePoint the character (Unicode code point) to be tested.
 * @return  {@code true} if the character is lowercase;
 *          {@code false} otherwise.
 * @see     Character#isLowerCase(int)
 * @see     Character#isTitleCase(int)
 * @see     Character#toLowerCase(int)
 * @see     Character#getType(int)
 * @since   1.5
 */
// BEGIN Android-changed: Reimplement methods natively on top of ICU4C.
public static boolean isLowerCase(int codePoint) {
    return isLowerCaseImpl(codePoint);
}
#end_block

#method_before
// END Android-changed: Use ICU.
public static boolean isUpperCase(char ch) {
    return isUpperCase((int) ch);
}
#method_after
// END Android-changed: Reimplement methods natively on top of ICU4C.
public static boolean isUpperCase(char ch) {
    return isUpperCase((int) ch);
}
#end_block

#method_before
/**
 * Determines if the specified character (Unicode code point) is an uppercase character.
 * <p>
 * A character is uppercase if its general category type, provided by
 * {@link Character#getType(int) getType(codePoint)}, is {@code UPPERCASE_LETTER},
 * or it has contributory property Other_Uppercase as defined by the Unicode Standard.
 * <p>
 * The following are examples of uppercase characters:
 * <blockquote><pre>
 * A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
 * '&#92;u00C0' '&#92;u00C1' '&#92;u00C2' '&#92;u00C3' '&#92;u00C4' '&#92;u00C5' '&#92;u00C6' '&#92;u00C7'
 * '&#92;u00C8' '&#92;u00C9' '&#92;u00CA' '&#92;u00CB' '&#92;u00CC' '&#92;u00CD' '&#92;u00CE' '&#92;u00CF'
 * '&#92;u00D0' '&#92;u00D1' '&#92;u00D2' '&#92;u00D3' '&#92;u00D4' '&#92;u00D5' '&#92;u00D6' '&#92;u00D8'
 * '&#92;u00D9' '&#92;u00DA' '&#92;u00DB' '&#92;u00DC' '&#92;u00DD' '&#92;u00DE'
 * </pre></blockquote>
 * <p> Many other Unicode characters are uppercase too.<p>
 *
 * @param   codePoint the character (Unicode code point) to be tested.
 * @return  {@code true} if the character is uppercase;
 *          {@code false} otherwise.
 * @see     Character#isLowerCase(int)
 * @see     Character#isTitleCase(int)
 * @see     Character#toUpperCase(int)
 * @see     Character#getType(int)
 * @since   1.5
 */
// BEGIN Android-changed: Use ICU.
// Reimplement isUpperCase() natively.
public static boolean isUpperCase(int codePoint) {
    return isUpperCaseImpl(codePoint);
}
#method_after
/**
 * Determines if the specified character (Unicode code point) is an uppercase character.
 * <p>
 * A character is uppercase if its general category type, provided by
 * {@link Character#getType(int) getType(codePoint)}, is {@code UPPERCASE_LETTER},
 * or it has contributory property Other_Uppercase as defined by the Unicode Standard.
 * <p>
 * The following are examples of uppercase characters:
 * <blockquote><pre>
 * A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
 * '&#92;u00C0' '&#92;u00C1' '&#92;u00C2' '&#92;u00C3' '&#92;u00C4' '&#92;u00C5' '&#92;u00C6' '&#92;u00C7'
 * '&#92;u00C8' '&#92;u00C9' '&#92;u00CA' '&#92;u00CB' '&#92;u00CC' '&#92;u00CD' '&#92;u00CE' '&#92;u00CF'
 * '&#92;u00D0' '&#92;u00D1' '&#92;u00D2' '&#92;u00D3' '&#92;u00D4' '&#92;u00D5' '&#92;u00D6' '&#92;u00D8'
 * '&#92;u00D9' '&#92;u00DA' '&#92;u00DB' '&#92;u00DC' '&#92;u00DD' '&#92;u00DE'
 * </pre></blockquote>
 * <p> Many other Unicode characters are uppercase too.<p>
 *
 * @param   codePoint the character (Unicode code point) to be tested.
 * @return  {@code true} if the character is uppercase;
 *          {@code false} otherwise.
 * @see     Character#isLowerCase(int)
 * @see     Character#isTitleCase(int)
 * @see     Character#toUpperCase(int)
 * @see     Character#getType(int)
 * @since   1.5
 */
// BEGIN Android-changed: Reimplement methods natively on top of ICU4C.
public static boolean isUpperCase(int codePoint) {
    return isUpperCaseImpl(codePoint);
}
#end_block

#method_before
// END Android-changed: Use ICU.
public static boolean isTitleCase(char ch) {
    return isTitleCase((int) ch);
}
#method_after
// END Android-changed: Reimplement methods natively on top of ICU4C.
public static boolean isTitleCase(char ch) {
    return isTitleCase((int) ch);
}
#end_block

#method_before
/**
 * Determines if the specified character (Unicode code point) is a titlecase character.
 * <p>
 * A character is a titlecase character if its general
 * category type, provided by {@link Character#getType(int) getType(codePoint)},
 * is {@code TITLECASE_LETTER}.
 * <p>
 * Some characters look like pairs of Latin letters. For example, there
 * is an uppercase letter that looks like "LJ" and has a corresponding
 * lowercase letter that looks like "lj". A third form, which looks like "Lj",
 * is the appropriate form to use when rendering a word in lowercase
 * with initial capitals, as for a book title.
 * <p>
 * These are some of the Unicode characters for which this method returns
 * {@code true}:
 * <ul>
 * <li>{@code LATIN CAPITAL LETTER D WITH SMALL LETTER Z WITH CARON}
 * <li>{@code LATIN CAPITAL LETTER L WITH SMALL LETTER J}
 * <li>{@code LATIN CAPITAL LETTER N WITH SMALL LETTER J}
 * <li>{@code LATIN CAPITAL LETTER D WITH SMALL LETTER Z}
 * </ul>
 * <p> Many other Unicode characters are titlecase too.<p>
 *
 * @param   codePoint the character (Unicode code point) to be tested.
 * @return  {@code true} if the character is titlecase;
 *          {@code false} otherwise.
 * @see     Character#isLowerCase(int)
 * @see     Character#isUpperCase(int)
 * @see     Character#toTitleCase(int)
 * @see     Character#getType(int)
 * @since   1.5
 */
// BEGIN Android-changed: Use ICU.
// Reimplement isTitleCase() natively.
public static boolean isTitleCase(int codePoint) {
    return isTitleCaseImpl(codePoint);
}
#method_after
/**
 * Determines if the specified character (Unicode code point) is a titlecase character.
 * <p>
 * A character is a titlecase character if its general
 * category type, provided by {@link Character#getType(int) getType(codePoint)},
 * is {@code TITLECASE_LETTER}.
 * <p>
 * Some characters look like pairs of Latin letters. For example, there
 * is an uppercase letter that looks like "LJ" and has a corresponding
 * lowercase letter that looks like "lj". A third form, which looks like "Lj",
 * is the appropriate form to use when rendering a word in lowercase
 * with initial capitals, as for a book title.
 * <p>
 * These are some of the Unicode characters for which this method returns
 * {@code true}:
 * <ul>
 * <li>{@code LATIN CAPITAL LETTER D WITH SMALL LETTER Z WITH CARON}
 * <li>{@code LATIN CAPITAL LETTER L WITH SMALL LETTER J}
 * <li>{@code LATIN CAPITAL LETTER N WITH SMALL LETTER J}
 * <li>{@code LATIN CAPITAL LETTER D WITH SMALL LETTER Z}
 * </ul>
 * <p> Many other Unicode characters are titlecase too.<p>
 *
 * @param   codePoint the character (Unicode code point) to be tested.
 * @return  {@code true} if the character is titlecase;
 *          {@code false} otherwise.
 * @see     Character#isLowerCase(int)
 * @see     Character#isUpperCase(int)
 * @see     Character#toTitleCase(int)
 * @see     Character#getType(int)
 * @since   1.5
 */
// BEGIN Android-changed: Reimplement methods natively on top of ICU4C.
public static boolean isTitleCase(int codePoint) {
    return isTitleCaseImpl(codePoint);
}
#end_block

#method_before
// END Android-changed: Use ICU.
public static boolean isDigit(char ch) {
    return isDigit((int) ch);
}
#method_after
// END Android-changed: Reimplement methods natively on top of ICU4C.
public static boolean isDigit(char ch) {
    return isDigit((int) ch);
}
#end_block

#method_before
/**
 * Determines if the specified character (Unicode code point) is a digit.
 * <p>
 * A character is a digit if its general category type, provided
 * by {@link Character#getType(int) getType(codePoint)}, is
 * {@code DECIMAL_DIGIT_NUMBER}.
 * <p>
 * Some Unicode character ranges that contain digits:
 * <ul>
 * <li>{@code '\u005Cu0030'} through {@code '\u005Cu0039'},
 *     ISO-LATIN-1 digits ({@code '0'} through {@code '9'})
 * <li>{@code '\u005Cu0660'} through {@code '\u005Cu0669'},
 *     Arabic-Indic digits
 * <li>{@code '\u005Cu06F0'} through {@code '\u005Cu06F9'},
 *     Extended Arabic-Indic digits
 * <li>{@code '\u005Cu0966'} through {@code '\u005Cu096F'},
 *     Devanagari digits
 * <li>{@code '\u005CuFF10'} through {@code '\u005CuFF19'},
 *     Fullwidth digits
 * </ul>
 *
 * Many other character ranges contain digits as well.
 *
 * @param   codePoint the character (Unicode code point) to be tested.
 * @return  {@code true} if the character is a digit;
 *          {@code false} otherwise.
 * @see     Character#forDigit(int, int)
 * @see     Character#getType(int)
 * @since   1.5
 */
// BEGIN Android-changed: Use ICU.
// Reimplement isDigit() natively.
public static boolean isDigit(int codePoint) {
    return isDigitImpl(codePoint);
}
#method_after
/**
 * Determines if the specified character (Unicode code point) is a digit.
 * <p>
 * A character is a digit if its general category type, provided
 * by {@link Character#getType(int) getType(codePoint)}, is
 * {@code DECIMAL_DIGIT_NUMBER}.
 * <p>
 * Some Unicode character ranges that contain digits:
 * <ul>
 * <li>{@code '\u005Cu0030'} through {@code '\u005Cu0039'},
 *     ISO-LATIN-1 digits ({@code '0'} through {@code '9'})
 * <li>{@code '\u005Cu0660'} through {@code '\u005Cu0669'},
 *     Arabic-Indic digits
 * <li>{@code '\u005Cu06F0'} through {@code '\u005Cu06F9'},
 *     Extended Arabic-Indic digits
 * <li>{@code '\u005Cu0966'} through {@code '\u005Cu096F'},
 *     Devanagari digits
 * <li>{@code '\u005CuFF10'} through {@code '\u005CuFF19'},
 *     Fullwidth digits
 * </ul>
 *
 * Many other character ranges contain digits as well.
 *
 * @param   codePoint the character (Unicode code point) to be tested.
 * @return  {@code true} if the character is a digit;
 *          {@code false} otherwise.
 * @see     Character#forDigit(int, int)
 * @see     Character#getType(int)
 * @since   1.5
 */
// BEGIN Android-changed: Reimplement methods natively on top of ICU4C.
public static boolean isDigit(int codePoint) {
    return isDigitImpl(codePoint);
}
#end_block

#method_before
// END Android-changed: Use ICU.
public static boolean isDefined(char ch) {
    return isDefined((int) ch);
}
#method_after
// END Android-changed: Reimplement methods natively on top of ICU4C.
public static boolean isDefined(char ch) {
    return isDefined((int) ch);
}
#end_block

#method_before
/**
 * Determines if a character (Unicode code point) is defined in Unicode.
 * <p>
 * A character is defined if at least one of the following is true:
 * <ul>
 * <li>It has an entry in the UnicodeData file.
 * <li>It has a value in a range defined by the UnicodeData file.
 * </ul>
 *
 * @param   codePoint the character (Unicode code point) to be tested.
 * @return  {@code true} if the character has a defined meaning
 *          in Unicode; {@code false} otherwise.
 * @see     Character#isDigit(int)
 * @see     Character#isLetter(int)
 * @see     Character#isLetterOrDigit(int)
 * @see     Character#isLowerCase(int)
 * @see     Character#isTitleCase(int)
 * @see     Character#isUpperCase(int)
 * @since   1.5
 */
// BEGIN Android-changed: Use ICU.
// Reimplement isDefined() natively.
public static boolean isDefined(int codePoint) {
    return isDefinedImpl(codePoint);
}
#method_after
/**
 * Determines if a character (Unicode code point) is defined in Unicode.
 * <p>
 * A character is defined if at least one of the following is true:
 * <ul>
 * <li>It has an entry in the UnicodeData file.
 * <li>It has a value in a range defined by the UnicodeData file.
 * </ul>
 *
 * @param   codePoint the character (Unicode code point) to be tested.
 * @return  {@code true} if the character has a defined meaning
 *          in Unicode; {@code false} otherwise.
 * @see     Character#isDigit(int)
 * @see     Character#isLetter(int)
 * @see     Character#isLetterOrDigit(int)
 * @see     Character#isLowerCase(int)
 * @see     Character#isTitleCase(int)
 * @see     Character#isUpperCase(int)
 * @since   1.5
 */
// BEGIN Android-changed: Reimplement methods natively on top of ICU4C.
public static boolean isDefined(int codePoint) {
    return isDefinedImpl(codePoint);
}
#end_block

#method_before
// END Android-changed: Use ICU.
public static boolean isLetter(char ch) {
    return isLetter((int) ch);
}
#method_after
// END Android-changed: Reimplement methods natively on top of ICU4C.
public static boolean isLetter(char ch) {
    return isLetter((int) ch);
}
#end_block

#method_before
/**
 * Determines if the specified character (Unicode code point) is a letter.
 * <p>
 * A character is considered to be a letter if its general
 * category type, provided by {@link Character#getType(int) getType(codePoint)},
 * is any of the following:
 * <ul>
 * <li> {@code UPPERCASE_LETTER}
 * <li> {@code LOWERCASE_LETTER}
 * <li> {@code TITLECASE_LETTER}
 * <li> {@code MODIFIER_LETTER}
 * <li> {@code OTHER_LETTER}
 * </ul>
 *
 * Not all letters have case. Many characters are
 * letters but are neither uppercase nor lowercase nor titlecase.
 *
 * @param   codePoint the character (Unicode code point) to be tested.
 * @return  {@code true} if the character is a letter;
 *          {@code false} otherwise.
 * @see     Character#isDigit(int)
 * @see     Character#isJavaIdentifierStart(int)
 * @see     Character#isLetterOrDigit(int)
 * @see     Character#isLowerCase(int)
 * @see     Character#isTitleCase(int)
 * @see     Character#isUnicodeIdentifierStart(int)
 * @see     Character#isUpperCase(int)
 * @since   1.5
 */
// BEGIN Android-changed: Use ICU.
// Reimplement isLetter() natively.
public static boolean isLetter(int codePoint) {
    return isLetterImpl(codePoint);
}
#method_after
/**
 * Determines if the specified character (Unicode code point) is a letter.
 * <p>
 * A character is considered to be a letter if its general
 * category type, provided by {@link Character#getType(int) getType(codePoint)},
 * is any of the following:
 * <ul>
 * <li> {@code UPPERCASE_LETTER}
 * <li> {@code LOWERCASE_LETTER}
 * <li> {@code TITLECASE_LETTER}
 * <li> {@code MODIFIER_LETTER}
 * <li> {@code OTHER_LETTER}
 * </ul>
 *
 * Not all letters have case. Many characters are
 * letters but are neither uppercase nor lowercase nor titlecase.
 *
 * @param   codePoint the character (Unicode code point) to be tested.
 * @return  {@code true} if the character is a letter;
 *          {@code false} otherwise.
 * @see     Character#isDigit(int)
 * @see     Character#isJavaIdentifierStart(int)
 * @see     Character#isLetterOrDigit(int)
 * @see     Character#isLowerCase(int)
 * @see     Character#isTitleCase(int)
 * @see     Character#isUnicodeIdentifierStart(int)
 * @see     Character#isUpperCase(int)
 * @since   1.5
 */
// BEGIN Android-changed: Reimplement methods natively on top of ICU4C.
public static boolean isLetter(int codePoint) {
    return isLetterImpl(codePoint);
}
#end_block

#method_before
// END Android-changed: Use ICU.
public static boolean isLetterOrDigit(char ch) {
    return isLetterOrDigit((int) ch);
}
#method_after
// END Android-changed: Reimplement methods natively on top of ICU4C.
public static boolean isLetterOrDigit(char ch) {
    return isLetterOrDigit((int) ch);
}
#end_block

#method_before
/**
 * Determines if the specified character (Unicode code point) is a letter or digit.
 * <p>
 * A character is considered to be a letter or digit if either
 * {@link #isLetter(int) isLetter(codePoint)} or
 * {@link #isDigit(int) isDigit(codePoint)} returns
 * {@code true} for the character.
 *
 * @param   codePoint the character (Unicode code point) to be tested.
 * @return  {@code true} if the character is a letter or digit;
 *          {@code false} otherwise.
 * @see     Character#isDigit(int)
 * @see     Character#isJavaIdentifierPart(int)
 * @see     Character#isLetter(int)
 * @see     Character#isUnicodeIdentifierPart(int)
 * @since   1.5
 */
// BEGIN Android-changed: Use ICU.
// Reimplement isLetterOrDigit() natively.
public static boolean isLetterOrDigit(int codePoint) {
    return isLetterOrDigitImpl(codePoint);
}
#method_after
/**
 * Determines if the specified character (Unicode code point) is a letter or digit.
 * <p>
 * A character is considered to be a letter or digit if either
 * {@link #isLetter(int) isLetter(codePoint)} or
 * {@link #isDigit(int) isDigit(codePoint)} returns
 * {@code true} for the character.
 *
 * @param   codePoint the character (Unicode code point) to be tested.
 * @return  {@code true} if the character is a letter or digit;
 *          {@code false} otherwise.
 * @see     Character#isDigit(int)
 * @see     Character#isJavaIdentifierPart(int)
 * @see     Character#isLetter(int)
 * @see     Character#isUnicodeIdentifierPart(int)
 * @since   1.5
 */
// BEGIN Android-changed: Reimplement methods natively on top of ICU4C.
public static boolean isLetterOrDigit(int codePoint) {
    return isLetterOrDigitImpl(codePoint);
}
#end_block

#method_before
// END Android-changed: Use ICU.
@Deprecated
public static boolean isJavaLetter(char ch) {
    return isJavaIdentifierStart(ch);
}
#method_after
// END Android-changed: Reimplement methods natively on top of ICU4C.
@Deprecated
public static boolean isJavaLetter(char ch) {
    return isJavaIdentifierStart(ch);
}
#end_block

#method_before
/**
 * Determines if the specified character (Unicode code point) is an alphabet.
 * <p>
 * A character is considered to be alphabetic if its general category type,
 * provided by {@link Character#getType(int) getType(codePoint)}, is any of
 * the following:
 * <ul>
 * <li> <code>UPPERCASE_LETTER</code>
 * <li> <code>LOWERCASE_LETTER</code>
 * <li> <code>TITLECASE_LETTER</code>
 * <li> <code>MODIFIER_LETTER</code>
 * <li> <code>OTHER_LETTER</code>
 * <li> <code>LETTER_NUMBER</code>
 * </ul>
 * or it has contributory property Other_Alphabetic as defined by the
 * Unicode Standard.
 *
 * @param   codePoint the character (Unicode code point) to be tested.
 * @return  <code>true</code> if the character is a Unicode alphabet
 *          character, <code>false</code> otherwise.
 * @since   1.7
 */
// BEGIN Android-changed: Use ICU.
// Reimplement isAlphabetic() natively.
public static boolean isAlphabetic(int codePoint) {
    return isAlphabeticImpl(codePoint);
}
#method_after
/**
 * Determines if the specified character (Unicode code point) is an alphabet.
 * <p>
 * A character is considered to be alphabetic if its general category type,
 * provided by {@link Character#getType(int) getType(codePoint)}, is any of
 * the following:
 * <ul>
 * <li> <code>UPPERCASE_LETTER</code>
 * <li> <code>LOWERCASE_LETTER</code>
 * <li> <code>TITLECASE_LETTER</code>
 * <li> <code>MODIFIER_LETTER</code>
 * <li> <code>OTHER_LETTER</code>
 * <li> <code>LETTER_NUMBER</code>
 * </ul>
 * or it has contributory property Other_Alphabetic as defined by the
 * Unicode Standard.
 *
 * @param   codePoint the character (Unicode code point) to be tested.
 * @return  <code>true</code> if the character is a Unicode alphabet
 *          character, <code>false</code> otherwise.
 * @since   1.7
 */
// BEGIN Android-changed: Reimplement methods natively on top of ICU4C.
public static boolean isAlphabetic(int codePoint) {
    return isAlphabeticImpl(codePoint);
}
#end_block

#method_before
// Android-changed: Use ICU.
/**
 * Determines if the specified character (Unicode code point) is a CJKV
 * (Chinese, Japanese, Korean and Vietnamese) ideograph, as defined by
 * the Unicode Standard.
 *
 * @param   codePoint the character (Unicode code point) to be tested.
 * @return  <code>true</code> if the character is a Unicode ideograph
 *          character, <code>false</code> otherwise.
 * @since   1.7
 */
// Begin Android-changed: Use ICU,
// Reimplement isIdeographic natively.
public static boolean isIdeographic(int codePoint) {
    return isIdeographicImpl(codePoint);
}
#method_after
// END Android-changed: Reimplement methods natively on top of ICU4C.
/**
 * Determines if the specified character (Unicode code point) is a CJKV
 * (Chinese, Japanese, Korean and Vietnamese) ideograph, as defined by
 * the Unicode Standard.
 *
 * @param   codePoint the character (Unicode code point) to be tested.
 * @return  <code>true</code> if the character is a Unicode ideograph
 *          character, <code>false</code> otherwise.
 * @since   1.7
 */
// BEGIN Android-changed: Reimplement methods natively on top of ICU4C.
public static boolean isIdeographic(int codePoint) {
    return isIdeographicImpl(codePoint);
}
#end_block

#method_before
// END Android-changed: Use ICU.
// Android-changed: Removed @see tag (target does not exist on Android):
// @see     javax.lang.model.SourceVersion#isIdentifier(CharSequence)
public static boolean isJavaIdentifierStart(char ch) {
    return isJavaIdentifierStart((int) ch);
}
#method_after
// END Android-changed: Reimplement methods natively on top of ICU4C.
// Android-changed: Removed @see tag (target does not exist on Android):
// @see     javax.lang.model.SourceVersion#isIdentifier(CharSequence)
public static boolean isJavaIdentifierStart(char ch) {
    return isJavaIdentifierStart((int) ch);
}
#end_block

#method_before
/**
 * Determines if the specified character (Unicode code point) is permissible as the
 * first character in a Unicode identifier.
 * <p>
 * A character may start a Unicode identifier if and only if
 * one of the following conditions is true:
 * <ul>
 * <li> {@link #isLetter(int) isLetter(codePoint)}
 *      returns {@code true}
 * <li> {@link #getType(int) getType(codePoint)}
 *      returns {@code LETTER_NUMBER}.
 * </ul>
 * @param   codePoint the character (Unicode code point) to be tested.
 * @return  {@code true} if the character may start a Unicode
 *          identifier; {@code false} otherwise.
 * @see     Character#isJavaIdentifierStart(int)
 * @see     Character#isLetter(int)
 * @see     Character#isUnicodeIdentifierPart(int)
 * @since   1.5
 */
// BEGIN Android-changed: Use ICU.
// Reimplement isUnicodeIdentifierStart() natively.
public static boolean isUnicodeIdentifierStart(int codePoint) {
    return isUnicodeIdentifierStartImpl(codePoint);
}
#method_after
/**
 * Determines if the specified character (Unicode code point) is permissible as the
 * first character in a Unicode identifier.
 * <p>
 * A character may start a Unicode identifier if and only if
 * one of the following conditions is true:
 * <ul>
 * <li> {@link #isLetter(int) isLetter(codePoint)}
 *      returns {@code true}
 * <li> {@link #getType(int) getType(codePoint)}
 *      returns {@code LETTER_NUMBER}.
 * </ul>
 * @param   codePoint the character (Unicode code point) to be tested.
 * @return  {@code true} if the character may start a Unicode
 *          identifier; {@code false} otherwise.
 * @see     Character#isJavaIdentifierStart(int)
 * @see     Character#isLetter(int)
 * @see     Character#isUnicodeIdentifierPart(int)
 * @since   1.5
 */
// BEGIN Android-changed: Reimplement methods natively on top of ICU4C.
public static boolean isUnicodeIdentifierStart(int codePoint) {
    return isUnicodeIdentifierStartImpl(codePoint);
}
#end_block

#method_before
// END Android-changed: Use ICU.
public static boolean isUnicodeIdentifierPart(char ch) {
    return isUnicodeIdentifierPart((int) ch);
}
#method_after
// END Android-changed: Reimplement methods natively on top of ICU4C..
public static boolean isUnicodeIdentifierPart(char ch) {
    return isUnicodeIdentifierPart((int) ch);
}
#end_block

#method_before
/**
 * Determines if the specified character (Unicode code point) may be part of a Unicode
 * identifier as other than the first character.
 * <p>
 * A character may be part of a Unicode identifier if and only if
 * one of the following statements is true:
 * <ul>
 * <li>  it is a letter
 * <li>  it is a connecting punctuation character (such as {@code '_'})
 * <li>  it is a digit
 * <li>  it is a numeric letter (such as a Roman numeral character)
 * <li>  it is a combining mark
 * <li>  it is a non-spacing mark
 * <li> {@code isIdentifierIgnorable} returns
 * {@code true} for this character.
 * </ul>
 * @param   codePoint the character (Unicode code point) to be tested.
 * @return  {@code true} if the character may be part of a
 *          Unicode identifier; {@code false} otherwise.
 * @see     Character#isIdentifierIgnorable(int)
 * @see     Character#isJavaIdentifierPart(int)
 * @see     Character#isLetterOrDigit(int)
 * @see     Character#isUnicodeIdentifierStart(int)
 * @since   1.5
 */
// BEGIN Android-changed: Use ICU.
// Reimplement isUnicodeIdentifierPart() natively.
public static boolean isUnicodeIdentifierPart(int codePoint) {
    return isUnicodeIdentifierPartImpl(codePoint);
}
#method_after
/**
 * Determines if the specified character (Unicode code point) may be part of a Unicode
 * identifier as other than the first character.
 * <p>
 * A character may be part of a Unicode identifier if and only if
 * one of the following statements is true:
 * <ul>
 * <li>  it is a letter
 * <li>  it is a connecting punctuation character (such as {@code '_'})
 * <li>  it is a digit
 * <li>  it is a numeric letter (such as a Roman numeral character)
 * <li>  it is a combining mark
 * <li>  it is a non-spacing mark
 * <li> {@code isIdentifierIgnorable} returns
 * {@code true} for this character.
 * </ul>
 * @param   codePoint the character (Unicode code point) to be tested.
 * @return  {@code true} if the character may be part of a
 *          Unicode identifier; {@code false} otherwise.
 * @see     Character#isIdentifierIgnorable(int)
 * @see     Character#isJavaIdentifierPart(int)
 * @see     Character#isLetterOrDigit(int)
 * @see     Character#isUnicodeIdentifierStart(int)
 * @since   1.5
 */
// BEGIN Android-changed: Reimplement methods natively on top of ICU4C.
public static boolean isUnicodeIdentifierPart(int codePoint) {
    return isUnicodeIdentifierPartImpl(codePoint);
}
#end_block

#method_before
// END Android-changed: Use ICU.
public static boolean isIdentifierIgnorable(char ch) {
    return isIdentifierIgnorable((int) ch);
}
#method_after
// END Android-changed: Reimplement methods natively on top of ICU4C..
public static boolean isIdentifierIgnorable(char ch) {
    return isIdentifierIgnorable((int) ch);
}
#end_block

#method_before
/**
 * Determines if the specified character (Unicode code point) should be regarded as
 * an ignorable character in a Java identifier or a Unicode identifier.
 * <p>
 * The following Unicode characters are ignorable in a Java identifier
 * or a Unicode identifier:
 * <ul>
 * <li>ISO control characters that are not whitespace
 * <ul>
 * <li>{@code '\u005Cu0000'} through {@code '\u005Cu0008'}
 * <li>{@code '\u005Cu000E'} through {@code '\u005Cu001B'}
 * <li>{@code '\u005Cu007F'} through {@code '\u005Cu009F'}
 * </ul>
 *
 * <li>all characters that have the {@code FORMAT} general
 * category value
 * </ul>
 *
 * @param   codePoint the character (Unicode code point) to be tested.
 * @return  {@code true} if the character is an ignorable control
 *          character that may be part of a Java or Unicode identifier;
 *          {@code false} otherwise.
 * @see     Character#isJavaIdentifierPart(int)
 * @see     Character#isUnicodeIdentifierPart(int)
 * @since   1.5
 */
// Android-changed: Use ICU.
// Reimplement isIdentifierIgnorable() natively.
public static boolean isIdentifierIgnorable(int codePoint) {
    return isIdentifierIgnorableImpl(codePoint);
}
#method_after
/**
 * Determines if the specified character (Unicode code point) should be regarded as
 * an ignorable character in a Java identifier or a Unicode identifier.
 * <p>
 * The following Unicode characters are ignorable in a Java identifier
 * or a Unicode identifier:
 * <ul>
 * <li>ISO control characters that are not whitespace
 * <ul>
 * <li>{@code '\u005Cu0000'} through {@code '\u005Cu0008'}
 * <li>{@code '\u005Cu000E'} through {@code '\u005Cu001B'}
 * <li>{@code '\u005Cu007F'} through {@code '\u005Cu009F'}
 * </ul>
 *
 * <li>all characters that have the {@code FORMAT} general
 * category value
 * </ul>
 *
 * @param   codePoint the character (Unicode code point) to be tested.
 * @return  {@code true} if the character is an ignorable control
 *          character that may be part of a Java or Unicode identifier;
 *          {@code false} otherwise.
 * @see     Character#isJavaIdentifierPart(int)
 * @see     Character#isUnicodeIdentifierPart(int)
 * @since   1.5
 */
// BEGIN Android-changed: Reimplement methods natively on top of ICU4C.
public static boolean isIdentifierIgnorable(int codePoint) {
    return isIdentifierIgnorableImpl(codePoint);
}
#end_block

#method_before
// END Android-changed: Use ICU.
public static char toLowerCase(char ch) {
    return (char) toLowerCase((int) ch);
}
#method_after
// END Android-changed: Reimplement methods natively on top of ICU4C.
public static char toLowerCase(char ch) {
    return (char) toLowerCase((int) ch);
}
#end_block

#method_before
/**
 * Converts the character (Unicode code point) argument to
 * lowercase using case mapping information from the UnicodeData
 * file.
 *
 * <p> Note that
 * {@code Character.isLowerCase(Character.toLowerCase(codePoint))}
 * does not always return {@code true} for some ranges of
 * characters, particularly those that are symbols or ideographs.
 *
 * <p>In general, {@link String#toLowerCase()} should be used to map
 * characters to lowercase. {@code String} case mapping methods
 * have several benefits over {@code Character} case mapping methods.
 * {@code String} case mapping methods can perform locale-sensitive
 * mappings, context-sensitive mappings, and 1:M character mappings, whereas
 * the {@code Character} case mapping methods cannot.
 *
 * @param   codePoint   the character (Unicode code point) to be converted.
 * @return  the lowercase equivalent of the character (Unicode code
 *          point), if any; otherwise, the character itself.
 * @see     Character#isLowerCase(int)
 * @see     String#toLowerCase()
 *
 * @since   1.5
 */
// BEGIN Android-changed: Use ICU.
// Reimplement toLowerCase() natively with optimization.
public static int toLowerCase(int codePoint) {
    if (codePoint >= 'A' && codePoint <= 'Z') {
        return codePoint + ('a' - 'A');
    }
    // All ASCII codepoints except the ones above remain unchanged.
    if (codePoint < 0x80) {
        return codePoint;
    }
    return toLowerCaseImpl(codePoint);
}
#method_after
/**
 * Converts the character (Unicode code point) argument to
 * lowercase using case mapping information from the UnicodeData
 * file.
 *
 * <p> Note that
 * {@code Character.isLowerCase(Character.toLowerCase(codePoint))}
 * does not always return {@code true} for some ranges of
 * characters, particularly those that are symbols or ideographs.
 *
 * <p>In general, {@link String#toLowerCase()} should be used to map
 * characters to lowercase. {@code String} case mapping methods
 * have several benefits over {@code Character} case mapping methods.
 * {@code String} case mapping methods can perform locale-sensitive
 * mappings, context-sensitive mappings, and 1:M character mappings, whereas
 * the {@code Character} case mapping methods cannot.
 *
 * @param   codePoint   the character (Unicode code point) to be converted.
 * @return  the lowercase equivalent of the character (Unicode code
 *          point), if any; otherwise, the character itself.
 * @see     Character#isLowerCase(int)
 * @see     String#toLowerCase()
 *
 * @since   1.5
 */
// BEGIN Android-changed: Reimplement methods natively on top of ICU4C.
public static int toLowerCase(int codePoint) {
    if (codePoint >= 'A' && codePoint <= 'Z') {
        return codePoint + ('a' - 'A');
    }
    // All ASCII codepoints except the ones above remain unchanged.
    if (codePoint < 0x80) {
        return codePoint;
    }
    return toLowerCaseImpl(codePoint);
}
#end_block

#method_before
// END Android-changed: Use ICU.
public static char toUpperCase(char ch) {
    return (char) toUpperCase((int) ch);
}
#method_after
// END Android-changed: Reimplement methods natively on top of ICU4C.
public static char toUpperCase(char ch) {
    return (char) toUpperCase((int) ch);
}
#end_block

#method_before
/**
 * Converts the character (Unicode code point) argument to
 * uppercase using case mapping information from the UnicodeData
 * file.
 *
 * <p>Note that
 * {@code Character.isUpperCase(Character.toUpperCase(codePoint))}
 * does not always return {@code true} for some ranges of
 * characters, particularly those that are symbols or ideographs.
 *
 * <p>In general, {@link String#toUpperCase()} should be used to map
 * characters to uppercase. {@code String} case mapping methods
 * have several benefits over {@code Character} case mapping methods.
 * {@code String} case mapping methods can perform locale-sensitive
 * mappings, context-sensitive mappings, and 1:M character mappings, whereas
 * the {@code Character} case mapping methods cannot.
 *
 * @param   codePoint   the character (Unicode code point) to be converted.
 * @return  the uppercase equivalent of the character, if any;
 *          otherwise, the character itself.
 * @see     Character#isUpperCase(int)
 * @see     String#toUpperCase()
 *
 * @since   1.5
 */
// BEGIN Android-changed: Use ICU.
// Reimplement toUpperCase() natively with optimization.
public static int toUpperCase(int codePoint) {
    if (codePoint >= 'a' && codePoint <= 'z') {
        return codePoint - ('a' - 'A');
    }
    // All ASCII codepoints except the ones above remain unchanged.
    if (codePoint < 0x80) {
        return codePoint;
    }
    return toUpperCaseImpl(codePoint);
}
#method_after
/**
 * Converts the character (Unicode code point) argument to
 * uppercase using case mapping information from the UnicodeData
 * file.
 *
 * <p>Note that
 * {@code Character.isUpperCase(Character.toUpperCase(codePoint))}
 * does not always return {@code true} for some ranges of
 * characters, particularly those that are symbols or ideographs.
 *
 * <p>In general, {@link String#toUpperCase()} should be used to map
 * characters to uppercase. {@code String} case mapping methods
 * have several benefits over {@code Character} case mapping methods.
 * {@code String} case mapping methods can perform locale-sensitive
 * mappings, context-sensitive mappings, and 1:M character mappings, whereas
 * the {@code Character} case mapping methods cannot.
 *
 * @param   codePoint   the character (Unicode code point) to be converted.
 * @return  the uppercase equivalent of the character, if any;
 *          otherwise, the character itself.
 * @see     Character#isUpperCase(int)
 * @see     String#toUpperCase()
 *
 * @since   1.5
 */
// BEGIN Android-changed: Reimplement methods natively on top of ICU4C.
public static int toUpperCase(int codePoint) {
    if (codePoint >= 'a' && codePoint <= 'z') {
        return codePoint - ('a' - 'A');
    }
    // All ASCII codepoints except the ones above remain unchanged.
    if (codePoint < 0x80) {
        return codePoint;
    }
    return toUpperCaseImpl(codePoint);
}
#end_block

#method_before
// ENDAndroid-changed: Use ICU.
public static char toTitleCase(char ch) {
    return (char) toTitleCase((int) ch);
}
#method_after
// END Android-changed: Reimplement methods natively on top of ICU4C.
public static char toTitleCase(char ch) {
    return (char) toTitleCase((int) ch);
}
#end_block

#method_before
/**
 * Converts the character (Unicode code point) argument to titlecase using case mapping
 * information from the UnicodeData file. If a character has no
 * explicit titlecase mapping and is not itself a titlecase char
 * according to UnicodeData, then the uppercase mapping is
 * returned as an equivalent titlecase mapping. If the
 * character argument is already a titlecase
 * character, the same character value will be
 * returned.
 *
 * <p>Note that
 * {@code Character.isTitleCase(Character.toTitleCase(codePoint))}
 * does not always return {@code true} for some ranges of
 * characters.
 *
 * @param   codePoint   the character (Unicode code point) to be converted.
 * @return  the titlecase equivalent of the character, if any;
 *          otherwise, the character itself.
 * @see     Character#isTitleCase(int)
 * @see     Character#toLowerCase(int)
 * @see     Character#toUpperCase(int)
 * @since   1.5
 */
// BEGIN Android-changed: Use ICU.
// Reimplement toTitleCase() natively.
public static int toTitleCase(int codePoint) {
    return toTitleCaseImpl(codePoint);
}
#method_after
/**
 * Converts the character (Unicode code point) argument to titlecase using case mapping
 * information from the UnicodeData file. If a character has no
 * explicit titlecase mapping and is not itself a titlecase char
 * according to UnicodeData, then the uppercase mapping is
 * returned as an equivalent titlecase mapping. If the
 * character argument is already a titlecase
 * character, the same character value will be
 * returned.
 *
 * <p>Note that
 * {@code Character.isTitleCase(Character.toTitleCase(codePoint))}
 * does not always return {@code true} for some ranges of
 * characters.
 *
 * @param   codePoint   the character (Unicode code point) to be converted.
 * @return  the titlecase equivalent of the character, if any;
 *          otherwise, the character itself.
 * @see     Character#isTitleCase(int)
 * @see     Character#toLowerCase(int)
 * @see     Character#toUpperCase(int)
 * @since   1.5
 */
// BEGIN Android-changed: Reimplement methods natively on top of ICU4C.
public static int toTitleCase(int codePoint) {
    return toTitleCaseImpl(codePoint);
}
#end_block

#method_before
// END Android-changed: Use ICU.
public static int digit(char ch, int radix) {
    return digit((int) ch, radix);
}
#method_after
// END Android-changed: Reimplement methods natively on top of ICU4C.
public static int digit(char ch, int radix) {
    return digit((int) ch, radix);
}
#end_block

#method_before
/**
 * Returns the numeric value of the specified character (Unicode
 * code point) in the specified radix.
 *
 * <p>If the radix is not in the range {@code MIN_RADIX} &le;
 * {@code radix} &le; {@code MAX_RADIX} or if the
 * character is not a valid digit in the specified
 * radix, {@code -1} is returned. A character is a valid digit
 * if at least one of the following is true:
 * <ul>
 * <li>The method {@link #isDigit(int) isDigit(codePoint)} is {@code true} of the character
 *     and the Unicode decimal digit value of the character (or its
 *     single-character decomposition) is less than the specified radix.
 *     In this case the decimal digit value is returned.
 * <li>The character is one of the uppercase Latin letters
 *     {@code 'A'} through {@code 'Z'} and its code is less than
 *     {@code radix + 'A' - 10}.
 *     In this case, {@code codePoint - 'A' + 10}
 *     is returned.
 * <li>The character is one of the lowercase Latin letters
 *     {@code 'a'} through {@code 'z'} and its code is less than
 *     {@code radix + 'a' - 10}.
 *     In this case, {@code codePoint - 'a' + 10}
 *     is returned.
 * <li>The character is one of the fullwidth uppercase Latin letters A
 *     ({@code '\u005CuFF21'}) through Z ({@code '\u005CuFF3A'})
 *     and its code is less than
 *     {@code radix + '\u005CuFF21' - 10}.
 *     In this case,
 *     {@code codePoint - '\u005CuFF21' + 10}
 *     is returned.
 * <li>The character is one of the fullwidth lowercase Latin letters a
 *     ({@code '\u005CuFF41'}) through z ({@code '\u005CuFF5A'})
 *     and its code is less than
 *     {@code radix + '\u005CuFF41'- 10}.
 *     In this case,
 *     {@code codePoint - '\u005CuFF41' + 10}
 *     is returned.
 * </ul>
 *
 * @param   codePoint the character (Unicode code point) to be converted.
 * @param   radix   the radix.
 * @return  the numeric value represented by the character in the
 *          specified radix.
 * @see     Character#forDigit(int, int)
 * @see     Character#isDigit(int)
 * @since   1.5
 */
// BEGIN Android-changed: Use ICU.
// Reimplement digit() natively with optimization.
public static int digit(int codePoint, int radix) {
    if (radix < MIN_RADIX || radix > MAX_RADIX) {
        return -1;
    }
    if (codePoint < 128) {
        // Optimized for ASCII
        int result = -1;
        if ('0' <= codePoint && codePoint <= '9') {
            result = codePoint - '0';
        } else if ('a' <= codePoint && codePoint <= 'z') {
            result = 10 + (codePoint - 'a');
        } else if ('A' <= codePoint && codePoint <= 'Z') {
            result = 10 + (codePoint - 'A');
        }
        return result < radix ? result : -1;
    }
    return digitImpl(codePoint, radix);
}
#method_after
/**
 * Returns the numeric value of the specified character (Unicode
 * code point) in the specified radix.
 *
 * <p>If the radix is not in the range {@code MIN_RADIX} &le;
 * {@code radix} &le; {@code MAX_RADIX} or if the
 * character is not a valid digit in the specified
 * radix, {@code -1} is returned. A character is a valid digit
 * if at least one of the following is true:
 * <ul>
 * <li>The method {@link #isDigit(int) isDigit(codePoint)} is {@code true} of the character
 *     and the Unicode decimal digit value of the character (or its
 *     single-character decomposition) is less than the specified radix.
 *     In this case the decimal digit value is returned.
 * <li>The character is one of the uppercase Latin letters
 *     {@code 'A'} through {@code 'Z'} and its code is less than
 *     {@code radix + 'A' - 10}.
 *     In this case, {@code codePoint - 'A' + 10}
 *     is returned.
 * <li>The character is one of the lowercase Latin letters
 *     {@code 'a'} through {@code 'z'} and its code is less than
 *     {@code radix + 'a' - 10}.
 *     In this case, {@code codePoint - 'a' + 10}
 *     is returned.
 * <li>The character is one of the fullwidth uppercase Latin letters A
 *     ({@code '\u005CuFF21'}) through Z ({@code '\u005CuFF3A'})
 *     and its code is less than
 *     {@code radix + '\u005CuFF21' - 10}.
 *     In this case,
 *     {@code codePoint - '\u005CuFF21' + 10}
 *     is returned.
 * <li>The character is one of the fullwidth lowercase Latin letters a
 *     ({@code '\u005CuFF41'}) through z ({@code '\u005CuFF5A'})
 *     and its code is less than
 *     {@code radix + '\u005CuFF41'- 10}.
 *     In this case,
 *     {@code codePoint - '\u005CuFF41' + 10}
 *     is returned.
 * </ul>
 *
 * @param   codePoint the character (Unicode code point) to be converted.
 * @param   radix   the radix.
 * @return  the numeric value represented by the character in the
 *          specified radix.
 * @see     Character#forDigit(int, int)
 * @see     Character#isDigit(int)
 * @since   1.5
 */
// BEGIN Android-changed: Reimplement methods natively on top of ICU4C.
public static int digit(int codePoint, int radix) {
    if (radix < MIN_RADIX || radix > MAX_RADIX) {
        return -1;
    }
    if (codePoint < 128) {
        // Optimized for ASCII
        int result = -1;
        if ('0' <= codePoint && codePoint <= '9') {
            result = codePoint - '0';
        } else if ('a' <= codePoint && codePoint <= 'z') {
            result = 10 + (codePoint - 'a');
        } else if ('A' <= codePoint && codePoint <= 'Z') {
            result = 10 + (codePoint - 'A');
        }
        return result < radix ? result : -1;
    }
    return digitImpl(codePoint, radix);
}
#end_block

#method_before
// END Android-changed: Use ICU.
public static int getNumericValue(char ch) {
    return getNumericValue((int) ch);
}
#method_after
// END Android-changed: Reimplement methods natively on top of ICU4C.
public static int getNumericValue(char ch) {
    return getNumericValue((int) ch);
}
#end_block

#method_before
/**
 * Returns the {@code int} value that the specified
 * character (Unicode code point) represents. For example, the character
 * {@code '\u005Cu216C'} (the Roman numeral fifty) will return
 * an {@code int} with a value of 50.
 * <p>
 * The letters A-Z in their uppercase ({@code '\u005Cu0041'} through
 * {@code '\u005Cu005A'}), lowercase
 * ({@code '\u005Cu0061'} through {@code '\u005Cu007A'}), and
 * full width variant ({@code '\u005CuFF21'} through
 * {@code '\u005CuFF3A'} and {@code '\u005CuFF41'} through
 * {@code '\u005CuFF5A'}) forms have numeric values from 10
 * through 35. This is independent of the Unicode specification,
 * which does not assign numeric values to these {@code char}
 * values.
 * <p>
 * If the character does not have a numeric value, then -1 is returned.
 * If the character has a numeric value that cannot be represented as a
 * nonnegative integer (for example, a fractional value), then -2
 * is returned.
 *
 * @param   codePoint the character (Unicode code point) to be converted.
 * @return  the numeric value of the character, as a nonnegative {@code int}
 *          value; -2 if the character has a numeric value that is not a
 *          nonnegative integer; -1 if the character has no numeric value.
 * @see     Character#forDigit(int, int)
 * @see     Character#isDigit(int)
 * @since   1.5
 */
// BEGIN Android-changed: Use ICU.
// Reimplement getNumericValue() natively with optimization.
public static int getNumericValue(int codePoint) {
    // This is both an optimization and papers over differences between Java and ICU.
    if (codePoint < 128) {
        if (codePoint >= '0' && codePoint <= '9') {
            return codePoint - '0';
        }
        if (codePoint >= 'a' && codePoint <= 'z') {
            return codePoint - ('a' - 10);
        }
        if (codePoint >= 'A' && codePoint <= 'Z') {
            return codePoint - ('A' - 10);
        }
        return -1;
    }
    // Full-width uppercase A-Z.
    if (codePoint >= 0xff21 && codePoint <= 0xff3a) {
        return codePoint - 0xff17;
    }
    // Full-width lowercase a-z.
    if (codePoint >= 0xff41 && codePoint <= 0xff5a) {
        return codePoint - 0xff37;
    }
    return getNumericValueImpl(codePoint);
}
#method_after
/**
 * Returns the {@code int} value that the specified
 * character (Unicode code point) represents. For example, the character
 * {@code '\u005Cu216C'} (the Roman numeral fifty) will return
 * an {@code int} with a value of 50.
 * <p>
 * The letters A-Z in their uppercase ({@code '\u005Cu0041'} through
 * {@code '\u005Cu005A'}), lowercase
 * ({@code '\u005Cu0061'} through {@code '\u005Cu007A'}), and
 * full width variant ({@code '\u005CuFF21'} through
 * {@code '\u005CuFF3A'} and {@code '\u005CuFF41'} through
 * {@code '\u005CuFF5A'}) forms have numeric values from 10
 * through 35. This is independent of the Unicode specification,
 * which does not assign numeric values to these {@code char}
 * values.
 * <p>
 * If the character does not have a numeric value, then -1 is returned.
 * If the character has a numeric value that cannot be represented as a
 * nonnegative integer (for example, a fractional value), then -2
 * is returned.
 *
 * @param   codePoint the character (Unicode code point) to be converted.
 * @return  the numeric value of the character, as a nonnegative {@code int}
 *          value; -2 if the character has a numeric value that is not a
 *          nonnegative integer; -1 if the character has no numeric value.
 * @see     Character#forDigit(int, int)
 * @see     Character#isDigit(int)
 * @since   1.5
 */
// BEGIN Android-changed: Reimplement methods natively on top of ICU4C.
public static int getNumericValue(int codePoint) {
    // This is both an optimization and papers over differences between Java and ICU.
    if (codePoint < 128) {
        if (codePoint >= '0' && codePoint <= '9') {
            return codePoint - '0';
        }
        if (codePoint >= 'a' && codePoint <= 'z') {
            return codePoint - ('a' - 10);
        }
        if (codePoint >= 'A' && codePoint <= 'Z') {
            return codePoint - ('A' - 10);
        }
        return -1;
    }
    // Full-width uppercase A-Z.
    if (codePoint >= 0xff21 && codePoint <= 0xff3a) {
        return codePoint - 0xff17;
    }
    // Full-width lowercase a-z.
    if (codePoint >= 0xff41 && codePoint <= 0xff5a) {
        return codePoint - 0xff37;
    }
    return getNumericValueImpl(codePoint);
}
#end_block

#method_before
// END Android-changed: Use ICU.
@Deprecated
public static boolean isSpace(char ch) {
    return (ch <= 0x0020) && (((((1L << 0x0009) | (1L << 0x000A) | (1L << 0x000C) | (1L << 0x000D) | (1L << 0x0020)) >> ch) & 1L) != 0);
}
#method_after
// END Android-changed: Reimplement methods natively on top of ICU4C.
@Deprecated
public static boolean isSpace(char ch) {
    return (ch <= 0x0020) && (((((1L << 0x0009) | (1L << 0x000A) | (1L << 0x000C) | (1L << 0x000D) | (1L << 0x0020)) >> ch) & 1L) != 0);
}
#end_block

#method_before
/**
 * Determines if the specified character (Unicode code point) is a
 * Unicode space character.  A character is considered to be a
 * space character if and only if it is specified to be a space
 * character by the Unicode Standard. This method returns true if
 * the character's general category type is any of the following:
 *
 * <ul>
 * <li> {@link #SPACE_SEPARATOR}
 * <li> {@link #LINE_SEPARATOR}
 * <li> {@link #PARAGRAPH_SEPARATOR}
 * </ul>
 *
 * @param   codePoint the character (Unicode code point) to be tested.
 * @return  {@code true} if the character is a space character;
 *          {@code false} otherwise.
 * @see     Character#isWhitespace(int)
 * @since   1.5
 */
// BEGIN Android-changed: Use ICU.
// Reimplement isSpaceChar natively with optimization.
public static boolean isSpaceChar(int codePoint) {
    // SPACE or NO-BREAK SPACE?
    if (codePoint == 0x20 || codePoint == 0xa0) {
        return true;
    }
    if (codePoint < 0x1000) {
        return false;
    }
    // OGHAM SPACE MARK or MONGOLIAN VOWEL SEPARATOR?
    if (codePoint == 0x1680 || codePoint == 0x180e) {
        return true;
    }
    if (codePoint < 0x2000) {
        return false;
    }
    if (codePoint <= 0xffff) {
        // Other whitespace from General Punctuation...
        return codePoint <= 0x200a || codePoint == 0x2028 || codePoint == 0x2029 || codePoint == 0x202f || codePoint == 0x205f || // ...or CJK Symbols and Punctuation?
        codePoint == 0x3000;
    }
    // Let icu4c worry about non-BMP code points.
    return isSpaceCharImpl(codePoint);
}
#method_after
/**
 * Determines if the specified character (Unicode code point) is a
 * Unicode space character.  A character is considered to be a
 * space character if and only if it is specified to be a space
 * character by the Unicode Standard. This method returns true if
 * the character's general category type is any of the following:
 *
 * <ul>
 * <li> {@link #SPACE_SEPARATOR}
 * <li> {@link #LINE_SEPARATOR}
 * <li> {@link #PARAGRAPH_SEPARATOR}
 * </ul>
 *
 * @param   codePoint the character (Unicode code point) to be tested.
 * @return  {@code true} if the character is a space character;
 *          {@code false} otherwise.
 * @see     Character#isWhitespace(int)
 * @since   1.5
 */
// BEGIN Android-changed: Reimplement methods natively on top of ICU4C.
public static boolean isSpaceChar(int codePoint) {
    // SPACE or NO-BREAK SPACE?
    if (codePoint == 0x20 || codePoint == 0xa0) {
        return true;
    }
    if (codePoint < 0x1000) {
        return false;
    }
    // OGHAM SPACE MARK or MONGOLIAN VOWEL SEPARATOR?
    if (codePoint == 0x1680 || codePoint == 0x180e) {
        return true;
    }
    if (codePoint < 0x2000) {
        return false;
    }
    if (codePoint <= 0xffff) {
        // Other whitespace from General Punctuation...
        return codePoint <= 0x200a || codePoint == 0x2028 || codePoint == 0x2029 || codePoint == 0x202f || codePoint == 0x205f || // ...or CJK Symbols and Punctuation?
        codePoint == 0x3000;
    }
    // Let icu4c worry about non-BMP code points.
    return isSpaceCharImpl(codePoint);
}
#end_block

#method_before
// END Android-changed: Use ICU.
public static boolean isWhitespace(char ch) {
    return isWhitespace((int) ch);
}
#method_after
// END Android-changed: Reimplement methods natively on top of ICU4C.
public static boolean isWhitespace(char ch) {
    return isWhitespace((int) ch);
}
#end_block

#method_before
/**
 * Determines if the specified character (Unicode code point) is
 * white space according to Java.  A character is a Java
 * whitespace character if and only if it satisfies one of the
 * following criteria:
 * <ul>
 * <li> It is a Unicode space character ({@link #SPACE_SEPARATOR},
 *      {@link #LINE_SEPARATOR}, or {@link #PARAGRAPH_SEPARATOR})
 *      but is not also a non-breaking space ({@code '\u005Cu00A0'},
 *      {@code '\u005Cu2007'}, {@code '\u005Cu202F'}).
 * <li> It is {@code '\u005Ct'}, U+0009 HORIZONTAL TABULATION.
 * <li> It is {@code '\u005Cn'}, U+000A LINE FEED.
 * <li> It is {@code '\u005Cu000B'}, U+000B VERTICAL TABULATION.
 * <li> It is {@code '\u005Cf'}, U+000C FORM FEED.
 * <li> It is {@code '\u005Cr'}, U+000D CARRIAGE RETURN.
 * <li> It is {@code '\u005Cu001C'}, U+001C FILE SEPARATOR.
 * <li> It is {@code '\u005Cu001D'}, U+001D GROUP SEPARATOR.
 * <li> It is {@code '\u005Cu001E'}, U+001E RECORD SEPARATOR.
 * <li> It is {@code '\u005Cu001F'}, U+001F UNIT SEPARATOR.
 * </ul>
 * <p>
 *
 * @param   codePoint the character (Unicode code point) to be tested.
 * @return  {@code true} if the character is a Java whitespace
 *          character; {@code false} otherwise.
 * @see     Character#isSpaceChar(int)
 * @since   1.5
 */
// BEGIN Android-changed: Use ICU.
// Reimplement isWhitespace() natively with optmization.
public static boolean isWhitespace(int codePoint) {
    // Any ASCII whitespace character?
    if ((codePoint >= 0x1c && codePoint <= 0x20) || (codePoint >= 0x09 && codePoint <= 0x0d)) {
        return true;
    }
    if (codePoint < 0x1000) {
        return false;
    }
    // OGHAM SPACE MARK or MONGOLIAN VOWEL SEPARATOR?
    if (codePoint == 0x1680 || codePoint == 0x180e) {
        return true;
    }
    if (codePoint < 0x2000) {
        return false;
    }
    // Exclude General Punctuation's non-breaking spaces (which includes FIGURE SPACE).
    if (codePoint == 0x2007 || codePoint == 0x202f) {
        return false;
    }
    if (codePoint <= 0xffff) {
        // Other whitespace from General Punctuation...
        return codePoint <= 0x200a || codePoint == 0x2028 || codePoint == 0x2029 || codePoint == 0x205f || // ...or CJK Symbols and Punctuation?
        codePoint == 0x3000;
    }
    // Let icu4c worry about non-BMP code points.
    return isWhitespaceImpl(codePoint);
}
#method_after
/**
 * Determines if the specified character (Unicode code point) is
 * white space according to Java.  A character is a Java
 * whitespace character if and only if it satisfies one of the
 * following criteria:
 * <ul>
 * <li> It is a Unicode space character ({@link #SPACE_SEPARATOR},
 *      {@link #LINE_SEPARATOR}, or {@link #PARAGRAPH_SEPARATOR})
 *      but is not also a non-breaking space ({@code '\u005Cu00A0'},
 *      {@code '\u005Cu2007'}, {@code '\u005Cu202F'}).
 * <li> It is {@code '\u005Ct'}, U+0009 HORIZONTAL TABULATION.
 * <li> It is {@code '\u005Cn'}, U+000A LINE FEED.
 * <li> It is {@code '\u005Cu000B'}, U+000B VERTICAL TABULATION.
 * <li> It is {@code '\u005Cf'}, U+000C FORM FEED.
 * <li> It is {@code '\u005Cr'}, U+000D CARRIAGE RETURN.
 * <li> It is {@code '\u005Cu001C'}, U+001C FILE SEPARATOR.
 * <li> It is {@code '\u005Cu001D'}, U+001D GROUP SEPARATOR.
 * <li> It is {@code '\u005Cu001E'}, U+001E RECORD SEPARATOR.
 * <li> It is {@code '\u005Cu001F'}, U+001F UNIT SEPARATOR.
 * </ul>
 * <p>
 *
 * @param   codePoint the character (Unicode code point) to be tested.
 * @return  {@code true} if the character is a Java whitespace
 *          character; {@code false} otherwise.
 * @see     Character#isSpaceChar(int)
 * @since   1.5
 */
// BEGIN Android-changed: Reimplement methods natively on top of ICU4C.
public static boolean isWhitespace(int codePoint) {
    // Any ASCII whitespace character?
    if ((codePoint >= 0x1c && codePoint <= 0x20) || (codePoint >= 0x09 && codePoint <= 0x0d)) {
        return true;
    }
    if (codePoint < 0x1000) {
        return false;
    }
    // OGHAM SPACE MARK or MONGOLIAN VOWEL SEPARATOR?
    if (codePoint == 0x1680 || codePoint == 0x180e) {
        return true;
    }
    if (codePoint < 0x2000) {
        return false;
    }
    // Exclude General Punctuation's non-breaking spaces (which includes FIGURE SPACE).
    if (codePoint == 0x2007 || codePoint == 0x202f) {
        return false;
    }
    if (codePoint <= 0xffff) {
        // Other whitespace from General Punctuation...
        return codePoint <= 0x200a || codePoint == 0x2028 || codePoint == 0x2029 || codePoint == 0x205f || // ...or CJK Symbols and Punctuation?
        codePoint == 0x3000;
    }
    // Let icu4c worry about non-BMP code points.
    return isWhitespaceImpl(codePoint);
}
#end_block

#method_before
// END Android-changed: Use ICU.
public static boolean isISOControl(char ch) {
    return isISOControl((int) ch);
}
#method_after
// END Android-changed: Reimplement methods natively on top of ICU4C.
public static boolean isISOControl(char ch) {
    return isISOControl((int) ch);
}
#end_block

#method_before
/**
 * Returns a value indicating a character's general category.
 *
 * @param   codePoint the character (Unicode code point) to be tested.
 * @return  a value of type {@code int} representing the
 *          character's general category.
 * @see     Character#COMBINING_SPACING_MARK COMBINING_SPACING_MARK
 * @see     Character#CONNECTOR_PUNCTUATION CONNECTOR_PUNCTUATION
 * @see     Character#CONTROL CONTROL
 * @see     Character#CURRENCY_SYMBOL CURRENCY_SYMBOL
 * @see     Character#DASH_PUNCTUATION DASH_PUNCTUATION
 * @see     Character#DECIMAL_DIGIT_NUMBER DECIMAL_DIGIT_NUMBER
 * @see     Character#ENCLOSING_MARK ENCLOSING_MARK
 * @see     Character#END_PUNCTUATION END_PUNCTUATION
 * @see     Character#FINAL_QUOTE_PUNCTUATION FINAL_QUOTE_PUNCTUATION
 * @see     Character#FORMAT FORMAT
 * @see     Character#INITIAL_QUOTE_PUNCTUATION INITIAL_QUOTE_PUNCTUATION
 * @see     Character#LETTER_NUMBER LETTER_NUMBER
 * @see     Character#LINE_SEPARATOR LINE_SEPARATOR
 * @see     Character#LOWERCASE_LETTER LOWERCASE_LETTER
 * @see     Character#MATH_SYMBOL MATH_SYMBOL
 * @see     Character#MODIFIER_LETTER MODIFIER_LETTER
 * @see     Character#MODIFIER_SYMBOL MODIFIER_SYMBOL
 * @see     Character#NON_SPACING_MARK NON_SPACING_MARK
 * @see     Character#OTHER_LETTER OTHER_LETTER
 * @see     Character#OTHER_NUMBER OTHER_NUMBER
 * @see     Character#OTHER_PUNCTUATION OTHER_PUNCTUATION
 * @see     Character#OTHER_SYMBOL OTHER_SYMBOL
 * @see     Character#PARAGRAPH_SEPARATOR PARAGRAPH_SEPARATOR
 * @see     Character#PRIVATE_USE PRIVATE_USE
 * @see     Character#SPACE_SEPARATOR SPACE_SEPARATOR
 * @see     Character#START_PUNCTUATION START_PUNCTUATION
 * @see     Character#SURROGATE SURROGATE
 * @see     Character#TITLECASE_LETTER TITLECASE_LETTER
 * @see     Character#UNASSIGNED UNASSIGNED
 * @see     Character#UPPERCASE_LETTER UPPERCASE_LETTER
 * @since   1.5
 */
// BEGIN Android-changed: Use ICU.
// Reimplement getType() natively.
public static int getType(int codePoint) {
    int type = getTypeImpl(codePoint);
    // The type values returned by ICU are not RI-compatible. The RI skips the value 17.
    if (type <= Character.FORMAT) {
        return type;
    }
    return (type + 1);
}
#method_after
/**
 * Returns a value indicating a character's general category.
 *
 * @param   codePoint the character (Unicode code point) to be tested.
 * @return  a value of type {@code int} representing the
 *          character's general category.
 * @see     Character#COMBINING_SPACING_MARK COMBINING_SPACING_MARK
 * @see     Character#CONNECTOR_PUNCTUATION CONNECTOR_PUNCTUATION
 * @see     Character#CONTROL CONTROL
 * @see     Character#CURRENCY_SYMBOL CURRENCY_SYMBOL
 * @see     Character#DASH_PUNCTUATION DASH_PUNCTUATION
 * @see     Character#DECIMAL_DIGIT_NUMBER DECIMAL_DIGIT_NUMBER
 * @see     Character#ENCLOSING_MARK ENCLOSING_MARK
 * @see     Character#END_PUNCTUATION END_PUNCTUATION
 * @see     Character#FINAL_QUOTE_PUNCTUATION FINAL_QUOTE_PUNCTUATION
 * @see     Character#FORMAT FORMAT
 * @see     Character#INITIAL_QUOTE_PUNCTUATION INITIAL_QUOTE_PUNCTUATION
 * @see     Character#LETTER_NUMBER LETTER_NUMBER
 * @see     Character#LINE_SEPARATOR LINE_SEPARATOR
 * @see     Character#LOWERCASE_LETTER LOWERCASE_LETTER
 * @see     Character#MATH_SYMBOL MATH_SYMBOL
 * @see     Character#MODIFIER_LETTER MODIFIER_LETTER
 * @see     Character#MODIFIER_SYMBOL MODIFIER_SYMBOL
 * @see     Character#NON_SPACING_MARK NON_SPACING_MARK
 * @see     Character#OTHER_LETTER OTHER_LETTER
 * @see     Character#OTHER_NUMBER OTHER_NUMBER
 * @see     Character#OTHER_PUNCTUATION OTHER_PUNCTUATION
 * @see     Character#OTHER_SYMBOL OTHER_SYMBOL
 * @see     Character#PARAGRAPH_SEPARATOR PARAGRAPH_SEPARATOR
 * @see     Character#PRIVATE_USE PRIVATE_USE
 * @see     Character#SPACE_SEPARATOR SPACE_SEPARATOR
 * @see     Character#START_PUNCTUATION START_PUNCTUATION
 * @see     Character#SURROGATE SURROGATE
 * @see     Character#TITLECASE_LETTER TITLECASE_LETTER
 * @see     Character#UNASSIGNED UNASSIGNED
 * @see     Character#UPPERCASE_LETTER UPPERCASE_LETTER
 * @since   1.5
 */
// BEGIN Android-changed: Reimplement methods natively on top of ICU4C.
public static int getType(int codePoint) {
    int type = getTypeImpl(codePoint);
    // The type values returned by ICU are not RI-compatible. The RI skips the value 17.
    if (type <= Character.FORMAT) {
        return type;
    }
    return (type + 1);
}
#end_block

#method_before
// END Android-changed: Use ICU.
public static char forDigit(int digit, int radix) {
    if ((digit >= radix) || (digit < 0)) {
        return '\0';
    }
    if ((radix < Character.MIN_RADIX) || (radix > Character.MAX_RADIX)) {
        return '\0';
    }
    if (digit < 10) {
        return (char) ('0' + digit);
    }
    return (char) ('a' - 10 + digit);
}
#method_after
// END Android-changed: Reimplement methods natively on top of ICU4C.
public static char forDigit(int digit, int radix) {
    if ((digit >= radix) || (digit < 0)) {
        return '\0';
    }
    if ((radix < Character.MIN_RADIX) || (radix > Character.MAX_RADIX)) {
        return '\0';
    }
    if (digit < 10) {
        return (char) ('0' + digit);
    }
    return (char) ('a' - 10 + digit);
}
#end_block

#method_before
/**
 * Returns the Unicode directionality property for the given
 * character (Unicode code point).  Character directionality is
 * used to calculate the visual ordering of text. The
 * directionality value of undefined character is {@link
 * #DIRECTIONALITY_UNDEFINED}.
 *
 * @param   codePoint the character (Unicode code point) for which
 *          the directionality property is requested.
 * @return the directionality property of the character.
 *
 * @see Character#DIRECTIONALITY_UNDEFINED DIRECTIONALITY_UNDEFINED
 * @see Character#DIRECTIONALITY_LEFT_TO_RIGHT DIRECTIONALITY_LEFT_TO_RIGHT
 * @see Character#DIRECTIONALITY_RIGHT_TO_LEFT DIRECTIONALITY_RIGHT_TO_LEFT
 * @see Character#DIRECTIONALITY_RIGHT_TO_LEFT_ARABIC DIRECTIONALITY_RIGHT_TO_LEFT_ARABIC
 * @see Character#DIRECTIONALITY_EUROPEAN_NUMBER DIRECTIONALITY_EUROPEAN_NUMBER
 * @see Character#DIRECTIONALITY_EUROPEAN_NUMBER_SEPARATOR DIRECTIONALITY_EUROPEAN_NUMBER_SEPARATOR
 * @see Character#DIRECTIONALITY_EUROPEAN_NUMBER_TERMINATOR DIRECTIONALITY_EUROPEAN_NUMBER_TERMINATOR
 * @see Character#DIRECTIONALITY_ARABIC_NUMBER DIRECTIONALITY_ARABIC_NUMBER
 * @see Character#DIRECTIONALITY_COMMON_NUMBER_SEPARATOR DIRECTIONALITY_COMMON_NUMBER_SEPARATOR
 * @see Character#DIRECTIONALITY_NONSPACING_MARK DIRECTIONALITY_NONSPACING_MARK
 * @see Character#DIRECTIONALITY_BOUNDARY_NEUTRAL DIRECTIONALITY_BOUNDARY_NEUTRAL
 * @see Character#DIRECTIONALITY_PARAGRAPH_SEPARATOR DIRECTIONALITY_PARAGRAPH_SEPARATOR
 * @see Character#DIRECTIONALITY_SEGMENT_SEPARATOR DIRECTIONALITY_SEGMENT_SEPARATOR
 * @see Character#DIRECTIONALITY_WHITESPACE DIRECTIONALITY_WHITESPACE
 * @see Character#DIRECTIONALITY_OTHER_NEUTRALS DIRECTIONALITY_OTHER_NEUTRALS
 * @see Character#DIRECTIONALITY_LEFT_TO_RIGHT_EMBEDDING DIRECTIONALITY_LEFT_TO_RIGHT_EMBEDDING
 * @see Character#DIRECTIONALITY_LEFT_TO_RIGHT_OVERRIDE DIRECTIONALITY_LEFT_TO_RIGHT_OVERRIDE
 * @see Character#DIRECTIONALITY_RIGHT_TO_LEFT_EMBEDDING DIRECTIONALITY_RIGHT_TO_LEFT_EMBEDDING
 * @see Character#DIRECTIONALITY_RIGHT_TO_LEFT_OVERRIDE DIRECTIONALITY_RIGHT_TO_LEFT_OVERRIDE
 * @see Character#DIRECTIONALITY_POP_DIRECTIONAL_FORMAT DIRECTIONALITY_POP_DIRECTIONAL_FORMAT
 * @since    1.5
 */
// BEGIN Android-changed: Use ICU.
// reimplement getDirectionality() natively.
public static byte getDirectionality(int codePoint) {
    if (getType(codePoint) == Character.UNASSIGNED) {
        return Character.DIRECTIONALITY_UNDEFINED;
    }
    byte directionality = getDirectionalityImpl(codePoint);
    if (directionality >= 0 && directionality < DIRECTIONALITY.length) {
        return DIRECTIONALITY[directionality];
    }
    return Character.DIRECTIONALITY_UNDEFINED;
}
#method_after
/**
 * Returns the Unicode directionality property for the given
 * character (Unicode code point).  Character directionality is
 * used to calculate the visual ordering of text. The
 * directionality value of undefined character is {@link
 * #DIRECTIONALITY_UNDEFINED}.
 *
 * @param   codePoint the character (Unicode code point) for which
 *          the directionality property is requested.
 * @return the directionality property of the character.
 *
 * @see Character#DIRECTIONALITY_UNDEFINED DIRECTIONALITY_UNDEFINED
 * @see Character#DIRECTIONALITY_LEFT_TO_RIGHT DIRECTIONALITY_LEFT_TO_RIGHT
 * @see Character#DIRECTIONALITY_RIGHT_TO_LEFT DIRECTIONALITY_RIGHT_TO_LEFT
 * @see Character#DIRECTIONALITY_RIGHT_TO_LEFT_ARABIC DIRECTIONALITY_RIGHT_TO_LEFT_ARABIC
 * @see Character#DIRECTIONALITY_EUROPEAN_NUMBER DIRECTIONALITY_EUROPEAN_NUMBER
 * @see Character#DIRECTIONALITY_EUROPEAN_NUMBER_SEPARATOR DIRECTIONALITY_EUROPEAN_NUMBER_SEPARATOR
 * @see Character#DIRECTIONALITY_EUROPEAN_NUMBER_TERMINATOR DIRECTIONALITY_EUROPEAN_NUMBER_TERMINATOR
 * @see Character#DIRECTIONALITY_ARABIC_NUMBER DIRECTIONALITY_ARABIC_NUMBER
 * @see Character#DIRECTIONALITY_COMMON_NUMBER_SEPARATOR DIRECTIONALITY_COMMON_NUMBER_SEPARATOR
 * @see Character#DIRECTIONALITY_NONSPACING_MARK DIRECTIONALITY_NONSPACING_MARK
 * @see Character#DIRECTIONALITY_BOUNDARY_NEUTRAL DIRECTIONALITY_BOUNDARY_NEUTRAL
 * @see Character#DIRECTIONALITY_PARAGRAPH_SEPARATOR DIRECTIONALITY_PARAGRAPH_SEPARATOR
 * @see Character#DIRECTIONALITY_SEGMENT_SEPARATOR DIRECTIONALITY_SEGMENT_SEPARATOR
 * @see Character#DIRECTIONALITY_WHITESPACE DIRECTIONALITY_WHITESPACE
 * @see Character#DIRECTIONALITY_OTHER_NEUTRALS DIRECTIONALITY_OTHER_NEUTRALS
 * @see Character#DIRECTIONALITY_LEFT_TO_RIGHT_EMBEDDING DIRECTIONALITY_LEFT_TO_RIGHT_EMBEDDING
 * @see Character#DIRECTIONALITY_LEFT_TO_RIGHT_OVERRIDE DIRECTIONALITY_LEFT_TO_RIGHT_OVERRIDE
 * @see Character#DIRECTIONALITY_RIGHT_TO_LEFT_EMBEDDING DIRECTIONALITY_RIGHT_TO_LEFT_EMBEDDING
 * @see Character#DIRECTIONALITY_RIGHT_TO_LEFT_OVERRIDE DIRECTIONALITY_RIGHT_TO_LEFT_OVERRIDE
 * @see Character#DIRECTIONALITY_POP_DIRECTIONAL_FORMAT DIRECTIONALITY_POP_DIRECTIONAL_FORMAT
 * @since    1.5
 */
// BEGIN Android-changed: Reimplement methods natively on top of ICU4C.
public static byte getDirectionality(int codePoint) {
    if (getType(codePoint) == Character.UNASSIGNED) {
        return Character.DIRECTIONALITY_UNDEFINED;
    }
    byte directionality = getDirectionalityImpl(codePoint);
    if (directionality >= 0 && directionality < DIRECTIONALITY.length) {
        return DIRECTIONALITY[directionality];
    }
    return Character.DIRECTIONALITY_UNDEFINED;
}
#end_block

#method_before
// END Android-changed: Use ICU.
public static boolean isMirrored(char ch) {
    return isMirrored((int) ch);
}
#method_after
// END Android-changed: Reimplement methods natively on top of ICU4C.
public static boolean isMirrored(char ch) {
    return isMirrored((int) ch);
}
#end_block

#method_before
/**
 * Determines whether the specified character (Unicode code point)
 * is mirrored according to the Unicode specification.  Mirrored
 * characters should have their glyphs horizontally mirrored when
 * displayed in text that is right-to-left.  For example,
 * {@code '\u005Cu0028'} LEFT PARENTHESIS is semantically
 * defined to be an <i>opening parenthesis</i>.  This will appear
 * as a "(" in text that is left-to-right but as a ")" in text
 * that is right-to-left.
 *
 * @param   codePoint the character (Unicode code point) to be tested.
 * @return  {@code true} if the character is mirrored, {@code false}
 *          if the character is not mirrored or is not defined.
 * @since   1.5
 */
// BEGIN Android-changed: Use ICU.
// Reimplement isMirrored() natively.
public static boolean isMirrored(int codePoint) {
    return isMirroredImpl(codePoint);
}
#method_after
/**
 * Determines whether the specified character (Unicode code point)
 * is mirrored according to the Unicode specification.  Mirrored
 * characters should have their glyphs horizontally mirrored when
 * displayed in text that is right-to-left.  For example,
 * {@code '\u005Cu0028'} LEFT PARENTHESIS is semantically
 * defined to be an <i>opening parenthesis</i>.  This will appear
 * as a "(" in text that is left-to-right but as a ")" in text
 * that is right-to-left.
 *
 * @param   codePoint the character (Unicode code point) to be tested.
 * @return  {@code true} if the character is mirrored, {@code false}
 *          if the character is not mirrored or is not defined.
 * @since   1.5
 */
// BEGIN Android-changed: Reimplement methods natively on top of ICU4C.
public static boolean isMirrored(int codePoint) {
    return isMirroredImpl(codePoint);
}
#end_block

#method_before
// END Android-changed: Use ICU.
public int compareTo(Character anotherCharacter) {
    return compare(this.value, anotherCharacter.value);
}
#method_after
// END Android-changed: Reimplement methods natively on top of ICU4C.
public int compareTo(Character anotherCharacter) {
    return compare(this.value, anotherCharacter.value);
}
#end_block

#method_before
@Test
@SdkSuppress(maxSdkVersion = Build.VERSION_CODES.N_MR1)
public void testGetWebViewRendererPreO() throws Throwable {
    AssumptionUtils.checkFeature(WebViewFeature.GET_WEB_VIEW_RENDERER);
    // It should not be possible to get a renderer pre-O
    final WebViewRenderer renderer = startAndGetRenderer(webView).get();
    Assert.assertNull(renderer);
    WebViewOnUiThread.destroy(webView);
}
#method_after
@Test
@SdkSuppress(maxSdkVersion = Build.VERSION_CODES.N_MR1)
public void testGetWebViewRendererPreO() throws Throwable {
    AssumptionUtils.checkFeature(WebViewFeature.GET_WEB_VIEW_RENDERER);
    // It should not be possible to get a renderer pre-O
    WebView webView = WebViewOnUiThread.createWebView();
    final WebViewRenderer renderer = startAndGetRenderer(webView).get();
    Assert.assertNull(renderer);
    WebViewOnUiThread.destroy(webView);
}
#end_block

#method_before
private static void sendMsg(Handler handler, int msg, int existingMsgPolicy, int arg1, int arg2, Object obj, int delay) {
    if (existingMsgPolicy == SENDMSG_REPLACE) {
        handler.removeMessages(msg);
    } else if (existingMsgPolicy == SENDMSG_NOOP && handler.hasMessages(msg)) {
        return;
    }
    synchronized (mLastDeviceConnectMsgTime) {
        long time = SystemClock.uptimeMillis() + delay;
        handler.sendMessageAtTime(handler.obtainMessage(msg, arg1, arg2, obj), time);
        if (msg == MSG_SET_WIRED_DEVICE_CONNECTION_STATE || msg == MSG_SET_A2DP_SRC_CONNECTION_STATE || msg == MSG_SET_A2DP_SINK_CONNECTION_STATE || msg == MSG_SET_HEARING_AID_CONNECTION_STATE) {
            mLastDeviceConnectMsgTime = time;
        }
    }
}
#method_after
private static void sendMsg(Handler handler, int msg, int existingMsgPolicy, int arg1, int arg2, Object obj, int delay) {
    if (existingMsgPolicy == SENDMSG_REPLACE) {
        handler.removeMessages(msg);
    } else if (existingMsgPolicy == SENDMSG_NOOP && handler.hasMessages(msg)) {
        return;
    }
    synchronized (mLastDeviceConnectMsgTime) {
        long time = SystemClock.uptimeMillis() + delay;
        if (msg == MSG_SET_A2DP_SRC_CONNECTION_STATE || msg == MSG_SET_A2DP_SINK_CONNECTION_STATE || msg == MSG_SET_HEARING_AID_CONNECTION_STATE || msg == MSG_SET_WIRED_DEVICE_CONNECTION_STATE || msg == MSG_A2DP_DEVICE_CONFIG_CHANGE || msg == MSG_BTA2DP_DOCK_TIMEOUT) {
            if (mLastDeviceConnectMsgTime >= time) {
                // add a little delay to make sure messages are ordered as expected
                time = mLastDeviceConnectMsgTime + 30;
            }
            mLastDeviceConnectMsgTime = time;
        }
        handler.sendMessageAtTime(handler.obtainMessage(msg, arg1, arg2, obj), time);
    }
}
#end_block

#method_before
public int setBluetoothHearingAidDeviceConnectionState(BluetoothDevice device, int state, boolean suppressNoisyIntent, int musicDevice) {
    int delay;
    synchronized (mConnectedDevices) {
        if (!suppressNoisyIntent) {
            int intState = (state == BluetoothHearingAid.STATE_CONNECTED) ? 1 : 0;
            delay = checkSendBecomingNoisyIntent(AudioSystem.DEVICE_OUT_HEARING_AID, intState, musicDevice);
        } else {
            delay = 0;
        }
        queueMsgUnderWakeLock(mAudioHandler, MSG_SET_HEARING_AID_CONNECTION_STATE, state, 0, /* arg2 unused */
        device, delay);
    }
    return delay;
}
#method_after
public int setBluetoothHearingAidDeviceConnectionState(BluetoothDevice device, int state, boolean suppressNoisyIntent, int musicDevice) {
    int delay;
    mDeviceLogger.log((new AudioEventLogger.StringEvent("setHearingAidDeviceConnectionState state=" + state + " addr=" + device.getAddress() + " supprNoisy=" + suppressNoisyIntent)).printLog(TAG));
    synchronized (mConnectedDevices) {
        if (!suppressNoisyIntent) {
            int intState = (state == BluetoothHearingAid.STATE_CONNECTED) ? 1 : 0;
            delay = checkSendBecomingNoisyIntent(AudioSystem.DEVICE_OUT_HEARING_AID, intState, musicDevice);
        } else {
            delay = 0;
        }
        queueMsgUnderWakeLock(mAudioHandler, MSG_SET_HEARING_AID_CONNECTION_STATE, state, 0, /* arg2 unused */
        device, delay);
    }
    return delay;
}
#end_block

#method_before
public int setBluetoothA2dpDeviceConnectionStateSuppressNoisyIntent(BluetoothDevice device, int state, int profile, boolean suppressNoisyIntent, int a2dpVolume) {
    if (mAudioHandler.hasMessages(MSG_SET_A2DP_SINK_CONNECTION_STATE, device)) {
        return 0;
    }
    return setBluetoothA2dpDeviceConnectionStateInt(device, state, profile, suppressNoisyIntent, AudioSystem.DEVICE_NONE, a2dpVolume);
}
#method_after
public int setBluetoothA2dpDeviceConnectionStateSuppressNoisyIntent(BluetoothDevice device, int state, int profile, boolean suppressNoisyIntent, int a2dpVolume) {
    mDeviceLogger.log((new AudioEventLogger.StringEvent("setBluetoothA2dpDeviceConnectionStateSuppressNoisyIntent state=" + state + // only querying address as this is the only readily available field on the device
    " addr=" + device.getAddress() + " prof=" + profile + " supprNoisy=" + suppressNoisyIntent + " vol=" + a2dpVolume)).printLog(TAG));
    if (mAudioHandler.hasMessages(MSG_SET_A2DP_SINK_CONNECTION_STATE, device)) {
        mDeviceLogger.log(new AudioEventLogger.StringEvent("A2DP connection state ignored"));
        return 0;
    }
    return setBluetoothA2dpDeviceConnectionStateInt(device, state, profile, suppressNoisyIntent, AudioSystem.DEVICE_NONE, a2dpVolume);
}
#end_block

#method_before
public int setBluetoothA2dpDeviceConnectionStateInt(BluetoothDevice device, int state, int profile, boolean suppressNoisyIntent, int musicDevice, int a2dpVolume) {
    int delay;
    if (profile != BluetoothProfile.A2DP && profile != BluetoothProfile.A2DP_SINK) {
        throw new IllegalArgumentException("invalid profile " + profile);
    }
    synchronized (mConnectedDevices) {
        if (profile == BluetoothProfile.A2DP && !suppressNoisyIntent) {
            int intState = (state == BluetoothA2dp.STATE_CONNECTED) ? 1 : 0;
            delay = checkSendBecomingNoisyIntent(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP, intState, musicDevice);
        } else {
            delay = 0;
        }
        queueMsgUnderWakeLock(mAudioHandler, (profile == BluetoothProfile.A2DP ? MSG_SET_A2DP_SINK_CONNECTION_STATE : MSG_SET_A2DP_SRC_CONNECTION_STATE), state, a2dpVolume, device, delay);
    }
    return delay;
}
#method_after
public int setBluetoothA2dpDeviceConnectionStateInt(BluetoothDevice device, int state, int profile, boolean suppressNoisyIntent, int musicDevice, int a2dpVolume) {
    int delay;
    if (profile != BluetoothProfile.A2DP && profile != BluetoothProfile.A2DP_SINK) {
        throw new IllegalArgumentException("invalid profile " + profile);
    }
    synchronized (mConnectedDevices) {
        if (profile == BluetoothProfile.A2DP && !suppressNoisyIntent) {
            int intState = (state == BluetoothA2dp.STATE_CONNECTED) ? 1 : 0;
            delay = checkSendBecomingNoisyIntent(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP, intState, musicDevice);
        } else {
            delay = 0;
        }
        if (DEBUG_DEVICES) {
            Log.d(TAG, "setBluetoothA2dpDeviceConnectionStateInt device: " + device + " state: " + state + " delay(ms): " + delay + " suppressNoisyIntent: " + suppressNoisyIntent);
        }
        queueMsgUnderWakeLock(mAudioHandler, (profile == BluetoothProfile.A2DP ? MSG_SET_A2DP_SINK_CONNECTION_STATE : MSG_SET_A2DP_SRC_CONNECTION_STATE), state, a2dpVolume, device, delay);
    }
    return delay;
}
#end_block

#method_before
@Override
public void handleMessage(Message msg) {
    switch(msg.what) {
        case MSG_SET_DEVICE_VOLUME:
            setDeviceVolume((VolumeStreamState) msg.obj, msg.arg1);
            break;
        case MSG_SET_ALL_VOLUMES:
            setAllVolumes((VolumeStreamState) msg.obj);
            break;
        case MSG_PERSIST_VOLUME:
            persistVolume((VolumeStreamState) msg.obj, msg.arg1);
            break;
        case MSG_PERSIST_RINGER_MODE:
            // note that the value persisted is the current ringer mode, not the
            // value of ringer mode as of the time the request was made to persist
            persistRingerMode(getRingerModeInternal());
            break;
        case MSG_AUDIO_SERVER_DIED:
            onAudioServerDied();
            break;
        case MSG_DISPATCH_AUDIO_SERVER_STATE:
            onDispatchAudioServerStateChange(msg.arg1 == 1);
            break;
        case MSG_UNLOAD_SOUND_EFFECTS:
            onUnloadSoundEffects();
            break;
        case MSG_LOAD_SOUND_EFFECTS:
            // FIXME: onLoadSoundEffects() should be executed in a separate thread as it
            // can take several dozens of milliseconds to complete
            boolean loaded = onLoadSoundEffects();
            if (msg.obj != null) {
                LoadSoundEffectReply reply = (LoadSoundEffectReply) msg.obj;
                synchronized (reply) {
                    reply.mStatus = loaded ? 0 : -1;
                    reply.notify();
                }
            }
            break;
        case MSG_PLAY_SOUND_EFFECT:
            onPlaySoundEffect(msg.arg1, msg.arg2);
            break;
        case MSG_BTA2DP_DOCK_TIMEOUT:
            // msg.obj  == address of BTA2DP device
            synchronized (mConnectedDevices) {
                makeA2dpDeviceUnavailableNow((String) msg.obj);
            }
            break;
        case MSG_SET_FORCE_USE:
        case MSG_SET_FORCE_BT_A2DP_USE:
            setForceUse(msg.arg1, msg.arg2, (String) msg.obj);
            break;
        case MSG_BT_HEADSET_CNCT_FAILED:
            resetBluetoothSco();
            break;
        case MSG_SET_WIRED_DEVICE_CONNECTION_STATE:
            {
                WiredDeviceConnectionState connectState = (WiredDeviceConnectionState) msg.obj;
                mWiredDevLogger.log(new WiredDevConnectEvent(connectState));
                onSetWiredDeviceConnectionState(connectState.mType, connectState.mState, connectState.mAddress, connectState.mName, connectState.mCaller);
                mAudioEventWakeLock.release();
            }
            break;
        case MSG_SET_A2DP_SRC_CONNECTION_STATE:
            onSetA2dpSourceConnectionState((BluetoothDevice) msg.obj, msg.arg1);
            mAudioEventWakeLock.release();
            break;
        case MSG_SET_A2DP_SINK_CONNECTION_STATE:
            onSetA2dpSinkConnectionState((BluetoothDevice) msg.obj, msg.arg1, msg.arg2);
            mAudioEventWakeLock.release();
            break;
        case MSG_SET_HEARING_AID_CONNECTION_STATE:
            onSetHearingAidConnectionState((BluetoothDevice) msg.obj, msg.arg1);
            mAudioEventWakeLock.release();
            break;
        case MSG_A2DP_DEVICE_CONFIG_CHANGE:
            onBluetoothA2dpDeviceConfigChange((BluetoothDevice) msg.obj);
            mAudioEventWakeLock.release();
            break;
        case MSG_DISABLE_AUDIO_FOR_UID:
            mPlaybackMonitor.disableAudioForUid(msg.arg1 == 1, /* disable */
            msg.arg2);
            mAudioEventWakeLock.release();
            break;
        case MSG_REPORT_NEW_ROUTES:
            {
                int N = mRoutesObservers.beginBroadcast();
                if (N > 0) {
                    AudioRoutesInfo routes;
                    synchronized (mCurAudioRoutes) {
                        routes = new AudioRoutesInfo(mCurAudioRoutes);
                    }
                    while (N > 0) {
                        N--;
                        IAudioRoutesObserver obs = mRoutesObservers.getBroadcastItem(N);
                        try {
                            obs.dispatchAudioRoutesChanged(routes);
                        } catch (RemoteException e) {
                        }
                    }
                }
                mRoutesObservers.finishBroadcast();
                observeDevicesForStreams(-1);
                break;
            }
        case MSG_CHECK_MUSIC_ACTIVE:
            onCheckMusicActive((String) msg.obj);
            break;
        case MSG_BROADCAST_AUDIO_BECOMING_NOISY:
            onSendBecomingNoisyIntent();
            break;
        case MSG_CONFIGURE_SAFE_MEDIA_VOLUME_FORCED:
        case MSG_CONFIGURE_SAFE_MEDIA_VOLUME:
            onConfigureSafeVolume((msg.what == MSG_CONFIGURE_SAFE_MEDIA_VOLUME_FORCED), (String) msg.obj);
            break;
        case MSG_PERSIST_SAFE_VOLUME_STATE:
            onPersistSafeVolumeState(msg.arg1);
            break;
        case MSG_BROADCAST_BT_CONNECTION_STATE:
            onBroadcastScoConnectionState(msg.arg1);
            break;
        case MSG_SYSTEM_READY:
            onSystemReady();
            break;
        case MSG_INDICATE_SYSTEM_READY:
            onIndicateSystemReady();
            break;
        case MSG_ACCESSORY_PLUG_MEDIA_UNMUTE:
            onAccessoryPlugMediaUnmute(msg.arg1);
            break;
        case MSG_PERSIST_MUSIC_ACTIVE_MS:
            final int musicActiveMs = msg.arg1;
            Settings.Secure.putIntForUser(mContentResolver, Settings.Secure.UNSAFE_VOLUME_MUSIC_ACTIVE_MS, musicActiveMs, UserHandle.USER_CURRENT);
            break;
        case MSG_UNMUTE_STREAM:
            onUnmuteStream(msg.arg1, msg.arg2);
            break;
        case MSG_DYN_POLICY_MIX_STATE_UPDATE:
            onDynPolicyMixStateUpdate((String) msg.obj, msg.arg1);
            break;
        case MSG_NOTIFY_VOL_EVENT:
            onNotifyVolumeEvent((IAudioPolicyCallback) msg.obj, msg.arg1);
            break;
        case MSG_ENABLE_SURROUND_FORMATS:
            onEnableSurroundFormats((ArrayList<Integer>) msg.obj);
            break;
    }
}
#method_after
@Override
public void handleMessage(Message msg) {
    switch(msg.what) {
        case MSG_SET_DEVICE_VOLUME:
            setDeviceVolume((VolumeStreamState) msg.obj, msg.arg1);
            break;
        case MSG_SET_ALL_VOLUMES:
            setAllVolumes((VolumeStreamState) msg.obj);
            break;
        case MSG_PERSIST_VOLUME:
            persistVolume((VolumeStreamState) msg.obj, msg.arg1);
            break;
        case MSG_PERSIST_RINGER_MODE:
            // note that the value persisted is the current ringer mode, not the
            // value of ringer mode as of the time the request was made to persist
            persistRingerMode(getRingerModeInternal());
            break;
        case MSG_AUDIO_SERVER_DIED:
            onAudioServerDied();
            break;
        case MSG_DISPATCH_AUDIO_SERVER_STATE:
            onDispatchAudioServerStateChange(msg.arg1 == 1);
            break;
        case MSG_UNLOAD_SOUND_EFFECTS:
            onUnloadSoundEffects();
            break;
        case MSG_LOAD_SOUND_EFFECTS:
            // FIXME: onLoadSoundEffects() should be executed in a separate thread as it
            // can take several dozens of milliseconds to complete
            boolean loaded = onLoadSoundEffects();
            if (msg.obj != null) {
                LoadSoundEffectReply reply = (LoadSoundEffectReply) msg.obj;
                synchronized (reply) {
                    reply.mStatus = loaded ? 0 : -1;
                    reply.notify();
                }
            }
            break;
        case MSG_PLAY_SOUND_EFFECT:
            onPlaySoundEffect(msg.arg1, msg.arg2);
            break;
        case MSG_BTA2DP_DOCK_TIMEOUT:
            // msg.obj  == address of BTA2DP device
            synchronized (mConnectedDevices) {
                makeA2dpDeviceUnavailableNow((String) msg.obj);
            }
            mAudioEventWakeLock.release();
            break;
        case MSG_SET_FORCE_USE:
        case MSG_SET_FORCE_BT_A2DP_USE:
            setForceUse(msg.arg1, msg.arg2, (String) msg.obj);
            break;
        case MSG_BT_HEADSET_CNCT_FAILED:
            resetBluetoothSco();
            break;
        case MSG_SET_WIRED_DEVICE_CONNECTION_STATE:
            {
                WiredDeviceConnectionState connectState = (WiredDeviceConnectionState) msg.obj;
                mDeviceLogger.log(new WiredDevConnectEvent(connectState));
                onSetWiredDeviceConnectionState(connectState.mType, connectState.mState, connectState.mAddress, connectState.mName, connectState.mCaller);
                mAudioEventWakeLock.release();
            }
            break;
        case MSG_SET_A2DP_SRC_CONNECTION_STATE:
            onSetA2dpSourceConnectionState((BluetoothDevice) msg.obj, msg.arg1);
            mAudioEventWakeLock.release();
            break;
        case MSG_SET_A2DP_SINK_CONNECTION_STATE:
            onSetA2dpSinkConnectionState((BluetoothDevice) msg.obj, msg.arg1, msg.arg2);
            mAudioEventWakeLock.release();
            break;
        case MSG_SET_HEARING_AID_CONNECTION_STATE:
            onSetHearingAidConnectionState((BluetoothDevice) msg.obj, msg.arg1);
            mAudioEventWakeLock.release();
            break;
        case MSG_A2DP_DEVICE_CONFIG_CHANGE:
            onBluetoothA2dpDeviceConfigChange((BluetoothDevice) msg.obj);
            mAudioEventWakeLock.release();
            break;
        case MSG_DISABLE_AUDIO_FOR_UID:
            mPlaybackMonitor.disableAudioForUid(msg.arg1 == 1, /* disable */
            msg.arg2);
            mAudioEventWakeLock.release();
            break;
        case MSG_REPORT_NEW_ROUTES:
            {
                int N = mRoutesObservers.beginBroadcast();
                if (N > 0) {
                    AudioRoutesInfo routes;
                    synchronized (mCurAudioRoutes) {
                        routes = new AudioRoutesInfo(mCurAudioRoutes);
                    }
                    while (N > 0) {
                        N--;
                        IAudioRoutesObserver obs = mRoutesObservers.getBroadcastItem(N);
                        try {
                            obs.dispatchAudioRoutesChanged(routes);
                        } catch (RemoteException e) {
                        }
                    }
                }
                mRoutesObservers.finishBroadcast();
                observeDevicesForStreams(-1);
                break;
            }
        case MSG_CHECK_MUSIC_ACTIVE:
            onCheckMusicActive((String) msg.obj);
            break;
        case MSG_BROADCAST_AUDIO_BECOMING_NOISY:
            onSendBecomingNoisyIntent();
            break;
        case MSG_CONFIGURE_SAFE_MEDIA_VOLUME_FORCED:
        case MSG_CONFIGURE_SAFE_MEDIA_VOLUME:
            onConfigureSafeVolume((msg.what == MSG_CONFIGURE_SAFE_MEDIA_VOLUME_FORCED), (String) msg.obj);
            break;
        case MSG_PERSIST_SAFE_VOLUME_STATE:
            onPersistSafeVolumeState(msg.arg1);
            break;
        case MSG_BROADCAST_BT_CONNECTION_STATE:
            onBroadcastScoConnectionState(msg.arg1);
            break;
        case MSG_SYSTEM_READY:
            onSystemReady();
            break;
        case MSG_INDICATE_SYSTEM_READY:
            onIndicateSystemReady();
            break;
        case MSG_ACCESSORY_PLUG_MEDIA_UNMUTE:
            onAccessoryPlugMediaUnmute(msg.arg1);
            break;
        case MSG_PERSIST_MUSIC_ACTIVE_MS:
            final int musicActiveMs = msg.arg1;
            Settings.Secure.putIntForUser(mContentResolver, Settings.Secure.UNSAFE_VOLUME_MUSIC_ACTIVE_MS, musicActiveMs, UserHandle.USER_CURRENT);
            break;
        case MSG_UNMUTE_STREAM:
            onUnmuteStream(msg.arg1, msg.arg2);
            break;
        case MSG_DYN_POLICY_MIX_STATE_UPDATE:
            onDynPolicyMixStateUpdate((String) msg.obj, msg.arg1);
            break;
        case MSG_NOTIFY_VOL_EVENT:
            onNotifyVolumeEvent((IAudioPolicyCallback) msg.obj, msg.arg1);
            break;
        case MSG_ENABLE_SURROUND_FORMATS:
            onEnableSurroundFormats((ArrayList<Integer>) msg.obj);
            break;
    }
}
#end_block

#method_before
private void makeA2dpDeviceAvailable(String address, String name, String eventSource) {
    // enable A2DP before notifying A2DP connection to avoid unnecessary processing in
    // audio policy manager
    VolumeStreamState streamState = mStreamStates[AudioSystem.STREAM_MUSIC];
    setBluetoothA2dpOnInt(true, eventSource);
    AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP, AudioSystem.DEVICE_STATE_AVAILABLE, address, name);
    // Reset A2DP suspend state each time a new sink is connected
    AudioSystem.setParameters("A2dpSuspended=false");
    mConnectedDevices.put(makeDeviceListKey(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP, address), new DeviceListSpec(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP, name, address));
    sendMsg(mAudioHandler, MSG_ACCESSORY_PLUG_MEDIA_UNMUTE, SENDMSG_QUEUE, AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP, 0, null, 0);
}
#method_after
private void makeA2dpDeviceAvailable(String address, String name, String eventSource) {
    // enable A2DP before notifying A2DP connection to avoid unnecessary processing in
    // audio policy manager
    VolumeStreamState streamState = mStreamStates[AudioSystem.STREAM_MUSIC];
    setBluetoothA2dpOnInt(true, eventSource);
    AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP, AudioSystem.DEVICE_STATE_AVAILABLE, address, name);
    // Reset A2DP suspend state each time a new sink is connected
    AudioSystem.setParameters("A2dpSuspended=false");
    mConnectedDevices.put(makeDeviceListKey(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP, address), new DeviceListSpec(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP, name, address));
    sendMsg(mAudioHandler, MSG_ACCESSORY_PLUG_MEDIA_UNMUTE, SENDMSG_QUEUE, AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP, 0, null, 0);
    setCurrentAudioRouteNameIfPossible(name);
}
#end_block

#method_before
private void onSendBecomingNoisyIntent() {
    sendBroadcastToAll(new Intent(AudioManager.ACTION_AUDIO_BECOMING_NOISY));
}
#method_after
private void onSendBecomingNoisyIntent() {
    mDeviceLogger.log((new AudioEventLogger.StringEvent("broadcast ACTION_AUDIO_BECOMING_NOISY")).printLog(TAG));
    sendBroadcastToAll(new Intent(AudioManager.ACTION_AUDIO_BECOMING_NOISY));
}
#end_block

#method_before
private void makeA2dpDeviceUnavailableNow(String address) {
    synchronized (mA2dpAvrcpLock) {
        mAvrcpAbsVolSupported = false;
    }
    AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP, AudioSystem.DEVICE_STATE_UNAVAILABLE, address, "");
    mConnectedDevices.remove(makeDeviceListKey(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP, address));
    // Remove A2DP routes as well
    setCurrentAudioRouteName(null);
}
#method_after
private void makeA2dpDeviceUnavailableNow(String address) {
    if (address == null) {
        return;
    }
    synchronized (mA2dpAvrcpLock) {
        mAvrcpAbsVolSupported = false;
    }
    AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP, AudioSystem.DEVICE_STATE_UNAVAILABLE, address, "");
    mConnectedDevices.remove(makeDeviceListKey(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP, address));
    // Remove A2DP routes as well
    setCurrentAudioRouteNameIfPossible(null);
    if (mDockAddress == address) {
        mDockAddress = null;
    }
}
#end_block

#method_before
private void makeA2dpDeviceUnavailableLater(String address, int delayMs) {
    // prevent any activity on the A2DP audio output to avoid unwanted
    // reconnection of the sink.
    AudioSystem.setParameters("A2dpSuspended=true");
    // the device will be made unavailable later, so consider it disconnected right away
    mConnectedDevices.remove(makeDeviceListKey(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP, address));
    // send the delayed message to make the device unavailable later
    Message msg = mAudioHandler.obtainMessage(MSG_BTA2DP_DOCK_TIMEOUT, address);
    mAudioHandler.sendMessageDelayed(msg, delayMs);
}
#method_after
private void makeA2dpDeviceUnavailableLater(String address, int delayMs) {
    // prevent any activity on the A2DP audio output to avoid unwanted
    // reconnection of the sink.
    AudioSystem.setParameters("A2dpSuspended=true");
    // the device will be made unavailable later, so consider it disconnected right away
    mConnectedDevices.remove(makeDeviceListKey(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP, address));
    // send the delayed message to make the device unavailable later
    queueMsgUnderWakeLock(mAudioHandler, MSG_BTA2DP_DOCK_TIMEOUT, 0, 0, address, delayMs);
}
#end_block

#method_before
private void makeHearingAidDeviceAvailable(String address, String name, String eventSource) {
    int index = mStreamStates[AudioSystem.STREAM_MUSIC].getIndex(AudioSystem.DEVICE_OUT_HEARING_AID);
    setHearingAidVolume(index, AudioSystem.STREAM_MUSIC);
    AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_HEARING_AID, AudioSystem.DEVICE_STATE_AVAILABLE, address, name);
    mConnectedDevices.put(makeDeviceListKey(AudioSystem.DEVICE_OUT_HEARING_AID, address), new DeviceListSpec(AudioSystem.DEVICE_OUT_HEARING_AID, name, address));
    sendMsg(mAudioHandler, MSG_ACCESSORY_PLUG_MEDIA_UNMUTE, SENDMSG_QUEUE, AudioSystem.DEVICE_OUT_HEARING_AID, 0, null, 0);
}
#method_after
private void makeHearingAidDeviceAvailable(String address, String name, String eventSource) {
    int index = mStreamStates[AudioSystem.STREAM_MUSIC].getIndex(AudioSystem.DEVICE_OUT_HEARING_AID);
    setHearingAidVolume(index, AudioSystem.STREAM_MUSIC);
    AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_HEARING_AID, AudioSystem.DEVICE_STATE_AVAILABLE, address, name);
    mConnectedDevices.put(makeDeviceListKey(AudioSystem.DEVICE_OUT_HEARING_AID, address), new DeviceListSpec(AudioSystem.DEVICE_OUT_HEARING_AID, name, address));
    sendMsg(mAudioHandler, MSG_ACCESSORY_PLUG_MEDIA_UNMUTE, SENDMSG_QUEUE, AudioSystem.DEVICE_OUT_HEARING_AID, 0, null, 0);
    sendMsg(mAudioHandler, MSG_SET_DEVICE_VOLUME, SENDMSG_QUEUE, AudioSystem.DEVICE_OUT_HEARING_AID, 0, mStreamStates[AudioSystem.STREAM_MUSIC], 0);
    setCurrentAudioRouteNameIfPossible(name);
}
#end_block

#method_before
private void makeHearingAidDeviceUnavailable(String address) {
    AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_HEARING_AID, AudioSystem.DEVICE_STATE_UNAVAILABLE, address, "");
    mConnectedDevices.remove(makeDeviceListKey(AudioSystem.DEVICE_OUT_HEARING_AID, address));
    // Remove Hearing Aid routes as well
    setCurrentAudioRouteName(null);
}
#method_after
private void makeHearingAidDeviceUnavailable(String address) {
    AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_HEARING_AID, AudioSystem.DEVICE_STATE_UNAVAILABLE, address, "");
    mConnectedDevices.remove(makeDeviceListKey(AudioSystem.DEVICE_OUT_HEARING_AID, address));
    // Remove Hearing Aid routes as well
    setCurrentAudioRouteNameIfPossible(null);
}
#end_block

#method_before
private void onSetA2dpSinkConnectionState(BluetoothDevice btDevice, int state, int a2dpVolume) {
    if (DEBUG_DEVICES) {
        Log.d(TAG, "onSetA2dpSinkConnectionState btDevice=" + btDevice + "state=" + state);
    }
    if (btDevice == null) {
        return;
    }
    String address = btDevice.getAddress();
    if (!BluetoothAdapter.checkBluetoothAddress(address)) {
        address = "";
    }
    synchronized (mConnectedDevices) {
        final String key = makeDeviceListKey(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP, btDevice.getAddress());
        final DeviceListSpec deviceSpec = mConnectedDevices.get(key);
        boolean isConnected = deviceSpec != null;
        if (isConnected && state != BluetoothProfile.STATE_CONNECTED) {
            if (btDevice.isBluetoothDock()) {
                if (state == BluetoothProfile.STATE_DISCONNECTED) {
                    // introduction of a delay for transient disconnections of docks when
                    // power is rapidly turned off/on, this message will be canceled if
                    // we reconnect the dock under a preset delay
                    makeA2dpDeviceUnavailableLater(address, BTA2DP_DOCK_TIMEOUT_MILLIS);
                // the next time isConnected is evaluated, it will be false for the dock
                }
            } else {
                makeA2dpDeviceUnavailableNow(address);
            }
        } else if (!isConnected && state == BluetoothProfile.STATE_CONNECTED) {
            if (btDevice.isBluetoothDock()) {
                // this could be a reconnection after a transient disconnection
                cancelA2dpDeviceTimeout();
                mDockAddress = address;
            } else {
                // a dock: cancel the dock timeout, and make the dock unavailable now
                if (hasScheduledA2dpDockTimeout()) {
                    cancelA2dpDeviceTimeout();
                    makeA2dpDeviceUnavailableNow(mDockAddress);
                }
            }
            if (a2dpVolume != -1) {
                VolumeStreamState streamState = mStreamStates[AudioSystem.STREAM_MUSIC];
                // Convert index to internal representation in VolumeStreamState
                a2dpVolume = a2dpVolume * 10;
                streamState.setIndex(a2dpVolume, AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP, "onSetA2dpSinkConnectionState");
                setDeviceVolume(streamState, AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP);
            }
            makeA2dpDeviceAvailable(address, btDevice.getName(), "onSetA2dpSinkConnectionState");
            setCurrentAudioRouteName(btDevice.getName());
        }
    }
}
#method_after
private void onSetA2dpSinkConnectionState(BluetoothDevice btDevice, int state, int a2dpVolume) {
    if (DEBUG_DEVICES) {
        Log.d(TAG, "onSetA2dpSinkConnectionState btDevice= " + btDevice + " state= " + state + " is dock: " + btDevice.isBluetoothDock());
    }
    if (btDevice == null) {
        return;
    }
    String address = btDevice.getAddress();
    if (!BluetoothAdapter.checkBluetoothAddress(address)) {
        address = "";
    }
    synchronized (mConnectedDevices) {
        final String key = makeDeviceListKey(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP, btDevice.getAddress());
        final DeviceListSpec deviceSpec = mConnectedDevices.get(key);
        boolean isConnected = deviceSpec != null;
        if (isConnected && state != BluetoothProfile.STATE_CONNECTED) {
            if (btDevice.isBluetoothDock()) {
                if (state == BluetoothProfile.STATE_DISCONNECTED) {
                    // introduction of a delay for transient disconnections of docks when
                    // power is rapidly turned off/on, this message will be canceled if
                    // we reconnect the dock under a preset delay
                    makeA2dpDeviceUnavailableLater(address, BTA2DP_DOCK_TIMEOUT_MILLIS);
                // the next time isConnected is evaluated, it will be false for the dock
                }
            } else {
                makeA2dpDeviceUnavailableNow(address);
            }
        } else if (!isConnected && state == BluetoothProfile.STATE_CONNECTED) {
            if (btDevice.isBluetoothDock()) {
                // this could be a reconnection after a transient disconnection
                cancelA2dpDeviceTimeout();
                mDockAddress = address;
            } else {
                // a dock: cancel the dock timeout, and make the dock unavailable now
                if (hasScheduledA2dpDockTimeout() && mDockAddress != null) {
                    cancelA2dpDeviceTimeout();
                    makeA2dpDeviceUnavailableNow(mDockAddress);
                }
            }
            if (a2dpVolume != -1) {
                VolumeStreamState streamState = mStreamStates[AudioSystem.STREAM_MUSIC];
                // Convert index to internal representation in VolumeStreamState
                a2dpVolume = a2dpVolume * 10;
                streamState.setIndex(a2dpVolume, AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP, "onSetA2dpSinkConnectionState");
                setDeviceVolume(streamState, AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP);
            }
            makeA2dpDeviceAvailable(address, btDevice.getName(), "onSetA2dpSinkConnectionState");
        }
    }
}
#end_block

#method_before
private void onSetHearingAidConnectionState(BluetoothDevice btDevice, int state) {
    if (DEBUG_DEVICES) {
        Log.d(TAG, "onSetHearingAidConnectionState btDevice=" + btDevice + ", state=" + state);
    }
    if (btDevice == null) {
        return;
    }
    String address = btDevice.getAddress();
    if (!BluetoothAdapter.checkBluetoothAddress(address)) {
        address = "";
    }
    synchronized (mConnectedDevices) {
        final String key = makeDeviceListKey(AudioSystem.DEVICE_OUT_HEARING_AID, btDevice.getAddress());
        final DeviceListSpec deviceSpec = mConnectedDevices.get(key);
        boolean isConnected = deviceSpec != null;
        if (isConnected && state != BluetoothProfile.STATE_CONNECTED) {
            makeHearingAidDeviceUnavailable(address);
        } else if (!isConnected && state == BluetoothProfile.STATE_CONNECTED) {
            makeHearingAidDeviceAvailable(address, btDevice.getName(), "onSetHearingAidConnectionState");
            setCurrentAudioRouteName(btDevice.getName());
        }
    }
}
#method_after
private void onSetHearingAidConnectionState(BluetoothDevice btDevice, int state) {
    if (DEBUG_DEVICES) {
        Log.d(TAG, "onSetHearingAidConnectionState btDevice=" + btDevice + ", state=" + state);
    }
    if (btDevice == null) {
        return;
    }
    String address = btDevice.getAddress();
    if (!BluetoothAdapter.checkBluetoothAddress(address)) {
        address = "";
    }
    synchronized (mConnectedDevices) {
        final String key = makeDeviceListKey(AudioSystem.DEVICE_OUT_HEARING_AID, btDevice.getAddress());
        final DeviceListSpec deviceSpec = mConnectedDevices.get(key);
        boolean isConnected = deviceSpec != null;
        if (isConnected && state != BluetoothProfile.STATE_CONNECTED) {
            makeHearingAidDeviceUnavailable(address);
        } else if (!isConnected && state == BluetoothProfile.STATE_CONNECTED) {
            makeHearingAidDeviceAvailable(address, btDevice.getName(), "onSetHearingAidConnectionState");
        }
    }
}
#end_block

#method_before
private void onBluetoothA2dpDeviceConfigChange(BluetoothDevice btDevice) {
    if (DEBUG_DEVICES) {
        Log.d(TAG, "onBluetoothA2dpDeviceConfigChange btDevice=" + btDevice);
    }
    if (btDevice == null) {
        return;
    }
    String address = btDevice.getAddress();
    if (!BluetoothAdapter.checkBluetoothAddress(address)) {
        address = "";
    }
    int device = AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP;
    synchronized (mConnectedDevices) {
        if (mAudioHandler.hasMessages(MSG_SET_A2DP_SINK_CONNECTION_STATE, btDevice)) {
            return;
        }
        final String key = makeDeviceListKey(device, address);
        final DeviceListSpec deviceSpec = mConnectedDevices.get(key);
        if (deviceSpec != null) {
            // Device is connected
            int musicDevice = getDeviceForStream(AudioSystem.STREAM_MUSIC);
            if (AudioSystem.handleDeviceConfigChange(device, address, btDevice.getName()) != AudioSystem.AUDIO_STATUS_OK) {
                // force A2DP device disconnection in case of error so that AudioService state is
                // consistent with audio policy manager state
                setBluetoothA2dpDeviceConnectionStateInt(btDevice, BluetoothA2dp.STATE_DISCONNECTED, BluetoothProfile.A2DP, false, /* suppressNoisyIntent */
                musicDevice, -1);
            }
        }
    }
}
#method_after
private void onBluetoothA2dpDeviceConfigChange(BluetoothDevice btDevice) {
    if (DEBUG_DEVICES) {
        Log.d(TAG, "onBluetoothA2dpDeviceConfigChange btDevice=" + btDevice);
    }
    if (btDevice == null) {
        return;
    }
    String address = btDevice.getAddress();
    if (!BluetoothAdapter.checkBluetoothAddress(address)) {
        address = "";
    }
    mDeviceLogger.log(new AudioEventLogger.StringEvent("onBluetoothA2dpDeviceConfigChange addr=" + address));
    int device = AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP;
    synchronized (mConnectedDevices) {
        if (mAudioHandler.hasMessages(MSG_SET_A2DP_SINK_CONNECTION_STATE, btDevice)) {
            mDeviceLogger.log(new AudioEventLogger.StringEvent("A2dp config change ignored"));
            return;
        }
        final String key = makeDeviceListKey(device, address);
        final DeviceListSpec deviceSpec = mConnectedDevices.get(key);
        if (deviceSpec != null) {
            // Device is connected
            int musicDevice = getDeviceForStream(AudioSystem.STREAM_MUSIC);
            if (AudioSystem.handleDeviceConfigChange(device, address, btDevice.getName()) != AudioSystem.AUDIO_STATUS_OK) {
                // force A2DP device disconnection in case of error so that AudioService state is
                // consistent with audio policy manager state
                setBluetoothA2dpDeviceConnectionStateInt(btDevice, BluetoothA2dp.STATE_DISCONNECTED, BluetoothProfile.A2DP, false, /* suppressNoisyIntent */
                musicDevice, -1);
            }
        }
    }
}
#end_block

#method_before
// must be called before removing the device from mConnectedDevices
// Called synchronized on mConnectedDevices
// musicDevice argument is used when not AudioSystem.DEVICE_NONE instead of querying
private int checkSendBecomingNoisyIntent(int device, int state, int musicDevice) {
    int delay = 0;
    if ((state == 0) && ((device & mBecomingNoisyIntentDevices) != 0)) {
        int devices = 0;
        for (int i = 0; i < mConnectedDevices.size(); i++) {
            int dev = mConnectedDevices.valueAt(i).mDeviceType;
            if (((dev & AudioSystem.DEVICE_BIT_IN) == 0) && ((dev & mBecomingNoisyIntentDevices) != 0)) {
                devices |= dev;
            }
        }
        if (musicDevice == AudioSystem.DEVICE_NONE) {
            musicDevice = getDeviceForStream(AudioSystem.STREAM_MUSIC);
        }
        // also checks whether media routing if affected by a dynamic policy
        if (((device == musicDevice) || isInCommunication()) && (device == devices) && !hasMediaDynamicPolicy()) {
            mAudioHandler.removeMessages(MSG_BROADCAST_AUDIO_BECOMING_NOISY);
            sendMsg(mAudioHandler, MSG_BROADCAST_AUDIO_BECOMING_NOISY, SENDMSG_REPLACE, 0, 0, null, 0);
            delay = 1000;
        }
    }
    if (mAudioHandler.hasMessages(MSG_SET_A2DP_SRC_CONNECTION_STATE) || mAudioHandler.hasMessages(MSG_SET_A2DP_SINK_CONNECTION_STATE) || mAudioHandler.hasMessages(MSG_SET_HEARING_AID_CONNECTION_STATE) || mAudioHandler.hasMessages(MSG_SET_WIRED_DEVICE_CONNECTION_STATE)) {
        synchronized (mLastDeviceConnectMsgTime) {
            long time = SystemClock.uptimeMillis();
            if (mLastDeviceConnectMsgTime > time) {
                delay = (int) (mLastDeviceConnectMsgTime - time) + 30;
            }
        }
    }
    return delay;
}
#method_after
// must be called before removing the device from mConnectedDevices
// Called synchronized on mConnectedDevices
// musicDevice argument is used when not AudioSystem.DEVICE_NONE instead of querying
private int checkSendBecomingNoisyIntent(int device, int state, int musicDevice) {
    int delay = 0;
    if ((state == 0) && ((device & mBecomingNoisyIntentDevices) != 0)) {
        int devices = 0;
        for (int i = 0; i < mConnectedDevices.size(); i++) {
            int dev = mConnectedDevices.valueAt(i).mDeviceType;
            if (((dev & AudioSystem.DEVICE_BIT_IN) == 0) && ((dev & mBecomingNoisyIntentDevices) != 0)) {
                devices |= dev;
            }
        }
        if (musicDevice == AudioSystem.DEVICE_NONE) {
            musicDevice = getDeviceForStream(AudioSystem.STREAM_MUSIC);
        }
        // also checks whether media routing if affected by a dynamic policy
        if (((device == musicDevice) || isInCommunication()) && (device == devices) && !hasMediaDynamicPolicy()) {
            mAudioHandler.removeMessages(MSG_BROADCAST_AUDIO_BECOMING_NOISY);
            sendMsg(mAudioHandler, MSG_BROADCAST_AUDIO_BECOMING_NOISY, SENDMSG_REPLACE, 0, 0, null, 0);
            delay = 1000;
        }
    }
    return delay;
}
#end_block

#method_before
@Override
protected void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
    if (!DumpUtils.checkDumpPermission(mContext, TAG, pw))
        return;
    mMediaFocusControl.dump(pw);
    dumpStreamStates(pw);
    dumpRingerMode(pw);
    pw.println("\nAudio routes:");
    pw.print("  mMainType=0x");
    pw.println(Integer.toHexString(mCurAudioRoutes.mainType));
    pw.print("  mBluetoothName=");
    pw.println(mCurAudioRoutes.bluetoothName);
    pw.println("\nOther state:");
    pw.print("  mVolumeController=");
    pw.println(mVolumeController);
    pw.print("  mSafeMediaVolumeState=");
    pw.println(safeMediaVolumeStateToString(mSafeMediaVolumeState));
    pw.print("  mSafeMediaVolumeIndex=");
    pw.println(mSafeMediaVolumeIndex);
    pw.print("  mSafeUsbMediaVolumeIndex=");
    pw.println(mSafeUsbMediaVolumeIndex);
    pw.print("  mSafeUsbMediaVolumeDbfs=");
    pw.println(mSafeUsbMediaVolumeDbfs);
    pw.print("  sIndependentA11yVolume=");
    pw.println(sIndependentA11yVolume);
    pw.print("  mPendingVolumeCommand=");
    pw.println(mPendingVolumeCommand);
    pw.print("  mMusicActiveMs=");
    pw.println(mMusicActiveMs);
    pw.print("  mMcc=");
    pw.println(mMcc);
    pw.print("  mCameraSoundForced=");
    pw.println(mCameraSoundForced);
    pw.print("  mHasVibrator=");
    pw.println(mHasVibrator);
    pw.print("  mVolumePolicy=");
    pw.println(mVolumePolicy);
    pw.print("  mAvrcpAbsVolSupported=");
    pw.println(mAvrcpAbsVolSupported);
    dumpAudioPolicies(pw);
    mDynPolicyLogger.dump(pw);
    mPlaybackMonitor.dump(pw);
    mRecordMonitor.dump(pw);
    pw.println("\n");
    pw.println("\nEvent logs:");
    mModeLogger.dump(pw);
    pw.println("\n");
    mWiredDevLogger.dump(pw);
    pw.println("\n");
    mForceUseLogger.dump(pw);
    pw.println("\n");
    mVolumeLogger.dump(pw);
}
#method_after
@Override
protected void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
    if (!DumpUtils.checkDumpPermission(mContext, TAG, pw))
        return;
    mMediaFocusControl.dump(pw);
    dumpStreamStates(pw);
    dumpRingerMode(pw);
    pw.println("\nAudio routes:");
    pw.print("  mMainType=0x");
    pw.println(Integer.toHexString(mCurAudioRoutes.mainType));
    pw.print("  mBluetoothName=");
    pw.println(mCurAudioRoutes.bluetoothName);
    pw.println("\nOther state:");
    pw.print("  mVolumeController=");
    pw.println(mVolumeController);
    pw.print("  mSafeMediaVolumeState=");
    pw.println(safeMediaVolumeStateToString(mSafeMediaVolumeState));
    pw.print("  mSafeMediaVolumeIndex=");
    pw.println(mSafeMediaVolumeIndex);
    pw.print("  mSafeUsbMediaVolumeIndex=");
    pw.println(mSafeUsbMediaVolumeIndex);
    pw.print("  mSafeUsbMediaVolumeDbfs=");
    pw.println(mSafeUsbMediaVolumeDbfs);
    pw.print("  sIndependentA11yVolume=");
    pw.println(sIndependentA11yVolume);
    pw.print("  mPendingVolumeCommand=");
    pw.println(mPendingVolumeCommand);
    pw.print("  mMusicActiveMs=");
    pw.println(mMusicActiveMs);
    pw.print("  mMcc=");
    pw.println(mMcc);
    pw.print("  mCameraSoundForced=");
    pw.println(mCameraSoundForced);
    pw.print("  mHasVibrator=");
    pw.println(mHasVibrator);
    pw.print("  mVolumePolicy=");
    pw.println(mVolumePolicy);
    pw.print("  mAvrcpAbsVolSupported=");
    pw.println(mAvrcpAbsVolSupported);
    dumpAudioPolicies(pw);
    mDynPolicyLogger.dump(pw);
    mPlaybackMonitor.dump(pw);
    mRecordMonitor.dump(pw);
    pw.println("\n");
    pw.println("\nEvent logs:");
    mModeLogger.dump(pw);
    pw.println("\n");
    mDeviceLogger.dump(pw);
    pw.println("\n");
    mForceUseLogger.dump(pw);
    pw.println("\n");
    mVolumeLogger.dump(pw);
}
#end_block

#method_before
public String getName() {
    return mName;
}
#method_after
@NonNull
public String getName() {
    return Common.nonNullOrEmpty(mName);
}
#end_block

#method_before
@Test
public void emptyListOnNullItems() {
    NavigationState state = createSampleState();
    // Setting a list item to null (even though this is not allowed by the API)
    state.mDestinations.set(0, null);
    // Ignoring the serialization step as Parcelable doesn't allow lists with null items. This
    // test is just to make sure that even if the serialization protocol is changed, the API
    // contract is still honored.
    assertEquals(new ArrayList(), state.getDestinations());
}
#method_after
@Test
public void emptyListOnNullItems() {
    NavigationState state = createSampleState();
    // Setting a list item to null (even though this is not allowed by the API)
    state.mDestinations = new ArrayList<>();
    state.mDestinations.add(0, null);
    // Ignoring the serialization step as Parcelable doesn't allow lists with null items. This
    // test is just to make sure that even if the serialization protocol is changed, the API
    // contract is still honored.
    assertEquals(new ArrayList(), state.getDestinations());
}
#end_block

#method_before
public static LayoutLibrary load(String layoutLibJarOsPath, ILogger log, String toolName) {
    LoadStatus status = LoadStatus.LOADING;
    String message = null;
    Bridge bridge = null;
    ILayoutBridge legacyBridge = null;
    ClassLoader classLoader = null;
    try {
        // get the URL for the file.
        File f = new File(layoutLibJarOsPath);
        if (f.isFile() == false) {
            if (log != null) {
                // $NON-NLS-1$
                log.error(null, "layoutlib.jar is missing!");
            }
        } else {
            URL[] url;
            File icu4j = new File(f.getParent().concat("/icu4j.jar"));
            if (icu4j.isFile()) {
                url = new URL[2];
                url[1] = icu4j.toURI().toURL();
            } else {
                url = new URL[1];
            }
            url[0] = f.toURI().toURL();
            // create a class loader. Because this jar reference interfaces
            // that are in the editors plugin, it's important to provide
            // a parent class loader.
            classLoader = new URLClassLoader(url, LayoutLibrary.class.getClassLoader());
            // load the class
            Class<?> clazz = classLoader.loadClass(CLASS_BRIDGE);
            if (clazz != null) {
                // instantiate an object of the class.
                Constructor<?> constructor = clazz.getConstructor();
                if (constructor != null) {
                    Object bridgeObject = constructor.newInstance();
                    if (bridgeObject instanceof Bridge) {
                        bridge = (Bridge) bridgeObject;
                    } else if (bridgeObject instanceof ILayoutBridge) {
                        legacyBridge = (ILayoutBridge) bridgeObject;
                    }
                }
            }
            if (bridge == null && legacyBridge == null) {
                status = LoadStatus.FAILED;
                // $NON-NLS-1$
                message = "Failed to load " + CLASS_BRIDGE;
                if (log != null) {
                    log.error(null, // $NON-NLS-1$
                    "Failed to load " + CLASS_BRIDGE + // $NON-NLS-1$
                    " from " + layoutLibJarOsPath);
                }
            } else {
                // mark the lib as loaded, unless it's overridden below.
                status = LoadStatus.LOADED;
                // check the API, only if it's not a legacy bridge
                if (bridge != null) {
                    int api = bridge.getApiLevel();
                    if (api > Bridge.API_CURRENT) {
                        status = LoadStatus.FAILED;
                        message = String.format("This version of the rendering library is more recent than your version of %1$s. Please update %1$s", toolName);
                    }
                }
            }
        }
    } catch (Throwable t) {
        status = LoadStatus.FAILED;
        Throwable cause = t;
        while (cause.getCause() != null) {
            cause = cause.getCause();
        }
        message = "Failed to load the LayoutLib: " + cause.getMessage();
        // log the error.
        if (log != null) {
            log.error(t, message);
        }
    }
    return new LayoutLibrary(bridge, legacyBridge, classLoader, status, message);
}
#method_after
public static LayoutLibrary load(String layoutLibJarOsPath, ILogger log, String toolName) {
    LoadStatus status = LoadStatus.LOADING;
    String message = null;
    Bridge bridge = null;
    ILayoutBridge legacyBridge = null;
    ClassLoader classLoader = null;
    try {
        // get the URL for the file.
        File f = new File(layoutLibJarOsPath);
        if (f.isFile() == false) {
            if (log != null) {
                // $NON-NLS-1$
                log.error(null, "layoutlib.jar is missing!");
            }
        } else {
            URL[] urls;
            // TODO: The icu jar has to be in the same location as layoutlib.jar. Get rid of
            // this dependency.
            File icu4j = new File(f.getParent(), FN_ICU_JAR);
            if (icu4j.isFile()) {
                urls = new URL[2];
                urls[1] = icu4j.toURI().toURL();
            } else {
                urls = new URL[1];
            }
            urls[0] = f.toURI().toURL();
            // create a class loader. Because this jar reference interfaces
            // that are in the editors plugin, it's important to provide
            // a parent class loader.
            classLoader = new URLClassLoader(urls, LayoutLibrary.class.getClassLoader());
            // load the class
            Class<?> clazz = classLoader.loadClass(CLASS_BRIDGE);
            if (clazz != null) {
                // instantiate an object of the class.
                Constructor<?> constructor = clazz.getConstructor();
                if (constructor != null) {
                    Object bridgeObject = constructor.newInstance();
                    if (bridgeObject instanceof Bridge) {
                        bridge = (Bridge) bridgeObject;
                    } else if (bridgeObject instanceof ILayoutBridge) {
                        legacyBridge = (ILayoutBridge) bridgeObject;
                    }
                }
            }
            if (bridge == null && legacyBridge == null) {
                status = LoadStatus.FAILED;
                // $NON-NLS-1$
                message = "Failed to load " + CLASS_BRIDGE;
                if (log != null) {
                    log.error(null, // $NON-NLS-1$
                    "Failed to load " + CLASS_BRIDGE + // $NON-NLS-1$
                    " from " + layoutLibJarOsPath);
                }
            } else {
                // mark the lib as loaded, unless it's overridden below.
                status = LoadStatus.LOADED;
                // check the API, only if it's not a legacy bridge
                if (bridge != null) {
                    int api = bridge.getApiLevel();
                    if (api > Bridge.API_CURRENT) {
                        status = LoadStatus.FAILED;
                        message = String.format("This version of the rendering library is more recent than your version of %1$s. Please update %1$s", toolName);
                    }
                }
            }
        }
    } catch (Throwable t) {
        status = LoadStatus.FAILED;
        Throwable cause = t;
        while (cause.getCause() != null) {
            cause = cause.getCause();
        }
        message = "Failed to load the LayoutLib: " + cause.getMessage();
        // log the error.
        if (log != null) {
            log.error(t, message);
        }
    }
    return new LayoutLibrary(bridge, legacyBridge, classLoader, status, message);
}
#end_block

#method_before
public List<String> getMenuIdNames() {
    return Collections.EMPTY_LIST;
}
#method_after
public List<String> getMenuIdNames() {
    return Collections.emptyList();
}
#end_block

