476
#method_before
public void bind() {
    if (mService != null) {
        throw new IllegalStateException("Already bound");
    }
    final ConditionVariable cv = new ConditionVariable();
    mServiceConnection = new ServiceConnection() {

        @Override
        public void onServiceConnected(ComponentName name, IBinder service) {
            mService = IMyService.Stub.asInterface(service);
            cv.open();
        }

        @Override
        public void onServiceDisconnected(ComponentName name) {
            mService = null;
        }
    };
    final Intent intent = new Intent();
    intent.setComponent(new ComponentName(APP2_PACKAGE, SERVICE_NAME));
    // Needs to use BIND_ALLOW_OOM_MANAGEMENT and BIND_NOT_FOREGROUND so app2 does not run in
    // the same process state as app
    mContext.bindService(intent, mServiceConnection, Context.BIND_AUTO_CREATE | Context.BIND_NOT_FOREGROUND);
    cv.block(TIMEOUT_MS);
    if (mService == null) {
        throw new IllegalStateException("Could not bind to MyService service after " + TIMEOUT_MS + "ms");
    }
}
#method_after
public void bind() {
    if (mService != null) {
        throw new IllegalStateException("Already bound");
    }
    final ConditionVariable cv = new ConditionVariable();
    mServiceConnection = new ServiceConnection() {

        @Override
        public void onServiceConnected(ComponentName name, IBinder service) {
            mService = IMyService.Stub.asInterface(service);
            cv.open();
        }

        @Override
        public void onServiceDisconnected(ComponentName name) {
            mService = null;
        }
    };
    final Intent intent = new Intent();
    intent.setComponent(new ComponentName(APP2_PACKAGE, SERVICE_NAME));
    // Needs to use BIND_NOT_FOREGROUND so app2 does not run in
    // the same process state as app
    mContext.bindService(intent, mServiceConnection, Context.BIND_AUTO_CREATE | Context.BIND_NOT_FOREGROUND);
    cv.block(TIMEOUT_MS);
    if (mService == null) {
        throw new IllegalStateException("Could not bind to MyService service after " + TIMEOUT_MS + "ms");
    }
}
#end_block

#method_before
@Override
protected void onStart() {
    super.onStart();
    SharedPreferences sharedPreferences = PreferenceManager.getDefaultSharedPreferences(getApplicationContext());
    for (String key : sharedPreferences.getAll().keySet()) {
        if (key.equals("use_affinity")) {
            nSetPreference(key, sharedPreferences.getBoolean(key, true) ? "true" : "false");
            continue;
        } else if (key.equals("hot_pocket")) {
            nSetPreference(key, sharedPreferences.getBoolean(key, false) ? "true" : "false");
            continue;
        } else if (key.equals("use_auto_swap_interval")) {
            nSetAutoSwapInterval(sharedPreferences.getBoolean(key, true));
            continue;
        }
        nSetPreference(key, sharedPreferences.getString(key, null));
    }
    mIsRunning = true;
    nStart();
    Choreographer.getInstance().postFrameCallback(this);
}
#method_after
@Override
protected void onStart() {
    super.onStart();
    SharedPreferences sharedPreferences = PreferenceManager.getDefaultSharedPreferences(getApplicationContext());
    for (String key : sharedPreferences.getAll().keySet()) {
        if (key.equals("use_affinity")) {
            nSetPreference(key, sharedPreferences.getBoolean(key, true) ? "true" : "false");
            continue;
        } else if (key.equals("hot_pocket")) {
            nSetPreference(key, sharedPreferences.getBoolean(key, false) ? "true" : "false");
            continue;
        } else if (key.equals("use_auto_swap_interval")) {
            nSetAutoSwapInterval(sharedPreferences.getBoolean(key, true));
            continue;
        } else if (key.equals("workload")) {
            nSetWorkload(sharedPreferences.getInt(key, 0));
            continue;
        }
        nSetPreference(key, sharedPreferences.getString(key, null));
    }
    mIsRunning = true;
    nStart();
    Choreographer.getInstance().postFrameCallback(this);
}
#end_block

#method_before
@Nullable
public CarMenuItem.OnClickListener getOnClickListener() {
    return mOnClickListener;
}
#method_after
@Nullable
public OnClickListener getOnClickListener() {
    return mOnClickListener;
}
#end_block

#method_before
@NonNull
public Builder setOnClickListener(@NonNull CarMenuItem.OnClickListener listener) {
    mOnClickListener = listener;
    return this;
}
#method_after
@NonNull
public Builder setOnClickListener(@NonNull OnClickListener listener) {
    mOnClickListener = listener;
    return this;
}
#end_block

#method_before
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_car_toolbar);
    CarToolbar carToolbar = findViewById(R.id.car_toolbar);
    carToolbar.setNavigationIconOnClickListener(v -> onSupportNavigateUp());
    Toolbar toolbar = findViewById(R.id.toolbar);
    toolbar.setNavigationOnClickListener(v -> onSupportNavigateUp());
    setSupportActionBar(toolbar);
    List<CarMenuItem> items = new ArrayList<>();
    findViewById(R.id.add_action).setOnClickListener(v -> {
        items.add(new CarMenuItem.Builder().setTitle("Action item").setDisplayBehavior(CarMenuItem.DisplayBehavior.ALWAYS).setStyle(R.style.AlertDialog).build());
        carToolbar.setMenuItems(items);
    });
    findViewById(R.id.add_if_room).setOnClickListener(v -> {
        items.add(new CarMenuItem.Builder().setTitle("If_Room item").setDisplayBehavior(CarMenuItem.DisplayBehavior.IF_ROOM).setStyle(R.style.AlertDialog).build());
        carToolbar.setMenuItems(items);
    });
    findViewById(R.id.add_overflow).setOnClickListener(v -> {
        items.add(new CarMenuItem.Builder().setTitle("Overflow item").setDisplayBehavior(CarMenuItem.DisplayBehavior.NEVER).setStyle(R.style.AlertDialog).build());
        carToolbar.setMenuItems(items);
    });
    findViewById(R.id.clear_menu).setOnClickListener(v -> {
        items.clear();
        carToolbar.setMenuItems(null);
    });
}
#method_after
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_car_toolbar);
    CarToolbar carToolbar = findViewById(R.id.car_toolbar);
    carToolbar.setNavigationIconOnClickListener(v -> onSupportNavigateUp());
    Toolbar toolbar = findViewById(R.id.toolbar);
    toolbar.setNavigationOnClickListener(v -> onSupportNavigateUp());
    setSupportActionBar(toolbar);
    List<CarMenuItem> items = new ArrayList<>();
    findViewById(R.id.add_action).setOnClickListener(v -> {
        items.add(new CarMenuItem.Builder().setTitle("Action item").setDisplayBehavior(CarMenuItem.DisplayBehavior.ALWAYS).setStyle(R.style.Widget_Car_Button_Borderless_Colored).build());
        carToolbar.setMenuItems(items);
    });
    findViewById(R.id.add_if_room).setOnClickListener(v -> {
        items.add(new CarMenuItem.Builder().setTitle("If_Room item").setDisplayBehavior(CarMenuItem.DisplayBehavior.IF_ROOM).setStyle(R.style.Widget_Car_Button_Borderless_Colored).build());
        carToolbar.setMenuItems(items);
    });
    findViewById(R.id.add_overflow).setOnClickListener(v -> {
        items.add(new CarMenuItem.Builder().setTitle("Overflow item").setDisplayBehavior(CarMenuItem.DisplayBehavior.NEVER).setStyle(R.style.Widget_Car_Button_Borderless_Colored).build());
        carToolbar.setMenuItems(items);
    });
    findViewById(R.id.clear_menu).setOnClickListener(v -> {
        items.clear();
        carToolbar.setMenuItems(null);
    });
}
#end_block

#method_before
@Override
protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
    int height = bottom - top;
    int layoutLeft = getPaddingLeft();
    int layoutRight = getPaddingRight();
    if (mNavButtonView.getVisibility() != GONE) {
        // Nav button is centered in container.
        int navButtonWidth = mNavButtonView.getMeasuredWidth();
        int containerWidth = Math.max(mEdgeButtonContainerWidth, navButtonWidth);
        int navButtonLeft = (containerWidth - navButtonWidth) / 2;
        layoutViewFromLeftVerticallyCentered(mNavButtonView, navButtonLeft, height);
        layoutLeft += containerWidth;
    }
    if (mOverflowButtonView.getVisibility() != GONE) {
        int hMargin = (mEdgeButtonContainerWidth - mOverflowButtonView.getMeasuredWidth()) / 2;
        layoutViewFromRightVerticallyCentered(mOverflowButtonView, right - hMargin, height);
        layoutRight += Math.max(mEdgeButtonContainerWidth, mOverflowButtonView.getMeasuredWidth());
    }
    if (mTitleIconView.getVisibility() != GONE) {
        layoutViewFromLeftVerticallyCentered(mTitleIconView, layoutLeft, height);
        layoutLeft += mTitleIconView.getMeasuredWidth();
    }
    if (mTitleTextView.getVisibility() != GONE && mSubtitleTextView.getVisibility() != GONE) {
        layoutTextViewsVerticallyCentered(mTitleTextView, mSubtitleTextView, layoutLeft, height);
    } else if (mTitleTextView.getVisibility() != GONE) {
        layoutViewFromLeftVerticallyCentered(mTitleTextView, layoutLeft, height);
    } else if (mSubtitleTextView.getVisibility() != GONE) {
        layoutViewFromLeftVerticallyCentered(mSubtitleTextView, layoutLeft, height);
    }
}
#method_after
@Override
protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
    int height = bottom - top;
    int layoutLeft = getPaddingLeft();
    int layoutRight = getPaddingRight();
    if (mNavButtonView.getVisibility() != GONE) {
        // Nav button is centered in container.
        int navButtonWidth = mNavButtonView.getMeasuredWidth();
        int containerWidth = Math.max(mEdgeButtonContainerWidth, navButtonWidth);
        int navButtonLeft = (containerWidth - navButtonWidth) / 2;
        layoutViewFromLeftVerticallyCentered(mNavButtonView, navButtonLeft, height);
        layoutLeft += containerWidth;
    }
    if (mOverflowButtonView.getVisibility() != GONE) {
        int horizontalMargin = (mEdgeButtonContainerWidth - mOverflowButtonView.getMeasuredWidth()) / 2;
        layoutViewFromRightVerticallyCentered(mOverflowButtonView, right - horizontalMargin, height);
        layoutRight += Math.max(mEdgeButtonContainerWidth, mOverflowButtonView.getMeasuredWidth());
    }
    if (mTitleIconView.getVisibility() != GONE) {
        layoutViewFromLeftVerticallyCentered(mTitleIconView, layoutLeft, height);
        layoutLeft += mTitleIconView.getMeasuredWidth();
    }
    if (mTitleTextView.getVisibility() != GONE && mSubtitleTextView.getVisibility() != GONE) {
        layoutTextViewsVerticallyCentered(mTitleTextView, mSubtitleTextView, layoutLeft, height);
    } else if (mTitleTextView.getVisibility() != GONE) {
        layoutViewFromLeftVerticallyCentered(mTitleTextView, layoutLeft, height);
    } else if (mSubtitleTextView.getVisibility() != GONE) {
        layoutViewFromLeftVerticallyCentered(mSubtitleTextView, layoutLeft, height);
    }
}
#end_block

#method_before
public void setMenuItems(@Nullable List<CarMenuItem> items) {
    mMenuItems = items;
    setupOverflowMenu();
    requestLayout();
}
#method_after
public void setMenuItems(@Nullable List<CarMenuItem> items) {
    mMenuItems = items;
    setUpOverflowMenu();
    requestLayout();
}
#end_block

#method_before
public com.googlecode.objectify.Key<ProfilingPointRunEntity> saveMultiRow() {
    int maxListSize = 300;
    if (this.getValues().size() > maxListSize) {
        List<List<Long>> partitionedValueList = Lists.partition(this.getValues(), maxListSize);
        int partitionedValueListSize = partitionedValueList.size();
        List<List<String>> partitionedLabelList = new ArrayList<>();
        if (Objects.nonNull(this.getLabels()) && this.getLabels().size() > maxListSize) {
            partitionedLabelList = Lists.partition(this.getLabels(), maxListSize);
        }
        com.googlecode.objectify.Key<ProfilingPointRunEntity> profilingPointRunEntityKey = null;
        if (partitionedValueListSize < maxListSize) {
            for (int index = 0; index < partitionedValueListSize; index++) {
                if (index > 0) {
                    this.values.addAll(partitionedValueList.get(index));
                    if (index < partitionedLabelList.size()) {
                        this.labels.addAll(partitionedLabelList.get(index));
                    }
                } else {
                    this.values = partitionedValueList.get(index);
                    if (index < partitionedLabelList.size()) {
                        this.labels = partitionedLabelList.get(index);
                    }
                }
                profilingPointRunEntityKey = ofy().save().entity(this).now();
            }
        }
        return profilingPointRunEntityKey;
    } else {
        return ofy().save().entity(this).now();
    }
}
#method_after
public com.googlecode.objectify.Key<ProfilingPointRunEntity> saveMultiRow() {
    if (this.getValues().size() > VALUE_SIZE_LIMIT) {
        List<List<Long>> partitionedValueList = Lists.partition(this.getValues(), VALUE_SIZE_LIMIT);
        int partitionedValueListSize = partitionedValueList.size();
        List<List<String>> partitionedLabelList = new ArrayList<>();
        if (Objects.nonNull(this.getLabels()) && this.getLabels().size() > VALUE_SIZE_LIMIT) {
            partitionedLabelList = Lists.partition(this.getLabels(), VALUE_SIZE_LIMIT);
        }
        com.googlecode.objectify.Key<ProfilingPointRunEntity> profilingPointRunEntityKey = null;
        if (partitionedValueListSize < VALUE_SIZE_LIMIT) {
            for (int index = 0; index < partitionedValueListSize; index++) {
                if (index > 0) {
                    this.values.addAll(partitionedValueList.get(index));
                    if (index < partitionedLabelList.size()) {
                        this.labels.addAll(partitionedLabelList.get(index));
                    }
                } else {
                    this.values = partitionedValueList.get(index);
                    if (index < partitionedLabelList.size()) {
                        this.labels = partitionedLabelList.get(index);
                    }
                }
                profilingPointRunEntityKey = ofy().save().entity(this).now();
            }
        }
        return profilingPointRunEntityKey;
    } else {
        return ofy().save().entity(this).now();
    }
}
#end_block

#method_before
public void test_112162449_audio() {
    // According to https://en.wikipedia.org/wiki/M3U#Internet_media_types
    // this is a giant mess, so we pick "audio/x-mpegurl" because a similar
    // playlist format uses "audio/x-scpls".
    assertMimeTypeFromExtension("audio/x-mpegurl", "m3u");
    assertMimeTypeFromExtension("audio/x-mpegurl", "m3u8");
    assertExtensionFromMimeType("m3u", "audio/x-mpegurl");
}
#method_after
public void test_112162449_audio() {
    // According to https://en.wikipedia.org/wiki/M3U#Internet_media_types
    // this is a giant mess, so we pick "audio/x-mpegurl" because a similar
    // playlist format uses "audio/x-scpls".
    assertMimeTypeFromExtension("audio/x-mpegurl", "m3u");
    assertMimeTypeFromExtension("audio/x-mpegurl", "m3u8");
    assertExtensionFromMimeType("m3u", "audio/x-mpegurl");
    assertExtensionFromMimeType("m4a", "audio/mp4");
    assertMimeTypeFromExtension("audio/mpeg", "m4a");
    assertBidirectional("audio/aac", "aac");
}
#end_block

#method_before
private static void parseTypes(String resource) {
    try (BufferedReader r = new BufferedReader(new InputStreamReader(MimeUtils.class.getResourceAsStream(resource)))) {
        String line;
        while ((line = r.readLine()) != null) {
            if (line.startsWith("#"))
                continue;
            final String[] split = splitPattern.split(line);
            final String mimeType = split[0];
            for (int i = 1; i < split.length; i++) {
                String extension = split[i].toLowerCase(Locale.US);
                if (extension.endsWith("!")) {
                    extension = extension.substring(0, extension.length() - 1);
                    // Overriding MIME definition wins
                    mimeTypeToExtensionMap.put(mimeType, extension);
                } else {
                    // First MIME definition wins
                    if (!mimeTypeToExtensionMap.containsKey(mimeType)) {
                        mimeTypeToExtensionMap.put(mimeType, extension);
                    }
                }
                // Last extension definition wins
                extensionToMimeTypeMap.put(extension, mimeType);
            }
        }
    } catch (IOException e) {
        throw new RuntimeException("Failed to parse " + resource, e);
    }
}
#method_after
private static void parseTypes(String resource) {
    try (BufferedReader r = new BufferedReader(new InputStreamReader(MimeUtils.class.getResourceAsStream(resource)))) {
        String line;
        while ((line = r.readLine()) != null) {
            int commentPos = line.indexOf('#');
            if (commentPos >= 0) {
                line = line.substring(0, commentPos);
            }
            line = line.trim();
            if (line.equals("")) {
                continue;
            }
            final String[] split = splitPattern.split(line);
            final String mimeType = split[0];
            for (int i = 1; i < split.length; i++) {
                String extension = split[i].toLowerCase(Locale.US);
                if (extension.endsWith("!")) {
                    extension = extension.substring(0, extension.length() - 1);
                    // Overriding MIME definition wins
                    mimeTypeToExtensionMap.put(mimeType, extension);
                } else {
                    // First MIME definition wins
                    if (!mimeTypeToExtensionMap.containsKey(mimeType)) {
                        mimeTypeToExtensionMap.put(mimeType, extension);
                    }
                }
                // Last extension definition wins
                extensionToMimeTypeMap.put(extension, mimeType);
            }
        }
    } catch (IOException e) {
        throw new RuntimeException("Failed to parse " + resource, e);
    }
}
#end_block

#method_before
@Override
protected void onStart() {
    super.onStart();
    SharedPreferences sharedPreferences = PreferenceManager.getDefaultSharedPreferences(getApplicationContext());
    for (String key : sharedPreferences.getAll().keySet()) {
        if (key.equals("use_affinity")) {
            nSetPreference(key, sharedPreferences.getBoolean(key, true) ? "true" : "false");
            continue;
        } else if (key.equals("hot_pocket")) {
            nSetPreference(key, sharedPreferences.getBoolean(key, false) ? "true" : "false");
            continue;
        } else if (key.equals("use_auto_swap_interval")) {
            nSetAutoSwapInterval(sharedPreferences.getBoolean(key, true));
            continue;
        } else if (key.equals("workload")) {
            nSetWorkload(sharedPreferences.getInt(key, 0));
            continue;
        }
        nSetPreference(key, sharedPreferences.getString(key, null));
    }
    mIsRunning = true;
    nStart();
    Choreographer.getInstance().postFrameCallback(this);
}
#method_after
@Override
protected void onStart() {
    super.onStart();
    SharedPreferences sharedPreferences = PreferenceManager.getDefaultSharedPreferences(getApplicationContext());
    for (String key : sharedPreferences.getAll().keySet()) {
        if (key.equals("use_affinity")) {
            nSetPreference(key, sharedPreferences.getBoolean(key, true) ? "true" : "false");
            continue;
        } else if (key.equals("hot_pocket")) {
            nSetPreference(key, sharedPreferences.getBoolean(key, false) ? "true" : "false");
            continue;
        } else if (key.equals("workload")) {
            nSetWorkload(sharedPreferences.getInt(key, 0));
            continue;
        }
        nSetPreference(key, sharedPreferences.getString(key, null));
    }
    mIsRunning = true;
    nStart();
    Choreographer.getInstance().postFrameCallback(this);
}
#end_block

#method_before
public static void onMainThreadSync(final Runnable runnable) {
    if (Looper.myLooper() == Looper.getMainLooper()) {
        throw new IllegalStateException("This cannot be called from the UI thread.");
    }
    final ResolvableFuture<Void> exceptionCatchingFuture = ResolvableFuture.create();
    onMainThread(new Runnable() {

        @Override
        public void run() {
            try {
                runnable.run();
                exceptionCatchingFuture.set(null);
            } catch (Throwable t) {
                exceptionCatchingFuture.setException(t);
            }
        }
    });
    waitForFuture(exceptionCatchingFuture);
}
#method_after
public static void onMainThreadSync(final Runnable runnable) {
    if (Looper.myLooper() == Looper.getMainLooper()) {
        throw new IllegalStateException("This cannot be called from the UI thread.");
    }
    final ResolvableFuture<Void> exceptionPropagatingFuture = ResolvableFuture.create();
    onMainThread(new Runnable() {

        @Override
        public void run() {
            try {
                runnable.run();
                exceptionPropagatingFuture.set(null);
            } catch (Throwable t) {
                exceptionPropagatingFuture.setException(t);
            }
        }
    });
    waitForFuture(exceptionPropagatingFuture);
}
#end_block

#method_before
public static <T> T waitForFuture(Future<T> future) {
    try {
        return future.get(TEST_TIMEOUT_MS, TimeUnit.MILLISECONDS);
    } catch (ExecutionException | InterruptedException | TimeoutException e) {
        throwAsRuntimeException(e);
        // Not reached.
        return null;
    }
}
#method_after
public static <T> T waitForFuture(Future<T> future) {
    try {
        return future.get(TEST_TIMEOUT_MS, TimeUnit.MILLISECONDS);
    } catch (ExecutionException e) {
        // Try to throw the cause itself, to avoid unnecessarily wrapping an unchecked
        // throwable.
        Throwable cause = e.getCause();
        if (cause instanceof Error)
            throw (Error) cause;
        if (cause instanceof RuntimeException)
            throw (RuntimeException) cause;
        throw new RuntimeException(cause);
    } catch (InterruptedException | TimeoutException e) {
        // Thread was interrupted, not this one.
        throw new RuntimeException(e.getCause());
    }
}
#end_block

#method_before
public static <T> T waitForNextQueueElement(BlockingQueue<T> queue) {
    try {
        T value = queue.poll(TEST_TIMEOUT_MS, TimeUnit.MILLISECONDS);
        if (value == null) {
            // #waitForFuture}.
            throw new TimeoutException("Timeout while trying to take next entry from BlockingQueue");
        }
        return value;
    } catch (TimeoutException | InterruptedException e) {
        throwAsRuntimeException(e);
        // Not reached.
        return null;
    }
}
#method_after
public static <T> T waitForNextQueueElement(BlockingQueue<T> queue) {
    try {
        T value = queue.poll(TEST_TIMEOUT_MS, TimeUnit.MILLISECONDS);
        if (value == null) {
            // #waitForFuture}.
            throw new TimeoutException("Timeout while trying to take next entry from BlockingQueue");
        }
        return value;
    } catch (TimeoutException | InterruptedException e) {
        // Thread was interrupted, not this one.
        throw new RuntimeException(e.getCause());
    }
}
#end_block

#method_before
@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.video_selector);
    mSelectList = (ListView) findViewById(R.id.select_list);
    final Button playButton = (Button) findViewById(R.id.play_button);
    mUrlText = (EditText) findViewById(R.id.video_selection_input);
    mSelectItems = null;
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
        if (checkSelfPermission(Manifest.permission.READ_EXTERNAL_STORAGE) == PackageManager.PERMISSION_GRANTED) {
            setUpInitialItemList();
        } else {
            requestPermissions(new String[] { Manifest.permission.READ_EXTERNAL_STORAGE }, EXTERNAL_STORAGE_PERMISSION_REQUEST_CODE);
        }
    } else {
        setUpInitialItemList();
    }
    playButton.setOnClickListener(new View.OnClickListener() {

        @Override
        public void onClick(View v) {
            Intent launch = createLaunchIntent(VideoSelector.this, mUrlText.getText().toString());
            startActivity(launch);
        }
    });
    mLoopingCheckbox = findViewById(R.id.looping_checkbox);
    mLoopingCheckbox.setChecked(false);
    mTextureViewCheckbox = findViewById(R.id.use_textureview_checkbox);
    mTextureViewCheckbox.setChecked(false);
    mAdvertisementCheckBox = findViewById(R.id.media_type_advertisement);
    mAdvertisementCheckBox.setChecked(false);
}
#method_after
@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    StrictMode.setThreadPolicy(new StrictMode.ThreadPolicy.Builder().detectAll().penaltyDeath().build());
    setContentView(R.layout.video_selector);
    mSelectList = (ListView) findViewById(R.id.select_list);
    final Button playButton = (Button) findViewById(R.id.play_button);
    mUrlText = (EditText) findViewById(R.id.video_selection_input);
    mSelectItems = null;
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
        if (checkSelfPermission(Manifest.permission.READ_EXTERNAL_STORAGE) == PackageManager.PERMISSION_GRANTED) {
            setUpInitialItemList();
        } else {
            requestPermissions(new String[] { Manifest.permission.READ_EXTERNAL_STORAGE }, EXTERNAL_STORAGE_PERMISSION_REQUEST_CODE);
        }
    } else {
        setUpInitialItemList();
    }
    playButton.setOnClickListener(new View.OnClickListener() {

        @Override
        public void onClick(View v) {
            Intent launch = createLaunchIntent(VideoSelector.this, mUrlText.getText().toString());
            startActivity(launch);
        }
    });
    mLoopingCheckbox = findViewById(R.id.looping_checkbox);
    mLoopingCheckbox.setChecked(false);
    mTextureViewCheckbox = findViewById(R.id.use_textureview_checkbox);
    mTextureViewCheckbox.setChecked(false);
    mAdvertisementCheckBox = findViewById(R.id.media_type_advertisement);
    mAdvertisementCheckBox.setChecked(false);
}
#end_block

#method_before
public static int getLastItemPositionOnSameRow(View view, RecyclerView parent) {
    GridLayoutManager layoutManager = ((GridLayoutManager) parent.getLayoutManager());
    GridLayoutManager.SpanSizeLookup spanSizeLookup = layoutManager.getSpanSizeLookup();
    int spanCount = layoutManager.getSpanCount();
    int itemCount = parent.getAdapter().getItemCount();
    int currentChildPosition = parent.getChildAdapterPosition(view);
    int spanSum = getSpanIndex(view) + spanSizeLookup.getSpanSize(currentChildPosition);
    // Iterate to the end of the row starting from the current child position.
    while (currentChildPosition < itemCount && spanSum <= spanCount) {
        int nextSpanSize = spanSizeLookup.getSpanSize(currentChildPosition + 1);
        if (spanSum + nextSpanSize > spanCount) {
            return currentChildPosition;
        }
        currentChildPosition++;
        spanSum += nextSpanSize;
    }
    return itemCount - 1;
}
#method_after
public static int getLastItemPositionOnSameRow(View view, RecyclerView parent) {
    GridLayoutManager layoutManager = ((GridLayoutManager) parent.getLayoutManager());
    GridLayoutManager.SpanSizeLookup spanSizeLookup = layoutManager.getSpanSizeLookup();
    int spanCount = layoutManager.getSpanCount();
    int lastItemPosition = parent.getAdapter().getItemCount() - 1;
    int currentChildPosition = parent.getChildAdapterPosition(view);
    int spanSum = getSpanIndex(view) + spanSizeLookup.getSpanSize(currentChildPosition);
    // Iterate to the end of the row starting from the current child position.
    while (currentChildPosition <= lastItemPosition && spanSum <= spanCount) {
        spanSum += spanSizeLookup.getSpanSize(currentChildPosition + 1);
        if (spanSum > spanCount) {
            return currentChildPosition;
        }
        currentChildPosition++;
    }
    return lastItemPosition;
}
#end_block

#method_before
@Test
public void testIsOnLastRow_oneItem() {
    setUpPagedListView(1);
    // Wait for the UI to lay itself out.
    InstrumentationRegistry.getInstrumentation().waitForIdleSync();
    RecyclerView recyclerView = mPagedListView.getRecyclerView();
    View child = recyclerView.getChildAt(0);
    assertTrue(GridLayoutManagerUtils.isOnLastRow(child, recyclerView));
}
#method_after
@Test
public void testIsOnLastRow_oneItem() {
    setUpPagedListView(1);
    RecyclerView recyclerView = mPagedListView.getRecyclerView();
    View child = recyclerView.getChildAt(0);
    assertTrue(GridLayoutManagerUtils.isOnLastRow(child, recyclerView));
}
#end_block

#method_before
@Test
public void testIsOnLastRow_oneRow() {
    // Initialize the PagedListView with enough items to fill up one row.
    setUpPagedListView(SPAN_COUNT);
    // Wait for the UI to lay itself out.
    InstrumentationRegistry.getInstrumentation().waitForIdleSync();
    RecyclerView recyclerView = mPagedListView.getRecyclerView();
    for (int i = 0; i < mPagedListView.getChildCount(); i++) {
        View child = recyclerView.getChildAt(i);
        assertTrue(GridLayoutManagerUtils.isOnLastRow(child, recyclerView));
    }
}
#method_after
@Test
public void testIsOnLastRow_oneRow() {
    // Initialize the PagedListView with enough items to fill up one row.
    setUpPagedListView(SPAN_COUNT);
    RecyclerView recyclerView = mPagedListView.getRecyclerView();
    for (int i = 0; i < mPagedListView.getChildCount(); i++) {
        View child = recyclerView.getChildAt(i);
        assertTrue(GridLayoutManagerUtils.isOnLastRow(child, recyclerView));
    }
}
#end_block

#method_before
@Test
public void testIsOnLastRow_lastRowNotOnScreen() {
    // Initialize the PagedListView with enough items so the last row is pushed off screen.
    setUpPagedListView(ITEMS_PER_PAGE * 20);
    // Wait for the UI to lay itself out.
    InstrumentationRegistry.getInstrumentation().waitForIdleSync();
    RecyclerView recyclerView = mPagedListView.getRecyclerView();
    // All visible children should not register to be on the last row.
    for (int i = 0; i < mPagedListView.getChildCount(); i++) {
        View child = recyclerView.getChildAt(i);
        assertFalse(GridLayoutManagerUtils.isOnLastRow(child, recyclerView));
    }
}
#method_after
@Test
public void testIsOnLastRow_lastRowNotOnScreen() {
    // Initialize the PagedListView with enough items so the last row is pushed off screen.
    setUpPagedListView(ITEMS_PER_PAGE * 20);
    RecyclerView recyclerView = mPagedListView.getRecyclerView();
    // All visible children should not register to be on the last row.
    for (int i = 0; i < mPagedListView.getChildCount(); i++) {
        View child = recyclerView.getChildAt(i);
        assertFalse(GridLayoutManagerUtils.isOnLastRow(child, recyclerView));
    }
}
#end_block

#method_before
@Test
public void testGetFirstRowItemCount_singleItem() {
    int itemCount = 1;
    setUpPagedListView(itemCount);
    RecyclerView recyclerView = mPagedListView.getRecyclerView();
    // Wait for the UI to lay itself out.
    InstrumentationRegistry.getInstrumentation().waitForIdleSync();
    assertEquals(itemCount, GridLayoutManagerUtils.getFirstRowItemCount(recyclerView));
}
#method_after
@Test
public void testGetFirstRowItemCount_singleItem() {
    int itemCount = 1;
    setUpPagedListView(itemCount);
    RecyclerView recyclerView = mPagedListView.getRecyclerView();
    assertEquals(itemCount, GridLayoutManagerUtils.getFirstRowItemCount(recyclerView));
}
#end_block

#method_before
@Test
public void testGetFirstRowItemCount_singleItemFullSpan() throws Throwable {
    int itemCount = 1;
    setUpPagedListView(itemCount);
    RecyclerView recyclerView = mPagedListView.getRecyclerView();
    mActivityRule.runOnUiThread(() -> {
        ((GridLayoutManager) recyclerView.getLayoutManager()).setSpanSizeLookup(new GridLayoutManager.SpanSizeLookup() {

            @Override
            public int getSpanSize(int position) {
                return SPAN_COUNT;
            }
        });
    });
    // Wait for the UI to lay itself out.
    InstrumentationRegistry.getInstrumentation().waitForIdleSync();
    assertEquals(itemCount, GridLayoutManagerUtils.getFirstRowItemCount(recyclerView));
}
#method_after
@Test
public void testGetFirstRowItemCount_singleItemFullSpan() throws Throwable {
    int itemCount = 1;
    setUpPagedListView(itemCount, new GridLayoutManager.SpanSizeLookup() {

        @Override
        public int getSpanSize(int position) {
            return SPAN_COUNT;
        }
    });
    RecyclerView recyclerView = mPagedListView.getRecyclerView();
    assertEquals(itemCount, GridLayoutManagerUtils.getFirstRowItemCount(recyclerView));
}
#end_block

#method_before
@Test
public void testGetFirstRowItemCount_nonFullFirstRow() {
    int itemCount = SPAN_COUNT - 1;
    setUpPagedListView(itemCount);
    RecyclerView recyclerView = mPagedListView.getRecyclerView();
    // Wait for the UI to lay itself out.
    InstrumentationRegistry.getInstrumentation().waitForIdleSync();
    assertEquals(itemCount, GridLayoutManagerUtils.getFirstRowItemCount(recyclerView));
}
#method_after
@Test
public void testGetFirstRowItemCount_nonFullFirstRow() {
    int itemCount = SPAN_COUNT - 1;
    setUpPagedListView(itemCount);
    RecyclerView recyclerView = mPagedListView.getRecyclerView();
    assertEquals(itemCount, GridLayoutManagerUtils.getFirstRowItemCount(recyclerView));
}
#end_block

#method_before
@Test
public void testGetFirstRowItemCount_fullRow() {
    int itemCount = SPAN_COUNT + 1;
    setUpPagedListView(itemCount);
    RecyclerView recyclerView = mPagedListView.getRecyclerView();
    // Wait for the UI to lay itself out.
    InstrumentationRegistry.getInstrumentation().waitForIdleSync();
    assertEquals(SPAN_COUNT, GridLayoutManagerUtils.getFirstRowItemCount(recyclerView));
}
#method_after
@Test
public void testGetFirstRowItemCount_fullRow() {
    int itemCount = SPAN_COUNT + 1;
    setUpPagedListView(itemCount);
    RecyclerView recyclerView = mPagedListView.getRecyclerView();
    assertEquals(SPAN_COUNT, GridLayoutManagerUtils.getFirstRowItemCount(recyclerView));
}
#end_block

#method_before
@Test
public void testGetFirstRowItemCount_ItemsOfMultiSpan() throws Throwable {
    int itemCount = SPAN_COUNT * 20;
    setUpPagedListView(itemCount);
    RecyclerView recyclerView = mPagedListView.getRecyclerView();
    mActivityRule.runOnUiThread(() -> {
        ((GridLayoutManager) recyclerView.getLayoutManager()).setSpanSizeLookup(new GridLayoutManager.SpanSizeLookup() {

            @Override
            public int getSpanSize(int position) {
                return position % 2 + 1;
            }
        });
    });
    // Wait for the UI to lay itself out.
    InstrumentationRegistry.getInstrumentation().waitForIdleSync();
    // Every 2 items take up 3 span. If there's extra span it can fit one more item.
    int expected = (SPAN_COUNT / 3) * 2 + (SPAN_COUNT % 3 > 0 ? 1 : 0);
    assertEquals(expected, GridLayoutManagerUtils.getFirstRowItemCount(recyclerView));
}
#method_after
@Test
public void testGetFirstRowItemCount_ItemsOfMultiSpan() throws Throwable {
    int itemCount = SPAN_COUNT * 20;
    setUpPagedListView(itemCount, new AlternatingSpanSizeLookup());
    RecyclerView recyclerView = mPagedListView.getRecyclerView();
    assertEquals(AlternatingSpanSizeLookup.ITEMS_PER_ROW, GridLayoutManagerUtils.getFirstRowItemCount(recyclerView));
}
#end_block

#method_before
@Test
public void testGetLastItemPositionOnSameRow_singleItem() {
    int itemCount = 1;
    setUpPagedListView(itemCount);
    // Wait for the UI to lay itself out.
    InstrumentationRegistry.getInstrumentation().waitForIdleSync();
    RecyclerView recyclerView = mPagedListView.getRecyclerView();
    View first = recyclerView.getLayoutManager().findViewByPosition(0);
    assertEquals(0, GridLayoutManagerUtils.getLastItemPositionOnSameRow(first, recyclerView));
}
#method_after
@Test
public void testGetLastItemPositionOnSameRow_singleItem() {
    int itemCount = 1;
    setUpPagedListView(itemCount);
    RecyclerView recyclerView = mPagedListView.getRecyclerView();
    View first = recyclerView.getLayoutManager().findViewByPosition(0);
    assertEquals(0, GridLayoutManagerUtils.getLastItemPositionOnSameRow(first, recyclerView));
}
#end_block

#method_before
@Test
public void testGetLastItemPositionOnSameRow() {
    // Ensure there are at least 2 rows of items.
    int itemCount = SPAN_COUNT * 2;
    setUpPagedListView(itemCount);
    // Wait for the UI to lay itself out.
    InstrumentationRegistry.getInstrumentation().waitForIdleSync();
    RecyclerView recyclerView = mPagedListView.getRecyclerView();
    int lastPosition = SPAN_COUNT - 1;
    for (int i = 0; i < SPAN_COUNT; i++) {
        View current = recyclerView.getLayoutManager().findViewByPosition(i);
        assertEquals(lastPosition, GridLayoutManagerUtils.getLastItemPositionOnSameRow(current, recyclerView));
    }
}
#method_after
@Test
public void testGetLastItemPositionOnSameRow() {
    // Ensure there are at least 2 rows of items.
    int itemCount = SPAN_COUNT * 2;
    setUpPagedListView(itemCount);
    RecyclerView recyclerView = mPagedListView.getRecyclerView();
    int lastPosition = SPAN_COUNT - 1;
    for (int i = 0; i < SPAN_COUNT; i++) {
        View current = recyclerView.getLayoutManager().findViewByPosition(i);
        assertEquals(lastPosition, GridLayoutManagerUtils.getLastItemPositionOnSameRow(current, recyclerView));
    }
}
#end_block

#method_before
@Test
public void testGetLastItemPositionOnSameRow_LastRowNotFull() {
    int lastRowFirstItem = SPAN_COUNT * 20;
    int lastRowLastItem = lastRowFirstItem + SPAN_COUNT - 1;
    int itemCount = lastRowLastItem + 1;
    setUpPagedListView(itemCount);
    // Wait for the UI to lay itself out.
    InstrumentationRegistry.getInstrumentation().waitForIdleSync();
    onView(withId(R.id.recycler_view)).perform(scrollToPosition(lastRowLastItem));
    RecyclerView recyclerView = mPagedListView.getRecyclerView();
    for (int i = lastRowFirstItem; i < itemCount; i++) {
        View current = recyclerView.getLayoutManager().findViewByPosition(i);
        assertEquals(lastRowLastItem, GridLayoutManagerUtils.getLastItemPositionOnSameRow(current, recyclerView));
    }
}
#method_after
@Test
public void testGetLastItemPositionOnSameRow_LastRowNotFull() {
    int lastRowFirstItem = SPAN_COUNT * 20;
    int lastRowLastItem = lastRowFirstItem + SPAN_COUNT - 1;
    int itemCount = lastRowLastItem + 1;
    setUpPagedListView(itemCount);
    onView(withId(R.id.recycler_view)).perform(scrollToPosition(lastRowLastItem));
    RecyclerView recyclerView = mPagedListView.getRecyclerView();
    for (int i = lastRowFirstItem; i < itemCount; i++) {
        View current = recyclerView.getLayoutManager().findViewByPosition(i);
        assertEquals(lastRowLastItem, GridLayoutManagerUtils.getLastItemPositionOnSameRow(current, recyclerView));
    }
}
#end_block

#method_before
@Test
public void testGetLastItemPositionOnSameRow_ItemsOfMultiSpan() throws Throwable {
    int itemCount = SPAN_COUNT * 20;
    setUpPagedListView(itemCount);
    RecyclerView recyclerView = mPagedListView.getRecyclerView();
    mActivityRule.runOnUiThread(() -> {
        ((GridLayoutManager) recyclerView.getLayoutManager()).setSpanSizeLookup(new GridLayoutManager.SpanSizeLookup() {

            @Override
            public int getSpanSize(int position) {
                return position % 2 + 1;
            }
        });
    });
    // Wait for the UI to lay itself out.
    InstrumentationRegistry.getInstrumentation().waitForIdleSync();
    // Every 2 items take up 3 span. If there's extra span it can fit one more item.
    int rowItemCount = (SPAN_COUNT / 3) * 2 + (SPAN_COUNT % 3 > 0 ? 1 : 0);
    for (int i = 0; i < rowItemCount; i++) {
        View current = recyclerView.getLayoutManager().findViewByPosition(i);
        assertEquals(rowItemCount - 1, GridLayoutManagerUtils.getLastItemPositionOnSameRow(current, recyclerView));
    }
}
#method_after
@Test
public void testGetLastItemPositionOnSameRow_ItemsOfMultiSpan() throws Throwable {
    int itemCount = SPAN_COUNT * 20;
    setUpPagedListView(itemCount, new AlternatingSpanSizeLookup());
    RecyclerView recyclerView = mPagedListView.getRecyclerView();
    int rowItemCount = AlternatingSpanSizeLookup.ITEMS_PER_ROW;
    for (int i = 0; i < rowItemCount; i++) {
        View current = recyclerView.getLayoutManager().findViewByPosition(i);
        assertEquals(rowItemCount - 1, GridLayoutManagerUtils.getLastItemPositionOnSameRow(current, recyclerView));
    }
}
#end_block

#method_before
@Test
public void testGetLastItemPositionOnSameRow_fullRow() {
    int itemCount = 1;
    setUpPagedListView(itemCount);
    // Wait for the UI to lay itself out.
    InstrumentationRegistry.getInstrumentation().waitForIdleSync();
    RecyclerView recyclerView = mPagedListView.getRecyclerView();
    View first = recyclerView.getLayoutManager().findViewByPosition(0);
    assertEquals(0, GridLayoutManagerUtils.getLastItemPositionOnSameRow(first, recyclerView));
}
#method_after
@Test
public void testGetLastItemPositionOnSameRow_fullRow() {
    int itemCount = 1;
    setUpPagedListView(itemCount);
    RecyclerView recyclerView = mPagedListView.getRecyclerView();
    View first = recyclerView.getLayoutManager().findViewByPosition(0);
    assertEquals(0, GridLayoutManagerUtils.getLastItemPositionOnSameRow(first, recyclerView));
}
#end_block

#method_before
private void setUpPagedListView(int itemCount) {
    try {
        mActivityRule.runOnUiThread(() -> {
            mPagedListView.getRecyclerView().setLayoutManager(mGridLayoutManager);
            mPagedListView.setMaxPages(PagedListView.ItemCap.UNLIMITED);
            mPagedListView.setAdapter(new TestAdapter(itemCount, mPagedListView.getMeasuredHeight()));
        });
    } catch (Throwable throwable) {
        throwable.printStackTrace();
        throw new RuntimeException(throwable);
    }
}
#method_after
private void setUpPagedListView(int itemCount) {
    setUpPagedListView(itemCount, new GridLayoutManager.DefaultSpanSizeLookup());
}
#end_block

#method_before
private void setUpPagedListView(int itemCount) {
    try {
        mActivityRule.runOnUiThread(() -> {
            mPagedListView.getRecyclerView().setLayoutManager(mGridLayoutManager);
            mPagedListView.setMaxPages(PagedListView.ItemCap.UNLIMITED);
            mPagedListView.setAdapter(new TestAdapter(itemCount, mPagedListView.getMeasuredHeight()));
        });
    } catch (Throwable throwable) {
        throwable.printStackTrace();
        throw new RuntimeException(throwable);
    }
}
#method_after
private void setUpPagedListView(int itemCount, GridLayoutManager.SpanSizeLookup spanSizeLookup) {
    try {
        mActivityRule.runOnUiThread(() -> {
            mGridLayoutManager.setSpanSizeLookup(spanSizeLookup);
            mPagedListView.getRecyclerView().setLayoutManager(mGridLayoutManager);
            mPagedListView.setMaxPages(PagedListView.ItemCap.UNLIMITED);
            mPagedListView.setAdapter(new TestAdapter(itemCount, mPagedListView.getMeasuredHeight()));
        });
    } catch (Throwable throwable) {
        throwable.printStackTrace();
        throw new RuntimeException(throwable);
    }
    // Wait for the UI to lay itself out.
    InstrumentationRegistry.getInstrumentation().waitForIdleSync();
}
#end_block

#method_before
private static String readResource(ClassLoader cl, String resourceName) throws Exception {
    InputStream in = cl.getResourceAsStream(resourceName);
    assertNotNull(in);
    byte[] contents = Streams.readFully(in);
    return new String(contents, StandardCharsets.UTF_8);
}
#method_after
private static String readResource(ClassLoader cl, String resourceName) throws Exception {
    InputStream in = cl.getResourceAsStream(resourceName);
    if (in == null) {
        return null;
    }
    byte[] contents = Streams.readFully(in);
    return new String(contents, StandardCharsets.UTF_8);
}
#end_block

#method_before
public void testLookupOrder_getResource() throws Exception {
    ClassLoader delegate = createClassLoader("parent.jar", "child.jar");
    assertEquals("child", readResource(delegate, "resource.txt"));
    delegate = createClassLoader("child.jar", "parent.jar");
    assertEquals("parent", readResource(delegate, "resource.txt"));
}
#method_after
public void testLookupOrder_getResource() throws Exception {
    ClassLoader delegate = createClassLoader("parent.jar", "child.jar");
    assertEquals("child", readResource(delegate, "resource.txt"));
    assertEquals("parent2", readResource(delegate, "resource2.txt"));
    delegate = createClassLoader("child.jar", "parent.jar");
    assertEquals("parent", readResource(delegate, "resource.txt"));
    assertEquals("parent2", readResource(delegate, "resource2.txt"));
}
#end_block

#method_before
public void testLookupOrderNoDelegate_getResources() throws Exception {
    ClassLoader delegate = createClassLoader("parent.jar", "child.jar", false);
    List<String> resources = readResources(delegate, "resource.txt");
    assertEquals(1, resources.size());
    assertEquals("child", resources.get(0));
    delegate = createClassLoader("child.jar", "parent.jar", false);
    resources = readResources(delegate, "resource.txt");
    assertEquals(1, resources.size());
    assertEquals("parent", resources.get(0));
}
#method_after
public void testLookupOrderNoDelegate_getResources() throws Exception {
    ClassLoader delegate = createClassLoader("parent.jar", "child.jar", false);
    List<String> resources = readResources(delegate, "resource.txt");
    assertEquals(1, resources.size());
    assertEquals("child", resources.get(0));
    resources = readResources(delegate, "resource2.txt");
    assertEquals(0, resources.size());
    delegate = createClassLoader("child.jar", "parent.jar", false);
    resources = readResources(delegate, "resource.txt");
    assertEquals(1, resources.size());
    assertEquals("parent", resources.get(0));
    resources = readResources(delegate, "resource2.txt");
    assertEquals(1, resources.size());
    assertEquals("parent2", resources.get(0));
}
#end_block

#method_before
private void subFormat(int patternCharIndex, int count, FieldDelegate delegate, StringBuffer buffer, boolean useDateFormatSymbols) {
    int maxIntCount = Integer.MAX_VALUE;
    String current = null;
    int beginOffset = buffer.length();
    int field = PATTERN_INDEX_TO_CALENDAR_FIELD[patternCharIndex];
    int value;
    if (field == CalendarBuilder.WEEK_YEAR) {
        if (calendar.isWeekDateSupported()) {
            value = calendar.getWeekYear();
        } else {
            // use calendar year 'y' instead
            patternCharIndex = PATTERN_YEAR;
            field = PATTERN_INDEX_TO_CALENDAR_FIELD[patternCharIndex];
            value = calendar.get(field);
        }
    } else if (field == CalendarBuilder.ISO_DAY_OF_WEEK) {
        value = CalendarBuilder.toISODayOfWeek(calendar.get(Calendar.DAY_OF_WEEK));
    } else {
        value = calendar.get(field);
    }
    int style = (count >= 4) ? Calendar.LONG : Calendar.SHORT;
    if (!useDateFormatSymbols && field != CalendarBuilder.ISO_DAY_OF_WEEK) {
        current = calendar.getDisplayName(field, style, locale);
    }
    switch(patternCharIndex) {
        case // 'G'
        PATTERN_ERA:
            if (useDateFormatSymbols) {
                String[] eras = formatData.getEras();
                if (value < eras.length) {
                    current = eras[value];
                }
            }
            if (current == null) {
                current = "";
            }
            break;
        // 'Y'
        case PATTERN_WEEK_YEAR:
        case // 'y'
        PATTERN_YEAR:
            if (calendar instanceof GregorianCalendar) {
                if (count != 2) {
                    zeroPaddingNumber(value, count, maxIntCount, buffer);
                } else {
                    zeroPaddingNumber(value, 2, 2, buffer);
                }
            // clip 1996 to 96
            } else {
                if (current == null) {
                    zeroPaddingNumber(value, style == Calendar.LONG ? 1 : count, maxIntCount, buffer);
                }
            }
            break;
        case // 'M' (context seinsive)
        PATTERN_MONTH:
            // BEGIN Android-changed: formatMonth() method to format using ICU data.
            /*
                String[] months;
                if (count >= 4) {
                    months = formatData.getMonths();
                    current = months[value];
                } else if (count == 3) {
                    months = formatData.getShortMonths();
                    current = months[value];
                }
            } else {
                if (count < 3) {
                    current = null;
                } else if (forceStandaloneForm) {
                    current = calendar.getDisplayName(field, style | 0x8000, locale);
                    if (current == null) {
                        current = calendar.getDisplayName(field, style, locale);
                    }
                }
            }
            if (current == null) {
                zeroPaddingNumber(value+1, count, maxIntCount, buffer);
            }
            */
            current = formatMonth(count, value, maxIntCount, buffer, useDateFormatSymbols, false, /* standalone */
            field, style);
            // END Android-changed: formatMonth() method to format using ICU data.
            break;
        case // 'L'
        PATTERN_MONTH_STANDALONE:
            // BEGIN Android-changed: formatMonth() method to format using ICU data.
            /*
            assert current == null;
            if (locale == null) {
                String[] months;
                if (count >= 4) {
                    months = formatData.getMonths();
                    current = months[value];
                } else if (count == 3) {
                    months = formatData.getShortMonths();
                    current = months[value];
                }
            } else {
                if (count >= 3) {
                    current = calendar.getDisplayName(field, style | 0x8000, locale);
                }
            }
            if (current == null) {
                zeroPaddingNumber(value+1, count, maxIntCount, buffer);
            }
            */
            current = formatMonth(count, value, maxIntCount, buffer, useDateFormatSymbols, true, /* standalone */
            field, style);
            // END Android-changed: formatMonth() method to format using ICU data.
            break;
        case // 'k' 1-based.  eg, 23:59 + 1 hour =>> 24:59
        PATTERN_HOUR_OF_DAY1:
            if (current == null) {
                if (value == 0) {
                    zeroPaddingNumber(calendar.getMaximum(Calendar.HOUR_OF_DAY) + 1, count, maxIntCount, buffer);
                } else {
                    zeroPaddingNumber(value, count, maxIntCount, buffer);
                }
            }
            break;
        case // 'E'
        PATTERN_DAY_OF_WEEK:
            /*
            if (useDateFormatSymbols) {
                String[] weekdays;
                if (count >= 4) {
                    weekdays = formatData.getWeekdays();
                    current = weekdays[value];
                } else { // count < 4, use abbreviated form if exists
                    weekdays = formatData.getShortWeekdays();
                    current = weekdays[value];
                }
            }
            */
            if (current == null) {
                current = formatWeekday(count, value, useDateFormatSymbols, false);
            }
            // END Android-removed: App compat for formatting pattern letter M.
            break;
        // BEGIN Android-added: support for 'c' (standalone day of week).
        case // 'c'
        PATTERN_STANDALONE_DAY_OF_WEEK:
            if (current == null) {
                current = formatWeekday(count, value, useDateFormatSymbols, true);
            }
            break;
        case // 'a'
        PATTERN_AM_PM:
            if (useDateFormatSymbols) {
                String[] ampm = formatData.getAmPmStrings();
                current = ampm[value];
            }
            break;
        // Not currently supported here.
        case PATTERN_DAY_PERIOD:
        case PATTERN_FLEXIBLE_DAY_PERIOD:
            current = "";
            break;
        case // 'h' 1-based.  eg, 11PM + 1 hour =>> 12 AM
        PATTERN_HOUR1:
            if (current == null) {
                if (value == 0) {
                    zeroPaddingNumber(calendar.getLeastMaximum(Calendar.HOUR) + 1, count, maxIntCount, buffer);
                } else {
                    zeroPaddingNumber(value, count, maxIntCount, buffer);
                }
            }
            break;
        case // 'z'
        PATTERN_ZONE_NAME:
            if (current == null) {
                // BEGIN Android-changed: Format time zone name using ICU.
                /*
                if (formatData.locale == null || formatData.isZoneStringsSet) {
                    int zoneIndex =
                        formatData.getZoneIndex(calendar.getTimeZone().getID());
                    if (zoneIndex == -1) {
                        value = calendar.get(Calendar.ZONE_OFFSET) +
                            calendar.get(Calendar.DST_OFFSET);
                        buffer.append(ZoneInfoFile.toCustomID(value));
                    } else {
                        int index = (calendar.get(Calendar.DST_OFFSET) == 0) ? 1: 3;
                        if (count < 4) {
                            // Use the short name
                            index++;
                        }
                        String[][] zoneStrings = formatData.getZoneStringsWrapper();
                        buffer.append(zoneStrings[zoneIndex][index]);
                    }
                } else {
                    TimeZone tz = calendar.getTimeZone();
                    boolean daylight = (calendar.get(Calendar.DST_OFFSET) != 0);
                    int tzstyle = (count < 4 ? TimeZone.SHORT : TimeZone.LONG);
                    buffer.append(tz.getDisplayName(daylight, tzstyle, formatData.locale));
                }
                */
                TimeZone tz = calendar.getTimeZone();
                boolean daylight = (calendar.get(Calendar.DST_OFFSET) != 0);
                String zoneString;
                if (formatData.isZoneStringsSet) {
                    // DateFormatSymbols.setZoneStrings() has be used, use those values instead of
                    // ICU code.
                    int tzstyle = count < 4 ? TimeZone.SHORT : TimeZone.LONG;
                    zoneString = libcore.icu.TimeZoneNames.getDisplayName(formatData.getZoneStringsWrapper(), tz.getID(), daylight, tzstyle);
                } else {
                    TimeZoneNames.NameType nameType;
                    if (count < 4) {
                        nameType = daylight ? TimeZoneNames.NameType.SHORT_DAYLIGHT : TimeZoneNames.NameType.SHORT_STANDARD;
                    } else {
                        nameType = daylight ? TimeZoneNames.NameType.LONG_DAYLIGHT : TimeZoneNames.NameType.LONG_STANDARD;
                    }
                    String canonicalID = android.icu.util.TimeZone.getCanonicalID(tz.getID());
                    zoneString = getTimeZoneNames().getDisplayName(canonicalID, nameType, calendar.getTimeInMillis());
                }
                if (zoneString != null) {
                    buffer.append(zoneString);
                } else {
                    int offsetMillis = calendar.get(Calendar.ZONE_OFFSET) + calendar.get(Calendar.DST_OFFSET);
                    buffer.append(TimeZone.createGmtOffsetString(true, true, offsetMillis));
                }
            // END Android-changed: Format time zone name using ICU.
            }
            break;
        case // 'Z' ("-/+hhmm" form)
        PATTERN_ZONE_VALUE:
            // BEGIN Android-changed: Use shared code in TimeZone for zone offset string.
            /*
            value = (calendar.get(Calendar.ZONE_OFFSET) +
                     calendar.get(Calendar.DST_OFFSET)) / 60000;

            int width = 4;
            if (value >= 0) {
                buffer.append('+');
            } else {
                width++;
            }

            int num = (value / 60) * 100 + (value % 60);
            CalendarUtils.sprintf0d(buffer, num, width);
            */
            value = calendar.get(Calendar.ZONE_OFFSET) + calendar.get(Calendar.DST_OFFSET);
            final boolean includeSeparator = (count >= 4);
            final boolean includeGmt = (count == 4);
            buffer.append(TimeZone.createGmtOffsetString(includeGmt, includeSeparator, value));
            break;
        case // 'X'
        PATTERN_ISO_ZONE:
            value = calendar.get(Calendar.ZONE_OFFSET) + calendar.get(Calendar.DST_OFFSET);
            if (value == 0) {
                buffer.append('Z');
                break;
            }
            value /= 60000;
            if (value >= 0) {
                buffer.append('+');
            } else {
                buffer.append('-');
                value = -value;
            }
            CalendarUtils.sprintf0d(buffer, value / 60, 2);
            if (count == 1) {
                break;
            }
            if (count == 3) {
                buffer.append(':');
            }
            CalendarUtils.sprintf0d(buffer, value % 60, 2);
            break;
        // BEGIN Android-added: Better UTS#35 conformity for fractional seconds.
        case // 'S'
        PATTERN_MILLISECOND:
            // in the resulting formatted output.
            if (current == null) {
                value = (int) (((double) value / 1000) * Math.pow(10, count));
                zeroPaddingNumber(value, count, count, buffer);
            }
            break;
        default:
            // case PATTERN_ISO_DAY_OF_WEEK:      // 'u' pseudo field, Monday = 1, ..., Sunday = 7
            if (current == null) {
                zeroPaddingNumber(value, count, maxIntCount, buffer);
            }
            break;
    }
    if (current != null) {
        buffer.append(current);
    }
    int fieldID = PATTERN_INDEX_TO_DATE_FORMAT_FIELD[patternCharIndex];
    Field f = PATTERN_INDEX_TO_DATE_FORMAT_FIELD_ID[patternCharIndex];
    delegate.formatted(fieldID, f, f, beginOffset, buffer.length(), buffer);
}
#method_after
private void subFormat(int patternCharIndex, int count, FieldDelegate delegate, StringBuffer buffer, boolean useDateFormatSymbols) {
    int maxIntCount = Integer.MAX_VALUE;
    String current = null;
    int beginOffset = buffer.length();
    int field = PATTERN_INDEX_TO_CALENDAR_FIELD[patternCharIndex];
    int value;
    if (field == CalendarBuilder.WEEK_YEAR) {
        if (calendar.isWeekDateSupported()) {
            value = calendar.getWeekYear();
        } else {
            // use calendar year 'y' instead
            patternCharIndex = PATTERN_YEAR;
            field = PATTERN_INDEX_TO_CALENDAR_FIELD[patternCharIndex];
            value = calendar.get(field);
        }
    } else if (field == CalendarBuilder.ISO_DAY_OF_WEEK) {
        value = CalendarBuilder.toISODayOfWeek(calendar.get(Calendar.DAY_OF_WEEK));
    } else {
        value = calendar.get(field);
    }
    int style = (count >= 4) ? Calendar.LONG : Calendar.SHORT;
    if (!useDateFormatSymbols && field != CalendarBuilder.ISO_DAY_OF_WEEK) {
        current = calendar.getDisplayName(field, style, locale);
    }
    switch(patternCharIndex) {
        case // 'G'
        PATTERN_ERA:
            if (useDateFormatSymbols) {
                String[] eras = formatData.getEras();
                if (value < eras.length) {
                    current = eras[value];
                }
            }
            if (current == null) {
                current = "";
            }
            break;
        // 'Y'
        case PATTERN_WEEK_YEAR:
        case // 'y'
        PATTERN_YEAR:
            if (calendar instanceof GregorianCalendar) {
                if (count != 2) {
                    zeroPaddingNumber(value, count, maxIntCount, buffer);
                } else {
                    zeroPaddingNumber(value, 2, 2, buffer);
                }
            // clip 1996 to 96
            } else {
                if (current == null) {
                    zeroPaddingNumber(value, style == Calendar.LONG ? 1 : count, maxIntCount, buffer);
                }
            }
            break;
        case // 'M' (context seinsive)
        PATTERN_MONTH:
            // BEGIN Android-changed: formatMonth() method to format using ICU data.
            /*
            if (useDateFormatSymbols) {
                String[] months;
                if (count >= 4) {
                    months = formatData.getMonths();
                    current = months[value];
                } else if (count == 3) {
                    months = formatData.getShortMonths();
                    current = months[value];
                }
            } else {
                if (count < 3) {
                    current = null;
                } else if (forceStandaloneForm) {
                    current = calendar.getDisplayName(field, style | 0x8000, locale);
                    if (current == null) {
                        current = calendar.getDisplayName(field, style, locale);
                    }
                }
            }
            if (current == null) {
                zeroPaddingNumber(value+1, count, maxIntCount, buffer);
            }
            */
            current = formatMonth(count, value, maxIntCount, buffer, useDateFormatSymbols, false, /* standalone */
            field, style);
            // END Android-changed: formatMonth() method to format using ICU data.
            break;
        case // 'L'
        PATTERN_MONTH_STANDALONE:
            // BEGIN Android-changed: formatMonth() method to format using ICU data.
            /*
            assert current == null;
            if (locale == null) {
                String[] months;
                if (count >= 4) {
                    months = formatData.getMonths();
                    current = months[value];
                } else if (count == 3) {
                    months = formatData.getShortMonths();
                    current = months[value];
                }
            } else {
                if (count >= 3) {
                    current = calendar.getDisplayName(field, style | 0x8000, locale);
                }
            }
            if (current == null) {
                zeroPaddingNumber(value+1, count, maxIntCount, buffer);
            }
            */
            current = formatMonth(count, value, maxIntCount, buffer, useDateFormatSymbols, true, /* standalone */
            field, style);
            // END Android-changed: formatMonth() method to format using ICU data.
            break;
        case // 'k' 1-based.  eg, 23:59 + 1 hour =>> 24:59
        PATTERN_HOUR_OF_DAY1:
            if (current == null) {
                if (value == 0) {
                    zeroPaddingNumber(calendar.getMaximum(Calendar.HOUR_OF_DAY) + 1, count, maxIntCount, buffer);
                } else {
                    zeroPaddingNumber(value, count, maxIntCount, buffer);
                }
            }
            break;
        case // 'E'
        PATTERN_DAY_OF_WEEK:
            /*
            if (useDateFormatSymbols) {
                String[] weekdays;
                if (count >= 4) {
                    weekdays = formatData.getWeekdays();
                    current = weekdays[value];
                } else { // count < 4, use abbreviated form if exists
                    weekdays = formatData.getShortWeekdays();
                    current = weekdays[value];
                }
            }
            */
            if (current == null) {
                current = formatWeekday(count, value, useDateFormatSymbols, false);
            }
            // END Android-removed: App compat for formatting pattern letter M.
            break;
        // BEGIN Android-added: support for 'c' (standalone day of week).
        case // 'c'
        PATTERN_STANDALONE_DAY_OF_WEEK:
            if (current == null) {
                current = formatWeekday(count, value, useDateFormatSymbols, true);
            }
            break;
        case // 'a'
        PATTERN_AM_PM:
            if (useDateFormatSymbols) {
                String[] ampm = formatData.getAmPmStrings();
                current = ampm[value];
            }
            break;
        // Not currently supported here.
        case PATTERN_DAY_PERIOD:
        case PATTERN_FLEXIBLE_DAY_PERIOD:
            current = "";
            break;
        case // 'h' 1-based.  eg, 11PM + 1 hour =>> 12 AM
        PATTERN_HOUR1:
            if (current == null) {
                if (value == 0) {
                    zeroPaddingNumber(calendar.getLeastMaximum(Calendar.HOUR) + 1, count, maxIntCount, buffer);
                } else {
                    zeroPaddingNumber(value, count, maxIntCount, buffer);
                }
            }
            break;
        case // 'z'
        PATTERN_ZONE_NAME:
            if (current == null) {
                // BEGIN Android-changed: Format time zone name using ICU.
                /*
                if (formatData.locale == null || formatData.isZoneStringsSet) {
                    int zoneIndex =
                        formatData.getZoneIndex(calendar.getTimeZone().getID());
                    if (zoneIndex == -1) {
                        value = calendar.get(Calendar.ZONE_OFFSET) +
                            calendar.get(Calendar.DST_OFFSET);
                        buffer.append(ZoneInfoFile.toCustomID(value));
                    } else {
                        int index = (calendar.get(Calendar.DST_OFFSET) == 0) ? 1: 3;
                        if (count < 4) {
                            // Use the short name
                            index++;
                        }
                        String[][] zoneStrings = formatData.getZoneStringsWrapper();
                        buffer.append(zoneStrings[zoneIndex][index]);
                    }
                } else {
                    TimeZone tz = calendar.getTimeZone();
                    boolean daylight = (calendar.get(Calendar.DST_OFFSET) != 0);
                    int tzstyle = (count < 4 ? TimeZone.SHORT : TimeZone.LONG);
                    buffer.append(tz.getDisplayName(daylight, tzstyle, formatData.locale));
                }
                */
                TimeZone tz = calendar.getTimeZone();
                boolean daylight = (calendar.get(Calendar.DST_OFFSET) != 0);
                String zoneString;
                if (formatData.isZoneStringsSet) {
                    // DateFormatSymbols.setZoneStrings() has be used, use those values instead of
                    // ICU code.
                    int tzstyle = count < 4 ? TimeZone.SHORT : TimeZone.LONG;
                    zoneString = libcore.icu.TimeZoneNames.getDisplayName(formatData.getZoneStringsWrapper(), tz.getID(), daylight, tzstyle);
                } else {
                    TimeZoneNames.NameType nameType;
                    if (count < 4) {
                        nameType = daylight ? TimeZoneNames.NameType.SHORT_DAYLIGHT : TimeZoneNames.NameType.SHORT_STANDARD;
                    } else {
                        nameType = daylight ? TimeZoneNames.NameType.LONG_DAYLIGHT : TimeZoneNames.NameType.LONG_STANDARD;
                    }
                    String canonicalID = android.icu.util.TimeZone.getCanonicalID(tz.getID());
                    zoneString = getTimeZoneNames().getDisplayName(canonicalID, nameType, calendar.getTimeInMillis());
                }
                if (zoneString != null) {
                    buffer.append(zoneString);
                } else {
                    int offsetMillis = calendar.get(Calendar.ZONE_OFFSET) + calendar.get(Calendar.DST_OFFSET);
                    buffer.append(TimeZone.createGmtOffsetString(true, true, offsetMillis));
                }
            // END Android-changed: Format time zone name using ICU.
            }
            break;
        case // 'Z' ("-/+hhmm" form)
        PATTERN_ZONE_VALUE:
            // BEGIN Android-changed: Use shared code in TimeZone for zone offset string.
            /*
            value = (calendar.get(Calendar.ZONE_OFFSET) +
                     calendar.get(Calendar.DST_OFFSET)) / 60000;

            int width = 4;
            if (value >= 0) {
                buffer.append('+');
            } else {
                width++;
            }

            int num = (value / 60) * 100 + (value % 60);
            CalendarUtils.sprintf0d(buffer, num, width);
            */
            value = calendar.get(Calendar.ZONE_OFFSET) + calendar.get(Calendar.DST_OFFSET);
            final boolean includeSeparator = (count >= 4);
            final boolean includeGmt = (count == 4);
            buffer.append(TimeZone.createGmtOffsetString(includeGmt, includeSeparator, value));
            break;
        case // 'X'
        PATTERN_ISO_ZONE:
            value = calendar.get(Calendar.ZONE_OFFSET) + calendar.get(Calendar.DST_OFFSET);
            if (value == 0) {
                buffer.append('Z');
                break;
            }
            value /= 60000;
            if (value >= 0) {
                buffer.append('+');
            } else {
                buffer.append('-');
                value = -value;
            }
            CalendarUtils.sprintf0d(buffer, value / 60, 2);
            if (count == 1) {
                break;
            }
            if (count == 3) {
                buffer.append(':');
            }
            CalendarUtils.sprintf0d(buffer, value % 60, 2);
            break;
        // BEGIN Android-added: Better UTS#35 conformity for fractional seconds.
        case // 'S'
        PATTERN_MILLISECOND:
            // in the resulting formatted output.
            if (current == null) {
                value = (int) (((double) value / 1000) * Math.pow(10, count));
                zeroPaddingNumber(value, count, count, buffer);
            }
            break;
        default:
            // case PATTERN_ISO_DAY_OF_WEEK:      // 'u' pseudo field, Monday = 1, ..., Sunday = 7
            if (current == null) {
                zeroPaddingNumber(value, count, maxIntCount, buffer);
            }
            break;
    }
    if (current != null) {
        buffer.append(current);
    }
    int fieldID = PATTERN_INDEX_TO_DATE_FORMAT_FIELD[patternCharIndex];
    Field f = PATTERN_INDEX_TO_DATE_FORMAT_FIELD_ID[patternCharIndex];
    delegate.formatted(fieldID, f, f, beginOffset, buffer.length(), buffer);
}
#end_block

#method_before
private String formatMonth(int count, int value, int maxIntCount, StringBuffer buffer, boolean useDateFormatSymbols, boolean standalone, int field, int style) {
    String current = null;
    if (useDateFormatSymbols) {
        final String[] months;
        if (count == 4) {
            months = standalone ? formatData.getStandAloneMonths() : formatData.getMonths();
        } else if (count == 5) {
            months = standalone ? formatData.getTinyStandAloneMonths() : formatData.getTinyMonths();
        } else if (count == 3) {
            months = standalone ? formatData.getShortStandAloneMonths() : formatData.getShortMonths();
        } else {
            months = null;
        }
        if (months != null) {
            current = months[value];
        }
    } else {
        if (count < 3) {
            current = null;
        } else {
            if (standalone) {
                // Calendar.STANDALONE_MASK
                style |= 0x8000;
            }
            current = calendar.getDisplayName(field, style, locale);
        }
    }
    if (current == null) {
        zeroPaddingNumber(value + 1, count, maxIntCount, buffer);
    }
    return current;
}
#method_after
private String formatMonth(int count, int value, int maxIntCount, StringBuffer buffer, boolean useDateFormatSymbols, boolean standalone, int field, int style) {
    String current = null;
    if (useDateFormatSymbols) {
        final String[] months;
        if (count == 4) {
            months = standalone ? formatData.getStandAloneMonths() : formatData.getMonths();
        } else if (count == 5) {
            months = standalone ? formatData.getTinyStandAloneMonths() : formatData.getTinyMonths();
        } else if (count == 3) {
            months = standalone ? formatData.getShortStandAloneMonths() : formatData.getShortMonths();
        } else {
            months = null;
        }
        if (months != null) {
            current = months[value];
        }
    } else {
        if (count < 3) {
            current = null;
        } else {
            if (standalone) {
                style = Calendar.toStandaloneStyle(style);
            }
            current = calendar.getDisplayName(field, style, locale);
        }
    }
    if (current == null) {
        zeroPaddingNumber(value + 1, count, maxIntCount, buffer);
    }
    return current;
}
#end_block

#method_before
@Override
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    // Desired height should be the height constraint for all child views.
    int desiredHeight = getPaddingTop() + getSuggestedMinimumHeight() + getPaddingBottom();
    int childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(desiredHeight, MeasureSpec.AT_MOST);
    int width = 0;
    // display priority than the title, subtitle, or the titleIcon.
    if (mNavButtonView.getVisibility() != GONE) {
        // Size of nav button is fixed.
        int measureSpec = MeasureSpec.makeMeasureSpec(mNavButtonIconSize, MeasureSpec.EXACTLY);
        mNavButtonView.measure(measureSpec, measureSpec);
        // Nav button width includes its container.
        int navWidth = Math.max(mEdgeButtonContainerWidth, mNavButtonView.getMeasuredWidth());
        width += navWidth + getHorizontalMargins(mNavButtonView);
    }
    if (mOverflowButtonView.getVisibility() != GONE) {
        int measureSpec = MeasureSpec.makeMeasureSpec(mNavButtonIconSize, MeasureSpec.EXACTLY);
        mOverflowButtonView.measure(measureSpec, measureSpec);
        width += Math.max(mEdgeButtonContainerWidth, mOverflowButtonView.getMeasuredWidth());
    }
    if (mTitleIconView.getVisibility() != GONE) {
        int measureSpec = MeasureSpec.makeMeasureSpec(mTitleIconSize, MeasureSpec.EXACTLY);
        mTitleIconView.measure(measureSpec, measureSpec);
        width += mTitleIconView.getMeasuredWidth();
    }
    int titleLength = 0;
    int subtitleLength = 0;
    if (mTitleTextView.getVisibility() != GONE) {
        measureChild(mTitleTextView, widthMeasureSpec, width, childHeightMeasureSpec, 0);
        titleLength = mTitleTextView.getMeasuredWidth() + getHorizontalMargins(mTitleTextView);
    }
    if (mSubtitleTextView.getVisibility() != GONE) {
        measureChild(mSubtitleTextView, widthMeasureSpec, width, childHeightMeasureSpec, 0);
        subtitleLength = mSubtitleTextView.getMeasuredWidth() + getHorizontalMargins(mSubtitleTextView);
    }
    width += Math.max(titleLength, subtitleLength);
    setMeasuredDimension(resolveSize(width, widthMeasureSpec), resolveSize(desiredHeight, heightMeasureSpec));
}
#method_after
@Override
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    // Desired height should be the height constraint for all child views.
    int desiredHeight = getPaddingTop() + getSuggestedMinimumHeight() + getPaddingBottom();
    int childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(desiredHeight, MeasureSpec.AT_MOST);
    int width = 0;
    // display priority than the title, subtitle, or the titleIcon.
    if (mNavButtonView.getVisibility() != GONE) {
        // Size of nav button is fixed.
        int measureSpec = MeasureSpec.makeMeasureSpec(mEdgeButtonIconSize, MeasureSpec.EXACTLY);
        mNavButtonView.measure(measureSpec, measureSpec);
        // Nav button width includes its container.
        int navWidth = Math.max(mEdgeButtonContainerWidth, mNavButtonView.getMeasuredWidth());
        width += navWidth + getHorizontalMargins(mNavButtonView);
    }
    if (mOverflowButtonView.getVisibility() != GONE) {
        int measureSpec = MeasureSpec.makeMeasureSpec(mEdgeButtonIconSize, MeasureSpec.EXACTLY);
        mOverflowButtonView.measure(measureSpec, measureSpec);
        width += Math.max(mEdgeButtonContainerWidth, mOverflowButtonView.getMeasuredWidth()) + getHorizontalMargins(mOverflowButtonView);
    }
    if (mTitleIconView.getVisibility() != GONE) {
        int measureSpec = MeasureSpec.makeMeasureSpec(mTitleIconSize, MeasureSpec.EXACTLY);
        mTitleIconView.measure(measureSpec, measureSpec);
        width += mTitleIconView.getMeasuredWidth();
    }
    int titleLength = 0;
    int subtitleLength = 0;
    if (mTitleTextView.getVisibility() != GONE) {
        measureChild(mTitleTextView, widthMeasureSpec, width, childHeightMeasureSpec, 0);
        titleLength = mTitleTextView.getMeasuredWidth() + getHorizontalMargins(mTitleTextView);
    }
    if (mSubtitleTextView.getVisibility() != GONE) {
        measureChild(mSubtitleTextView, widthMeasureSpec, width, childHeightMeasureSpec, 0);
        subtitleLength = mSubtitleTextView.getMeasuredWidth() + getHorizontalMargins(mSubtitleTextView);
    }
    width += Math.max(titleLength, subtitleLength);
    setMeasuredDimension(resolveSize(width, widthMeasureSpec), resolveSize(desiredHeight, heightMeasureSpec));
}
#end_block

#method_before
@Override
protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
    int height = bottom - top;
    int layoutLeft = getPaddingLeft();
    int layoutRight = getPaddingRight();
    if (mOverflowButtonView.getVisibility() != GONE) {
        int hMargin = (mEdgeButtonContainerWidth - mOverflowButtonView.getMeasuredWidth()) / 2;
        layoutViewVerticallyCentered(mOverflowButtonView, /* rtl= */
        true, right - hMargin, height);
        layoutRight += mEdgeButtonContainerWidth;
    }
    if (mNavButtonView.getVisibility() != GONE) {
        // Nav button is centered in container.
        int navButtonWidth = mNavButtonView.getMeasuredWidth();
        int containerWidth = Math.max(mEdgeButtonContainerWidth, navButtonWidth);
        int navButtonLeft = (containerWidth - navButtonWidth) / 2;
        layoutViewVerticallyCentered(mNavButtonView, /* rtl= */
        false, navButtonLeft, height);
        layoutLeft += containerWidth;
    }
    if (mTitleIconView.getVisibility() != GONE) {
        layoutViewVerticallyCentered(mTitleIconView, /* rtl= */
        false, layoutLeft, height);
        layoutLeft += mTitleIconView.getMeasuredWidth();
    }
    if (mTitleTextView.getVisibility() != GONE && mSubtitleTextView.getVisibility() != GONE) {
        layoutTextViewsVerticallyCentered(mTitleTextView, mSubtitleTextView, layoutLeft, height);
    } else if (mTitleTextView.getVisibility() != GONE) {
        layoutViewVerticallyCentered(mTitleTextView, /* rtl= */
        false, layoutLeft, height);
    } else if (mSubtitleTextView.getVisibility() != GONE) {
        layoutViewVerticallyCentered(mSubtitleTextView, /* rtl= */
        false, layoutLeft, height);
    }
}
#method_after
@Override
protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
    int height = bottom - top;
    int layoutLeft = getPaddingLeft();
    int layoutRight = getPaddingRight();
    if (mNavButtonView.getVisibility() != GONE) {
        // Nav button is centered in container.
        int navButtonWidth = mNavButtonView.getMeasuredWidth();
        int containerWidth = Math.max(mEdgeButtonContainerWidth, navButtonWidth);
        int navButtonLeft = (containerWidth - navButtonWidth) / 2;
        layoutViewFromLeftVerticallyCentered(mNavButtonView, navButtonLeft, height);
        layoutLeft += containerWidth;
    }
    if (mOverflowButtonView.getVisibility() != GONE) {
        int horizontalMargin = (mEdgeButtonContainerWidth - mOverflowButtonView.getMeasuredWidth()) / 2;
        layoutViewFromRightVerticallyCentered(mOverflowButtonView, right - horizontalMargin, height);
        layoutRight += Math.max(mEdgeButtonContainerWidth, mOverflowButtonView.getMeasuredWidth());
    }
    if (mTitleIconView.getVisibility() != GONE) {
        layoutViewFromLeftVerticallyCentered(mTitleIconView, layoutLeft, height);
        layoutLeft += mTitleIconView.getMeasuredWidth();
    }
    if (mTitleTextView.getVisibility() != GONE && mSubtitleTextView.getVisibility() != GONE) {
        layoutTextViewsVerticallyCentered(mTitleTextView, mSubtitleTextView, layoutLeft, height);
    } else if (mTitleTextView.getVisibility() != GONE) {
        layoutViewFromLeftVerticallyCentered(mTitleTextView, layoutLeft, height);
    } else if (mSubtitleTextView.getVisibility() != GONE) {
        layoutViewFromLeftVerticallyCentered(mSubtitleTextView, layoutLeft, height);
    }
}
#end_block

#method_before
public void setOverflowIcon(Icon icon) {
    mOverflowButtonView.setImageDrawable(icon.loadDrawable(getContext()));
}
#method_after
public void setOverflowIcon(@NonNull Icon icon) {
    mOverflowButtonView.setImageDrawable(icon.loadDrawable(getContext()));
}
#end_block

#method_before
public static void setLogger(Logger logger) {
    sLogger = logger;
}
#method_after
public static synchronized void setLogger(Logger logger) {
    sLogger = logger;
}
#end_block

#method_before
@Test
@LargeTest
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.KITKAT)
public void testPlayAudio() throws Exception {
    final int resid = R.raw.testmp3_2;
    final int mp3Duration = 34909;
    final int tolerance = 70;
    final int seekDuration = 100;
    AssetFileDescriptor afd = mResources.openRawResourceFd(resid);
    mPlayer.setMediaItem(new FileMediaItem.Builder(afd.getFileDescriptor(), afd.getStartOffset(), afd.getLength()).build());
    AudioAttributesCompat attributes = new AudioAttributesCompat.Builder().setLegacyStreamType(AudioManager.STREAM_MUSIC).build();
    mPlayer.setAudioAttributes(attributes);
    ListenableFuture<PlayerResult> future = mPlayer.prepare();
    assertEquals(RESULT_CODE_SUCCESS, future.get().getResultCode());
    assertFalse(mPlayer.getPlayerState() == MediaPlayer.PLAYER_STATE_PLAYING);
    future = mPlayer.play();
    assertEquals(RESULT_CODE_SUCCESS, future.get().getResultCode());
    assertTrue(mPlayer.getPlayerState() == MediaPlayer.PLAYER_STATE_PLAYING);
    assertEquals(mp3Duration, mPlayer.getDuration(), tolerance);
    long pos = mPlayer.getCurrentPosition();
    assertTrue(pos >= 0);
    assertTrue(pos < mp3Duration - seekDuration);
    future = mPlayer.seekTo(pos + seekDuration, MediaPlayer2.SEEK_PREVIOUS_SYNC);
    assertEquals(RESULT_CODE_SUCCESS, future.get().getResultCode());
    assertEquals(pos + seekDuration, mPlayer.getCurrentPosition(), tolerance);
    future = mPlayer.pause();
    assertEquals(RESULT_CODE_SUCCESS, future.get().getResultCode());
    assertFalse(mPlayer.getPlayerState() == MediaPlayer.PLAYER_STATE_PLAYING);
    future = mPlayer.play();
    assertEquals(RESULT_CODE_SUCCESS, future.get().getResultCode());
    assertTrue(mPlayer.getPlayerState() == MediaPlayer.PLAYER_STATE_PLAYING);
    // waiting to complete
    while (mPlayer.getPlayerState() == MediaPlayer.PLAYER_STATE_PLAYING) {
        Thread.sleep(SLEEP_TIME);
    }
}
#method_after
@Test
@LargeTest
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.KITKAT)
public void testPlayAudio() throws Exception {
    final int resid = R.raw.testmp3_2;
    final int mp3Duration = 34909;
    final int tolerance = 70;
    final int seekDuration = 100;
    AssetFileDescriptor afd = mResources.openRawResourceFd(resid);
    mPlayer.setMediaItem(new FileMediaItem.Builder(afd.getFileDescriptor(), afd.getStartOffset(), afd.getLength()).build());
    AudioAttributesCompat attributes = new AudioAttributesCompat.Builder().setLegacyStreamType(AudioManager.STREAM_MUSIC).build();
    mPlayer.setAudioAttributes(attributes);
    ListenableFuture<PlayerResult> future = mPlayer.prepare();
    assertEquals(RESULT_SUCCESS, future.get().getResultCode());
    assertFalse(mPlayer.getPlayerState() == MediaPlayer.PLAYER_STATE_PLAYING);
    future = mPlayer.play();
    assertEquals(RESULT_SUCCESS, future.get().getResultCode());
    assertTrue(mPlayer.getPlayerState() == MediaPlayer.PLAYER_STATE_PLAYING);
    assertEquals(mp3Duration, mPlayer.getDuration(), tolerance);
    long pos = mPlayer.getCurrentPosition();
    assertTrue(pos >= 0);
    assertTrue(pos < mp3Duration - seekDuration);
    future = mPlayer.seekTo(pos + seekDuration, MediaPlayer2.SEEK_PREVIOUS_SYNC);
    assertEquals(RESULT_SUCCESS, future.get().getResultCode());
    assertEquals(pos + seekDuration, mPlayer.getCurrentPosition(), tolerance);
    future = mPlayer.pause();
    assertEquals(RESULT_SUCCESS, future.get().getResultCode());
    assertFalse(mPlayer.getPlayerState() == MediaPlayer.PLAYER_STATE_PLAYING);
    future = mPlayer.play();
    assertEquals(RESULT_SUCCESS, future.get().getResultCode());
    assertTrue(mPlayer.getPlayerState() == MediaPlayer.PLAYER_STATE_PLAYING);
    // waiting to complete
    while (mPlayer.getPlayerState() == MediaPlayer.PLAYER_STATE_PLAYING) {
        Thread.sleep(SLEEP_TIME);
    }
}
#end_block

#method_before
@Test
@SmallTest
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.KITKAT)
public void testGetDuration() throws Exception {
    if (!loadResource(R.raw.testvideo)) {
        fail();
    }
    final int expectedDuration = 11047;
    final int tolerance = 70;
    mPlayer.setSurface(mActivity.getSurfaceHolder2().getSurface());
    assertEquals(MediaPlayer.PLAYER_STATE_IDLE, mPlayer.getPlayerState());
    assertEquals(MediaPlayer.UNKNOWN_TIME, mPlayer.getDuration());
    ListenableFuture<PlayerResult> future = mPlayer.prepare();
    assertEquals(RESULT_CODE_SUCCESS, future.get().getResultCode());
    assertEquals(MediaPlayer.PLAYER_STATE_PAUSED, mPlayer.getPlayerState());
    assertEquals(expectedDuration, mPlayer.getDuration(), tolerance);
}
#method_after
@Test
@SmallTest
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.KITKAT)
public void testGetDuration() throws Exception {
    if (!loadResource(R.raw.testvideo)) {
        fail();
    }
    final int expectedDuration = 11047;
    final int tolerance = 70;
    mPlayer.setSurface(mActivity.getSurfaceHolder2().getSurface());
    assertEquals(MediaPlayer.PLAYER_STATE_IDLE, mPlayer.getPlayerState());
    assertEquals(MediaPlayer.UNKNOWN_TIME, mPlayer.getDuration());
    ListenableFuture<PlayerResult> future = mPlayer.prepare();
    assertEquals(RESULT_SUCCESS, future.get().getResultCode());
    assertEquals(MediaPlayer.PLAYER_STATE_PAUSED, mPlayer.getPlayerState());
    assertEquals(expectedDuration, mPlayer.getDuration(), tolerance);
}
#end_block

#method_before
private void selectSubtitleTrack(int index) throws Exception {
    int trackIndex = mSubtitleTrackIndex.get(index);
    ListenableFuture<PlayerResult> future = mPlayer.selectTrack(trackIndex);
    assertEquals(RESULT_CODE_SUCCESS, future.get().getResultCode());
    mSelectedSubtitleIndex = index;
}
#method_after
private void selectSubtitleTrack(int index) throws Exception {
    int trackIndex = mSubtitleTrackIndex.get(index);
    ListenableFuture<PlayerResult> future = mPlayer.selectTrack(trackIndex);
    assertEquals(RESULT_SUCCESS, future.get().getResultCode());
    mSelectedSubtitleIndex = index;
}
#end_block

#method_before
@Test
@LargeTest
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.KITKAT)
public void testDeselectTrackForSubtitleTracks() throws Throwable {
    if (!loadResource(R.raw.testvideo_with_2_subtitle_tracks)) {
        fail();
    }
    mInstrumentation.waitForIdleSync();
    MediaPlayer.PlayerCallback callback = new MediaPlayer.PlayerCallback() {

        @Override
        public void onInfo(MediaPlayer mp, MediaItem dsd, int what, int extra) {
            if (what == MediaPlayer2.MEDIA_INFO_METADATA_UPDATE) {
                mOnInfoCalled.signal();
            }
        }

        @Override
        public void onSubtitleData(MediaPlayer mp, MediaItem dsd, SubtitleData data) {
            if (data != null && data.getData() != null) {
                mOnSubtitleDataCalled.signal();
            }
        }
    };
    mPlayer.registerPlayerCallback(mExecutor, callback);
    mPlayer.setSurface(mActivity.getSurfaceHolder().getSurface());
    mPlayer.prepare();
    mPlayer.play().get();
    assertTrue(mPlayer.getPlayerState() == MediaPlayer.PLAYER_STATE_PLAYING);
    // Closed caption tracks are in-band.
    // So, those tracks will be found after processing a number of frames.
    mOnInfoCalled.waitForSignal(1500);
    mOnInfoCalled.reset();
    mOnInfoCalled.waitForSignal(1500);
    readSubtitleTracks();
    // Run twice to check if repeated selection-deselection on the same track works well.
    for (int i = 0; i < 2; i++) {
        // Waits until at least one subtitle is fired. Timeout is 2.5 seconds.
        selectSubtitleTrack(i);
        mOnSubtitleDataCalled.reset();
        assertTrue(mOnSubtitleDataCalled.waitForSignal(2500));
        // Try deselecting track.
        assertEquals(RESULT_CODE_SUCCESS, deselectSubtitleTrack(i));
        mOnSubtitleDataCalled.reset();
        assertFalse(mOnSubtitleDataCalled.waitForSignal(1500));
    }
    // Deselecting unselected track: expected error status
    assertNotEquals(RESULT_CODE_SUCCESS, deselectSubtitleTrack(0));
    mPlayer.reset();
}
#method_after
@Test
@LargeTest
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.KITKAT)
public void testDeselectTrackForSubtitleTracks() throws Throwable {
    if (!loadResource(R.raw.testvideo_with_2_subtitle_tracks)) {
        fail();
    }
    mInstrumentation.waitForIdleSync();
    MediaPlayer.PlayerCallback callback = new MediaPlayer.PlayerCallback() {

        @Override
        public void onInfo(MediaPlayer mp, MediaItem dsd, int what, int extra) {
            if (what == MediaPlayer2.MEDIA_INFO_METADATA_UPDATE) {
                mOnInfoCalled.signal();
            }
        }

        @Override
        public void onSubtitleData(MediaPlayer mp, MediaItem dsd, SubtitleData data) {
            if (data != null && data.getData() != null) {
                mOnSubtitleDataCalled.signal();
            }
        }
    };
    mPlayer.registerPlayerCallback(mExecutor, callback);
    mPlayer.setSurface(mActivity.getSurfaceHolder().getSurface());
    mPlayer.prepare();
    mPlayer.play().get();
    assertTrue(mPlayer.getPlayerState() == MediaPlayer.PLAYER_STATE_PLAYING);
    // Closed caption tracks are in-band.
    // So, those tracks will be found after processing a number of frames.
    mOnInfoCalled.waitForSignal(1500);
    mOnInfoCalled.reset();
    mOnInfoCalled.waitForSignal(1500);
    readSubtitleTracks();
    // Run twice to check if repeated selection-deselection on the same track works well.
    for (int i = 0; i < 2; i++) {
        // Waits until at least one subtitle is fired. Timeout is 2.5 seconds.
        selectSubtitleTrack(i);
        mOnSubtitleDataCalled.reset();
        assertTrue(mOnSubtitleDataCalled.waitForSignal(2500));
        // Try deselecting track.
        assertEquals(RESULT_SUCCESS, deselectSubtitleTrack(i));
        mOnSubtitleDataCalled.reset();
        assertFalse(mOnSubtitleDataCalled.waitForSignal(1500));
    }
    // Deselecting unselected track: expected error status
    assertNotEquals(RESULT_SUCCESS, deselectSubtitleTrack(0));
    mPlayer.reset();
}
#end_block

#method_before
@Test
@LargeTest
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.KITKAT)
public void testMediaTimeDiscontinuity() throws Exception {
    if (!loadResource(R.raw.bbb_s1_320x240_mp4_h264_mp2_800kbps_30fps_aac_lc_5ch_240kbps_44100hz)) {
        // skip
        return;
    }
    final BlockingDeque<MediaTimestamp> timestamps = new LinkedBlockingDeque<>();
    MediaPlayer.PlayerCallback callback = new MediaPlayer.PlayerCallback() {

        @Override
        public void onMediaTimeDiscontinuity(MediaPlayer mp, MediaItem dsd, MediaTimestamp timestamp) {
            timestamps.add(timestamp);
            mOnMediaTimeDiscontinuityCalled.signal();
        }
    };
    mPlayer.registerPlayerCallback(mExecutor, callback);
    mPlayer.setSurface(mActivity.getSurfaceHolder().getSurface());
    mPlayer.prepare();
    // Timestamp needs to be reported when playback starts.
    mOnMediaTimeDiscontinuityCalled.reset();
    mPlayer.play();
    do {
        assertTrue(mOnMediaTimeDiscontinuityCalled.waitForSignal(1000));
    } while (Math.abs(timestamps.getLast().getMediaClockRate() - 1.0f) > 0.01f);
    // Timestamp needs to be reported when seeking is done.
    mOnMediaTimeDiscontinuityCalled.reset();
    assertEquals(RESULT_CODE_SUCCESS, mPlayer.seekTo(3000).get().getResultCode());
    do {
        assertTrue(mOnMediaTimeDiscontinuityCalled.waitForSignal(1000));
    } while (Math.abs(timestamps.getLast().getMediaClockRate() - 1.0f) > 0.01f);
    // Timestamp needs to be updated when playback rate changes.
    mOnMediaTimeDiscontinuityCalled.reset();
    mPlayer.setPlaybackParams(new PlaybackParams.Builder().setSpeed(0.5f).build());
    mOnMediaTimeDiscontinuityCalled.waitForSignal();
    do {
        assertTrue(mOnMediaTimeDiscontinuityCalled.waitForSignal(1000));
    } while (Math.abs(timestamps.getLast().getMediaClockRate() - 0.5f) > 0.01f);
    // Timestamp needs to be updated when player is paused.
    mOnMediaTimeDiscontinuityCalled.reset();
    mPlayer.pause();
    mOnMediaTimeDiscontinuityCalled.waitForSignal();
    do {
        assertTrue(mOnMediaTimeDiscontinuityCalled.waitForSignal(1000));
    } while (Math.abs(timestamps.getLast().getMediaClockRate() - 0.0f) > 0.01f);
    mPlayer.reset();
}
#method_after
@Test
@LargeTest
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.KITKAT)
public void testMediaTimeDiscontinuity() throws Exception {
    if (!loadResource(R.raw.bbb_s1_320x240_mp4_h264_mp2_800kbps_30fps_aac_lc_5ch_240kbps_44100hz)) {
        // skip
        return;
    }
    final BlockingDeque<MediaTimestamp> timestamps = new LinkedBlockingDeque<>();
    MediaPlayer.PlayerCallback callback = new MediaPlayer.PlayerCallback() {

        @Override
        public void onMediaTimeDiscontinuity(MediaPlayer mp, MediaItem dsd, MediaTimestamp timestamp) {
            timestamps.add(timestamp);
            mOnMediaTimeDiscontinuityCalled.signal();
        }
    };
    mPlayer.registerPlayerCallback(mExecutor, callback);
    mPlayer.setSurface(mActivity.getSurfaceHolder().getSurface());
    mPlayer.prepare();
    // Timestamp needs to be reported when playback starts.
    mOnMediaTimeDiscontinuityCalled.reset();
    mPlayer.play();
    do {
        assertTrue(mOnMediaTimeDiscontinuityCalled.waitForSignal(1000));
    } while (Math.abs(timestamps.getLast().getMediaClockRate() - 1.0f) > 0.01f);
    // Timestamp needs to be reported when seeking is done.
    mOnMediaTimeDiscontinuityCalled.reset();
    assertEquals(RESULT_SUCCESS, mPlayer.seekTo(3000).get().getResultCode());
    do {
        assertTrue(mOnMediaTimeDiscontinuityCalled.waitForSignal(1000));
    } while (Math.abs(timestamps.getLast().getMediaClockRate() - 1.0f) > 0.01f);
    // Timestamp needs to be updated when playback rate changes.
    mOnMediaTimeDiscontinuityCalled.reset();
    mPlayer.setPlaybackParams(new PlaybackParams.Builder().setSpeed(0.5f).build());
    mOnMediaTimeDiscontinuityCalled.waitForSignal();
    do {
        assertTrue(mOnMediaTimeDiscontinuityCalled.waitForSignal(1000));
    } while (Math.abs(timestamps.getLast().getMediaClockRate() - 0.5f) > 0.01f);
    // Timestamp needs to be updated when player is paused.
    mOnMediaTimeDiscontinuityCalled.reset();
    mPlayer.pause();
    mOnMediaTimeDiscontinuityCalled.waitForSignal();
    do {
        assertTrue(mOnMediaTimeDiscontinuityCalled.waitForSignal(1000));
    } while (Math.abs(timestamps.getLast().getMediaClockRate() - 0.0f) > 0.01f);
    mPlayer.reset();
}
#end_block

#method_before
@Test
@LargeTest
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.KITKAT)
public void testMedia2DataSourceIsClosedOnReset() throws Exception {
    TestDataSourceCallback dataSource = new TestDataSourceCallback(new byte[0]);
    assertEquals(RESULT_CODE_SUCCESS, mPlayer.setMediaItem(new CallbackMediaItem.Builder(dataSource).build()).get().getResultCode());
    mPlayer.reset();
    assertTrue(dataSource.isClosed());
}
#method_after
@Test
@LargeTest
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.KITKAT)
public void testMedia2DataSourceIsClosedOnReset() throws Exception {
    TestDataSourceCallback dataSource = new TestDataSourceCallback(new byte[0]);
    assertEquals(RESULT_SUCCESS, mPlayer.setMediaItem(new CallbackMediaItem.Builder(dataSource).build()).get().getResultCode());
    mPlayer.reset();
    assertTrue(dataSource.isClosed());
}
#end_block

#method_before
@Test
@SmallTest
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.KITKAT)
public void testSkipUnnecessarySeek() throws Exception {
    final int resid = R.raw.video_480x360_mp4_h264_1350kbps_30fps_aac_stereo_192kbps_44100hz;
    final TestDataSourceCallback source = TestDataSourceCallback.fromAssetFd(mResources.openRawResourceFd(resid));
    final Monitor readAllowed = new Monitor();
    DataSourceCallback dataSource = new DataSourceCallback() {

        @Override
        public int readAt(long position, byte[] buffer, int offset, int size) throws IOException {
            if (!readAllowed.isSignalled()) {
                try {
                    readAllowed.waitForSignal();
                } catch (InterruptedException e) {
                    fail();
                }
            }
            return source.readAt(position, buffer, offset, size);
        }

        @Override
        public long getSize() throws IOException {
            return source.getSize();
        }

        @Override
        public void close() throws IOException {
            source.close();
        }
    };
    MediaPlayer.PlayerCallback callback = new MediaPlayer.PlayerCallback() {

        @Override
        public void onError(MediaPlayer mp, MediaItem dsd, int what, int extra) {
            mOnErrorCalled.signal();
        }
    };
    mPlayer.registerPlayerCallback(mExecutor, callback);
    mPlayer.setMediaItem(new CallbackMediaItem.Builder(dataSource).build());
    mOnErrorCalled.reset();
    // prepare() will be pending until readAllowed is signaled.
    mPlayer.prepare();
    ListenableFuture<PlayerResult> seekFuture1 = mPlayer.seekTo(3000);
    ListenableFuture<PlayerResult> seekFuture2 = mPlayer.seekTo(2000);
    ListenableFuture<PlayerResult> seekFuture3 = mPlayer.seekTo(1000);
    readAllowed.signal();
    assertEquals(RESULT_CODE_SKIPPED, seekFuture1.get().getResultCode());
    assertEquals(RESULT_CODE_SKIPPED, seekFuture2.get().getResultCode());
    assertEquals(RESULT_CODE_SUCCESS, seekFuture3.get().getResultCode());
    assertFalse(mOnErrorCalled.isSignalled());
}
#method_after
@Test
@SmallTest
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.KITKAT)
public void testSkipUnnecessarySeek() throws Exception {
    final int resid = R.raw.video_480x360_mp4_h264_1350kbps_30fps_aac_stereo_192kbps_44100hz;
    final TestDataSourceCallback source = TestDataSourceCallback.fromAssetFd(mResources.openRawResourceFd(resid));
    final Monitor readAllowed = new Monitor();
    DataSourceCallback dataSource = new DataSourceCallback() {

        @Override
        public int readAt(long position, byte[] buffer, int offset, int size) throws IOException {
            if (!readAllowed.isSignalled()) {
                try {
                    readAllowed.waitForSignal();
                } catch (InterruptedException e) {
                    fail();
                }
            }
            return source.readAt(position, buffer, offset, size);
        }

        @Override
        public long getSize() throws IOException {
            return source.getSize();
        }

        @Override
        public void close() throws IOException {
            source.close();
        }
    };
    MediaPlayer.PlayerCallback callback = new MediaPlayer.PlayerCallback() {

        @Override
        public void onError(MediaPlayer mp, MediaItem dsd, int what, int extra) {
            mOnErrorCalled.signal();
        }
    };
    mPlayer.registerPlayerCallback(mExecutor, callback);
    mPlayer.setMediaItem(new CallbackMediaItem.Builder(dataSource).build());
    mOnErrorCalled.reset();
    // prepare() will be pending until readAllowed is signaled.
    mPlayer.prepare();
    ListenableFuture<PlayerResult> seekFuture1 = mPlayer.seekTo(3000);
    ListenableFuture<PlayerResult> seekFuture2 = mPlayer.seekTo(2000);
    ListenableFuture<PlayerResult> seekFuture3 = mPlayer.seekTo(1000);
    readAllowed.signal();
    assertEquals(RESULT_INFO_SKIPPED, seekFuture1.get().getResultCode());
    assertEquals(RESULT_INFO_SKIPPED, seekFuture2.get().getResultCode());
    assertEquals(RESULT_SUCCESS, seekFuture3.get().getResultCode());
    assertFalse(mOnErrorCalled.isSignalled());
}
#end_block

#method_before
@Test
@SmallTest
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.KITKAT)
public void testSetAndGetShuflleMode() throws Exception {
    final TestUtils.Monitor onShuffleModeChangedMonitor = new TestUtils.Monitor();
    MediaPlayer.PlayerCallback callback = new MediaPlayer.PlayerCallback() {

        @Override
        public void onShuffleModeChanged(SessionPlayer player, int shuffleMode) {
            mPlayerCbArg1 = player;
            mPlayerCbArg2 = new Integer(shuffleMode);
            onShuffleModeChangedMonitor.signal();
        }
    };
    mPlayer.registerPlayerCallback(mExecutor, callback);
    int shuffleMode = mPlayer.getShuffleMode();
    ListenableFuture<PlayerResult> future;
    PlayerResult result;
    if (shuffleMode != SessionPlayer.SHUFFLE_MODE_NONE) {
        onShuffleModeChangedMonitor.reset();
        future = mPlayer.setShuffleMode(SessionPlayer.SHUFFLE_MODE_NONE);
        assertTrue(onShuffleModeChangedMonitor.waitForSignal(WAIT_TIME_MS));
        result = future.get();
        assertEquals(mPlayer, mPlayerCbArg1);
        assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
        assertEquals(SessionPlayer.SHUFFLE_MODE_NONE, ((Integer) mPlayerCbArg2).intValue());
        assertEquals(SessionPlayer.SHUFFLE_MODE_NONE, mPlayer.getShuffleMode());
    }
    onShuffleModeChangedMonitor.reset();
    future = mPlayer.setShuffleMode(SessionPlayer.SHUFFLE_MODE_ALL);
    assertTrue(onShuffleModeChangedMonitor.waitForSignal(WAIT_TIME_MS));
    result = future.get();
    assertEquals(mPlayer, mPlayerCbArg1);
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertEquals(SessionPlayer.SHUFFLE_MODE_ALL, ((Integer) mPlayerCbArg2).intValue());
    assertEquals(SessionPlayer.SHUFFLE_MODE_ALL, mPlayer.getShuffleMode());
    onShuffleModeChangedMonitor.reset();
    future = mPlayer.setShuffleMode(SessionPlayer.SHUFFLE_MODE_GROUP);
    assertTrue(onShuffleModeChangedMonitor.waitForSignal(WAIT_TIME_MS));
    result = future.get();
    assertEquals(mPlayer, mPlayerCbArg1);
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertEquals(SessionPlayer.SHUFFLE_MODE_GROUP, ((Integer) mPlayerCbArg2).intValue());
    assertEquals(SessionPlayer.SHUFFLE_MODE_GROUP, mPlayer.getShuffleMode());
    // INVALID_SHUFFLE_MODE will not change the shuffle mode.
    onShuffleModeChangedMonitor.reset();
    future = mPlayer.setShuffleMode(INVALID_SHUFFLE_MODE);
    assertFalse(onShuffleModeChangedMonitor.waitForSignal(WAIT_TIME_MS));
    result = future.get();
    assertEquals(mPlayer, mPlayerCbArg1);
    assertEquals(RESULT_CODE_BAD_VALUE, result.getResultCode());
    assertEquals(SessionPlayer.SHUFFLE_MODE_GROUP, mPlayer.getShuffleMode());
}
#method_after
@Test
@SmallTest
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.KITKAT)
public void testSetAndGetShuflleMode() throws Exception {
    final TestUtils.Monitor onShuffleModeChangedMonitor = new TestUtils.Monitor();
    MediaPlayer.PlayerCallback callback = new MediaPlayer.PlayerCallback() {

        @Override
        public void onShuffleModeChanged(SessionPlayer player, int shuffleMode) {
            mPlayerCbArg1 = player;
            mPlayerCbArg2 = new Integer(shuffleMode);
            onShuffleModeChangedMonitor.signal();
        }
    };
    mPlayer.registerPlayerCallback(mExecutor, callback);
    int shuffleMode = mPlayer.getShuffleMode();
    ListenableFuture<PlayerResult> future;
    PlayerResult result;
    if (shuffleMode != SessionPlayer.SHUFFLE_MODE_NONE) {
        onShuffleModeChangedMonitor.reset();
        future = mPlayer.setShuffleMode(SessionPlayer.SHUFFLE_MODE_NONE);
        assertTrue(onShuffleModeChangedMonitor.waitForSignal(WAIT_TIME_MS));
        result = future.get();
        assertEquals(mPlayer, mPlayerCbArg1);
        assertEquals(RESULT_SUCCESS, result.getResultCode());
        assertEquals(SessionPlayer.SHUFFLE_MODE_NONE, ((Integer) mPlayerCbArg2).intValue());
        assertEquals(SessionPlayer.SHUFFLE_MODE_NONE, mPlayer.getShuffleMode());
    }
    onShuffleModeChangedMonitor.reset();
    future = mPlayer.setShuffleMode(SessionPlayer.SHUFFLE_MODE_ALL);
    assertTrue(onShuffleModeChangedMonitor.waitForSignal(WAIT_TIME_MS));
    result = future.get();
    assertEquals(mPlayer, mPlayerCbArg1);
    assertEquals(RESULT_SUCCESS, result.getResultCode());
    assertEquals(SessionPlayer.SHUFFLE_MODE_ALL, ((Integer) mPlayerCbArg2).intValue());
    assertEquals(SessionPlayer.SHUFFLE_MODE_ALL, mPlayer.getShuffleMode());
    onShuffleModeChangedMonitor.reset();
    future = mPlayer.setShuffleMode(SessionPlayer.SHUFFLE_MODE_GROUP);
    assertTrue(onShuffleModeChangedMonitor.waitForSignal(WAIT_TIME_MS));
    result = future.get();
    assertEquals(mPlayer, mPlayerCbArg1);
    assertEquals(RESULT_SUCCESS, result.getResultCode());
    assertEquals(SessionPlayer.SHUFFLE_MODE_GROUP, ((Integer) mPlayerCbArg2).intValue());
    assertEquals(SessionPlayer.SHUFFLE_MODE_GROUP, mPlayer.getShuffleMode());
    // INVALID_SHUFFLE_MODE will not change the shuffle mode.
    onShuffleModeChangedMonitor.reset();
    future = mPlayer.setShuffleMode(INVALID_SHUFFLE_MODE);
    assertFalse(onShuffleModeChangedMonitor.waitForSignal(WAIT_TIME_MS));
    result = future.get();
    assertEquals(mPlayer, mPlayerCbArg1);
    assertEquals(RESULT_ERROR_BAD_VALUE, result.getResultCode());
    assertEquals(SessionPlayer.SHUFFLE_MODE_GROUP, mPlayer.getShuffleMode());
}
#end_block

#method_before
@Test
@SmallTest
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.KITKAT)
public void testSetAndGetRepeatMode() throws Exception {
    final TestUtils.Monitor onRepeatModeChangedMonitor = new TestUtils.Monitor();
    MediaPlayer.PlayerCallback callback = new MediaPlayer.PlayerCallback() {

        @Override
        public void onRepeatModeChanged(SessionPlayer player, int repeatMode) {
            mPlayerCbArg1 = player;
            mPlayerCbArg2 = new Integer(repeatMode);
            onRepeatModeChangedMonitor.signal();
        }
    };
    mPlayer.registerPlayerCallback(mExecutor, callback);
    int repeatMode = mPlayer.getRepeatMode();
    ListenableFuture<PlayerResult> future;
    PlayerResult result;
    if (repeatMode != SessionPlayer.REPEAT_MODE_NONE) {
        onRepeatModeChangedMonitor.reset();
        future = mPlayer.setRepeatMode(SessionPlayer.REPEAT_MODE_NONE);
        assertTrue(onRepeatModeChangedMonitor.waitForSignal(WAIT_TIME_MS));
        result = future.get();
        assertEquals(mPlayer, mPlayerCbArg1);
        assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
        assertEquals(SessionPlayer.REPEAT_MODE_NONE, ((Integer) mPlayerCbArg2).intValue());
        assertEquals(SessionPlayer.REPEAT_MODE_NONE, mPlayer.getRepeatMode());
    }
    onRepeatModeChangedMonitor.reset();
    future = mPlayer.setRepeatMode(SessionPlayer.REPEAT_MODE_ALL);
    assertTrue(onRepeatModeChangedMonitor.waitForSignal(WAIT_TIME_MS));
    result = future.get();
    assertEquals(mPlayer, mPlayerCbArg1);
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertEquals(SessionPlayer.REPEAT_MODE_ALL, ((Integer) mPlayerCbArg2).intValue());
    assertEquals(SessionPlayer.REPEAT_MODE_ALL, mPlayer.getRepeatMode());
    onRepeatModeChangedMonitor.reset();
    future = mPlayer.setRepeatMode(SessionPlayer.REPEAT_MODE_GROUP);
    assertTrue(onRepeatModeChangedMonitor.waitForSignal(WAIT_TIME_MS));
    result = future.get();
    assertEquals(mPlayer, mPlayerCbArg1);
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertEquals(SessionPlayer.REPEAT_MODE_GROUP, ((Integer) mPlayerCbArg2).intValue());
    assertEquals(SessionPlayer.REPEAT_MODE_GROUP, mPlayer.getRepeatMode());
    // INVALID_REPEAT_MODE will not change the repeat mode.
    onRepeatModeChangedMonitor.reset();
    future = mPlayer.setRepeatMode(INVALID_REPEAT_MODE);
    assertFalse(onRepeatModeChangedMonitor.waitForSignal(WAIT_TIME_MS));
    result = future.get();
    assertEquals(mPlayer, mPlayerCbArg1);
    assertEquals(RESULT_CODE_BAD_VALUE, result.getResultCode());
    assertEquals(SessionPlayer.REPEAT_MODE_GROUP, mPlayer.getRepeatMode());
}
#method_after
@Test
@SmallTest
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.KITKAT)
public void testSetAndGetRepeatMode() throws Exception {
    final TestUtils.Monitor onRepeatModeChangedMonitor = new TestUtils.Monitor();
    MediaPlayer.PlayerCallback callback = new MediaPlayer.PlayerCallback() {

        @Override
        public void onRepeatModeChanged(SessionPlayer player, int repeatMode) {
            mPlayerCbArg1 = player;
            mPlayerCbArg2 = new Integer(repeatMode);
            onRepeatModeChangedMonitor.signal();
        }
    };
    mPlayer.registerPlayerCallback(mExecutor, callback);
    int repeatMode = mPlayer.getRepeatMode();
    ListenableFuture<PlayerResult> future;
    PlayerResult result;
    if (repeatMode != SessionPlayer.REPEAT_MODE_NONE) {
        onRepeatModeChangedMonitor.reset();
        future = mPlayer.setRepeatMode(SessionPlayer.REPEAT_MODE_NONE);
        assertTrue(onRepeatModeChangedMonitor.waitForSignal(WAIT_TIME_MS));
        result = future.get();
        assertEquals(mPlayer, mPlayerCbArg1);
        assertEquals(RESULT_SUCCESS, result.getResultCode());
        assertEquals(SessionPlayer.REPEAT_MODE_NONE, ((Integer) mPlayerCbArg2).intValue());
        assertEquals(SessionPlayer.REPEAT_MODE_NONE, mPlayer.getRepeatMode());
    }
    onRepeatModeChangedMonitor.reset();
    future = mPlayer.setRepeatMode(SessionPlayer.REPEAT_MODE_ALL);
    assertTrue(onRepeatModeChangedMonitor.waitForSignal(WAIT_TIME_MS));
    result = future.get();
    assertEquals(mPlayer, mPlayerCbArg1);
    assertEquals(RESULT_SUCCESS, result.getResultCode());
    assertEquals(SessionPlayer.REPEAT_MODE_ALL, ((Integer) mPlayerCbArg2).intValue());
    assertEquals(SessionPlayer.REPEAT_MODE_ALL, mPlayer.getRepeatMode());
    onRepeatModeChangedMonitor.reset();
    future = mPlayer.setRepeatMode(SessionPlayer.REPEAT_MODE_GROUP);
    assertTrue(onRepeatModeChangedMonitor.waitForSignal(WAIT_TIME_MS));
    result = future.get();
    assertEquals(mPlayer, mPlayerCbArg1);
    assertEquals(RESULT_SUCCESS, result.getResultCode());
    assertEquals(SessionPlayer.REPEAT_MODE_GROUP, ((Integer) mPlayerCbArg2).intValue());
    assertEquals(SessionPlayer.REPEAT_MODE_GROUP, mPlayer.getRepeatMode());
    // INVALID_REPEAT_MODE will not change the repeat mode.
    onRepeatModeChangedMonitor.reset();
    future = mPlayer.setRepeatMode(INVALID_REPEAT_MODE);
    assertFalse(onRepeatModeChangedMonitor.waitForSignal(WAIT_TIME_MS));
    result = future.get();
    assertEquals(mPlayer, mPlayerCbArg1);
    assertEquals(RESULT_ERROR_BAD_VALUE, result.getResultCode());
    assertEquals(SessionPlayer.REPEAT_MODE_GROUP, mPlayer.getRepeatMode());
}
#end_block

#method_before
@Test
@SmallTest
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.KITKAT)
public void testSetPlaylist() throws Exception {
    List<MediaItem> playlist = createPlaylist(10);
    try {
        mPlayer.setPlaylist(null, null);
        fail();
    } catch (Exception e) {
    // pass-through
    }
    try {
        List<MediaItem> list = new ArrayList<>();
        list.add(null);
        mPlayer.setPlaylist(list, null);
        fail();
    } catch (Exception e) {
    // pass-through
    }
    ListenableFuture<PlayerResult> future = mPlayer.setPlaylist(playlist, null);
    PlayerResult result = future.get();
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertEquals(playlist.size(), mPlayer.getPlaylist().size());
    assertEquals(playlist.get(0), mPlayer.getCurrentMediaItem());
}
#method_after
@Test
@SmallTest
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.KITKAT)
public void testSetPlaylist() throws Exception {
    List<MediaItem> playlist = createPlaylist(10);
    try {
        mPlayer.setPlaylist(null, null);
        fail();
    } catch (Exception e) {
    // pass-through
    }
    try {
        List<MediaItem> list = new ArrayList<>();
        list.add(null);
        mPlayer.setPlaylist(list, null);
        fail();
    } catch (Exception e) {
    // pass-through
    }
    ListenableFuture<PlayerResult> future = mPlayer.setPlaylist(playlist, null);
    PlayerResult result = future.get();
    assertEquals(RESULT_SUCCESS, result.getResultCode());
    assertEquals(playlist.size(), mPlayer.getPlaylist().size());
    assertEquals(playlist.get(0), mPlayer.getCurrentMediaItem());
}
#end_block

#method_before
@Test
@SmallTest
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.KITKAT)
public void testSkipToPlaylistItems() throws Exception {
    int listSize = 5;
    List<MediaItem> playlist = createPlaylist(listSize);
    PlayerResult result = mPlayer.setPlaylist(playlist, null).get();
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    mPlayer.setRepeatMode(SessionPlayer.REPEAT_MODE_NONE).get();
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    // Test skipToPlaylistItem
    for (int i = listSize - 1; i >= 0; --i) {
        result = mPlayer.skipToPlaylistItem(i).get();
        assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
        assertEquals(i, mPlayer.getCurrentMediaItemIndex());
        assertEquals(playlist.get(i), mPlayer.getCurrentMediaItem());
    }
}
#method_after
@Test
@SmallTest
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.KITKAT)
public void testSkipToPlaylistItems() throws Exception {
    int listSize = 5;
    List<MediaItem> playlist = createPlaylist(listSize);
    PlayerResult result = mPlayer.setPlaylist(playlist, null).get();
    assertEquals(RESULT_SUCCESS, result.getResultCode());
    mPlayer.setRepeatMode(SessionPlayer.REPEAT_MODE_NONE).get();
    assertEquals(RESULT_SUCCESS, result.getResultCode());
    // Test skipToPlaylistItem
    for (int i = listSize - 1; i >= 0; --i) {
        result = mPlayer.skipToPlaylistItem(i).get();
        assertEquals(RESULT_SUCCESS, result.getResultCode());
        assertEquals(i, mPlayer.getCurrentMediaItemIndex());
        assertEquals(playlist.get(i), mPlayer.getCurrentMediaItem());
    }
}
#end_block

#method_before
@Test
@SmallTest
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.KITKAT)
public void testSkipToNextItems() throws Exception {
    int listSize = 5;
    List<MediaItem> playlist = createPlaylist(listSize);
    PlayerResult result = mPlayer.setPlaylist(playlist, null).get();
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    mPlayer.setRepeatMode(SessionPlayer.REPEAT_MODE_NONE).get();
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    // curPlayPos = 0
    for (int curPlayPos = 0; curPlayPos < listSize - 1; ++curPlayPos) {
        result = mPlayer.skipToNextPlaylistItem().get();
        assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
        assertEquals(curPlayPos + 1, mPlayer.getCurrentMediaItemIndex());
        assertEquals(playlist.get(curPlayPos + 1), mPlayer.getCurrentMediaItem());
    }
    result = mPlayer.skipToNextPlaylistItem().get();
    assertEquals(RESULT_CODE_INVALID_STATE, result.getResultCode());
    assertEquals(listSize - 1, mPlayer.getCurrentMediaItemIndex());
    assertEquals(playlist.get(listSize - 1), mPlayer.getCurrentMediaItem());
}
#method_after
@Test
@SmallTest
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.KITKAT)
public void testSkipToNextItems() throws Exception {
    int listSize = 5;
    List<MediaItem> playlist = createPlaylist(listSize);
    PlayerResult result = mPlayer.setPlaylist(playlist, null).get();
    assertEquals(RESULT_SUCCESS, result.getResultCode());
    mPlayer.setRepeatMode(SessionPlayer.REPEAT_MODE_NONE).get();
    assertEquals(RESULT_SUCCESS, result.getResultCode());
    // curPlayPos = 0
    for (int curPlayPos = 0; curPlayPos < listSize - 1; ++curPlayPos) {
        result = mPlayer.skipToNextPlaylistItem().get();
        assertEquals(RESULT_SUCCESS, result.getResultCode());
        assertEquals(curPlayPos + 1, mPlayer.getCurrentMediaItemIndex());
        assertEquals(playlist.get(curPlayPos + 1), mPlayer.getCurrentMediaItem());
    }
    result = mPlayer.skipToNextPlaylistItem().get();
    assertEquals(RESULT_ERROR_INVALID_STATE, result.getResultCode());
    assertEquals(listSize - 1, mPlayer.getCurrentMediaItemIndex());
    assertEquals(playlist.get(listSize - 1), mPlayer.getCurrentMediaItem());
}
#end_block

#method_before
@Test
@SmallTest
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.KITKAT)
public void testSkipToPreviousItems() throws Exception {
    int listSize = 5;
    List<MediaItem> playlist = createPlaylist(listSize);
    PlayerResult result = mPlayer.setPlaylist(playlist, null).get();
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    mPlayer.setRepeatMode(SessionPlayer.REPEAT_MODE_NONE).get();
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    result = mPlayer.skipToPlaylistItem(listSize - 1).get();
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    // curPlayPos = listSize - 1
    for (int curPlayPos = listSize - 1; curPlayPos > 0; --curPlayPos) {
        result = mPlayer.skipToPreviousPlaylistItem().get();
        assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
        assertEquals(curPlayPos - 1, mPlayer.getCurrentMediaItemIndex());
        assertEquals(playlist.get(curPlayPos - 1), mPlayer.getCurrentMediaItem());
    }
    result = mPlayer.skipToPreviousPlaylistItem().get();
    assertEquals(RESULT_CODE_INVALID_STATE, result.getResultCode());
    assertEquals(0, mPlayer.getCurrentMediaItemIndex());
    assertEquals(playlist.get(0), mPlayer.getCurrentMediaItem());
}
#method_after
@Test
@SmallTest
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.KITKAT)
public void testSkipToPreviousItems() throws Exception {
    int listSize = 5;
    List<MediaItem> playlist = createPlaylist(listSize);
    PlayerResult result = mPlayer.setPlaylist(playlist, null).get();
    assertEquals(RESULT_SUCCESS, result.getResultCode());
    mPlayer.setRepeatMode(SessionPlayer.REPEAT_MODE_NONE).get();
    assertEquals(RESULT_SUCCESS, result.getResultCode());
    result = mPlayer.skipToPlaylistItem(listSize - 1).get();
    assertEquals(RESULT_SUCCESS, result.getResultCode());
    // curPlayPos = listSize - 1
    for (int curPlayPos = listSize - 1; curPlayPos > 0; --curPlayPos) {
        result = mPlayer.skipToPreviousPlaylistItem().get();
        assertEquals(RESULT_SUCCESS, result.getResultCode());
        assertEquals(curPlayPos - 1, mPlayer.getCurrentMediaItemIndex());
        assertEquals(playlist.get(curPlayPos - 1), mPlayer.getCurrentMediaItem());
    }
    result = mPlayer.skipToPreviousPlaylistItem().get();
    assertEquals(RESULT_ERROR_INVALID_STATE, result.getResultCode());
    assertEquals(0, mPlayer.getCurrentMediaItemIndex());
    assertEquals(playlist.get(0), mPlayer.getCurrentMediaItem());
}
#end_block

#method_before
@Test
@SmallTest
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.KITKAT)
public void testSkipToNextPreviousItemsWithRepeatMode() throws Exception {
    int listSize = 5;
    List<MediaItem> playlist = createPlaylist(listSize);
    PlayerResult result = mPlayer.setPlaylist(playlist, null).get();
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    result = mPlayer.setRepeatMode(SessionPlayer.REPEAT_MODE_ALL).get();
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertEquals(listSize - 1, mPlayer.getPreviousMediaItemIndex());
    result = mPlayer.skipToPreviousPlaylistItem().get();
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertEquals(listSize - 1, mPlayer.getCurrentMediaItemIndex());
    assertEquals(playlist.get(listSize - 1), mPlayer.getCurrentMediaItem());
    assertEquals(0, mPlayer.getNextMediaItemIndex());
    result = mPlayer.skipToNextPlaylistItem().get();
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertEquals(0, mPlayer.getCurrentMediaItemIndex());
    assertEquals(playlist.get(0), mPlayer.getCurrentMediaItem());
}
#method_after
@Test
@SmallTest
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.KITKAT)
public void testSkipToNextPreviousItemsWithRepeatMode() throws Exception {
    int listSize = 5;
    List<MediaItem> playlist = createPlaylist(listSize);
    PlayerResult result = mPlayer.setPlaylist(playlist, null).get();
    assertEquals(RESULT_SUCCESS, result.getResultCode());
    result = mPlayer.setRepeatMode(SessionPlayer.REPEAT_MODE_ALL).get();
    assertEquals(RESULT_SUCCESS, result.getResultCode());
    assertEquals(listSize - 1, mPlayer.getPreviousMediaItemIndex());
    result = mPlayer.skipToPreviousPlaylistItem().get();
    assertEquals(RESULT_SUCCESS, result.getResultCode());
    assertEquals(listSize - 1, mPlayer.getCurrentMediaItemIndex());
    assertEquals(playlist.get(listSize - 1), mPlayer.getCurrentMediaItem());
    assertEquals(0, mPlayer.getNextMediaItemIndex());
    result = mPlayer.skipToNextPlaylistItem().get();
    assertEquals(RESULT_SUCCESS, result.getResultCode());
    assertEquals(0, mPlayer.getCurrentMediaItemIndex());
    assertEquals(playlist.get(0), mPlayer.getCurrentMediaItem());
}
#end_block

#method_before
@Test
@SmallTest
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.KITKAT)
public void testPlaylistAfterSkipToNextItem() throws Exception {
    int listSize = 2;
    List<MediaItem> playlist = createPlaylist(listSize);
    PlayerResult result = mPlayer.setPlaylist(playlist, null).get();
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertEquals(0, mPlayer.getCurrentMediaItemIndex());
    assertEquals(playlist.get(0), mPlayer.getCurrentMediaItem());
    result = mPlayer.skipToNextPlaylistItem().get();
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertEquals(1, mPlayer.getCurrentMediaItemIndex());
    assertEquals(playlist.get(1), mPlayer.getCurrentMediaItem());
    // Will not go to the next if the next is end of the playlist
    result = mPlayer.skipToNextPlaylistItem().get();
    assertEquals(RESULT_CODE_INVALID_STATE, result.getResultCode());
    assertEquals(1, mPlayer.getCurrentMediaItemIndex());
    assertEquals(playlist.get(1), mPlayer.getCurrentMediaItem());
    result = mPlayer.setRepeatMode(SessionPlayer.REPEAT_MODE_ALL).get();
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    result = mPlayer.skipToNextPlaylistItem().get();
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertEquals(0, mPlayer.getCurrentMediaItemIndex());
    assertEquals(playlist.get(0), mPlayer.getCurrentMediaItem());
}
#method_after
@Test
@SmallTest
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.KITKAT)
public void testPlaylistAfterSkipToNextItem() throws Exception {
    int listSize = 2;
    List<MediaItem> playlist = createPlaylist(listSize);
    PlayerResult result = mPlayer.setPlaylist(playlist, null).get();
    assertEquals(RESULT_SUCCESS, result.getResultCode());
    assertEquals(0, mPlayer.getCurrentMediaItemIndex());
    assertEquals(playlist.get(0), mPlayer.getCurrentMediaItem());
    result = mPlayer.skipToNextPlaylistItem().get();
    assertEquals(RESULT_SUCCESS, result.getResultCode());
    assertEquals(1, mPlayer.getCurrentMediaItemIndex());
    assertEquals(playlist.get(1), mPlayer.getCurrentMediaItem());
    // Will not go to the next if the next is end of the playlist
    result = mPlayer.skipToNextPlaylistItem().get();
    assertEquals(RESULT_ERROR_INVALID_STATE, result.getResultCode());
    assertEquals(1, mPlayer.getCurrentMediaItemIndex());
    assertEquals(playlist.get(1), mPlayer.getCurrentMediaItem());
    result = mPlayer.setRepeatMode(SessionPlayer.REPEAT_MODE_ALL).get();
    assertEquals(RESULT_SUCCESS, result.getResultCode());
    result = mPlayer.skipToNextPlaylistItem().get();
    assertEquals(RESULT_SUCCESS, result.getResultCode());
    assertEquals(0, mPlayer.getCurrentMediaItemIndex());
    assertEquals(playlist.get(0), mPlayer.getCurrentMediaItem());
}
#end_block

#method_before
@Test
@SmallTest
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.KITKAT)
public void testPlaylistAfterSkipToPreviousItem() throws Exception {
    int listSize = 2;
    List<MediaItem> playlist = createPlaylist(listSize);
    PlayerResult result = mPlayer.setPlaylist(playlist, null).get();
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertEquals(0, mPlayer.getCurrentMediaItemIndex());
    assertEquals(playlist.get(0), mPlayer.getCurrentMediaItem());
    // Will not go to the previous if the current is the first one
    result = mPlayer.skipToPreviousPlaylistItem().get();
    assertEquals(RESULT_CODE_INVALID_STATE, result.getResultCode());
    assertEquals(0, mPlayer.getCurrentMediaItemIndex());
    assertEquals(playlist.get(0), mPlayer.getCurrentMediaItem());
    result = mPlayer.setRepeatMode(SessionPlayer.REPEAT_MODE_ALL).get();
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    result = mPlayer.skipToPreviousPlaylistItem().get();
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertEquals(1, mPlayer.getCurrentMediaItemIndex());
    assertEquals(playlist.get(1), mPlayer.getCurrentMediaItem());
}
#method_after
@Test
@SmallTest
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.KITKAT)
public void testPlaylistAfterSkipToPreviousItem() throws Exception {
    int listSize = 2;
    List<MediaItem> playlist = createPlaylist(listSize);
    PlayerResult result = mPlayer.setPlaylist(playlist, null).get();
    assertEquals(RESULT_SUCCESS, result.getResultCode());
    assertEquals(0, mPlayer.getCurrentMediaItemIndex());
    assertEquals(playlist.get(0), mPlayer.getCurrentMediaItem());
    // Will not go to the previous if the current is the first one
    result = mPlayer.skipToPreviousPlaylistItem().get();
    assertEquals(RESULT_ERROR_INVALID_STATE, result.getResultCode());
    assertEquals(0, mPlayer.getCurrentMediaItemIndex());
    assertEquals(playlist.get(0), mPlayer.getCurrentMediaItem());
    result = mPlayer.setRepeatMode(SessionPlayer.REPEAT_MODE_ALL).get();
    assertEquals(RESULT_SUCCESS, result.getResultCode());
    result = mPlayer.skipToPreviousPlaylistItem().get();
    assertEquals(RESULT_SUCCESS, result.getResultCode());
    assertEquals(1, mPlayer.getCurrentMediaItemIndex());
    assertEquals(playlist.get(1), mPlayer.getCurrentMediaItem());
}
#end_block

#method_before
@Test
@SmallTest
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.KITKAT)
public void testCurrentMediaItemChangedCalledAfterSetMediaItem() throws Exception {
    final int currentIdx = -1;
    MediaItem item = createMediaItem(100);
    final TestUtils.Monitor onCurrentMediaItemChangedMonitor = new TestUtils.Monitor();
    MediaPlayer.PlayerCallback callback = new MediaPlayer.PlayerCallback() {

        @Override
        public void onCurrentMediaItemChanged(SessionPlayer player, MediaItem item) {
            assertEquals(currentIdx, mPlayer.getCurrentMediaItemIndex());
            onCurrentMediaItemChangedMonitor.signal();
        }
    };
    mPlayer.registerPlayerCallback(mExecutor, callback);
    PlayerResult result = mPlayer.setMediaItem(item).get();
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertTrue(onCurrentMediaItemChangedMonitor.waitForSignal(WAIT_TIME_MS));
}
#method_after
@Test
@SmallTest
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.KITKAT)
public void testCurrentMediaItemChangedCalledAfterSetMediaItem() throws Exception {
    final int currentIdx = -1;
    MediaItem item = createMediaItem(100);
    final TestUtils.Monitor onCurrentMediaItemChangedMonitor = new TestUtils.Monitor();
    MediaPlayer.PlayerCallback callback = new MediaPlayer.PlayerCallback() {

        @Override
        public void onCurrentMediaItemChanged(SessionPlayer player, MediaItem item) {
            assertEquals(currentIdx, mPlayer.getCurrentMediaItemIndex());
            onCurrentMediaItemChangedMonitor.signal();
        }
    };
    mPlayer.registerPlayerCallback(mExecutor, callback);
    PlayerResult result = mPlayer.setMediaItem(item).get();
    assertEquals(RESULT_SUCCESS, result.getResultCode());
    assertTrue(onCurrentMediaItemChangedMonitor.waitForSignal(WAIT_TIME_MS));
}
#end_block

#method_before
@Test
@SmallTest
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.KITKAT)
public void testCurrentMediaItemChangedCalledAfterSetPlayList() throws Exception {
    int listSize = 2;
    final int currentIdx = 0;
    List<MediaItem> playlist = createPlaylist(listSize);
    final TestUtils.Monitor onCurrentMediaItemChangedMonitor = new TestUtils.Monitor();
    MediaPlayer.PlayerCallback callback = new MediaPlayer.PlayerCallback() {

        @Override
        public void onCurrentMediaItemChanged(SessionPlayer player, MediaItem item) {
            assertEquals(currentIdx, mPlayer.getCurrentMediaItemIndex());
            onCurrentMediaItemChangedMonitor.signal();
        }
    };
    mPlayer.registerPlayerCallback(mExecutor, callback);
    PlayerResult result = mPlayer.setPlaylist(playlist, null).get();
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertTrue(onCurrentMediaItemChangedMonitor.waitForSignal(WAIT_TIME_MS));
}
#method_after
@Test
@SmallTest
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.KITKAT)
public void testCurrentMediaItemChangedCalledAfterSetPlayList() throws Exception {
    int listSize = 2;
    final int currentIdx = 0;
    List<MediaItem> playlist = createPlaylist(listSize);
    final TestUtils.Monitor onCurrentMediaItemChangedMonitor = new TestUtils.Monitor();
    MediaPlayer.PlayerCallback callback = new MediaPlayer.PlayerCallback() {

        @Override
        public void onCurrentMediaItemChanged(SessionPlayer player, MediaItem item) {
            assertEquals(currentIdx, mPlayer.getCurrentMediaItemIndex());
            onCurrentMediaItemChangedMonitor.signal();
        }
    };
    mPlayer.registerPlayerCallback(mExecutor, callback);
    PlayerResult result = mPlayer.setPlaylist(playlist, null).get();
    assertEquals(RESULT_SUCCESS, result.getResultCode());
    assertTrue(onCurrentMediaItemChangedMonitor.waitForSignal(WAIT_TIME_MS));
}
#end_block

#method_before
void connect(final IMediaController caller, final String callingPackage, final int pid, final int uid) {
    MediaSessionManager.RemoteUserInfo remoteUserInfo = new MediaSessionManager.RemoteUserInfo(callingPackage, pid, uid);
    final ControllerInfo controllerInfo = new ControllerInfo(remoteUserInfo, mSessionManager.isTrustedForMediaControl(remoteUserInfo), new Controller2Cb(caller));
    mSessionImpl.getCallbackExecutor().execute(new Runnable() {

        @Override
        public void run() {
            if (mSessionImpl.isClosed()) {
                return;
            }
            final IBinder callbackBinder = ((Controller2Cb) controllerInfo.getControllerCb()).getCallbackBinder();
            synchronized (mLock) {
                // Keep connecting controllers.
                // This helps sessions to call APIs in the onConnect()
                // (e.g. setCustomLayout()) instead of pending them.
                mConnectingControllers.add(callbackBinder);
            }
            SessionCommandGroup allowedCommands = mSessionImpl.getCallback().onConnect(mSessionImpl.getInstance(), controllerInfo);
            // Don't reject connection for the request from trusted app.
            // Otherwise server will fail to retrieve session's information to dispatch
            // media keys to.
            boolean accept = allowedCommands != null || controllerInfo.isTrusted();
            if (accept) {
                if (DEBUG) {
                    Log.d(TAG, "Accepting connection, controllerInfo=" + controllerInfo + " allowedCommands=" + allowedCommands);
                }
                if (allowedCommands == null) {
                    // For trusted apps, send non-null allowed commands to keep
                    // connection.
                    allowedCommands = new SessionCommandGroup();
                }
                synchronized (mLock) {
                    if (mConnectedControllersManager.isConnected(controllerInfo)) {
                        Log.w(TAG, "Controller " + controllerInfo + " has sent connection" + " request multiple times");
                    }
                    mConnectingControllers.remove(callbackBinder);
                    mConnectedControllersManager.addController(callbackBinder, controllerInfo, allowedCommands);
                }
                // If connection is accepted, notify the current state to the controller.
                // It's needed because we cannot call synchronous calls between
                // session/controller.
                // Note: We're doing this after the onConnectionChanged(), but there's no
                // guarantee that events here are notified after the onConnected()
                // because IMediaController is oneway (i.e. async call) and Stub will
                // use thread poll for incoming calls.
                ConnectionResult state = new ConnectionResult(MediaSessionStub.this, mSessionImpl, allowedCommands);
                // another thread.
                if (mSessionImpl.isClosed()) {
                    return;
                }
                try {
                    caller.onConnected(MediaUtils.toParcelable(state));
                } catch (RemoteException e) {
                // Controller may be died prematurely.
                }
            } else {
                synchronized (mLock) {
                    mConnectingControllers.remove(callbackBinder);
                }
                if (DEBUG) {
                    Log.d(TAG, "Rejecting connection, controllerInfo=" + controllerInfo);
                }
                try {
                    caller.onDisconnected();
                } catch (RemoteException e) {
                // Controller may be died prematurely.
                // Not an issue because we'll ignore it anyway.
                }
            }
        }
    });
}
#method_after
void connect(final IMediaController caller, final String callingPackage, final int pid, final int uid) {
    MediaSessionManager.RemoteUserInfo remoteUserInfo = new MediaSessionManager.RemoteUserInfo(callingPackage, pid, uid);
    final ControllerInfo controllerInfo = new ControllerInfo(remoteUserInfo, mSessionManager.isTrustedForMediaControl(remoteUserInfo), new Controller2Cb(caller));
    mSessionImpl.getCallbackExecutor().execute(new Runnable() {

        @Override
        public void run() {
            if (mSessionImpl.isClosed()) {
                return;
            }
            final IBinder callbackBinder = ((Controller2Cb) controllerInfo.getControllerCb()).getCallbackBinder();
            synchronized (mLock) {
                // Keep connecting controllers.
                // This helps sessions to call APIs in the onConnect()
                // (e.g. setCustomLayout()) instead of pending them.
                mConnectingControllers.add(callbackBinder);
            }
            SessionCommandGroup allowedCommands = mSessionImpl.getCallback().onConnect(mSessionImpl.getInstance(), controllerInfo);
            // Don't reject connection for the request from trusted app.
            // Otherwise server will fail to retrieve session's information to dispatch
            // media keys to.
            boolean accept = allowedCommands != null || controllerInfo.isTrusted();
            if (accept) {
                if (DEBUG) {
                    Log.d(TAG, "Accepting connection, controllerInfo=" + controllerInfo + " allowedCommands=" + allowedCommands);
                }
                if (allowedCommands == null) {
                    // For trusted apps, send non-null allowed commands to keep
                    // connection.
                    allowedCommands = new SessionCommandGroup();
                }
                SequencedFutureManager sequencedFutureManager;
                synchronized (mLock) {
                    if (mConnectedControllersManager.isConnected(controllerInfo)) {
                        Log.w(TAG, "Controller " + controllerInfo + " has sent connection" + " request multiple times");
                    }
                    mConnectingControllers.remove(callbackBinder);
                    mConnectedControllersManager.addController(callbackBinder, controllerInfo, allowedCommands);
                    sequencedFutureManager = mConnectedControllersManager.getSequencedFutureManager(controllerInfo);
                }
                // If connection is accepted, notify the current state to the controller.
                // It's needed because we cannot call synchronous calls between
                // session/controller.
                // Note: We're doing this after the onConnectionChanged(), but there's no
                // guarantee that events here are notified after the onConnected()
                // because IMediaController is oneway (i.e. async call) and Stub will
                // use thread poll for incoming calls.
                ConnectionResult state = new ConnectionResult(MediaSessionStub.this, mSessionImpl, allowedCommands);
                // another thread.
                if (mSessionImpl.isClosed()) {
                    return;
                }
                try {
                    caller.onConnected(sequencedFutureManager.obtainNextSequenceNumber(), MediaUtils.toParcelable(state));
                } catch (RemoteException e) {
                // Controller may be died prematurely.
                }
            } else {
                synchronized (mLock) {
                    mConnectingControllers.remove(callbackBinder);
                }
                if (DEBUG) {
                    Log.d(TAG, "Rejecting connection, controllerInfo=" + controllerInfo);
                }
                try {
                    caller.onDisconnected(0);
                } catch (RemoteException e) {
                // Controller may be died prematurely.
                // Not an issue because we'll ignore it anyway.
                }
            }
        }
    });
}
#end_block

#method_before
@Override
void onPlaybackInfoChanged(PlaybackInfo info) throws RemoteException {
    mIControllerCallback.onPlaybackInfoChanged(MediaUtils.toParcelable(info));
}
#method_after
@Override
void onPlaybackInfoChanged(int seq, PlaybackInfo info) throws RemoteException {
    mIControllerCallback.onPlaybackInfoChanged(seq, MediaUtils.toParcelable(info));
}
#end_block

#method_before
@Override
void onAllowedCommandsChanged(SessionCommandGroup commands) throws RemoteException {
    mIControllerCallback.onAllowedCommandsChanged(MediaUtils.toParcelable(commands));
}
#method_after
@Override
void onAllowedCommandsChanged(int seq, SessionCommandGroup commands) throws RemoteException {
    mIControllerCallback.onAllowedCommandsChanged(seq, MediaUtils.toParcelable(commands));
}
#end_block

#method_before
@Override
void onPlayerStateChanged(long eventTimeMs, long positionMs, int playerState) throws RemoteException {
    mIControllerCallback.onPlayerStateChanged(eventTimeMs, positionMs, playerState);
}
#method_after
@Override
void onPlayerStateChanged(int seq, long eventTimeMs, long positionMs, int playerState) throws RemoteException {
    mIControllerCallback.onPlayerStateChanged(seq, eventTimeMs, positionMs, playerState);
}
#end_block

#method_before
@Override
void onPlaybackSpeedChanged(long eventTimeMs, long positionMs, float speed) throws RemoteException {
    mIControllerCallback.onPlaybackSpeedChanged(eventTimeMs, positionMs, speed);
}
#method_after
@Override
void onPlaybackSpeedChanged(int seq, long eventTimeMs, long positionMs, float speed) throws RemoteException {
    mIControllerCallback.onPlaybackSpeedChanged(seq, eventTimeMs, positionMs, speed);
}
#end_block

#method_before
@Override
void onBufferingStateChanged(MediaItem item, int bufferingState, long bufferedPositionMs, long eventTimeMs, long positionMs) throws RemoteException {
    mIControllerCallback.onBufferingStateChanged(MediaUtils.toParcelable(item), bufferingState, bufferedPositionMs, eventTimeMs, positionMs);
}
#method_after
@Override
void onBufferingStateChanged(int seq, MediaItem item, int bufferingState, long bufferedPositionMs, long eventTimeMs, long positionMs) throws RemoteException {
    mIControllerCallback.onBufferingStateChanged(seq, MediaUtils.toParcelable(item), bufferingState, bufferedPositionMs, eventTimeMs, positionMs);
}
#end_block

#method_before
@Override
void onSeekCompleted(long eventTimeMs, long positionMs, long seekPositionMs) throws RemoteException {
    mIControllerCallback.onSeekCompleted(eventTimeMs, positionMs, seekPositionMs);
}
#method_after
@Override
void onSeekCompleted(int seq, long eventTimeMs, long positionMs, long seekPositionMs) throws RemoteException {
    mIControllerCallback.onSeekCompleted(seq, eventTimeMs, positionMs, seekPositionMs);
}
#end_block

#method_before
@Override
void onCurrentMediaItemChanged(MediaItem item, int currentIdx, int previousIdx, int nextIdx) throws RemoteException {
    mIControllerCallback.onCurrentMediaItemChanged(MediaUtils.toParcelable(item), currentIdx, previousIdx, nextIdx);
}
#method_after
@Override
void onCurrentMediaItemChanged(int seq, MediaItem item, int currentIdx, int previousIdx, int nextIdx) throws RemoteException {
    mIControllerCallback.onCurrentMediaItemChanged(seq, MediaUtils.toParcelable(item), currentIdx, previousIdx, nextIdx);
}
#end_block

#method_before
@Override
void onPlaylistChanged(List<MediaItem> playlist, MediaMetadata metadata, int currentIdx, int previousIdx, int nextIdx) throws RemoteException {
    ControllerInfo controller = mConnectedControllersManager.getController(getCallbackBinder());
    if (mConnectedControllersManager.isAllowedCommand(controller, SessionCommand.COMMAND_CODE_PLAYER_GET_PLAYLIST)) {
        mIControllerCallback.onPlaylistChanged(MediaUtils.convertMediaItemListToParcelImplListSlice(playlist), MediaUtils.toParcelable(metadata), currentIdx, previousIdx, nextIdx);
    } else if (mConnectedControllersManager.isAllowedCommand(controller, SessionCommand.COMMAND_CODE_PLAYER_GET_PLAYLIST_METADATA)) {
        mIControllerCallback.onPlaylistMetadataChanged(MediaUtils.toParcelable(metadata));
    }
}
#method_after
@Override
void onPlaylistChanged(int seq, List<MediaItem> playlist, MediaMetadata metadata, int currentIdx, int previousIdx, int nextIdx) throws RemoteException {
    ControllerInfo controller = mConnectedControllersManager.getController(getCallbackBinder());
    if (mConnectedControllersManager.isAllowedCommand(controller, SessionCommand.COMMAND_CODE_PLAYER_GET_PLAYLIST)) {
        mIControllerCallback.onPlaylistChanged(seq, MediaUtils.convertMediaItemListToParcelImplListSlice(playlist), MediaUtils.toParcelable(metadata), currentIdx, previousIdx, nextIdx);
    } else if (mConnectedControllersManager.isAllowedCommand(controller, SessionCommand.COMMAND_CODE_PLAYER_GET_PLAYLIST_METADATA)) {
        mIControllerCallback.onPlaylistMetadataChanged(seq, MediaUtils.toParcelable(metadata));
    }
}
#end_block

#method_before
@Override
void onPlaylistMetadataChanged(MediaMetadata metadata) throws RemoteException {
    ControllerInfo controller = mConnectedControllersManager.getController(getCallbackBinder());
    if (mConnectedControllersManager.isAllowedCommand(controller, SessionCommand.COMMAND_CODE_PLAYER_GET_PLAYLIST_METADATA)) {
        mIControllerCallback.onPlaylistMetadataChanged(MediaUtils.toParcelable(metadata));
    }
}
#method_after
@Override
void onPlaylistMetadataChanged(int seq, MediaMetadata metadata) throws RemoteException {
    ControllerInfo controller = mConnectedControllersManager.getController(getCallbackBinder());
    if (mConnectedControllersManager.isAllowedCommand(controller, SessionCommand.COMMAND_CODE_PLAYER_GET_PLAYLIST_METADATA)) {
        mIControllerCallback.onPlaylistMetadataChanged(seq, MediaUtils.toParcelable(metadata));
    }
}
#end_block

#method_before
@Override
void onShuffleModeChanged(int shuffleMode) throws RemoteException {
    mIControllerCallback.onShuffleModeChanged(shuffleMode);
}
#method_after
@Override
void onShuffleModeChanged(int seq, int shuffleMode) throws RemoteException {
    mIControllerCallback.onShuffleModeChanged(seq, shuffleMode);
}
#end_block

#method_before
@Override
void onRepeatModeChanged(int repeatMode) throws RemoteException {
    mIControllerCallback.onRepeatModeChanged(repeatMode);
}
#method_after
@Override
void onRepeatModeChanged(int seq, int repeatMode) throws RemoteException {
    mIControllerCallback.onRepeatModeChanged(seq, repeatMode);
}
#end_block

#method_before
@Override
void onPlaybackCompleted() throws RemoteException {
    mIControllerCallback.onPlaybackCompleted();
}
#method_after
@Override
void onPlaybackCompleted(int seq) throws RemoteException {
    mIControllerCallback.onPlaybackCompleted(seq);
}
#end_block

#method_before
@Override
void onChildrenChanged(String parentId, int itemCount, LibraryParams params) throws RemoteException {
    mIControllerCallback.onChildrenChanged(parentId, itemCount, MediaUtils.toParcelable(params));
}
#method_after
@Override
void onChildrenChanged(int seq, String parentId, int itemCount, LibraryParams params) throws RemoteException {
    mIControllerCallback.onChildrenChanged(seq, parentId, itemCount, MediaUtils.toParcelable(params));
}
#end_block

#method_before
@Override
void onSearchResultChanged(String query, int itemCount, LibraryParams params) throws RemoteException {
    mIControllerCallback.onSearchResultChanged(query, itemCount, MediaUtils.toParcelable(params));
}
#method_after
@Override
void onSearchResultChanged(int seq, String query, int itemCount, LibraryParams params) throws RemoteException {
    mIControllerCallback.onSearchResultChanged(seq, query, itemCount, MediaUtils.toParcelable(params));
}
#end_block

#method_before
@Override
void onDisconnected() throws RemoteException {
    mIControllerCallback.onDisconnected();
}
#method_after
@Override
void onDisconnected(int seq) throws RemoteException {
    mIControllerCallback.onDisconnected(seq);
}
#end_block

#method_before
@Override
final void onPlaybackInfoChanged(PlaybackInfo info) throws RemoteException {
// No-op. BrowserCompat doesn't understand Controller features.
}
#method_after
@Override
final void onPlaybackInfoChanged(int seq, PlaybackInfo info) throws RemoteException {
// No-op. BrowserCompat doesn't understand Controller features.
}
#end_block

#method_before
@Override
final void onAllowedCommandsChanged(SessionCommandGroup commands) throws RemoteException {
// No-op. BrowserCompat doesn't understand Controller features.
}
#method_after
@Override
final void onAllowedCommandsChanged(int seq, SessionCommandGroup commands) throws RemoteException {
// No-op. BrowserCompat doesn't understand Controller features.
}
#end_block

#method_before
@Override
final void onPlayerStateChanged(long eventTimeMs, long positionMs, int playerState) throws RemoteException {
// No-op. BrowserCompat doesn't understand Controller features.
}
#method_after
@Override
final void onPlayerStateChanged(int seq, long eventTimeMs, long positionMs, int playerState) throws RemoteException {
// No-op. BrowserCompat doesn't understand Controller features.
}
#end_block

#method_before
@Override
final void onPlaybackSpeedChanged(long eventTimeMs, long positionMs, float speed) throws RemoteException {
// No-op. BrowserCompat doesn't understand Controller features.
}
#method_after
@Override
final void onPlaybackSpeedChanged(int seq, long eventTimeMs, long positionMs, float speed) throws RemoteException {
// No-op. BrowserCompat doesn't understand Controller features.
}
#end_block

#method_before
@Override
final void onBufferingStateChanged(MediaItem item, int bufferingState, long bufferedPositionMs, long eventTimeMs, long positionMs) throws RemoteException {
// No-op. BrowserCompat doesn't understand Controller features.
}
#method_after
@Override
final void onBufferingStateChanged(int seq, MediaItem item, int bufferingState, long bufferedPositionMs, long eventTimeMs, long positionMs) throws RemoteException {
// No-op. BrowserCompat doesn't understand Controller features.
}
#end_block

#method_before
@Override
final void onSeekCompleted(long eventTimeMs, long positionMs, long position) throws RemoteException {
// No-op. BrowserCompat doesn't understand Controller features.
}
#method_after
@Override
final void onSeekCompleted(int seq, long eventTimeMs, long positionMs, long position) throws RemoteException {
// No-op. BrowserCompat doesn't understand Controller features.
}
#end_block

#method_before
@Override
final void onCurrentMediaItemChanged(MediaItem item, int currentIdx, int previousIdx, int nextIdx) throws RemoteException {
// No-op. BrowserCompat doesn't understand Controller features.
}
#method_after
@Override
final void onCurrentMediaItemChanged(int seq, MediaItem item, int currentIdx, int previousIdx, int nextIdx) throws RemoteException {
// No-op. BrowserCompat doesn't understand Controller features.
}
#end_block

#method_before
@Override
final void onPlaylistChanged(List<MediaItem> playlist, MediaMetadata metadata, int currentIdx, int previousIdx, int nextIdx) throws RemoteException {
// No-op. BrowserCompat doesn't understand Controller features.
}
#method_after
@Override
final void onPlaylistChanged(int seq, List<MediaItem> playlist, MediaMetadata metadata, int currentIdx, int previousIdx, int nextIdx) throws RemoteException {
// No-op. BrowserCompat doesn't understand Controller features.
}
#end_block

#method_before
@Override
final void onPlaylistMetadataChanged(MediaMetadata metadata) throws RemoteException {
// No-op. BrowserCompat doesn't understand Controller features.
}
#method_after
@Override
final void onPlaylistMetadataChanged(int seq, MediaMetadata metadata) throws RemoteException {
// No-op. BrowserCompat doesn't understand Controller features.
}
#end_block

#method_before
@Override
final void onShuffleModeChanged(int shuffleMode) throws RemoteException {
// No-op. BrowserCompat doesn't understand Controller features.
}
#method_after
@Override
final void onShuffleModeChanged(int seq, int shuffleMode) throws RemoteException {
// No-op. BrowserCompat doesn't understand Controller features.
}
#end_block

#method_before
@Override
final void onRepeatModeChanged(int repeatMode) throws RemoteException {
// No-op. BrowserCompat doesn't understand Controller features.
}
#method_after
@Override
final void onRepeatModeChanged(int seq, int repeatMode) throws RemoteException {
// No-op. BrowserCompat doesn't understand Controller features.
}
#end_block

#method_before
@Override
final void onPlaybackCompleted() throws RemoteException {
// No-op. BrowserCompat doesn't understand Controller features.
}
#method_after
@Override
final void onPlaybackCompleted(int seq) throws RemoteException {
// No-op. BrowserCompat doesn't understand Controller features.
}
#end_block

#method_before
@Override
final void onDisconnected() throws RemoteException {
// No-op. BrowserCompat doesn't have concept of receiving release of a session.
}
#method_after
@Override
final void onDisconnected(int seq) throws RemoteException {
// No-op. BrowserCompat doesn't have concept of receiving release of a session.
}
#end_block

#method_before
@Override
void onChildrenChanged(String parentId, int itemCount, LibraryParams params) throws RemoteException {
    Bundle extras = params != null ? params.getExtras() : null;
    notifyChildrenChanged(mRemoteUserInfo, parentId, extras);
}
#method_after
@Override
void onChildrenChanged(int seq, String parentId, int itemCount, LibraryParams params) throws RemoteException {
    Bundle extras = params != null ? params.getExtras() : null;
    notifyChildrenChanged(mRemoteUserInfo, parentId, extras);
}
#end_block

#method_before
@Override
void onSearchResultChanged(String query, int itemCount, LibraryParams params) throws RemoteException {
    // In MediaLibrarySession/MediaBrowser, we have two different APIs for getting size of
    // search result (and also starting search) and getting result.
    // However, MediaBrowserService/MediaBrowserCompat only have one search API for getting
    // search result.
    final List<SearchRequest> searchRequests = new ArrayList<>();
    synchronized (mLock) {
        for (int i = mSearchRequests.size() - 1; i >= 0; i--) {
            SearchRequest iter = mSearchRequests.get(i);
            if (ObjectsCompat.equals(mRemoteUserInfo, iter.mRemoteUserInfo) && iter.mQuery.equals(query)) {
                searchRequests.add(iter);
                mSearchRequests.remove(i);
            }
        }
        if (searchRequests.size() == 0) {
            if (DEBUG) {
                Log.d(TAG, "search() hasn't called by " + mRemoteUserInfo + " with query=" + query);
            }
            return;
        }
    }
    mLibrarySessionImpl.getCallbackExecutor().execute(new Runnable() {

        @Override
        public void run() {
            for (int i = 0; i < searchRequests.size(); i++) {
                SearchRequest request = searchRequests.get(i);
                int page = 0;
                int pageSize = Integer.MAX_VALUE;
                if (request.mExtras != null) {
                    try {
                        request.mExtras.setClassLoader(mLibrarySessionImpl.getContext().getClassLoader());
                        page = request.mExtras.getInt(MediaBrowserCompat.EXTRA_PAGE, -1);
                        pageSize = request.mExtras.getInt(MediaBrowserCompat.EXTRA_PAGE_SIZE, -1);
                    } catch (BadParcelableException e) {
                        request.mResult.sendResult(null);
                        return;
                    }
                }
                if (page < 0 || pageSize < 1) {
                    page = 0;
                    pageSize = Integer.MAX_VALUE;
                }
                LibraryParams params = MediaUtils.convertToLibraryParams(mLibrarySessionImpl.getContext(), request.mExtras);
                LibraryResult libraryResult = mLibrarySessionImpl.getCallback().onGetSearchResult(mLibrarySessionImpl.getInstance(), request.mController, request.mQuery, page, pageSize, params);
                if (libraryResult == null || libraryResult.getResultCode() != RESULT_CODE_SUCCESS) {
                    request.mResult.sendResult(null);
                } else {
                    request.mResult.sendResult(MediaUtils.truncateListBySize(MediaUtils.convertToMediaItemList(libraryResult.getMediaItems()), TRANSACTION_SIZE_LIMIT_IN_BYTES));
                }
            }
        }
    });
}
#method_after
@Override
void onSearchResultChanged(int seq, String query, int itemCount, LibraryParams params) throws RemoteException {
    // In MediaLibrarySession/MediaBrowser, we have two different APIs for getting size of
    // search result (and also starting search) and getting result.
    // However, MediaBrowserService/MediaBrowserCompat only have one search API for getting
    // search result.
    final List<SearchRequest> searchRequests = new ArrayList<>();
    synchronized (mLock) {
        for (int i = mSearchRequests.size() - 1; i >= 0; i--) {
            SearchRequest iter = mSearchRequests.get(i);
            if (ObjectsCompat.equals(mRemoteUserInfo, iter.mRemoteUserInfo) && iter.mQuery.equals(query)) {
                searchRequests.add(iter);
                mSearchRequests.remove(i);
            }
        }
        if (searchRequests.size() == 0) {
            if (DEBUG) {
                Log.d(TAG, "search() hasn't called by " + mRemoteUserInfo + " with query=" + query);
            }
            return;
        }
    }
    mLibrarySessionImpl.getCallbackExecutor().execute(new Runnable() {

        @Override
        public void run() {
            for (int i = 0; i < searchRequests.size(); i++) {
                SearchRequest request = searchRequests.get(i);
                int page = 0;
                int pageSize = Integer.MAX_VALUE;
                if (request.mExtras != null) {
                    try {
                        request.mExtras.setClassLoader(mLibrarySessionImpl.getContext().getClassLoader());
                        page = request.mExtras.getInt(MediaBrowserCompat.EXTRA_PAGE, -1);
                        pageSize = request.mExtras.getInt(MediaBrowserCompat.EXTRA_PAGE_SIZE, -1);
                    } catch (BadParcelableException e) {
                        request.mResult.sendResult(null);
                        return;
                    }
                }
                if (page < 0 || pageSize < 1) {
                    page = 0;
                    pageSize = Integer.MAX_VALUE;
                }
                LibraryParams params = MediaUtils.convertToLibraryParams(mLibrarySessionImpl.getContext(), request.mExtras);
                LibraryResult libraryResult = mLibrarySessionImpl.getCallback().onGetSearchResult(mLibrarySessionImpl.getInstance(), request.mController, request.mQuery, page, pageSize, params);
                if (libraryResult == null || libraryResult.getResultCode() != RESULT_CODE_SUCCESS) {
                    request.mResult.sendResult(null);
                } else {
                    request.mResult.sendResult(MediaUtils.truncateListBySize(MediaUtils.convertToMediaItemList(libraryResult.getMediaItems()), TRANSACTION_SIZE_LIMIT_IN_BYTES));
                }
            }
        }
    });
}
#end_block

#method_before
@Override
void onChildrenChanged(String parentId, int itemCount, LibraryParams libraryParams) throws RemoteException {
    // This will trigger {@link MediaLibraryServiceLegacyStub#onLoadChildren}.
    if (libraryParams == null || libraryParams.getExtras() == null) {
        mService.notifyChildrenChanged(parentId);
    } else {
        mService.notifyChildrenChanged(parentId, libraryParams.getExtras());
    }
}
#method_after
@Override
void onChildrenChanged(int seq, String parentId, int itemCount, LibraryParams libraryParams) throws RemoteException {
    // This will trigger {@link MediaLibraryServiceLegacyStub#onLoadChildren}.
    if (libraryParams == null || libraryParams.getExtras() == null) {
        mService.notifyChildrenChanged(parentId);
    } else {
        mService.notifyChildrenChanged(parentId, libraryParams.getExtras());
    }
}
#end_block

#method_before
@Override
void onSearchResultChanged(String query, int itemCount, LibraryParams params) throws RemoteException {
    // {@link MediaLibraryServiceLegacyStub#onSearch} instead.
    if (DEBUG) {
        throw new RuntimeException("Unexpected API call. Use result.sendResult() for" + " sending onSearchResultChanged() result instead of this");
    }
}
#method_after
@Override
void onSearchResultChanged(int seq, String query, int itemCount, LibraryParams params) throws RemoteException {
    // {@link MediaLibraryServiceLegacyStub#onSearch} instead.
    if (DEBUG) {
        throw new RuntimeException("Unexpected API call. Use result.sendResult() for" + " sending onSearchResultChanged() result instead of this");
    }
}
#end_block

#method_before
@Override
public void notifyChildrenChanged(final String parentId, final int itemCount, final LibraryParams params) {
    dispatchRemoteControllerCallbackTask(new RemoteControllerCallbackTask() {

        @Override
        public void run(ControllerCb callback) throws RemoteException {
            if (isSubscribed(callback, parentId)) {
                callback.onChildrenChanged(parentId, itemCount, params);
            }
        }
    });
}
#method_after
@Override
public void notifyChildrenChanged(final String parentId, final int itemCount, final LibraryParams params) {
    dispatchRemoteControllerTaskWithoutReturn(new RemoteControllerTask() {

        @Override
        public void run(ControllerCb callback, int seq) throws RemoteException {
            if (isSubscribed(callback, parentId)) {
                callback.onChildrenChanged(seq, parentId, itemCount, params);
            }
        }
    });
}
#end_block

#method_before
@Override
public void notifyChildrenChanged(final ControllerInfo controller, final String parentId, final int itemCount, final LibraryParams params) {
    dispatchRemoteControllerCallbackTask(controller, new RemoteControllerCallbackTask() {

        @Override
        public void run(ControllerCb callback) throws RemoteException {
            if (!isSubscribed(callback, parentId)) {
                if (DEBUG) {
                    Log.d(TAG, "Skipping notifyChildrenChanged() to " + controller + " because it hasn't subscribed");
                    dumpSubscription();
                }
                return;
            }
            callback.onChildrenChanged(parentId, itemCount, params);
        }
    });
}
#method_after
@Override
public void notifyChildrenChanged(final ControllerInfo controller, final String parentId, final int itemCount, final LibraryParams params) {
    dispatchRemoteControllerTaskWithoutReturn(controller, new RemoteControllerTask() {

        @Override
        public void run(ControllerCb callback, int seq) throws RemoteException {
            if (!isSubscribed(callback, parentId)) {
                if (DEBUG) {
                    Log.d(TAG, "Skipping notifyChildrenChanged() to " + controller + " because it hasn't subscribed");
                    dumpSubscription();
                }
                return;
            }
            callback.onChildrenChanged(seq, parentId, itemCount, params);
        }
    });
}
#end_block

#method_before
@Override
public void notifySearchResultChanged(ControllerInfo controller, final String query, final int itemCount, final LibraryParams params) {
    dispatchRemoteControllerCallbackTask(controller, new RemoteControllerCallbackTask() {

        @Override
        public void run(ControllerCb callback) throws RemoteException {
            callback.onSearchResultChanged(query, itemCount, params);
        }
    });
}
#method_after
@Override
public void notifySearchResultChanged(ControllerInfo controller, final String query, final int itemCount, final LibraryParams params) {
    dispatchRemoteControllerTaskWithoutReturn(controller, new RemoteControllerTask() {

        @Override
        public void run(ControllerCb callback, int seq) throws RemoteException {
            callback.onSearchResultChanged(seq, query, itemCount, params);
        }
    });
}
#end_block

#method_before
private void dispatchSessionTaskInternal(@Nullable final SessionCommand sessionCommand, @CommandCode final int commandCode, @NonNull final SessionTask task) {
    if (mSessionImpl.isClosed()) {
        return;
    }
    final RemoteUserInfo remoteUserInfo = mSessionImpl.getSessionCompat().getCurrentControllerInfo();
    if (remoteUserInfo == null) {
        Log.d(TAG, "RemoteUserInfo is null, ignoring command=" + sessionCommand + ", commandCode=" + commandCode);
        return;
    }
    mSessionImpl.getCallbackExecutor().execute(new Runnable() {

        @Override
        public void run() {
            if (mSessionImpl.isClosed()) {
                return;
            }
            final ControllerInfo controller;
            ControllerInfo ctrl = mConnectedControllersManager.getController(remoteUserInfo);
            if (ctrl != null) {
                controller = ctrl;
            } else {
                controller = new ControllerInfo(remoteUserInfo, mSessionManager.isTrustedForMediaControl(remoteUserInfo), new ControllerLegacyCb(remoteUserInfo));
            }
            if (!mConnectedControllersManager.isConnected(controller)) {
                SessionCommandGroup allowedCommands = mSessionImpl.getCallback().onConnect(mSessionImpl.getInstance(), controller);
                if (allowedCommands == null) {
                    try {
                        controller.getControllerCb().onDisconnected();
                    } catch (RemoteException ex) {
                    // Controller may have died prematurely.
                    }
                    return;
                }
                mConnectedControllersManager.addController(controller.getRemoteUserInfo(), controller, allowedCommands);
            }
            handleTaskOnExecutor(controller, sessionCommand, commandCode, task);
        }
    });
}
#method_after
private void dispatchSessionTaskInternal(@Nullable final SessionCommand sessionCommand, @CommandCode final int commandCode, @NonNull final SessionTask task) {
    if (mSessionImpl.isClosed()) {
        return;
    }
    final RemoteUserInfo remoteUserInfo = mSessionImpl.getSessionCompat().getCurrentControllerInfo();
    if (remoteUserInfo == null) {
        Log.d(TAG, "RemoteUserInfo is null, ignoring command=" + sessionCommand + ", commandCode=" + commandCode);
        return;
    }
    mSessionImpl.getCallbackExecutor().execute(new Runnable() {

        @Override
        public void run() {
            if (mSessionImpl.isClosed()) {
                return;
            }
            final ControllerInfo controller;
            ControllerInfo ctrl = mConnectedControllersManager.getController(remoteUserInfo);
            if (ctrl != null) {
                controller = ctrl;
            } else {
                controller = new ControllerInfo(remoteUserInfo, mSessionManager.isTrustedForMediaControl(remoteUserInfo), new ControllerLegacyCb(remoteUserInfo));
            }
            if (!mConnectedControllersManager.isConnected(controller)) {
                SessionCommandGroup allowedCommands = mSessionImpl.getCallback().onConnect(mSessionImpl.getInstance(), controller);
                if (allowedCommands == null) {
                    try {
                        controller.getControllerCb().onDisconnected(0);
                    } catch (RemoteException ex) {
                    // Controller may have died prematurely.
                    }
                    return;
                }
                mConnectedControllersManager.addController(controller.getRemoteUserInfo(), controller, allowedCommands);
            }
            handleTaskOnExecutor(controller, sessionCommand, commandCode, task);
        }
    });
}
#end_block

#method_before
@Override
void onPlaybackInfoChanged(PlaybackInfo info) throws RemoteException {
    throw new AssertionError("This shouldn't be called.");
}
#method_after
@Override
void onPlaybackInfoChanged(int seq, PlaybackInfo info) throws RemoteException {
    throw new AssertionError("This shouldn't be called.");
}
#end_block

#method_before
@Override
void onAllowedCommandsChanged(SessionCommandGroup commands) throws RemoteException {
// no-op
}
#method_after
@Override
void onAllowedCommandsChanged(int seq, SessionCommandGroup commands) throws RemoteException {
// no-op
}
#end_block

#method_before
@Override
void onPlayerStateChanged(long eventTimeMs, long positionMs, int playerState) throws RemoteException {
    throw new AssertionError("This shouldn't be called.");
}
#method_after
@Override
void onPlayerStateChanged(int seq, long eventTimeMs, long positionMs, int playerState) throws RemoteException {
    throw new AssertionError("This shouldn't be called.");
}
#end_block

#method_before
@Override
void onPlaybackSpeedChanged(long eventTimeMs, long positionMs, float speed) throws RemoteException {
    throw new AssertionError("This shouldn't be called.");
}
#method_after
@Override
void onPlaybackSpeedChanged(int seq, long eventTimeMs, long positionMs, float speed) throws RemoteException {
    throw new AssertionError("This shouldn't be called.");
}
#end_block

#method_before
@Override
void onBufferingStateChanged(MediaItem item, int bufferingState, long bufferedPositionMs, long eventTimeMs, long positionMs) throws RemoteException {
    throw new AssertionError("This shouldn't be called.");
}
#method_after
@Override
void onBufferingStateChanged(int seq, MediaItem item, int bufferingState, long bufferedPositionMs, long eventTimeMs, long positionMs) throws RemoteException {
    throw new AssertionError("This shouldn't be called.");
}
#end_block

#method_before
@Override
void onSeekCompleted(long eventTimeMs, long positionMs, long position) throws RemoteException {
    throw new AssertionError("This shouldn't be called.");
}
#method_after
@Override
void onSeekCompleted(int seq, long eventTimeMs, long positionMs, long position) throws RemoteException {
    throw new AssertionError("This shouldn't be called.");
}
#end_block

#method_before
@Override
void onCurrentMediaItemChanged(MediaItem item, int currentIdx, int previousIdx, int nextIdx) throws RemoteException {
    throw new AssertionError("This shouldn't be called.");
}
#method_after
@Override
void onCurrentMediaItemChanged(int seq, MediaItem item, int currentIdx, int previousIdx, int nextIdx) throws RemoteException {
    throw new AssertionError("This shouldn't be called.");
}
#end_block

#method_before
@Override
void onPlaylistChanged(List<MediaItem> playlist, MediaMetadata metadata, int currentIdx, int previousIdx, int nextIdx) throws RemoteException {
    throw new AssertionError("This shouldn't be called.");
}
#method_after
@Override
void onPlaylistChanged(int seq, List<MediaItem> playlist, MediaMetadata metadata, int currentIdx, int previousIdx, int nextIdx) throws RemoteException {
    throw new AssertionError("This shouldn't be called.");
}
#end_block

#method_before
@Override
void onPlaylistMetadataChanged(MediaMetadata metadata) throws RemoteException {
    throw new AssertionError("This shouldn't be called.");
}
#method_after
@Override
void onPlaylistMetadataChanged(int seq, MediaMetadata metadata) throws RemoteException {
    throw new AssertionError("This shouldn't be called.");
}
#end_block

#method_before
@Override
void onShuffleModeChanged(int shuffleMode) throws RemoteException {
    throw new AssertionError("This shouldn't be called.");
}
#method_after
@Override
void onShuffleModeChanged(int seq, int shuffleMode) throws RemoteException {
    throw new AssertionError("This shouldn't be called.");
}
#end_block

#method_before
@Override
void onRepeatModeChanged(int repeatMode) throws RemoteException {
    throw new AssertionError("This shouldn't be called.");
}
#method_after
@Override
void onRepeatModeChanged(int seq, int repeatMode) throws RemoteException {
    throw new AssertionError("This shouldn't be called.");
}
#end_block

#method_before
@Override
void onPlaybackCompleted() throws RemoteException {
    throw new AssertionError("This shouldn't be called.");
}
#method_after
@Override
void onPlaybackCompleted(int seq) throws RemoteException {
    throw new AssertionError("This shouldn't be called.");
}
#end_block

#method_before
@Override
void onChildrenChanged(String parentId, int itemCount, LibraryParams params) throws RemoteException {
// no-op
}
#method_after
@Override
void onChildrenChanged(int seq, String parentId, int itemCount, LibraryParams params) throws RemoteException {
// no-op
}
#end_block

#method_before
@Override
void onSearchResultChanged(String query, int itemCount, LibraryParams params) throws RemoteException {
// no-op
}
#method_after
@Override
void onSearchResultChanged(int seq, String query, int itemCount, LibraryParams params) throws RemoteException {
// no-op
}
#end_block

#method_before
@Override
void onDisconnected() throws RemoteException {
// no-op
}
#method_after
@Override
void onDisconnected(int seq) throws RemoteException {
// no-op
}
#end_block

#method_before
@Override
void onPlaybackInfoChanged(PlaybackInfo info) throws RemoteException {
// no-op. Calling MediaSessionCompat#setPlaybackToLocal/Remote
// is already done in updatePlayerConnector().
}
#method_after
@Override
void onPlaybackInfoChanged(int seq, PlaybackInfo info) throws RemoteException {
// no-op. Calling MediaSessionCompat#setPlaybackToLocal/Remote
// is already done in updatePlayerConnector().
}
#end_block

#method_before
@Override
void onAllowedCommandsChanged(SessionCommandGroup commands) throws RemoteException {
    throw new AssertionError("This shouldn't be called.");
}
#method_after
@Override
void onAllowedCommandsChanged(int seq, SessionCommandGroup commands) throws RemoteException {
    throw new AssertionError("This shouldn't be called.");
}
#end_block

#method_before
@Override
void onPlayerStateChanged(long eventTimeMs, long positionMs, int playerState) throws RemoteException {
    // Note: This method does not use any of the given arguments.
    mSessionImpl.getSessionCompat().setPlaybackState(mSessionImpl.createPlaybackStateCompat());
}
#method_after
@Override
void onPlayerStateChanged(int seq, long eventTimeMs, long positionMs, int playerState) throws RemoteException {
    // Note: This method does not use any of the given arguments.
    mSessionImpl.getSessionCompat().setPlaybackState(mSessionImpl.createPlaybackStateCompat());
}
#end_block

#method_before
@Override
void onPlaybackSpeedChanged(long eventTimeMs, long positionMs, float speed) throws RemoteException {
    // Note: This method does not use any of the given arguments.
    mSessionImpl.getSessionCompat().setPlaybackState(mSessionImpl.createPlaybackStateCompat());
}
#method_after
@Override
void onPlaybackSpeedChanged(int seq, long eventTimeMs, long positionMs, float speed) throws RemoteException {
    // Note: This method does not use any of the given arguments.
    mSessionImpl.getSessionCompat().setPlaybackState(mSessionImpl.createPlaybackStateCompat());
}
#end_block

#method_before
@Override
void onBufferingStateChanged(MediaItem item, int bufferingState, long bufferedPositionMs, long eventTimeMs, long positionMs) throws RemoteException {
    // Note: This method does not use any of the given arguments.
    mSessionImpl.getSessionCompat().setPlaybackState(mSessionImpl.createPlaybackStateCompat());
}
#method_after
@Override
void onBufferingStateChanged(int seq, MediaItem item, int bufferingState, long bufferedPositionMs, long eventTimeMs, long positionMs) throws RemoteException {
    // Note: This method does not use any of the given arguments.
    mSessionImpl.getSessionCompat().setPlaybackState(mSessionImpl.createPlaybackStateCompat());
}
#end_block

#method_before
@Override
void onSeekCompleted(long eventTimeMs, long positionMs, long position) throws RemoteException {
    // Note: This method does not use any of the given arguments.
    mSessionImpl.getSessionCompat().setPlaybackState(mSessionImpl.createPlaybackStateCompat());
}
#method_after
@Override
void onSeekCompleted(int seq, long eventTimeMs, long positionMs, long position) throws RemoteException {
    // Note: This method does not use any of the given arguments.
    mSessionImpl.getSessionCompat().setPlaybackState(mSessionImpl.createPlaybackStateCompat());
}
#end_block

#method_before
@Override
void onCurrentMediaItemChanged(MediaItem item, int currentIdx, int previousIdx, int nextIdx) throws RemoteException {
    mSessionImpl.getSessionCompat().setMetadata(item == null ? null : MediaUtils.convertToMediaMetadataCompat(item.getMetadata()));
}
#method_after
@Override
void onCurrentMediaItemChanged(int seq, MediaItem item, int currentIdx, int previousIdx, int nextIdx) throws RemoteException {
    mSessionImpl.getSessionCompat().setMetadata(item == null ? null : MediaUtils.convertToMediaMetadataCompat(item.getMetadata()));
}
#end_block

#method_before
@Override
void onPlaylistChanged(List<MediaItem> playlist, MediaMetadata metadata, int currentIdx, int previousIdx, int nextIdx) throws RemoteException {
    if (Build.VERSION.SDK_INT < 21) {
        if (playlist == null) {
            mSessionImpl.getSessionCompat().setQueue(null);
        } else {
            // In order to avoid TransactionTooLargeException for below API 21, we need to
            // cut the list so that it doesn't exceed the binder transaction limit.
            List<QueueItem> queueItemList = MediaUtils.convertToQueueItemList(playlist);
            List<QueueItem> truncatedList = MediaUtils.truncateListBySize(queueItemList, TRANSACTION_SIZE_LIMIT_IN_BYTES);
            if (truncatedList.size() != playlist.size()) {
                Log.i(TAG, "Sending " + truncatedList.size() + " items out of " + playlist.size());
            }
            mSessionImpl.getSessionCompat().setQueue(truncatedList);
        }
    } else {
        // Framework MediaSession#setQueue() uses ParceledListSlice,
        // which means we can safely send long lists.
        mSessionImpl.getSessionCompat().setQueue(MediaUtils.convertToQueueItemList(playlist));
    }
    onPlaylistMetadataChanged(metadata);
}
#method_after
@Override
void onPlaylistChanged(int seq, List<MediaItem> playlist, MediaMetadata metadata, int currentIdx, int previousIdx, int nextIdx) throws RemoteException {
    if (Build.VERSION.SDK_INT < 21) {
        if (playlist == null) {
            mSessionImpl.getSessionCompat().setQueue(null);
        } else {
            // In order to avoid TransactionTooLargeException for below API 21, we need to
            // cut the list so that it doesn't exceed the binder transaction limit.
            List<QueueItem> queueItemList = MediaUtils.convertToQueueItemList(playlist);
            List<QueueItem> truncatedList = MediaUtils.truncateListBySize(queueItemList, TRANSACTION_SIZE_LIMIT_IN_BYTES);
            if (truncatedList.size() != playlist.size()) {
                Log.i(TAG, "Sending " + truncatedList.size() + " items out of " + playlist.size());
            }
            mSessionImpl.getSessionCompat().setQueue(truncatedList);
        }
    } else {
        // Framework MediaSession#setQueue() uses ParceledListSlice,
        // which means we can safely send long lists.
        mSessionImpl.getSessionCompat().setQueue(MediaUtils.convertToQueueItemList(playlist));
    }
    onPlaylistMetadataChanged(seq, metadata);
}
#end_block

#method_before
@Override
void onPlaylistMetadataChanged(MediaMetadata metadata) throws RemoteException {
    // Since there is no 'queue metadata', only set title of the queue.
    CharSequence oldTitle = mSessionImpl.getSessionCompat().getController().getQueueTitle();
    CharSequence newTitle = null;
    if (metadata != null) {
        newTitle = metadata.getText(METADATA_KEY_DISPLAY_TITLE);
        if (newTitle == null) {
            newTitle = metadata.getText(METADATA_KEY_TITLE);
        }
    }
    if (!TextUtils.equals(oldTitle, newTitle)) {
        mSessionImpl.getSessionCompat().setQueueTitle(newTitle);
    }
}
#method_after
@Override
void onPlaylistMetadataChanged(int seq, MediaMetadata metadata) throws RemoteException {
    // Since there is no 'queue metadata', only set title of the queue.
    CharSequence oldTitle = mSessionImpl.getSessionCompat().getController().getQueueTitle();
    CharSequence newTitle = null;
    if (metadata != null) {
        newTitle = metadata.getText(METADATA_KEY_DISPLAY_TITLE);
        if (newTitle == null) {
            newTitle = metadata.getText(METADATA_KEY_TITLE);
        }
    }
    if (!TextUtils.equals(oldTitle, newTitle)) {
        mSessionImpl.getSessionCompat().setQueueTitle(newTitle);
    }
}
#end_block

#method_before
@Override
void onShuffleModeChanged(int shuffleMode) throws RemoteException {
    mSessionImpl.getSessionCompat().setShuffleMode(shuffleMode);
}
#method_after
@Override
void onShuffleModeChanged(int seq, int shuffleMode) throws RemoteException {
    mSessionImpl.getSessionCompat().setShuffleMode(shuffleMode);
}
#end_block

#method_before
@Override
void onRepeatModeChanged(int repeatMode) throws RemoteException {
    mSessionImpl.getSessionCompat().setRepeatMode(repeatMode);
}
#method_after
@Override
void onRepeatModeChanged(int seq, int repeatMode) throws RemoteException {
    mSessionImpl.getSessionCompat().setRepeatMode(repeatMode);
}
#end_block

#method_before
@Override
void onPlaybackCompleted() throws RemoteException {
    PlaybackStateCompat state = mSessionImpl.createPlaybackStateCompat();
    if (state.getState() != PlaybackStateCompat.STATE_PAUSED) {
        state = new PlaybackStateCompat.Builder(state).setState(PlaybackStateCompat.STATE_PAUSED, state.getPosition(), state.getPlaybackSpeed()).build();
    }
    mSessionImpl.getSessionCompat().setPlaybackState(state);
}
#method_after
@Override
void onPlaybackCompleted(int seq) throws RemoteException {
    PlaybackStateCompat state = mSessionImpl.createPlaybackStateCompat();
    if (state.getState() != PlaybackStateCompat.STATE_PAUSED) {
        state = new PlaybackStateCompat.Builder(state).setState(PlaybackStateCompat.STATE_PAUSED, state.getPosition(), state.getPlaybackSpeed()).build();
    }
    mSessionImpl.getSessionCompat().setPlaybackState(state);
}
#end_block

#method_before
@Override
void onChildrenChanged(String parentId, int itemCount, LibraryParams params) throws RemoteException {
// no-op
}
#method_after
@Override
void onChildrenChanged(int seq, String parentId, int itemCount, LibraryParams params) throws RemoteException {
// no-op
}
#end_block

#method_before
@Override
void onSearchResultChanged(String query, int itemCount, LibraryParams params) throws RemoteException {
// no-op
}
#method_after
@Override
void onSearchResultChanged(int seq, String query, int itemCount, LibraryParams params) throws RemoteException {
// no-op
}
#end_block

#method_before
@Override
void onDisconnected() throws RemoteException {
// no-op. Calling MediaSessionCompat#release() is already done in close().
}
#method_after
@Override
void onDisconnected(int seq) throws RemoteException {
// no-op. Calling MediaSessionCompat#release() is already done in close().
}
#end_block

#method_before
@NonNull
public LibraryParams build() {
    return new LibraryParams(mBundle, mRecent, mOffline, mSuggested);
}
#method_after
@Override
@NonNull
public MediaLibrarySession build() {
    if (mCallbackExecutor == null) {
        mCallbackExecutor = ContextCompat.getMainExecutor(mContext);
    }
    if (mCallback == null) {
        mCallback = new MediaLibrarySession.MediaLibrarySessionCallback() {
        };
    }
    return new MediaLibrarySession(mContext, mId, mPlayer, mSessionActivity, mCallbackExecutor, mCallback);
}
#end_block

#method_before
@Override
public void onCurrentMediaItemChanged(final ParcelImpl item, final int currentIdx, final int previousIdx, final int nextIdx) {
    if (item == null) {
        return;
    }
    dispatchControllerTask(new ControllerTask() {

        @Override
        public void run(MediaControllerImplBase controller) {
            controller.notifyCurrentMediaItemChanged((MediaItem) MediaUtils.fromParcelable(item), currentIdx, previousIdx, nextIdx);
        }
    });
}
#method_after
@Override
public void onCurrentMediaItemChanged(int seq, final ParcelImpl item, final int currentIdx, final int previousIdx, final int nextIdx) {
    if (item == null) {
        return;
    }
    dispatchControllerTask(new ControllerTask() {

        @Override
        public void run(MediaControllerImplBase controller) {
            controller.notifyCurrentMediaItemChanged((MediaItem) MediaUtils.fromParcelable(item), currentIdx, previousIdx, nextIdx);
        }
    });
}
#end_block

#method_before
@Override
public void onPlayerStateChanged(final long eventTimeMs, final long positionMs, final int state) {
    dispatchControllerTask(new ControllerTask() {

        @Override
        public void run(MediaControllerImplBase controller) {
            controller.notifyPlayerStateChanges(eventTimeMs, positionMs, state);
        }
    });
}
#method_after
@Override
public void onPlayerStateChanged(int seq, final long eventTimeMs, final long positionMs, final int state) {
    dispatchControllerTask(new ControllerTask() {

        @Override
        public void run(MediaControllerImplBase controller) {
            controller.notifyPlayerStateChanges(eventTimeMs, positionMs, state);
        }
    });
}
#end_block

#method_before
@Override
public void onPlaybackSpeedChanged(final long eventTimeMs, final long positionMs, final float speed) {
    dispatchControllerTask(new ControllerTask() {

        @Override
        public void run(MediaControllerImplBase controller) {
            controller.notifyPlaybackSpeedChanges(eventTimeMs, positionMs, speed);
        }
    });
}
#method_after
@Override
public void onPlaybackSpeedChanged(int seq, final long eventTimeMs, final long positionMs, final float speed) {
    dispatchControllerTask(new ControllerTask() {

        @Override
        public void run(MediaControllerImplBase controller) {
            controller.notifyPlaybackSpeedChanges(eventTimeMs, positionMs, speed);
        }
    });
}
#end_block

#method_before
@Override
public void onBufferingStateChanged(final ParcelImpl item, @BuffState final int state, final long bufferedPositionMs, final long eventTimeMs, final long positionMs) {
    if (item == null) {
        return;
    }
    dispatchControllerTask(new ControllerTask() {

        @Override
        public void run(MediaControllerImplBase controller) {
            MediaItem itemObj = MediaUtils.fromParcelable(item);
            if (itemObj == null) {
                Log.w(TAG, "onBufferingStateChanged(): Ignoring null item");
                return;
            }
            controller.notifyBufferingStateChanged(itemObj, state, bufferedPositionMs, eventTimeMs, positionMs);
        }
    });
}
#method_after
@Override
public void onBufferingStateChanged(int seq, final ParcelImpl item, @BuffState final int state, final long bufferedPositionMs, final long eventTimeMs, final long positionMs) {
    if (item == null) {
        return;
    }
    dispatchControllerTask(new ControllerTask() {

        @Override
        public void run(MediaControllerImplBase controller) {
            MediaItem itemObj = MediaUtils.fromParcelable(item);
            if (itemObj == null) {
                Log.w(TAG, "onBufferingStateChanged(): Ignoring null item");
                return;
            }
            controller.notifyBufferingStateChanged(itemObj, state, bufferedPositionMs, eventTimeMs, positionMs);
        }
    });
}
#end_block

#method_before
@Override
public void onPlaylistChanged(final ParcelImplListSlice listSlice, final ParcelImpl metadata, final int currentIdx, final int previousIdx, final int nextIdx) {
    if (metadata == null) {
        return;
    }
    dispatchControllerTask(new ControllerTask() {

        @Override
        public void run(MediaControllerImplBase controller) {
            List<MediaItem> playlist = MediaUtils.convertParcelImplListSliceToMediaItemList(listSlice);
            controller.notifyPlaylistChanges(playlist, (MediaMetadata) MediaUtils.fromParcelable(metadata), currentIdx, previousIdx, nextIdx);
        }
    });
}
#method_after
@Override
public void onPlaylistChanged(int seq, final ParcelImplListSlice listSlice, final ParcelImpl metadata, final int currentIdx, final int previousIdx, final int nextIdx) {
    if (metadata == null) {
        return;
    }
    dispatchControllerTask(new ControllerTask() {

        @Override
        public void run(MediaControllerImplBase controller) {
            List<MediaItem> playlist = MediaUtils.convertParcelImplListSliceToMediaItemList(listSlice);
            controller.notifyPlaylistChanges(playlist, (MediaMetadata) MediaUtils.fromParcelable(metadata), currentIdx, previousIdx, nextIdx);
        }
    });
}
#end_block

#method_before
@Override
public void onPlaylistMetadataChanged(final ParcelImpl metadata) throws RuntimeException {
    if (metadata == null) {
        return;
    }
    dispatchControllerTask(new ControllerTask() {

        @Override
        public void run(MediaControllerImplBase controller) {
            controller.notifyPlaylistMetadataChanges((MediaMetadata) MediaUtils.fromParcelable(metadata));
        }
    });
}
#method_after
@Override
public void onPlaylistMetadataChanged(int seq, final ParcelImpl metadata) throws RuntimeException {
    if (metadata == null) {
        return;
    }
    dispatchControllerTask(new ControllerTask() {

        @Override
        public void run(MediaControllerImplBase controller) {
            controller.notifyPlaylistMetadataChanges((MediaMetadata) MediaUtils.fromParcelable(metadata));
        }
    });
}
#end_block

#method_before
@Override
public void onRepeatModeChanged(final int repeatMode) {
    dispatchControllerTask(new ControllerTask() {

        @Override
        public void run(MediaControllerImplBase controller) {
            controller.notifyRepeatModeChanges(repeatMode);
        }
    });
}
#method_after
@Override
public void onRepeatModeChanged(int seq, final int repeatMode) {
    dispatchControllerTask(new ControllerTask() {

        @Override
        public void run(MediaControllerImplBase controller) {
            controller.notifyRepeatModeChanges(repeatMode);
        }
    });
}
#end_block

#method_before
@Override
public void onShuffleModeChanged(final int shuffleMode) {
    dispatchControllerTask(new ControllerTask() {

        @Override
        public void run(MediaControllerImplBase controller) {
            controller.notifyShuffleModeChanges(shuffleMode);
        }
    });
}
#method_after
@Override
public void onShuffleModeChanged(int seq, final int shuffleMode) {
    dispatchControllerTask(new ControllerTask() {

        @Override
        public void run(MediaControllerImplBase controller) {
            controller.notifyShuffleModeChanges(shuffleMode);
        }
    });
}
#end_block

#method_before
@Override
public void onPlaybackCompleted() {
    dispatchControllerTask(new ControllerTask() {

        @Override
        public void run(MediaControllerImplBase controller) {
            controller.notifyPlaybackCompleted();
        }
    });
}
#method_after
@Override
public void onPlaybackCompleted(int seq) {
    dispatchControllerTask(new ControllerTask() {

        @Override
        public void run(MediaControllerImplBase controller) {
            controller.notifyPlaybackCompleted();
        }
    });
}
#end_block

#method_before
@Override
public void onPlaybackInfoChanged(final ParcelImpl playbackInfo) throws RuntimeException {
    if (playbackInfo == null) {
        return;
    }
    if (DEBUG) {
        Log.d(TAG, "onPlaybackInfoChanged");
    }
    dispatchControllerTask(new ControllerTask() {

        @Override
        public void run(MediaControllerImplBase controller) {
            PlaybackInfo info = MediaUtils.fromParcelable(playbackInfo);
            if (info == null) {
                Log.w(TAG, "onPlaybackInfoChanged(): Ignoring null playbackInfo");
                return;
            }
            controller.notifyPlaybackInfoChanges(info);
        }
    });
}
#method_after
@Override
public void onPlaybackInfoChanged(int seq, final ParcelImpl playbackInfo) throws RuntimeException {
    if (playbackInfo == null) {
        return;
    }
    if (DEBUG) {
        Log.d(TAG, "onPlaybackInfoChanged");
    }
    dispatchControllerTask(new ControllerTask() {

        @Override
        public void run(MediaControllerImplBase controller) {
            PlaybackInfo info = MediaUtils.fromParcelable(playbackInfo);
            if (info == null) {
                Log.w(TAG, "onPlaybackInfoChanged(): Ignoring null playbackInfo");
                return;
            }
            controller.notifyPlaybackInfoChanges(info);
        }
    });
}
#end_block

#method_before
@Override
public void onSeekCompleted(final long eventTimeMs, final long positionMs, final long seekPositionMs) {
    dispatchControllerTask(new ControllerTask() {

        @Override
        public void run(MediaControllerImplBase controller) {
            controller.notifySeekCompleted(eventTimeMs, positionMs, seekPositionMs);
        }
    });
}
#method_after
@Override
public void onSeekCompleted(int seq, final long eventTimeMs, final long positionMs, final long seekPositionMs) {
    dispatchControllerTask(new ControllerTask() {

        @Override
        public void run(MediaControllerImplBase controller) {
            controller.notifySeekCompleted(eventTimeMs, positionMs, seekPositionMs);
        }
    });
}
#end_block

#method_before
@Override
public void onConnected(ParcelImpl connectionResult) {
    if (connectionResult == null) {
        // disconnected
        onDisconnected();
        return;
    }
    final long token = Binder.clearCallingIdentity();
    try {
        final MediaControllerImplBase controller = mController.get();
        if (controller == null) {
            if (DEBUG) {
                Log.d(TAG, "onConnected after MediaController2.close()");
            }
            return;
        }
        ConnectionResult result = MediaUtils.fromParcelable(connectionResult);
        List<MediaItem> itemList = MediaUtils.convertParcelImplListSliceToMediaItemList(result.getPlaylistSlice());
        controller.onConnectedNotLocked(result.getSessionStub(), result.getAllowedCommands(), result.getPlayerState(), result.getCurrentMediaItem(), result.getPositionEventTimeMs(), result.getPositionMs(), result.getPlaybackSpeed(), result.getBufferedPositionMs(), result.getPlaybackInfo(), result.getRepeatMode(), result.getShuffleMode(), itemList, result.getSessionActivity());
    } finally {
        Binder.restoreCallingIdentity(token);
    }
}
#method_after
@Override
public void onConnected(int seq, ParcelImpl connectionResult) {
    if (connectionResult == null) {
        // disconnected
        onDisconnected(seq);
        return;
    }
    final long token = Binder.clearCallingIdentity();
    try {
        final MediaControllerImplBase controller = mController.get();
        if (controller == null) {
            if (DEBUG) {
                Log.d(TAG, "onConnected after MediaController2.close()");
            }
            return;
        }
        ConnectionResult result = MediaUtils.fromParcelable(connectionResult);
        List<MediaItem> itemList = MediaUtils.convertParcelImplListSliceToMediaItemList(result.getPlaylistSlice());
        controller.onConnectedNotLocked(result.getSessionStub(), result.getAllowedCommands(), result.getPlayerState(), result.getCurrentMediaItem(), result.getPositionEventTimeMs(), result.getPositionMs(), result.getPlaybackSpeed(), result.getBufferedPositionMs(), result.getPlaybackInfo(), result.getRepeatMode(), result.getShuffleMode(), itemList, result.getSessionActivity());
    } finally {
        Binder.restoreCallingIdentity(token);
    }
}
#end_block

#method_before
@Override
public void onDisconnected() {
    final long token = Binder.clearCallingIdentity();
    try {
        final MediaControllerImplBase controller = mController.get();
        if (controller == null) {
            if (DEBUG) {
                Log.d(TAG, "onDisconnected after MediaController2.close()");
            }
            return;
        }
        controller.getInstance().close();
    } finally {
        Binder.restoreCallingIdentity(token);
    }
}
#method_after
@Override
public void onDisconnected(int seq) {
    final long token = Binder.clearCallingIdentity();
    try {
        final MediaControllerImplBase controller = mController.get();
        if (controller == null) {
            if (DEBUG) {
                Log.d(TAG, "onDisconnected after MediaController2.close()");
            }
            return;
        }
        controller.getInstance().close();
    } finally {
        Binder.restoreCallingIdentity(token);
    }
}
#end_block

#method_before
@Override
public void onAllowedCommandsChanged(final ParcelImpl commands) {
    if (commands == null) {
        return;
    }
    dispatchControllerTask(new ControllerTask() {

        @Override
        public void run(MediaControllerImplBase controller) {
            SessionCommandGroup commandGroup = MediaUtils.fromParcelable(commands);
            if (commandGroup == null) {
                Log.w(TAG, "onAllowedCommandsChanged(): Ignoring null commands");
                return;
            }
            controller.onAllowedCommandsChanged(commandGroup);
        }
    });
}
#method_after
@Override
public void onAllowedCommandsChanged(int seq, final ParcelImpl commands) {
    if (commands == null) {
        return;
    }
    dispatchControllerTask(new ControllerTask() {

        @Override
        public void run(MediaControllerImplBase controller) {
            SessionCommandGroup commandGroup = MediaUtils.fromParcelable(commands);
            if (commandGroup == null) {
                Log.w(TAG, "onAllowedCommandsChanged(): Ignoring null commands");
                return;
            }
            controller.onAllowedCommandsChanged(commandGroup);
        }
    });
}
#end_block

#method_before
// //////////////////////////////////////////////////////////////////////////////////////////
// MediaBrowser specific
@Override
public void onSearchResultChanged(final String query, final int itemCount, final ParcelImpl libraryParams) throws RuntimeException {
    if (libraryParams == null) {
        return;
    }
    if (TextUtils.isEmpty(query)) {
        Log.w(TAG, "onSearchResultChanged(): Ignoring empty query");
        return;
    }
    if (itemCount < 0) {
        Log.w(TAG, "onSearchResultChanged(): Ignoring negative itemCount: " + itemCount);
        return;
    }
    dispatchBrowserTask(new BrowserTask() {

        @Override
        public void run(MediaBrowserImplBase browser) {
            browser.notifySearchResultChanged(query, itemCount, (LibraryParams) MediaUtils.fromParcelable(libraryParams));
        }
    });
}
#method_after
// //////////////////////////////////////////////////////////////////////////////////////////
// MediaBrowser specific
@Override
public void onSearchResultChanged(int seq, final String query, final int itemCount, final ParcelImpl libraryParams) throws RuntimeException {
    if (libraryParams == null) {
        return;
    }
    if (TextUtils.isEmpty(query)) {
        Log.w(TAG, "onSearchResultChanged(): Ignoring empty query");
        return;
    }
    if (itemCount < 0) {
        Log.w(TAG, "onSearchResultChanged(): Ignoring negative itemCount: " + itemCount);
        return;
    }
    dispatchBrowserTask(new BrowserTask() {

        @Override
        public void run(MediaBrowserImplBase browser) {
            browser.notifySearchResultChanged(query, itemCount, (LibraryParams) MediaUtils.fromParcelable(libraryParams));
        }
    });
}
#end_block

#method_before
@Override
public void onChildrenChanged(final String parentId, final int itemCount, final ParcelImpl libraryParams) {
    if (libraryParams == null) {
        return;
    }
    if (TextUtils.isEmpty(parentId)) {
        Log.w(TAG, "onChildrenChanged(): Ignoring empty parentId");
        return;
    }
    if (itemCount < 0) {
        Log.w(TAG, "onChildrenChanged(): Ignoring negative itemCount: " + itemCount);
        return;
    }
    dispatchBrowserTask(new BrowserTask() {

        @Override
        public void run(MediaBrowserImplBase browser) {
            browser.notifyChildrenChanged(parentId, itemCount, (LibraryParams) MediaUtils.fromParcelable(libraryParams));
        }
    });
}
#method_after
@Override
public void onChildrenChanged(int seq, final String parentId, final int itemCount, final ParcelImpl libraryParams) {
    if (libraryParams == null) {
        return;
    }
    if (TextUtils.isEmpty(parentId)) {
        Log.w(TAG, "onChildrenChanged(): Ignoring empty parentId");
        return;
    }
    if (itemCount < 0) {
        Log.w(TAG, "onChildrenChanged(): Ignoring negative itemCount: " + itemCount);
        return;
    }
    dispatchBrowserTask(new BrowserTask() {

        @Override
        public void run(MediaBrowserImplBase browser) {
            browser.notifyChildrenChanged(parentId, itemCount, (LibraryParams) MediaUtils.fromParcelable(libraryParams));
        }
    });
}
#end_block

#method_before
@Override
public void close() {
    synchronized (mLock) {
        if (isClosed()) {
            return;
        }
        if (DEBUG) {
            Log.d(TAG, "Closing session, id=" + getId() + ", token=" + getToken());
        }
        synchronized (MediaSessionImplBase.class) {
            SESSION_ID_LIST.remove(mSessionId);
        }
        mPlayer.unregisterPlayerCallback(mPlayerCallback);
        mSessionCompat.release();
        mCallback.onSessionClosed(mInstance);
        dispatchRemoteControllerCallbackTask(new RemoteControllerCallbackTask() {

            @Override
            public void run(ControllerCb callback) throws RemoteException {
                callback.onDisconnected();
            }
        });
        mHandler.removeCallbacksAndMessages(null);
        if (mHandlerThread.isAlive()) {
            if (Build.VERSION.SDK_INT >= 18) {
                mHandlerThread.quitSafely();
            } else {
                mHandlerThread.quit();
            }
        }
    }
}
#method_after
@Override
public void close() {
    synchronized (mLock) {
        if (isClosed()) {
            return;
        }
        if (DEBUG) {
            Log.d(TAG, "Closing session, id=" + getId() + ", token=" + getToken());
        }
        synchronized (MediaSessionImplBase.class) {
            SESSION_ID_LIST.remove(mSessionId);
        }
        mPlayer.unregisterPlayerCallback(mPlayerCallback);
        mSessionCompat.release();
        mCallback.onSessionClosed(mInstance);
        dispatchRemoteControllerTaskWithoutReturn(new RemoteControllerTask() {

            @Override
            public void run(ControllerCb callback, int seq) throws RemoteException {
                callback.onDisconnected(seq);
            }
        });
        mHandler.removeCallbacksAndMessages(null);
        if (mHandlerThread.isAlive()) {
            if (Build.VERSION.SDK_INT >= 18) {
                mHandlerThread.quitSafely();
            } else {
                mHandlerThread.quit();
            }
        }
    }
}
#end_block

#method_before
@Override
public void setAllowedCommands(@NonNull ControllerInfo controller, @NonNull final SessionCommandGroup commands) {
    if (mSessionStub.getConnectedControllersManager().isConnected(controller)) {
        mSessionStub.getConnectedControllersManager().updateAllowedCommands(controller, commands);
        dispatchRemoteControllerCallbackTask(controller, new RemoteControllerCallbackTask() {

            @Override
            public void run(ControllerCb callback) throws RemoteException {
                callback.onAllowedCommandsChanged(commands);
            }
        });
    } else {
        mSessionLegacyStub.getConnectedControllersManager().updateAllowedCommands(controller, commands);
    }
}
#method_after
@Override
public void setAllowedCommands(@NonNull ControllerInfo controller, @NonNull final SessionCommandGroup commands) {
    if (mSessionStub.getConnectedControllersManager().isConnected(controller)) {
        mSessionStub.getConnectedControllersManager().updateAllowedCommands(controller, commands);
        dispatchRemoteControllerTaskWithoutReturn(controller, new RemoteControllerTask() {

            @Override
            public void run(ControllerCb callback, int seq) throws RemoteException {
                callback.onAllowedCommandsChanged(seq, commands);
            }
        });
    } else {
        mSessionLegacyStub.getConnectedControllersManager().updateAllowedCommands(controller, commands);
    }
}
#end_block

#method_before
@Override
public void broadcastCustomCommand(@NonNull final SessionCommand command, @Nullable final Bundle args) {
    dispatchRemoteControllerTask(new RemoteControllerTask() {

        @Override
        public void run(ControllerCb controller, int seq) throws RemoteException {
            controller.sendCustomCommand(seq, command, args);
        }
    });
}
#method_after
@Override
public void broadcastCustomCommand(@NonNull final SessionCommand command, @Nullable final Bundle args) {
    dispatchRemoteControllerTaskWithoutReturn(new RemoteControllerTask() {

        @Override
        public void run(ControllerCb controller, int seq) throws RemoteException {
            controller.sendCustomCommand(seq, command, args);
        }
    });
}
#end_block

#method_before
@SuppressLint("WrongConstant")
private void notifyPlayerUpdatedNotLocked(SessionPlayer oldPlayer) {
    // Tells the playlist change first, to current item can change be notified with an item
    // within the playlist.
    List<MediaItem> oldPlaylist = oldPlayer.getPlaylist();
    final List<MediaItem> newPlaylist = getPlaylistOrNull();
    if (!ObjectsCompat.equals(oldPlaylist, newPlaylist)) {
        dispatchRemoteControllerCallbackTask(new RemoteControllerCallbackTask() {

            @Override
            public void run(ControllerCb callback) throws RemoteException {
                callback.onPlaylistChanged(newPlaylist, getPlaylistMetadata(), getCurrentMediaItemIndex(), getPreviousMediaItemIndex(), getNextMediaItemIndex());
            }
        });
    } else {
        MediaMetadata oldMetadata = oldPlayer.getPlaylistMetadata();
        final MediaMetadata newMetadata = getPlaylistMetadata();
        if (!ObjectsCompat.equals(oldMetadata, newMetadata)) {
            dispatchRemoteControllerCallbackTask(new RemoteControllerCallbackTask() {

                @Override
                public void run(ControllerCb callback) throws RemoteException {
                    callback.onPlaylistMetadataChanged(newMetadata);
                }
            });
        }
    }
    MediaItem oldCurrentItem = oldPlayer.getCurrentMediaItem();
    final MediaItem newCurrentItem = getCurrentMediaItemOrNull();
    if (!ObjectsCompat.equals(oldCurrentItem, newCurrentItem)) {
        dispatchRemoteControllerCallbackTask(new RemoteControllerCallbackTask() {

            @Override
            public void run(ControllerCb callback) throws RemoteException {
                callback.onCurrentMediaItemChanged(newCurrentItem, getCurrentMediaItemIndex(), getPreviousMediaItemIndex(), getNextMediaItemIndex());
            }
        });
    }
    @SessionPlayer.RepeatMode
    final int repeatMode = getRepeatMode();
    if (oldPlayer.getRepeatMode() != repeatMode) {
        dispatchRemoteControllerCallbackTask(new RemoteControllerCallbackTask() {

            @Override
            public void run(ControllerCb callback) throws RemoteException {
                callback.onRepeatModeChanged(repeatMode);
            }
        });
    }
    @SessionPlayer.ShuffleMode
    final int shuffleMode = getShuffleMode();
    if (oldPlayer.getShuffleMode() != shuffleMode) {
        dispatchRemoteControllerCallbackTask(new RemoteControllerCallbackTask() {

            @Override
            public void run(ControllerCb callback) throws RemoteException {
                callback.onShuffleModeChanged(shuffleMode);
            }
        });
    }
    // Always forcefully send the player state and buffered state to send the current position
    // and buffered position.
    final long currentTimeMs = SystemClock.elapsedRealtime();
    final long positionMs = getCurrentPosition();
    final int playerState = getPlayerState();
    dispatchRemoteControllerCallbackTask(new RemoteControllerCallbackTask() {

        @Override
        public void run(ControllerCb callback) throws RemoteException {
            callback.onPlayerStateChanged(currentTimeMs, positionMs, playerState);
        }
    });
    final MediaItem item = getCurrentMediaItemOrNull();
    if (item != null) {
        final int bufferingState = getBufferingState();
        final long bufferedPositionMs = getBufferedPosition();
        dispatchRemoteControllerCallbackTask(new RemoteControllerCallbackTask() {

            @Override
            public void run(ControllerCb callback) throws RemoteException {
                callback.onBufferingStateChanged(item, bufferingState, bufferedPositionMs, SystemClock.elapsedRealtime(), getCurrentPosition());
            }
        });
    }
    final float speed = getPlaybackSpeed();
    if (speed != oldPlayer.getPlaybackSpeed()) {
        dispatchRemoteControllerCallbackTask(new RemoteControllerCallbackTask() {

            @Override
            public void run(ControllerCb callback) throws RemoteException {
                callback.onPlaybackSpeedChanged(currentTimeMs, positionMs, speed);
            }
        });
    }
// Note: AudioInfo is updated outside of this API.
}
#method_after
@SuppressLint("WrongConstant")
private void notifyPlayerUpdatedNotLocked(SessionPlayer oldPlayer) {
    // Tells the playlist change first, to current item can change be notified with an item
    // within the playlist.
    List<MediaItem> oldPlaylist = oldPlayer.getPlaylist();
    final List<MediaItem> newPlaylist = getPlaylistOrNull();
    if (!ObjectsCompat.equals(oldPlaylist, newPlaylist)) {
        dispatchRemoteControllerTaskWithoutReturn(new RemoteControllerTask() {

            @Override
            public void run(ControllerCb callback, int seq) throws RemoteException {
                callback.onPlaylistChanged(seq, newPlaylist, getPlaylistMetadata(), getCurrentMediaItemIndex(), getPreviousMediaItemIndex(), getNextMediaItemIndex());
            }
        });
    } else {
        MediaMetadata oldMetadata = oldPlayer.getPlaylistMetadata();
        final MediaMetadata newMetadata = getPlaylistMetadata();
        if (!ObjectsCompat.equals(oldMetadata, newMetadata)) {
            dispatchRemoteControllerTaskWithoutReturn(new RemoteControllerTask() {

                @Override
                public void run(ControllerCb callback, int seq) throws RemoteException {
                    callback.onPlaylistMetadataChanged(seq, newMetadata);
                }
            });
        }
    }
    MediaItem oldCurrentItem = oldPlayer.getCurrentMediaItem();
    final MediaItem newCurrentItem = getCurrentMediaItemOrNull();
    if (!ObjectsCompat.equals(oldCurrentItem, newCurrentItem)) {
        dispatchRemoteControllerTaskWithoutReturn(new RemoteControllerTask() {

            @Override
            public void run(ControllerCb callback, int seq) throws RemoteException {
                callback.onCurrentMediaItemChanged(seq, newCurrentItem, getCurrentMediaItemIndex(), getPreviousMediaItemIndex(), getNextMediaItemIndex());
            }
        });
    }
    @SessionPlayer.RepeatMode
    final int repeatMode = getRepeatMode();
    if (oldPlayer.getRepeatMode() != repeatMode) {
        dispatchRemoteControllerTaskWithoutReturn(new RemoteControllerTask() {

            @Override
            public void run(ControllerCb callback, int seq) throws RemoteException {
                callback.onRepeatModeChanged(seq, repeatMode);
            }
        });
    }
    @SessionPlayer.ShuffleMode
    final int shuffleMode = getShuffleMode();
    if (oldPlayer.getShuffleMode() != shuffleMode) {
        dispatchRemoteControllerTaskWithoutReturn(new RemoteControllerTask() {

            @Override
            public void run(ControllerCb callback, int seq) throws RemoteException {
                callback.onShuffleModeChanged(seq, shuffleMode);
            }
        });
    }
    // Always forcefully send the player state and buffered state to send the current position
    // and buffered position.
    final long currentTimeMs = SystemClock.elapsedRealtime();
    final long positionMs = getCurrentPosition();
    final int playerState = getPlayerState();
    dispatchRemoteControllerTaskWithoutReturn(new RemoteControllerTask() {

        @Override
        public void run(ControllerCb callback, int seq) throws RemoteException {
            callback.onPlayerStateChanged(seq, currentTimeMs, positionMs, playerState);
        }
    });
    final MediaItem item = getCurrentMediaItemOrNull();
    if (item != null) {
        final int bufferingState = getBufferingState();
        final long bufferedPositionMs = getBufferedPosition();
        dispatchRemoteControllerTaskWithoutReturn(new RemoteControllerTask() {

            @Override
            public void run(ControllerCb callback, int seq) throws RemoteException {
                callback.onBufferingStateChanged(seq, item, bufferingState, bufferedPositionMs, SystemClock.elapsedRealtime(), getCurrentPosition());
            }
        });
    }
    final float speed = getPlaybackSpeed();
    if (speed != oldPlayer.getPlaybackSpeed()) {
        dispatchRemoteControllerTaskWithoutReturn(new RemoteControllerTask() {

            @Override
            public void run(ControllerCb callback, int seq) throws RemoteException {
                callback.onPlaybackSpeedChanged(seq, currentTimeMs, positionMs, speed);
            }
        });
    }
// Note: AudioInfo is updated outside of this API.
}
#end_block

#method_before
@SuppressWarnings("WeakerAccess")
/* synthetic access */
void notifyPlaybackInfoChangedNotLocked(final PlaybackInfo info) {
    dispatchRemoteControllerCallbackTask(new RemoteControllerCallbackTask() {

        @Override
        public void run(ControllerCb callback) throws RemoteException {
            callback.onPlaybackInfoChanged(info);
        }
    });
}
#method_after
@SuppressWarnings("WeakerAccess")
/* synthetic access */
void notifyPlaybackInfoChangedNotLocked(final PlaybackInfo info) {
    dispatchRemoteControllerTaskWithoutReturn(new RemoteControllerTask() {

        @Override
        public void run(ControllerCb callback, int seq) throws RemoteException {
            callback.onPlaybackInfoChanged(seq, info);
        }
    });
}
#end_block

#method_before
@Override
public void onCurrentMediaItemChanged(final SessionPlayer player, final MediaItem item) {
    final MediaSessionImplBase session = getSession();
    if (session == null || session.getPlayer() != player || player == null) {
        return;
    }
    synchronized (session.mLock) {
        if (mMediaItem != null) {
            mMediaItem.removeOnMetadataChangedListener(mCurrentItemChangedListener);
        }
        if (item != null) {
            item.addOnMetadataChangedListener(session.mCallbackExecutor, mCurrentItemChangedListener);
        }
        mMediaItem = item;
    }
    // Note: No sanity check whether the item is in the playlist.
    updateDurationIfNeeded(player, item);
    session.dispatchRemoteControllerCallbackTask(new RemoteControllerCallbackTask() {

        @Override
        public void run(ControllerCb callback) throws RemoteException {
            callback.onCurrentMediaItemChanged(item, session.getCurrentMediaItemIndex(), session.getPreviousMediaItemIndex(), session.getNextMediaItemIndex());
        }
    });
}
#method_after
@Override
public void onCurrentMediaItemChanged(final SessionPlayer player, final MediaItem item) {
    final MediaSessionImplBase session = getSession();
    if (session == null || session.getPlayer() != player || player == null) {
        return;
    }
    synchronized (session.mLock) {
        if (mMediaItem != null) {
            mMediaItem.removeOnMetadataChangedListener(mCurrentItemChangedListener);
        }
        if (item != null) {
            item.addOnMetadataChangedListener(session.mCallbackExecutor, mCurrentItemChangedListener);
        }
        mMediaItem = item;
    }
    // Note: No sanity check whether the item is in the playlist.
    updateDurationIfNeeded(player, item);
    session.dispatchRemoteControllerTaskWithoutReturn(new RemoteControllerTask() {

        @Override
        public void run(ControllerCb callback, int seq) throws RemoteException {
            callback.onCurrentMediaItemChanged(seq, item, session.getCurrentMediaItemIndex(), session.getPreviousMediaItemIndex(), session.getNextMediaItemIndex());
        }
    });
}
#end_block

#method_before
@Override
public void onPlayerStateChanged(final SessionPlayer player, final int state) {
    final MediaSessionImplBase session = getSession();
    if (session == null || session.getPlayer() != player || player == null) {
        return;
    }
    session.getCallback().onPlayerStateChanged(session.getInstance(), state);
    updateDurationIfNeeded(player, player.getCurrentMediaItem());
    session.dispatchRemoteControllerCallbackTask(new RemoteControllerCallbackTask() {

        @Override
        public void run(ControllerCb callback) throws RemoteException {
            callback.onPlayerStateChanged(SystemClock.elapsedRealtime(), player.getCurrentPosition(), state);
        }
    });
}
#method_after
@Override
public void onPlayerStateChanged(final SessionPlayer player, final int state) {
    final MediaSessionImplBase session = getSession();
    if (session == null || session.getPlayer() != player || player == null) {
        return;
    }
    session.getCallback().onPlayerStateChanged(session.getInstance(), state);
    updateDurationIfNeeded(player, player.getCurrentMediaItem());
    session.dispatchRemoteControllerTaskWithoutReturn(new RemoteControllerTask() {

        @Override
        public void run(ControllerCb callback, int seq) throws RemoteException {
            callback.onPlayerStateChanged(seq, SystemClock.elapsedRealtime(), player.getCurrentPosition(), state);
        }
    });
}
#end_block

#method_before
@Override
public void onBufferingStateChanged(final SessionPlayer player, final MediaItem item, final int state) {
    updateDurationIfNeeded(player, item);
    dispatchRemoteControllerTask(player, new RemoteControllerCallbackTask() {

        @Override
        public void run(ControllerCb callback) throws RemoteException {
            callback.onBufferingStateChanged(item, state, player.getBufferedPosition(), SystemClock.elapsedRealtime(), player.getCurrentPosition());
        }
    });
}
#method_after
@Override
public void onBufferingStateChanged(final SessionPlayer player, final MediaItem item, final int state) {
    updateDurationIfNeeded(player, item);
    dispatchRemoteControllerTask(player, new RemoteControllerTask() {

        @Override
        public void run(ControllerCb callback, int seq) throws RemoteException {
            callback.onBufferingStateChanged(seq, item, state, player.getBufferedPosition(), SystemClock.elapsedRealtime(), player.getCurrentPosition());
        }
    });
}
#end_block

#method_before
@Override
public void onPlaybackSpeedChanged(final SessionPlayer player, final float speed) {
    dispatchRemoteControllerTask(player, new RemoteControllerCallbackTask() {

        @Override
        public void run(ControllerCb callback) throws RemoteException {
            callback.onPlaybackSpeedChanged(SystemClock.elapsedRealtime(), player.getCurrentPosition(), speed);
        }
    });
}
#method_after
@Override
public void onPlaybackSpeedChanged(final SessionPlayer player, final float speed) {
    dispatchRemoteControllerTask(player, new RemoteControllerTask() {

        @Override
        public void run(ControllerCb callback, int seq) throws RemoteException {
            callback.onPlaybackSpeedChanged(seq, SystemClock.elapsedRealtime(), player.getCurrentPosition(), speed);
        }
    });
}
#end_block

#method_before
@Override
public void onSeekCompleted(final SessionPlayer player, final long position) {
    dispatchRemoteControllerTask(player, new RemoteControllerCallbackTask() {

        @Override
        public void run(ControllerCb callback) throws RemoteException {
            callback.onSeekCompleted(SystemClock.elapsedRealtime(), player.getCurrentPosition(), position);
        }
    });
}
#method_after
@Override
public void onSeekCompleted(final SessionPlayer player, final long position) {
    dispatchRemoteControllerTask(player, new RemoteControllerTask() {

        @Override
        public void run(ControllerCb callback, int seq) throws RemoteException {
            callback.onSeekCompleted(seq, SystemClock.elapsedRealtime(), player.getCurrentPosition(), position);
        }
    });
}
#end_block

#method_before
@Override
public void onPlaylistChanged(final SessionPlayer player, final List<MediaItem> list, final MediaMetadata metadata) {
    final MediaSessionImplBase session = getSession();
    if (session == null || session.getPlayer() != player || player == null) {
        return;
    }
    synchronized (session.mLock) {
        if (mList != null) {
            for (int i = 0; i < mList.size(); i++) {
                mList.get(i).removeOnMetadataChangedListener(mPlaylistItemChangedListener);
            }
        }
        if (list != null) {
            for (int i = 0; i < list.size(); i++) {
                list.get(i).addOnMetadataChangedListener(session.mCallbackExecutor, mPlaylistItemChangedListener);
            }
        }
        mList = list;
    }
    dispatchRemoteControllerTask(player, new RemoteControllerCallbackTask() {

        @Override
        public void run(ControllerCb callback) throws RemoteException {
            callback.onPlaylistChanged(list, metadata, session.getCurrentMediaItemIndex(), session.getPreviousMediaItemIndex(), session.getNextMediaItemIndex());
        }
    });
}
#method_after
@Override
public void onPlaylistChanged(final SessionPlayer player, final List<MediaItem> list, final MediaMetadata metadata) {
    final MediaSessionImplBase session = getSession();
    if (session == null || session.getPlayer() != player || player == null) {
        return;
    }
    synchronized (session.mLock) {
        if (mList != null) {
            for (int i = 0; i < mList.size(); i++) {
                mList.get(i).removeOnMetadataChangedListener(mPlaylistItemChangedListener);
            }
        }
        if (list != null) {
            for (int i = 0; i < list.size(); i++) {
                list.get(i).addOnMetadataChangedListener(session.mCallbackExecutor, mPlaylistItemChangedListener);
            }
        }
        mList = list;
    }
    dispatchRemoteControllerTask(player, new RemoteControllerTask() {

        @Override
        public void run(ControllerCb callback, int seq) throws RemoteException {
            callback.onPlaylistChanged(seq, list, metadata, session.getCurrentMediaItemIndex(), session.getPreviousMediaItemIndex(), session.getNextMediaItemIndex());
        }
    });
}
#end_block

#method_before
@Override
public void onPlaylistMetadataChanged(final SessionPlayer player, final MediaMetadata metadata) {
    dispatchRemoteControllerTask(player, new RemoteControllerCallbackTask() {

        @Override
        public void run(ControllerCb callback) throws RemoteException {
            callback.onPlaylistMetadataChanged(metadata);
        }
    });
}
#method_after
@Override
public void onPlaylistMetadataChanged(final SessionPlayer player, final MediaMetadata metadata) {
    dispatchRemoteControllerTask(player, new RemoteControllerTask() {

        @Override
        public void run(ControllerCb callback, int seq) throws RemoteException {
            callback.onPlaylistMetadataChanged(seq, metadata);
        }
    });
}
#end_block

#method_before
@Override
public void onRepeatModeChanged(final SessionPlayer player, final int repeatMode) {
    dispatchRemoteControllerTask(player, new RemoteControllerCallbackTask() {

        @Override
        public void run(ControllerCb callback) throws RemoteException {
            callback.onRepeatModeChanged(repeatMode);
        }
    });
}
#method_after
@Override
public void onRepeatModeChanged(final SessionPlayer player, final int repeatMode) {
    dispatchRemoteControllerTask(player, new RemoteControllerTask() {

        @Override
        public void run(ControllerCb callback, int seq) throws RemoteException {
            callback.onRepeatModeChanged(seq, repeatMode);
        }
    });
}
#end_block

#method_before
@Override
public void onShuffleModeChanged(final SessionPlayer player, final int shuffleMode) {
    dispatchRemoteControllerTask(player, new RemoteControllerCallbackTask() {

        @Override
        public void run(ControllerCb callback) throws RemoteException {
            callback.onShuffleModeChanged(shuffleMode);
        }
    });
}
#method_after
@Override
public void onShuffleModeChanged(final SessionPlayer player, final int shuffleMode) {
    dispatchRemoteControllerTask(player, new RemoteControllerTask() {

        @Override
        public void run(ControllerCb callback, int seq) throws RemoteException {
            callback.onShuffleModeChanged(seq, shuffleMode);
        }
    });
}
#end_block

#method_before
@Override
public void onPlaybackCompleted(SessionPlayer player) {
    dispatchRemoteControllerTask(player, new RemoteControllerCallbackTask() {

        @Override
        public void run(ControllerCb callback) throws RemoteException {
            callback.onPlaybackCompleted();
        }
    });
}
#method_after
@Override
public void onPlaybackCompleted(SessionPlayer player) {
    dispatchRemoteControllerTask(player, new RemoteControllerTask() {

        @Override
        public void run(ControllerCb callback, int seq) throws RemoteException {
            callback.onPlaybackCompleted(seq);
        }
    });
}
#end_block

#method_before
private void dispatchRemoteControllerTask(@NonNull SessionPlayer player, @NonNull RemoteControllerCallbackTask task) {
    final MediaSessionImplBase session = getSession();
    if (session == null || session.getPlayer() != player || player == null) {
        return;
    }
    session.dispatchRemoteControllerCallbackTask(task);
}
#method_after
private void dispatchRemoteControllerTask(@NonNull SessionPlayer player, @NonNull RemoteControllerTask task) {
    final MediaSessionImplBase session = getSession();
    if (session == null || session.getPlayer() != player || player == null) {
        return;
    }
    session.dispatchRemoteControllerTaskWithoutReturn(task);
}
#end_block

#method_before
private void updateDurationIfNeeded(@NonNull final SessionPlayer player, @Nullable final MediaItem item) {
    if (item == null) {
        return;
    }
    if (!item.equals(player.getCurrentMediaItem())) {
        return;
    }
    final long duration = player.getDuration();
    if (duration <= 0 || duration == UNKNOWN_TIME) {
        return;
    }
    MediaMetadata metadata = item.getMetadata();
    if (metadata != null) {
        if (!metadata.containsKey(METADATA_KEY_DURATION)) {
            metadata = new MediaMetadata.Builder(metadata).putLong(METADATA_KEY_DURATION, duration).build();
        } else {
            long durationFromMetadata = metadata.getLong(METADATA_KEY_DURATION);
            if (duration == durationFromMetadata) {
                return;
            }
            // Warns developers about the mismatch. Don't log media item here to keep
            // metadata secure.
            Log.w(TAG, "duration mismatch for an item." + " duration from player=" + duration + " duration from metadata=" + durationFromMetadata + ". May be a timing issue?");
        // Trust duration in the metadata set by developer.
        // In theory, duration may differ if the current item has been
        // changed before the getDuration(). So it's better not touch
        // duration set by developer.
        }
    } else {
        metadata = new MediaMetadata.Builder().putLong(METADATA_KEY_DURATION, duration).putString(METADATA_KEY_MEDIA_ID, item.getMediaId()).putLong(METADATA_KEY_PLAYABLE, 1).build();
    }
    if (metadata != null) {
        final MediaSessionImplBase session = getSession();
        item.setMetadata(metadata);
        dispatchRemoteControllerTask(player, new RemoteControllerCallbackTask() {

            @Override
            public void run(ControllerCb callback) throws RemoteException {
                callback.onPlaylistChanged(player.getPlaylist(), player.getPlaylistMetadata(), session.getCurrentMediaItemIndex(), session.getPreviousMediaItemIndex(), session.getNextMediaItemIndex());
            }
        });
    }
}
#method_after
private void updateDurationIfNeeded(@NonNull final SessionPlayer player, @Nullable final MediaItem item) {
    if (item == null) {
        return;
    }
    if (!item.equals(player.getCurrentMediaItem())) {
        return;
    }
    final long duration = player.getDuration();
    if (duration <= 0 || duration == UNKNOWN_TIME) {
        return;
    }
    MediaMetadata metadata = item.getMetadata();
    if (metadata != null) {
        if (!metadata.containsKey(METADATA_KEY_DURATION)) {
            metadata = new MediaMetadata.Builder(metadata).putLong(METADATA_KEY_DURATION, duration).build();
        } else {
            long durationFromMetadata = metadata.getLong(METADATA_KEY_DURATION);
            if (duration == durationFromMetadata) {
                return;
            }
            // Warns developers about the mismatch. Don't log media item here to keep
            // metadata secure.
            Log.w(TAG, "duration mismatch for an item." + " duration from player=" + duration + " duration from metadata=" + durationFromMetadata + ". May be a timing issue?");
        // Trust duration in the metadata set by developer.
        // In theory, duration may differ if the current item has been
        // changed before the getDuration(). So it's better not touch
        // duration set by developer.
        }
    } else {
        metadata = new MediaMetadata.Builder().putLong(METADATA_KEY_DURATION, duration).putString(METADATA_KEY_MEDIA_ID, item.getMediaId()).putLong(METADATA_KEY_PLAYABLE, 1).build();
    }
    if (metadata != null) {
        final MediaSessionImplBase session = getSession();
        item.setMetadata(metadata);
        dispatchRemoteControllerTask(player, new RemoteControllerTask() {

            @Override
            public void run(ControllerCb callback, int seq) throws RemoteException {
                callback.onPlaylistChanged(seq, player.getPlaylist(), player.getPlaylistMetadata(), session.getCurrentMediaItemIndex(), session.getPreviousMediaItemIndex(), session.getNextMediaItemIndex());
            }
        });
    }
}
#end_block

#method_before
@Override
public void onMetadataChanged(final MediaItem item) {
    final MediaSessionImplBase session = mSession.get();
    if (session == null || item == null) {
        return;
    }
    final MediaItem currentItem = session.getCurrentMediaItem();
    if (currentItem != null && item.equals(currentItem)) {
        session.dispatchRemoteControllerCallbackTask(new RemoteControllerCallbackTask() {

            @Override
            public void run(ControllerCb callback) throws RemoteException {
                callback.onCurrentMediaItemChanged(item, session.getCurrentMediaItemIndex(), session.getPreviousMediaItemIndex(), session.getNextMediaItemIndex());
            }
        });
    }
}
#method_after
@Override
public void onMetadataChanged(final MediaItem item) {
    final MediaSessionImplBase session = mSession.get();
    if (session == null || item == null) {
        return;
    }
    final MediaItem currentItem = session.getCurrentMediaItem();
    if (currentItem != null && item.equals(currentItem)) {
        session.dispatchRemoteControllerTaskWithoutReturn(new RemoteControllerTask() {

            @Override
            public void run(ControllerCb callback, int seq) throws RemoteException {
                callback.onCurrentMediaItemChanged(seq, item, session.getCurrentMediaItemIndex(), session.getPreviousMediaItemIndex(), session.getNextMediaItemIndex());
            }
        });
    }
}
#end_block

#method_before
@Override
public void onMetadataChanged(final MediaItem item) {
    final MediaSessionImplBase session = mSession.get();
    if (session == null || item == null) {
        return;
    }
    final List<MediaItem> list = session.getPlaylist();
    if (list == null) {
        return;
    }
    for (int i = 0; i < list.size(); i++) {
        if (item.equals(list.get(i))) {
            session.dispatchRemoteControllerCallbackTask(new RemoteControllerCallbackTask() {

                @Override
                public void run(ControllerCb callback) throws RemoteException {
                    callback.onPlaylistChanged(list, session.getPlaylistMetadata(), session.getCurrentMediaItemIndex(), session.getPreviousMediaItemIndex(), session.getNextMediaItemIndex());
                }
            });
            return;
        }
    }
}
#method_after
@Override
public void onMetadataChanged(final MediaItem item) {
    final MediaSessionImplBase session = mSession.get();
    if (session == null || item == null) {
        return;
    }
    final List<MediaItem> list = session.getPlaylist();
    if (list == null) {
        return;
    }
    for (int i = 0; i < list.size(); i++) {
        if (item.equals(list.get(i))) {
            session.dispatchRemoteControllerTaskWithoutReturn(new RemoteControllerTask() {

                @Override
                public void run(ControllerCb callback, int seq) throws RemoteException {
                    callback.onPlaylistChanged(seq, list, session.getPlaylistMetadata(), session.getCurrentMediaItemIndex(), session.getPreviousMediaItemIndex(), session.getNextMediaItemIndex());
                }
            });
            return;
        }
    }
}
#end_block

#method_before
@NonNull
public CommandButton build() {
    return new CommandButton(mCommand, mIconResId, mDisplayName, mExtras, mEnabled);
}
#method_after
@Override
@NonNull
public MediaSession build() {
    if (mCallbackExecutor == null) {
        mCallbackExecutor = ContextCompat.getMainExecutor(mContext);
    }
    if (mCallback == null) {
        mCallback = new SessionCallback() {
        };
    }
    return new MediaSession(mContext, mId, mPlayer, mSessionActivity, mCallbackExecutor, mCallback);
}
#end_block

#method_before
public void testContextSensitiveMonth_nonGregorianCalendar() {
    final String fmt = "MMMMM";
    final Locale ru = new Locale("ru");
    DateFormat dateFormat = new SimpleDateFormat(fmt, ru);
    NonGregorianCalendar cal = new NonGregorianCalendar();
    cal.clear();
    cal.setTimeZone(UTC);
    dateFormat.setCalendar(cal);
    // The RI forces standalone form here, which would be "".
    // Android does not force standalone form. http://b/66411240#comment7
    assertEquals("", dateFormat.format(new Date(0)));
}
#method_after
public void testContextSensitiveMonth_nonGregorianCalendar() {
    final String fmt = "MMMMM";
    final Locale ru = new Locale("ru");
    SimpleDateFormat dateFormat = new SimpleDateFormat(fmt, ru);
    NonGregorianCalendar cal = new NonGregorianCalendar();
    cal.clear();
    cal.setTimeZone(UTC);
    dateFormat.setCalendar(cal);
    // The RI forces standalone form here, which would be "".
    // Android does not force standalone form. http://b/66411240#comment7
    assertEquals("", dateFormat.format(new Date(0)));
}
#end_block

#method_before
private char[] compile(String pattern) {
    int length = pattern.length();
    boolean inQuote = false;
    StringBuilder compiledCode = new StringBuilder(length * 2);
    StringBuilder tmpBuffer = null;
    // BEGIN Android-changed: Dead code because we use ICU.
    // formatWeekday() reimplemented using ICU data and no longer uses forceStandaloneForm.
    /*
        int count = 0, tagcount = 0;
        int lastTag = -1, prevTag = -1;
        */
    int count = 0;
    int lastTag = -1;
    for (int i = 0; i < length; i++) {
        char c = pattern.charAt(i);
        if (c == '\'') {
            // in a quoted section.
            if ((i + 1) < length) {
                c = pattern.charAt(i + 1);
                if (c == '\'') {
                    i++;
                    if (count != 0) {
                        encode(lastTag, count, compiledCode);
                        // BEGIN Android-removed: Dead code because we use ICU.
                        // formatWeekday() reimplemented using ICU data and no longer uses
                        // forceStandaloneForm.
                        /*
                            tagcount++;
                            prevTag = lastTag;
                            */
                        // END Android-removed: Dead code because we use ICU.
                        lastTag = -1;
                        count = 0;
                    }
                    if (inQuote) {
                        tmpBuffer.append(c);
                    } else {
                        compiledCode.append((char) (TAG_QUOTE_ASCII_CHAR << 8 | c));
                    }
                    continue;
                }
            }
            if (!inQuote) {
                if (count != 0) {
                    encode(lastTag, count, compiledCode);
                    // BEGIN Android-removed: Dead code because we use ICU.
                    // formatWeekday() reimplemented using ICU data and no longer uses
                    // forceStandaloneForm.
                    /*
                        tagcount++;
                        prevTag = lastTag;
                        */
                    // END Android-removed: Dead code because we use ICU.
                    lastTag = -1;
                    count = 0;
                }
                if (tmpBuffer == null) {
                    tmpBuffer = new StringBuilder(length);
                } else {
                    tmpBuffer.setLength(0);
                }
                inQuote = true;
            } else {
                int len = tmpBuffer.length();
                if (len == 1) {
                    char ch = tmpBuffer.charAt(0);
                    if (ch < 128) {
                        compiledCode.append((char) (TAG_QUOTE_ASCII_CHAR << 8 | ch));
                    } else {
                        compiledCode.append((char) (TAG_QUOTE_CHARS << 8 | 1));
                        compiledCode.append(ch);
                    }
                } else {
                    encode(TAG_QUOTE_CHARS, len, compiledCode);
                    compiledCode.append(tmpBuffer);
                }
                inQuote = false;
            }
            continue;
        }
        if (inQuote) {
            tmpBuffer.append(c);
            continue;
        }
        if (!(c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z')) {
            if (count != 0) {
                encode(lastTag, count, compiledCode);
                // BEGIN Android-removed: Dead code because we use ICU.
                // formatWeekday() reimplemented using ICU data and no longer uses
                // forceStandaloneForm.
                /*
                    tagcount++;
                    prevTag = lastTag;
                    */
                // END Android-removed: Dead code because we use ICU.
                lastTag = -1;
                count = 0;
            }
            if (c < 128) {
                // In most cases, c would be a delimiter, such as ':'.
                compiledCode.append((char) (TAG_QUOTE_ASCII_CHAR << 8 | c));
            } else {
                // Take any contiguous non-ASCII alphabet characters and
                // put them in a single TAG_QUOTE_CHARS.
                int j;
                for (j = i + 1; j < length; j++) {
                    char d = pattern.charAt(j);
                    if (d == '\'' || (d >= 'a' && d <= 'z' || d >= 'A' && d <= 'Z')) {
                        break;
                    }
                }
                compiledCode.append((char) (TAG_QUOTE_CHARS << 8 | (j - i)));
                for (; i < j; i++) {
                    compiledCode.append(pattern.charAt(i));
                }
                i--;
            }
            continue;
        }
        int tag;
        if ((tag = DateFormatSymbols.patternChars.indexOf(c)) == -1) {
            throw new IllegalArgumentException("Illegal pattern character " + "'" + c + "'");
        }
        if (lastTag == -1 || lastTag == tag) {
            lastTag = tag;
            count++;
            continue;
        }
        encode(lastTag, count, compiledCode);
        // BEGIN Android-removed: Dead code because we use ICU.
        // formatWeekday() reimplemented using ICU data and no longer uses forceStandaloneForm.
        /*
            tagcount++;
            prevTag = lastTag;
            */
        // END Android-removed: Dead code because we use ICU.
        lastTag = tag;
        count = 1;
    }
    if (inQuote) {
        throw new IllegalArgumentException("Unterminated quote");
    }
    if (count != 0) {
        encode(lastTag, count, compiledCode);
    // BEGIN Android-removed: Dead code because we use ICU.
    // formatWeekday() reimplemented using ICU data and no longer uses forceStandaloneForm.
    /*
            tagcount++;
            prevTag = lastTag;
            */
    // END Android-removed: Dead code because we use ICU.
    }
    // Android-removed: Dead code because we use ICU.
    // formatWeekday() reimplemented using ICU data and no longer uses forceStandaloneForm.
    // forceStandaloneForm = (tagcount == 1 && prevTag == PATTERN_MONTH);
    // Copy the compiled pattern to a char array
    int len = compiledCode.length();
    char[] r = new char[len];
    compiledCode.getChars(0, len, r, 0);
    return r;
}
#method_after
private char[] compile(String pattern) {
    int length = pattern.length();
    boolean inQuote = false;
    StringBuilder compiledCode = new StringBuilder(length * 2);
    StringBuilder tmpBuffer = null;
    // BEGIN Android-removed: App compat for formatting pattern letter M.
    // See forceStandaloneForm field
    /*
        int count = 0, tagcount = 0;
        int lastTag = -1, prevTag = -1;
        */
    int count = 0;
    int lastTag = -1;
    for (int i = 0; i < length; i++) {
        char c = pattern.charAt(i);
        if (c == '\'') {
            // in a quoted section.
            if ((i + 1) < length) {
                c = pattern.charAt(i + 1);
                if (c == '\'') {
                    i++;
                    if (count != 0) {
                        encode(lastTag, count, compiledCode);
                        // BEGIN Android-removed: App compat for formatting pattern letter M.
                        // See forceStandaloneForm field
                        /*
                            tagcount++;
                            prevTag = lastTag;
                            */
                        // END Android-removed: App compat for formatting pattern letter M.
                        lastTag = -1;
                        count = 0;
                    }
                    if (inQuote) {
                        tmpBuffer.append(c);
                    } else {
                        compiledCode.append((char) (TAG_QUOTE_ASCII_CHAR << 8 | c));
                    }
                    continue;
                }
            }
            if (!inQuote) {
                if (count != 0) {
                    encode(lastTag, count, compiledCode);
                    // BEGIN Android-removed: App compat for formatting pattern letter M.
                    // See forceStandaloneForm field
                    /*
                        tagcount++;
                        prevTag = lastTag;
                        */
                    // END Android-removed: App compat for formatting pattern letter M.
                    lastTag = -1;
                    count = 0;
                }
                if (tmpBuffer == null) {
                    tmpBuffer = new StringBuilder(length);
                } else {
                    tmpBuffer.setLength(0);
                }
                inQuote = true;
            } else {
                int len = tmpBuffer.length();
                if (len == 1) {
                    char ch = tmpBuffer.charAt(0);
                    if (ch < 128) {
                        compiledCode.append((char) (TAG_QUOTE_ASCII_CHAR << 8 | ch));
                    } else {
                        compiledCode.append((char) (TAG_QUOTE_CHARS << 8 | 1));
                        compiledCode.append(ch);
                    }
                } else {
                    encode(TAG_QUOTE_CHARS, len, compiledCode);
                    compiledCode.append(tmpBuffer);
                }
                inQuote = false;
            }
            continue;
        }
        if (inQuote) {
            tmpBuffer.append(c);
            continue;
        }
        if (!(c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z')) {
            if (count != 0) {
                encode(lastTag, count, compiledCode);
                // BEGIN Android-removed: App compat for formatting pattern letter M.
                // See forceStandaloneForm field
                /*
                    tagcount++;
                    prevTag = lastTag;
                    */
                // END Android-removed: App compat for formatting pattern letter M.
                lastTag = -1;
                count = 0;
            }
            if (c < 128) {
                // In most cases, c would be a delimiter, such as ':'.
                compiledCode.append((char) (TAG_QUOTE_ASCII_CHAR << 8 | c));
            } else {
                // Take any contiguous non-ASCII alphabet characters and
                // put them in a single TAG_QUOTE_CHARS.
                int j;
                for (j = i + 1; j < length; j++) {
                    char d = pattern.charAt(j);
                    if (d == '\'' || (d >= 'a' && d <= 'z' || d >= 'A' && d <= 'Z')) {
                        break;
                    }
                }
                compiledCode.append((char) (TAG_QUOTE_CHARS << 8 | (j - i)));
                for (; i < j; i++) {
                    compiledCode.append(pattern.charAt(i));
                }
                i--;
            }
            continue;
        }
        int tag;
        if ((tag = DateFormatSymbols.patternChars.indexOf(c)) == -1) {
            throw new IllegalArgumentException("Illegal pattern character " + "'" + c + "'");
        }
        if (lastTag == -1 || lastTag == tag) {
            lastTag = tag;
            count++;
            continue;
        }
        encode(lastTag, count, compiledCode);
        // BEGIN Android-removed: App compat for formatting pattern letter M.
        // See forceStandaloneForm field
        /*
            tagcount++;
            prevTag = lastTag;
            */
        // END Android-removed: App compat for formatting pattern letter M.
        lastTag = tag;
        count = 1;
    }
    if (inQuote) {
        throw new IllegalArgumentException("Unterminated quote");
    }
    if (count != 0) {
        encode(lastTag, count, compiledCode);
    // BEGIN Android-removed: App compat for formatting pattern letter M.
    // See forceStandaloneForm field
    /*
            tagcount++;
            prevTag = lastTag;
            */
    // END Android-removed: App compat for formatting pattern letter M.
    }
    // Android-removed: App compat for formatting pattern letter M.
    // See forceStandaloneForm field
    // forceStandaloneForm = (tagcount == 1 && prevTag == PATTERN_MONTH);
    // Copy the compiled pattern to a char array
    int len = compiledCode.length();
    char[] r = new char[len];
    compiledCode.getChars(0, len, r, 0);
    return r;
}
#end_block

#method_before
private void subFormat(int patternCharIndex, int count, FieldDelegate delegate, StringBuffer buffer, boolean useDateFormatSymbols) {
    int maxIntCount = Integer.MAX_VALUE;
    String current = null;
    int beginOffset = buffer.length();
    int field = PATTERN_INDEX_TO_CALENDAR_FIELD[patternCharIndex];
    int value;
    if (field == CalendarBuilder.WEEK_YEAR) {
        if (calendar.isWeekDateSupported()) {
            value = calendar.getWeekYear();
        } else {
            // use calendar year 'y' instead
            patternCharIndex = PATTERN_YEAR;
            field = PATTERN_INDEX_TO_CALENDAR_FIELD[patternCharIndex];
            value = calendar.get(field);
        }
    } else if (field == CalendarBuilder.ISO_DAY_OF_WEEK) {
        value = CalendarBuilder.toISODayOfWeek(calendar.get(Calendar.DAY_OF_WEEK));
    } else {
        value = calendar.get(field);
    }
    int style = (count >= 4) ? Calendar.LONG : Calendar.SHORT;
    if (!useDateFormatSymbols && field != CalendarBuilder.ISO_DAY_OF_WEEK) {
        current = calendar.getDisplayName(field, style, locale);
    }
    switch(patternCharIndex) {
        case // 'G'
        PATTERN_ERA:
            if (useDateFormatSymbols) {
                String[] eras = formatData.getEras();
                if (value < eras.length) {
                    current = eras[value];
                }
            }
            if (current == null) {
                current = "";
            }
            break;
        // 'Y'
        case PATTERN_WEEK_YEAR:
        case // 'y'
        PATTERN_YEAR:
            if (calendar instanceof GregorianCalendar) {
                if (count != 2) {
                    zeroPaddingNumber(value, count, maxIntCount, buffer);
                } else {
                    zeroPaddingNumber(value, 2, 2, buffer);
                }
            // clip 1996 to 96
            } else {
                if (current == null) {
                    zeroPaddingNumber(value, style == Calendar.LONG ? 1 : count, maxIntCount, buffer);
                }
            }
            break;
        case // 'M' (context seinsive)
        PATTERN_MONTH:
            if (useDateFormatSymbols) {
                // BEGIN Android-changed: formatMonth() method to format using ICU data.
                /*
                String[] months;
                if (count >= 4) {
                    months = formatData.getMonths();
                    current = months[value];
                } else if (count == 3) {
                    months = formatData.getShortMonths();
                    current = months[value];
                }
            } else {
                if (count < 3) {
                    current = null;
                } else if (forceStandaloneForm) {
                    current = calendar.getDisplayName(field, style | 0x8000, locale);
                    if (current == null) {
                        current = calendar.getDisplayName(field, style, locale);
                    }
                }
            }
            if (current == null) {
                zeroPaddingNumber(value+1, count, maxIntCount, buffer);
            }
            */
                current = formatMonth(count, value, maxIntCount, buffer, useDateFormatSymbols, false);
            // END Android-changed: formatMonth() method to format using ICU data.
            }
            break;
        case // 'L'
        PATTERN_MONTH_STANDALONE:
            /*
            assert current == null;
            if (locale == null) {
                String[] months;
                if (count >= 4) {
                    months = formatData.getMonths();
                    current = months[value];
                } else if (count == 3) {
                    months = formatData.getShortMonths();
                    current = months[value];
                }
            } else {
                if (count >= 3) {
                    current = calendar.getDisplayName(field, style | 0x8000, locale);
                }
            }
            if (current == null) {
                zeroPaddingNumber(value+1, count, maxIntCount, buffer);
            */
            if (useDateFormatSymbols) {
                current = formatMonth(count, value, maxIntCount, buffer, useDateFormatSymbols, true);
            // END Android-changed: formatMonth() method to format using ICU data.
            }
            break;
        case // 'k' 1-based.  eg, 23:59 + 1 hour =>> 24:59
        PATTERN_HOUR_OF_DAY1:
            if (current == null) {
                if (value == 0) {
                    zeroPaddingNumber(calendar.getMaximum(Calendar.HOUR_OF_DAY) + 1, count, maxIntCount, buffer);
                } else {
                    zeroPaddingNumber(value, count, maxIntCount, buffer);
                }
            }
            break;
        case // 'E'
        PATTERN_DAY_OF_WEEK:
            /*
            if (useDateFormatSymbols) {
                String[] weekdays;
                if (count >= 4) {
                    weekdays = formatData.getWeekdays();
                    current = weekdays[value];
                } else { // count < 4, use abbreviated form if exists
                    weekdays = formatData.getShortWeekdays();
                    current = weekdays[value];
                }
            }
            */
            if (current == null) {
                current = formatWeekday(count, value, useDateFormatSymbols, false);
            }
            // END Android-changed: formatWeekday() method to format using ICU data.
            break;
        // BEGIN Android-added: support for 'c' (standalone day of week).
        case // 'c'
        PATTERN_STANDALONE_DAY_OF_WEEK:
            if (current == null) {
                current = formatWeekday(count, value, useDateFormatSymbols, true);
            }
            break;
        case // 'a'
        PATTERN_AM_PM:
            if (useDateFormatSymbols) {
                String[] ampm = formatData.getAmPmStrings();
                current = ampm[value];
            }
            break;
        // Not currently supported here.
        case PATTERN_DAY_PERIOD:
        case PATTERN_FLEXIBLE_DAY_PERIOD:
            current = "";
            break;
        case // 'h' 1-based.  eg, 11PM + 1 hour =>> 12 AM
        PATTERN_HOUR1:
            if (current == null) {
                if (value == 0) {
                    zeroPaddingNumber(calendar.getLeastMaximum(Calendar.HOUR) + 1, count, maxIntCount, buffer);
                } else {
                    zeroPaddingNumber(value, count, maxIntCount, buffer);
                }
            }
            break;
        case // 'z'
        PATTERN_ZONE_NAME:
            if (current == null) {
                // BEGIN Android-changed: Format time zone name using ICU.
                /*
                if (formatData.locale == null || formatData.isZoneStringsSet) {
                    int zoneIndex =
                        formatData.getZoneIndex(calendar.getTimeZone().getID());
                    if (zoneIndex == -1) {
                        value = calendar.get(Calendar.ZONE_OFFSET) +
                            calendar.get(Calendar.DST_OFFSET);
                        buffer.append(ZoneInfoFile.toCustomID(value));
                    } else {
                        int index = (calendar.get(Calendar.DST_OFFSET) == 0) ? 1: 3;
                        if (count < 4) {
                            // Use the short name
                            index++;
                        }
                        String[][] zoneStrings = formatData.getZoneStringsWrapper();
                        buffer.append(zoneStrings[zoneIndex][index]);
                    }
                } else {
                    TimeZone tz = calendar.getTimeZone();
                    boolean daylight = (calendar.get(Calendar.DST_OFFSET) != 0);
                    int tzstyle = (count < 4 ? TimeZone.SHORT : TimeZone.LONG);
                    buffer.append(tz.getDisplayName(daylight, tzstyle, formatData.locale));
                }
                */
                TimeZone tz = calendar.getTimeZone();
                boolean daylight = (calendar.get(Calendar.DST_OFFSET) != 0);
                String zoneString;
                if (formatData.isZoneStringsSet) {
                    // DateFormatSymbols.setZoneStrings() has be used, use those values instead of
                    // ICU code.
                    int tzstyle = count < 4 ? TimeZone.SHORT : TimeZone.LONG;
                    zoneString = libcore.icu.TimeZoneNames.getDisplayName(formatData.getZoneStringsWrapper(), tz.getID(), daylight, tzstyle);
                } else {
                    TimeZoneNames.NameType nameType;
                    if (count < 4) {
                        nameType = daylight ? TimeZoneNames.NameType.SHORT_DAYLIGHT : TimeZoneNames.NameType.SHORT_STANDARD;
                    } else {
                        nameType = daylight ? TimeZoneNames.NameType.LONG_DAYLIGHT : TimeZoneNames.NameType.LONG_STANDARD;
                    }
                    String canonicalID = android.icu.util.TimeZone.getCanonicalID(tz.getID());
                    zoneString = getTimeZoneNames().getDisplayName(canonicalID, nameType, calendar.getTimeInMillis());
                }
                if (zoneString != null) {
                    buffer.append(zoneString);
                } else {
                    int offsetMillis = calendar.get(Calendar.ZONE_OFFSET) + calendar.get(Calendar.DST_OFFSET);
                    buffer.append(TimeZone.createGmtOffsetString(true, true, offsetMillis));
                }
            // END Android-changed: Format time zone name using ICU.
            }
            break;
        case // 'Z' ("-/+hhmm" form)
        PATTERN_ZONE_VALUE:
            // BEGIN Android-changed: Use shared code in TimeZone for zone offset string.
            /*
            value = (calendar.get(Calendar.ZONE_OFFSET) +
                     calendar.get(Calendar.DST_OFFSET)) / 60000;

            int width = 4;
            if (value >= 0) {
                buffer.append('+');
            } else {
                width++;
            }

            int num = (value / 60) * 100 + (value % 60);
            CalendarUtils.sprintf0d(buffer, num, width);
            */
            value = calendar.get(Calendar.ZONE_OFFSET) + calendar.get(Calendar.DST_OFFSET);
            final boolean includeSeparator = (count >= 4);
            final boolean includeGmt = (count == 4);
            buffer.append(TimeZone.createGmtOffsetString(includeGmt, includeSeparator, value));
            break;
        case // 'X'
        PATTERN_ISO_ZONE:
            value = calendar.get(Calendar.ZONE_OFFSET) + calendar.get(Calendar.DST_OFFSET);
            if (value == 0) {
                buffer.append('Z');
                break;
            }
            value /= 60000;
            if (value >= 0) {
                buffer.append('+');
            } else {
                buffer.append('-');
                value = -value;
            }
            CalendarUtils.sprintf0d(buffer, value / 60, 2);
            if (count == 1) {
                break;
            }
            if (count == 3) {
                buffer.append(':');
            }
            CalendarUtils.sprintf0d(buffer, value % 60, 2);
            break;
        // BEGIN Android-added: Better UTS#35 conformity for fractional seconds.
        case // 'S'
        PATTERN_MILLISECOND:
            // in the resulting formatted output.
            if (current == null) {
                value = (int) (((double) value / 1000) * Math.pow(10, count));
                zeroPaddingNumber(value, count, count, buffer);
            }
            break;
        default:
            // case PATTERN_ISO_DAY_OF_WEEK:      // 'u' pseudo field, Monday = 1, ..., Sunday = 7
            if (current == null) {
                zeroPaddingNumber(value, count, maxIntCount, buffer);
            }
            break;
    }
    if (current != null) {
        buffer.append(current);
    }
    int fieldID = PATTERN_INDEX_TO_DATE_FORMAT_FIELD[patternCharIndex];
    Field f = PATTERN_INDEX_TO_DATE_FORMAT_FIELD_ID[patternCharIndex];
    delegate.formatted(fieldID, f, f, beginOffset, buffer.length(), buffer);
}
#method_after
private void subFormat(int patternCharIndex, int count, FieldDelegate delegate, StringBuffer buffer, boolean useDateFormatSymbols) {
    int maxIntCount = Integer.MAX_VALUE;
    String current = null;
    int beginOffset = buffer.length();
    int field = PATTERN_INDEX_TO_CALENDAR_FIELD[patternCharIndex];
    int value;
    if (field == CalendarBuilder.WEEK_YEAR) {
        if (calendar.isWeekDateSupported()) {
            value = calendar.getWeekYear();
        } else {
            // use calendar year 'y' instead
            patternCharIndex = PATTERN_YEAR;
            field = PATTERN_INDEX_TO_CALENDAR_FIELD[patternCharIndex];
            value = calendar.get(field);
        }
    } else if (field == CalendarBuilder.ISO_DAY_OF_WEEK) {
        value = CalendarBuilder.toISODayOfWeek(calendar.get(Calendar.DAY_OF_WEEK));
    } else {
        value = calendar.get(field);
    }
    int style = (count >= 4) ? Calendar.LONG : Calendar.SHORT;
    if (!useDateFormatSymbols && field != CalendarBuilder.ISO_DAY_OF_WEEK) {
        current = calendar.getDisplayName(field, style, locale);
    }
    switch(patternCharIndex) {
        case // 'G'
        PATTERN_ERA:
            if (useDateFormatSymbols) {
                String[] eras = formatData.getEras();
                if (value < eras.length) {
                    current = eras[value];
                }
            }
            if (current == null) {
                current = "";
            }
            break;
        // 'Y'
        case PATTERN_WEEK_YEAR:
        case // 'y'
        PATTERN_YEAR:
            if (calendar instanceof GregorianCalendar) {
                if (count != 2) {
                    zeroPaddingNumber(value, count, maxIntCount, buffer);
                } else {
                    zeroPaddingNumber(value, 2, 2, buffer);
                }
            // clip 1996 to 96
            } else {
                if (current == null) {
                    zeroPaddingNumber(value, style == Calendar.LONG ? 1 : count, maxIntCount, buffer);
                }
            }
            break;
        case // 'M' (context seinsive)
        PATTERN_MONTH:
            if (useDateFormatSymbols) {
                // BEGIN Android-changed: formatMonth() method to format using ICU data.
                /*
                String[] months;
                if (count >= 4) {
                    months = formatData.getMonths();
                    current = months[value];
                } else if (count == 3) {
                    months = formatData.getShortMonths();
                    current = months[value];
                }
            } else {
                if (count < 3) {
                    current = null;
                } else if (forceStandaloneForm) {
                    current = calendar.getDisplayName(field, style | 0x8000, locale);
                    if (current == null) {
                        current = calendar.getDisplayName(field, style, locale);
                    }
                }
            }
            if (current == null) {
                zeroPaddingNumber(value+1, count, maxIntCount, buffer);
            }
            */
                current = formatMonth(count, value, maxIntCount, buffer, useDateFormatSymbols, false);
            // END Android-changed: formatMonth() method to format using ICU data.
            }
            break;
        case // 'L'
        PATTERN_MONTH_STANDALONE:
            /*
            assert current == null;
            if (locale == null) {
                String[] months;
                if (count >= 4) {
                    months = formatData.getMonths();
                    current = months[value];
                } else if (count == 3) {
                    months = formatData.getShortMonths();
                    current = months[value];
                }
            } else {
                if (count >= 3) {
                    current = calendar.getDisplayName(field, style | 0x8000, locale);
                }
            }
            if (current == null) {
                zeroPaddingNumber(value+1, count, maxIntCount, buffer);
            */
            if (useDateFormatSymbols) {
                current = formatMonth(count, value, maxIntCount, buffer, useDateFormatSymbols, true);
            // END Android-changed: formatMonth() method to format using ICU data.
            }
            break;
        case // 'k' 1-based.  eg, 23:59 + 1 hour =>> 24:59
        PATTERN_HOUR_OF_DAY1:
            if (current == null) {
                if (value == 0) {
                    zeroPaddingNumber(calendar.getMaximum(Calendar.HOUR_OF_DAY) + 1, count, maxIntCount, buffer);
                } else {
                    zeroPaddingNumber(value, count, maxIntCount, buffer);
                }
            }
            break;
        case // 'E'
        PATTERN_DAY_OF_WEEK:
            /*
            if (useDateFormatSymbols) {
                String[] weekdays;
                if (count >= 4) {
                    weekdays = formatData.getWeekdays();
                    current = weekdays[value];
                } else { // count < 4, use abbreviated form if exists
                    weekdays = formatData.getShortWeekdays();
                    current = weekdays[value];
                }
            }
            */
            if (current == null) {
                current = formatWeekday(count, value, useDateFormatSymbols, false);
            }
            // END Android-removed: App compat for formatting pattern letter M.
            break;
        // BEGIN Android-added: support for 'c' (standalone day of week).
        case // 'c'
        PATTERN_STANDALONE_DAY_OF_WEEK:
            if (current == null) {
                current = formatWeekday(count, value, useDateFormatSymbols, true);
            }
            break;
        case // 'a'
        PATTERN_AM_PM:
            if (useDateFormatSymbols) {
                String[] ampm = formatData.getAmPmStrings();
                current = ampm[value];
            }
            break;
        // Not currently supported here.
        case PATTERN_DAY_PERIOD:
        case PATTERN_FLEXIBLE_DAY_PERIOD:
            current = "";
            break;
        case // 'h' 1-based.  eg, 11PM + 1 hour =>> 12 AM
        PATTERN_HOUR1:
            if (current == null) {
                if (value == 0) {
                    zeroPaddingNumber(calendar.getLeastMaximum(Calendar.HOUR) + 1, count, maxIntCount, buffer);
                } else {
                    zeroPaddingNumber(value, count, maxIntCount, buffer);
                }
            }
            break;
        case // 'z'
        PATTERN_ZONE_NAME:
            if (current == null) {
                // BEGIN Android-changed: Format time zone name using ICU.
                /*
                if (formatData.locale == null || formatData.isZoneStringsSet) {
                    int zoneIndex =
                        formatData.getZoneIndex(calendar.getTimeZone().getID());
                    if (zoneIndex == -1) {
                        value = calendar.get(Calendar.ZONE_OFFSET) +
                            calendar.get(Calendar.DST_OFFSET);
                        buffer.append(ZoneInfoFile.toCustomID(value));
                    } else {
                        int index = (calendar.get(Calendar.DST_OFFSET) == 0) ? 1: 3;
                        if (count < 4) {
                            // Use the short name
                            index++;
                        }
                        String[][] zoneStrings = formatData.getZoneStringsWrapper();
                        buffer.append(zoneStrings[zoneIndex][index]);
                    }
                } else {
                    TimeZone tz = calendar.getTimeZone();
                    boolean daylight = (calendar.get(Calendar.DST_OFFSET) != 0);
                    int tzstyle = (count < 4 ? TimeZone.SHORT : TimeZone.LONG);
                    buffer.append(tz.getDisplayName(daylight, tzstyle, formatData.locale));
                }
                */
                TimeZone tz = calendar.getTimeZone();
                boolean daylight = (calendar.get(Calendar.DST_OFFSET) != 0);
                String zoneString;
                if (formatData.isZoneStringsSet) {
                    // DateFormatSymbols.setZoneStrings() has be used, use those values instead of
                    // ICU code.
                    int tzstyle = count < 4 ? TimeZone.SHORT : TimeZone.LONG;
                    zoneString = libcore.icu.TimeZoneNames.getDisplayName(formatData.getZoneStringsWrapper(), tz.getID(), daylight, tzstyle);
                } else {
                    TimeZoneNames.NameType nameType;
                    if (count < 4) {
                        nameType = daylight ? TimeZoneNames.NameType.SHORT_DAYLIGHT : TimeZoneNames.NameType.SHORT_STANDARD;
                    } else {
                        nameType = daylight ? TimeZoneNames.NameType.LONG_DAYLIGHT : TimeZoneNames.NameType.LONG_STANDARD;
                    }
                    String canonicalID = android.icu.util.TimeZone.getCanonicalID(tz.getID());
                    zoneString = getTimeZoneNames().getDisplayName(canonicalID, nameType, calendar.getTimeInMillis());
                }
                if (zoneString != null) {
                    buffer.append(zoneString);
                } else {
                    int offsetMillis = calendar.get(Calendar.ZONE_OFFSET) + calendar.get(Calendar.DST_OFFSET);
                    buffer.append(TimeZone.createGmtOffsetString(true, true, offsetMillis));
                }
            // END Android-changed: Format time zone name using ICU.
            }
            break;
        case // 'Z' ("-/+hhmm" form)
        PATTERN_ZONE_VALUE:
            // BEGIN Android-changed: Use shared code in TimeZone for zone offset string.
            /*
            value = (calendar.get(Calendar.ZONE_OFFSET) +
                     calendar.get(Calendar.DST_OFFSET)) / 60000;

            int width = 4;
            if (value >= 0) {
                buffer.append('+');
            } else {
                width++;
            }

            int num = (value / 60) * 100 + (value % 60);
            CalendarUtils.sprintf0d(buffer, num, width);
            */
            value = calendar.get(Calendar.ZONE_OFFSET) + calendar.get(Calendar.DST_OFFSET);
            final boolean includeSeparator = (count >= 4);
            final boolean includeGmt = (count == 4);
            buffer.append(TimeZone.createGmtOffsetString(includeGmt, includeSeparator, value));
            break;
        case // 'X'
        PATTERN_ISO_ZONE:
            value = calendar.get(Calendar.ZONE_OFFSET) + calendar.get(Calendar.DST_OFFSET);
            if (value == 0) {
                buffer.append('Z');
                break;
            }
            value /= 60000;
            if (value >= 0) {
                buffer.append('+');
            } else {
                buffer.append('-');
                value = -value;
            }
            CalendarUtils.sprintf0d(buffer, value / 60, 2);
            if (count == 1) {
                break;
            }
            if (count == 3) {
                buffer.append(':');
            }
            CalendarUtils.sprintf0d(buffer, value % 60, 2);
            break;
        // BEGIN Android-added: Better UTS#35 conformity for fractional seconds.
        case // 'S'
        PATTERN_MILLISECOND:
            // in the resulting formatted output.
            if (current == null) {
                value = (int) (((double) value / 1000) * Math.pow(10, count));
                zeroPaddingNumber(value, count, count, buffer);
            }
            break;
        default:
            // case PATTERN_ISO_DAY_OF_WEEK:      // 'u' pseudo field, Monday = 1, ..., Sunday = 7
            if (current == null) {
                zeroPaddingNumber(value, count, maxIntCount, buffer);
            }
            break;
    }
    if (current != null) {
        buffer.append(current);
    }
    int fieldID = PATTERN_INDEX_TO_DATE_FORMAT_FIELD[patternCharIndex];
    Field f = PATTERN_INDEX_TO_DATE_FORMAT_FIELD_ID[patternCharIndex];
    delegate.formatted(fieldID, f, f, beginOffset, buffer.length(), buffer);
}
#end_block

#method_before
@NonNull
public OnNavigateUpListener getFallbackOnNavigateUpListener() {
    return mFallbackOnNavigateUpListener;
}
#method_after
@Nullable
public OnNavigateUpListener getFallbackOnNavigateUpListener() {
    return mFallbackOnNavigateUpListener;
}
#end_block

#method_before
public static boolean navigateUp(@NonNull NavController navController, @NonNull AppBarConfiguration configuration) {
    DrawerLayout drawerLayout = configuration.getDrawerLayout();
    NavDestination currentDestination = navController.getCurrentDestination();
    Set<Integer> topLevelDestinations = configuration.getTopLevelDestinations();
    if (drawerLayout != null && currentDestination != null && matchDestinations(currentDestination, topLevelDestinations)) {
        drawerLayout.openDrawer(GravityCompat.START);
        return true;
    } else {
        return navController.navigateUp() || configuration.getFallbackOnNavigateUpListener().onNavigateUp();
    }
}
#method_after
public static boolean navigateUp(@NonNull NavController navController, @NonNull AppBarConfiguration configuration) {
    DrawerLayout drawerLayout = configuration.getDrawerLayout();
    NavDestination currentDestination = navController.getCurrentDestination();
    Set<Integer> topLevelDestinations = configuration.getTopLevelDestinations();
    if (drawerLayout != null && currentDestination != null && matchDestinations(currentDestination, topLevelDestinations)) {
        drawerLayout.openDrawer(GravityCompat.START);
        return true;
    } else {
        if (navController.navigateUp()) {
            return true;
        } else if (configuration.getFallbackOnNavigateUpListener() != null) {
            return configuration.getFallbackOnNavigateUpListener().onNavigateUp();
        } else {
            return false;
        }
    }
}
#end_block

#method_before
@Before
public void setUp() throws Throwable {
    Activity activity = mActivityTestRule.getActivity();
    TestUtils.setKeepScreenOn(mActivityTestRule, activity);
    mContext = activity;
    mReceiver = BlockingReceiver.registerForPendingIntent(mContext);
    final PendingIntent intent = mReceiver.getPendingIntent();
    mTextClassifier = new TextClassifier() {

        @Override
        public TextClassification classifyText(@NonNull TextClassification.Request r) {
            final RemoteActionCompat remoteAction = new RemoteActionCompat(ICON, ITEM, "desc", intent);
            remoteAction.setShouldShowIcon(false);
            return new TextClassification.Builder().addAction(remoteAction).build();
        }
    };
    final Map<String, Float> scores = new ArrayMap<>();
    scores.put(TextClassifier.TYPE_EMAIL, 1f);
    mTextLink = new TextLink(0, ENTITY.length(), scores);
}
#method_after
@Before
public void setUp() throws Throwable {
    Activity activity = mActivityTestRule.getActivity();
    TestUtils.keepScreenOn(mActivityTestRule, activity);
    mContext = activity;
    mReceiver = BlockingReceiver.registerForPendingIntent(mContext);
    final PendingIntent intent = mReceiver.getPendingIntent();
    mTextClassifier = new TextClassifier() {

        @Override
        public TextClassification classifyText(@NonNull TextClassification.Request r) {
            final RemoteActionCompat remoteAction = new RemoteActionCompat(ICON, ITEM, "desc", intent);
            remoteAction.setShouldShowIcon(false);
            return new TextClassification.Builder().addAction(remoteAction).build();
        }
    };
    final Map<String, Float> scores = new ArrayMap<>();
    scores.put(TextClassifier.TYPE_EMAIL, 1f);
    mTextLink = new TextLink(0, ENTITY.length(), scores);
}
#end_block

#method_before
@NonNull
public Request build() {
    return new Request(mText, mStartIndex, mEndIndex, mDefaultLocales, mReferenceTime, mExtras == null ? Bundle.EMPTY : BundleUtils.deepCopy(mExtras));
}
#method_after
@NonNull
public TextClassification build() {
    return new TextClassification(mText, mActions, new EntityConfidence(mEntityConfidence), mId, mExtras == null ? Bundle.EMPTY : BundleUtils.deepCopy(mExtras));
}
#end_block

#method_before
@Before
public void setUp() throws Throwable {
    final Activity activity = mActivityTestRule.getActivity();
    TestUtils.setKeepScreenOn(mActivityTestRule, activity);
    mContext = activity;
    final SupportMenu menu = new MenuBuilder(mContext);
    menu.add("One");
    menu.add("Two");
    menu.add("Three");
    mWidget = activity.findViewById(androidx.textclassifier.test.R.id.textview);
    mFloatingToolbar = new FloatingToolbar(mWidget);
    mFloatingToolbar.setMenu(menu);
}
#method_after
@Before
public void setUp() throws Throwable {
    final Activity activity = mActivityTestRule.getActivity();
    TestUtils.keepScreenOn(mActivityTestRule, activity);
    mContext = activity;
    final SupportMenu menu = new MenuBuilder(mContext);
    menu.add("One");
    menu.add("Two");
    menu.add("Three");
    mWidget = activity.findViewById(androidx.textclassifier.test.R.id.textview);
    mFloatingToolbar = new FloatingToolbar(mWidget);
    mFloatingToolbar.setMenu(menu);
}
#end_block

#method_before
public void setTitle(@NonNull CharSequence title) {
    mTitle = title;
}
#method_after
public void setTitle(@Nullable CharSequence title) {
    mTitle = title;
}
#end_block

#method_before
@NonNull
public CharSequence getTitle() {
    return mTitle;
}
#method_after
@Nullable
public CharSequence getTitle() {
    return mTitle;
}
#end_block

#method_before
public int getStyleResId() {
    return mStyleResId;
}
#method_after
@StyleRes
public int getStyleResId() {
    return mStyleResId;
}
#end_block

#method_before
@NonNull
public CarMenuItem build() {
    return new CarMenuItem(this);
}
#method_after
@NonNull
public CarMenuItem build() {
    // TODO(120920382): Remove this check once a default style is added.
    if (mStyleResId == 0) {
        throw new IllegalStateException("Invalid style resource id.");
    }
    return new CarMenuItem(this);
}
#end_block

#method_before
@Nullable
public static WebViewRendererImpl forInvocationHandler(InvocationHandler invocationHandler) {
    if (invocationHandler == null) {
        return null;
    }
    // Make a possibly temporary proxy object in order to call into WebView.
    final WebViewRendererBoundaryInterface boundaryInterface = BoundaryInterfaceReflectionUtil.castToSuppLibClass(WebViewRendererBoundaryInterface.class, invocationHandler);
    // to return a previously created wrapper object.
    return (WebViewRendererImpl) boundaryInterface.getOrCreatePeer(new Callable<Object>() {

        @Override
        public Object call() {
            return new WebViewRendererImpl(boundaryInterface);
        }
    });
}
#method_after
@Nullable
public static WebViewRendererImpl forInvocationHandler(InvocationHandler invocationHandler) {
    // Make a possibly temporary proxy object in order to call into WebView.
    final WebViewRendererBoundaryInterface boundaryInterface = BoundaryInterfaceReflectionUtil.castToSuppLibClass(WebViewRendererBoundaryInterface.class, invocationHandler);
    // to return a previously created wrapper object.
    return (WebViewRendererImpl) boundaryInterface.getOrCreatePeer(new Callable<Object>() {

        @Override
        public Object call() {
            return new WebViewRendererImpl(boundaryInterface);
        }
    });
}
#end_block

#method_before
public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
    if (((bitField0_ & 0x00000001) == 0x00000001)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, accessToken_);
    }
    if (((bitField0_ & 0x00000002) == 0x00000002)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, resultPath_);
    }
    if (((bitField0_ & 0x00000004) == 0x00000004)) {
        output.writeBool(3, bootSuccess_);
    }
    if (((bitField0_ & 0x00000008) == 0x00000008)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 11, branch_);
    }
    if (((bitField0_ & 0x00000010) == 0x00000010)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 12, target_);
    }
    if (((bitField0_ & 0x00000020) == 0x00000020)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 13, buildId_);
    }
    if (((bitField0_ & 0x00000040) == 0x00000040)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 21, suitePlan_);
    }
    if (((bitField0_ & 0x00000080) == 0x00000080)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 22, suiteVersion_);
    }
    if (((bitField0_ & 0x00000100) == 0x00000100)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 23, suiteBuildNumber_);
    }
    if (((bitField0_ & 0x00000200) == 0x00000200)) {
        output.writeInt64(24, startTime_);
    }
    if (((bitField0_ & 0x00000400) == 0x00000400)) {
        output.writeInt64(25, endTime_);
    }
    if (((bitField0_ & 0x00000800) == 0x00000800)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 26, hostName_);
    }
    if (((bitField0_ & 0x00001000) == 0x00001000)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 27, suiteName_);
    }
    if (((bitField0_ & 0x00002000) == 0x00002000)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 31, buildSystemFingerprint_);
    }
    if (((bitField0_ & 0x00004000) == 0x00004000)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 32, buildVendorFingerprint_);
    }
    if (((bitField0_ & 0x00008000) == 0x00008000)) {
        output.writeInt32(33, testType_);
    }
    if (((bitField0_ & 0x00010000) == 0x00010000)) {
        output.writeInt32(41, passedTestCaseCount_);
    }
    if (((bitField0_ & 0x00020000) == 0x00020000)) {
        output.writeInt32(42, failedTestCaseCount_);
    }
    if (((bitField0_ & 0x00040000) == 0x00040000)) {
        output.writeInt32(43, modulesDone_);
    }
    if (((bitField0_ & 0x00080000) == 0x00080000)) {
        output.writeInt32(44, modulesTotal_);
    }
    if (((bitField0_ & 0x00100000) == 0x00100000)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 51, infraLogPath_);
    }
    for (int i = 0; i < repackedImagePath_.size(); i++) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 52, repackedImagePath_.getRaw(i));
    }
    if (((bitField0_ & 0x00200000) == 0x00200000)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 61, vendorBuildId_);
    }
    if (((bitField0_ & 0x00400000) == 0x00400000)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 62, gsiBuildId_);
    }
    unknownFields.writeTo(output);
}
#method_after
public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
    if (((bitField0_ & 0x00000001) == 0x00000001)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, accessToken_);
    }
    if (((bitField0_ & 0x00000002) == 0x00000002)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, resultPath_);
    }
    if (((bitField0_ & 0x00000004) == 0x00000004)) {
        output.writeBool(3, bootSuccess_);
    }
    if (((bitField0_ & 0x00000008) == 0x00000008)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 11, branch_);
    }
    if (((bitField0_ & 0x00000010) == 0x00000010)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 12, target_);
    }
    if (((bitField0_ & 0x00000020) == 0x00000020)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 13, buildId_);
    }
    if (((bitField0_ & 0x00000040) == 0x00000040)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 21, suitePlan_);
    }
    if (((bitField0_ & 0x00000080) == 0x00000080)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 22, suiteVersion_);
    }
    if (((bitField0_ & 0x00000100) == 0x00000100)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 23, suiteBuildNumber_);
    }
    if (((bitField0_ & 0x00000200) == 0x00000200)) {
        output.writeInt64(24, startTime_);
    }
    if (((bitField0_ & 0x00000400) == 0x00000400)) {
        output.writeInt64(25, endTime_);
    }
    if (((bitField0_ & 0x00000800) == 0x00000800)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 26, hostName_);
    }
    if (((bitField0_ & 0x00001000) == 0x00001000)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 27, suiteName_);
    }
    if (((bitField0_ & 0x00002000) == 0x00002000)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 31, buildSystemFingerprint_);
    }
    if (((bitField0_ & 0x00004000) == 0x00004000)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 32, buildVendorFingerprint_);
    }
    if (((bitField0_ & 0x00008000) == 0x00008000)) {
        output.writeInt32(33, testType_);
    }
    if (((bitField0_ & 0x00010000) == 0x00010000)) {
        output.writeInt32(41, passedTestCaseCount_);
    }
    if (((bitField0_ & 0x00020000) == 0x00020000)) {
        output.writeInt32(42, failedTestCaseCount_);
    }
    if (((bitField0_ & 0x00040000) == 0x00040000)) {
        output.writeInt32(43, modulesDone_);
    }
    if (((bitField0_ & 0x00080000) == 0x00080000)) {
        output.writeInt32(44, modulesTotal_);
    }
    if (((bitField0_ & 0x00100000) == 0x00100000)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 51, infraLogPath_);
    }
    for (int i = 0; i < repackedImagePath_.size(); i++) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 52, repackedImagePath_.getRaw(i));
    }
    if (((bitField0_ & 0x00200000) == 0x00200000)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 61, vendorBuildId_);
    }
    if (((bitField0_ & 0x00400000) == 0x00400000)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 62, gsiBuildId_);
    }
    if (((bitField0_ & 0x00800000) == 0x00800000)) {
        output.writeMessage(63, getScheduleConfig());
    }
    unknownFields.writeTo(output);
}
#end_block

#method_before
public int getSerializedSize() {
    int size = memoizedSize;
    if (size != -1)
        return size;
    size = 0;
    if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, accessToken_);
    }
    if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, resultPath_);
    }
    if (((bitField0_ & 0x00000004) == 0x00000004)) {
        size += com.google.protobuf.CodedOutputStream.computeBoolSize(3, bootSuccess_);
    }
    if (((bitField0_ & 0x00000008) == 0x00000008)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(11, branch_);
    }
    if (((bitField0_ & 0x00000010) == 0x00000010)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(12, target_);
    }
    if (((bitField0_ & 0x00000020) == 0x00000020)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(13, buildId_);
    }
    if (((bitField0_ & 0x00000040) == 0x00000040)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(21, suitePlan_);
    }
    if (((bitField0_ & 0x00000080) == 0x00000080)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(22, suiteVersion_);
    }
    if (((bitField0_ & 0x00000100) == 0x00000100)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(23, suiteBuildNumber_);
    }
    if (((bitField0_ & 0x00000200) == 0x00000200)) {
        size += com.google.protobuf.CodedOutputStream.computeInt64Size(24, startTime_);
    }
    if (((bitField0_ & 0x00000400) == 0x00000400)) {
        size += com.google.protobuf.CodedOutputStream.computeInt64Size(25, endTime_);
    }
    if (((bitField0_ & 0x00000800) == 0x00000800)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(26, hostName_);
    }
    if (((bitField0_ & 0x00001000) == 0x00001000)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(27, suiteName_);
    }
    if (((bitField0_ & 0x00002000) == 0x00002000)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(31, buildSystemFingerprint_);
    }
    if (((bitField0_ & 0x00004000) == 0x00004000)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(32, buildVendorFingerprint_);
    }
    if (((bitField0_ & 0x00008000) == 0x00008000)) {
        size += com.google.protobuf.CodedOutputStream.computeInt32Size(33, testType_);
    }
    if (((bitField0_ & 0x00010000) == 0x00010000)) {
        size += com.google.protobuf.CodedOutputStream.computeInt32Size(41, passedTestCaseCount_);
    }
    if (((bitField0_ & 0x00020000) == 0x00020000)) {
        size += com.google.protobuf.CodedOutputStream.computeInt32Size(42, failedTestCaseCount_);
    }
    if (((bitField0_ & 0x00040000) == 0x00040000)) {
        size += com.google.protobuf.CodedOutputStream.computeInt32Size(43, modulesDone_);
    }
    if (((bitField0_ & 0x00080000) == 0x00080000)) {
        size += com.google.protobuf.CodedOutputStream.computeInt32Size(44, modulesTotal_);
    }
    if (((bitField0_ & 0x00100000) == 0x00100000)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(51, infraLogPath_);
    }
    {
        int dataSize = 0;
        for (int i = 0; i < repackedImagePath_.size(); i++) {
            dataSize += computeStringSizeNoTag(repackedImagePath_.getRaw(i));
        }
        size += dataSize;
        size += 2 * getRepackedImagePathList().size();
    }
    if (((bitField0_ & 0x00200000) == 0x00200000)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(61, vendorBuildId_);
    }
    if (((bitField0_ & 0x00400000) == 0x00400000)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(62, gsiBuildId_);
    }
    size += unknownFields.getSerializedSize();
    memoizedSize = size;
    return size;
}
#method_after
public int getSerializedSize() {
    int size = memoizedSize;
    if (size != -1)
        return size;
    size = 0;
    if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, accessToken_);
    }
    if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, resultPath_);
    }
    if (((bitField0_ & 0x00000004) == 0x00000004)) {
        size += com.google.protobuf.CodedOutputStream.computeBoolSize(3, bootSuccess_);
    }
    if (((bitField0_ & 0x00000008) == 0x00000008)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(11, branch_);
    }
    if (((bitField0_ & 0x00000010) == 0x00000010)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(12, target_);
    }
    if (((bitField0_ & 0x00000020) == 0x00000020)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(13, buildId_);
    }
    if (((bitField0_ & 0x00000040) == 0x00000040)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(21, suitePlan_);
    }
    if (((bitField0_ & 0x00000080) == 0x00000080)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(22, suiteVersion_);
    }
    if (((bitField0_ & 0x00000100) == 0x00000100)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(23, suiteBuildNumber_);
    }
    if (((bitField0_ & 0x00000200) == 0x00000200)) {
        size += com.google.protobuf.CodedOutputStream.computeInt64Size(24, startTime_);
    }
    if (((bitField0_ & 0x00000400) == 0x00000400)) {
        size += com.google.protobuf.CodedOutputStream.computeInt64Size(25, endTime_);
    }
    if (((bitField0_ & 0x00000800) == 0x00000800)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(26, hostName_);
    }
    if (((bitField0_ & 0x00001000) == 0x00001000)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(27, suiteName_);
    }
    if (((bitField0_ & 0x00002000) == 0x00002000)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(31, buildSystemFingerprint_);
    }
    if (((bitField0_ & 0x00004000) == 0x00004000)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(32, buildVendorFingerprint_);
    }
    if (((bitField0_ & 0x00008000) == 0x00008000)) {
        size += com.google.protobuf.CodedOutputStream.computeInt32Size(33, testType_);
    }
    if (((bitField0_ & 0x00010000) == 0x00010000)) {
        size += com.google.protobuf.CodedOutputStream.computeInt32Size(41, passedTestCaseCount_);
    }
    if (((bitField0_ & 0x00020000) == 0x00020000)) {
        size += com.google.protobuf.CodedOutputStream.computeInt32Size(42, failedTestCaseCount_);
    }
    if (((bitField0_ & 0x00040000) == 0x00040000)) {
        size += com.google.protobuf.CodedOutputStream.computeInt32Size(43, modulesDone_);
    }
    if (((bitField0_ & 0x00080000) == 0x00080000)) {
        size += com.google.protobuf.CodedOutputStream.computeInt32Size(44, modulesTotal_);
    }
    if (((bitField0_ & 0x00100000) == 0x00100000)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(51, infraLogPath_);
    }
    {
        int dataSize = 0;
        for (int i = 0; i < repackedImagePath_.size(); i++) {
            dataSize += computeStringSizeNoTag(repackedImagePath_.getRaw(i));
        }
        size += dataSize;
        size += 2 * getRepackedImagePathList().size();
    }
    if (((bitField0_ & 0x00200000) == 0x00200000)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(61, vendorBuildId_);
    }
    if (((bitField0_ & 0x00400000) == 0x00400000)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(62, gsiBuildId_);
    }
    if (((bitField0_ & 0x00800000) == 0x00800000)) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(63, getScheduleConfig());
    }
    size += unknownFields.getSerializedSize();
    memoizedSize = size;
    return size;
}
#end_block

#method_before
@java.lang.Override
public boolean equals(final java.lang.Object obj) {
    if (obj == this) {
        return true;
    }
    if (!(obj instanceof com.android.vts.proto.TestSuiteResultMessageProto.TestSuiteResultMessage)) {
        return super.equals(obj);
    }
    com.android.vts.proto.TestSuiteResultMessageProto.TestSuiteResultMessage other = (com.android.vts.proto.TestSuiteResultMessageProto.TestSuiteResultMessage) obj;
    boolean result = true;
    result = result && (hasAccessToken() == other.hasAccessToken());
    if (hasAccessToken()) {
        result = result && getAccessToken().equals(other.getAccessToken());
    }
    result = result && (hasResultPath() == other.hasResultPath());
    if (hasResultPath()) {
        result = result && getResultPath().equals(other.getResultPath());
    }
    result = result && (hasBootSuccess() == other.hasBootSuccess());
    if (hasBootSuccess()) {
        result = result && (getBootSuccess() == other.getBootSuccess());
    }
    result = result && (hasBranch() == other.hasBranch());
    if (hasBranch()) {
        result = result && getBranch().equals(other.getBranch());
    }
    result = result && (hasTarget() == other.hasTarget());
    if (hasTarget()) {
        result = result && getTarget().equals(other.getTarget());
    }
    result = result && (hasBuildId() == other.hasBuildId());
    if (hasBuildId()) {
        result = result && getBuildId().equals(other.getBuildId());
    }
    result = result && (hasSuitePlan() == other.hasSuitePlan());
    if (hasSuitePlan()) {
        result = result && getSuitePlan().equals(other.getSuitePlan());
    }
    result = result && (hasSuiteVersion() == other.hasSuiteVersion());
    if (hasSuiteVersion()) {
        result = result && getSuiteVersion().equals(other.getSuiteVersion());
    }
    result = result && (hasSuiteBuildNumber() == other.hasSuiteBuildNumber());
    if (hasSuiteBuildNumber()) {
        result = result && getSuiteBuildNumber().equals(other.getSuiteBuildNumber());
    }
    result = result && (hasStartTime() == other.hasStartTime());
    if (hasStartTime()) {
        result = result && (getStartTime() == other.getStartTime());
    }
    result = result && (hasEndTime() == other.hasEndTime());
    if (hasEndTime()) {
        result = result && (getEndTime() == other.getEndTime());
    }
    result = result && (hasHostName() == other.hasHostName());
    if (hasHostName()) {
        result = result && getHostName().equals(other.getHostName());
    }
    result = result && (hasSuiteName() == other.hasSuiteName());
    if (hasSuiteName()) {
        result = result && getSuiteName().equals(other.getSuiteName());
    }
    result = result && (hasBuildSystemFingerprint() == other.hasBuildSystemFingerprint());
    if (hasBuildSystemFingerprint()) {
        result = result && getBuildSystemFingerprint().equals(other.getBuildSystemFingerprint());
    }
    result = result && (hasBuildVendorFingerprint() == other.hasBuildVendorFingerprint());
    if (hasBuildVendorFingerprint()) {
        result = result && getBuildVendorFingerprint().equals(other.getBuildVendorFingerprint());
    }
    result = result && (hasTestType() == other.hasTestType());
    if (hasTestType()) {
        result = result && (getTestType() == other.getTestType());
    }
    result = result && (hasPassedTestCaseCount() == other.hasPassedTestCaseCount());
    if (hasPassedTestCaseCount()) {
        result = result && (getPassedTestCaseCount() == other.getPassedTestCaseCount());
    }
    result = result && (hasFailedTestCaseCount() == other.hasFailedTestCaseCount());
    if (hasFailedTestCaseCount()) {
        result = result && (getFailedTestCaseCount() == other.getFailedTestCaseCount());
    }
    result = result && (hasModulesDone() == other.hasModulesDone());
    if (hasModulesDone()) {
        result = result && (getModulesDone() == other.getModulesDone());
    }
    result = result && (hasModulesTotal() == other.hasModulesTotal());
    if (hasModulesTotal()) {
        result = result && (getModulesTotal() == other.getModulesTotal());
    }
    result = result && (hasInfraLogPath() == other.hasInfraLogPath());
    if (hasInfraLogPath()) {
        result = result && getInfraLogPath().equals(other.getInfraLogPath());
    }
    result = result && getRepackedImagePathList().equals(other.getRepackedImagePathList());
    result = result && (hasVendorBuildId() == other.hasVendorBuildId());
    if (hasVendorBuildId()) {
        result = result && getVendorBuildId().equals(other.getVendorBuildId());
    }
    result = result && (hasGsiBuildId() == other.hasGsiBuildId());
    if (hasGsiBuildId()) {
        result = result && getGsiBuildId().equals(other.getGsiBuildId());
    }
    result = result && unknownFields.equals(other.unknownFields);
    return result;
}
#method_after
@java.lang.Override
public boolean equals(final java.lang.Object obj) {
    if (obj == this) {
        return true;
    }
    if (!(obj instanceof com.android.vts.proto.TestSuiteResultMessageProto.TestSuiteResultMessage)) {
        return super.equals(obj);
    }
    com.android.vts.proto.TestSuiteResultMessageProto.TestSuiteResultMessage other = (com.android.vts.proto.TestSuiteResultMessageProto.TestSuiteResultMessage) obj;
    boolean result = true;
    result = result && (hasAccessToken() == other.hasAccessToken());
    if (hasAccessToken()) {
        result = result && getAccessToken().equals(other.getAccessToken());
    }
    result = result && (hasResultPath() == other.hasResultPath());
    if (hasResultPath()) {
        result = result && getResultPath().equals(other.getResultPath());
    }
    result = result && (hasBootSuccess() == other.hasBootSuccess());
    if (hasBootSuccess()) {
        result = result && (getBootSuccess() == other.getBootSuccess());
    }
    result = result && (hasBranch() == other.hasBranch());
    if (hasBranch()) {
        result = result && getBranch().equals(other.getBranch());
    }
    result = result && (hasTarget() == other.hasTarget());
    if (hasTarget()) {
        result = result && getTarget().equals(other.getTarget());
    }
    result = result && (hasBuildId() == other.hasBuildId());
    if (hasBuildId()) {
        result = result && getBuildId().equals(other.getBuildId());
    }
    result = result && (hasSuitePlan() == other.hasSuitePlan());
    if (hasSuitePlan()) {
        result = result && getSuitePlan().equals(other.getSuitePlan());
    }
    result = result && (hasSuiteVersion() == other.hasSuiteVersion());
    if (hasSuiteVersion()) {
        result = result && getSuiteVersion().equals(other.getSuiteVersion());
    }
    result = result && (hasSuiteBuildNumber() == other.hasSuiteBuildNumber());
    if (hasSuiteBuildNumber()) {
        result = result && getSuiteBuildNumber().equals(other.getSuiteBuildNumber());
    }
    result = result && (hasStartTime() == other.hasStartTime());
    if (hasStartTime()) {
        result = result && (getStartTime() == other.getStartTime());
    }
    result = result && (hasEndTime() == other.hasEndTime());
    if (hasEndTime()) {
        result = result && (getEndTime() == other.getEndTime());
    }
    result = result && (hasHostName() == other.hasHostName());
    if (hasHostName()) {
        result = result && getHostName().equals(other.getHostName());
    }
    result = result && (hasSuiteName() == other.hasSuiteName());
    if (hasSuiteName()) {
        result = result && getSuiteName().equals(other.getSuiteName());
    }
    result = result && (hasBuildSystemFingerprint() == other.hasBuildSystemFingerprint());
    if (hasBuildSystemFingerprint()) {
        result = result && getBuildSystemFingerprint().equals(other.getBuildSystemFingerprint());
    }
    result = result && (hasBuildVendorFingerprint() == other.hasBuildVendorFingerprint());
    if (hasBuildVendorFingerprint()) {
        result = result && getBuildVendorFingerprint().equals(other.getBuildVendorFingerprint());
    }
    result = result && (hasTestType() == other.hasTestType());
    if (hasTestType()) {
        result = result && (getTestType() == other.getTestType());
    }
    result = result && (hasPassedTestCaseCount() == other.hasPassedTestCaseCount());
    if (hasPassedTestCaseCount()) {
        result = result && (getPassedTestCaseCount() == other.getPassedTestCaseCount());
    }
    result = result && (hasFailedTestCaseCount() == other.hasFailedTestCaseCount());
    if (hasFailedTestCaseCount()) {
        result = result && (getFailedTestCaseCount() == other.getFailedTestCaseCount());
    }
    result = result && (hasModulesDone() == other.hasModulesDone());
    if (hasModulesDone()) {
        result = result && (getModulesDone() == other.getModulesDone());
    }
    result = result && (hasModulesTotal() == other.hasModulesTotal());
    if (hasModulesTotal()) {
        result = result && (getModulesTotal() == other.getModulesTotal());
    }
    result = result && (hasInfraLogPath() == other.hasInfraLogPath());
    if (hasInfraLogPath()) {
        result = result && getInfraLogPath().equals(other.getInfraLogPath());
    }
    result = result && getRepackedImagePathList().equals(other.getRepackedImagePathList());
    result = result && (hasVendorBuildId() == other.hasVendorBuildId());
    if (hasVendorBuildId()) {
        result = result && getVendorBuildId().equals(other.getVendorBuildId());
    }
    result = result && (hasGsiBuildId() == other.hasGsiBuildId());
    if (hasGsiBuildId()) {
        result = result && getGsiBuildId().equals(other.getGsiBuildId());
    }
    result = result && (hasScheduleConfig() == other.hasScheduleConfig());
    if (hasScheduleConfig()) {
        result = result && getScheduleConfig().equals(other.getScheduleConfig());
    }
    result = result && unknownFields.equals(other.unknownFields);
    return result;
}
#end_block

#method_before
@java.lang.Override
public int hashCode() {
    if (memoizedHashCode != 0) {
        return memoizedHashCode;
    }
    int hash = 41;
    hash = (19 * hash) + getDescriptorForType().hashCode();
    if (hasAccessToken()) {
        hash = (37 * hash) + ACCESS_TOKEN_FIELD_NUMBER;
        hash = (53 * hash) + getAccessToken().hashCode();
    }
    if (hasResultPath()) {
        hash = (37 * hash) + RESULT_PATH_FIELD_NUMBER;
        hash = (53 * hash) + getResultPath().hashCode();
    }
    if (hasBootSuccess()) {
        hash = (37 * hash) + BOOT_SUCCESS_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(getBootSuccess());
    }
    if (hasBranch()) {
        hash = (37 * hash) + BRANCH_FIELD_NUMBER;
        hash = (53 * hash) + getBranch().hashCode();
    }
    if (hasTarget()) {
        hash = (37 * hash) + TARGET_FIELD_NUMBER;
        hash = (53 * hash) + getTarget().hashCode();
    }
    if (hasBuildId()) {
        hash = (37 * hash) + BUILD_ID_FIELD_NUMBER;
        hash = (53 * hash) + getBuildId().hashCode();
    }
    if (hasSuitePlan()) {
        hash = (37 * hash) + SUITE_PLAN_FIELD_NUMBER;
        hash = (53 * hash) + getSuitePlan().hashCode();
    }
    if (hasSuiteVersion()) {
        hash = (37 * hash) + SUITE_VERSION_FIELD_NUMBER;
        hash = (53 * hash) + getSuiteVersion().hashCode();
    }
    if (hasSuiteBuildNumber()) {
        hash = (37 * hash) + SUITE_BUILD_NUMBER_FIELD_NUMBER;
        hash = (53 * hash) + getSuiteBuildNumber().hashCode();
    }
    if (hasStartTime()) {
        hash = (37 * hash) + START_TIME_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(getStartTime());
    }
    if (hasEndTime()) {
        hash = (37 * hash) + END_TIME_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(getEndTime());
    }
    if (hasHostName()) {
        hash = (37 * hash) + HOST_NAME_FIELD_NUMBER;
        hash = (53 * hash) + getHostName().hashCode();
    }
    if (hasSuiteName()) {
        hash = (37 * hash) + SUITE_NAME_FIELD_NUMBER;
        hash = (53 * hash) + getSuiteName().hashCode();
    }
    if (hasBuildSystemFingerprint()) {
        hash = (37 * hash) + BUILD_SYSTEM_FINGERPRINT_FIELD_NUMBER;
        hash = (53 * hash) + getBuildSystemFingerprint().hashCode();
    }
    if (hasBuildVendorFingerprint()) {
        hash = (37 * hash) + BUILD_VENDOR_FINGERPRINT_FIELD_NUMBER;
        hash = (53 * hash) + getBuildVendorFingerprint().hashCode();
    }
    if (hasTestType()) {
        hash = (37 * hash) + TEST_TYPE_FIELD_NUMBER;
        hash = (53 * hash) + getTestType();
    }
    if (hasPassedTestCaseCount()) {
        hash = (37 * hash) + PASSED_TEST_CASE_COUNT_FIELD_NUMBER;
        hash = (53 * hash) + getPassedTestCaseCount();
    }
    if (hasFailedTestCaseCount()) {
        hash = (37 * hash) + FAILED_TEST_CASE_COUNT_FIELD_NUMBER;
        hash = (53 * hash) + getFailedTestCaseCount();
    }
    if (hasModulesDone()) {
        hash = (37 * hash) + MODULES_DONE_FIELD_NUMBER;
        hash = (53 * hash) + getModulesDone();
    }
    if (hasModulesTotal()) {
        hash = (37 * hash) + MODULES_TOTAL_FIELD_NUMBER;
        hash = (53 * hash) + getModulesTotal();
    }
    if (hasInfraLogPath()) {
        hash = (37 * hash) + INFRA_LOG_PATH_FIELD_NUMBER;
        hash = (53 * hash) + getInfraLogPath().hashCode();
    }
    if (getRepackedImagePathCount() > 0) {
        hash = (37 * hash) + REPACKED_IMAGE_PATH_FIELD_NUMBER;
        hash = (53 * hash) + getRepackedImagePathList().hashCode();
    }
    if (hasVendorBuildId()) {
        hash = (37 * hash) + VENDOR_BUILD_ID_FIELD_NUMBER;
        hash = (53 * hash) + getVendorBuildId().hashCode();
    }
    if (hasGsiBuildId()) {
        hash = (37 * hash) + GSI_BUILD_ID_FIELD_NUMBER;
        hash = (53 * hash) + getGsiBuildId().hashCode();
    }
    hash = (29 * hash) + unknownFields.hashCode();
    memoizedHashCode = hash;
    return hash;
}
#method_after
@java.lang.Override
public int hashCode() {
    if (memoizedHashCode != 0) {
        return memoizedHashCode;
    }
    int hash = 41;
    hash = (19 * hash) + getDescriptorForType().hashCode();
    if (hasAccessToken()) {
        hash = (37 * hash) + ACCESS_TOKEN_FIELD_NUMBER;
        hash = (53 * hash) + getAccessToken().hashCode();
    }
    if (hasResultPath()) {
        hash = (37 * hash) + RESULT_PATH_FIELD_NUMBER;
        hash = (53 * hash) + getResultPath().hashCode();
    }
    if (hasBootSuccess()) {
        hash = (37 * hash) + BOOT_SUCCESS_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(getBootSuccess());
    }
    if (hasBranch()) {
        hash = (37 * hash) + BRANCH_FIELD_NUMBER;
        hash = (53 * hash) + getBranch().hashCode();
    }
    if (hasTarget()) {
        hash = (37 * hash) + TARGET_FIELD_NUMBER;
        hash = (53 * hash) + getTarget().hashCode();
    }
    if (hasBuildId()) {
        hash = (37 * hash) + BUILD_ID_FIELD_NUMBER;
        hash = (53 * hash) + getBuildId().hashCode();
    }
    if (hasSuitePlan()) {
        hash = (37 * hash) + SUITE_PLAN_FIELD_NUMBER;
        hash = (53 * hash) + getSuitePlan().hashCode();
    }
    if (hasSuiteVersion()) {
        hash = (37 * hash) + SUITE_VERSION_FIELD_NUMBER;
        hash = (53 * hash) + getSuiteVersion().hashCode();
    }
    if (hasSuiteBuildNumber()) {
        hash = (37 * hash) + SUITE_BUILD_NUMBER_FIELD_NUMBER;
        hash = (53 * hash) + getSuiteBuildNumber().hashCode();
    }
    if (hasStartTime()) {
        hash = (37 * hash) + START_TIME_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(getStartTime());
    }
    if (hasEndTime()) {
        hash = (37 * hash) + END_TIME_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(getEndTime());
    }
    if (hasHostName()) {
        hash = (37 * hash) + HOST_NAME_FIELD_NUMBER;
        hash = (53 * hash) + getHostName().hashCode();
    }
    if (hasSuiteName()) {
        hash = (37 * hash) + SUITE_NAME_FIELD_NUMBER;
        hash = (53 * hash) + getSuiteName().hashCode();
    }
    if (hasBuildSystemFingerprint()) {
        hash = (37 * hash) + BUILD_SYSTEM_FINGERPRINT_FIELD_NUMBER;
        hash = (53 * hash) + getBuildSystemFingerprint().hashCode();
    }
    if (hasBuildVendorFingerprint()) {
        hash = (37 * hash) + BUILD_VENDOR_FINGERPRINT_FIELD_NUMBER;
        hash = (53 * hash) + getBuildVendorFingerprint().hashCode();
    }
    if (hasTestType()) {
        hash = (37 * hash) + TEST_TYPE_FIELD_NUMBER;
        hash = (53 * hash) + getTestType();
    }
    if (hasPassedTestCaseCount()) {
        hash = (37 * hash) + PASSED_TEST_CASE_COUNT_FIELD_NUMBER;
        hash = (53 * hash) + getPassedTestCaseCount();
    }
    if (hasFailedTestCaseCount()) {
        hash = (37 * hash) + FAILED_TEST_CASE_COUNT_FIELD_NUMBER;
        hash = (53 * hash) + getFailedTestCaseCount();
    }
    if (hasModulesDone()) {
        hash = (37 * hash) + MODULES_DONE_FIELD_NUMBER;
        hash = (53 * hash) + getModulesDone();
    }
    if (hasModulesTotal()) {
        hash = (37 * hash) + MODULES_TOTAL_FIELD_NUMBER;
        hash = (53 * hash) + getModulesTotal();
    }
    if (hasInfraLogPath()) {
        hash = (37 * hash) + INFRA_LOG_PATH_FIELD_NUMBER;
        hash = (53 * hash) + getInfraLogPath().hashCode();
    }
    if (getRepackedImagePathCount() > 0) {
        hash = (37 * hash) + REPACKED_IMAGE_PATH_FIELD_NUMBER;
        hash = (53 * hash) + getRepackedImagePathList().hashCode();
    }
    if (hasVendorBuildId()) {
        hash = (37 * hash) + VENDOR_BUILD_ID_FIELD_NUMBER;
        hash = (53 * hash) + getVendorBuildId().hashCode();
    }
    if (hasGsiBuildId()) {
        hash = (37 * hash) + GSI_BUILD_ID_FIELD_NUMBER;
        hash = (53 * hash) + getGsiBuildId().hashCode();
    }
    if (hasScheduleConfig()) {
        hash = (37 * hash) + SCHEDULE_CONFIG_FIELD_NUMBER;
        hash = (53 * hash) + getScheduleConfig().hashCode();
    }
    hash = (29 * hash) + unknownFields.hashCode();
    memoizedHashCode = hash;
    return hash;
}
#end_block

#method_before
private void maybeForceBuilderInitialization() {
    if (com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders) {
    }
}
#method_after
private void maybeForceBuilderInitialization() {
    if (com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders) {
        getScheduleConfigFieldBuilder();
    }
}
#end_block

#method_before
public Builder clear() {
    super.clear();
    accessToken_ = "";
    bitField0_ = (bitField0_ & ~0x00000001);
    resultPath_ = "";
    bitField0_ = (bitField0_ & ~0x00000002);
    bootSuccess_ = true;
    bitField0_ = (bitField0_ & ~0x00000004);
    branch_ = "";
    bitField0_ = (bitField0_ & ~0x00000008);
    target_ = "";
    bitField0_ = (bitField0_ & ~0x00000010);
    buildId_ = "";
    bitField0_ = (bitField0_ & ~0x00000020);
    suitePlan_ = "";
    bitField0_ = (bitField0_ & ~0x00000040);
    suiteVersion_ = "";
    bitField0_ = (bitField0_ & ~0x00000080);
    suiteBuildNumber_ = "";
    bitField0_ = (bitField0_ & ~0x00000100);
    startTime_ = 0L;
    bitField0_ = (bitField0_ & ~0x00000200);
    endTime_ = 0L;
    bitField0_ = (bitField0_ & ~0x00000400);
    hostName_ = "";
    bitField0_ = (bitField0_ & ~0x00000800);
    suiteName_ = "";
    bitField0_ = (bitField0_ & ~0x00001000);
    buildSystemFingerprint_ = "";
    bitField0_ = (bitField0_ & ~0x00002000);
    buildVendorFingerprint_ = "";
    bitField0_ = (bitField0_ & ~0x00004000);
    testType_ = 0;
    bitField0_ = (bitField0_ & ~0x00008000);
    passedTestCaseCount_ = 0;
    bitField0_ = (bitField0_ & ~0x00010000);
    failedTestCaseCount_ = 0;
    bitField0_ = (bitField0_ & ~0x00020000);
    modulesDone_ = 0;
    bitField0_ = (bitField0_ & ~0x00040000);
    modulesTotal_ = 0;
    bitField0_ = (bitField0_ & ~0x00080000);
    infraLogPath_ = "";
    bitField0_ = (bitField0_ & ~0x00100000);
    repackedImagePath_ = com.google.protobuf.LazyStringArrayList.EMPTY;
    bitField0_ = (bitField0_ & ~0x00200000);
    vendorBuildId_ = "";
    bitField0_ = (bitField0_ & ~0x00400000);
    gsiBuildId_ = "";
    bitField0_ = (bitField0_ & ~0x00800000);
    return this;
}
#method_after
public Builder clear() {
    super.clear();
    accessToken_ = "";
    bitField0_ = (bitField0_ & ~0x00000001);
    resultPath_ = "";
    bitField0_ = (bitField0_ & ~0x00000002);
    bootSuccess_ = true;
    bitField0_ = (bitField0_ & ~0x00000004);
    branch_ = "";
    bitField0_ = (bitField0_ & ~0x00000008);
    target_ = "";
    bitField0_ = (bitField0_ & ~0x00000010);
    buildId_ = "";
    bitField0_ = (bitField0_ & ~0x00000020);
    suitePlan_ = "";
    bitField0_ = (bitField0_ & ~0x00000040);
    suiteVersion_ = "";
    bitField0_ = (bitField0_ & ~0x00000080);
    suiteBuildNumber_ = "";
    bitField0_ = (bitField0_ & ~0x00000100);
    startTime_ = 0L;
    bitField0_ = (bitField0_ & ~0x00000200);
    endTime_ = 0L;
    bitField0_ = (bitField0_ & ~0x00000400);
    hostName_ = "";
    bitField0_ = (bitField0_ & ~0x00000800);
    suiteName_ = "";
    bitField0_ = (bitField0_ & ~0x00001000);
    buildSystemFingerprint_ = "";
    bitField0_ = (bitField0_ & ~0x00002000);
    buildVendorFingerprint_ = "";
    bitField0_ = (bitField0_ & ~0x00004000);
    testType_ = 0;
    bitField0_ = (bitField0_ & ~0x00008000);
    passedTestCaseCount_ = 0;
    bitField0_ = (bitField0_ & ~0x00010000);
    failedTestCaseCount_ = 0;
    bitField0_ = (bitField0_ & ~0x00020000);
    modulesDone_ = 0;
    bitField0_ = (bitField0_ & ~0x00040000);
    modulesTotal_ = 0;
    bitField0_ = (bitField0_ & ~0x00080000);
    infraLogPath_ = "";
    bitField0_ = (bitField0_ & ~0x00100000);
    repackedImagePath_ = com.google.protobuf.LazyStringArrayList.EMPTY;
    bitField0_ = (bitField0_ & ~0x00200000);
    vendorBuildId_ = "";
    bitField0_ = (bitField0_ & ~0x00400000);
    gsiBuildId_ = "";
    bitField0_ = (bitField0_ & ~0x00800000);
    if (scheduleConfigBuilder_ == null) {
        scheduleConfig_ = null;
    } else {
        scheduleConfigBuilder_.clear();
    }
    bitField0_ = (bitField0_ & ~0x01000000);
    return this;
}
#end_block

#method_before
public com.android.vts.proto.TestSuiteResultMessageProto.TestSuiteResultMessage buildPartial() {
    com.android.vts.proto.TestSuiteResultMessageProto.TestSuiteResultMessage result = new com.android.vts.proto.TestSuiteResultMessageProto.TestSuiteResultMessage(this);
    int from_bitField0_ = bitField0_;
    int to_bitField0_ = 0;
    if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
        to_bitField0_ |= 0x00000001;
    }
    result.accessToken_ = accessToken_;
    if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
        to_bitField0_ |= 0x00000002;
    }
    result.resultPath_ = resultPath_;
    if (((from_bitField0_ & 0x00000004) == 0x00000004)) {
        to_bitField0_ |= 0x00000004;
    }
    result.bootSuccess_ = bootSuccess_;
    if (((from_bitField0_ & 0x00000008) == 0x00000008)) {
        to_bitField0_ |= 0x00000008;
    }
    result.branch_ = branch_;
    if (((from_bitField0_ & 0x00000010) == 0x00000010)) {
        to_bitField0_ |= 0x00000010;
    }
    result.target_ = target_;
    if (((from_bitField0_ & 0x00000020) == 0x00000020)) {
        to_bitField0_ |= 0x00000020;
    }
    result.buildId_ = buildId_;
    if (((from_bitField0_ & 0x00000040) == 0x00000040)) {
        to_bitField0_ |= 0x00000040;
    }
    result.suitePlan_ = suitePlan_;
    if (((from_bitField0_ & 0x00000080) == 0x00000080)) {
        to_bitField0_ |= 0x00000080;
    }
    result.suiteVersion_ = suiteVersion_;
    if (((from_bitField0_ & 0x00000100) == 0x00000100)) {
        to_bitField0_ |= 0x00000100;
    }
    result.suiteBuildNumber_ = suiteBuildNumber_;
    if (((from_bitField0_ & 0x00000200) == 0x00000200)) {
        to_bitField0_ |= 0x00000200;
    }
    result.startTime_ = startTime_;
    if (((from_bitField0_ & 0x00000400) == 0x00000400)) {
        to_bitField0_ |= 0x00000400;
    }
    result.endTime_ = endTime_;
    if (((from_bitField0_ & 0x00000800) == 0x00000800)) {
        to_bitField0_ |= 0x00000800;
    }
    result.hostName_ = hostName_;
    if (((from_bitField0_ & 0x00001000) == 0x00001000)) {
        to_bitField0_ |= 0x00001000;
    }
    result.suiteName_ = suiteName_;
    if (((from_bitField0_ & 0x00002000) == 0x00002000)) {
        to_bitField0_ |= 0x00002000;
    }
    result.buildSystemFingerprint_ = buildSystemFingerprint_;
    if (((from_bitField0_ & 0x00004000) == 0x00004000)) {
        to_bitField0_ |= 0x00004000;
    }
    result.buildVendorFingerprint_ = buildVendorFingerprint_;
    if (((from_bitField0_ & 0x00008000) == 0x00008000)) {
        to_bitField0_ |= 0x00008000;
    }
    result.testType_ = testType_;
    if (((from_bitField0_ & 0x00010000) == 0x00010000)) {
        to_bitField0_ |= 0x00010000;
    }
    result.passedTestCaseCount_ = passedTestCaseCount_;
    if (((from_bitField0_ & 0x00020000) == 0x00020000)) {
        to_bitField0_ |= 0x00020000;
    }
    result.failedTestCaseCount_ = failedTestCaseCount_;
    if (((from_bitField0_ & 0x00040000) == 0x00040000)) {
        to_bitField0_ |= 0x00040000;
    }
    result.modulesDone_ = modulesDone_;
    if (((from_bitField0_ & 0x00080000) == 0x00080000)) {
        to_bitField0_ |= 0x00080000;
    }
    result.modulesTotal_ = modulesTotal_;
    if (((from_bitField0_ & 0x00100000) == 0x00100000)) {
        to_bitField0_ |= 0x00100000;
    }
    result.infraLogPath_ = infraLogPath_;
    if (((bitField0_ & 0x00200000) == 0x00200000)) {
        repackedImagePath_ = repackedImagePath_.getUnmodifiableView();
        bitField0_ = (bitField0_ & ~0x00200000);
    }
    result.repackedImagePath_ = repackedImagePath_;
    if (((from_bitField0_ & 0x00400000) == 0x00400000)) {
        to_bitField0_ |= 0x00200000;
    }
    result.vendorBuildId_ = vendorBuildId_;
    if (((from_bitField0_ & 0x00800000) == 0x00800000)) {
        to_bitField0_ |= 0x00400000;
    }
    result.gsiBuildId_ = gsiBuildId_;
    result.bitField0_ = to_bitField0_;
    onBuilt();
    return result;
}
#method_after
public com.android.vts.proto.TestSuiteResultMessageProto.TestSuiteResultMessage buildPartial() {
    com.android.vts.proto.TestSuiteResultMessageProto.TestSuiteResultMessage result = new com.android.vts.proto.TestSuiteResultMessageProto.TestSuiteResultMessage(this);
    int from_bitField0_ = bitField0_;
    int to_bitField0_ = 0;
    if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
        to_bitField0_ |= 0x00000001;
    }
    result.accessToken_ = accessToken_;
    if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
        to_bitField0_ |= 0x00000002;
    }
    result.resultPath_ = resultPath_;
    if (((from_bitField0_ & 0x00000004) == 0x00000004)) {
        to_bitField0_ |= 0x00000004;
    }
    result.bootSuccess_ = bootSuccess_;
    if (((from_bitField0_ & 0x00000008) == 0x00000008)) {
        to_bitField0_ |= 0x00000008;
    }
    result.branch_ = branch_;
    if (((from_bitField0_ & 0x00000010) == 0x00000010)) {
        to_bitField0_ |= 0x00000010;
    }
    result.target_ = target_;
    if (((from_bitField0_ & 0x00000020) == 0x00000020)) {
        to_bitField0_ |= 0x00000020;
    }
    result.buildId_ = buildId_;
    if (((from_bitField0_ & 0x00000040) == 0x00000040)) {
        to_bitField0_ |= 0x00000040;
    }
    result.suitePlan_ = suitePlan_;
    if (((from_bitField0_ & 0x00000080) == 0x00000080)) {
        to_bitField0_ |= 0x00000080;
    }
    result.suiteVersion_ = suiteVersion_;
    if (((from_bitField0_ & 0x00000100) == 0x00000100)) {
        to_bitField0_ |= 0x00000100;
    }
    result.suiteBuildNumber_ = suiteBuildNumber_;
    if (((from_bitField0_ & 0x00000200) == 0x00000200)) {
        to_bitField0_ |= 0x00000200;
    }
    result.startTime_ = startTime_;
    if (((from_bitField0_ & 0x00000400) == 0x00000400)) {
        to_bitField0_ |= 0x00000400;
    }
    result.endTime_ = endTime_;
    if (((from_bitField0_ & 0x00000800) == 0x00000800)) {
        to_bitField0_ |= 0x00000800;
    }
    result.hostName_ = hostName_;
    if (((from_bitField0_ & 0x00001000) == 0x00001000)) {
        to_bitField0_ |= 0x00001000;
    }
    result.suiteName_ = suiteName_;
    if (((from_bitField0_ & 0x00002000) == 0x00002000)) {
        to_bitField0_ |= 0x00002000;
    }
    result.buildSystemFingerprint_ = buildSystemFingerprint_;
    if (((from_bitField0_ & 0x00004000) == 0x00004000)) {
        to_bitField0_ |= 0x00004000;
    }
    result.buildVendorFingerprint_ = buildVendorFingerprint_;
    if (((from_bitField0_ & 0x00008000) == 0x00008000)) {
        to_bitField0_ |= 0x00008000;
    }
    result.testType_ = testType_;
    if (((from_bitField0_ & 0x00010000) == 0x00010000)) {
        to_bitField0_ |= 0x00010000;
    }
    result.passedTestCaseCount_ = passedTestCaseCount_;
    if (((from_bitField0_ & 0x00020000) == 0x00020000)) {
        to_bitField0_ |= 0x00020000;
    }
    result.failedTestCaseCount_ = failedTestCaseCount_;
    if (((from_bitField0_ & 0x00040000) == 0x00040000)) {
        to_bitField0_ |= 0x00040000;
    }
    result.modulesDone_ = modulesDone_;
    if (((from_bitField0_ & 0x00080000) == 0x00080000)) {
        to_bitField0_ |= 0x00080000;
    }
    result.modulesTotal_ = modulesTotal_;
    if (((from_bitField0_ & 0x00100000) == 0x00100000)) {
        to_bitField0_ |= 0x00100000;
    }
    result.infraLogPath_ = infraLogPath_;
    if (((bitField0_ & 0x00200000) == 0x00200000)) {
        repackedImagePath_ = repackedImagePath_.getUnmodifiableView();
        bitField0_ = (bitField0_ & ~0x00200000);
    }
    result.repackedImagePath_ = repackedImagePath_;
    if (((from_bitField0_ & 0x00400000) == 0x00400000)) {
        to_bitField0_ |= 0x00200000;
    }
    result.vendorBuildId_ = vendorBuildId_;
    if (((from_bitField0_ & 0x00800000) == 0x00800000)) {
        to_bitField0_ |= 0x00400000;
    }
    result.gsiBuildId_ = gsiBuildId_;
    if (((from_bitField0_ & 0x01000000) == 0x01000000)) {
        to_bitField0_ |= 0x00800000;
    }
    if (scheduleConfigBuilder_ == null) {
        result.scheduleConfig_ = scheduleConfig_;
    } else {
        result.scheduleConfig_ = scheduleConfigBuilder_.build();
    }
    result.bitField0_ = to_bitField0_;
    onBuilt();
    return result;
}
#end_block

#method_before
public Builder mergeFrom(com.android.vts.proto.TestSuiteResultMessageProto.TestSuiteResultMessage other) {
    if (other == com.android.vts.proto.TestSuiteResultMessageProto.TestSuiteResultMessage.getDefaultInstance())
        return this;
    if (other.hasAccessToken()) {
        bitField0_ |= 0x00000001;
        accessToken_ = other.accessToken_;
        onChanged();
    }
    if (other.hasResultPath()) {
        bitField0_ |= 0x00000002;
        resultPath_ = other.resultPath_;
        onChanged();
    }
    if (other.hasBootSuccess()) {
        setBootSuccess(other.getBootSuccess());
    }
    if (other.hasBranch()) {
        bitField0_ |= 0x00000008;
        branch_ = other.branch_;
        onChanged();
    }
    if (other.hasTarget()) {
        bitField0_ |= 0x00000010;
        target_ = other.target_;
        onChanged();
    }
    if (other.hasBuildId()) {
        bitField0_ |= 0x00000020;
        buildId_ = other.buildId_;
        onChanged();
    }
    if (other.hasSuitePlan()) {
        bitField0_ |= 0x00000040;
        suitePlan_ = other.suitePlan_;
        onChanged();
    }
    if (other.hasSuiteVersion()) {
        bitField0_ |= 0x00000080;
        suiteVersion_ = other.suiteVersion_;
        onChanged();
    }
    if (other.hasSuiteBuildNumber()) {
        bitField0_ |= 0x00000100;
        suiteBuildNumber_ = other.suiteBuildNumber_;
        onChanged();
    }
    if (other.hasStartTime()) {
        setStartTime(other.getStartTime());
    }
    if (other.hasEndTime()) {
        setEndTime(other.getEndTime());
    }
    if (other.hasHostName()) {
        bitField0_ |= 0x00000800;
        hostName_ = other.hostName_;
        onChanged();
    }
    if (other.hasSuiteName()) {
        bitField0_ |= 0x00001000;
        suiteName_ = other.suiteName_;
        onChanged();
    }
    if (other.hasBuildSystemFingerprint()) {
        bitField0_ |= 0x00002000;
        buildSystemFingerprint_ = other.buildSystemFingerprint_;
        onChanged();
    }
    if (other.hasBuildVendorFingerprint()) {
        bitField0_ |= 0x00004000;
        buildVendorFingerprint_ = other.buildVendorFingerprint_;
        onChanged();
    }
    if (other.hasTestType()) {
        setTestType(other.getTestType());
    }
    if (other.hasPassedTestCaseCount()) {
        setPassedTestCaseCount(other.getPassedTestCaseCount());
    }
    if (other.hasFailedTestCaseCount()) {
        setFailedTestCaseCount(other.getFailedTestCaseCount());
    }
    if (other.hasModulesDone()) {
        setModulesDone(other.getModulesDone());
    }
    if (other.hasModulesTotal()) {
        setModulesTotal(other.getModulesTotal());
    }
    if (other.hasInfraLogPath()) {
        bitField0_ |= 0x00100000;
        infraLogPath_ = other.infraLogPath_;
        onChanged();
    }
    if (!other.repackedImagePath_.isEmpty()) {
        if (repackedImagePath_.isEmpty()) {
            repackedImagePath_ = other.repackedImagePath_;
            bitField0_ = (bitField0_ & ~0x00200000);
        } else {
            ensureRepackedImagePathIsMutable();
            repackedImagePath_.addAll(other.repackedImagePath_);
        }
        onChanged();
    }
    if (other.hasVendorBuildId()) {
        bitField0_ |= 0x00400000;
        vendorBuildId_ = other.vendorBuildId_;
        onChanged();
    }
    if (other.hasGsiBuildId()) {
        bitField0_ |= 0x00800000;
        gsiBuildId_ = other.gsiBuildId_;
        onChanged();
    }
    this.mergeUnknownFields(other.unknownFields);
    onChanged();
    return this;
}
#method_after
public Builder mergeFrom(com.android.vts.proto.TestSuiteResultMessageProto.TestSuiteResultMessage other) {
    if (other == com.android.vts.proto.TestSuiteResultMessageProto.TestSuiteResultMessage.getDefaultInstance())
        return this;
    if (other.hasAccessToken()) {
        bitField0_ |= 0x00000001;
        accessToken_ = other.accessToken_;
        onChanged();
    }
    if (other.hasResultPath()) {
        bitField0_ |= 0x00000002;
        resultPath_ = other.resultPath_;
        onChanged();
    }
    if (other.hasBootSuccess()) {
        setBootSuccess(other.getBootSuccess());
    }
    if (other.hasBranch()) {
        bitField0_ |= 0x00000008;
        branch_ = other.branch_;
        onChanged();
    }
    if (other.hasTarget()) {
        bitField0_ |= 0x00000010;
        target_ = other.target_;
        onChanged();
    }
    if (other.hasBuildId()) {
        bitField0_ |= 0x00000020;
        buildId_ = other.buildId_;
        onChanged();
    }
    if (other.hasSuitePlan()) {
        bitField0_ |= 0x00000040;
        suitePlan_ = other.suitePlan_;
        onChanged();
    }
    if (other.hasSuiteVersion()) {
        bitField0_ |= 0x00000080;
        suiteVersion_ = other.suiteVersion_;
        onChanged();
    }
    if (other.hasSuiteBuildNumber()) {
        bitField0_ |= 0x00000100;
        suiteBuildNumber_ = other.suiteBuildNumber_;
        onChanged();
    }
    if (other.hasStartTime()) {
        setStartTime(other.getStartTime());
    }
    if (other.hasEndTime()) {
        setEndTime(other.getEndTime());
    }
    if (other.hasHostName()) {
        bitField0_ |= 0x00000800;
        hostName_ = other.hostName_;
        onChanged();
    }
    if (other.hasSuiteName()) {
        bitField0_ |= 0x00001000;
        suiteName_ = other.suiteName_;
        onChanged();
    }
    if (other.hasBuildSystemFingerprint()) {
        bitField0_ |= 0x00002000;
        buildSystemFingerprint_ = other.buildSystemFingerprint_;
        onChanged();
    }
    if (other.hasBuildVendorFingerprint()) {
        bitField0_ |= 0x00004000;
        buildVendorFingerprint_ = other.buildVendorFingerprint_;
        onChanged();
    }
    if (other.hasTestType()) {
        setTestType(other.getTestType());
    }
    if (other.hasPassedTestCaseCount()) {
        setPassedTestCaseCount(other.getPassedTestCaseCount());
    }
    if (other.hasFailedTestCaseCount()) {
        setFailedTestCaseCount(other.getFailedTestCaseCount());
    }
    if (other.hasModulesDone()) {
        setModulesDone(other.getModulesDone());
    }
    if (other.hasModulesTotal()) {
        setModulesTotal(other.getModulesTotal());
    }
    if (other.hasInfraLogPath()) {
        bitField0_ |= 0x00100000;
        infraLogPath_ = other.infraLogPath_;
        onChanged();
    }
    if (!other.repackedImagePath_.isEmpty()) {
        if (repackedImagePath_.isEmpty()) {
            repackedImagePath_ = other.repackedImagePath_;
            bitField0_ = (bitField0_ & ~0x00200000);
        } else {
            ensureRepackedImagePathIsMutable();
            repackedImagePath_.addAll(other.repackedImagePath_);
        }
        onChanged();
    }
    if (other.hasVendorBuildId()) {
        bitField0_ |= 0x00400000;
        vendorBuildId_ = other.vendorBuildId_;
        onChanged();
    }
    if (other.hasGsiBuildId()) {
        bitField0_ |= 0x00800000;
        gsiBuildId_ = other.gsiBuildId_;
        onChanged();
    }
    if (other.hasScheduleConfig()) {
        mergeScheduleConfig(other.getScheduleConfig());
    }
    this.mergeUnknownFields(other.unknownFields);
    onChanged();
    return this;
}
#end_block

#method_before
private int runListPackages(boolean showSourceDir) throws RemoteException {
    final PrintWriter pw = getOutPrintWriter();
    int getFlags = 0;
    boolean listDisabled = false, listEnabled = false;
    boolean listSystem = false, listThirdParty = false;
    boolean listInstaller = false;
    boolean showUid = false;
    boolean showVersionCode = false;
    boolean showApex = false;
    int uid = -1;
    int userId = UserHandle.USER_SYSTEM;
    try {
        String opt;
        while ((opt = getNextOption()) != null) {
            switch(opt) {
                case "-d":
                    listDisabled = true;
                    break;
                case "-e":
                    listEnabled = true;
                    break;
                case "-a":
                    getFlags |= PackageManager.MATCH_KNOWN_PACKAGES;
                    break;
                case "-f":
                    showSourceDir = true;
                    break;
                case "-i":
                    listInstaller = true;
                    break;
                case "-l":
                    // old compat
                    break;
                case "-s":
                    listSystem = true;
                    break;
                case "-U":
                    showUid = true;
                    break;
                case "-u":
                    getFlags |= PackageManager.MATCH_UNINSTALLED_PACKAGES;
                    break;
                case "-3":
                    listThirdParty = true;
                    break;
                case "--show-versioncode":
                    showVersionCode = true;
                    break;
                case "--apex":
                    getFlags |= PackageManager.MATCH_APEX;
                    showApex = true;
                    break;
                case "--user":
                    userId = UserHandle.parseUserArg(getNextArgRequired());
                    break;
                case "--uid":
                    showUid = true;
                    uid = Integer.parseInt(getNextArgRequired());
                    break;
                default:
                    pw.println("Error: Unknown option: " + opt);
                    return -1;
            }
        }
    } catch (RuntimeException ex) {
        pw.println("Error: " + ex.toString());
        return -1;
    }
    final String filter = getNextArg();
    @SuppressWarnings("unchecked")
    final ParceledListSlice<PackageInfo> slice = mInterface.getInstalledPackages(getFlags, userId);
    final List<PackageInfo> packages = slice.getList();
    final int count = packages.size();
    for (int p = 0; p < count; p++) {
        final PackageInfo info = packages.get(p);
        if (filter != null && !info.packageName.contains(filter)) {
            continue;
        }
        final boolean hasApp = info.applicationInfo != null;
        if (uid != -1 && hasApp && info.applicationInfo.uid != uid) {
            continue;
        }
        final boolean isSystem = hasApp && (info.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) != 0;
        final boolean isEnabled = hasApp && info.applicationInfo.enabled;
        if ((!listDisabled || !isEnabled) && (!listEnabled || isEnabled) && (!listSystem || isSystem) && (!listThirdParty || !isSystem)) {
            pw.print("package:");
            if (showSourceDir && hasApp) {
                pw.print(info.applicationInfo.sourceDir);
                pw.print("=");
            }
            pw.print(info.packageName);
            if (showVersionCode && hasApp) {
                pw.print(" versionCode:");
                pw.print(info.applicationInfo.versionCode);
            }
            if (listInstaller && !info.isApex) {
                pw.print("  installer=");
                pw.print(mInterface.getInstallerPackageName(info.packageName));
            }
            if (showUid && hasApp) {
                pw.print(" uid:");
                pw.print(info.applicationInfo.uid);
            }
            if (showApex) {
                pw.print(" apex:");
                pw.print(info.isApex);
            }
            pw.println();
        }
    }
    return 0;
}
#method_after
private int runListPackages(boolean showSourceDir) throws RemoteException {
    final PrintWriter pw = getOutPrintWriter();
    int getFlags = 0;
    boolean listDisabled = false, listEnabled = false;
    boolean listSystem = false, listThirdParty = false;
    boolean listInstaller = false;
    boolean showUid = false;
    boolean showVersionCode = false;
    boolean listApexOnly = false;
    int uid = -1;
    int userId = UserHandle.USER_SYSTEM;
    try {
        String opt;
        while ((opt = getNextOption()) != null) {
            switch(opt) {
                case "-d":
                    listDisabled = true;
                    break;
                case "-e":
                    listEnabled = true;
                    break;
                case "-a":
                    getFlags |= PackageManager.MATCH_KNOWN_PACKAGES;
                    break;
                case "-f":
                    showSourceDir = true;
                    break;
                case "-i":
                    listInstaller = true;
                    break;
                case "-l":
                    // old compat
                    break;
                case "-s":
                    listSystem = true;
                    break;
                case "-U":
                    showUid = true;
                    break;
                case "-u":
                    getFlags |= PackageManager.MATCH_UNINSTALLED_PACKAGES;
                    break;
                case "-3":
                    listThirdParty = true;
                    break;
                case "--show-versioncode":
                    showVersionCode = true;
                    break;
                case "--apex-only":
                    getFlags |= PackageManager.MATCH_APEX;
                    listApexOnly = true;
                    break;
                case "--user":
                    userId = UserHandle.parseUserArg(getNextArgRequired());
                    break;
                case "--uid":
                    showUid = true;
                    uid = Integer.parseInt(getNextArgRequired());
                    break;
                default:
                    pw.println("Error: Unknown option: " + opt);
                    return -1;
            }
        }
    } catch (RuntimeException ex) {
        pw.println("Error: " + ex.toString());
        return -1;
    }
    final String filter = getNextArg();
    @SuppressWarnings("unchecked")
    final ParceledListSlice<PackageInfo> slice = mInterface.getInstalledPackages(getFlags, userId);
    final List<PackageInfo> packages = slice.getList();
    final int count = packages.size();
    for (int p = 0; p < count; p++) {
        final PackageInfo info = packages.get(p);
        if (filter != null && !info.packageName.contains(filter)) {
            continue;
        }
        final boolean isApex = info.isApex;
        if (uid != -1 && !isApex && info.applicationInfo.uid != uid) {
            continue;
        }
        final boolean isSystem = !isApex && (info.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) != 0;
        final boolean isEnabled = !isApex && info.applicationInfo.enabled;
        if ((!listDisabled || !isEnabled) && (!listEnabled || isEnabled) && (!listSystem || isSystem) && (!listThirdParty || !isSystem) && (!listApexOnly || isApex)) {
            pw.print("package:");
            if (showSourceDir && !isApex) {
                pw.print(info.applicationInfo.sourceDir);
                pw.print("=");
            }
            pw.print(info.packageName);
            if (showVersionCode && !isApex) {
                pw.print(" versionCode:");
                pw.print(info.applicationInfo.versionCode);
            }
            if (listInstaller && !isApex) {
                pw.print("  installer=");
                pw.print(mInterface.getInstallerPackageName(info.packageName));
            }
            if (showUid && !isApex) {
                pw.print(" uid:");
                pw.print(info.applicationInfo.uid);
            }
            pw.println();
        }
    }
    return 0;
}
#end_block

#method_before
@Override
public void onHelp() {
    final PrintWriter pw = getOutPrintWriter();
    pw.println("Package manager (package) commands:");
    pw.println("  help");
    pw.println("    Print this help text.");
    pw.println("");
    pw.println("  path [--user USER_ID] PACKAGE");
    pw.println("    Print the path to the .apk of the given PACKAGE.");
    pw.println("");
    pw.println("  dump PACKAGE");
    pw.println("    Print various system state associated with the given PACKAGE.");
    pw.println("");
    pw.println("  list features");
    pw.println("    Prints all features of the system.");
    pw.println("");
    pw.println("  has-feature FEATURE_NAME [version]");
    pw.println("    Prints true and returns exit status 0 when system has a FEATURE_NAME,");
    pw.println("    otherwise prints false and returns exit status 1");
    pw.println("");
    pw.println("  list instrumentation [-f] [TARGET-PACKAGE]");
    pw.println("    Prints all test packages; optionally only those targeting TARGET-PACKAGE");
    pw.println("    Options:");
    pw.println("      -f: dump the name of the .apk file containing the test package");
    pw.println("");
    pw.println("  list libraries");
    pw.println("    Prints all system libraries.");
    pw.println("");
    pw.println("  list packages [-f] [-d] [-e] [-s] [-3] [-i] [-l] [-u] [-U] ");
    pw.println("      [--apex] [--uid UID] [--user USER_ID] [FILTER]");
    pw.println("    Prints all packages; optionally only those whose name contains");
    pw.println("    the text in FILTER.  Options are:");
    pw.println("      -f: see their associated file");
    pw.println("      -a: all known packages");
    pw.println("      -d: filter to only show disabled packages");
    pw.println("      -e: filter to only show enabled packages");
    pw.println("      -s: filter to only show system packages");
    pw.println("      -3: filter to only show third party packages");
    pw.println("      -i: see the installer for the packages");
    pw.println("      -l: ignored (used for compatibility with older releases)");
    pw.println("      -U: also show the package UID");
    pw.println("      -u: also include uninstalled packages");
    pw.println("      --apex: also include APEX packages");
    pw.println("      --uid UID: filter to only show packages with the given UID");
    pw.println("      --user USER_ID: only list packages belonging to the given user");
    pw.println("");
    pw.println("  list permission-groups");
    pw.println("    Prints all known permission groups.");
    pw.println("");
    pw.println("  list permissions [-g] [-f] [-d] [-u] [GROUP]");
    pw.println("    Prints all known permissions; optionally only those in GROUP.  Options are:");
    pw.println("      -g: organize by group");
    pw.println("      -f: print all information");
    pw.println("      -s: short summary");
    pw.println("      -d: only list dangerous permissions");
    pw.println("      -u: list only the permissions users will see");
    pw.println("");
    pw.println("  resolve-activity [--brief] [--components] [--user USER_ID] INTENT");
    pw.println("    Prints the activity that resolves to the given INTENT.");
    pw.println("");
    pw.println("  query-activities [--brief] [--components] [--user USER_ID] INTENT");
    pw.println("    Prints all activities that can handle the given INTENT.");
    pw.println("");
    pw.println("  query-services [--brief] [--components] [--user USER_ID] INTENT");
    pw.println("    Prints all services that can handle the given INTENT.");
    pw.println("");
    pw.println("  query-receivers [--brief] [--components] [--user USER_ID] INTENT");
    pw.println("    Prints all broadcast receivers that can handle the given INTENT.");
    pw.println("");
    pw.println("  install [-lrtsfdg] [-i PACKAGE] [--user USER_ID|all|current]");
    pw.println("       [-p INHERIT_PACKAGE] [--install-location 0/1/2]");
    pw.println("       [--originating-uri URI] [---referrer URI]");
    pw.println("       [--abi ABI_NAME] [--force-sdk]");
    pw.println("       [--preload] [--instantapp] [--full] [--dont-kill]");
    pw.println("       [--force-uuid internal|UUID] [--pkg PACKAGE] [-S BYTES] [PATH|-]");
    pw.println("    Install an application.  Must provide the apk data to install, either as a");
    pw.println("    file path or '-' to read from stdin.  Options are:");
    pw.println("      -l: forward lock application");
    pw.println("      -R: disallow replacement of existing application");
    pw.println("      -t: allow test packages");
    pw.println("      -i: specify package name of installer owning the app");
    pw.println("      -s: install application on sdcard");
    pw.println("      -f: install application on internal flash");
    pw.println("      -d: allow version code downgrade (debuggable packages only)");
    pw.println("      -p: partial application install (new split on top of existing pkg)");
    pw.println("      -g: grant all runtime permissions");
    pw.println("      -S: size in bytes of package, required for stdin");
    pw.println("      --user: install under the given user.");
    pw.println("      --dont-kill: installing a new feature split, don't kill running app");
    pw.println("      --originating-uri: set URI where app was downloaded from");
    pw.println("      --referrer: set URI that instigated the install of the app");
    pw.println("      --pkg: specify expected package name of app being installed");
    pw.println("      --abi: override the default ABI of the platform");
    pw.println("      --instantapp: cause the app to be installed as an ephemeral install app");
    pw.println("      --full: cause the app to be installed as a non-ephemeral full app");
    pw.println("      --install-location: force the install location:");
    pw.println("          0=auto, 1=internal only, 2=prefer external");
    pw.println("      --force-uuid: force install on to disk volume with given UUID");
    pw.println("      --force-sdk: allow install even when existing app targets platform");
    pw.println("          codename but new one targets a final API level");
    pw.println("");
    pw.println("  install-create [-lrtsfdg] [-i PACKAGE] [--user USER_ID|all|current]");
    pw.println("       [-p INHERIT_PACKAGE] [--install-location 0/1/2]");
    pw.println("       [--originating-uri URI] [---referrer URI]");
    pw.println("       [--abi ABI_NAME] [--force-sdk]");
    pw.println("       [--preload] [--instantapp] [--full] [--dont-kill]");
    pw.println("       [--force-uuid internal|UUID] [--pkg PACKAGE] [-S BYTES]");
    pw.println("    Like \"install\", but starts an install session.  Use \"install-write\"");
    pw.println("    to push data into the session, and \"install-commit\" to finish.");
    pw.println("");
    pw.println("  install-write [-S BYTES] SESSION_ID SPLIT_NAME [PATH|-]");
    pw.println("    Write an apk into the given install session.  If the path is '-', data");
    pw.println("    will be read from stdin.  Options are:");
    pw.println("      -S: size in bytes of package, required for stdin");
    pw.println("");
    pw.println("  install-commit SESSION_ID");
    pw.println("    Commit the given active install session, installing the app.");
    pw.println("");
    pw.println("  install-abandon SESSION_ID");
    pw.println("    Delete the given active install session.");
    pw.println("");
    pw.println("  set-install-location LOCATION");
    pw.println("    Changes the default install location.  NOTE this is only intended for debugging;");
    pw.println("    using this can cause applications to break and other undersireable behavior.");
    pw.println("    LOCATION is one of:");
    pw.println("    0 [auto]: Let system decide the best location");
    pw.println("    1 [internal]: Install on internal device storage");
    pw.println("    2 [external]: Install on external media");
    pw.println("");
    pw.println("  get-install-location");
    pw.println("    Returns the current install location: 0, 1 or 2 as per set-install-location.");
    pw.println("");
    pw.println("  move-package PACKAGE [internal|UUID]");
    pw.println("");
    pw.println("  move-primary-storage [internal|UUID]");
    pw.println("");
    pw.println("  pm uninstall [-k] [--user USER_ID] [--versionCode VERSION_CODE] PACKAGE [SPLIT]");
    pw.println("    Remove the given package name from the system.  May remove an entire app");
    pw.println("    if no SPLIT name is specified, otherwise will remove only the split of the");
    pw.println("    given app.  Options are:");
    pw.println("      -k: keep the data and cache directories around after package removal.");
    pw.println("      --user: remove the app from the given user.");
    pw.println("      --versionCode: only uninstall if the app has the given version code.");
    pw.println("");
    pw.println("  clear [--user USER_ID] PACKAGE");
    pw.println("    Deletes all data associated with a package.");
    pw.println("");
    pw.println("  enable [--user USER_ID] PACKAGE_OR_COMPONENT");
    pw.println("  disable [--user USER_ID] PACKAGE_OR_COMPONENT");
    pw.println("  disable-user [--user USER_ID] PACKAGE_OR_COMPONENT");
    pw.println("  disable-until-used [--user USER_ID] PACKAGE_OR_COMPONENT");
    pw.println("  default-state [--user USER_ID] PACKAGE_OR_COMPONENT");
    pw.println("    These commands change the enabled state of a given package or");
    pw.println("    component (written as \"package/class\").");
    pw.println("");
    pw.println("  hide [--user USER_ID] PACKAGE_OR_COMPONENT");
    pw.println("  unhide [--user USER_ID] PACKAGE_OR_COMPONENT");
    pw.println("");
    pw.println("  suspend [--user USER_ID] TARGET-PACKAGE");
    pw.println("    Suspends the specified package (as user).");
    pw.println("");
    pw.println("  unsuspend [--user USER_ID] TARGET-PACKAGE");
    pw.println("    Unsuspends the specified package (as user).");
    pw.println("");
    pw.println("  grant [--user USER_ID] PACKAGE PERMISSION");
    pw.println("  revoke [--user USER_ID] PACKAGE PERMISSION");
    pw.println("    These commands either grant or revoke permissions to apps.  The permissions");
    pw.println("    must be declared as used in the app's manifest, be runtime permissions");
    pw.println("    (protection level dangerous), and the app targeting SDK greater than Lollipop MR1.");
    pw.println("");
    pw.println("  reset-permissions");
    pw.println("    Revert all runtime permissions to their default state.");
    pw.println("");
    pw.println("  set-permission-enforced PERMISSION [true|false]");
    pw.println("");
    pw.println("  get-privapp-permissions TARGET-PACKAGE");
    pw.println("    Prints all privileged permissions for a package.");
    pw.println("");
    pw.println("  get-privapp-deny-permissions TARGET-PACKAGE");
    pw.println("    Prints all privileged permissions that are denied for a package.");
    pw.println("");
    pw.println("  get-oem-permissions TARGET-PACKAGE");
    pw.println("    Prints all OEM permissions for a package.");
    pw.println("");
    pw.println("  set-app-link [--user USER_ID] PACKAGE {always|ask|never|undefined}");
    pw.println("  get-app-link [--user USER_ID] PACKAGE");
    pw.println("");
    pw.println("  trim-caches DESIRED_FREE_SPACE [internal|UUID]");
    pw.println("    Trim cache files to reach the given free space.");
    pw.println("");
    pw.println("  create-user [--profileOf USER_ID] [--managed] [--restricted] [--ephemeral]");
    pw.println("      [--guest] USER_NAME");
    pw.println("    Create a new user with the given USER_NAME, printing the new user identifier");
    pw.println("    of the user.");
    pw.println("");
    pw.println("  remove-user USER_ID");
    pw.println("    Remove the user with the given USER_IDENTIFIER, deleting all data");
    pw.println("    associated with that user");
    pw.println("");
    pw.println("  set-user-restriction [--user USER_ID] RESTRICTION VALUE");
    pw.println("");
    pw.println("  get-max-users");
    pw.println("");
    pw.println("  get-max-running-users");
    pw.println("");
    pw.println("  compile [-m MODE | -r REASON] [-f] [-c] [--split SPLIT_NAME]");
    pw.println("          [--reset] [--check-prof (true | false)] (-a | TARGET-PACKAGE)");
    pw.println("    Trigger compilation of TARGET-PACKAGE or all packages if \"-a\".  Options are:");
    pw.println("      -a: compile all packages");
    pw.println("      -c: clear profile data before compiling");
    pw.println("      -f: force compilation even if not needed");
    pw.println("      -m: select compilation mode");
    pw.println("          MODE is one of the dex2oat compiler filters:");
    pw.println("            assume-verified");
    pw.println("            extract");
    pw.println("            verify");
    pw.println("            quicken");
    pw.println("            space-profile");
    pw.println("            space");
    pw.println("            speed-profile");
    pw.println("            speed");
    pw.println("            everything");
    pw.println("      -r: select compilation reason");
    pw.println("          REASON is one of:");
    for (int i = 0; i < PackageManagerServiceCompilerMapping.REASON_STRINGS.length; i++) {
        pw.println("            " + PackageManagerServiceCompilerMapping.REASON_STRINGS[i]);
    }
    pw.println("      --reset: restore package to its post-install state");
    pw.println("      --check-prof (true | false): look at profiles when doing dexopt?");
    pw.println("      --secondary-dex: compile app secondary dex files");
    pw.println("      --split SPLIT: compile only the given split name");
    pw.println("");
    pw.println("  force-dex-opt PACKAGE");
    pw.println("    Force immediate execution of dex opt for the given PACKAGE.");
    pw.println("");
    pw.println("  bg-dexopt-job");
    pw.println("    Execute the background optimizations immediately.");
    pw.println("    Note that the command only runs the background optimizer logic. It may");
    pw.println("    overlap with the actual job but the job scheduler will not be able to");
    pw.println("    cancel it. It will also run even if the device is not in the idle");
    pw.println("    maintenance mode.");
    pw.println("");
    pw.println("  reconcile-secondary-dex-files TARGET-PACKAGE");
    pw.println("    Reconciles the package secondary dex files with the generated oat files.");
    pw.println("");
    pw.println("  dump-profiles TARGET-PACKAGE");
    pw.println("    Dumps method/class profile files to");
    pw.println("    " + ART_PROFILE_SNAPSHOT_DEBUG_LOCATION + "TARGET-PACKAGE.txt");
    pw.println("");
    pw.println("  snapshot-profile TARGET-PACKAGE [--code-path path]");
    pw.println("    Take a snapshot of the package profiles to");
    pw.println("    " + ART_PROFILE_SNAPSHOT_DEBUG_LOCATION + "TARGET-PACKAGE[-code-path].prof");
    pw.println("    If TARGET-PACKAGE=android it will take a snapshot of the boot image");
    pw.println("");
    pw.println("  set-home-activity [--user USER_ID] TARGET-COMPONENT");
    pw.println("    Set the default home activity (aka launcher).");
    pw.println("");
    pw.println("  set-installer PACKAGE INSTALLER");
    pw.println("    Set installer package name");
    pw.println("");
    pw.println("  get-instantapp-resolver");
    pw.println("    Return the name of the component that is the current instant app installer.");
    pw.println("");
    pw.println("  set-harmful-app-warning [--user <USER_ID>] <PACKAGE> [<WARNING>]");
    pw.println("    Mark the app as harmful with the given warning message.");
    pw.println("");
    pw.println("  get-harmful-app-warning [--user <USER_ID>] <PACKAGE>");
    pw.println("    Return the harmful app warning message for the given app, if present");
    pw.println();
    pw.println("  uninstall-system-updates");
    pw.println("    Remove updates to all system applications and fall back to their /system " + "version.");
    pw.println();
    Intent.printIntentArgsHelp(pw, "");
}
#method_after
@Override
public void onHelp() {
    final PrintWriter pw = getOutPrintWriter();
    pw.println("Package manager (package) commands:");
    pw.println("  help");
    pw.println("    Print this help text.");
    pw.println("");
    pw.println("  path [--user USER_ID] PACKAGE");
    pw.println("    Print the path to the .apk of the given PACKAGE.");
    pw.println("");
    pw.println("  dump PACKAGE");
    pw.println("    Print various system state associated with the given PACKAGE.");
    pw.println("");
    pw.println("  list features");
    pw.println("    Prints all features of the system.");
    pw.println("");
    pw.println("  has-feature FEATURE_NAME [version]");
    pw.println("    Prints true and returns exit status 0 when system has a FEATURE_NAME,");
    pw.println("    otherwise prints false and returns exit status 1");
    pw.println("");
    pw.println("  list instrumentation [-f] [TARGET-PACKAGE]");
    pw.println("    Prints all test packages; optionally only those targeting TARGET-PACKAGE");
    pw.println("    Options:");
    pw.println("      -f: dump the name of the .apk file containing the test package");
    pw.println("");
    pw.println("  list libraries");
    pw.println("    Prints all system libraries.");
    pw.println("");
    pw.println("  list packages [-f] [-d] [-e] [-s] [-3] [-i] [-l] [-u] [-U] ");
    pw.println("      [--apex-only] [--uid UID] [--user USER_ID] [FILTER]");
    pw.println("    Prints all packages; optionally only those whose name contains");
    pw.println("    the text in FILTER.  Options are:");
    pw.println("      -f: see their associated file");
    pw.println("      -a: all known packages (but excluding APEXes)");
    pw.println("      -d: filter to only show disabled packages");
    pw.println("      -e: filter to only show enabled packages");
    pw.println("      -s: filter to only show system packages");
    pw.println("      -3: filter to only show third party packages");
    pw.println("      -i: see the installer for the packages");
    pw.println("      -l: ignored (used for compatibility with older releases)");
    pw.println("      -U: also show the package UID");
    pw.println("      -u: also include uninstalled packages");
    pw.println("      --apex-only: only show APEX packages");
    pw.println("      --uid UID: filter to only show packages with the given UID");
    pw.println("      --user USER_ID: only list packages belonging to the given user");
    pw.println("");
    pw.println("  list permission-groups");
    pw.println("    Prints all known permission groups.");
    pw.println("");
    pw.println("  list permissions [-g] [-f] [-d] [-u] [GROUP]");
    pw.println("    Prints all known permissions; optionally only those in GROUP.  Options are:");
    pw.println("      -g: organize by group");
    pw.println("      -f: print all information");
    pw.println("      -s: short summary");
    pw.println("      -d: only list dangerous permissions");
    pw.println("      -u: list only the permissions users will see");
    pw.println("");
    pw.println("  resolve-activity [--brief] [--components] [--user USER_ID] INTENT");
    pw.println("    Prints the activity that resolves to the given INTENT.");
    pw.println("");
    pw.println("  query-activities [--brief] [--components] [--user USER_ID] INTENT");
    pw.println("    Prints all activities that can handle the given INTENT.");
    pw.println("");
    pw.println("  query-services [--brief] [--components] [--user USER_ID] INTENT");
    pw.println("    Prints all services that can handle the given INTENT.");
    pw.println("");
    pw.println("  query-receivers [--brief] [--components] [--user USER_ID] INTENT");
    pw.println("    Prints all broadcast receivers that can handle the given INTENT.");
    pw.println("");
    pw.println("  install [-lrtsfdg] [-i PACKAGE] [--user USER_ID|all|current]");
    pw.println("       [-p INHERIT_PACKAGE] [--install-location 0/1/2]");
    pw.println("       [--originating-uri URI] [---referrer URI]");
    pw.println("       [--abi ABI_NAME] [--force-sdk]");
    pw.println("       [--preload] [--instantapp] [--full] [--dont-kill]");
    pw.println("       [--force-uuid internal|UUID] [--pkg PACKAGE] [-S BYTES] [PATH|-]");
    pw.println("    Install an application.  Must provide the apk data to install, either as a");
    pw.println("    file path or '-' to read from stdin.  Options are:");
    pw.println("      -l: forward lock application");
    pw.println("      -R: disallow replacement of existing application");
    pw.println("      -t: allow test packages");
    pw.println("      -i: specify package name of installer owning the app");
    pw.println("      -s: install application on sdcard");
    pw.println("      -f: install application on internal flash");
    pw.println("      -d: allow version code downgrade (debuggable packages only)");
    pw.println("      -p: partial application install (new split on top of existing pkg)");
    pw.println("      -g: grant all runtime permissions");
    pw.println("      -S: size in bytes of package, required for stdin");
    pw.println("      --user: install under the given user.");
    pw.println("      --dont-kill: installing a new feature split, don't kill running app");
    pw.println("      --originating-uri: set URI where app was downloaded from");
    pw.println("      --referrer: set URI that instigated the install of the app");
    pw.println("      --pkg: specify expected package name of app being installed");
    pw.println("      --abi: override the default ABI of the platform");
    pw.println("      --instantapp: cause the app to be installed as an ephemeral install app");
    pw.println("      --full: cause the app to be installed as a non-ephemeral full app");
    pw.println("      --install-location: force the install location:");
    pw.println("          0=auto, 1=internal only, 2=prefer external");
    pw.println("      --force-uuid: force install on to disk volume with given UUID");
    pw.println("      --force-sdk: allow install even when existing app targets platform");
    pw.println("          codename but new one targets a final API level");
    pw.println("");
    pw.println("  install-create [-lrtsfdg] [-i PACKAGE] [--user USER_ID|all|current]");
    pw.println("       [-p INHERIT_PACKAGE] [--install-location 0/1/2]");
    pw.println("       [--originating-uri URI] [---referrer URI]");
    pw.println("       [--abi ABI_NAME] [--force-sdk]");
    pw.println("       [--preload] [--instantapp] [--full] [--dont-kill]");
    pw.println("       [--force-uuid internal|UUID] [--pkg PACKAGE] [-S BYTES]");
    pw.println("    Like \"install\", but starts an install session.  Use \"install-write\"");
    pw.println("    to push data into the session, and \"install-commit\" to finish.");
    pw.println("");
    pw.println("  install-write [-S BYTES] SESSION_ID SPLIT_NAME [PATH|-]");
    pw.println("    Write an apk into the given install session.  If the path is '-', data");
    pw.println("    will be read from stdin.  Options are:");
    pw.println("      -S: size in bytes of package, required for stdin");
    pw.println("");
    pw.println("  install-commit SESSION_ID");
    pw.println("    Commit the given active install session, installing the app.");
    pw.println("");
    pw.println("  install-abandon SESSION_ID");
    pw.println("    Delete the given active install session.");
    pw.println("");
    pw.println("  set-install-location LOCATION");
    pw.println("    Changes the default install location.  NOTE this is only intended for debugging;");
    pw.println("    using this can cause applications to break and other undersireable behavior.");
    pw.println("    LOCATION is one of:");
    pw.println("    0 [auto]: Let system decide the best location");
    pw.println("    1 [internal]: Install on internal device storage");
    pw.println("    2 [external]: Install on external media");
    pw.println("");
    pw.println("  get-install-location");
    pw.println("    Returns the current install location: 0, 1 or 2 as per set-install-location.");
    pw.println("");
    pw.println("  move-package PACKAGE [internal|UUID]");
    pw.println("");
    pw.println("  move-primary-storage [internal|UUID]");
    pw.println("");
    pw.println("  pm uninstall [-k] [--user USER_ID] [--versionCode VERSION_CODE] PACKAGE [SPLIT]");
    pw.println("    Remove the given package name from the system.  May remove an entire app");
    pw.println("    if no SPLIT name is specified, otherwise will remove only the split of the");
    pw.println("    given app.  Options are:");
    pw.println("      -k: keep the data and cache directories around after package removal.");
    pw.println("      --user: remove the app from the given user.");
    pw.println("      --versionCode: only uninstall if the app has the given version code.");
    pw.println("");
    pw.println("  clear [--user USER_ID] PACKAGE");
    pw.println("    Deletes all data associated with a package.");
    pw.println("");
    pw.println("  enable [--user USER_ID] PACKAGE_OR_COMPONENT");
    pw.println("  disable [--user USER_ID] PACKAGE_OR_COMPONENT");
    pw.println("  disable-user [--user USER_ID] PACKAGE_OR_COMPONENT");
    pw.println("  disable-until-used [--user USER_ID] PACKAGE_OR_COMPONENT");
    pw.println("  default-state [--user USER_ID] PACKAGE_OR_COMPONENT");
    pw.println("    These commands change the enabled state of a given package or");
    pw.println("    component (written as \"package/class\").");
    pw.println("");
    pw.println("  hide [--user USER_ID] PACKAGE_OR_COMPONENT");
    pw.println("  unhide [--user USER_ID] PACKAGE_OR_COMPONENT");
    pw.println("");
    pw.println("  suspend [--user USER_ID] TARGET-PACKAGE");
    pw.println("    Suspends the specified package (as user).");
    pw.println("");
    pw.println("  unsuspend [--user USER_ID] TARGET-PACKAGE");
    pw.println("    Unsuspends the specified package (as user).");
    pw.println("");
    pw.println("  grant [--user USER_ID] PACKAGE PERMISSION");
    pw.println("  revoke [--user USER_ID] PACKAGE PERMISSION");
    pw.println("    These commands either grant or revoke permissions to apps.  The permissions");
    pw.println("    must be declared as used in the app's manifest, be runtime permissions");
    pw.println("    (protection level dangerous), and the app targeting SDK greater than Lollipop MR1.");
    pw.println("");
    pw.println("  reset-permissions");
    pw.println("    Revert all runtime permissions to their default state.");
    pw.println("");
    pw.println("  set-permission-enforced PERMISSION [true|false]");
    pw.println("");
    pw.println("  get-privapp-permissions TARGET-PACKAGE");
    pw.println("    Prints all privileged permissions for a package.");
    pw.println("");
    pw.println("  get-privapp-deny-permissions TARGET-PACKAGE");
    pw.println("    Prints all privileged permissions that are denied for a package.");
    pw.println("");
    pw.println("  get-oem-permissions TARGET-PACKAGE");
    pw.println("    Prints all OEM permissions for a package.");
    pw.println("");
    pw.println("  set-app-link [--user USER_ID] PACKAGE {always|ask|never|undefined}");
    pw.println("  get-app-link [--user USER_ID] PACKAGE");
    pw.println("");
    pw.println("  trim-caches DESIRED_FREE_SPACE [internal|UUID]");
    pw.println("    Trim cache files to reach the given free space.");
    pw.println("");
    pw.println("  create-user [--profileOf USER_ID] [--managed] [--restricted] [--ephemeral]");
    pw.println("      [--guest] USER_NAME");
    pw.println("    Create a new user with the given USER_NAME, printing the new user identifier");
    pw.println("    of the user.");
    pw.println("");
    pw.println("  remove-user USER_ID");
    pw.println("    Remove the user with the given USER_IDENTIFIER, deleting all data");
    pw.println("    associated with that user");
    pw.println("");
    pw.println("  set-user-restriction [--user USER_ID] RESTRICTION VALUE");
    pw.println("");
    pw.println("  get-max-users");
    pw.println("");
    pw.println("  get-max-running-users");
    pw.println("");
    pw.println("  compile [-m MODE | -r REASON] [-f] [-c] [--split SPLIT_NAME]");
    pw.println("          [--reset] [--check-prof (true | false)] (-a | TARGET-PACKAGE)");
    pw.println("    Trigger compilation of TARGET-PACKAGE or all packages if \"-a\".  Options are:");
    pw.println("      -a: compile all packages");
    pw.println("      -c: clear profile data before compiling");
    pw.println("      -f: force compilation even if not needed");
    pw.println("      -m: select compilation mode");
    pw.println("          MODE is one of the dex2oat compiler filters:");
    pw.println("            assume-verified");
    pw.println("            extract");
    pw.println("            verify");
    pw.println("            quicken");
    pw.println("            space-profile");
    pw.println("            space");
    pw.println("            speed-profile");
    pw.println("            speed");
    pw.println("            everything");
    pw.println("      -r: select compilation reason");
    pw.println("          REASON is one of:");
    for (int i = 0; i < PackageManagerServiceCompilerMapping.REASON_STRINGS.length; i++) {
        pw.println("            " + PackageManagerServiceCompilerMapping.REASON_STRINGS[i]);
    }
    pw.println("      --reset: restore package to its post-install state");
    pw.println("      --check-prof (true | false): look at profiles when doing dexopt?");
    pw.println("      --secondary-dex: compile app secondary dex files");
    pw.println("      --split SPLIT: compile only the given split name");
    pw.println("");
    pw.println("  force-dex-opt PACKAGE");
    pw.println("    Force immediate execution of dex opt for the given PACKAGE.");
    pw.println("");
    pw.println("  bg-dexopt-job");
    pw.println("    Execute the background optimizations immediately.");
    pw.println("    Note that the command only runs the background optimizer logic. It may");
    pw.println("    overlap with the actual job but the job scheduler will not be able to");
    pw.println("    cancel it. It will also run even if the device is not in the idle");
    pw.println("    maintenance mode.");
    pw.println("");
    pw.println("  reconcile-secondary-dex-files TARGET-PACKAGE");
    pw.println("    Reconciles the package secondary dex files with the generated oat files.");
    pw.println("");
    pw.println("  dump-profiles TARGET-PACKAGE");
    pw.println("    Dumps method/class profile files to");
    pw.println("    " + ART_PROFILE_SNAPSHOT_DEBUG_LOCATION + "TARGET-PACKAGE.txt");
    pw.println("");
    pw.println("  snapshot-profile TARGET-PACKAGE [--code-path path]");
    pw.println("    Take a snapshot of the package profiles to");
    pw.println("    " + ART_PROFILE_SNAPSHOT_DEBUG_LOCATION + "TARGET-PACKAGE[-code-path].prof");
    pw.println("    If TARGET-PACKAGE=android it will take a snapshot of the boot image");
    pw.println("");
    pw.println("  set-home-activity [--user USER_ID] TARGET-COMPONENT");
    pw.println("    Set the default home activity (aka launcher).");
    pw.println("");
    pw.println("  set-installer PACKAGE INSTALLER");
    pw.println("    Set installer package name");
    pw.println("");
    pw.println("  get-instantapp-resolver");
    pw.println("    Return the name of the component that is the current instant app installer.");
    pw.println("");
    pw.println("  set-harmful-app-warning [--user <USER_ID>] <PACKAGE> [<WARNING>]");
    pw.println("    Mark the app as harmful with the given warning message.");
    pw.println("");
    pw.println("  get-harmful-app-warning [--user <USER_ID>] <PACKAGE>");
    pw.println("    Return the harmful app warning message for the given app, if present");
    pw.println();
    pw.println("  uninstall-system-updates");
    pw.println("    Remove updates to all system applications and fall back to their /system " + "version.");
    pw.println();
    Intent.printIntentArgsHelp(pw, "");
}
#end_block

#method_before
final void finishBooting() {
    synchronized (this) {
        if (!mBootAnimationComplete) {
            mCallFinishBooting = true;
            return;
        }
        mCallFinishBooting = false;
    }
    ArraySet<String> completedIsas = new ArraySet<String>();
    for (String abi : Build.SUPPORTED_ABIS) {
        zygoteProcess.establishZygoteConnectionForAbi(abi);
        final String instructionSet = VMRuntime.getInstructionSet(abi);
        if (!completedIsas.contains(instructionSet)) {
            try {
                mInstaller.markBootComplete(VMRuntime.getInstructionSet(abi));
            } catch (InstallerException e) {
                if (!VMRuntime.didPruneDalvikCache()) {
                    // This is technically not the right filter, as different zygotes may
                    // have made different pruning decisions. But the log is best effort,
                    // anyways.
                    Slog.w(TAG, "Unable to mark boot complete for abi: " + abi + " (" + e.getMessage() + ")");
                }
            }
            completedIsas.add(instructionSet);
        }
    }
    IntentFilter pkgFilter = new IntentFilter();
    pkgFilter.addAction(Intent.ACTION_QUERY_PACKAGE_RESTART);
    pkgFilter.addDataScheme("package");
    mContext.registerReceiver(new BroadcastReceiver() {

        @Override
        public void onReceive(Context context, Intent intent) {
            String[] pkgs = intent.getStringArrayExtra(Intent.EXTRA_PACKAGES);
            if (pkgs != null) {
                for (String pkg : pkgs) {
                    synchronized (ActivityManagerService.this) {
                        if (forceStopPackageLocked(pkg, -1, false, false, false, false, false, 0, "query restart")) {
                            setResultCode(Activity.RESULT_OK);
                            return;
                        }
                    }
                }
            }
        }
    }, pkgFilter);
    IntentFilter dumpheapFilter = new IntentFilter();
    dumpheapFilter.addAction(DumpHeapActivity.ACTION_DELETE_DUMPHEAP);
    mContext.registerReceiver(new BroadcastReceiver() {

        @Override
        public void onReceive(Context context, Intent intent) {
            if (intent.getBooleanExtra(DumpHeapActivity.EXTRA_DELAY_DELETE, false)) {
                mHandler.sendEmptyMessageDelayed(POST_DUMP_HEAP_NOTIFICATION_MSG, 5 * 60 * 1000);
            } else {
                mHandler.sendEmptyMessage(POST_DUMP_HEAP_NOTIFICATION_MSG);
            }
        }
    }, dumpheapFilter);
    // Let system services know.
    mSystemServiceManager.startBootPhase(SystemService.PHASE_BOOT_COMPLETED);
    synchronized (this) {
        // Ensure that any processes we had put on hold are now started
        // up.
        final int NP = mProcessesOnHold.size();
        if (NP > 0) {
            ArrayList<ProcessRecord> procs = new ArrayList<ProcessRecord>(mProcessesOnHold);
            for (int ip = 0; ip < NP; ip++) {
                if (DEBUG_PROCESSES)
                    Slog.v(TAG_PROCESSES, "Starting process on hold: " + procs.get(ip));
                startProcessLocked(procs.get(ip), "on-hold", null);
            }
        }
        if (mFactoryTest == FactoryTest.FACTORY_TEST_LOW_LEVEL) {
            return;
        }
        // Start looking for apps that are abusing wake locks.
        Message nmsg = mHandler.obtainMessage(CHECK_EXCESSIVE_POWER_USE_MSG);
        mHandler.sendMessageDelayed(nmsg, mConstants.POWER_CHECK_INTERVAL);
        // Tell anyone interested that we are done booting!
        SystemProperties.set("sys.boot_completed", "1");
        // And trigger dev.bootcomplete if we are not showing encryption progress
        if (!"trigger_restart_min_framework".equals(SystemProperties.get("vold.decrypt")) || "".equals(SystemProperties.get("vold.encrypt_progress"))) {
            SystemProperties.set("dev.bootcomplete", "1");
        }
        mUserController.sendBootCompleted(new IIntentReceiver.Stub() {

            @Override
            public void performReceive(Intent intent, int resultCode, String data, Bundle extras, boolean ordered, boolean sticky, int sendingUser) {
                synchronized (ActivityManagerService.this) {
                    requestPssAllProcsLocked(SystemClock.uptimeMillis(), true, false);
                }
            }
        });
        mUserController.scheduleStartProfiles();
    }
}
#method_after
final void finishBooting() {
    synchronized (this) {
        if (!mBootAnimationComplete) {
            mCallFinishBooting = true;
            return;
        }
        mCallFinishBooting = false;
    }
    ArraySet<String> completedIsas = new ArraySet<String>();
    for (String abi : Build.SUPPORTED_ABIS) {
        zygoteProcess.establishZygoteConnectionForAbi(abi);
        final String instructionSet = VMRuntime.getInstructionSet(abi);
        if (!completedIsas.contains(instructionSet)) {
            try {
                mInstaller.markBootComplete(VMRuntime.getInstructionSet(abi));
            } catch (InstallerException e) {
                if (!VMRuntime.didPruneDalvikCache()) {
                    // This is technically not the right filter, as different zygotes may
                    // have made different pruning decisions. But the log is best effort,
                    // anyways.
                    Slog.w(TAG, "Unable to mark boot complete for abi: " + abi + " (" + e.getMessage() + ")");
                }
            }
            completedIsas.add(instructionSet);
        }
    }
    IntentFilter pkgFilter = new IntentFilter();
    pkgFilter.addAction(Intent.ACTION_QUERY_PACKAGE_RESTART);
    pkgFilter.addDataScheme("package");
    mContext.registerReceiver(new BroadcastReceiver() {

        @Override
        public void onReceive(Context context, Intent intent) {
            String[] pkgs = intent.getStringArrayExtra(Intent.EXTRA_PACKAGES);
            if (pkgs != null) {
                for (String pkg : pkgs) {
                    synchronized (ActivityManagerService.this) {
                        if (forceStopPackageLocked(pkg, -1, false, false, false, false, false, 0, "query restart")) {
                            setResultCode(Activity.RESULT_OK);
                            return;
                        }
                    }
                }
            }
        }
    }, pkgFilter);
    IntentFilter dumpheapFilter = new IntentFilter();
    dumpheapFilter.addAction(DumpHeapActivity.ACTION_DELETE_DUMPHEAP);
    mContext.registerReceiver(new BroadcastReceiver() {

        @Override
        public void onReceive(Context context, Intent intent) {
            if (intent.getBooleanExtra(DumpHeapActivity.EXTRA_DELAY_DELETE, false)) {
                mHandler.sendEmptyMessageDelayed(POST_DUMP_HEAP_NOTIFICATION_MSG, 5 * 60 * 1000);
            } else {
                mHandler.sendEmptyMessage(POST_DUMP_HEAP_NOTIFICATION_MSG);
            }
        }
    }, dumpheapFilter);
    // Let system services know.
    mSystemServiceManager.startBootPhase(SystemService.PHASE_BOOT_COMPLETED);
    synchronized (this) {
        // Ensure that any processes we had put on hold are now started
        // up.
        final int NP = mProcessesOnHold.size();
        if (NP > 0) {
            ArrayList<ProcessRecord> procs = new ArrayList<ProcessRecord>(mProcessesOnHold);
            for (int ip = 0; ip < NP; ip++) {
                if (DEBUG_PROCESSES)
                    Slog.v(TAG_PROCESSES, "Starting process on hold: " + procs.get(ip));
                startProcessLocked(procs.get(ip), "on-hold", null);
            }
        }
        if (mFactoryTest == FactoryTest.FACTORY_TEST_LOW_LEVEL) {
            return;
        }
        // Start looking for apps that are abusing wake locks.
        Message nmsg = mHandler.obtainMessage(CHECK_EXCESSIVE_POWER_USE_MSG);
        mHandler.sendMessageDelayed(nmsg, mConstants.POWER_CHECK_INTERVAL);
        // Tell anyone interested that we are done booting!
        SystemProperties.set("sys.boot_completed", "1");
        // And trigger dev.bootcomplete if we are not showing encryption progress
        if (!"trigger_restart_min_framework".equals(VoldProperties.decrypt().orElse("")) || "".equals(VoldProperties.encrypt_progress().orElse(""))) {
            SystemProperties.set("dev.bootcomplete", "1");
        }
        mUserController.sendBootCompleted(new IIntentReceiver.Stub() {

            @Override
            public void performReceive(Intent intent, int resultCode, String data, Bundle extras, boolean ordered, boolean sticky, int sendingUser) {
                synchronized (ActivityManagerService.this) {
                    requestPssAllProcsLocked(SystemClock.uptimeMillis(), true, false);
                }
            }
        });
        mUserController.scheduleStartProfiles();
    }
}
#end_block

#method_before
@Deprecated
@Override
public void requestBugReport(int bugreportType) {
    String extraOptions = null;
    switch(bugreportType) {
        case ActivityManager.BUGREPORT_OPTION_DEFAULT:
            // Default options.
            break;
        case ActivityManager.BUGREPORT_OPTION_FULL:
            extraOptions = "bugreportfull";
            break;
        case ActivityManager.BUGREPORT_OPTION_INTERACTIVE:
            extraOptions = "bugreportplus";
            break;
        case ActivityManager.BUGREPORT_OPTION_REMOTE:
            extraOptions = "bugreportremote";
            break;
        case ActivityManager.BUGREPORT_OPTION_WEAR:
            extraOptions = "bugreportwear";
            break;
        case ActivityManager.BUGREPORT_OPTION_TELEPHONY:
            extraOptions = "bugreporttelephony";
            break;
        case ActivityManager.BUGREPORT_OPTION_WIFI:
            extraOptions = "bugreportwifi";
            break;
        default:
            throw new IllegalArgumentException("Provided bugreport type is not correct, value: " + bugreportType);
    }
    // Always log caller, even if it does not have permission to dump.
    String type = extraOptions == null ? "bugreport" : extraOptions;
    Slog.i(TAG, type + " requested by UID " + Binder.getCallingUid());
    enforceCallingPermission(android.Manifest.permission.DUMP, "requestBugReport");
    if (extraOptions != null) {
        SystemProperties.set("dumpstate.options", extraOptions);
    }
    SystemProperties.set("ctl.start", "bugreport");
}
#method_after
@Deprecated
@Override
public void requestBugReport(int bugreportType) {
    String extraOptions = null;
    switch(bugreportType) {
        case ActivityManager.BUGREPORT_OPTION_FULL:
            extraOptions = "bugreportfull";
            break;
        case ActivityManager.BUGREPORT_OPTION_INTERACTIVE:
            extraOptions = "bugreportplus";
            break;
        case ActivityManager.BUGREPORT_OPTION_REMOTE:
            extraOptions = "bugreportremote";
            break;
        case ActivityManager.BUGREPORT_OPTION_WEAR:
            extraOptions = "bugreportwear";
            break;
        case ActivityManager.BUGREPORT_OPTION_TELEPHONY:
            extraOptions = "bugreporttelephony";
            break;
        case ActivityManager.BUGREPORT_OPTION_WIFI:
            extraOptions = "bugreportwifi";
            break;
        default:
            throw new IllegalArgumentException("Provided bugreport type is not correct, value: " + bugreportType);
    }
    // Always log caller, even if it does not have permission to dump.
    String type = extraOptions == null ? "bugreport" : extraOptions;
    Slog.i(TAG, type + " requested by UID " + Binder.getCallingUid());
    enforceCallingPermission(android.Manifest.permission.DUMP, "requestBugReport");
    if (extraOptions != null) {
        SystemProperties.set("dumpstate.options", extraOptions);
    }
    SystemProperties.set("ctl.start", "bugreport");
}
#end_block

#method_before
@Test
public void testShowTitleItems() {
    Uri uri = Uri.parse("content://pkg/slice");
    ListBuilder lb = new ListBuilder(mContext, uri, ListBuilder.INFINITY);
    lb.addRow(new ListBuilder.RowBuilder().setTitleItem(getAction("Action")).setTitle("Title").setSubtitle("Subtitle").setPrimaryAction(getAction("Action")));
    Slice s = lb.build();
    mSliceView.setSlice(s);
    mSliceView.showTitleItems(true);
    RowContent row = (RowContent) mSliceView.mListContent.getRowItems().get(0);
    assertTrue(row.hasTitleItems());
    assertNotNull(row.getStartItem());
}
#method_after
@Test
public void testShowTitleItems() {
    Uri uri = Uri.parse("content://pkg/slice");
    ListBuilder lb = new ListBuilder(mContext, uri, ListBuilder.INFINITY);
    lb.addRow(new ListBuilder.RowBuilder().setTitleItem(getAction("Action")).setTitle("Title").setSubtitle("Subtitle").setPrimaryAction(getAction("Action")));
    Slice s = lb.build();
    mSliceView.setSlice(s);
    mSliceView.showTitleItems(true);
    RowContent row = (RowContent) mSliceView.mListContent.getRowItems().get(0);
    assertTrue(row.hasTitleItems());
    assertNotNull(row.getStartItem());
    mSliceView.showTitleItems(false);
    assertFalse(row.hasTitleItems());
    assertNull(row.getStartItem());
}
#end_block

#method_before
private void populateViews(boolean isUpdate) {
    boolean skipSliderUpdate = isUpdate && mIsRangeSliding;
    if (!skipSliderUpdate) {
        resetViewState();
    }
    if (mRowContent.getLayoutDir() != -1) {
        setLayoutDirection(mRowContent.getLayoutDir());
    }
    if (mRowContent.isDefaultSeeMore()) {
        showSeeMore();
        return;
    }
    CharSequence contentDescr = mRowContent.getContentDescription();
    if (contentDescr != null) {
        mContent.setContentDescription(contentDescr);
    }
    mStartItem = mRowContent.getStartItem();
    boolean showStart = mStartItem != null && (mRowIndex > 0 || mRowContent.hasTitleItems());
    if (showStart) {
        showStart = addItem(mStartItem, mTintColor, true);
    }
    mStartContainer.setVisibility(showStart ? View.VISIBLE : View.GONE);
    final SliceItem titleItem = mRowContent.getTitleItem();
    if (titleItem != null) {
        mPrimaryText.setText(titleItem.getSanitizedText());
    }
    if (mSliceStyle != null) {
        mPrimaryText.setTextSize(TypedValue.COMPLEX_UNIT_PX, mIsHeader ? mSliceStyle.getHeaderTitleSize() : mSliceStyle.getTitleSize());
        mPrimaryText.setTextColor(mSliceStyle.getTitleColor());
    }
    mPrimaryText.setVisibility(titleItem != null ? View.VISIBLE : View.GONE);
    addSubtitle(titleItem != null);
    SliceItem primaryAction = mRowContent.getPrimaryAction();
    if (primaryAction != null && primaryAction != mStartItem) {
        mRowAction = new SliceActionImpl(primaryAction);
        if (mRowAction.isToggle()) {
            // If primary action is a toggle, add it and we're done
            addAction(mRowAction, mTintColor, mEndContainer, false);
            // TODO: if start item is tappable, touch feedback should exclude it
            setViewClickable(mRootView, true);
            return;
        }
    }
    final SliceItem range = mRowContent.getRange();
    if (range != null) {
        if (mRowAction != null) {
            setViewClickable(mRootView, true);
        }
        if (!skipSliderUpdate) {
            determineRangeValues(range);
            addRange(range);
        } else {
            // Even if we're skipping the update, we should still update the range item
            mRangeItem = range;
        }
        return;
    }
    updateEndItems();
    updateActionSpinner();
}
#method_after
private void populateViews(boolean isUpdate) {
    boolean skipSliderUpdate = isUpdate && mIsRangeSliding;
    if (!skipSliderUpdate) {
        resetViewState();
    }
    if (mRowContent.getLayoutDir() != -1) {
        setLayoutDirection(mRowContent.getLayoutDir());
    }
    if (mRowContent.isDefaultSeeMore()) {
        showSeeMore();
        return;
    }
    CharSequence contentDescr = mRowContent.getContentDescription();
    if (contentDescr != null) {
        mContent.setContentDescription(contentDescr);
    }
    mStartItem = mRowContent.getStartItem();
    boolean showStart = mStartItem != null && (mRowIndex > 0 || mRowContent.hasTitleItems());
    if (showStart) {
        showStart = addItem(mStartItem, mTintColor, true);
    }
    mStartContainer.setVisibility(showStart ? View.VISIBLE : View.GONE);
    final SliceItem titleItem = mRowContent.getTitleItem();
    if (titleItem != null) {
        mPrimaryText.setText(titleItem.getSanitizedText());
    }
    if (mSliceStyle != null) {
        mPrimaryText.setTextSize(TypedValue.COMPLEX_UNIT_PX, mIsHeader ? mSliceStyle.getHeaderTitleSize() : mSliceStyle.getTitleSize());
        mPrimaryText.setTextColor(mSliceStyle.getTitleColor());
    }
    mPrimaryText.setVisibility(titleItem != null ? View.VISIBLE : View.GONE);
    addSubtitle(titleItem != null);
    if (mRowContent.hasBottomDivider()) {
        if (mSliceStyle != null) {
            final int padding = mSliceStyle.getHeaderDividerPadding();
            LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) mBottomDivider.getLayoutParams();
            lp.setMargins(padding, 0, padding, 0);
            mBottomDivider.setLayoutParams(lp);
        }
        mBottomDivider.setVisibility(View.VISIBLE);
    } else {
        mBottomDivider.setVisibility(View.GONE);
    }
    SliceItem primaryAction = mRowContent.getPrimaryAction();
    if (primaryAction != null && primaryAction != mStartItem) {
        mRowAction = new SliceActionImpl(primaryAction);
        if (mRowAction.isToggle()) {
            // If primary action is a toggle, add it and we're done
            addAction(mRowAction, mTintColor, mEndContainer, false);
            // TODO: if start item is tappable, touch feedback should exclude it
            setViewClickable(mRootView, true);
            return;
        }
    }
    final SliceItem range = mRowContent.getRange();
    if (range != null) {
        if (mRowAction != null) {
            setViewClickable(mRootView, true);
        }
        if (!skipSliderUpdate) {
            determineRangeValues(range);
            addRange(range);
        } else {
            // Even if we're skipping the update, we should still update the range item
            mRangeItem = range;
        }
        return;
    }
    updateEndItems();
    updateActionSpinner();
}
#end_block

#method_before
private void updateEndItems() {
    if (mRowContent == null) {
        return;
    }
    mEndContainer.removeAllViews();
    // If we're here we can can show end items; check for top level actions first
    List endItems = mRowContent.getEndItems();
    if (mHeaderActions != null) {
        // Use these if we have them instead
        endItems = mHeaderActions;
    }
    // doesn't show title items.
    if (mRowIndex == 0 && mStartItem != null && endItems.isEmpty() && !mRowContent.hasTitleItems()) {
        endItems.add(mStartItem);
    }
    // If we're here we might be able to show end items
    int endItemCount = 0;
    boolean firstItemIsADefaultToggle = false;
    boolean singleActionAtTheEnd = false;
    SliceItem endAction = null;
    for (int i = 0; i < endItems.size(); i++) {
        final SliceItem endItem = (endItems.get(i) instanceof SliceItem) ? (SliceItem) endItems.get(i) : ((SliceActionImpl) endItems.get(i)).getSliceItem();
        if (endItemCount < MAX_END_ITEMS) {
            if (addItem(endItem, mTintColor, false)) {
                if (endAction == null && SliceQuery.find(endItem, FORMAT_ACTION) != null) {
                    endAction = endItem;
                }
                endItemCount++;
                if (endItemCount == 1) {
                    firstItemIsADefaultToggle = !mToggles.isEmpty() && SliceQuery.find(endItem.getSlice(), FORMAT_IMAGE) == null;
                    singleActionAtTheEnd = endItems.size() == 1 && SliceQuery.find(endItem, FORMAT_ACTION) != null;
                }
            }
        }
    }
    mEndContainer.setVisibility(endItemCount > 0 ? VISIBLE : GONE);
    // If there is a row action and the first end item is a default toggle, or action divider
    // is set by presenter and a single action is at the end of the row, show the divider.
    mDivider.setVisibility(mRowAction != null && (firstItemIsADefaultToggle || (mRowContent.hasActionDivider() && singleActionAtTheEnd)) ? View.VISIBLE : View.GONE);
    boolean hasStartAction = mStartItem != null && SliceQuery.find(mStartItem, FORMAT_ACTION) != null;
    boolean hasEndItemAction = endAction != null;
    boolean endAndRowActionTheSame = false;
    if (mRowAction != null) {
        setViewClickable(mRootView, true);
    } else if (hasEndItemAction != hasStartAction && (endItemCount == 1 || hasStartAction)) {
        // This row only has 1 action in start or end position; make whole row clickable for it
        endAndRowActionTheSame = true;
        if (!mToggles.isEmpty()) {
            mRowAction = mToggles.keySet().iterator().next();
        } else if (!mActions.isEmpty() && mActions.size() == 1) {
            mRowAction = mActions.valueAt(0).getAction();
        }
        setViewClickable(mRootView, true);
    }
    if (mRowAction != null && !endAndRowActionTheSame && mLoadingActions.contains(mRowAction.getSliceItem())) {
        mShowActionSpinner = true;
    }
}
#method_after
private void updateEndItems() {
    if (mRowContent == null) {
        return;
    }
    mEndContainer.removeAllViews();
    // If we're here we can can show end items; check for top level actions first
    List endItems = mRowContent.getEndItems();
    if (mHeaderActions != null) {
        // Use these if we have them instead
        endItems = mHeaderActions;
    }
    // doesn't show title items.
    if (mRowIndex == 0 && mStartItem != null && endItems.isEmpty() && !mRowContent.hasTitleItems()) {
        endItems.add(mStartItem);
    }
    // If we're here we might be able to show end items
    int endItemCount = 0;
    boolean firstItemIsADefaultToggle = false;
    boolean singleActionAtTheEnd = false;
    SliceItem endAction = null;
    for (int i = 0; i < endItems.size(); i++) {
        final SliceItem endItem = (endItems.get(i) instanceof SliceItem) ? (SliceItem) endItems.get(i) : ((SliceActionImpl) endItems.get(i)).getSliceItem();
        if (endItemCount < MAX_END_ITEMS) {
            if (addItem(endItem, mTintColor, false)) {
                if (endAction == null && SliceQuery.find(endItem, FORMAT_ACTION) != null) {
                    endAction = endItem;
                }
                endItemCount++;
                if (endItemCount == 1) {
                    firstItemIsADefaultToggle = !mToggles.isEmpty() && SliceQuery.find(endItem.getSlice(), FORMAT_IMAGE) == null;
                    singleActionAtTheEnd = endItems.size() == 1 && SliceQuery.find(endItem, FORMAT_ACTION) != null;
                }
            }
        }
    }
    mEndContainer.setVisibility(endItemCount > 0 ? VISIBLE : GONE);
    // If there is a row action and the first end item is a default toggle, or action divider
    // is set by presenter and a single action is at the end of the row, show the divider.
    mActionDivider.setVisibility(mRowAction != null && (firstItemIsADefaultToggle || (mRowContent.hasActionDivider() && singleActionAtTheEnd)) ? View.VISIBLE : View.GONE);
    boolean hasStartAction = mStartItem != null && SliceQuery.find(mStartItem, FORMAT_ACTION) != null;
    boolean hasEndItemAction = endAction != null;
    boolean endAndRowActionTheSame = false;
    if (mRowAction != null) {
        setViewClickable(mRootView, true);
    } else if (hasEndItemAction != hasStartAction && (endItemCount == 1 || hasStartAction)) {
        // This row only has 1 action in start or end position; make whole row clickable for it
        endAndRowActionTheSame = true;
        if (!mToggles.isEmpty()) {
            mRowAction = mToggles.keySet().iterator().next();
        } else if (!mActions.isEmpty() && mActions.size() == 1) {
            mRowAction = mActions.valueAt(0).getAction();
        }
        setViewClickable(mRootView, true);
    }
    if (mRowAction != null && !endAndRowActionTheSame && mLoadingActions.contains(mRowAction.getSliceItem())) {
        mShowActionSpinner = true;
    }
}
#end_block

#method_before
private void resetViewState() {
    mRootView.setVisibility(VISIBLE);
    setLayoutDirection(View.LAYOUT_DIRECTION_INHERIT);
    setViewClickable(mRootView, false);
    setViewClickable(mContent, false);
    mStartContainer.removeAllViews();
    mEndContainer.removeAllViews();
    mEndContainer.setVisibility(GONE);
    mPrimaryText.setText(null);
    mSecondaryText.setText(null);
    mLastUpdatedText.setText(null);
    mLastUpdatedText.setVisibility(GONE);
    mToggles.clear();
    mActions.clear();
    mRowAction = null;
    mStartItem = null;
    mDivider.setVisibility(GONE);
    if (mSeeMoreView != null) {
        mRootView.removeView(mSeeMoreView);
        mSeeMoreView = null;
    }
    mIsRangeSliding = false;
    mRangeHasPendingUpdate = false;
    mRangeItem = null;
    mRangeMinValue = 0;
    mRangeValue = 0;
    mLastSentRangeUpdate = 0;
    mHandler = null;
    if (mRangeBar != null) {
        removeView(mRangeBar);
        mRangeBar = null;
    }
    mActionSpinner.setVisibility(GONE);
}
#method_after
private void resetViewState() {
    mRootView.setVisibility(VISIBLE);
    setLayoutDirection(View.LAYOUT_DIRECTION_INHERIT);
    setViewClickable(mRootView, false);
    setViewClickable(mContent, false);
    mStartContainer.removeAllViews();
    mEndContainer.removeAllViews();
    mEndContainer.setVisibility(GONE);
    mPrimaryText.setText(null);
    mSecondaryText.setText(null);
    mLastUpdatedText.setText(null);
    mLastUpdatedText.setVisibility(GONE);
    mToggles.clear();
    mActions.clear();
    mRowAction = null;
    mStartItem = null;
    mBottomDivider.setVisibility(GONE);
    mActionDivider.setVisibility(GONE);
    if (mSeeMoreView != null) {
        mRootView.removeView(mSeeMoreView);
        mSeeMoreView = null;
    }
    mIsRangeSliding = false;
    mRangeHasPendingUpdate = false;
    mRangeItem = null;
    mRangeMinValue = 0;
    mRangeValue = 0;
    mLastSentRangeUpdate = 0;
    mHandler = null;
    if (mRangeBar != null) {
        removeView(mRangeBar);
        mRangeBar = null;
    }
    mActionSpinner.setVisibility(GONE);
}
#end_block

#method_before
public void setSlice(@Nullable Slice slice) {
    initSliceMetrics(slice);
    boolean isUpdate = slice != null && mCurrentSlice != null && slice.getUri().equals(mCurrentSlice.getUri());
    SliceMetadata oldSliceData = mSliceMetadata;
    mCurrentSlice = slice;
    mSliceMetadata = mCurrentSlice != null ? SliceMetadata.from(getContext(), mCurrentSlice) : null;
    if (isUpdate) {
        // If its an update check the loading state
        SliceMetadata newSliceData = mSliceMetadata;
        if (oldSliceData.getLoadingState() == SliceMetadata.LOADED_ALL && newSliceData.getLoadingState() == SliceMetadata.LOADED_NONE) {
            // ignore the update.
            return;
        }
    } else {
        mCurrentView.resetView();
    }
    mListContent = mSliceMetadata != null ? mSliceMetadata.getListContent() : null;
    if (mShowTitleItems) {
        showTitleItems(true);
    }
    if (mShowActionDividers) {
        showActionDividers(true);
    }
    if (mListContent == null || !mListContent.isValid()) {
        mActions = null;
        mCurrentView.resetView();
        updateActions();
        return;
    }
    // New slice means we shouldn't have any actions loading
    mCurrentView.setLoadingActions(null);
    // Check if the slice content is expired and show when it was last updated
    mActions = mSliceMetadata.getSliceActions();
    mCurrentView.setLastUpdated(mSliceMetadata.getLastUpdatedTime());
    mCurrentView.setShowLastUpdated(mShowLastUpdated && mSliceMetadata.isExpired());
    mCurrentView.setAllowTwoLines(mSliceMetadata.isPermissionSlice());
    // Tint color can come with the slice, so may need to update it
    mCurrentView.setTint(getTintColor());
    if (mListContent.getLayoutDir() != -1) {
        mCurrentView.setLayoutDirection(mListContent.getLayoutDir());
    } else {
        mCurrentView.setLayoutDirection(View.LAYOUT_DIRECTION_INHERIT);
    }
    // Set the slice
    mCurrentView.setSliceContent(mListContent);
    updateActions();
    // Log slice metrics visible.
    logSliceMetricsVisibilityChange(true);
    // Automatically refresh the last updated label when the slice TTL isn't infinity.
    refreshLastUpdatedLabel(true);
}
#method_after
public void setSlice(@Nullable Slice slice) {
    initSliceMetrics(slice);
    boolean isUpdate = slice != null && mCurrentSlice != null && slice.getUri().equals(mCurrentSlice.getUri());
    SliceMetadata oldSliceData = mSliceMetadata;
    mCurrentSlice = slice;
    mSliceMetadata = mCurrentSlice != null ? SliceMetadata.from(getContext(), mCurrentSlice) : null;
    if (isUpdate) {
        // If its an update check the loading state
        SliceMetadata newSliceData = mSliceMetadata;
        if (oldSliceData.getLoadingState() == SliceMetadata.LOADED_ALL && newSliceData.getLoadingState() == SliceMetadata.LOADED_NONE) {
            // ignore the update.
            return;
        }
    } else {
        mCurrentView.resetView();
    }
    mListContent = mSliceMetadata != null ? mSliceMetadata.getListContent() : null;
    if (mShowTitleItems) {
        showTitleItems(true);
    }
    if (mShowHeaderDivider) {
        showHeaderDivider(true);
    }
    if (mShowActionDividers) {
        showActionDividers(true);
    }
    if (mListContent == null || !mListContent.isValid()) {
        mActions = null;
        mCurrentView.resetView();
        updateActions();
        return;
    }
    // New slice means we shouldn't have any actions loading
    mCurrentView.setLoadingActions(null);
    // Check if the slice content is expired and show when it was last updated
    mActions = mSliceMetadata.getSliceActions();
    mCurrentView.setLastUpdated(mSliceMetadata.getLastUpdatedTime());
    mCurrentView.setShowLastUpdated(mShowLastUpdated && mSliceMetadata.isExpired());
    mCurrentView.setAllowTwoLines(mSliceMetadata.isPermissionSlice());
    // Tint color can come with the slice, so may need to update it
    mCurrentView.setTint(getTintColor());
    if (mListContent.getLayoutDir() != -1) {
        mCurrentView.setLayoutDirection(mListContent.getLayoutDir());
    } else {
        mCurrentView.setLayoutDirection(View.LAYOUT_DIRECTION_INHERIT);
    }
    // Set the slice
    mCurrentView.setSliceContent(mListContent);
    updateActions();
    // Log slice metrics visible.
    logSliceMetricsVisibilityChange(true);
    // Automatically refresh the last updated label when the slice TTL isn't infinity.
    refreshLastUpdatedLabel(true);
}
#end_block

#method_before
public void showTitleItems(boolean enabled) {
    mShowTitleItems = true;
    if (mListContent != null) {
        mListContent.showTitleItems(enabled);
    }
}
#method_after
public void showTitleItems(boolean enabled) {
    mShowTitleItems = enabled;
    if (mListContent != null) {
        mListContent.showTitleItems(enabled);
    }
}
#end_block

#method_before
private void smoothScrollToPosition_scrollerOnlyJumps(final boolean canFindTarget) throws Throwable {
    final List<Integer> receivedScrollToPositions = new ArrayList<>();
    final TestAdapter testAdapter = new TestAdapter(200);
    final AtomicBoolean mTargetFound = new AtomicBoolean(false);
    TestLayoutManager tlm = new TestLayoutManager() {

        int pendingScrollPosition = -1;

        @Override
        public void onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state) {
            detachAndScrapAttachedViews(recycler);
            final int pos = pendingScrollPosition < 0 ? 0 : pendingScrollPosition;
            layoutRange(recycler, pos, pos + 10);
            if (layoutLatch != null) {
                layoutLatch.countDown();
            }
        }

        @Override
        public void smoothScrollToPosition(RecyclerView recyclerView, RecyclerView.State state, final int position) {
            RecyclerView.SmoothScroller ss = new LinearSmoothScroller(recyclerView.getContext()) {

                @Override
                public PointF computeScrollVectorForPosition(int targetPosition) {
                    return new PointF(0, 1);
                }

                @Override
                protected void onTargetFound(View targetView, RecyclerView.State state, Action action) {
                    super.onTargetFound(targetView, state, action);
                    mTargetFound.set(true);
                }

                @Override
                protected void updateActionForInterimTarget(Action action) {
                    int limit = canFindTarget ? getTargetPosition() : 100;
                    if (pendingScrollPosition + 2 < limit) {
                        if (pendingScrollPosition != NO_POSITION) {
                            assertEquals(pendingScrollPosition, getChildViewHolderInt(getChildAt(0)).getAdapterPosition());
                        }
                        action.jumpTo(pendingScrollPosition + 2);
                    }
                }
            };
            ss.setTargetPosition(position);
            startSmoothScroll(ss);
        }

        @Override
        public void scrollToPosition(int position) {
            receivedScrollToPositions.add(position);
            pendingScrollPosition = position;
            requestLayout();
        }
    };
    final RecyclerView rv = new RecyclerView(getActivity());
    rv.setAdapter(testAdapter);
    rv.setLayoutManager(tlm);
    tlm.expectLayouts(1);
    setRecyclerView(rv);
    tlm.waitForLayout(2);
    mActivityRule.runOnUiThread(new Runnable() {

        @Override
        public void run() {
            rv.smoothScrollToPosition(150);
        }
    });
    int limit = 100;
    while (rv.getLayoutManager().isSmoothScrolling() && --limit > 0) {
        Thread.sleep(200);
        checkForMainThreadException();
    }
    checkForMainThreadException();
    assertTrue(limit > 0);
    for (int i = 1; i < 100; i += 2) {
        assertTrue("scroll positions must include " + i, receivedScrollToPositions.contains(i));
    }
    assertEquals(canFindTarget, mTargetFound.get());
}
#method_after
private void smoothScrollToPosition_scrollerOnlyJumps(final boolean canFindTarget) throws Throwable {
    final List<Integer> receivedScrollToPositions = new ArrayList<>();
    final TestAdapter testAdapter = new TestAdapter(200);
    final AtomicBoolean mTargetFound = new AtomicBoolean(false);
    TestLayoutManager tlm = new TestLayoutManager() {

        int pendingScrollPosition = -1;

        @Override
        public void onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state) {
            detachAndScrapAttachedViews(recycler);
            final int pos = pendingScrollPosition < 0 ? 0 : pendingScrollPosition;
            layoutRange(recycler, pos, pos + 10);
            if (layoutLatch != null) {
                layoutLatch.countDown();
            }
        }

        @Override
        public void smoothScrollToPosition(RecyclerView recyclerView, RecyclerView.State state, final int position) {
            RecyclerView.SmoothScroller ss = new LinearSmoothScroller(recyclerView.getContext()) {

                @Override
                public PointF computeScrollVectorForPosition(int targetPosition) {
                    return new PointF(0, 1);
                }

                @Override
                protected void onTargetFound(View targetView, RecyclerView.State state, Action action) {
                    super.onTargetFound(targetView, state, action);
                    mTargetFound.set(true);
                }

                @Override
                protected void updateActionForInterimTarget(Action action) {
                    int limit = canFindTarget ? getTargetPosition() : 100;
                    if (pendingScrollPosition + 2 < limit) {
                        if (pendingScrollPosition != NO_POSITION) {
                            assertEquals(pendingScrollPosition, getChildViewHolderInt(getChildAt(0)).getAdapterPosition());
                        }
                        action.jumpTo(pendingScrollPosition + 2);
                    }
                }
            };
            ss.setTargetPosition(position);
            startSmoothScroll(ss);
        }

        @Override
        public void scrollToPosition(int position) {
            receivedScrollToPositions.add(position);
            pendingScrollPosition = position;
            requestLayout();
        }
    };
    final RecyclerView rv = new RecyclerView(getActivity());
    rv.setAdapter(testAdapter);
    rv.setLayoutManager(tlm);
    tlm.expectLayouts(1);
    setRecyclerView(rv);
    tlm.waitForLayout(2);
    final ArrayList<Integer> scrollStates = new ArrayList<>();
    rv.addOnScrollListener(new RecyclerView.OnScrollListener() {

        @Override
        public void onScrollStateChanged(RecyclerView recyclerView, int newState) {
            scrollStates.add(newState);
        }
    });
    mActivityRule.runOnUiThread(new Runnable() {

        @Override
        public void run() {
            rv.smoothScrollToPosition(150);
        }
    });
    int limit = 100;
    while (rv.getLayoutManager().isSmoothScrolling() && --limit > 0) {
        Thread.sleep(200);
        checkForMainThreadException();
    }
    checkForMainThreadException();
    assertTrue(limit > 0);
    for (int i = 1; i < 100; i += 2) {
        assertTrue("scroll positions must include " + i, receivedScrollToPositions.contains(i));
    }
    assertThat(scrollStates.toArray(), is(equalTo(new Object[] { SCROLL_STATE_SETTLING, SCROLL_STATE_IDLE })));
    assertEquals(canFindTarget, mTargetFound.get());
}
#end_block

#method_before
private LinkedHashMap<String, IConfiguration> loadOneConfig(String configName, String configFullName, Set<IAbi> abis, String suiteTag) {
    LinkedHashMap<String, IConfiguration> toRun = new LinkedHashMap<>();
    final String name = configName.replace(CONFIG_EXT, "");
    final String[] pathArg = new String[] { configFullName };
    try {
        boolean primaryAbi = true;
        boolean shouldCreateMultiAbi = true;
        // If a particular parameter was requested to be run, find it.
        IModuleParameter mForcedParameter = null;
        if (mForcedModuleParameter != null) {
            mForcedParameter = ModuleParametersHelper.getParameterHandler(mForcedModuleParameter);
        }
        // configs are idempotent. This however means we parse the same file multiple times
        for (IAbi abi : abis) {
            // Only enable the primary abi filtering when switching to the parameterized mode
            if (mAllowParameterizedModules && !primaryAbi && !shouldCreateMultiAbi) {
                continue;
            }
            String baseId = AbiUtils.createId(abi.getName(), name);
            if (!shouldRunModule(baseId)) {
                // skip this name/abi combination.
                continue;
            }
            IConfiguration config = mConfigFactory.createConfigurationFromArgs(pathArg);
            // If a suiteTag is used, we load with it.
            if (!Strings.isNullOrEmpty(suiteTag) && !config.getConfigurationDescription().getSuiteTags().contains(suiteTag)) {
                CLog.d("Configuration %s does not include the suite-tag '%s'. Ignoring it.", configFullName, suiteTag);
                continue;
            }
            boolean skipCreatingBaseConfig = false;
            List<IModuleParameter> params = getModuleParameters(name, config);
            // Handle parameterized modules if enabled.
            if (mAllowParameterizedModules) {
                if (params.isEmpty() && mForcedParameter != null && !(mForcedParameter instanceof NegativeHandler)) {
                    // standard module.
                    continue;
                }
                shouldCreateMultiAbi = shouldCreateMultiAbiForBase(params);
                // If we find any parameterized combination.
                for (IModuleParameter param : params) {
                    if (param instanceof NegativeHandler) {
                        continue;
                    }
                    if (mForcedParameter != null) {
                        // When a particular parameter is forced, only create it not the others
                        if (param.getClass().equals(mForcedParameter.getClass())) {
                            skipCreatingBaseConfig = true;
                        } else {
                            continue;
                        }
                    }
                    // Only create primary abi of parameterized modules
                    if (!primaryAbi) {
                        continue;
                    }
                    String fullId = String.format("%s[%s]", baseId, param.getParameterIdentifier());
                    IConfiguration paramConfig = mConfigFactory.createConfigurationFromArgs(pathArg);
                    setUpConfig(name, baseId, fullId, paramConfig, abi);
                    param.applySetup(paramConfig);
                    toRun.put(fullId, paramConfig);
                }
            }
            primaryAbi = false;
            // version of it.
            if (skipCreatingBaseConfig) {
                continue;
            }
            // Always add the base regular configuration to the execution.
            setUpConfig(name, baseId, baseId, config, abi);
            toRun.put(baseId, config);
        }
    } catch (ConfigurationException e) {
        throw new RuntimeException(String.format("Error parsing configuration: %s: '%s'", configFullName, e.getMessage()), e);
    }
    return toRun;
}
#method_after
private LinkedHashMap<String, IConfiguration> loadOneConfig(String configName, String configFullName, Set<IAbi> abis, String suiteTag) {
    LinkedHashMap<String, IConfiguration> toRun = new LinkedHashMap<>();
    final String name = configName.replace(CONFIG_EXT, "");
    final String[] pathArg = new String[] { configFullName };
    try {
        boolean primaryAbi = true;
        boolean shouldCreateMultiAbi = true;
        // If a particular parameter was requested to be run, find it.
        IModuleParameter mForcedParameter = null;
        if (mForcedModuleParameter != null) {
            mForcedParameter = ModuleParametersHelper.getParameterHandler(mForcedModuleParameter);
        }
        // configs are idempotent. This however means we parse the same file multiple times
        for (IAbi abi : abis) {
            // Only enable the primary abi filtering when switching to the parameterized mode
            if (mAllowParameterizedModules && !primaryAbi && !shouldCreateMultiAbi) {
                continue;
            }
            String baseId = AbiUtils.createId(abi.getName(), name);
            if (!shouldRunModule(baseId)) {
                // skip this name/abi combination.
                continue;
            }
            IConfiguration config = mConfigFactory.createConfigurationFromArgs(pathArg);
            // If a suiteTag is used, we load with it.
            if (!Strings.isNullOrEmpty(suiteTag) && !config.getConfigurationDescription().getSuiteTags().contains(suiteTag)) {
                CLog.d("Configuration %s does not include the suite-tag '%s'. Ignoring it.", configFullName, suiteTag);
                continue;
            }
            boolean skipCreatingBaseConfig = false;
            List<IModuleParameter> params = getModuleParameters(name, config);
            // Handle parameterized modules if enabled.
            if (mAllowParameterizedModules) {
                if (params.isEmpty() && mForcedParameter != null && !(mForcedParameter instanceof NegativeHandler)) {
                    // standard module.
                    continue;
                }
                shouldCreateMultiAbi = shouldCreateMultiAbiForBase(params);
                // If we find any parameterized combination.
                for (IModuleParameter param : params) {
                    if (param instanceof NegativeHandler) {
                        if (mForcedParameter != null && !param.getClass().equals(mForcedParameter.getClass())) {
                            skipCreatingBaseConfig = true;
                        }
                        continue;
                    }
                    if (mForcedParameter != null) {
                        // When a particular parameter is forced, only create it not the others
                        if (param.getClass().equals(mForcedParameter.getClass())) {
                            skipCreatingBaseConfig = true;
                        } else {
                            continue;
                        }
                    }
                    // Only create primary abi of parameterized modules
                    if (!primaryAbi) {
                        continue;
                    }
                    String fullId = String.format("%s[%s]", baseId, param.getParameterIdentifier());
                    IConfiguration paramConfig = mConfigFactory.createConfigurationFromArgs(pathArg);
                    setUpConfig(name, baseId, fullId, paramConfig, abi);
                    param.applySetup(paramConfig);
                    toRun.put(fullId, paramConfig);
                }
            }
            primaryAbi = false;
            // version of it.
            if (skipCreatingBaseConfig) {
                continue;
            }
            // Always add the base regular configuration to the execution.
            setUpConfig(name, baseId, baseId, config, abi);
            toRun.put(baseId, config);
        }
    } catch (ConfigurationException e) {
        throw new RuntimeException(String.format("Error parsing configuration: %s: '%s'", configFullName, e.getMessage()), e);
    }
    return toRun;
}
#end_block

#method_before
@VisibleForTesting
void logDeviceBatteryLevel(IInvocationContext context, String event) {
    for (ITestDevice testDevice : context.getDevices()) {
        if (testDevice == null) {
            continue;
        }
        IDevice device = testDevice.getIDevice();
        if (device == null || device instanceof StubDevice) {
            continue;
        }
        try {
            Integer batteryLevel = device.getBattery(500, TimeUnit.MILLISECONDS).get();
            CLog.v("%s - %s - %d%%", BATT_TAG, event, batteryLevel);
            context.getBuildInfo(testDevice).addBuildAttribute(String.format(BATTERY_ATTRIBUTE_FORMAT_KEY, testDevice.getSerialNumber(), event), batteryLevel.toString());
            continue;
        } catch (InterruptedException | ExecutionException e) {
        // fall through
        }
        CLog.v("Failed to get battery level for %s", testDevice.getSerialNumber());
    }
}
#method_after
@VisibleForTesting
void logDeviceBatteryLevel(IInvocationContext context, String event) {
    for (ITestDevice testDevice : context.getDevices()) {
        if (testDevice == null) {
            continue;
        }
        if (testDevice.getIDevice() instanceof StubDevice) {
            continue;
        }
        Integer batteryLevel = testDevice.getBattery();
        if (batteryLevel == null) {
            CLog.v("Failed to get battery level for %s", testDevice.getSerialNumber());
            continue;
        }
        CLog.v("%s - %s - %d%%", BATT_TAG, event, batteryLevel);
        context.getBuildInfo(testDevice).addBuildAttribute(String.format(BATTERY_ATTRIBUTE_FORMAT_KEY, testDevice.getSerialNumber(), event), batteryLevel.toString());
    }
}
#end_block

#method_before
public void checkDeviceBatteryLevel() {
    for (String deviceName : mInvocationContext.getDeviceConfigNames()) {
        if (mCmd.getConfiguration().getDeviceConfigByName(deviceName).getDeviceOptions() == null) {
            CLog.d("No deviceOptions in the configuration, cannot do Battery level check");
            return;
        }
        final Integer cutoffBattery = mCmd.getConfiguration().getDeviceConfigByName(deviceName).getDeviceOptions().getCutoffBattery();
        if (mInvocationContext.getDevice(deviceName) != null && cutoffBattery != null) {
            final IDevice device = mInvocationContext.getDevice(deviceName).getIDevice();
            int batteryLevel = -1;
            try {
                batteryLevel = device.getBattery(500, TimeUnit.MILLISECONDS).get();
            } catch (InterruptedException | ExecutionException e) {
            // fall through
            }
            CLog.d("device %s: battery level=%d%%", device.getSerialNumber(), batteryLevel);
            // So batteryLevel=0 will not trigger a stop.
            if (0 < batteryLevel && batteryLevel < cutoffBattery) {
                if (RunUtil.getDefault().isInterruptAllowed()) {
                    CLog.i("Stopping %s: battery too low (%d%% < %d%%)", getName(), batteryLevel, cutoffBattery);
                    stopInvocation(String.format("battery too low (%d%% < %d%%)", batteryLevel, cutoffBattery));
                } else {
                    // In this case, the battery is check periodically by CommandScheduler
                    // so there will be more opportunity to terminate the invocation when
                    // it's interruptible.
                    CLog.w("device: %s has a low battery but is in uninterruptible state.", device.getSerialNumber());
                }
            }
        }
    }
}
#method_after
public void checkDeviceBatteryLevel() {
    for (String deviceName : mInvocationContext.getDeviceConfigNames()) {
        if (mCmd.getConfiguration().getDeviceConfigByName(deviceName).getDeviceOptions() == null) {
            CLog.d("No deviceOptions in the configuration, cannot do Battery level check");
            return;
        }
        final Integer cutoffBattery = mCmd.getConfiguration().getDeviceConfigByName(deviceName).getDeviceOptions().getCutoffBattery();
        if (mInvocationContext.getDevice(deviceName) != null && cutoffBattery != null) {
            final ITestDevice device = mInvocationContext.getDevice(deviceName);
            Integer batteryLevel = device.getBattery();
            if (batteryLevel == null) {
                return;
            }
            CLog.d("device %s: battery level=%d%%", device.getSerialNumber(), batteryLevel);
            // So batteryLevel=0 will not trigger a stop.
            if (0 < batteryLevel && batteryLevel < cutoffBattery) {
                if (RunUtil.getDefault().isInterruptAllowed()) {
                    CLog.i("Stopping %s: battery too low (%d%% < %d%%)", getName(), batteryLevel, cutoffBattery);
                    stopInvocation(String.format("battery too low (%d%% < %d%%)", batteryLevel, cutoffBattery));
                } else {
                    // In this case, the battery is check periodically by CommandScheduler
                    // so there will be more opportunity to terminate the invocation when
                    // it's interruptible.
                    CLog.w("device: %s has a low battery but is in uninterruptible state.", device.getSerialNumber());
                }
            }
        }
    }
}
#end_block

#method_before
protected Set<File> validateGcsFilePath() throws ConfigurationException {
    Set<File> gcsFiles = new HashSet<>();
    for (Map.Entry<String, OptionFieldsForName> optionPair : mOptionMap.entrySet()) {
        final String optName = optionPair.getKey();
        final OptionFieldsForName optionFields = optionPair.getValue();
        if (optName.indexOf(NAMESPACE_SEPARATOR) >= 0) {
            // Only return unqualified option names
            continue;
        }
        GCSDownloaderHelper downloader = createDownloader();
        for (Map.Entry<Object, Field> fieldEntry : optionFields) {
            final Object obj = fieldEntry.getKey();
            final Field field = fieldEntry.getValue();
            final Option option = field.getAnnotation(Option.class);
            if (option == null) {
                continue;
            }
            // At this point, we know this is an option field; make sure it's set
            field.setAccessible(true);
            final Object value;
            try {
                value = field.get(obj);
            } catch (IllegalAccessException e) {
                throw new ConfigurationException(String.format("internal error: %s", e.getMessage()));
            }
            if (value == null) {
                continue;
            } else if (value instanceof File) {
                File consideredFile = (File) value;
                // Don't use absolute path as it would not start with gs:
                if (consideredFile.getPath().startsWith("gs:/")) {
                    String path = consideredFile.getPath().replaceAll("gs:/", "gs://");
                    CLog.d("Considering: %s for download.", path);
                    // We need to download the file from the bucket
                    try {
                        File gsFile = downloader.fetchTestResource(path);
                        gcsFiles.add(gsFile);
                        // Replace the field value
                        field.set(obj, gsFile);
                    } catch (BuildRetrievalError | IllegalAccessException e) {
                        CLog.e(e);
                        // Clean up all files
                        for (File f : gcsFiles) {
                            FileUtil.deleteFile(f);
                        }
                        throw new ConfigurationException(String.format("Failed to download %s", path), e);
                    }
                }
            }
        // TODO: Handle collection of files
        }
    }
    return gcsFiles;
}
#method_after
protected Set<File> validateGcsFilePath() throws ConfigurationException {
    Set<File> gcsFiles = new HashSet<>();
    for (Map.Entry<String, OptionFieldsForName> optionPair : mOptionMap.entrySet()) {
        final String optName = optionPair.getKey();
        final OptionFieldsForName optionFields = optionPair.getValue();
        if (optName.indexOf(NAMESPACE_SEPARATOR) >= 0) {
            // Only return unqualified option names
            continue;
        }
        GCSDownloaderHelper downloader = createDownloader();
        for (Map.Entry<Object, Field> fieldEntry : optionFields) {
            final Object obj = fieldEntry.getKey();
            final Field field = fieldEntry.getValue();
            final Option option = field.getAnnotation(Option.class);
            if (option == null) {
                continue;
            }
            // At this point, we know this is an option field; make sure it's set
            field.setAccessible(true);
            final Object value;
            try {
                value = field.get(obj);
            } catch (IllegalAccessException e) {
                throw new ConfigurationException(String.format("internal error: %s", e.getMessage()));
            }
            if (value == null) {
                continue;
            } else if (value instanceof File) {
                File consideredFile = (File) value;
                // Don't use absolute path as it would not start with gs:
                if (consideredFile.getPath().startsWith("gs:/")) {
                    // File object remote double // so we have to rebuild it
                    String path = consideredFile.getPath().replaceAll("gs:/", "gs://");
                    CLog.d("Considering option '%s' with path: '%s' for download.", option.name(), path);
                    // We need to download the file from the bucket
                    try {
                        File gsFile = downloader.fetchTestResource(path);
                        gcsFiles.add(gsFile);
                        // Replace the field value
                        field.set(obj, gsFile);
                    } catch (BuildRetrievalError | IllegalAccessException e) {
                        CLog.e(e);
                        // Clean up all files
                        for (File f : gcsFiles) {
                            FileUtil.deleteFile(f);
                        }
                        throw new ConfigurationException(String.format("Failed to download %s", path), e);
                    }
                }
            }
        // TODO: Handle collection of files
        }
    }
    return gcsFiles;
}
#end_block

#method_before
public void setBusinessLogicHostFile(File hostFile) {
    setBusinessLogicHostFile(hostFile, "");
}
#method_after
public void setBusinessLogicHostFile(File hostFile) {
    setBusinessLogicHostFile(hostFile, null);
}
#end_block

#method_before
public void setBusinessLogicHostFile(File hostFile, String module_id) {
    mBuildInfo.addBuildAttribute(BUSINESS_LOGIC_HOST_FILE + module_id, hostFile.getAbsolutePath());
}
#method_after
public void setBusinessLogicHostFile(File hostFile, String moduleId) {
    String key = (moduleId == null) ? "" : moduleId;
    mBuildInfo.setFile(BUSINESS_LOGIC_HOST_FILE + key, hostFile, hostFile.getName());
}
#end_block

#method_before
public boolean hasBusinessLogicHostFile() {
    return hasBusinessLogicHostFile("");
}
#method_after
public boolean hasBusinessLogicHostFile() {
    return hasBusinessLogicHostFile(null);
}
#end_block

#method_before
public boolean hasBusinessLogicHostFile(String module_id) {
    return mBuildInfo.getBuildAttributes().get(BUSINESS_LOGIC_HOST_FILE + module_id) != null;
}
#method_after
public boolean hasBusinessLogicHostFile(String moduleId) {
    String key = (moduleId == null) ? "" : moduleId;
    return mBuildInfo.getFile(BUSINESS_LOGIC_HOST_FILE + key) != null;
}
#end_block

#method_before
public File getBusinessLogicHostFile() {
    return getBusinessLogicHostFile("");
}
#method_after
public File getBusinessLogicHostFile() {
    return getBusinessLogicHostFile(null);
}
#end_block

#method_before
public File getBusinessLogicHostFile(String module_id) {
    return (hasBusinessLogicHostFile(module_id)) ? new File(mBuildInfo.getBuildAttributes().get(BUSINESS_LOGIC_HOST_FILE + module_id)) : null;
}
#method_after
public File getBusinessLogicHostFile(String moduleId) {
    String key = (moduleId == null) ? "" : moduleId;
    return mBuildInfo.getFile(BUSINESS_LOGIC_HOST_FILE + key);
}
#end_block

#method_before
public void testSetBusinessLogicHostFile() throws Exception {
    File tmpBLFile = FileUtil.createTempFile("businesslogic-test-file", ".bl");
    FileUtil.writeToFile("test string", tmpBLFile);
    try {
        mHelper.setBusinessLogicHostFile(tmpBLFile);
        File currentBLFile = mHelper.getBusinessLogicHostFile();
        assertNotNull(currentBLFile);
        assertEquals(tmpBLFile, currentBLFile);
        // In case of sharding the underlying build info will be cloned, and old build cleaned.
        IBuildInfo clone = mBuild.clone();
        try {
            CompatibilityBuildHelper helperShard = new CompatibilityBuildHelper(clone);
            File newBLFile = helperShard.getBusinessLogicHostFile();
            assertNotNull(newBLFile);
            assertEquals(tmpBLFile, newBLFile);
            // content has also followed.
            assertEquals("test string", FileUtil.readStringFromFile(newBLFile));
        } finally {
            clone.cleanUp();
        }
    } finally {
        FileUtil.deleteFile(tmpBLFile);
    }
}
#method_after
public void testSetBusinessLogicHostFile() throws Exception {
    File tmpBLFile = FileUtil.createTempFile("businesslogic-test-file", ".bl");
    FileUtil.writeToFile("test string", tmpBLFile);
    try {
        mHelper.setBusinessLogicHostFile(tmpBLFile);
        File currentBLFile = mHelper.getBusinessLogicHostFile();
        assertNotNull(currentBLFile);
        assertEquals(tmpBLFile, currentBLFile);
        // In case of sharding the underlying build info will be cloned, and old build cleaned.
        IBuildInfo clone = mBuild.clone();
        try {
            CompatibilityBuildHelper helperShard = new CompatibilityBuildHelper(clone);
            File newBLFile = helperShard.getBusinessLogicHostFile();
            assertNotNull(newBLFile);
            // content has also followed.
            assertEquals("test string", FileUtil.readStringFromFile(newBLFile));
        } finally {
            clone.cleanUp();
        }
    } finally {
        FileUtil.deleteFile(tmpBLFile);
    }
}
#end_block

#method_before
public void testSetBusinessLogicHostFileWithModuleId() throws Exception {
    File tmpBLFile = FileUtil.createTempFile("businesslogic-test-file", ".bl");
    FileUtil.writeToFile("test string", tmpBLFile);
    try {
        String module_id = "64MODULE1";
        mHelper.setBusinessLogicHostFile(tmpBLFile, module_id);
        File currentBLFile = mHelper.getBusinessLogicHostFile(module_id);
        assertNotNull(currentBLFile);
        assertEquals(tmpBLFile, currentBLFile);
        // In case of sharding the underlying build info will be cloned, and old build cleaned.
        IBuildInfo clone = mBuild.clone();
        try {
            CompatibilityBuildHelper helperShard = new CompatibilityBuildHelper(clone);
            File newBLFile = helperShard.getBusinessLogicHostFile(module_id);
            assertNotNull(newBLFile);
            assertEquals(tmpBLFile, newBLFile);
            // content has also followed.
            assertEquals("test string", FileUtil.readStringFromFile(newBLFile));
        } finally {
            clone.cleanUp();
        }
    } finally {
        FileUtil.deleteFile(tmpBLFile);
    }
}
#method_after
public void testSetBusinessLogicHostFileWithModuleId() throws Exception {
    File tmpBLFile = FileUtil.createTempFile("businesslogic-test-file", ".bl");
    FileUtil.writeToFile("test string", tmpBLFile);
    try {
        String moduleId = "64MODULE1";
        mHelper.setBusinessLogicHostFile(tmpBLFile, moduleId);
        File currentBLFile = mHelper.getBusinessLogicHostFile(moduleId);
        assertNotNull(currentBLFile);
        assertEquals(tmpBLFile, currentBLFile);
        // In case of sharding the underlying build info will be cloned, and old build cleaned.
        IBuildInfo clone = mBuild.clone();
        try {
            CompatibilityBuildHelper helperShard = new CompatibilityBuildHelper(clone);
            File newBLFile = helperShard.getBusinessLogicHostFile(moduleId);
            assertNotNull(newBLFile);
            // content has also followed.
            assertEquals("test string", FileUtil.readStringFromFile(newBLFile));
        } finally {
            clone.cleanUp();
        }
    } finally {
        FileUtil.deleteFile(tmpBLFile);
    }
}
#end_block

#method_before
public void testHasBusinessLogicHostFile() throws Exception {
    File tmpBLFile = FileUtil.createTempFile("businesslogic-test-file", ".bl");
    try {
        mBuild.addBuildAttribute(BUSINESS_LOGIC_HOST_FILE, tmpBLFile.getAbsolutePath());
        assertTrue(mHelper.hasBusinessLogicHostFile());
        // In case of sharding the underlying build info will be cloned, and old build cleaned.
        IBuildInfo clone = mBuild.clone();
        try {
            CompatibilityBuildHelper helperShard = new CompatibilityBuildHelper(clone);
            assertTrue(helperShard.hasBusinessLogicHostFile());
        } finally {
            clone.cleanUp();
        }
    } finally {
        FileUtil.deleteFile(tmpBLFile);
    }
}
#method_after
public void testHasBusinessLogicHostFile() throws Exception {
    File tmpBLFile = FileUtil.createTempFile("businesslogic-test-file", ".bl");
    try {
        mBuild.setFile(BUSINESS_LOGIC_HOST_FILE, tmpBLFile, tmpBLFile.getName());
        assertTrue(mHelper.hasBusinessLogicHostFile());
        // In case of sharding the underlying build info will be cloned, and old build cleaned.
        IBuildInfo clone = mBuild.clone();
        try {
            CompatibilityBuildHelper helperShard = new CompatibilityBuildHelper(clone);
            assertTrue(helperShard.hasBusinessLogicHostFile());
        } finally {
            clone.cleanUp();
        }
    } finally {
        FileUtil.deleteFile(tmpBLFile);
    }
}
#end_block

#method_before
public void testHasBusinessLogicHostFileModuleId() throws Exception {
    File tmpBLFile = FileUtil.createTempFile("businesslogic-test-file", ".bl");
    try {
        String module_id = "64MODULE1";
        mBuild.addBuildAttribute(BUSINESS_LOGIC_HOST_FILE + module_id, tmpBLFile.getAbsolutePath());
        assertTrue(mHelper.hasBusinessLogicHostFile(module_id));
        // In case of sharding the underlying build info will be cloned, and old build cleaned.
        IBuildInfo clone = mBuild.clone();
        try {
            CompatibilityBuildHelper helperShard = new CompatibilityBuildHelper(clone);
            assertTrue(helperShard.hasBusinessLogicHostFile(module_id));
        } finally {
            clone.cleanUp();
        }
    } finally {
        FileUtil.deleteFile(tmpBLFile);
    }
}
#method_after
public void testHasBusinessLogicHostFileModuleId() throws Exception {
    File tmpBLFile = FileUtil.createTempFile("businesslogic-test-file", ".bl");
    try {
        String moduleId = "64MODULE1";
        mBuild.setFile(BUSINESS_LOGIC_HOST_FILE + moduleId, tmpBLFile, tmpBLFile.getName());
        assertTrue(mHelper.hasBusinessLogicHostFile(moduleId));
        // In case of sharding the underlying build info will be cloned, and old build cleaned.
        IBuildInfo clone = mBuild.clone();
        try {
            CompatibilityBuildHelper helperShard = new CompatibilityBuildHelper(clone);
            assertTrue(helperShard.hasBusinessLogicHostFile(moduleId));
        } finally {
            clone.cleanUp();
        }
    } finally {
        FileUtil.deleteFile(tmpBLFile);
    }
}
#end_block

#method_before
public void testGetBusinessLogicHostFile() throws Exception {
    File tmpBLFile = FileUtil.createTempFile("businesslogic-test-file", ".bl");
    FileUtil.writeToFile("test string", tmpBLFile);
    try {
        mBuild.addBuildAttribute(BUSINESS_LOGIC_HOST_FILE, tmpBLFile.getAbsolutePath());
        File currentBLFile = mHelper.getBusinessLogicHostFile();
        assertNotNull(currentBLFile);
        assertEquals(tmpBLFile, currentBLFile);
        // In case of sharding the underlying build info will be cloned, and old build cleaned.
        IBuildInfo clone = mBuild.clone();
        try {
            CompatibilityBuildHelper helperShard = new CompatibilityBuildHelper(clone);
            File newBLFile = helperShard.getBusinessLogicHostFile();
            assertNotNull(newBLFile);
            assertEquals(tmpBLFile, newBLFile);
            // content has also followed.
            assertEquals("test string", FileUtil.readStringFromFile(newBLFile));
        } finally {
            clone.cleanUp();
        }
    } finally {
        FileUtil.deleteFile(tmpBLFile);
    }
}
#method_after
public void testGetBusinessLogicHostFile() throws Exception {
    File tmpBLFile = FileUtil.createTempFile("businesslogic-test-file", ".bl");
    FileUtil.writeToFile("test string", tmpBLFile);
    try {
        mBuild.setFile(BUSINESS_LOGIC_HOST_FILE, tmpBLFile, tmpBLFile.getName());
        File currentBLFile = mHelper.getBusinessLogicHostFile();
        assertNotNull(currentBLFile);
        assertEquals(tmpBLFile, currentBLFile);
        // In case of sharding the underlying build info will be cloned, and old build cleaned.
        IBuildInfo clone = mBuild.clone();
        try {
            CompatibilityBuildHelper helperShard = new CompatibilityBuildHelper(clone);
            File newBLFile = helperShard.getBusinessLogicHostFile();
            assertNotNull(newBLFile);
            // content has also followed.
            assertEquals("test string", FileUtil.readStringFromFile(newBLFile));
        } finally {
            clone.cleanUp();
        }
    } finally {
        FileUtil.deleteFile(tmpBLFile);
    }
}
#end_block

#method_before
public void testGetBusinessLogicHostFileWithModuleId() throws Exception {
    File tmpBLFile = FileUtil.createTempFile("businesslogic-test-file", ".bl");
    FileUtil.writeToFile("test string", tmpBLFile);
    try {
        String module_id = "64MODULE1";
        mBuild.addBuildAttribute(BUSINESS_LOGIC_HOST_FILE + module_id, tmpBLFile.getAbsolutePath());
        File currentBLFile = mHelper.getBusinessLogicHostFile(module_id);
        assertNotNull(currentBLFile);
        assertEquals(tmpBLFile, currentBLFile);
        // In case of sharding the underlying build info will be cloned, and old build cleaned.
        IBuildInfo clone = mBuild.clone();
        try {
            CompatibilityBuildHelper helperShard = new CompatibilityBuildHelper(clone);
            File newBLFile = helperShard.getBusinessLogicHostFile(module_id);
            assertNotNull(newBLFile);
            assertEquals(tmpBLFile, newBLFile);
            // content has also followed.
            assertEquals("test string", FileUtil.readStringFromFile(newBLFile));
        } finally {
            clone.cleanUp();
        }
    } finally {
        FileUtil.deleteFile(tmpBLFile);
    }
}
#method_after
public void testGetBusinessLogicHostFileWithModuleId() throws Exception {
    File tmpBLFile = FileUtil.createTempFile("businesslogic-test-file", ".bl");
    FileUtil.writeToFile("test string", tmpBLFile);
    try {
        String moduleId = "64MODULE1";
        mBuild.setFile(BUSINESS_LOGIC_HOST_FILE + moduleId, tmpBLFile, tmpBLFile.getName());
        File currentBLFile = mHelper.getBusinessLogicHostFile(moduleId);
        assertNotNull(currentBLFile);
        assertEquals(tmpBLFile, currentBLFile);
        // In case of sharding the underlying build info will be cloned, and old build cleaned.
        IBuildInfo clone = mBuild.clone();
        try {
            CompatibilityBuildHelper helperShard = new CompatibilityBuildHelper(clone);
            File newBLFile = helperShard.getBusinessLogicHostFile(moduleId);
            assertNotNull(newBLFile);
            // content has also followed.
            assertEquals("test string", FileUtil.readStringFromFile(newBLFile));
        } finally {
            clone.cleanUp();
        }
    } finally {
        FileUtil.deleteFile(tmpBLFile);
    }
}
#end_block

#method_before
@Override
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    // Desired height should be the height constraint for all child views.
    int desiredHeight = getPaddingTop() + getSuggestedMinimumHeight() + getPaddingBottom();
    int childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(desiredHeight, MeasureSpec.AT_MOST);
    int width = 0;
    if (mNavButtonView.getVisibility() != GONE) {
        // Size of nav button is fixed.
        int measureSpec = MeasureSpec.makeMeasureSpec(mNavButtonIconSize, MeasureSpec.EXACTLY);
        mNavButtonView.measure(measureSpec, measureSpec);
        // Nav button width includes its container.
        int navWidth = Math.max(mNavButtonContainerWidth, mNavButtonView.getMeasuredWidth());
        width += navWidth + getHorizontalMargins(mNavButtonView);
    }
    int textLength = 0;
    if (mTitleTextView.getVisibility() != GONE) {
        measureChild(mTitleTextView, widthMeasureSpec, width, childHeightMeasureSpec, 0);
        textLength = mTitleTextView.getMeasuredWidth() + getHorizontalMargins(mTitleTextView);
    }
    if (mSubtitleTextView.getVisibility() != GONE) {
        measureChild(mSubtitleTextView, widthMeasureSpec, width, childHeightMeasureSpec, 0);
        textLength = Math.max(textLength, mSubtitleTextView.getMeasuredWidth() + getHorizontalMargins(mSubtitleTextView));
    }
    width += textLength;
    setMeasuredDimension(resolveSize(width, widthMeasureSpec), resolveSize(desiredHeight, heightMeasureSpec));
}
#method_after
@Override
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    // Desired height should be the height constraint for all child views.
    int desiredHeight = getPaddingTop() + getSuggestedMinimumHeight() + getPaddingBottom();
    int childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(desiredHeight, MeasureSpec.AT_MOST);
    int width = 0;
    if (mNavButtonView.getVisibility() != GONE) {
        // Size of nav button is fixed.
        int measureSpec = MeasureSpec.makeMeasureSpec(mNavButtonIconSize, MeasureSpec.EXACTLY);
        mNavButtonView.measure(measureSpec, measureSpec);
        // Nav button width includes its container.
        int navWidth = Math.max(mNavButtonContainerWidth, mNavButtonView.getMeasuredWidth());
        width += navWidth + getHorizontalMargins(mNavButtonView);
    }
    if (mTitleIconView.getVisibility() != GONE) {
        int measureSpec = MeasureSpec.makeMeasureSpec(mTitleIconSize, MeasureSpec.EXACTLY);
        mTitleIconView.measure(measureSpec, measureSpec);
        width += mTitleIconView.getMeasuredWidth();
    }
    int titleLength = 0;
    int subtitleLength = 0;
    if (mTitleTextView.getVisibility() != GONE) {
        measureChild(mTitleTextView, widthMeasureSpec, width, childHeightMeasureSpec, 0);
        titleLength = mTitleTextView.getMeasuredWidth() + getHorizontalMargins(mTitleTextView);
    }
    if (mSubtitleTextView.getVisibility() != GONE) {
        measureChild(mSubtitleTextView, widthMeasureSpec, width, childHeightMeasureSpec, 0);
        subtitleLength = mSubtitleTextView.getMeasuredWidth() + getHorizontalMargins(mSubtitleTextView);
    }
    width += Math.max(titleLength, subtitleLength);
    setMeasuredDimension(resolveSize(width, widthMeasureSpec), resolveSize(desiredHeight, heightMeasureSpec));
}
#end_block

#method_before
@Override
protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
    int height = bottom - top;
    int layoutLeft = getPaddingLeft();
    if (mNavButtonView.getVisibility() != GONE) {
        // Nav button is centered in container.
        int navButtonWidth = mNavButtonView.getMeasuredWidth();
        int containerWidth = Math.max(mNavButtonContainerWidth, navButtonWidth);
        int navButtonLeft = (containerWidth - navButtonWidth) / 2;
        layoutViewVerticallyCentered(mNavButtonView, navButtonLeft, height);
        layoutLeft += containerWidth;
    }
    if (mTitleTextView.getVisibility() != GONE) {
        if (mSubtitleTextView.getVisibility() != GONE) {
            layoutTextViewsVerticallyCentered(mTitleTextView, mSubtitleTextView, layoutLeft, height);
        } else {
            layoutViewVerticallyCentered(mTitleTextView, layoutLeft, height);
        }
    } else if (mSubtitleTextView.getVisibility() != GONE) {
        layoutViewVerticallyCentered(mSubtitleTextView, layoutLeft, height);
    }
}
#method_after
@Override
protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
    int height = bottom - top;
    int layoutLeft = getPaddingLeft();
    if (mNavButtonView.getVisibility() != GONE) {
        // Nav button is centered in container.
        int navButtonWidth = mNavButtonView.getMeasuredWidth();
        int containerWidth = Math.max(mNavButtonContainerWidth, navButtonWidth);
        int navButtonLeft = (containerWidth - navButtonWidth) / 2;
        layoutViewVerticallyCentered(mNavButtonView, navButtonLeft, height);
        layoutLeft += containerWidth;
    }
    if (mTitleIconView.getVisibility() != GONE) {
        layoutViewVerticallyCentered(mTitleIconView, layoutLeft, height);
        layoutLeft += mTitleIconView.getMeasuredWidth();
    }
    if (mTitleTextView.getVisibility() != GONE && mSubtitleTextView.getVisibility() != GONE) {
        layoutTextViewsVerticallyCentered(mTitleTextView, mSubtitleTextView, layoutLeft, height);
    } else if (mTitleTextView.getVisibility() != GONE) {
        layoutViewVerticallyCentered(mTitleTextView, layoutLeft, height);
    } else if (mSubtitleTextView.getVisibility() != GONE) {
        layoutViewVerticallyCentered(mSubtitleTextView, layoutLeft, height);
    }
}
#end_block

#method_before
public CharSequence getSubtitle() {
    return mSubtitleText;
}
#method_after
@Nullable
public CharSequence getSubtitle() {
    return mSubtitleText;
}
#end_block

#method_before
public void setSubtitle(CharSequence subtitle) {
    mSubtitleText = subtitle;
    mSubtitleTextView.setText(subtitle);
    mSubtitleTextView.setVisibility(TextUtils.isEmpty(subtitle) ? GONE : VISIBLE);
}
#method_after
public void setSubtitle(@Nullable CharSequence subtitle) {
    mSubtitleText = subtitle;
    mSubtitleTextView.setText(subtitle);
    mSubtitleTextView.setVisibility(TextUtils.isEmpty(subtitle) ? GONE : VISIBLE);
}
#end_block

#method_before
private void layoutTextViewsVerticallyCentered(View title, View subtitle, int left, int height) {
    int titleHeight = title.getMeasuredHeight();
    int titleWidth = title.getMeasuredWidth();
    int subtitleHeight = subtitle.getMeasuredHeight();
    int subtitleWidth = subtitle.getMeasuredWidth();
    int titleTop = (height - titleHeight - subtitleHeight - getResources().getDimensionPixelSize(R.dimen.car_padding_1)) / 2;
    title.layout(left, titleTop, left + titleWidth, titleTop + titleHeight);
    int subtitleTop = height / 2 + getResources().getDimensionPixelSize(R.dimen.car_padding_1) / 2;
    subtitle.layout(left, subtitleTop, left + subtitleWidth, subtitleTop + subtitleHeight);
}
#method_after
private void layoutTextViewsVerticallyCentered(View title, View subtitle, int left, int height) {
    int titleHeight = title.getMeasuredHeight();
    int titleWidth = title.getMeasuredWidth();
    int subtitleHeight = subtitle.getMeasuredHeight();
    int subtitleWidth = subtitle.getMeasuredWidth();
    int titleTop = (height - titleHeight - subtitleHeight - mTextVerticalPadding) / 2;
    title.layout(left, titleTop, left + titleWidth, titleTop + titleHeight);
    int subtitleTop = title.getBottom() + mTextVerticalPadding;
    subtitle.layout(left, subtitleTop, left + subtitleWidth, subtitleTop + subtitleHeight);
}
#end_block

#method_before
@Test
public void testSetNavigationIcon_doesNotThrowError() throws Throwable {
    // Since there is no easy way to compare drawable, here we are testing that calling the
    // relevant APIs doesn't crash.
    mActivityRule.runOnUiThread(() -> mToolbar.setNavigationIcon(android.R.drawable.sym_def_app_icon));
}
#method_after
@Test
public void testSetNavigationIcon_doesNotThrowError() throws Throwable {
    // Since there is no easy way to compare drawable, here we are testing that calling the
    // relevant APIs doesn't crash.
    mActivityRule.runOnUiThread(() -> mToolbar.setNavigationIcon(Icon.createWithResource(mActivity, android.R.drawable.sym_def_app_icon)));
}
#end_block

#method_before
@Test
public void testSetNavigationIconContainerWidth() throws Throwable {
    mActivityRule.runOnUiThread(() -> {
        mToolbar.setNavigationIcon(R.drawable.ic_nav_arrow_back);
        // Set title to verify icon space on right.
        mToolbar.setTitle("title");
    });
    int sideWidth = 10;
    // Container width is icon width plus |sideWidth| on both ends.
    int containerWidth = getNavigationIconView().getWidth() + (sideWidth * 2);
    mActivityRule.runOnUiThread(() -> mToolbar.setNavigationIconContainerWidth(containerWidth));
    onView(withId(R.id.nav_button)).check(matches(withLeft(sideWidth)));
    onView(withId(R.id.title)).check(matches(withLeft(containerWidth)));
}
#method_after
@Test
public void testSetNavigationIconContainerWidth() throws Throwable {
    mActivityRule.runOnUiThread(() -> {
        mToolbar.setNavigationIcon(Icon.createWithResource(mActivity, R.drawable.ic_nav_arrow_back));
        // Set title to verify icon space on right.
        mToolbar.setTitle("title");
    });
    int sideWidth = 10;
    // Container width is icon width plus |sideWidth| on both ends.
    int containerWidth = getNavigationIconView().getWidth() + (sideWidth * 2);
    mActivityRule.runOnUiThread(() -> mToolbar.setNavigationIconContainerWidth(containerWidth));
    onView(withId(R.id.nav_button)).check(matches(withLeft(sideWidth)));
    onView(withId(R.id.title)).check(matches(withLeft(containerWidth)));
}
#end_block

#method_before
@Test
public void testSetNavigationIconContainerWidth_NoContainerKeepsIconCompletelyVisible() throws Throwable {
    mActivityRule.runOnUiThread(() -> {
        mToolbar.setNavigationIcon(R.drawable.ic_nav_arrow_back);
        // Set title to verify icon space on right.
        mToolbar.setTitle("title");
    });
    int containerWidth = 0;
    mActivityRule.runOnUiThread(() -> mToolbar.setNavigationIconContainerWidth(containerWidth));
    onView(withId(R.id.nav_button)).check(matches(withLeft(0)));
    onView(withId(R.id.title)).check(isCompletelyRightOf(withId(R.id.nav_button)));
}
#method_after
@Test
public void testSetNavigationIconContainerWidth_NoContainerKeepsIconCompletelyVisible() throws Throwable {
    mActivityRule.runOnUiThread(() -> {
        mToolbar.setNavigationIcon(Icon.createWithResource(mActivity, (R.drawable.ic_nav_arrow_back)));
        // Set title to verify icon space on right.
        mToolbar.setTitle("title");
    });
    int containerWidth = 0;
    mActivityRule.runOnUiThread(() -> mToolbar.setNavigationIconContainerWidth(containerWidth));
    onView(withId(R.id.nav_button)).check(matches(withLeft(0)));
    onView(withId(R.id.title)).check(isCompletelyRightOf(withId(R.id.nav_button)));
}
#end_block

#method_before
@Test
public void testSubtitleShowsWhenContentNotEmpty() throws Throwable {
    mActivityRule.runOnUiThread(() -> mToolbar.setSubtitle("sub title"));
    onView(withId(R.id.sub_title)).check(matches(isDisplayed()));
}
#method_after
@Test
public void testSubtitleShowsWhenContentNotEmpty() throws Throwable {
    mActivityRule.runOnUiThread(() -> mToolbar.setSubtitle("this is subtitle"));
    onView(withId(R.id.subtitle)).check(matches(isDisplayed()));
}
#end_block

#method_before
@GuardedBy("mLock")
private void onVolumeCreatedLocked(VolumeInfo vol) {
    if (mPms.isOnlyCoreApps()) {
        Slog.d(TAG, "System booted in core-only mode; ignoring volume " + vol.getId());
        return;
    }
    if (vol.type == VolumeInfo.TYPE_EMULATED) {
        final StorageManager storage = mContext.getSystemService(StorageManager.class);
        final VolumeInfo privateVol = storage.findPrivateForEmulated(vol);
        if (Objects.equals(StorageManager.UUID_PRIVATE_INTERNAL, mPrimaryStorageUuid) && VolumeInfo.ID_PRIVATE_INTERNAL.equals(privateVol.id)) {
            Slog.v(TAG, "Found primary storage at " + vol);
            vol.mountFlags |= VolumeInfo.MOUNT_FLAG_PRIMARY;
            vol.mountFlags |= VolumeInfo.MOUNT_FLAG_VISIBLE;
            mHandler.obtainMessage(H_VOLUME_MOUNT, vol).sendToTarget();
        } else if (Objects.equals(privateVol.fsUuid, mPrimaryStorageUuid)) {
            Slog.v(TAG, "Found primary storage at " + vol);
            vol.mountFlags |= VolumeInfo.MOUNT_FLAG_PRIMARY;
            vol.mountFlags |= VolumeInfo.MOUNT_FLAG_VISIBLE;
            mHandler.obtainMessage(H_VOLUME_MOUNT, vol).sendToTarget();
        }
    } else if (vol.type == VolumeInfo.TYPE_PUBLIC) {
        // TODO: only look at first public partition
        if (Objects.equals(StorageManager.UUID_PRIMARY_PHYSICAL, mPrimaryStorageUuid) && vol.disk.isDefaultPrimary()) {
            Slog.v(TAG, "Found primary storage at " + vol);
            vol.mountFlags |= VolumeInfo.MOUNT_FLAG_PRIMARY;
            vol.mountFlags |= VolumeInfo.MOUNT_FLAG_VISIBLE;
        }
        // public API requirement of being in a stable location.
        if (vol.disk.isAdoptable()) {
            vol.mountFlags |= VolumeInfo.MOUNT_FLAG_VISIBLE;
        }
        vol.mountUserId = mCurrentUserId;
        mHandler.obtainMessage(H_VOLUME_MOUNT, vol).sendToTarget();
    } else if (vol.type == VolumeInfo.TYPE_PRIVATE) {
        mHandler.obtainMessage(H_VOLUME_MOUNT, vol).sendToTarget();
    } else {
        Slog.d(TAG, "Skipping automatic mounting of " + vol);
    }
}
#method_after
@GuardedBy("mLock")
private void onVolumeCreatedLocked(VolumeInfo vol) {
    if (mPms.isOnlyCoreApps()) {
        Slog.d(TAG, "System booted in core-only mode; ignoring volume " + vol.getId());
        return;
    }
    if (vol.type == VolumeInfo.TYPE_EMULATED) {
        final StorageManager storage = mContext.getSystemService(StorageManager.class);
        final VolumeInfo privateVol = storage.findPrivateForEmulated(vol);
        if (Objects.equals(StorageManager.UUID_PRIVATE_INTERNAL, mPrimaryStorageUuid) && VolumeInfo.ID_PRIVATE_INTERNAL.equals(privateVol.id)) {
            Slog.v(TAG, "Found primary storage at " + vol);
            vol.mountFlags |= VolumeInfo.MOUNT_FLAG_PRIMARY;
            vol.mountFlags |= VolumeInfo.MOUNT_FLAG_VISIBLE;
            mHandler.obtainMessage(H_VOLUME_MOUNT, vol).sendToTarget();
        } else if (Objects.equals(privateVol.fsUuid, mPrimaryStorageUuid)) {
            Slog.v(TAG, "Found primary storage at " + vol);
            vol.mountFlags |= VolumeInfo.MOUNT_FLAG_PRIMARY;
            vol.mountFlags |= VolumeInfo.MOUNT_FLAG_VISIBLE;
            mHandler.obtainMessage(H_VOLUME_MOUNT, vol).sendToTarget();
        }
    } else if (vol.type == VolumeInfo.TYPE_PUBLIC) {
        // TODO: only look at first public partition
        if (Objects.equals(StorageManager.UUID_PRIMARY_PHYSICAL, mPrimaryStorageUuid) && vol.disk.isDefaultPrimary()) {
            Slog.v(TAG, "Found primary storage at " + vol);
            vol.mountFlags |= VolumeInfo.MOUNT_FLAG_PRIMARY;
            vol.mountFlags |= VolumeInfo.MOUNT_FLAG_VISIBLE;
        }
        // public API requirement of being in a stable location.
        if (vol.disk.isAdoptable()) {
            vol.mountFlags |= VolumeInfo.MOUNT_FLAG_VISIBLE;
        }
        vol.mountUserId = mCurrentUserId;
        mHandler.obtainMessage(H_VOLUME_MOUNT, vol).sendToTarget();
    } else if (vol.type == VolumeInfo.TYPE_PRIVATE) {
        mHandler.obtainMessage(H_VOLUME_MOUNT, vol).sendToTarget();
    } else if (vol.type == VolumeInfo.TYPE_STUB) {
        vol.mountUserId = mCurrentUserId;
        mHandler.obtainMessage(H_VOLUME_MOUNT, vol).sendToTarget();
    } else {
        Slog.d(TAG, "Skipping automatic mounting of " + vol);
    }
}
#end_block

#method_before
private boolean isBroadcastWorthy(VolumeInfo vol) {
    switch(vol.getType()) {
        case VolumeInfo.TYPE_PRIVATE:
        case VolumeInfo.TYPE_PUBLIC:
        case VolumeInfo.TYPE_EMULATED:
            break;
        default:
            return false;
    }
    switch(vol.getState()) {
        case VolumeInfo.STATE_MOUNTED:
        case VolumeInfo.STATE_MOUNTED_READ_ONLY:
        case VolumeInfo.STATE_EJECTING:
        case VolumeInfo.STATE_UNMOUNTED:
        case VolumeInfo.STATE_UNMOUNTABLE:
        case VolumeInfo.STATE_BAD_REMOVAL:
            break;
        default:
            return false;
    }
    return true;
}
#method_after
private boolean isBroadcastWorthy(VolumeInfo vol) {
    switch(vol.getType()) {
        case VolumeInfo.TYPE_PRIVATE:
        case VolumeInfo.TYPE_PUBLIC:
        case VolumeInfo.TYPE_EMULATED:
        case VolumeInfo.TYPE_STUB:
            break;
        default:
            return false;
    }
    switch(vol.getState()) {
        case VolumeInfo.STATE_MOUNTED:
        case VolumeInfo.STATE_MOUNTED_READ_ONLY:
        case VolumeInfo.STATE_EJECTING:
        case VolumeInfo.STATE_UNMOUNTED:
        case VolumeInfo.STATE_UNMOUNTABLE:
        case VolumeInfo.STATE_BAD_REMOVAL:
            break;
        default:
            return false;
    }
    return true;
}
#end_block

#method_before
@GuardedBy("mLock")
private void onVolumeStateChangedLocked(VolumeInfo vol, int oldState, int newState) {
    // metadata, or so we can annoy them when a private volume is ejected
    if (vol.isMountedReadable() && !TextUtils.isEmpty(vol.fsUuid)) {
        VolumeRecord rec = mRecords.get(vol.fsUuid);
        if (rec == null) {
            rec = new VolumeRecord(vol.type, vol.fsUuid);
            rec.partGuid = vol.partGuid;
            rec.createdMillis = System.currentTimeMillis();
            if (vol.type == VolumeInfo.TYPE_PRIVATE) {
                rec.nickname = vol.disk.getDescription();
            }
            mRecords.put(rec.fsUuid, rec);
            writeSettingsLocked();
        } else {
            // Handle upgrade case where we didn't store partition GUID
            if (TextUtils.isEmpty(rec.partGuid)) {
                rec.partGuid = vol.partGuid;
                writeSettingsLocked();
            }
        }
    }
    mCallbacks.notifyVolumeStateChanged(vol, oldState, newState);
    // processes that receive the intent unnecessarily.
    if (mBootCompleted && isBroadcastWorthy(vol)) {
        final Intent intent = new Intent(VolumeInfo.ACTION_VOLUME_STATE_CHANGED);
        intent.putExtra(VolumeInfo.EXTRA_VOLUME_ID, vol.id);
        intent.putExtra(VolumeInfo.EXTRA_VOLUME_STATE, newState);
        intent.putExtra(VolumeRecord.EXTRA_FS_UUID, vol.fsUuid);
        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT | Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND);
        mHandler.obtainMessage(H_INTERNAL_BROADCAST, intent).sendToTarget();
    }
    final String oldStateEnv = VolumeInfo.getEnvironmentForState(oldState);
    final String newStateEnv = VolumeInfo.getEnvironmentForState(newState);
    if (!Objects.equals(oldStateEnv, newStateEnv)) {
        // user-specific broadcasts.
        for (int userId : mSystemUnlockedUsers) {
            if (vol.isVisibleForRead(userId)) {
                final StorageVolume userVol = vol.buildStorageVolume(mContext, userId, false);
                mHandler.obtainMessage(H_VOLUME_BROADCAST, userVol).sendToTarget();
                mCallbacks.notifyStorageStateChanged(userVol.getPath(), oldStateEnv, newStateEnv);
            }
        }
    }
    if (vol.type == VolumeInfo.TYPE_PUBLIC && vol.state == VolumeInfo.STATE_EJECTING) {
        // TODO: this should eventually be handled by new ObbVolume state changes
        /*
             * Some OBBs might have been unmounted when this volume was
             * unmounted, so send a message to the handler to let it know to
             * remove those from the list of mounted OBBS.
             */
        mObbActionHandler.sendMessage(mObbActionHandler.obtainMessage(OBB_FLUSH_MOUNT_STATE, vol.path));
    }
    maybeLogMediaMount(vol, newState);
}
#method_after
@GuardedBy("mLock")
private void onVolumeStateChangedLocked(VolumeInfo vol, int oldState, int newState) {
    // metadata, or so we can annoy them when a private volume is ejected
    if (vol.isMountedReadable() && !TextUtils.isEmpty(vol.fsUuid)) {
        VolumeRecord rec = mRecords.get(vol.fsUuid);
        if (rec == null) {
            rec = new VolumeRecord(vol.type, vol.fsUuid);
            rec.partGuid = vol.partGuid;
            rec.createdMillis = System.currentTimeMillis();
            if (vol.type == VolumeInfo.TYPE_PRIVATE) {
                rec.nickname = vol.disk.getDescription();
            }
            mRecords.put(rec.fsUuid, rec);
            writeSettingsLocked();
        } else {
            // Handle upgrade case where we didn't store partition GUID
            if (TextUtils.isEmpty(rec.partGuid)) {
                rec.partGuid = vol.partGuid;
                writeSettingsLocked();
            }
        }
    }
    mCallbacks.notifyVolumeStateChanged(vol, oldState, newState);
    // processes that receive the intent unnecessarily.
    if (mBootCompleted && isBroadcastWorthy(vol)) {
        final Intent intent = new Intent(VolumeInfo.ACTION_VOLUME_STATE_CHANGED);
        intent.putExtra(VolumeInfo.EXTRA_VOLUME_ID, vol.id);
        intent.putExtra(VolumeInfo.EXTRA_VOLUME_STATE, newState);
        intent.putExtra(VolumeRecord.EXTRA_FS_UUID, vol.fsUuid);
        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT | Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND);
        mHandler.obtainMessage(H_INTERNAL_BROADCAST, intent).sendToTarget();
    }
    final String oldStateEnv = VolumeInfo.getEnvironmentForState(oldState);
    final String newStateEnv = VolumeInfo.getEnvironmentForState(newState);
    if (!Objects.equals(oldStateEnv, newStateEnv)) {
        // user-specific broadcasts.
        for (int userId : mSystemUnlockedUsers) {
            if (vol.isVisibleForRead(userId)) {
                final StorageVolume userVol = vol.buildStorageVolume(mContext, userId, false);
                mHandler.obtainMessage(H_VOLUME_BROADCAST, userVol).sendToTarget();
                mCallbacks.notifyStorageStateChanged(userVol.getPath(), oldStateEnv, newStateEnv);
            }
        }
    }
    if ((vol.type == VolumeInfo.TYPE_PUBLIC || vol.type == VolumeInfo.TYPE_STUB) && vol.state == VolumeInfo.STATE_EJECTING) {
        // TODO: this should eventually be handled by new ObbVolume state changes
        /*
             * Some OBBs might have been unmounted when this volume was
             * unmounted, so send a message to the handler to let it know to
             * remove those from the list of mounted OBBS.
             */
        mObbActionHandler.sendMessage(mObbActionHandler.obtainMessage(OBB_FLUSH_MOUNT_STATE, vol.path));
    }
    maybeLogMediaMount(vol, newState);
}
#end_block

#method_before
private boolean isMountDisallowed(VolumeInfo vol) {
    UserManager userManager = mContext.getSystemService(UserManager.class);
    boolean isUsbRestricted = false;
    if (vol.disk != null && vol.disk.isUsb()) {
        isUsbRestricted = userManager.hasUserRestriction(UserManager.DISALLOW_USB_FILE_TRANSFER, Binder.getCallingUserHandle());
    }
    boolean isTypeRestricted = false;
    if (vol.type == VolumeInfo.TYPE_PUBLIC || vol.type == VolumeInfo.TYPE_PRIVATE) {
        isTypeRestricted = userManager.hasUserRestriction(UserManager.DISALLOW_MOUNT_PHYSICAL_MEDIA, Binder.getCallingUserHandle());
    }
    return isUsbRestricted || isTypeRestricted;
}
#method_after
private boolean isMountDisallowed(VolumeInfo vol) {
    UserManager userManager = mContext.getSystemService(UserManager.class);
    boolean isUsbRestricted = false;
    if (vol.disk != null && vol.disk.isUsb()) {
        isUsbRestricted = userManager.hasUserRestriction(UserManager.DISALLOW_USB_FILE_TRANSFER, Binder.getCallingUserHandle());
    }
    boolean isTypeRestricted = false;
    if (vol.type == VolumeInfo.TYPE_PUBLIC || vol.type == VolumeInfo.TYPE_PRIVATE || vol.type == VolumeInfo.TYPE_STUB) {
        isTypeRestricted = userManager.hasUserRestriction(UserManager.DISALLOW_MOUNT_PHYSICAL_MEDIA, Binder.getCallingUserHandle());
    }
    return isUsbRestricted || isTypeRestricted;
}
#end_block

#method_before
@Override
public StorageVolume[] getVolumeList(int uid, String packageName, int flags) {
    final int userId = UserHandle.getUserId(uid);
    final boolean forWrite = (flags & StorageManager.FLAG_FOR_WRITE) != 0;
    final boolean realState = (flags & StorageManager.FLAG_REAL_STATE) != 0;
    final boolean includeInvisible = (flags & StorageManager.FLAG_INCLUDE_INVISIBLE) != 0;
    final boolean userKeyUnlocked;
    final boolean storagePermission;
    final long token = Binder.clearCallingIdentity();
    try {
        userKeyUnlocked = isUserKeyUnlocked(userId);
        storagePermission = mStorageManagerInternal.hasExternalStorage(uid, packageName);
    } finally {
        Binder.restoreCallingIdentity(token);
    }
    boolean foundPrimary = false;
    final ArrayList<StorageVolume> res = new ArrayList<>();
    synchronized (mLock) {
        for (int i = 0; i < mVolumes.size(); i++) {
            final VolumeInfo vol = mVolumes.valueAt(i);
            switch(vol.getType()) {
                case VolumeInfo.TYPE_PUBLIC:
                case VolumeInfo.TYPE_EMULATED:
                    break;
                default:
                    continue;
            }
            boolean match = false;
            if (forWrite) {
                match = vol.isVisibleForWrite(userId);
            } else {
                match = vol.isVisibleForRead(userId) || (includeInvisible && vol.getPath() != null);
            }
            if (!match)
                continue;
            boolean reportUnmounted = false;
            if ((vol.getType() == VolumeInfo.TYPE_EMULATED) && !userKeyUnlocked) {
                reportUnmounted = true;
            } else if (!storagePermission && !realState) {
                reportUnmounted = true;
            }
            final StorageVolume userVol = vol.buildStorageVolume(mContext, userId, reportUnmounted);
            if (vol.isPrimary()) {
                res.add(0, userVol);
                foundPrimary = true;
            } else {
                res.add(userVol);
            }
        }
    }
    if (!foundPrimary) {
        Log.w(TAG, "No primary storage defined yet; hacking together a stub");
        final boolean primaryPhysical = SystemProperties.getBoolean(StorageManager.PROP_PRIMARY_PHYSICAL, false);
        final String id = "stub_primary";
        final File path = Environment.getLegacyExternalStorageDirectory();
        final String description = mContext.getString(android.R.string.unknownName);
        final boolean primary = true;
        final boolean removable = primaryPhysical;
        final boolean emulated = !primaryPhysical;
        final boolean allowMassStorage = false;
        final long maxFileSize = 0L;
        final UserHandle owner = new UserHandle(userId);
        final String uuid = null;
        final String state = Environment.MEDIA_REMOVED;
        res.add(0, new StorageVolume(id, path, path, description, primary, removable, emulated, allowMassStorage, maxFileSize, owner, uuid, state));
    }
    return res.toArray(new StorageVolume[res.size()]);
}
#method_after
@Override
public StorageVolume[] getVolumeList(int uid, String packageName, int flags) {
    final int userId = UserHandle.getUserId(uid);
    final boolean forWrite = (flags & StorageManager.FLAG_FOR_WRITE) != 0;
    final boolean realState = (flags & StorageManager.FLAG_REAL_STATE) != 0;
    final boolean includeInvisible = (flags & StorageManager.FLAG_INCLUDE_INVISIBLE) != 0;
    final boolean userKeyUnlocked;
    final boolean storagePermission;
    final long token = Binder.clearCallingIdentity();
    try {
        userKeyUnlocked = isUserKeyUnlocked(userId);
        storagePermission = mStorageManagerInternal.hasExternalStorage(uid, packageName);
    } finally {
        Binder.restoreCallingIdentity(token);
    }
    boolean foundPrimary = false;
    final ArrayList<StorageVolume> res = new ArrayList<>();
    synchronized (mLock) {
        for (int i = 0; i < mVolumes.size(); i++) {
            final VolumeInfo vol = mVolumes.valueAt(i);
            switch(vol.getType()) {
                case VolumeInfo.TYPE_PUBLIC:
                case VolumeInfo.TYPE_STUB:
                case VolumeInfo.TYPE_EMULATED:
                    break;
                default:
                    continue;
            }
            boolean match = false;
            if (forWrite) {
                match = vol.isVisibleForWrite(userId);
            } else {
                match = vol.isVisibleForRead(userId) || (includeInvisible && vol.getPath() != null);
            }
            if (!match)
                continue;
            boolean reportUnmounted = false;
            if ((vol.getType() == VolumeInfo.TYPE_EMULATED) && !userKeyUnlocked) {
                reportUnmounted = true;
            } else if (!storagePermission && !realState) {
                reportUnmounted = true;
            }
            final StorageVolume userVol = vol.buildStorageVolume(mContext, userId, reportUnmounted);
            if (vol.isPrimary()) {
                res.add(0, userVol);
                foundPrimary = true;
            } else {
                res.add(userVol);
            }
        }
    }
    if (!foundPrimary) {
        Log.w(TAG, "No primary storage defined yet; hacking together a stub");
        final boolean primaryPhysical = SystemProperties.getBoolean(StorageManager.PROP_PRIMARY_PHYSICAL, false);
        final String id = "stub_primary";
        final File path = Environment.getLegacyExternalStorageDirectory();
        final String description = mContext.getString(android.R.string.unknownName);
        final boolean primary = true;
        final boolean removable = primaryPhysical;
        final boolean emulated = !primaryPhysical;
        final boolean allowMassStorage = false;
        final long maxFileSize = 0L;
        final UserHandle owner = new UserHandle(userId);
        final String uuid = null;
        final String state = Environment.MEDIA_REMOVED;
        res.add(0, new StorageVolume(id, path, path, description, primary, removable, emulated, allowMassStorage, maxFileSize, owner, uuid, state));
    }
    return res.toArray(new StorageVolume[res.size()]);
}
#end_block

#method_before
@NonNull
public UUID getUuidForPath(@NonNull File path) throws IOException {
    Preconditions.checkNotNull(path);
    final String pathString = path.getCanonicalPath();
    if (FileUtils.contains(Environment.getDataDirectory().getAbsolutePath(), pathString)) {
        return UUID_DEFAULT;
    }
    try {
        for (VolumeInfo vol : mStorageManager.getVolumes(0)) {
            if (vol.path != null && FileUtils.contains(vol.path, pathString) && vol.type != VolumeInfo.TYPE_PUBLIC) {
                // underlying volume
                try {
                    return convert(vol.fsUuid);
                } catch (IllegalArgumentException e) {
                    continue;
                }
            }
        }
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
    throw new FileNotFoundException("Failed to find a storage device for " + path);
}
#method_after
@NonNull
public UUID getUuidForPath(@NonNull File path) throws IOException {
    Preconditions.checkNotNull(path);
    final String pathString = path.getCanonicalPath();
    if (FileUtils.contains(Environment.getDataDirectory().getAbsolutePath(), pathString)) {
        return UUID_DEFAULT;
    }
    try {
        for (VolumeInfo vol : mStorageManager.getVolumes(0)) {
            if (vol.path != null && FileUtils.contains(vol.path, pathString) && vol.type != VolumeInfo.TYPE_PUBLIC && vol.type != VolumeInfo.TYPE_STUB) {
                // underlying volume
                try {
                    return convert(vol.fsUuid);
                } catch (IllegalArgumentException e) {
                    continue;
                }
            }
        }
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
    throw new FileNotFoundException("Failed to find a storage device for " + path);
}
#end_block

#method_before
public void systemReady(final Runnable goingCallback, TimingsTraceLog traceLog) {
    traceLog.traceBegin("PhaseActivityManagerReady");
    synchronized (this) {
        if (mSystemReady) {
            // by the SystemServer
            if (goingCallback != null) {
                goingCallback.run();
            }
            return;
        }
        mHasHeavyWeightFeature = mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_CANT_SAVE_STATE);
        mLocalDeviceIdleController = LocalServices.getService(DeviceIdleController.LocalService.class);
        mAssistUtils = new AssistUtils(mContext);
        mVrController.onSystemReady();
        // Make sure we have the current profile info, since it is needed for security checks.
        mUserController.onSystemReady();
        mRecentTasks.onSystemReadyLocked();
        mAppOpsService.systemReady();
        mSystemReady = true;
    }
    try {
        sTheRealBuildSerial = IDeviceIdentifiersPolicyService.Stub.asInterface(ServiceManager.getService(Context.DEVICE_IDENTIFIERS_SERVICE)).getSerial();
    } catch (RemoteException e) {
    }
    ArrayList<ProcessRecord> procsToKill = null;
    synchronized (mPidsSelfLocked) {
        for (int i = mPidsSelfLocked.size() - 1; i >= 0; i--) {
            ProcessRecord proc = mPidsSelfLocked.valueAt(i);
            if (!isAllowedWhileBooting(proc.info)) {
                if (procsToKill == null) {
                    procsToKill = new ArrayList<ProcessRecord>();
                }
                procsToKill.add(proc);
            }
        }
    }
    synchronized (this) {
        if (procsToKill != null) {
            for (int i = procsToKill.size() - 1; i >= 0; i--) {
                ProcessRecord proc = procsToKill.get(i);
                Slog.i(TAG, "Removing system update proc: " + proc);
                removeProcessLocked(proc, true, false, "system update done");
            }
        }
        // Now that we have cleaned up any update processes, we
        // are ready to start launching real processes and know that
        // we won't trample on them any more.
        mProcessesReady = true;
    }
    Slog.i(TAG, "System now ready");
    EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_AMS_READY, SystemClock.uptimeMillis());
    synchronized (this) {
        if (mFactoryTest == FactoryTest.FACTORY_TEST_LOW_LEVEL) {
            ResolveInfo ri = mContext.getPackageManager().resolveActivity(new Intent(Intent.ACTION_FACTORY_TEST), STOCK_PM_FLAGS);
            CharSequence errorMsg = null;
            if (ri != null) {
                ActivityInfo ai = ri.activityInfo;
                ApplicationInfo app = ai.applicationInfo;
                if ((app.flags & ApplicationInfo.FLAG_SYSTEM) != 0) {
                    mTopAction = Intent.ACTION_FACTORY_TEST;
                    mTopData = null;
                    mTopComponent = new ComponentName(app.packageName, ai.name);
                } else {
                    errorMsg = mContext.getResources().getText(com.android.internal.R.string.factorytest_not_system);
                }
            } else {
                errorMsg = mContext.getResources().getText(com.android.internal.R.string.factorytest_no_action);
            }
            if (errorMsg != null) {
                mTopAction = null;
                mTopData = null;
                mTopComponent = null;
                Message msg = Message.obtain();
                msg.what = SHOW_FACTORY_ERROR_UI_MSG;
                msg.getData().putCharSequence("msg", errorMsg);
                mUiHandler.sendMessage(msg);
            }
        }
    }
    retrieveSettings();
    final int currentUserId = mUserController.getCurrentUserId();
    synchronized (this) {
        readGrantedUriPermissionsLocked();
    }
    final PowerManagerInternal pmi = LocalServices.getService(PowerManagerInternal.class);
    if (pmi != null) {
        pmi.registerLowPowerModeObserver(ServiceType.FORCE_BACKGROUND_CHECK, state -> updateForceBackgroundCheck(state.batterySaverEnabled));
        updateForceBackgroundCheck(pmi.getLowPowerState(ServiceType.FORCE_BACKGROUND_CHECK).batterySaverEnabled);
    } else {
        Slog.wtf(TAG, "PowerManagerInternal not found.");
    }
    if (goingCallback != null)
        goingCallback.run();
    traceLog.traceBegin("ActivityManagerStartApps");
    mBatteryStatsService.noteEvent(BatteryStats.HistoryItem.EVENT_USER_RUNNING_START, Integer.toString(currentUserId), currentUserId);
    mBatteryStatsService.noteEvent(BatteryStats.HistoryItem.EVENT_USER_FOREGROUND_START, Integer.toString(currentUserId), currentUserId);
    mSystemServiceManager.startUser(currentUserId);
    synchronized (this) {
        // Only start up encryption-aware persistent apps; once user is
        // unlocked we'll come back around and start unaware apps
        startPersistentApps(PackageManager.MATCH_DIRECT_BOOT_AWARE);
        // Start up initial activity.
        mBooting = true;
        // to handle home activity in this case.
        if (UserManager.isSplitSystemUser() && Settings.Secure.getInt(mContext.getContentResolver(), Settings.Secure.USER_SETUP_COMPLETE, 0) != 0) {
            ComponentName cName = new ComponentName(mContext, SystemUserHomeActivity.class);
            try {
                AppGlobals.getPackageManager().setComponentEnabledSetting(cName, PackageManager.COMPONENT_ENABLED_STATE_ENABLED, 0, UserHandle.USER_SYSTEM);
            } catch (RemoteException e) {
                throw e.rethrowAsRuntimeException();
            }
        }
        startHomeActivityLocked(currentUserId, "systemReady");
        try {
            if (AppGlobals.getPackageManager().hasSystemUidErrors()) {
                Slog.e(TAG, "UIDs on the system are inconsistent, you need to wipe your" + " data partition or your device will be unstable.");
                mUiHandler.obtainMessage(SHOW_UID_ERROR_UI_MSG).sendToTarget();
            }
        } catch (RemoteException e) {
        }
        if (!Build.isBuildConsistent()) {
            Slog.e(TAG, "Build fingerprint is not consistent, warning user");
            mUiHandler.obtainMessage(SHOW_FINGERPRINT_ERROR_UI_MSG).sendToTarget();
        }
        long ident = Binder.clearCallingIdentity();
        try {
            Intent intent = new Intent(Intent.ACTION_USER_STARTED);
            intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY | Intent.FLAG_RECEIVER_FOREGROUND);
            intent.putExtra(Intent.EXTRA_USER_HANDLE, currentUserId);
            broadcastIntentLocked(null, null, intent, null, null, 0, null, null, null, OP_NONE, null, false, false, MY_PID, SYSTEM_UID, currentUserId);
            intent = new Intent(Intent.ACTION_USER_STARTING);
            intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
            intent.putExtra(Intent.EXTRA_USER_HANDLE, currentUserId);
            broadcastIntentLocked(null, null, intent, null, new IIntentReceiver.Stub() {

                @Override
                public void performReceive(Intent intent, int resultCode, String data, Bundle extras, boolean ordered, boolean sticky, int sendingUser) throws RemoteException {
                }
            }, 0, null, null, new String[] { INTERACT_ACROSS_USERS }, OP_NONE, null, true, false, MY_PID, SYSTEM_UID, UserHandle.USER_ALL);
        } catch (Throwable t) {
            Slog.wtf(TAG, "Failed sending first user broadcasts", t);
        } finally {
            Binder.restoreCallingIdentity(ident);
        }
        mStackSupervisor.resumeFocusedStackTopActivityLocked();
        mUserController.sendUserSwitchBroadcasts(-1, currentUserId);
        BinderInternal.nSetBinderProxyCountWatermarks(6000, 5500);
        BinderInternal.nSetBinderProxyCountEnabled(true);
        BinderInternal.setBinderProxyCountCallback(new BinderInternal.BinderProxyLimitListener() {

            @Override
            public void onLimitReached(int uid) {
                Slog.wtf(TAG, "Uid " + uid + " sent too many Binders to uid " + Process.myUid());
                if (uid == Process.SYSTEM_UID) {
                    Slog.i(TAG, "Skipping kill (uid is SYSTEM)");
                } else {
                    killUid(UserHandle.getAppId(uid), UserHandle.getUserId(uid), "Too many Binders sent to SYSTEM");
                }
            }
        }, mHandler);
        // ActivityManagerStartApps
        traceLog.traceEnd();
        // PhaseActivityManagerReady
        traceLog.traceEnd();
    }
}
#method_after
public void systemReady(final Runnable goingCallback, TimingsTraceLog traceLog) {
    traceLog.traceBegin("PhaseActivityManagerReady");
    synchronized (this) {
        if (mSystemReady) {
            // by the SystemServer
            if (goingCallback != null) {
                goingCallback.run();
            }
            return;
        }
        mHasHeavyWeightFeature = mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_CANT_SAVE_STATE);
        mLocalDeviceIdleController = LocalServices.getService(DeviceIdleController.LocalService.class);
        mAssistUtils = new AssistUtils(mContext);
        mVrController.onSystemReady();
        // Make sure we have the current profile info, since it is needed for security checks.
        mUserController.onSystemReady();
        mRecentTasks.onSystemReadyLocked();
        mAppOpsService.systemReady();
        mSystemReady = true;
    }
    try {
        sTheRealBuildSerial = IDeviceIdentifiersPolicyService.Stub.asInterface(ServiceManager.getService(Context.DEVICE_IDENTIFIERS_SERVICE)).getSerial();
    } catch (RemoteException e) {
    }
    ArrayList<ProcessRecord> procsToKill = null;
    synchronized (mPidsSelfLocked) {
        for (int i = mPidsSelfLocked.size() - 1; i >= 0; i--) {
            ProcessRecord proc = mPidsSelfLocked.valueAt(i);
            if (!isAllowedWhileBooting(proc.info)) {
                if (procsToKill == null) {
                    procsToKill = new ArrayList<ProcessRecord>();
                }
                procsToKill.add(proc);
            }
        }
    }
    synchronized (this) {
        if (procsToKill != null) {
            for (int i = procsToKill.size() - 1; i >= 0; i--) {
                ProcessRecord proc = procsToKill.get(i);
                Slog.i(TAG, "Removing system update proc: " + proc);
                removeProcessLocked(proc, true, false, "system update done");
            }
        }
        // Now that we have cleaned up any update processes, we
        // are ready to start launching real processes and know that
        // we won't trample on them any more.
        mProcessesReady = true;
    }
    Slog.i(TAG, "System now ready");
    EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_AMS_READY, SystemClock.uptimeMillis());
    synchronized (this) {
        if (mFactoryTest == FactoryTest.FACTORY_TEST_LOW_LEVEL) {
            ResolveInfo ri = mContext.getPackageManager().resolveActivity(new Intent(Intent.ACTION_FACTORY_TEST), STOCK_PM_FLAGS);
            CharSequence errorMsg = null;
            if (ri != null) {
                ActivityInfo ai = ri.activityInfo;
                ApplicationInfo app = ai.applicationInfo;
                if ((app.flags & ApplicationInfo.FLAG_SYSTEM) != 0) {
                    mTopAction = Intent.ACTION_FACTORY_TEST;
                    mTopData = null;
                    mTopComponent = new ComponentName(app.packageName, ai.name);
                } else {
                    errorMsg = mContext.getResources().getText(com.android.internal.R.string.factorytest_not_system);
                }
            } else {
                errorMsg = mContext.getResources().getText(com.android.internal.R.string.factorytest_no_action);
            }
            if (errorMsg != null) {
                mTopAction = null;
                mTopData = null;
                mTopComponent = null;
                Message msg = Message.obtain();
                msg.what = SHOW_FACTORY_ERROR_UI_MSG;
                msg.getData().putCharSequence("msg", errorMsg);
                mUiHandler.sendMessage(msg);
            }
        }
    }
    retrieveSettings();
    final int currentUserId = mUserController.getCurrentUserId();
    synchronized (this) {
        readGrantedUriPermissionsLocked();
    }
    final PowerManagerInternal pmi = LocalServices.getService(PowerManagerInternal.class);
    if (pmi != null) {
        pmi.registerLowPowerModeObserver(ServiceType.FORCE_BACKGROUND_CHECK, state -> updateForceBackgroundCheck(state.batterySaverEnabled));
        updateForceBackgroundCheck(pmi.getLowPowerState(ServiceType.FORCE_BACKGROUND_CHECK).batterySaverEnabled);
    } else {
        Slog.wtf(TAG, "PowerManagerInternal not found.");
    }
    if (goingCallback != null)
        goingCallback.run();
    traceLog.traceBegin("ActivityManagerStartApps");
    mBatteryStatsService.noteEvent(BatteryStats.HistoryItem.EVENT_USER_RUNNING_START, Integer.toString(currentUserId), currentUserId);
    mBatteryStatsService.noteEvent(BatteryStats.HistoryItem.EVENT_USER_FOREGROUND_START, Integer.toString(currentUserId), currentUserId);
    mSystemServiceManager.startUser(currentUserId);
    synchronized (this) {
        // Only start up encryption-aware persistent apps; once user is
        // unlocked we'll come back around and start unaware apps
        startPersistentApps(PackageManager.MATCH_DIRECT_BOOT_AWARE);
        // Start up initial activity.
        mBooting = true;
        // to handle home activity in this case.
        if (UserManager.isSplitSystemUser() && Settings.Secure.getInt(mContext.getContentResolver(), Settings.Secure.USER_SETUP_COMPLETE, 0) != 0) {
            ComponentName cName = new ComponentName(mContext, SystemUserHomeActivity.class);
            try {
                AppGlobals.getPackageManager().setComponentEnabledSetting(cName, PackageManager.COMPONENT_ENABLED_STATE_ENABLED, 0, UserHandle.USER_SYSTEM);
            } catch (RemoteException e) {
                throw e.rethrowAsRuntimeException();
            }
        }
        startHomeActivityLocked(currentUserId, "systemReady");
        try {
            if (AppGlobals.getPackageManager().hasSystemUidErrors()) {
                Slog.e(TAG, "UIDs on the system are inconsistent, you need to wipe your" + " data partition or your device will be unstable.");
                mUiHandler.obtainMessage(SHOW_UID_ERROR_UI_MSG).sendToTarget();
            }
        } catch (RemoteException e) {
        }
        if (!Build.isBuildConsistent()) {
            Slog.e(TAG, "Build fingerprint is not consistent, warning user");
            mUiHandler.obtainMessage(SHOW_FINGERPRINT_ERROR_UI_MSG).sendToTarget();
        }
        long ident = Binder.clearCallingIdentity();
        try {
            Intent intent = new Intent(Intent.ACTION_USER_STARTED);
            intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY | Intent.FLAG_RECEIVER_FOREGROUND);
            intent.putExtra(Intent.EXTRA_USER_HANDLE, currentUserId);
            broadcastIntentLocked(null, null, intent, null, null, 0, null, null, null, OP_NONE, null, false, false, MY_PID, SYSTEM_UID, currentUserId);
            intent = new Intent(Intent.ACTION_USER_STARTING);
            intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
            intent.putExtra(Intent.EXTRA_USER_HANDLE, currentUserId);
            broadcastIntentLocked(null, null, intent, null, new IIntentReceiver.Stub() {

                @Override
                public void performReceive(Intent intent, int resultCode, String data, Bundle extras, boolean ordered, boolean sticky, int sendingUser) throws RemoteException {
                }
            }, 0, null, null, new String[] { INTERACT_ACROSS_USERS }, OP_NONE, null, true, false, MY_PID, SYSTEM_UID, UserHandle.USER_ALL);
        } catch (Throwable t) {
            Slog.wtf(TAG, "Failed sending first user broadcasts", t);
        } finally {
            Binder.restoreCallingIdentity(ident);
        }
        mStackSupervisor.resumeFocusedStackTopActivityLocked();
        mUserController.sendUserSwitchBroadcasts(-1, currentUserId);
        BinderInternal.nSetBinderProxyCountWatermarks(6000, 5500);
        BinderInternal.nSetBinderProxyCountEnabled(true);
        BinderInternal.setBinderProxyCountCallback(new BinderInternal.BinderProxyLimitListener() {

            @Override
            public void onLimitReached(int uid) {
                Slog.wtf(TAG, "Uid " + uid + " sent too many Binders to uid " + Process.myUid());
                BinderProxy.dumpProxyDebugInfo();
                if (uid == Process.SYSTEM_UID) {
                    Slog.i(TAG, "Skipping kill (uid is SYSTEM)");
                } else {
                    killUid(UserHandle.getAppId(uid), UserHandle.getUserId(uid), "Too many Binders sent to SYSTEM");
                }
            }
        }, mHandler);
        // ActivityManagerStartApps
        traceLog.traceEnd();
        // PhaseActivityManagerReady
        traceLog.traceEnd();
    }
}
#end_block

#method_before
private void doDump(FileDescriptor fd, PrintWriter pw, String[] args, boolean useProto) {
    if (!DumpUtils.checkDumpAndUsageStatsPermission(mContext, TAG, pw))
        return;
    boolean dumpAll = false;
    boolean dumpClient = false;
    boolean dumpCheckin = false;
    boolean dumpCheckinFormat = false;
    boolean dumpNormalPriority = false;
    boolean dumpVisibleStacksOnly = false;
    boolean dumpFocusedStackOnly = false;
    String dumpPackage = null;
    int opti = 0;
    while (opti < args.length) {
        String opt = args[opti];
        if (opt == null || opt.length() <= 0 || opt.charAt(0) != '-') {
            break;
        }
        opti++;
        if ("-a".equals(opt)) {
            dumpAll = true;
        } else if ("-c".equals(opt)) {
            dumpClient = true;
        } else if ("-v".equals(opt)) {
            dumpVisibleStacksOnly = true;
        } else if ("-f".equals(opt)) {
            dumpFocusedStackOnly = true;
        } else if ("-p".equals(opt)) {
            if (opti < args.length) {
                dumpPackage = args[opti];
                opti++;
            } else {
                pw.println("Error: -p option requires package argument");
                return;
            }
            dumpClient = true;
        } else if ("--checkin".equals(opt)) {
            dumpCheckin = dumpCheckinFormat = true;
        } else if ("-C".equals(opt)) {
            dumpCheckinFormat = true;
        } else if ("--normal-priority".equals(opt)) {
            dumpNormalPriority = true;
        } else if ("-h".equals(opt)) {
            ActivityManagerShellCommand.dumpHelp(pw, true);
            return;
        } else {
            pw.println("Unknown argument: " + opt + "; use -h for help");
        }
    }
    long origId = Binder.clearCallingIdentity();
    if (useProto) {
        final ProtoOutputStream proto = new ProtoOutputStream(fd);
        String cmd = opti < args.length ? args[opti] : "";
        opti++;
        if ("activities".equals(cmd) || "a".equals(cmd)) {
            // output proto is ActivityManagerServiceDumpActivitiesProto
            synchronized (this) {
                writeActivitiesToProtoLocked(proto);
            }
        } else if ("broadcasts".equals(cmd) || "b".equals(cmd)) {
            // output proto is ActivityManagerServiceDumpBroadcastsProto
            synchronized (this) {
                writeBroadcastsToProtoLocked(proto);
            }
        } else if ("provider".equals(cmd)) {
            String[] newArgs;
            String name;
            if (opti >= args.length) {
                name = null;
                newArgs = EMPTY_STRING_ARRAY;
            } else {
                name = args[opti];
                opti++;
                newArgs = new String[args.length - opti];
                if (args.length > 2)
                    System.arraycopy(args, opti, newArgs, 0, args.length - opti);
            }
            if (!dumpProviderProto(fd, pw, name, newArgs)) {
                pw.println("No providers match: " + name);
                pw.println("Use -h for help.");
            }
        } else if ("service".equals(cmd)) {
            // output proto is ActivityManagerServiceDumpServicesProto
            mServices.writeToProto(proto, ActivityManagerServiceDumpServicesProto.ACTIVE_SERVICES);
        } else if ("processes".equals(cmd) || "p".equals(cmd)) {
            if (opti < args.length) {
                dumpPackage = args[opti];
                opti++;
            }
            // output proto is ProcessProto
            synchronized (this) {
                writeProcessesToProtoLocked(proto, dumpPackage);
            }
        } else {
            // default option, dump everything, output is ActivityManagerServiceProto
            synchronized (this) {
                long activityToken = proto.start(ActivityManagerServiceProto.ACTIVITIES);
                writeActivitiesToProtoLocked(proto);
                proto.end(activityToken);
                long broadcastToken = proto.start(ActivityManagerServiceProto.BROADCASTS);
                writeBroadcastsToProtoLocked(proto);
                proto.end(broadcastToken);
                long serviceToken = proto.start(ActivityManagerServiceProto.SERVICES);
                mServices.writeToProto(proto, ActivityManagerServiceDumpServicesProto.ACTIVE_SERVICES);
                proto.end(serviceToken);
                long processToken = proto.start(ActivityManagerServiceProto.PROCESSES);
                writeProcessesToProtoLocked(proto, dumpPackage);
                proto.end(processToken);
            }
        }
        proto.flush();
        Binder.restoreCallingIdentity(origId);
        return;
    }
    int dumpAppId = getAppId(dumpPackage);
    boolean more = false;
    // Is the caller requesting to dump a particular piece of data?
    if (opti < args.length) {
        String cmd = args[opti];
        opti++;
        if ("activities".equals(cmd) || "a".equals(cmd)) {
            synchronized (this) {
                dumpActivitiesLocked(fd, pw, args, opti, true, dumpClient, dumpPackage);
            }
        } else if ("lastanr".equals(cmd)) {
            synchronized (this) {
                dumpLastANRLocked(pw);
            }
        } else if ("starter".equals(cmd)) {
            synchronized (this) {
                dumpActivityStarterLocked(pw, dumpPackage);
            }
        } else if ("containers".equals(cmd)) {
            synchronized (this) {
                dumpActivityContainersLocked(pw);
            }
        } else if ("recents".equals(cmd) || "r".equals(cmd)) {
            synchronized (this) {
                if (mRecentTasks != null) {
                    mRecentTasks.dump(pw, true, /* dumpAll */
                    dumpPackage);
                }
            }
        } else if ("binder-proxies".equals(cmd)) {
            if (opti >= args.length) {
                dumpBinderProxiesCounts(pw, BinderInternal.nGetBinderProxyPerUidCounts(), "Counts of Binder Proxies held by SYSTEM");
            } else {
                String uid = args[opti];
                opti++;
                // Ensure Binder Proxy Count is as up to date as possible
                System.gc();
                System.runFinalization();
                System.gc();
                pw.println(BinderInternal.nGetBinderProxyCount(Integer.parseInt(uid)));
            }
        } else if ("broadcasts".equals(cmd) || "b".equals(cmd)) {
            if (opti < args.length) {
                dumpPackage = args[opti];
                opti++;
            }
            synchronized (this) {
                dumpBroadcastsLocked(fd, pw, args, opti, true, dumpPackage);
            }
        } else if ("broadcast-stats".equals(cmd)) {
            if (opti < args.length) {
                dumpPackage = args[opti];
                opti++;
            }
            synchronized (this) {
                if (dumpCheckinFormat) {
                    dumpBroadcastStatsCheckinLocked(fd, pw, args, opti, dumpCheckin, dumpPackage);
                } else {
                    dumpBroadcastStatsLocked(fd, pw, args, opti, true, dumpPackage);
                }
            }
        } else if ("intents".equals(cmd) || "i".equals(cmd)) {
            if (opti < args.length) {
                dumpPackage = args[opti];
                opti++;
            }
            synchronized (this) {
                dumpPendingIntentsLocked(fd, pw, args, opti, true, dumpPackage);
            }
        } else if ("processes".equals(cmd) || "p".equals(cmd)) {
            if (opti < args.length) {
                dumpPackage = args[opti];
                opti++;
            }
            synchronized (this) {
                dumpProcessesLocked(fd, pw, args, opti, true, dumpPackage, dumpAppId);
            }
        } else if ("oom".equals(cmd) || "o".equals(cmd)) {
            synchronized (this) {
                dumpOomLocked(fd, pw, args, opti, true);
            }
        } else if ("permissions".equals(cmd) || "perm".equals(cmd)) {
            synchronized (this) {
                dumpPermissionsLocked(fd, pw, args, opti, true, null);
            }
        } else if ("provider".equals(cmd)) {
            String[] newArgs;
            String name;
            if (opti >= args.length) {
                name = null;
                newArgs = EMPTY_STRING_ARRAY;
            } else {
                name = args[opti];
                opti++;
                newArgs = new String[args.length - opti];
                if (args.length > 2)
                    System.arraycopy(args, opti, newArgs, 0, args.length - opti);
            }
            if (!dumpProvider(fd, pw, name, newArgs, 0, dumpAll)) {
                pw.println("No providers match: " + name);
                pw.println("Use -h for help.");
            }
        } else if ("providers".equals(cmd) || "prov".equals(cmd)) {
            synchronized (this) {
                dumpProvidersLocked(fd, pw, args, opti, true, null);
            }
        } else if ("service".equals(cmd)) {
            String[] newArgs;
            String name;
            if (opti >= args.length) {
                name = null;
                newArgs = EMPTY_STRING_ARRAY;
            } else {
                name = args[opti];
                opti++;
                newArgs = new String[args.length - opti];
                if (args.length > 2)
                    System.arraycopy(args, opti, newArgs, 0, args.length - opti);
            }
            if (!mServices.dumpService(fd, pw, name, newArgs, 0, dumpAll)) {
                pw.println("No services match: " + name);
                pw.println("Use -h for help.");
            }
        } else if ("package".equals(cmd)) {
            String[] newArgs;
            if (opti >= args.length) {
                pw.println("package: no package name specified");
                pw.println("Use -h for help.");
            } else {
                dumpPackage = args[opti];
                opti++;
                newArgs = new String[args.length - opti];
                if (args.length > 2)
                    System.arraycopy(args, opti, newArgs, 0, args.length - opti);
                args = newArgs;
                opti = 0;
                more = true;
            }
        } else if ("associations".equals(cmd) || "as".equals(cmd)) {
            synchronized (this) {
                dumpAssociationsLocked(fd, pw, args, opti, true, dumpClient, dumpPackage);
            }
        } else if ("settings".equals(cmd)) {
            synchronized (this) {
                mConstants.dump(pw);
            }
        } else if ("services".equals(cmd) || "s".equals(cmd)) {
            if (dumpClient) {
                ActiveServices.ServiceDumper dumper;
                synchronized (this) {
                    dumper = mServices.newServiceDumperLocked(fd, pw, args, opti, true, dumpPackage);
                }
                dumper.dumpWithClient();
            } else {
                synchronized (this) {
                    mServices.newServiceDumperLocked(fd, pw, args, opti, true, dumpPackage).dumpLocked();
                }
            }
        } else if ("locks".equals(cmd)) {
            LockGuard.dump(fd, pw, args);
        } else {
            // Dumping a single activity?
            if (!dumpActivity(fd, pw, cmd, args, opti, dumpAll, dumpVisibleStacksOnly, dumpFocusedStackOnly)) {
                ActivityManagerShellCommand shell = new ActivityManagerShellCommand(this, true);
                int res = shell.exec(this, null, fd, null, args, null, new ResultReceiver(null));
                if (res < 0) {
                    pw.println("Bad activity command, or no activities match: " + cmd);
                    pw.println("Use -h for help.");
                }
            }
        }
        if (!more) {
            Binder.restoreCallingIdentity(origId);
            return;
        }
    }
    // No piece of data specified, dump everything.
    if (dumpCheckinFormat) {
        dumpBroadcastStatsCheckinLocked(fd, pw, args, opti, dumpCheckin, dumpPackage);
    } else if (dumpClient) {
        ActiveServices.ServiceDumper sdumper;
        synchronized (this) {
            mConstants.dump(pw);
            pw.println();
            if (dumpAll) {
                pw.println("-------------------------------------------------------------------------------");
            }
            dumpPendingIntentsLocked(fd, pw, args, opti, dumpAll, dumpPackage);
            pw.println();
            if (dumpAll) {
                pw.println("-------------------------------------------------------------------------------");
            }
            dumpBroadcastsLocked(fd, pw, args, opti, dumpAll, dumpPackage);
            pw.println();
            if (dumpAll) {
                pw.println("-------------------------------------------------------------------------------");
            }
            if (dumpAll || dumpPackage != null) {
                dumpBroadcastStatsLocked(fd, pw, args, opti, dumpAll, dumpPackage);
                pw.println();
                if (dumpAll) {
                    pw.println("-------------------------------------------------------------------------------");
                }
            }
            dumpProvidersLocked(fd, pw, args, opti, dumpAll, dumpPackage);
            pw.println();
            if (dumpAll) {
                pw.println("-------------------------------------------------------------------------------");
            }
            dumpPermissionsLocked(fd, pw, args, opti, dumpAll, dumpPackage);
            pw.println();
            if (dumpAll) {
                pw.println("-------------------------------------------------------------------------------");
            }
            sdumper = mServices.newServiceDumperLocked(fd, pw, args, opti, dumpAll, dumpPackage);
        }
        sdumper.dumpWithClient();
        pw.println();
        synchronized (this) {
            if (dumpAll) {
                pw.println("-------------------------------------------------------------------------------");
            }
            if (mRecentTasks != null) {
                mRecentTasks.dump(pw, dumpAll, dumpPackage);
            }
            pw.println();
            if (dumpAll) {
                pw.println("-------------------------------------------------------------------------------");
            }
            dumpLastANRLocked(pw);
            pw.println();
            if (dumpAll) {
                pw.println("-------------------------------------------------------------------------------");
            }
            dumpActivityStarterLocked(pw, dumpPackage);
            pw.println();
            if (dumpAll) {
                pw.println("-------------------------------------------------------------------------------");
            }
            dumpActivityContainersLocked(pw);
            pw.println();
            if (dumpAll) {
                pw.println("-------------------------------------------------------------------------------");
            }
            dumpActivitiesLocked(fd, pw, args, opti, dumpAll, dumpClient, dumpPackage);
            if (mAssociations.size() > 0) {
                pw.println();
                if (dumpAll) {
                    pw.println("-------------------------------------------------------------------------------");
                }
                dumpAssociationsLocked(fd, pw, args, opti, dumpAll, dumpClient, dumpPackage);
            }
            pw.println();
            if (dumpAll) {
                pw.println("-------------------------------------------------------------------------------");
            }
            dumpProcessesLocked(fd, pw, args, opti, dumpAll, dumpPackage, dumpAppId);
        }
    } else {
        synchronized (this) {
            mConstants.dump(pw);
            pw.println();
            if (dumpAll) {
                pw.println("-------------------------------------------------------------------------------");
            }
            dumpPendingIntentsLocked(fd, pw, args, opti, dumpAll, dumpPackage);
            pw.println();
            if (dumpAll) {
                pw.println("-------------------------------------------------------------------------------");
            }
            dumpBroadcastsLocked(fd, pw, args, opti, dumpAll, dumpPackage);
            pw.println();
            if (dumpAll) {
                pw.println("-------------------------------------------------------------------------------");
            }
            if (dumpAll || dumpPackage != null) {
                dumpBroadcastStatsLocked(fd, pw, args, opti, dumpAll, dumpPackage);
                pw.println();
                if (dumpAll) {
                    pw.println("-------------------------------------------------------------------------------");
                }
            }
            dumpProvidersLocked(fd, pw, args, opti, dumpAll, dumpPackage);
            pw.println();
            if (dumpAll) {
                pw.println("-------------------------------------------------------------------------------");
            }
            dumpPermissionsLocked(fd, pw, args, opti, dumpAll, dumpPackage);
            pw.println();
            if (dumpAll) {
                pw.println("-------------------------------------------------------------------------------");
            }
            mServices.newServiceDumperLocked(fd, pw, args, opti, dumpAll, dumpPackage).dumpLocked();
            pw.println();
            if (dumpAll) {
                pw.println("-------------------------------------------------------------------------------");
            }
            if (mRecentTasks != null) {
                mRecentTasks.dump(pw, dumpAll, dumpPackage);
            }
            pw.println();
            if (dumpAll) {
                pw.println("-------------------------------------------------------------------------------");
            }
            dumpLastANRLocked(pw);
            pw.println();
            if (dumpAll) {
                pw.println("-------------------------------------------------------------------------------");
            }
            dumpActivityStarterLocked(pw, dumpPackage);
            pw.println();
            if (dumpAll) {
                pw.println("-------------------------------------------------------------------------------");
            }
            dumpActivityContainersLocked(pw);
            // section if priority is Normal.
            if (!dumpNormalPriority) {
                pw.println();
                if (dumpAll) {
                    pw.println("-------------------------------------------------------------------------------");
                }
                dumpActivitiesLocked(fd, pw, args, opti, dumpAll, dumpClient, dumpPackage);
            }
            if (mAssociations.size() > 0) {
                pw.println();
                if (dumpAll) {
                    pw.println("-------------------------------------------------------------------------------");
                }
                dumpAssociationsLocked(fd, pw, args, opti, dumpAll, dumpClient, dumpPackage);
            }
            pw.println();
            if (dumpAll) {
                pw.println("-------------------------------------------------------------------------------");
            }
            dumpProcessesLocked(fd, pw, args, opti, dumpAll, dumpPackage, dumpAppId);
        }
    }
    Binder.restoreCallingIdentity(origId);
}
#method_after
private void doDump(FileDescriptor fd, PrintWriter pw, String[] args, boolean useProto) {
    if (!DumpUtils.checkDumpAndUsageStatsPermission(mContext, TAG, pw))
        return;
    boolean dumpAll = false;
    boolean dumpClient = false;
    boolean dumpCheckin = false;
    boolean dumpCheckinFormat = false;
    boolean dumpNormalPriority = false;
    boolean dumpVisibleStacksOnly = false;
    boolean dumpFocusedStackOnly = false;
    String dumpPackage = null;
    int opti = 0;
    while (opti < args.length) {
        String opt = args[opti];
        if (opt == null || opt.length() <= 0 || opt.charAt(0) != '-') {
            break;
        }
        opti++;
        if ("-a".equals(opt)) {
            dumpAll = true;
        } else if ("-c".equals(opt)) {
            dumpClient = true;
        } else if ("-v".equals(opt)) {
            dumpVisibleStacksOnly = true;
        } else if ("-f".equals(opt)) {
            dumpFocusedStackOnly = true;
        } else if ("-p".equals(opt)) {
            if (opti < args.length) {
                dumpPackage = args[opti];
                opti++;
            } else {
                pw.println("Error: -p option requires package argument");
                return;
            }
            dumpClient = true;
        } else if ("--checkin".equals(opt)) {
            dumpCheckin = dumpCheckinFormat = true;
        } else if ("-C".equals(opt)) {
            dumpCheckinFormat = true;
        } else if ("--normal-priority".equals(opt)) {
            dumpNormalPriority = true;
        } else if ("-h".equals(opt)) {
            ActivityManagerShellCommand.dumpHelp(pw, true);
            return;
        } else {
            pw.println("Unknown argument: " + opt + "; use -h for help");
        }
    }
    long origId = Binder.clearCallingIdentity();
    if (useProto) {
        final ProtoOutputStream proto = new ProtoOutputStream(fd);
        String cmd = opti < args.length ? args[opti] : "";
        opti++;
        if ("activities".equals(cmd) || "a".equals(cmd)) {
            // output proto is ActivityManagerServiceDumpActivitiesProto
            synchronized (this) {
                writeActivitiesToProtoLocked(proto);
            }
        } else if ("broadcasts".equals(cmd) || "b".equals(cmd)) {
            // output proto is ActivityManagerServiceDumpBroadcastsProto
            synchronized (this) {
                writeBroadcastsToProtoLocked(proto);
            }
        } else if ("provider".equals(cmd)) {
            String[] newArgs;
            String name;
            if (opti >= args.length) {
                name = null;
                newArgs = EMPTY_STRING_ARRAY;
            } else {
                name = args[opti];
                opti++;
                newArgs = new String[args.length - opti];
                if (args.length > 2)
                    System.arraycopy(args, opti, newArgs, 0, args.length - opti);
            }
            if (!dumpProviderProto(fd, pw, name, newArgs)) {
                pw.println("No providers match: " + name);
                pw.println("Use -h for help.");
            }
        } else if ("service".equals(cmd)) {
            // output proto is ActivityManagerServiceDumpServicesProto
            mServices.writeToProto(proto, ActivityManagerServiceDumpServicesProto.ACTIVE_SERVICES);
        } else if ("processes".equals(cmd) || "p".equals(cmd)) {
            if (opti < args.length) {
                dumpPackage = args[opti];
                opti++;
            }
            // output proto is ProcessProto
            synchronized (this) {
                writeProcessesToProtoLocked(proto, dumpPackage);
            }
        } else {
            // default option, dump everything, output is ActivityManagerServiceProto
            synchronized (this) {
                long activityToken = proto.start(ActivityManagerServiceProto.ACTIVITIES);
                writeActivitiesToProtoLocked(proto);
                proto.end(activityToken);
                long broadcastToken = proto.start(ActivityManagerServiceProto.BROADCASTS);
                writeBroadcastsToProtoLocked(proto);
                proto.end(broadcastToken);
                long serviceToken = proto.start(ActivityManagerServiceProto.SERVICES);
                mServices.writeToProto(proto, ActivityManagerServiceDumpServicesProto.ACTIVE_SERVICES);
                proto.end(serviceToken);
                long processToken = proto.start(ActivityManagerServiceProto.PROCESSES);
                writeProcessesToProtoLocked(proto, dumpPackage);
                proto.end(processToken);
            }
        }
        proto.flush();
        Binder.restoreCallingIdentity(origId);
        return;
    }
    int dumpAppId = getAppId(dumpPackage);
    boolean more = false;
    // Is the caller requesting to dump a particular piece of data?
    if (opti < args.length) {
        String cmd = args[opti];
        opti++;
        if ("activities".equals(cmd) || "a".equals(cmd)) {
            synchronized (this) {
                dumpActivitiesLocked(fd, pw, args, opti, true, dumpClient, dumpPackage);
            }
        } else if ("lastanr".equals(cmd)) {
            synchronized (this) {
                dumpLastANRLocked(pw);
            }
        } else if ("starter".equals(cmd)) {
            synchronized (this) {
                dumpActivityStarterLocked(pw, dumpPackage);
            }
        } else if ("containers".equals(cmd)) {
            synchronized (this) {
                dumpActivityContainersLocked(pw);
            }
        } else if ("recents".equals(cmd) || "r".equals(cmd)) {
            synchronized (this) {
                if (mRecentTasks != null) {
                    mRecentTasks.dump(pw, true, /* dumpAll */
                    dumpPackage);
                }
            }
        } else if ("binder-proxies".equals(cmd)) {
            if (opti >= args.length) {
                dumpBinderProxyInterfaceCounts(pw, "Top proxy interface names held by SYSTEM");
                dumpBinderProxiesCounts(pw, BinderInternal.nGetBinderProxyPerUidCounts(), "Number of proxies per uid held by SYSTEM");
            } else {
                String uid = args[opti];
                opti++;
                // Ensure Binder Proxy Count is as up to date as possible
                System.gc();
                System.runFinalization();
                System.gc();
                pw.println(BinderInternal.nGetBinderProxyCount(Integer.parseInt(uid)));
            }
        } else if ("broadcasts".equals(cmd) || "b".equals(cmd)) {
            if (opti < args.length) {
                dumpPackage = args[opti];
                opti++;
            }
            synchronized (this) {
                dumpBroadcastsLocked(fd, pw, args, opti, true, dumpPackage);
            }
        } else if ("broadcast-stats".equals(cmd)) {
            if (opti < args.length) {
                dumpPackage = args[opti];
                opti++;
            }
            synchronized (this) {
                if (dumpCheckinFormat) {
                    dumpBroadcastStatsCheckinLocked(fd, pw, args, opti, dumpCheckin, dumpPackage);
                } else {
                    dumpBroadcastStatsLocked(fd, pw, args, opti, true, dumpPackage);
                }
            }
        } else if ("intents".equals(cmd) || "i".equals(cmd)) {
            if (opti < args.length) {
                dumpPackage = args[opti];
                opti++;
            }
            synchronized (this) {
                dumpPendingIntentsLocked(fd, pw, args, opti, true, dumpPackage);
            }
        } else if ("processes".equals(cmd) || "p".equals(cmd)) {
            if (opti < args.length) {
                dumpPackage = args[opti];
                opti++;
            }
            synchronized (this) {
                dumpProcessesLocked(fd, pw, args, opti, true, dumpPackage, dumpAppId);
            }
        } else if ("oom".equals(cmd) || "o".equals(cmd)) {
            synchronized (this) {
                dumpOomLocked(fd, pw, args, opti, true);
            }
        } else if ("permissions".equals(cmd) || "perm".equals(cmd)) {
            synchronized (this) {
                dumpPermissionsLocked(fd, pw, args, opti, true, null);
            }
        } else if ("provider".equals(cmd)) {
            String[] newArgs;
            String name;
            if (opti >= args.length) {
                name = null;
                newArgs = EMPTY_STRING_ARRAY;
            } else {
                name = args[opti];
                opti++;
                newArgs = new String[args.length - opti];
                if (args.length > 2)
                    System.arraycopy(args, opti, newArgs, 0, args.length - opti);
            }
            if (!dumpProvider(fd, pw, name, newArgs, 0, dumpAll)) {
                pw.println("No providers match: " + name);
                pw.println("Use -h for help.");
            }
        } else if ("providers".equals(cmd) || "prov".equals(cmd)) {
            synchronized (this) {
                dumpProvidersLocked(fd, pw, args, opti, true, null);
            }
        } else if ("service".equals(cmd)) {
            String[] newArgs;
            String name;
            if (opti >= args.length) {
                name = null;
                newArgs = EMPTY_STRING_ARRAY;
            } else {
                name = args[opti];
                opti++;
                newArgs = new String[args.length - opti];
                if (args.length > 2)
                    System.arraycopy(args, opti, newArgs, 0, args.length - opti);
            }
            if (!mServices.dumpService(fd, pw, name, newArgs, 0, dumpAll)) {
                pw.println("No services match: " + name);
                pw.println("Use -h for help.");
            }
        } else if ("package".equals(cmd)) {
            String[] newArgs;
            if (opti >= args.length) {
                pw.println("package: no package name specified");
                pw.println("Use -h for help.");
            } else {
                dumpPackage = args[opti];
                opti++;
                newArgs = new String[args.length - opti];
                if (args.length > 2)
                    System.arraycopy(args, opti, newArgs, 0, args.length - opti);
                args = newArgs;
                opti = 0;
                more = true;
            }
        } else if ("associations".equals(cmd) || "as".equals(cmd)) {
            synchronized (this) {
                dumpAssociationsLocked(fd, pw, args, opti, true, dumpClient, dumpPackage);
            }
        } else if ("settings".equals(cmd)) {
            synchronized (this) {
                mConstants.dump(pw);
            }
        } else if ("services".equals(cmd) || "s".equals(cmd)) {
            if (dumpClient) {
                ActiveServices.ServiceDumper dumper;
                synchronized (this) {
                    dumper = mServices.newServiceDumperLocked(fd, pw, args, opti, true, dumpPackage);
                }
                dumper.dumpWithClient();
            } else {
                synchronized (this) {
                    mServices.newServiceDumperLocked(fd, pw, args, opti, true, dumpPackage).dumpLocked();
                }
            }
        } else if ("locks".equals(cmd)) {
            LockGuard.dump(fd, pw, args);
        } else {
            // Dumping a single activity?
            if (!dumpActivity(fd, pw, cmd, args, opti, dumpAll, dumpVisibleStacksOnly, dumpFocusedStackOnly)) {
                ActivityManagerShellCommand shell = new ActivityManagerShellCommand(this, true);
                int res = shell.exec(this, null, fd, null, args, null, new ResultReceiver(null));
                if (res < 0) {
                    pw.println("Bad activity command, or no activities match: " + cmd);
                    pw.println("Use -h for help.");
                }
            }
        }
        if (!more) {
            Binder.restoreCallingIdentity(origId);
            return;
        }
    }
    // No piece of data specified, dump everything.
    if (dumpCheckinFormat) {
        dumpBroadcastStatsCheckinLocked(fd, pw, args, opti, dumpCheckin, dumpPackage);
    } else if (dumpClient) {
        ActiveServices.ServiceDumper sdumper;
        synchronized (this) {
            mConstants.dump(pw);
            pw.println();
            if (dumpAll) {
                pw.println("-------------------------------------------------------------------------------");
            }
            dumpPendingIntentsLocked(fd, pw, args, opti, dumpAll, dumpPackage);
            pw.println();
            if (dumpAll) {
                pw.println("-------------------------------------------------------------------------------");
            }
            dumpBroadcastsLocked(fd, pw, args, opti, dumpAll, dumpPackage);
            pw.println();
            if (dumpAll) {
                pw.println("-------------------------------------------------------------------------------");
            }
            if (dumpAll || dumpPackage != null) {
                dumpBroadcastStatsLocked(fd, pw, args, opti, dumpAll, dumpPackage);
                pw.println();
                if (dumpAll) {
                    pw.println("-------------------------------------------------------------------------------");
                }
            }
            dumpProvidersLocked(fd, pw, args, opti, dumpAll, dumpPackage);
            pw.println();
            if (dumpAll) {
                pw.println("-------------------------------------------------------------------------------");
            }
            dumpPermissionsLocked(fd, pw, args, opti, dumpAll, dumpPackage);
            pw.println();
            if (dumpAll) {
                pw.println("-------------------------------------------------------------------------------");
            }
            sdumper = mServices.newServiceDumperLocked(fd, pw, args, opti, dumpAll, dumpPackage);
        }
        sdumper.dumpWithClient();
        pw.println();
        synchronized (this) {
            if (dumpAll) {
                pw.println("-------------------------------------------------------------------------------");
            }
            if (mRecentTasks != null) {
                mRecentTasks.dump(pw, dumpAll, dumpPackage);
            }
            pw.println();
            if (dumpAll) {
                pw.println("-------------------------------------------------------------------------------");
            }
            dumpLastANRLocked(pw);
            pw.println();
            if (dumpAll) {
                pw.println("-------------------------------------------------------------------------------");
            }
            dumpActivityStarterLocked(pw, dumpPackage);
            pw.println();
            if (dumpAll) {
                pw.println("-------------------------------------------------------------------------------");
            }
            dumpActivityContainersLocked(pw);
            pw.println();
            if (dumpAll) {
                pw.println("-------------------------------------------------------------------------------");
            }
            dumpActivitiesLocked(fd, pw, args, opti, dumpAll, dumpClient, dumpPackage);
            if (mAssociations.size() > 0) {
                pw.println();
                if (dumpAll) {
                    pw.println("-------------------------------------------------------------------------------");
                }
                dumpAssociationsLocked(fd, pw, args, opti, dumpAll, dumpClient, dumpPackage);
            }
            pw.println();
            if (dumpAll) {
                pw.println("-------------------------------------------------------------------------------");
            }
            dumpProcessesLocked(fd, pw, args, opti, dumpAll, dumpPackage, dumpAppId);
        }
    } else {
        synchronized (this) {
            mConstants.dump(pw);
            pw.println();
            if (dumpAll) {
                pw.println("-------------------------------------------------------------------------------");
            }
            dumpPendingIntentsLocked(fd, pw, args, opti, dumpAll, dumpPackage);
            pw.println();
            if (dumpAll) {
                pw.println("-------------------------------------------------------------------------------");
            }
            dumpBroadcastsLocked(fd, pw, args, opti, dumpAll, dumpPackage);
            pw.println();
            if (dumpAll) {
                pw.println("-------------------------------------------------------------------------------");
            }
            if (dumpAll || dumpPackage != null) {
                dumpBroadcastStatsLocked(fd, pw, args, opti, dumpAll, dumpPackage);
                pw.println();
                if (dumpAll) {
                    pw.println("-------------------------------------------------------------------------------");
                }
            }
            dumpProvidersLocked(fd, pw, args, opti, dumpAll, dumpPackage);
            pw.println();
            if (dumpAll) {
                pw.println("-------------------------------------------------------------------------------");
            }
            dumpPermissionsLocked(fd, pw, args, opti, dumpAll, dumpPackage);
            pw.println();
            if (dumpAll) {
                pw.println("-------------------------------------------------------------------------------");
            }
            mServices.newServiceDumperLocked(fd, pw, args, opti, dumpAll, dumpPackage).dumpLocked();
            pw.println();
            if (dumpAll) {
                pw.println("-------------------------------------------------------------------------------");
            }
            if (mRecentTasks != null) {
                mRecentTasks.dump(pw, dumpAll, dumpPackage);
            }
            pw.println();
            if (dumpAll) {
                pw.println("-------------------------------------------------------------------------------");
            }
            dumpLastANRLocked(pw);
            pw.println();
            if (dumpAll) {
                pw.println("-------------------------------------------------------------------------------");
            }
            dumpActivityStarterLocked(pw, dumpPackage);
            pw.println();
            if (dumpAll) {
                pw.println("-------------------------------------------------------------------------------");
            }
            dumpActivityContainersLocked(pw);
            // section if priority is Normal.
            if (!dumpNormalPriority) {
                pw.println();
                if (dumpAll) {
                    pw.println("-------------------------------------------------------------------------------");
                }
                dumpActivitiesLocked(fd, pw, args, opti, dumpAll, dumpClient, dumpPackage);
            }
            if (mAssociations.size() > 0) {
                pw.println();
                if (dumpAll) {
                    pw.println("-------------------------------------------------------------------------------");
                }
                dumpAssociationsLocked(fd, pw, args, opti, dumpAll, dumpClient, dumpPackage);
            }
            pw.println();
            if (dumpAll) {
                pw.println("-------------------------------------------------------------------------------");
            }
            dumpProcessesLocked(fd, pw, args, opti, dumpAll, dumpPackage, dumpAppId);
        }
    }
    Binder.restoreCallingIdentity(origId);
}
#end_block

#method_before
public static long CRC32Byte(int value) {
    crc32.reset();
    crc32.update(value);
    return crc32.getValue();
}
#method_after
public static long CRC32Byte(int value) {
    CRC32 crc32 = new CRC32();
    crc32.update(value);
    return crc32.getValue();
}
#end_block

#method_before
public static long CRC32BytesUsingUpdateInt(int... values) {
    crc32.reset();
    for (int value : values) {
        crc32.update(value);
    }
    return crc32.getValue();
}
#method_after
public static long CRC32BytesUsingUpdateInt(int... values) {
    CRC32 crc32 = new CRC32();
    for (int value : values) {
        crc32.update(value);
    }
    return crc32.getValue();
}
#end_block

#method_before
private static long CRC32ByteArray(byte[] bytes, int off, int len) {
    crc32.reset();
    crc32.update(bytes, off, len);
    return crc32.getValue();
}
#method_after
private static long CRC32ByteArray(byte[] bytes, int off, int len) {
    CRC32 crc32 = new CRC32();
    crc32.update(bytes, off, len);
    return crc32.getValue();
}
#end_block

#method_before
// This is used to test we generate correct code for constant offsets.
private static long CRC32ByteArray(byte[] bytes) {
    crc32.reset();
    crc32.update(bytes);
    return crc32.getValue();
}
#method_after
// This is used to test we generate correct code for constant offsets.
private static long CRC32ByteArray(byte[] bytes) {
    CRC32 crc32 = new CRC32();
    crc32.update(bytes);
    return crc32.getValue();
}
#end_block

#method_before
private static long CRC32ByteAndByteArray(int value, byte[] bytes) {
    crc32.reset();
    crc32.update(value);
    crc32.update(bytes);
    return crc32.getValue();
}
#method_after
private static long CRC32ByteAndByteArray(int value, byte[] bytes) {
    CRC32 crc32 = new CRC32();
    crc32.update(value);
    crc32.update(bytes);
    return crc32.getValue();
}
#end_block

#method_before
private static long CRC32ByteArrayAndByte(byte[] bytes, int value) {
    crc32.reset();
    crc32.update(bytes);
    crc32.update(value);
    return crc32.getValue();
}
#method_after
private static long CRC32ByteArrayAndByte(byte[] bytes, int value) {
    CRC32 crc32 = new CRC32();
    crc32.update(bytes);
    crc32.update(value);
    return crc32.getValue();
}
#end_block

#method_before
private static void TestCRC32UpdateBytes() {
    assertEqual(0L, CRC32ByteArray(new byte[] {}));
    assertEqual(0L, CRC32ByteArray(new byte[] {}, 0, 0));
    assertEqual(0L, CRC32ByteArray(new byte[] { 0 }, 0, 0));
    assertEqual(0L, CRC32ByteArray(new byte[] { 0 }, 1, 0));
    assertEqual(0L, CRC32ByteArray(new byte[] { 0, 0 }, 1, 0));
    assertEqual(true, CRC32ByteArrayThrowsNPException());
    assertEqual(true, CRC32ByteArrayThrowsIOBException(new byte[] {}, -1, 0));
    assertEqual(true, CRC32ByteArrayThrowsIOBException(new byte[] { 0 }, -1, 1));
    assertEqual(true, CRC32ByteArrayThrowsIOBException(new byte[] { 0 }, 0, -1));
    assertEqual(true, CRC32ByteArrayThrowsIOBException(new byte[] {}, 0, -1));
    assertEqual(true, CRC32ByteArrayThrowsIOBException(new byte[] {}, 1, 0));
    assertEqual(true, CRC32ByteArrayThrowsIOBException(new byte[] {}, -1, 1));
    assertEqual(true, CRC32ByteArrayThrowsIOBException(new byte[] {}, 1, -1));
    assertEqual(true, CRC32ByteArrayThrowsIOBException(new byte[] {}, 0, 1));
    assertEqual(true, CRC32ByteArrayThrowsIOBException(new byte[] {}, 0, 10));
    assertEqual(true, CRC32ByteArrayThrowsIOBException(new byte[] { 0 }, 0, 10));
    assertEqual(true, CRC32ByteArrayThrowsIOBException(new byte[] {}, 10, 10));
    assertEqual(true, CRC32ByteArrayThrowsIOBException(new byte[] { 0, 0, 0, 0 }, 2, 3));
    assertEqual(true, CRC32ByteArrayThrowsIOBException(new byte[] { 0, 0, 0, 0 }, 3, 2));
    assertEqual(CRC32Byte(0), CRC32ByteArray(new byte[] { 0 }));
    assertEqual(CRC32Byte(0), CRC32ByteArray(new byte[] { 0 }, 0, 1));
    assertEqual(CRC32Byte(1), CRC32ByteArray(new byte[] { 1 }));
    assertEqual(CRC32Byte(1), CRC32ByteArray(new byte[] { 1 }, 0, 1));
    assertEqual(CRC32Byte(0x0f), CRC32ByteArray(new byte[] { 0x0f }));
    assertEqual(CRC32Byte(0x0f), CRC32ByteArray(new byte[] { 0x0f }, 0, 1));
    assertEqual(CRC32Byte(0xff), CRC32ByteArray(new byte[] { -1 }));
    assertEqual(CRC32Byte(0xff), CRC32ByteArray(new byte[] { -1 }, 0, 1));
    assertEqual(CRC32BytesUsingUpdateInt(0, 0, 0), CRC32ByteArray(new byte[] { 0, 0, 0 }));
    assertEqual(CRC32BytesUsingUpdateInt(0, 0, 0), CRC32ByteArray(new byte[] { 0, 0, 0 }, 0, 3));
    assertEqual(CRC32BytesUsingUpdateInt(1, 1, 1), CRC32ByteArray(new byte[] { 1, 1, 1 }));
    assertEqual(CRC32BytesUsingUpdateInt(1, 1, 1), CRC32ByteArray(new byte[] { 1, 1, 1 }, 0, 3));
    assertEqual(CRC32BytesUsingUpdateInt(0x0f, 0x0f, 0x0f), CRC32ByteArray(new byte[] { 0x0f, 0x0f, 0x0f }));
    assertEqual(CRC32BytesUsingUpdateInt(0x0f, 0x0f, 0x0f), CRC32ByteArray(new byte[] { 0x0f, 0x0f, 0x0f }, 0, 3));
    assertEqual(CRC32BytesUsingUpdateInt(0xff, 0xff, 0xff), CRC32ByteArray(new byte[] { -1, -1, -1 }));
    assertEqual(CRC32BytesUsingUpdateInt(0xff, 0xff, 0xff), CRC32ByteArray(new byte[] { -1, -1, -1 }, 0, 3));
    assertEqual(CRC32BytesUsingUpdateInt(1, 2), CRC32ByteArray(new byte[] { 1, 2 }));
    assertEqual(CRC32BytesUsingUpdateInt(1, 2), CRC32ByteArray(new byte[] { 1, 2 }, 0, 2));
    assertEqual(CRC32BytesUsingUpdateInt(0, -1, Byte.MIN_VALUE, Byte.MAX_VALUE), CRC32ByteArray(new byte[] { 0, -1, Byte.MIN_VALUE, Byte.MAX_VALUE }));
    assertEqual(CRC32BytesUsingUpdateInt(0, -1, Byte.MIN_VALUE, Byte.MAX_VALUE), CRC32ByteArray(new byte[] { 0, -1, Byte.MIN_VALUE, Byte.MAX_VALUE }, 0, 4));
    assertEqual(CRC32BytesUsingUpdateInt(0, 0, 0), CRC32ByteAndByteArray(0, new byte[] { 0, 0 }));
    assertEqual(CRC32BytesUsingUpdateInt(1, 1, 1), CRC32ByteAndByteArray(1, new byte[] { 1, 1 }));
    assertEqual(CRC32BytesUsingUpdateInt(0x0f, 0x0f, 0x0f), CRC32ByteAndByteArray(0x0f, new byte[] { 0x0f, 0x0f }));
    assertEqual(CRC32BytesUsingUpdateInt(0xff, 0xff, 0xff), CRC32ByteAndByteArray(-1, new byte[] { -1, -1 }));
    assertEqual(CRC32BytesUsingUpdateInt(1, 2, 3), CRC32ByteAndByteArray(1, new byte[] { 2, 3 }));
    assertEqual(CRC32BytesUsingUpdateInt(0, -1, Byte.MIN_VALUE, Byte.MAX_VALUE), CRC32ByteAndByteArray(0, new byte[] { -1, Byte.MIN_VALUE, Byte.MAX_VALUE }));
    assertEqual(CRC32BytesUsingUpdateInt(0, 0, 0), CRC32ByteArrayAndByte(new byte[] { 0, 0 }, 0));
    assertEqual(CRC32BytesUsingUpdateInt(1, 1, 1), CRC32ByteArrayAndByte(new byte[] { 1, 1 }, 1));
    assertEqual(CRC32BytesUsingUpdateInt(0x0f, 0x0f, 0x0f), CRC32ByteArrayAndByte(new byte[] { 0x0f, 0x0f }, 0x0f));
    assertEqual(CRC32BytesUsingUpdateInt(0xff, 0xff, 0xff), CRC32ByteArrayAndByte(new byte[] { -1, -1 }, -1));
    assertEqual(CRC32BytesUsingUpdateInt(1, 2, 3), CRC32ByteArrayAndByte(new byte[] { 1, 2 }, 3));
    assertEqual(CRC32BytesUsingUpdateInt(0, -1, Byte.MIN_VALUE, Byte.MAX_VALUE), CRC32ByteArrayAndByte(new byte[] { 0, -1, Byte.MIN_VALUE }, Byte.MAX_VALUE));
    byte[] bytes = new byte[128 * 1024];
    Random rnd = new Random(0);
    rnd.nextBytes(bytes);
    assertEqual(CRC32BytesUsingUpdateInt(bytes, 0, bytes.length), CRC32ByteArray(bytes));
    assertEqual(CRC32BytesUsingUpdateInt(bytes, 0, 8 * 1024), CRC32ByteArray(bytes, 0, 8 * 1024));
    int off = rnd.nextInt(bytes.length / 2);
    for (int len = 0; len <= 16; ++len) {
        assertEqual(CRC32BytesUsingUpdateInt(bytes, off, len), CRC32ByteArray(bytes, off, len));
    }
    // Check there are no issues with unaligned accesses.
    for (int o = 1; o < 8; ++o) {
        for (int l = 2; l <= 14; l += 2) {
            assertEqual(CRC32BytesUsingUpdateInt(bytes, o, l), CRC32ByteArray(bytes, o, l));
        }
    }
    int len = bytes.length / 2;
    assertEqual(CRC32BytesUsingUpdateInt(bytes, 0, len - 1), CRC32ByteArray(bytes, 0, len - 1));
    assertEqual(CRC32BytesUsingUpdateInt(bytes, 0, len), CRC32ByteArray(bytes, 0, len));
    assertEqual(CRC32BytesUsingUpdateInt(bytes, 0, len + 1), CRC32ByteArray(bytes, 0, len + 1));
    len = rnd.nextInt(bytes.length + 1);
    off = rnd.nextInt(bytes.length - len);
    assertEqual(CRC32BytesUsingUpdateInt(bytes, off, len), CRC32ByteArray(bytes, off, len));
}
#method_after
private static void TestCRC32UpdateBytes() {
    assertEqual(0L, CRC32ByteArray(new byte[] {}));
    assertEqual(0L, CRC32ByteArray(new byte[] {}, 0, 0));
    assertEqual(0L, CRC32ByteArray(new byte[] { 0 }, 0, 0));
    assertEqual(0L, CRC32ByteArray(new byte[] { 0 }, 1, 0));
    assertEqual(0L, CRC32ByteArray(new byte[] { 0, 0 }, 1, 0));
    assertEqual(true, CRC32ByteArrayThrowsNPE());
    assertEqual(true, CRC32ByteArrayThrowsAIOOBE(new byte[] {}, -1, 0));
    assertEqual(true, CRC32ByteArrayThrowsAIOOBE(new byte[] { 0 }, -1, 1));
    assertEqual(true, CRC32ByteArrayThrowsAIOOBE(new byte[] { 0 }, 0, -1));
    assertEqual(true, CRC32ByteArrayThrowsAIOOBE(new byte[] {}, 0, -1));
    assertEqual(true, CRC32ByteArrayThrowsAIOOBE(new byte[] {}, 1, 0));
    assertEqual(true, CRC32ByteArrayThrowsAIOOBE(new byte[] {}, -1, 1));
    assertEqual(true, CRC32ByteArrayThrowsAIOOBE(new byte[] {}, 1, -1));
    assertEqual(true, CRC32ByteArrayThrowsAIOOBE(new byte[] {}, 0, 1));
    assertEqual(true, CRC32ByteArrayThrowsAIOOBE(new byte[] {}, 0, 10));
    assertEqual(true, CRC32ByteArrayThrowsAIOOBE(new byte[] { 0 }, 0, 10));
    assertEqual(true, CRC32ByteArrayThrowsAIOOBE(new byte[] {}, 10, 10));
    assertEqual(true, CRC32ByteArrayThrowsAIOOBE(new byte[] { 0, 0, 0, 0 }, 2, 3));
    assertEqual(true, CRC32ByteArrayThrowsAIOOBE(new byte[] { 0, 0, 0, 0 }, 3, 2));
    assertEqual(CRC32Byte(0), CRC32ByteArray(new byte[] { 0 }));
    assertEqual(CRC32Byte(0), CRC32ByteArray(new byte[] { 0 }, 0, 1));
    assertEqual(CRC32Byte(1), CRC32ByteArray(new byte[] { 1 }));
    assertEqual(CRC32Byte(1), CRC32ByteArray(new byte[] { 1 }, 0, 1));
    assertEqual(CRC32Byte(0x0f), CRC32ByteArray(new byte[] { 0x0f }));
    assertEqual(CRC32Byte(0x0f), CRC32ByteArray(new byte[] { 0x0f }, 0, 1));
    assertEqual(CRC32Byte(0xff), CRC32ByteArray(new byte[] { -1 }));
    assertEqual(CRC32Byte(0xff), CRC32ByteArray(new byte[] { -1 }, 0, 1));
    assertEqual(CRC32BytesUsingUpdateInt(0, 0, 0), CRC32ByteArray(new byte[] { 0, 0, 0 }));
    assertEqual(CRC32BytesUsingUpdateInt(0, 0, 0), CRC32ByteArray(new byte[] { 0, 0, 0 }, 0, 3));
    assertEqual(CRC32BytesUsingUpdateInt(1, 1, 1), CRC32ByteArray(new byte[] { 1, 1, 1 }));
    assertEqual(CRC32BytesUsingUpdateInt(1, 1, 1), CRC32ByteArray(new byte[] { 1, 1, 1 }, 0, 3));
    assertEqual(CRC32BytesUsingUpdateInt(0x0f, 0x0f, 0x0f), CRC32ByteArray(new byte[] { 0x0f, 0x0f, 0x0f }));
    assertEqual(CRC32BytesUsingUpdateInt(0x0f, 0x0f, 0x0f), CRC32ByteArray(new byte[] { 0x0f, 0x0f, 0x0f }, 0, 3));
    assertEqual(CRC32BytesUsingUpdateInt(0xff, 0xff, 0xff), CRC32ByteArray(new byte[] { -1, -1, -1 }));
    assertEqual(CRC32BytesUsingUpdateInt(0xff, 0xff, 0xff), CRC32ByteArray(new byte[] { -1, -1, -1 }, 0, 3));
    assertEqual(CRC32BytesUsingUpdateInt(1, 2), CRC32ByteArray(new byte[] { 1, 2 }));
    assertEqual(CRC32BytesUsingUpdateInt(1, 2), CRC32ByteArray(new byte[] { 1, 2 }, 0, 2));
    assertEqual(CRC32BytesUsingUpdateInt(0, -1, Byte.MIN_VALUE, Byte.MAX_VALUE), CRC32ByteArray(new byte[] { 0, -1, Byte.MIN_VALUE, Byte.MAX_VALUE }));
    assertEqual(CRC32BytesUsingUpdateInt(0, -1, Byte.MIN_VALUE, Byte.MAX_VALUE), CRC32ByteArray(new byte[] { 0, -1, Byte.MIN_VALUE, Byte.MAX_VALUE }, 0, 4));
    assertEqual(CRC32BytesUsingUpdateInt(0, 0, 0), CRC32ByteAndByteArray(0, new byte[] { 0, 0 }));
    assertEqual(CRC32BytesUsingUpdateInt(1, 1, 1), CRC32ByteAndByteArray(1, new byte[] { 1, 1 }));
    assertEqual(CRC32BytesUsingUpdateInt(0x0f, 0x0f, 0x0f), CRC32ByteAndByteArray(0x0f, new byte[] { 0x0f, 0x0f }));
    assertEqual(CRC32BytesUsingUpdateInt(0xff, 0xff, 0xff), CRC32ByteAndByteArray(-1, new byte[] { -1, -1 }));
    assertEqual(CRC32BytesUsingUpdateInt(1, 2, 3), CRC32ByteAndByteArray(1, new byte[] { 2, 3 }));
    assertEqual(CRC32BytesUsingUpdateInt(0, -1, Byte.MIN_VALUE, Byte.MAX_VALUE), CRC32ByteAndByteArray(0, new byte[] { -1, Byte.MIN_VALUE, Byte.MAX_VALUE }));
    assertEqual(CRC32BytesUsingUpdateInt(0, 0, 0), CRC32ByteArrayAndByte(new byte[] { 0, 0 }, 0));
    assertEqual(CRC32BytesUsingUpdateInt(1, 1, 1), CRC32ByteArrayAndByte(new byte[] { 1, 1 }, 1));
    assertEqual(CRC32BytesUsingUpdateInt(0x0f, 0x0f, 0x0f), CRC32ByteArrayAndByte(new byte[] { 0x0f, 0x0f }, 0x0f));
    assertEqual(CRC32BytesUsingUpdateInt(0xff, 0xff, 0xff), CRC32ByteArrayAndByte(new byte[] { -1, -1 }, -1));
    assertEqual(CRC32BytesUsingUpdateInt(1, 2, 3), CRC32ByteArrayAndByte(new byte[] { 1, 2 }, 3));
    assertEqual(CRC32BytesUsingUpdateInt(0, -1, Byte.MIN_VALUE, Byte.MAX_VALUE), CRC32ByteArrayAndByte(new byte[] { 0, -1, Byte.MIN_VALUE }, Byte.MAX_VALUE));
    byte[] bytes = new byte[128 * 1024];
    Random rnd = new Random(0);
    rnd.nextBytes(bytes);
    assertEqual(CRC32BytesUsingUpdateInt(bytes, 0, bytes.length), CRC32ByteArray(bytes));
    assertEqual(CRC32BytesUsingUpdateInt(bytes, 0, 8 * 1024), CRC32ByteArray(bytes, 0, 8 * 1024));
    int off = rnd.nextInt(bytes.length / 2);
    for (int len = 0; len <= 16; ++len) {
        assertEqual(CRC32BytesUsingUpdateInt(bytes, off, len), CRC32ByteArray(bytes, off, len));
    }
    // Check there are no issues with unaligned accesses.
    for (int o = 1; o < 8; ++o) {
        for (int l = 0; l <= 16; ++l) {
            assertEqual(CRC32BytesUsingUpdateInt(bytes, o, l), CRC32ByteArray(bytes, o, l));
        }
    }
    int len = bytes.length / 2;
    assertEqual(CRC32BytesUsingUpdateInt(bytes, 0, len - 1), CRC32ByteArray(bytes, 0, len - 1));
    assertEqual(CRC32BytesUsingUpdateInt(bytes, 0, len), CRC32ByteArray(bytes, 0, len));
    assertEqual(CRC32BytesUsingUpdateInt(bytes, 0, len + 1), CRC32ByteArray(bytes, 0, len + 1));
    len = rnd.nextInt(bytes.length + 1);
    off = rnd.nextInt(bytes.length - len);
    assertEqual(CRC32BytesUsingUpdateInt(bytes, off, len), CRC32ByteArray(bytes, off, len));
}
#end_block

#method_before
private void printEnumClass(CodeWriter out, String name, XsdRestriction restrictionType) throws JavaCodeGeneratorException {
    out.printf("public enum %s {", name);
    List<XsdEnumeration> enums = restrictionType.getEnums();
    for (XsdEnumeration tag : enums) {
        out.printf("\n%s(\"%s\"),", Utils.toEnumName(tag.getValue()), tag.getValue());
    }
    out.printf(";\n\n");
    out.printf("private final String name;\n\n");
    out.printf("%s(String name) {\n" + "this.name = name;\n" + "}\n\n", name);
    out.printf("public String getName() {\n" + "return name;\n" + "}\n");
    out.println("}");
}
#method_after
private void printEnumClass(CodeWriter out, String name, XsdRestriction restrictionType) throws JavaCodeGeneratorException {
    out.printf("public enum %s {", name);
    List<XsdEnumeration> enums = restrictionType.getEnums();
    for (XsdEnumeration tag : enums) {
        out.printf("\n%s(\"%s\"),", Utils.toEnumName(tag.getValue()), tag.getValue());
    }
    out.printf(";\n\n");
    out.printf("private final String rawName;\n\n");
    out.printf("%s(String rawName) {\n" + "this.rawName = rawName;\n" + "}\n\n", name);
    out.printf("public String getRawName() {\n" + "return rawName;\n" + "}\n");
    out.println("}");
}
#end_block

#method_before
private void printParser(CodeWriter out, String name, XsdComplexType complexType) throws JavaCodeGeneratorException {
    JavaSimpleType baseValueType = (complexType instanceof XsdSimpleContent) ? getValueType((XsdSimpleContent) complexType, true) : null;
    List<XsdElement> allElements = new ArrayList<>();
    List<XsdAttribute> allAttributes = new ArrayList<>();
    stackComponents(complexType, allElements, allAttributes);
    // parse types for elements and attributes
    List<JavaType> allElementTypes = new ArrayList<>();
    for (XsdElement element : allElements) {
        XsdElement elementValue = resolveElement(element);
        JavaType javaType = parseType(elementValue.getType(), elementValue.getName());
        allElementTypes.add(javaType);
    }
    List<JavaSimpleType> allAttributeTypes = new ArrayList<>();
    for (XsdAttribute attribute : allAttributes) {
        XsdType type = resolveAttribute(attribute).getType();
        allAttributeTypes.add(parseSimpleType(type, false));
    }
    out.printf("static %s read(org.xmlpull.v1.XmlPullParser parser) " + "throws org.xmlpull.v1.XmlPullParserException, java.io.IOException, " + "javax.xml.datatype.DatatypeConfigurationException {\n", name);
    out.printf("%s instance = new %s();\n" + "String raw = null;\n", name, name);
    for (int i = 0; i < allAttributes.size(); ++i) {
        JavaType type = allAttributeTypes.get(i);
        XsdAttribute attribute = resolveAttribute(allAttributes.get(i));
        String variableName = Utils.toVariableName(attribute.getName());
        out.printf("raw = parser.getAttributeValue(null, \"%s\");\n" + "if (raw != null) {\n", attribute.getName());
        out.print(type.getParsingExpression());
        out.printf("instance.set%s(value);\n" + "}\n", Utils.capitalize(variableName));
    }
    if (baseValueType != null) {
        out.print("raw = XmlParser.readText(parser);\n" + "if (raw != null) {\n");
        out.print(baseValueType.getParsingExpression());
        out.print("instance.setValue(value);\n" + "}\n");
    } else if (!allElements.isEmpty()) {
        out.print("while (parser.next() != org.xmlpull.v1.XmlPullParser.END_TAG) {\n" + "if (parser.getEventType() != org.xmlpull.v1.XmlPullParser.START_TAG) " + "continue;\n" + "String tagName = parser.getName();\n");
        for (int i = 0; i < allElements.size(); ++i) {
            JavaType type = allElementTypes.get(i);
            XsdElement element = allElements.get(i);
            XsdElement elementValue = resolveElement(element);
            String variableName = Utils.toVariableName(elementValue.getName());
            out.printf("if (tagName.equals(\"%s\")) {\n", elementValue.getName());
            if (type instanceof JavaSimpleType) {
                out.print("raw = XmlParser.readText(parser);\n");
            }
            out.print(type.getParsingExpression());
            if (element.isMultiple()) {
                out.printf("instance.get%s().add(value);\n", Utils.capitalize(variableName));
            } else {
                out.printf("instance.set%s(value);\n", Utils.capitalize(variableName));
            }
            out.printf("} else ");
        }
        out.print("{\n" + "XmlParser.skip(parser);\n" + "}\n" + "}\n");
    }
    out.print("return instance;\n" + "}\n");
}
#method_after
private void printParser(CodeWriter out, String name, XsdComplexType complexType) throws JavaCodeGeneratorException {
    JavaSimpleType baseValueType = (complexType instanceof XsdSimpleContent) ? getValueType((XsdSimpleContent) complexType, true) : null;
    List<XsdElement> allElements = new ArrayList<>();
    List<XsdAttribute> allAttributes = new ArrayList<>();
    stackComponents(complexType, allElements, allAttributes);
    // parse types for elements and attributes
    List<JavaType> allElementTypes = new ArrayList<>();
    for (XsdElement element : allElements) {
        XsdElement elementValue = resolveElement(element);
        JavaType javaType = parseType(elementValue.getType(), elementValue.getName());
        allElementTypes.add(javaType);
    }
    List<JavaSimpleType> allAttributeTypes = new ArrayList<>();
    for (XsdAttribute attribute : allAttributes) {
        XsdType type = resolveAttribute(attribute).getType();
        allAttributeTypes.add(parseSimpleType(type, false));
    }
    out.printf("static %s read(org.xmlpull.v1.XmlPullParser parser) " + "throws org.xmlpull.v1.XmlPullParserException, java.io.IOException, " + "javax.xml.datatype.DatatypeConfigurationException {\n", name);
    out.printf("%s instance = new %s();\n" + "String raw = null;\n", name, name);
    for (int i = 0; i < allAttributes.size(); ++i) {
        JavaType type = allAttributeTypes.get(i);
        XsdAttribute attribute = resolveAttribute(allAttributes.get(i));
        String variableName = Utils.toVariableName(attribute.getName());
        out.printf("raw = parser.getAttributeValue(null, \"%s\");\n" + "if (raw != null) {\n", attribute.getName());
        out.print(type.getParsingExpression());
        out.printf("instance.set%s(value);\n" + "}\n", Utils.capitalize(variableName));
    }
    if (baseValueType != null) {
        out.print("raw = XmlParser.readText(parser);\n" + "if (raw != null) {\n");
        out.print(baseValueType.getParsingExpression());
        out.print("instance.setValue(value);\n" + "}\n");
    } else if (!allElements.isEmpty()) {
        out.print("while (parser.next() != org.xmlpull.v1.XmlPullParser.END_TAG) {\n" + "if (parser.getEventType() != org.xmlpull.v1.XmlPullParser.START_TAG) " + "continue;\n" + "String tagName = parser.getName();\n");
        for (int i = 0; i < allElements.size(); ++i) {
            JavaType type = allElementTypes.get(i);
            XsdElement element = allElements.get(i);
            XsdElement elementValue = resolveElement(element);
            String variableName = Utils.toVariableName(elementValue.getName());
            out.printf("if (tagName.equals(\"%s\")) {\n", elementValue.getName());
            if (type instanceof JavaSimpleType) {
                out.print("raw = XmlParser.readText(parser);\n");
            }
            out.print(type.getParsingExpression());
            if (element.isMultiple()) {
                out.printf("instance.get%s().add(value);\n", Utils.capitalize(variableName));
            } else {
                out.printf("instance.set%s(value);\n", Utils.capitalize(variableName));
            }
            out.printf("} else ");
        }
        out.print("{\n" + "XmlParser.skip(parser);\n" + "}\n" + "}\n");
    } else {
        out.print("XmlParser.skip(parser);\n");
    }
    out.print("return instance;\n" + "}\n");
}
#end_block

#method_before
private JavaSimpleType parseSimpleTypeValue(XsdSimpleType simpleType, boolean traverse) throws JavaCodeGeneratorException {
    if (simpleType instanceof XsdList) {
        XsdList list = (XsdList) simpleType;
        return parseSimpleType(list.getItemType(), traverse).newListType();
    } else if (simpleType instanceof XsdRestriction) {
        // we don't consider any restrictions.
        XsdRestriction restriction = (XsdRestriction) simpleType;
        if (restriction.getEnums() != null) {
            String name = Utils.toClassName(restriction.getName());
            return new JavaSimpleType(name, name + ".valueOf(%s)", false);
        }
        return parseSimpleType(restriction.getBase(), traverse);
    } else if (simpleType instanceof XsdUnion) {
        // unions are almost always interpreted as java.lang.String
        // Exceptionally, if any of member types of union are 'list', then we interpret it as
        // List<String>
        XsdUnion union = (XsdUnion) simpleType;
        for (XsdType memberType : union.getMemberTypes()) {
            if (parseSimpleType(memberType, traverse).isList()) {
                return new JavaSimpleType("java.lang.String", "%s", true);
            }
        }
        return new JavaSimpleType("java.lang.String", "%s", false);
    } else {
        // unreachable
        throw new IllegalStateException("unknown simple type");
    }
}
#method_after
private JavaSimpleType parseSimpleTypeValue(XsdSimpleType simpleType, boolean traverse) throws JavaCodeGeneratorException {
    if (simpleType instanceof XsdList) {
        XsdList list = (XsdList) simpleType;
        return parseSimpleType(list.getItemType(), traverse).newListType();
    } else if (simpleType instanceof XsdRestriction) {
        // we don't consider any restrictions.
        XsdRestriction restriction = (XsdRestriction) simpleType;
        if (restriction.getEnums() != null) {
            String name = Utils.toClassName(restriction.getName());
            return new JavaSimpleType(name, name + ".valueOf(%s.replace(\".\", \"_\")." + "replaceAll(\"[^A-Za-z0-9_]\", \"\"))", false);
        }
        return parseSimpleType(restriction.getBase(), traverse);
    } else if (simpleType instanceof XsdUnion) {
        // unions are almost always interpreted as java.lang.String
        // Exceptionally, if any of member types of union are 'list', then we interpret it as
        // List<String>
        XsdUnion union = (XsdUnion) simpleType;
        for (XsdType memberType : union.getMemberTypes()) {
            if (parseSimpleType(memberType, traverse).isList()) {
                return new JavaSimpleType("java.lang.String", "%s", true);
            }
        }
        return new JavaSimpleType("java.lang.String", "%s", false);
    } else {
        // unreachable
        throw new IllegalStateException("unknown simple type");
    }
}
#end_block

#method_before
static String toVariableName(String name) throws CppCodeGeneratorException {
    // remove non-alphanumeric and non-underscore characters
    String trimmed = name.replaceAll("[^A-Za-z0-9_]", "");
    if (trimmed.isEmpty()) {
        throw new CppCodeGeneratorException(String.format("cannot convert to a variable name : %s", name));
    }
    String lowered = (trimmed.charAt(0) >= '0' && trimmed.charAt(0) <= '9') ? "_" + trimmed : lowerize(trimmed);
    // always starts with a lowercase or underscore character.
    return (keywordSet.contains(trimmed)) ? "_" + lowered : lowered;
}
#method_after
static String toVariableName(String name) throws CppCodeGeneratorException {
    // remove non-alphanumeric and non-underscore characters
    String trimmed = name.replaceAll("[^A-Za-z0-9_]", "");
    if (trimmed.isEmpty()) {
        throw new CppCodeGeneratorException(String.format("cannot convert to a variable name : %s", name));
    }
    String lowered = Character.isDigit(trimmed.charAt(0)) ? "_" + trimmed : lowerize(trimmed);
    // always starts with a lowercase or underscore character.
    return (keywordSet.contains(trimmed)) ? "_" + lowered : lowered;
}
#end_block

#method_before
static String toClassName(String name) throws CppCodeGeneratorException {
    // remove non-alphanumeric characters
    String trimmed = name.replaceAll("[^A-Za-z0-9]", "");
    if (trimmed.isEmpty() || (trimmed.charAt(0) >= '0' && trimmed.charAt(0) <= '9')) {
        throw new CppCodeGeneratorException(String.format("cannot convert to a class name : %s", name));
    }
    return capitalize(trimmed);
}
#method_after
static String toClassName(String name) throws CppCodeGeneratorException {
    // remove non-alphanumeric characters
    String trimmed = name.replaceAll("[^A-Za-z0-9]", "");
    if (trimmed.isEmpty() || Character.isDigit(trimmed.charAt(0))) {
        throw new CppCodeGeneratorException(String.format("cannot convert to a class name : %s", name));
    }
    return capitalize(trimmed);
}
#end_block

#method_before
static String toEnumName(String name) throws CppCodeGeneratorException {
    String trimmed = name.replace(".", "_").replaceAll("[^A-Za-z0-9_]", "");
    if (trimmed.isEmpty()) {
        throw new CppCodeGeneratorException(String.format("cannot convert to a variable name : %s", name));
    }
    String enumName = (trimmed.charAt(0) >= '0' && trimmed.charAt(0) <= '9') ? "_" + trimmed : trimmed;
    return (keywordSet.contains(trimmed)) ? "_" + enumName : enumName;
}
#method_after
static String toEnumName(String name) throws CppCodeGeneratorException {
    String trimmed = name.replace(".", "_").replaceAll("[^A-Za-z0-9_]", "");
    if (trimmed.isEmpty()) {
        throw new CppCodeGeneratorException(String.format("cannot convert to a variable name : %s", name));
    }
    String enumName = Character.isDigit(trimmed.charAt(0)) ? "_" + trimmed : trimmed;
    return (keywordSet.contains(trimmed)) ? "_" + enumName : enumName;
}
#end_block

#method_before
static String toVariableName(String name) throws JavaCodeGeneratorException {
    // remove non-alphanumeric and non-underscore characters
    String trimmed = name.replaceAll("[^A-Za-z0-9_]", "");
    if (trimmed.isEmpty()) {
        throw new JavaCodeGeneratorException(String.format("cannot convert to a variable name : %s", name));
    }
    String lowered = (trimmed.charAt(0) >= '0' && trimmed.charAt(0) <= '9') ? "_" + trimmed : lowerize(trimmed);
    // always starts with a lowercase or underscore character.
    return (keywordSet.contains(trimmed)) ? "_" + lowered : lowered;
}
#method_after
static String toVariableName(String name) throws JavaCodeGeneratorException {
    // remove non-alphanumeric and non-underscore characters
    String trimmed = name.replaceAll("[^A-Za-z0-9_]", "");
    if (trimmed.isEmpty()) {
        throw new JavaCodeGeneratorException(String.format("cannot convert to a variable name : %s", name));
    }
    String lowered = Character.isDigit(trimmed.charAt(0)) ? "_" + trimmed : lowerize(trimmed);
    // always starts with a lowercase or underscore character.
    return (keywordSet.contains(trimmed)) ? "_" + lowered : lowered;
}
#end_block

#method_before
static String toClassName(String name) throws JavaCodeGeneratorException {
    // remove non-alphanumeric characters
    String trimmed = name.replaceAll("[^A-Za-z0-9]", "");
    if (trimmed.isEmpty() || (trimmed.charAt(0) >= '0' && trimmed.charAt(0) <= '9')) {
        throw new JavaCodeGeneratorException(String.format("cannot convert to a class name : %s", name));
    }
    return capitalize(trimmed);
}
#method_after
static String toClassName(String name) throws JavaCodeGeneratorException {
    // remove non-alphanumeric characters
    String trimmed = name.replaceAll("[^A-Za-z0-9]", "");
    if (trimmed.isEmpty() || Character.isDigit(trimmed.charAt(0))) {
        throw new JavaCodeGeneratorException(String.format("cannot convert to a class name : %s", name));
    }
    return capitalize(trimmed);
}
#end_block

#method_before
static String toEnumName(String name) throws JavaCodeGeneratorException {
    String trimmed = name.replace(".", "_").replaceAll("[^A-Za-z0-9_]", "");
    if (trimmed.isEmpty()) {
        throw new JavaCodeGeneratorException(String.format("cannot convert to a variable name : %s", name));
    }
    String enumName = (trimmed.charAt(0) >= '0' && trimmed.charAt(0) <= '9') ? "_" + trimmed : trimmed;
    return (keywordSet.contains(trimmed)) ? "_" + enumName : enumName;
}
#method_after
static String toEnumName(String name) throws JavaCodeGeneratorException {
    String trimmed = name.replace(".", "_").replaceAll("[^A-Za-z0-9_]", "");
    if (trimmed.isEmpty()) {
        throw new JavaCodeGeneratorException(String.format("cannot convert to a variable name : %s", name));
    }
    String enumName = Character.isDigit(trimmed.charAt(0)) ? "_" + trimmed : trimmed;
    return (keywordSet.contains(trimmed)) ? "_" + enumName : enumName;
}
#end_block

#method_before
@Override
public void onStartInputView(EditorInfo editorInfo, boolean reastarting) {
    super.onStartInputView(editorInfo, reastarting);
    mEditorInfo = editorInfo;
    mKeyboardView.setKeyboard(mQweKeyboard, getLocale());
    mKeyboardWrapper.setPadding(0, getResources().getDimensionPixelSize(R.dimen.keyboard_padding_vertical), 0, 0);
    mKeyboardView.setOnKeyboardActionListener(mKeyboardActionListener);
    mPopupKeyboardView.setOnKeyboardActionListener(mPopupKeyboardActionListener);
    mKeyboardView.setShifted(mKeyboardView.isShifted());
    updateCapitalization();
}
#method_after
@Override
public void onStartInputView(EditorInfo editorInfo, boolean reastarting) {
    super.onStartInputView(editorInfo, reastarting);
    mEditorInfo = editorInfo;
    mKeyboardView.setKeyboard(mQweKeyboard, getLocale());
    mKeyboardWrapper.setPadding(0, getResources().getDimensionPixelSize(R.dimen.keyboard_padding_vertical), 0, 0);
    mKeyboardView.setOnKeyboardActionListener(mKeyboardActionListener);
    mPopupKeyboardView.setOnKeyboardActionListener(mPopupKeyboardActionListener);
    mKeyboardView.setShifted(mEditorInfo.initialCapsMode != 0);
}
#end_block

#method_before
private void updateCapitalization() {
    InputConnection inputConnection = getCurrentInputConnection();
    if (inputConnection != null) {
        boolean shouldCapitalize = inputConnection.getCursorCapsMode(mEditorInfo.inputType) != 0;
        mKeyboardView.setShifted(shouldCapitalize);
    }
}
#method_after
private void updateCapitalization() {
    boolean shouldCapitalize = getCurrentInputConnection().getCursorCapsMode(mEditorInfo.inputType) != 0;
    mKeyboardView.setShifted(shouldCapitalize);
}
#end_block

#method_before
public Event getNextEvent() throws IOException {
    Event e = null;
    while (e == null && mReader.peek() != JsonToken.END_DOCUMENT) {
        Event.Builder eb = new Event.Builder();
        try {
            mReader.beginObject();
            while (mReader.hasNext()) {
                String name = mReader.nextName();
                switch(name) {
                    case "id":
                        eb.setId(readInt());
                        break;
                    case "command":
                        eb.setCommand(mReader.nextString());
                        break;
                    case "descriptor":
                        eb.setDescriptor(readData());
                        break;
                    case "name":
                        eb.setName(mReader.nextString());
                        break;
                    case "vid":
                        eb.setVid(readInt());
                        break;
                    case "pid":
                        eb.setPid(readInt());
                        break;
                    case "report":
                        eb.setReport(readData());
                        break;
                    case "feature_reports":
                        try {
                            mReader.beginArray();
                            while (mReader.hasNext()) {
                                eb.addFeatureReport(readData());
                            }
                            mReader.endArray();
                        } catch (IllegalStateException | NumberFormatException e1) {
                            consumeRemainingElements();
                            mReader.endArray();
                            throw new IllegalStateException("Encountered malformed data.", e1);
                        }
                        break;
                    case "duration":
                        eb.setDuration(readInt());
                        break;
                    default:
                        mReader.skipValue();
                }
            }
            mReader.endObject();
        } catch (IllegalStateException ex) {
            error("Error reading in object, ignoring.", ex);
            consumeRemainingElements();
            mReader.endObject();
            continue;
        }
        e = eb.build();
    }
    return e;
}
#method_after
public Event getNextEvent() throws IOException {
    Event e = null;
    while (e == null && mReader.peek() != JsonToken.END_DOCUMENT) {
        Event.Builder eb = new Event.Builder();
        try {
            mReader.beginObject();
            while (mReader.hasNext()) {
                String name = mReader.nextName();
                switch(name) {
                    case "id":
                        eb.setId(readInt());
                        break;
                    case "command":
                        eb.setCommand(mReader.nextString());
                        break;
                    case "descriptor":
                        eb.setDescriptor(readData());
                        break;
                    case "name":
                        eb.setName(mReader.nextString());
                        break;
                    case "vid":
                        eb.setVid(readInt());
                        break;
                    case "pid":
                        eb.setPid(readInt());
                        break;
                    case "report":
                        eb.setReport(readData());
                        break;
                    case "feature_reports":
                        eb.setFeatureReports(readFeatureReports());
                        break;
                    case "duration":
                        eb.setDuration(readInt());
                        break;
                    default:
                        mReader.skipValue();
                }
            }
            mReader.endObject();
        } catch (IllegalStateException ex) {
            error("Error reading in object, ignoring.", ex);
            consumeRemainingElements();
            mReader.endObject();
            continue;
        }
        e = eb.build();
    }
    return e;
}
#end_block

#method_before
@Override
public void handleMessage(Message msg) {
    switch(msg.what) {
        case MSG_OPEN_DEVICE:
            SomeArgs args = (SomeArgs) msg.obj;
            mPtr = nativeOpenDevice((String) args.arg1, args.argi1, args.argi2, args.argi3, (byte[]) args.arg2, new DeviceCallback());
            pauseEvents();
            break;
        case MSG_SEND_REPORT:
            if (mPtr != 0) {
                nativeSendReport(mPtr, (byte[]) msg.obj);
            } else {
                Log.e(TAG, "Tried to send report to closed device.");
            }
            break;
        case MSG_SEND_GET_FEATURE_REPORT_REPLY:
            if (mPtr != 0) {
                nativeSendGetFeatureReportReply(mPtr, msg.arg1, msg.arg2, (byte[]) msg.obj);
            } else {
                Log.e(TAG, "Tried to send feature report reply to closed device.");
            }
            break;
        case MSG_CLOSE_DEVICE:
            if (mPtr != 0) {
                nativeCloseDevice(mPtr);
                getLooper().quitSafely();
                mPtr = 0;
            } else {
                Log.e(TAG, "Tried to close already closed device.");
            }
            synchronized (mCond) {
                mCond.notify();
            }
            break;
        default:
            throw new IllegalArgumentException("Unknown device message");
    }
}
#method_after
@Override
public void handleMessage(Message msg) {
    switch(msg.what) {
        case MSG_OPEN_DEVICE:
            SomeArgs args = (SomeArgs) msg.obj;
            mPtr = nativeOpenDevice((String) args.arg1, args.argi1, args.argi2, args.argi3, (byte[]) args.arg2, new DeviceCallback());
            pauseEvents();
            break;
        case MSG_SEND_REPORT:
            if (mPtr != 0) {
                nativeSendReport(mPtr, (byte[]) msg.obj);
            } else {
                Log.e(TAG, "Tried to send report to closed device.");
            }
            break;
        case MSG_SEND_GET_FEATURE_REPORT_REPLY:
            if (mPtr != 0) {
                nativeSendGetFeatureReportReply(mPtr, msg.arg1, (byte[]) msg.obj);
            } else {
                Log.e(TAG, "Tried to send feature report reply to closed device.");
            }
            break;
        case MSG_CLOSE_DEVICE:
            if (mPtr != 0) {
                nativeCloseDevice(mPtr);
                getLooper().quitSafely();
                mPtr = 0;
            } else {
                Log.e(TAG, "Tried to close already closed device.");
            }
            synchronized (mCond) {
                mCond.notify();
            }
            break;
        default:
            throw new IllegalArgumentException("Unknown device message");
    }
}
#end_block

#method_before
public void onDeviceGetReport(int requestId, int reportId) {
    byte[] report = mFeatureReports.get(reportId);
    Message msg;
    if (report == null) {
        Log.e(TAG, "Requested feature report " + reportId + " is not specified");
        // Create an empty report with only one byte containing the report id.
        report = new byte[] { (byte) reportId };
        msg = mHandler.obtainMessage(MSG_SEND_GET_FEATURE_REPORT_REPLY, requestId, REQUEST_FAILURE, report);
    } else {
        msg = mHandler.obtainMessage(MSG_SEND_GET_FEATURE_REPORT_REPLY, requestId, REQUEST_SUCCESS, report);
    }
    // Message is set to asynchronous so it won't be blocked by synchronization
    // barrier during UHID_OPEN. This is necessary for drivers that do
    // UHID_GET_REPORT requests during probe.
    msg.setAsynchronous(true);
    mHandler.sendMessageAtTime(msg, mTimeToSend);
}
#method_after
public void onDeviceGetReport(int requestId, int reportId) {
    byte[] report = mFeatureReports.get(reportId);
    if (report == null) {
        Log.e(TAG, "Requested feature report " + reportId + " is not specified");
    }
    Message msg;
    msg = mHandler.obtainMessage(MSG_SEND_GET_FEATURE_REPORT_REPLY, requestId, 0, report);
    // Message is set to asynchronous so it won't be blocked by synchronization
    // barrier during UHID_OPEN. This is necessary for drivers that do
    // UHID_GET_REPORT requests during probe.
    msg.setAsynchronous(true);
    mHandler.sendMessageAtTime(msg, mTimeToSend);
}
#end_block

#method_before
public void deleteNotificationChannel(String channelId) {
    if (Build.VERSION.SDK_INT >= 26) {
        mNotificationManager.deleteNotificationChannel(channelId);
    }
}
#method_after
public void deleteNotificationChannel(@NonNull String channelId) {
    if (Build.VERSION.SDK_INT >= 26) {
        mNotificationManager.deleteNotificationChannel(channelId);
    }
}
#end_block

#method_before
public void deleteNotificationChannelGroup(String groupId) {
    if (Build.VERSION.SDK_INT >= 26) {
        mNotificationManager.deleteNotificationChannelGroup(groupId);
    }
}
#method_after
public void deleteNotificationChannelGroup(@NonNull String groupId) {
    if (Build.VERSION.SDK_INT >= 26) {
        mNotificationManager.deleteNotificationChannelGroup(groupId);
    }
}
#end_block

#method_before
@Nullable
public NotificationChannel getNotificationChannel(String channelId) {
    if (Build.VERSION.SDK_INT >= 26) {
        return mNotificationManager.getNotificationChannel(channelId);
    }
    return null;
}
#method_after
@Nullable
public NotificationChannel getNotificationChannel(@NonNull String channelId) {
    if (Build.VERSION.SDK_INT >= 26) {
        return mNotificationManager.getNotificationChannel(channelId);
    }
    return null;
}
#end_block

#method_before
@Nullable
public NotificationChannelGroup getNotificationChannelGroup(String channelGroupId) {
    if (Build.VERSION.SDK_INT >= 28) {
        return mNotificationManager.getNotificationChannelGroup(channelGroupId);
    } else if (Build.VERSION.SDK_INT >= 26) {
        // find the group in list by its ID
        for (NotificationChannelGroup group : getNotificationChannelGroups()) {
            if (group.getId().equals(channelGroupId))
                return group;
        }
        // requested group doesn't exist
        return null;
    } else {
        return null;
    }
}
#method_after
@Nullable
public NotificationChannelGroup getNotificationChannelGroup(@NonNull String channelGroupId) {
    if (Build.VERSION.SDK_INT >= 28) {
        return mNotificationManager.getNotificationChannelGroup(channelGroupId);
    } else if (Build.VERSION.SDK_INT >= 26) {
        // find the group in list by its ID
        for (NotificationChannelGroup group : getNotificationChannelGroups()) {
            if (group.getId().equals(channelGroupId))
                return group;
        }
        // requested group doesn't exist
        return null;
    } else {
        return null;
    }
}
#end_block

#method_before
public List<NotificationChannel> getNotificationChannels() {
    if (Build.VERSION.SDK_INT >= 26) {
        return mNotificationManager.getNotificationChannels();
    }
    return Collections.emptyList();
}
#method_after
@NonNull
public List<NotificationChannel> getNotificationChannels() {
    if (Build.VERSION.SDK_INT >= 26) {
        return mNotificationManager.getNotificationChannels();
    }
    return Collections.emptyList();
}
#end_block

#method_before
public List<NotificationChannelGroup> getNotificationChannelGroups() {
    if (Build.VERSION.SDK_INT >= 26) {
        return mNotificationManager.getNotificationChannelGroups();
    }
    return Collections.emptyList();
}
#method_after
@NonNull
public List<NotificationChannelGroup> getNotificationChannelGroups() {
    if (Build.VERSION.SDK_INT >= 26) {
        return mNotificationManager.getNotificationChannelGroups();
    }
    return Collections.emptyList();
}
#end_block

#method_before
@SdkSuppress(minSdkVersion = 26)
@Test
public void testCreateNotificationChannelGroups() {
    String groupOneId = genUniqueId(TYPE_GROUP);
    String channelGroupOneId = genUniqueId(TYPE_CHANNEL);
    NotificationChannelGroup groupOne = new NotificationChannelGroup(groupOneId, "groupOneName");
    NotificationChannel channelGroupOne = new NotificationChannel(channelGroupOneId, "channelGroupOneName", NotificationManagerCompat.IMPORTANCE_NONE);
    channelGroupOne.setGroup(groupOneId);
    String channelGroupTwoId = genUniqueId(TYPE_CHANNEL);
    String secondChannelGroupTwoId = genUniqueId(TYPE_CHANNEL);
    NotificationChannelGroup groupTwo = new NotificationChannelGroup(genUniqueId(TYPE_GROUP), "groupTwoName");
    NotificationChannel channelGroupTwo = new NotificationChannel(channelGroupTwoId, "channelGroupTwoName", NotificationManagerCompat.IMPORTANCE_MAX);
    channelGroupTwo.setGroup(groupTwo.getId());
    NotificationChannel secondChannelGroupTwo = new NotificationChannel(secondChannelGroupTwoId, "secondChannelGroupTwoName", NotificationManagerCompat.IMPORTANCE_MAX);
    secondChannelGroupTwo.setGroup(groupTwo.getId());
    List<NotificationChannelGroup> groups = Arrays.asList(groupOne, groupTwo);
    List<NotificationChannel> channels = Arrays.asList(channelGroupOne, channelGroupTwo, secondChannelGroupTwo);
    int groupsBefore = mPlatformNotificationManager.getNotificationChannelGroups().size();
    int channelsBefore = mPlatformNotificationManager.getNotificationChannels().size();
    NotificationManagerCompat notificationManager = NotificationManagerCompat.from(mContext);
    notificationManager.createNotificationChannelGroups(groups);
    notificationManager.createNotificationChannels(channels);
    // the correct number of groups and channels was created
    assertEquals(groupsBefore + groups.size(), mPlatformNotificationManager.getNotificationChannelGroups().size());
    assertEquals(channelsBefore + channels.size(), mPlatformNotificationManager.getNotificationChannels().size());
    NotificationChannelGroup resultOne = notificationManager.getNotificationChannelGroup(groupOneId);
    assertNotNull(resultOne);
    assertEquals(groupOne.getName(), resultOne.getName());
    NotificationChannel resultChannel = mPlatformNotificationManager.getNotificationChannel(channelGroupOneId);
    assertEquals(groupOneId, resultChannel.getGroup());
    assertEquals(channelGroupOne, resultChannel);
    NotificationChannelGroup resultTwo = notificationManager.getNotificationChannelGroup(groupTwo.getId());
    assertNotNull(resultTwo);
    assertEquals(groupTwo.getName(), resultTwo.getName());
    // assertEquals(Arrays.asList(channelGroupTwo, secondChannelGroupTwo),
    // resultTwo.getChannels());
    assertTrue(mPlatformNotificationManager.getNotificationChannels().containsAll(channels));
}
#method_after
@SdkSuppress(minSdkVersion = 26)
@Test
public void testCreateNotificationChannelGroups() {
    String groupOneId = genUniqueId(TYPE_GROUP);
    String channelGroupOneId = genUniqueId(TYPE_CHANNEL);
    NotificationChannelGroup groupOne = new NotificationChannelGroup(groupOneId, "groupOneName");
    NotificationChannel channelGroupOne = new NotificationChannel(channelGroupOneId, "channelGroupOneName", NotificationManagerCompat.IMPORTANCE_MIN);
    channelGroupOne.setGroup(groupOneId);
    String channelGroupTwoId = genUniqueId(TYPE_CHANNEL);
    String secondChannelGroupTwoId = genUniqueId(TYPE_CHANNEL);
    NotificationChannelGroup groupTwo = new NotificationChannelGroup(genUniqueId(TYPE_GROUP), "groupTwoName");
    NotificationChannel channelGroupTwo = new NotificationChannel(channelGroupTwoId, "channelGroupTwoName", NotificationManagerCompat.IMPORTANCE_DEFAULT);
    channelGroupTwo.setGroup(groupTwo.getId());
    NotificationChannel secondChannelGroupTwo = new NotificationChannel(secondChannelGroupTwoId, "secondChannelGroupTwoName", NotificationManagerCompat.IMPORTANCE_MAX);
    secondChannelGroupTwo.setGroup(groupTwo.getId());
    List<NotificationChannelGroup> groups = Arrays.asList(groupOne, groupTwo);
    List<NotificationChannel> channels = Arrays.asList(channelGroupOne, channelGroupTwo, secondChannelGroupTwo);
    int groupsBefore = mPlatformNotificationManager.getNotificationChannelGroups().size();
    int channelsBefore = mPlatformNotificationManager.getNotificationChannels().size();
    NotificationManagerCompat notificationManager = NotificationManagerCompat.from(mContext);
    notificationManager.createNotificationChannelGroups(groups);
    notificationManager.createNotificationChannels(channels);
    // the correct number of groups and channels was created
    assertEquals(groupsBefore + groups.size(), mPlatformNotificationManager.getNotificationChannelGroups().size());
    assertEquals(channelsBefore + channels.size(), mPlatformNotificationManager.getNotificationChannels().size());
    NotificationChannelGroup resultOne = notificationManager.getNotificationChannelGroup(groupOneId);
    assertNotNull(resultOne);
    assertEquals(groupOne.getName(), resultOne.getName());
    NotificationChannel resultChannel = mPlatformNotificationManager.getNotificationChannel(channelGroupOneId);
    assertEquals(groupOneId, resultChannel.getGroup());
    assertEquals(channelGroupOne, resultChannel);
    NotificationChannelGroup resultTwo = notificationManager.getNotificationChannelGroup(groupTwo.getId());
    assertNotNull(resultTwo);
    assertEquals(groupTwo.getName(), resultTwo.getName());
    // assertEquals(Arrays.asList(channelGroupTwo, secondChannelGroupTwo),
    // resultTwo.getChannels());
    assertTrue(mPlatformNotificationManager.getNotificationChannels().containsAll(channels));
}
#end_block

#method_before
private void updateTcpBufferSizes(NetworkAgentInfo nai) {
    if (isDefaultNetwork(nai) == false) {
        return;
    }
    String tcpBufferSizes = nai.linkProperties.getTcpBufferSizes();
    String[] values = null;
    if (tcpBufferSizes != null) {
        values = tcpBufferSizes.split(",");
    }
    if (values == null || values.length != 6) {
        if (DBG)
            log("Invalid tcpBufferSizes string: " + tcpBufferSizes + ", using defaults");
        tcpBufferSizes = DEFAULT_TCP_BUFFER_SIZES;
        values = tcpBufferSizes.split(",");
    }
    if (tcpBufferSizes.equals(mCurrentTcpBufferSizes))
        return;
    try {
        if (VDBG || DDBG)
            Slog.d(TAG, "Setting tx/rx TCP buffers to " + tcpBufferSizes);
        String rmemValues = values[0] + " " + values[1] + " " + values[2];
        String wmemValues = values[3] + " " + values[4] + " " + values[5];
        mNetd.setTcpRWmemorySize(rmemValues, wmemValues);
        mCurrentTcpBufferSizes = tcpBufferSizes;
    } catch (RemoteException e) {
        loge("Can't set TCP buffer sizes:" + e);
    }
    Integer rwndValue = Settings.Global.getInt(mContext.getContentResolver(), Settings.Global.TCP_DEFAULT_INIT_RWND, mSystemProperties.getInt("net.tcp.default_init_rwnd", 0));
    final String sysctlKey = "sys.sysctl.tcp_def_init_rwnd";
    if (rwndValue != 0) {
        mSystemProperties.set(sysctlKey, rwndValue.toString());
    }
}
#method_after
private void updateTcpBufferSizes(NetworkAgentInfo nai) {
    if (isDefaultNetwork(nai) == false) {
        return;
    }
    String tcpBufferSizes = nai.linkProperties.getTcpBufferSizes();
    String[] values = null;
    if (tcpBufferSizes != null) {
        values = tcpBufferSizes.split(",");
    }
    if (values == null || values.length != 6) {
        if (DBG)
            log("Invalid tcpBufferSizes string: " + tcpBufferSizes + ", using defaults");
        tcpBufferSizes = DEFAULT_TCP_BUFFER_SIZES;
        values = tcpBufferSizes.split(",");
    }
    if (tcpBufferSizes.equals(mCurrentTcpBufferSizes))
        return;
    try {
        if (VDBG || DDBG)
            Slog.d(TAG, "Setting tx/rx TCP buffers to " + tcpBufferSizes);
        String rmemValues = String.join(" ", values[0], values[1], values[2]);
        String wmemValues = String.join(" ", values[3], values[4], values[5]);
        mNetd.setTcpRWmemorySize(rmemValues, wmemValues);
        mCurrentTcpBufferSizes = tcpBufferSizes;
    } catch (RemoteException | ServiceSpecificException e) {
        loge("Can't set TCP buffer sizes:" + e);
    }
    Integer rwndValue = Settings.Global.getInt(mContext.getContentResolver(), Settings.Global.TCP_DEFAULT_INIT_RWND, mSystemProperties.getInt("net.tcp.default_init_rwnd", 0));
    final String sysctlKey = "sys.sysctl.tcp_def_init_rwnd";
    if (rwndValue != 0) {
        mSystemProperties.set(sysctlKey, rwndValue.toString());
    }
}
#end_block

#method_before
private int convertImsCodec(int c) {
    switch(c) {
        case ImsStreamMediaProfile.AUDIO_QUALITY_AMR:
            return TelephonyCallSession.Event.AudioCodec.AUDIO_QUALITY_AMR;
        case ImsStreamMediaProfile.AUDIO_QUALITY_AMR_WB:
            return TelephonyCallSession.Event.AudioCodec.AUDIO_QUALITY_AMR_WB;
        case ImsStreamMediaProfile.AUDIO_QUALITY_QCELP13K:
            return TelephonyCallSession.Event.AudioCodec.AUDIO_QUALITY_QCELP13K;
        case ImsStreamMediaProfile.AUDIO_QUALITY_EVRC:
            return TelephonyCallSession.Event.AudioCodec.AUDIO_QUALITY_EVRC;
        case ImsStreamMediaProfile.AUDIO_QUALITY_EVRC_B:
            return TelephonyCallSession.Event.AudioCodec.AUDIO_QUALITY_EVRC_B;
        case ImsStreamMediaProfile.AUDIO_QUALITY_EVRC_WB:
            return TelephonyCallSession.Event.AudioCodec.AUDIO_QUALITY_EVRC_WB;
        case ImsStreamMediaProfile.AUDIO_QUALITY_EVRC_NW:
            return TelephonyCallSession.Event.AudioCodec.AUDIO_QUALITY_EVRC_NW;
        case ImsStreamMediaProfile.AUDIO_QUALITY_GSM_EFR:
            return TelephonyCallSession.Event.AudioCodec.AUDIO_QUALITY_GSM_EFR;
        case ImsStreamMediaProfile.AUDIO_QUALITY_GSM_FR:
            return TelephonyCallSession.Event.AudioCodec.AUDIO_QUALITY_GSM_FR;
        case ImsStreamMediaProfile.AUDIO_QUALITY_GSM_HR:
            return TelephonyCallSession.Event.AudioCodec.AUDIO_QUALITY_GSM_HR;
        case ImsStreamMediaProfile.AUDIO_QUALITY_G711U:
            return TelephonyCallSession.Event.AudioCodec.AUDIO_QUALITY_G711U;
        case ImsStreamMediaProfile.AUDIO_QUALITY_G723:
            return TelephonyCallSession.Event.AudioCodec.AUDIO_QUALITY_G723;
        case ImsStreamMediaProfile.AUDIO_QUALITY_G711A:
            return TelephonyCallSession.Event.AudioCodec.AUDIO_QUALITY_G711A;
        case ImsStreamMediaProfile.AUDIO_QUALITY_G722:
            return TelephonyCallSession.Event.AudioCodec.AUDIO_QUALITY_G722;
        case ImsStreamMediaProfile.AUDIO_QUALITY_G711AB:
            return TelephonyCallSession.Event.AudioCodec.AUDIO_QUALITY_G711AB;
        case ImsStreamMediaProfile.AUDIO_QUALITY_G729:
            return TelephonyCallSession.Event.AudioCodec.AUDIO_QUALITY_G729;
        case ImsStreamMediaProfile.AUDIO_QUALITY_EVS_NB:
            return TelephonyCallSession.Event.AudioCodec.AUDIO_QUALITY_EVS_NB;
        case ImsStreamMediaProfile.AUDIO_QUALITY_EVS_WB:
            return TelephonyCallSession.Event.AudioCodec.AUDIO_QUALITY_EVS_WB;
        case ImsStreamMediaProfile.AUDIO_QUALITY_EVS_SWB:
            return TelephonyCallSession.Event.AudioCodec.AUDIO_QUALITY_EVS_SWB;
        case ImsStreamMediaProfile.AUDIO_QUALITY_EVS_FB:
            return TelephonyCallSession.Event.AudioCodec.AUDIO_QUALITY_EVS_FB;
        default:
            return TelephonyCallSession.Event.AudioCodec.AUDIO_CODEC_UNKNOWN;
    }
}
#method_after
private int convertImsCodec(int c) {
    switch(c) {
        case ImsStreamMediaProfile.AUDIO_QUALITY_AMR:
            return TelephonyCallSession.Event.AudioCodec.AUDIO_CODEC_AMR;
        case ImsStreamMediaProfile.AUDIO_QUALITY_AMR_WB:
            return TelephonyCallSession.Event.AudioCodec.AUDIO_CODEC_AMR_WB;
        case ImsStreamMediaProfile.AUDIO_QUALITY_QCELP13K:
            return TelephonyCallSession.Event.AudioCodec.AUDIO_CODEC_QCELP13K;
        case ImsStreamMediaProfile.AUDIO_QUALITY_EVRC:
            return TelephonyCallSession.Event.AudioCodec.AUDIO_CODEC_EVRC;
        case ImsStreamMediaProfile.AUDIO_QUALITY_EVRC_B:
            return TelephonyCallSession.Event.AudioCodec.AUDIO_CODEC_EVRC_B;
        case ImsStreamMediaProfile.AUDIO_QUALITY_EVRC_WB:
            return TelephonyCallSession.Event.AudioCodec.AUDIO_CODEC_EVRC_WB;
        case ImsStreamMediaProfile.AUDIO_QUALITY_EVRC_NW:
            return TelephonyCallSession.Event.AudioCodec.AUDIO_CODEC_EVRC_NW;
        case ImsStreamMediaProfile.AUDIO_QUALITY_GSM_EFR:
            return TelephonyCallSession.Event.AudioCodec.AUDIO_CODEC_GSM_EFR;
        case ImsStreamMediaProfile.AUDIO_QUALITY_GSM_FR:
            return TelephonyCallSession.Event.AudioCodec.AUDIO_CODEC_GSM_FR;
        case ImsStreamMediaProfile.AUDIO_QUALITY_GSM_HR:
            return TelephonyCallSession.Event.AudioCodec.AUDIO_CODEC_GSM_HR;
        case ImsStreamMediaProfile.AUDIO_QUALITY_G711U:
            return TelephonyCallSession.Event.AudioCodec.AUDIO_CODEC_G711U;
        case ImsStreamMediaProfile.AUDIO_QUALITY_G723:
            return TelephonyCallSession.Event.AudioCodec.AUDIO_CODEC_G723;
        case ImsStreamMediaProfile.AUDIO_QUALITY_G711A:
            return TelephonyCallSession.Event.AudioCodec.AUDIO_CODEC_G711A;
        case ImsStreamMediaProfile.AUDIO_QUALITY_G722:
            return TelephonyCallSession.Event.AudioCodec.AUDIO_CODEC_G722;
        case ImsStreamMediaProfile.AUDIO_QUALITY_G711AB:
            return TelephonyCallSession.Event.AudioCodec.AUDIO_CODEC_G711AB;
        case ImsStreamMediaProfile.AUDIO_QUALITY_G729:
            return TelephonyCallSession.Event.AudioCodec.AUDIO_CODEC_G729;
        case ImsStreamMediaProfile.AUDIO_QUALITY_EVS_NB:
            return TelephonyCallSession.Event.AudioCodec.AUDIO_CODEC_EVS_NB;
        case ImsStreamMediaProfile.AUDIO_QUALITY_EVS_WB:
            return TelephonyCallSession.Event.AudioCodec.AUDIO_CODEC_EVS_WB;
        case ImsStreamMediaProfile.AUDIO_QUALITY_EVS_SWB:
            return TelephonyCallSession.Event.AudioCodec.AUDIO_CODEC_EVS_SWB;
        case ImsStreamMediaProfile.AUDIO_QUALITY_EVS_FB:
            return TelephonyCallSession.Event.AudioCodec.AUDIO_CODEC_EVS_FB;
        default:
            return TelephonyCallSession.Event.AudioCodec.AUDIO_CODEC_UNKNOWN;
    }
}
#end_block

#method_before
private int convertGsmCdmaCodec(int c) {
    switch(c) {
        case DriverCall.AUDIO_QUALITY_AMR:
            return TelephonyCallSession.Event.AudioCodec.AUDIO_QUALITY_AMR;
        case DriverCall.AUDIO_QUALITY_AMR_WB:
            return TelephonyCallSession.Event.AudioCodec.AUDIO_QUALITY_AMR_WB;
        case DriverCall.AUDIO_QUALITY_GSM_EFR:
            return TelephonyCallSession.Event.AudioCodec.AUDIO_QUALITY_GSM_EFR;
        case DriverCall.AUDIO_QUALITY_GSM_FR:
            return TelephonyCallSession.Event.AudioCodec.AUDIO_QUALITY_GSM_FR;
        case DriverCall.AUDIO_QUALITY_GSM_HR:
            return TelephonyCallSession.Event.AudioCodec.AUDIO_QUALITY_GSM_HR;
        case DriverCall.AUDIO_QUALITY_EVRC:
            return TelephonyCallSession.Event.AudioCodec.AUDIO_QUALITY_EVRC;
        case DriverCall.AUDIO_QUALITY_EVRC_B:
            return TelephonyCallSession.Event.AudioCodec.AUDIO_QUALITY_EVRC_B;
        case DriverCall.AUDIO_QUALITY_EVRC_WB:
            return TelephonyCallSession.Event.AudioCodec.AUDIO_QUALITY_EVRC_WB;
        case DriverCall.AUDIO_QUALITY_EVRC_NW:
            return TelephonyCallSession.Event.AudioCodec.AUDIO_QUALITY_EVRC_NW;
        default:
            return TelephonyCallSession.Event.AudioCodec.AUDIO_CODEC_UNKNOWN;
    }
}
#method_after
private int convertGsmCdmaCodec(int c) {
    switch(c) {
        case DriverCall.AUDIO_QUALITY_AMR:
            return TelephonyCallSession.Event.AudioCodec.AUDIO_CODEC_AMR;
        case DriverCall.AUDIO_QUALITY_AMR_WB:
            return TelephonyCallSession.Event.AudioCodec.AUDIO_CODEC_AMR_WB;
        case DriverCall.AUDIO_QUALITY_GSM_EFR:
            return TelephonyCallSession.Event.AudioCodec.AUDIO_CODEC_GSM_EFR;
        case DriverCall.AUDIO_QUALITY_GSM_FR:
            return TelephonyCallSession.Event.AudioCodec.AUDIO_CODEC_GSM_FR;
        case DriverCall.AUDIO_QUALITY_GSM_HR:
            return TelephonyCallSession.Event.AudioCodec.AUDIO_CODEC_GSM_HR;
        case DriverCall.AUDIO_QUALITY_EVRC:
            return TelephonyCallSession.Event.AudioCodec.AUDIO_CODEC_EVRC;
        case DriverCall.AUDIO_QUALITY_EVRC_B:
            return TelephonyCallSession.Event.AudioCodec.AUDIO_CODEC_EVRC_B;
        case DriverCall.AUDIO_QUALITY_EVRC_WB:
            return TelephonyCallSession.Event.AudioCodec.AUDIO_CODEC_EVRC_WB;
        case DriverCall.AUDIO_QUALITY_EVRC_NW:
            return TelephonyCallSession.Event.AudioCodec.AUDIO_CODEC_EVRC_NW;
        default:
            return TelephonyCallSession.Event.AudioCodec.AUDIO_CODEC_UNKNOWN;
    }
}
#end_block

#method_before
private void checkEglDrawError(String msg) throws LegacyExceptionUtils.BufferQueueAbandonedException {
    int error;
    if ((error = EGL14.eglGetError()) == EGL14.EGL_BAD_NATIVE_WINDOW) {
        Log.d(TAG, "workaround for EGL_BAD_NATIVE_WINDOW");
        throw new LegacyExceptionUtils.BufferQueueAbandonedException();
    }
    if ((error = EGL14.eglGetError()) != EGL14.EGL_SUCCESS) {
        throw new IllegalStateException(msg + ": EGL error: 0x" + Integer.toHexString(error));
    }
}
#method_after
private void checkEglDrawError(String msg) throws LegacyExceptionUtils.BufferQueueAbandonedException {
    int error;
    if ((error = EGL14.eglGetError()) == EGL14.EGL_BAD_NATIVE_WINDOW) {
        throw new LegacyExceptionUtils.BufferQueueAbandonedException();
    }
    if ((error = EGL14.eglGetError()) != EGL14.EGL_SUCCESS) {
        throw new IllegalStateException(msg + ": EGL error: 0x" + Integer.toHexString(error));
    }
}
#end_block

#method_before
private void connectToSession() {
    IMediaSession iSession = IMediaSession.Stub.asInterface((IBinder) mToken.getBinder());
    int seq = mSequencedFutureManager.obtainNextSequenceNumber();
    ConnectionRequest request = new ConnectionRequest(mContext.getPackageName());
    try {
        iSession.connect(mControllerStub, seq, MediaUtils.toParcelable(request));
    } catch (RemoteException e) {
        Log.w(TAG, "Failed to call connection request. Framework will retry" + " automatically");
    }
}
#method_after
private void connectToSession() {
    IMediaSession iSession = IMediaSession.Stub.asInterface((IBinder) mToken.getBinder());
    int seq = mSequencedFutureManager.obtainNextSequenceNumber();
    ConnectionRequest request = new ConnectionRequest(mContext.getPackageName(), Process.myPid());
    try {
        iSession.connect(mControllerStub, seq, MediaUtils.toParcelable(request));
    } catch (RemoteException e) {
        Log.w(TAG, "Failed to call connection request. Framework will retry" + " automatically");
    }
}
#end_block

#method_before
@Override
public void onServiceConnected(ComponentName name, IBinder service) {
    // Note that it's always main-thread.
    if (DEBUG) {
        Log.d(TAG, "onServiceConnected " + name + " " + this);
    }
    // Sanity check
    if (!mToken.getPackageName().equals(name.getPackageName())) {
        Log.wtf(TAG, "Expected connection to " + mToken.getPackageName() + " but is" + " connected to " + name);
        return;
    }
    IMediaSessionService iService = IMediaSessionService.Stub.asInterface(service);
    if (iService == null) {
        Log.wtf(TAG, "Service interface is missing.");
        return;
    }
    ConnectionRequest request = new ConnectionRequest(getContext().getPackageName());
    try {
        iService.connect(mControllerStub, MediaUtils.toParcelable(request));
    } catch (RemoteException e) {
        Log.w(TAG, "Service " + name + " has died prematurely");
        mInstance.close();
    }
}
#method_after
@Override
public void onServiceConnected(ComponentName name, IBinder service) {
    // Note that it's always main-thread.
    if (DEBUG) {
        Log.d(TAG, "onServiceConnected " + name + " " + this);
    }
    // Sanity check
    if (!mToken.getPackageName().equals(name.getPackageName())) {
        Log.wtf(TAG, "Expected connection to " + mToken.getPackageName() + " but is" + " connected to " + name);
        return;
    }
    IMediaSessionService iService = IMediaSessionService.Stub.asInterface(service);
    if (iService == null) {
        Log.wtf(TAG, "Service interface is missing.");
        return;
    }
    ConnectionRequest request = new ConnectionRequest(getContext().getPackageName(), Process.myPid());
    try {
        iService.connect(mControllerStub, MediaUtils.toParcelable(request));
    } catch (RemoteException e) {
        Log.w(TAG, "Service " + name + " has died prematurely");
        mInstance.close();
    }
}
#end_block

#method_before
// ////////////////////////////////////////////////////////////////////////////////////////////
// AIDL methods for session overrides
// ////////////////////////////////////////////////////////////////////////////////////////////
@Override
public void connect(final IMediaController caller, int seq, ParcelImpl connectionRequest) throws RuntimeException {
    if (caller == null || connectionRequest == null) {
        return;
    }
    final int pid = Binder.getCallingPid();
    final int uid = Binder.getCallingUid();
    final long token = Binder.clearCallingIdentity();
    final ConnectionRequest request = MediaUtils.fromParcelable(connectionRequest);
    try {
        connect(caller, request.getPackageName(), pid, uid);
    } finally {
        Binder.restoreCallingIdentity(token);
    }
}
#method_after
// ////////////////////////////////////////////////////////////////////////////////////////////
// AIDL methods for session overrides
// ////////////////////////////////////////////////////////////////////////////////////////////
@Override
public void connect(final IMediaController caller, int seq, ParcelImpl connectionRequest) throws RuntimeException {
    if (caller == null || connectionRequest == null) {
        return;
    }
    final int uid = Binder.getCallingUid();
    final int callingPid = Binder.getCallingPid();
    final long token = Binder.clearCallingIdentity();
    final ConnectionRequest request = MediaUtils.fromParcelable(connectionRequest);
    // Binder.getCallingPid() can be 0 for an oneway call from the remote process.
    // If it's the case, use PID from the ConnectionRequest.
    final int pid = (callingPid != 0) ? callingPid : request.getPid();
    try {
        connect(caller, request.getPackageName(), pid, uid);
    } finally {
        Binder.restoreCallingIdentity(token);
    }
}
#end_block

#method_before
@NonNull
public CommandButton build() {
    return new CommandButton(mCommand, mIconResId, mDisplayName, mExtras, mEnabled);
}
#method_after
@Override
@NonNull
public MediaSession build() {
    if (mCallbackExecutor == null) {
        mCallbackExecutor = ContextCompat.getMainExecutor(mContext);
    }
    if (mCallback == null) {
        mCallback = new SessionCallback() {
        };
    }
    return new MediaSession(mContext, mId, mPlayer, mSessionActivity, mCallbackExecutor, mCallback);
}
#end_block

#method_before
/**
 * This should remain functionally equivalent to
 * android.webkit.cts.PostMessageTest#testMessageChannel. Modifications to this test should be
 * reflected in that test as necessary. See http://go/modifying-webview-cts.
 */
@Test
public void testMessageChannel() throws Throwable {
    WebkitUtils.checkFeature(WebViewFeature.CREATE_WEB_MESSAGE_CHANNEL);
    WebkitUtils.checkFeature(WebViewFeature.POST_WEB_MESSAGE);
    WebkitUtils.checkFeature(WebViewFeature.WEB_MESSAGE_PORT_POST_MESSAGE);
    WebkitUtils.checkFeature(WebViewFeature.WEB_MESSAGE_PORT_SET_MESSAGE_CALLBACK);
    loadPage(CHANNEL_MESSAGE);
    final WebMessagePortCompat[] channel = mOnUiThread.createWebMessageChannelCompat();
    WebMessageCompat message = new WebMessageCompat(WEBVIEW_MESSAGE, new WebMessagePortCompat[] { channel[1] });
    mOnUiThread.postWebMessageCompat(message, Uri.parse(BASE_URI));
    final int messageCount = 3;
    final WebkitUtils.FutureFactory<String> futureFactory = new WebkitUtils.FutureFactory<>(messageCount);
    InstrumentationRegistry.getInstrumentation().runOnMainSync(new Runnable() {

        @Override
        public void run() {
            for (int i = 0; i < messageCount; i++) {
                channel[0].postMessage(new WebMessageCompat(WEBVIEW_MESSAGE + i));
            }
            channel[0].setWebMessageCallback(new WebMessageCallbackCompat() {

                @Override
                public void onMessage(@NonNull WebMessagePortCompat port, WebMessageCompat message) {
                    ResolvableFuture<String> future = futureFactory.getNewFuture();
                    future.set(message.getData());
                }
            });
        }
    });
    // Wait for all the responses to arrive.
    List<ResolvableFuture<String>> futures = futureFactory.getAllCreatedFutures();
    int i = 0;
    for (ResolvableFuture<String> future : futures) {
        // The JavaScript code simply appends an integer counter to the end of the message it
        // receives, which is why we have a second i on the end.
        String expectedMessageFromJavascript = WEBVIEW_MESSAGE + i + "" + i;
        Assert.assertEquals(expectedMessageFromJavascript, WebkitUtils.waitForFuture(future));
        i++;
    }
}
#method_after
/**
 * This should remain functionally equivalent to
 * android.webkit.cts.PostMessageTest#testMessageChannel. Modifications to this test should be
 * reflected in that test as necessary. See http://go/modifying-webview-cts.
 */
@Test
public void testMessageChannel() throws Throwable {
    WebkitUtils.checkFeature(WebViewFeature.CREATE_WEB_MESSAGE_CHANNEL);
    WebkitUtils.checkFeature(WebViewFeature.POST_WEB_MESSAGE);
    WebkitUtils.checkFeature(WebViewFeature.WEB_MESSAGE_PORT_POST_MESSAGE);
    WebkitUtils.checkFeature(WebViewFeature.WEB_MESSAGE_PORT_SET_MESSAGE_CALLBACK);
    loadPage(CHANNEL_MESSAGE);
    final WebMessagePortCompat[] channel = mOnUiThread.createWebMessageChannelCompat();
    WebMessageCompat message = new WebMessageCompat(WEBVIEW_MESSAGE, new WebMessagePortCompat[] { channel[1] });
    mOnUiThread.postWebMessageCompat(message, Uri.parse(BASE_URI));
    final int messageCount = 3;
    final BlockingQueue<String> queue = new ArrayBlockingQueue<>(messageCount);
    InstrumentationRegistry.getInstrumentation().runOnMainSync(new Runnable() {

        @Override
        public void run() {
            for (int i = 0; i < messageCount; i++) {
                channel[0].postMessage(new WebMessageCompat(WEBVIEW_MESSAGE + i));
            }
            channel[0].setWebMessageCallback(new WebMessageCallbackCompat() {

                @Override
                public void onMessage(@NonNull WebMessagePortCompat port, WebMessageCompat message) {
                    queue.add(message.getData());
                }
            });
        }
    });
    // Wait for all the responses to arrive.
    for (int i = 0; i < messageCount; i++) {
        // The JavaScript code simply appends an integer counter to the end of the message it
        // receives, which is why we have a second i on the end.
        String expectedMessageFromJavascript = WEBVIEW_MESSAGE + i + "" + i;
        Assert.assertEquals(expectedMessageFromJavascript, WebkitUtils.waitForNextQueueElement(queue));
    }
}
#end_block

#method_before
public static <T> T waitForFuture(Future<T> future) throws InterruptedException, ExecutionException, TimeoutException {
    return future.get(TEST_TIMEOUT_MS, TimeUnit.MILLISECONDS);
}
#method_after
public static <T> T waitForFuture(Future<T> future) throws InterruptedException, ExecutionException, TimeoutException {
    // TODO(ntfschr): consider catching ExecutionException and throwing e.getCause().
    return future.get(TEST_TIMEOUT_MS, TimeUnit.MILLISECONDS);
}
#end_block

#method_before
@Before
public void setup() throws Throwable {
    mContext = InstrumentationRegistry.getTargetContext();
    mMainHandlerExecutor = ContextCompat.getMainExecutor(mContext);
    mInstrumentation = InstrumentationRegistry.getInstrumentation();
    mActivity = mActivityRule.getActivity();
    mVideoView = mActivity.findViewById(R.id.videoview);
    mFileSchemeUri = Uri.parse("android.resource://" + mContext.getPackageName() + "/" + R.raw.test_file_scheme_video);
    mHttpsSchemeUri = Uri.parse(mContext.getResources().getString(R.string.test_https_scheme_video));
    mHttpSchemeUri = Uri.parse(mContext.getResources().getString(R.string.test_http_scheme_video));
    mFileSchemeMediaItem = createTestMediaItem2(mFileSchemeUri);
    mHttpsSchemeMediaItem = createTestMediaItem2(mHttpsSchemeUri);
    mHttpSchemeMediaItem = createTestMediaItem2(mHttpSchemeUri);
    setKeepScreenOn();
    checkAttachedToWindow();
}
#method_after
@Before
public void setup() throws Throwable {
    mContext = InstrumentationRegistry.getTargetContext();
    mMainHandlerExecutor = ContextCompat.getMainExecutor(mContext);
    mInstrumentation = InstrumentationRegistry.getInstrumentation();
    mActivity = mActivityRule.getActivity();
    mVideoView = mActivity.findViewById(R.id.videoview);
    mFileSchemeUri = Uri.parse("android.resource://" + mContext.getPackageName() + "/" + R.raw.test_file_scheme_video);
    mFileSchemeMediaItem = createTestMediaItem2(mFileSchemeUri);
    setKeepScreenOn();
    checkAttachedToWindow();
}
#end_block

#method_before
@VisibleForTesting
boolean isCurrentMediaItemFromNetwork() {
    MediaItem currentMediaItem = mController.getCurrentMediaItem();
    if (currentMediaItem == null) {
        return false;
    }
    if (!(currentMediaItem instanceof UriMediaItem)) {
        return false;
    }
    Uri uri = ((UriMediaItem) currentMediaItem).getUri();
    String scheme = uri.getScheme();
    if (scheme == null) {
        return false;
    }
    return scheme.equals("http") || scheme.equals("https") || scheme.equals("rtsp");
}
#method_after
@VisibleForTesting
boolean isCurrentMediaItemFromNetwork() {
    MediaItem currentMediaItem = mController.getCurrentMediaItem();
    if (!(currentMediaItem instanceof UriMediaItem)) {
        return false;
    }
    Uri uri = ((UriMediaItem) currentMediaItem).getUri();
    return UriUtil.isFromNetwork(uri);
}
#end_block

#method_before
@Override
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    // Desired height should be the height constraint for all child views.
    int desiredHeight = getPaddingTop() + getSuggestedMinimumHeight() + getPaddingBottom();
    int childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(desiredHeight, MeasureSpec.AT_MOST);
    int width = 0;
    if (mNavButtonView.getVisibility() != GONE) {
        // Size of nav button is fixed.
        int measureSpec = MeasureSpec.makeMeasureSpec(mNavButtonIconSize, MeasureSpec.EXACTLY);
        mNavButtonView.measure(measureSpec, measureSpec);
        // Nav button width includes its container.
        int navWidth = Math.max(mNavButtonContainerWidth, mNavButtonView.getMeasuredWidth());
        width += navWidth + getHorizontalMargins(mNavButtonView);
    }
    if (mLogoView.getVisibility() != GONE) {
        int measureSpec = MeasureSpec.makeMeasureSpec(mLogoSize, MeasureSpec.EXACTLY);
        mLogoView.measure(measureSpec, measureSpec);
        width += mLogoView.getMeasuredWidth();
    }
    if (mTitleTextView.getVisibility() != GONE) {
        measureChild(mTitleTextView, widthMeasureSpec, width, childHeightMeasureSpec, 0);
        width += mTitleTextView.getMeasuredWidth() + getHorizontalMargins(mTitleTextView);
    }
    setMeasuredDimension(resolveSize(width, widthMeasureSpec), resolveSize(desiredHeight, heightMeasureSpec));
}
#method_after
@Override
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    // Desired height should be the height constraint for all child views.
    int desiredHeight = getPaddingTop() + getSuggestedMinimumHeight() + getPaddingBottom();
    int childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(desiredHeight, MeasureSpec.AT_MOST);
    int width = 0;
    if (mNavButtonView.getVisibility() != GONE) {
        // Size of nav button is fixed.
        int measureSpec = MeasureSpec.makeMeasureSpec(mNavButtonIconSize, MeasureSpec.EXACTLY);
        mNavButtonView.measure(measureSpec, measureSpec);
        // Nav button width includes its container.
        int navWidth = Math.max(mNavButtonContainerWidth, mNavButtonView.getMeasuredWidth());
        width += navWidth + getHorizontalMargins(mNavButtonView);
    }
    if (mTitleIconView.getVisibility() != GONE) {
        int measureSpec = MeasureSpec.makeMeasureSpec(mTitleIconSize, MeasureSpec.EXACTLY);
        mTitleIconView.measure(measureSpec, measureSpec);
        width += mTitleIconView.getMeasuredWidth();
    }
    if (mTitleTextView.getVisibility() != GONE) {
        measureChild(mTitleTextView, widthMeasureSpec, width, childHeightMeasureSpec, 0);
        width += mTitleTextView.getMeasuredWidth() + getHorizontalMargins(mTitleTextView);
    }
    setMeasuredDimension(resolveSize(width, widthMeasureSpec), resolveSize(desiredHeight, heightMeasureSpec));
}
#end_block

#method_before
@Override
protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
    int height = bottom - top;
    int layoutLeft = getPaddingLeft();
    if (mNavButtonView.getVisibility() != GONE) {
        // Nav button is centered in container.
        int navButtonWidth = mNavButtonView.getMeasuredWidth();
        int containerWidth = Math.max(mNavButtonContainerWidth, navButtonWidth);
        int navButtonLeft = (containerWidth - navButtonWidth) / 2;
        layoutViewVerticallyCentered(mNavButtonView, navButtonLeft, height);
        layoutLeft += containerWidth;
    }
    if (mLogoView.getVisibility() != GONE) {
        layoutViewVerticallyCentered(mLogoView, layoutLeft, height);
        layoutLeft += mLogoView.getMeasuredWidth();
    }
    if (mTitleTextView.getVisibility() != GONE) {
        layoutViewVerticallyCentered(mTitleTextView, layoutLeft, height);
    }
}
#method_after
@Override
protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
    int height = bottom - top;
    int layoutLeft = getPaddingLeft();
    if (mNavButtonView.getVisibility() != GONE) {
        // Nav button is centered in container.
        int navButtonWidth = mNavButtonView.getMeasuredWidth();
        int containerWidth = Math.max(mNavButtonContainerWidth, navButtonWidth);
        int navButtonLeft = (containerWidth - navButtonWidth) / 2;
        layoutViewVerticallyCentered(mNavButtonView, navButtonLeft, height);
        layoutLeft += containerWidth;
    }
    if (mTitleIconView.getVisibility() != GONE) {
        layoutViewVerticallyCentered(mTitleIconView, layoutLeft, height);
        layoutLeft += mTitleIconView.getMeasuredWidth();
    }
    if (mTitleTextView.getVisibility() != GONE) {
        layoutViewVerticallyCentered(mTitleTextView, layoutLeft, height);
    }
}
#end_block

#method_before
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_car_toolbar);
    CarToolbar carToolbar = findViewById(R.id.car_toolbar);
    carToolbar.setNavigationIconOnClickListener(v -> this.onSupportNavigateUp());
    Toolbar toolbar = findViewById(R.id.toolbar);
    toolbar.setNavigationOnClickListener(v -> this.onSupportNavigateUp());
    setSupportActionBar(toolbar);
}
#method_after
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_car_toolbar);
    CarToolbar carToolbar = findViewById(R.id.car_toolbar);
    carToolbar.setNavigationIconOnClickListener(v -> onSupportNavigateUp());
    Toolbar toolbar = findViewById(R.id.toolbar);
    toolbar.setNavigationOnClickListener(v -> onSupportNavigateUp());
    setSupportActionBar(toolbar);
}
#end_block

#method_before
@Test
public void testSetNavigationIcon_doesNotThrowError() throws Throwable {
    // Since there is no easy way to compare drawable, here we are testing that calling the
    // relevant APIs doesn't crash.
    mActivityRule.runOnUiThread(() -> mToolbar.setNavigationIcon(android.R.drawable.sym_def_app_icon));
}
#method_after
@Test
public void testSetNavigationIcon_doesNotThrowError() throws Throwable {
    // Since there is no easy way to compare drawable, here we are testing that calling the
    // relevant APIs doesn't crash.
    mActivityRule.runOnUiThread(() -> mToolbar.setNavigationIcon(Icon.createWithResource(mActivity, android.R.drawable.sym_def_app_icon)));
}
#end_block

#method_before
@Test
public void testSetNavigationIconContainerWidth() throws Throwable {
    mActivityRule.runOnUiThread(() -> {
        mToolbar.setNavigationIcon(R.drawable.ic_nav_arrow_back);
        // Set title to verify icon space on right.
        mToolbar.setTitle("title");
    });
    int sideWidth = 10;
    // Container width is icon width plus |sideWidth| on both ends.
    int containerWidth = getNavigationIconView().getWidth() + (sideWidth * 2);
    mActivityRule.runOnUiThread(() -> mToolbar.setNavigationIconContainerWidth(containerWidth));
    onView(withId(R.id.nav_button)).check(matches(withLeft(sideWidth)));
    onView(withId(R.id.title)).check(matches(withLeft(containerWidth)));
}
#method_after
@Test
public void testSetNavigationIconContainerWidth() throws Throwable {
    mActivityRule.runOnUiThread(() -> {
        mToolbar.setNavigationIcon(Icon.createWithResource(mActivity, R.drawable.ic_nav_arrow_back));
        // Set title to verify icon space on right.
        mToolbar.setTitle("title");
    });
    int sideWidth = 10;
    // Container width is icon width plus |sideWidth| on both ends.
    int containerWidth = getNavigationIconView().getWidth() + (sideWidth * 2);
    mActivityRule.runOnUiThread(() -> mToolbar.setNavigationIconContainerWidth(containerWidth));
    onView(withId(R.id.nav_button)).check(matches(withLeft(sideWidth)));
    onView(withId(R.id.title)).check(matches(withLeft(containerWidth)));
}
#end_block

#method_before
@Test
public void testSetNavigationIconContainerWidth_NoContainerKeepsIconCompletelyVisible() throws Throwable {
    mActivityRule.runOnUiThread(() -> {
        mToolbar.setNavigationIcon(R.drawable.ic_nav_arrow_back);
        // Set title to verify icon space on right.
        mToolbar.setTitle("title");
    });
    int containerWidth = 0;
    mActivityRule.runOnUiThread(() -> mToolbar.setNavigationIconContainerWidth(containerWidth));
    onView(withId(R.id.nav_button)).check(matches(withLeft(0)));
    onView(withId(R.id.title)).check(isCompletelyRightOf(withId(R.id.nav_button)));
}
#method_after
@Test
public void testSetNavigationIconContainerWidth_NoContainerKeepsIconCompletelyVisible() throws Throwable {
    mActivityRule.runOnUiThread(() -> {
        mToolbar.setNavigationIcon(Icon.createWithResource(mActivity, (R.drawable.ic_nav_arrow_back)));
        // Set title to verify icon space on right.
        mToolbar.setTitle("title");
    });
    int containerWidth = 0;
    mActivityRule.runOnUiThread(() -> mToolbar.setNavigationIconContainerWidth(containerWidth));
    onView(withId(R.id.nav_button)).check(matches(withLeft(0)));
    onView(withId(R.id.title)).check(isCompletelyRightOf(withId(R.id.nav_button)));
}
#end_block

#method_before
private char[] compile(String pattern) {
    int length = pattern.length();
    boolean inQuote = false;
    StringBuilder compiledCode = new StringBuilder(length * 2);
    StringBuilder tmpBuffer = null;
    // BEGIN Android-changed: Dead code because we use ICU.
    // FormatWeekday reimplemented using ICU data and no longer uses forceStandaloneForm.
    /*
        int count = 0, tagcount = 0;
        int lastTag = -1, prevTag = -1;
        */
    int count = 0;
    int lastTag = -1;
    for (int i = 0; i < length; i++) {
        char c = pattern.charAt(i);
        if (c == '\'') {
            // in a quoted section.
            if ((i + 1) < length) {
                c = pattern.charAt(i + 1);
                if (c == '\'') {
                    i++;
                    if (count != 0) {
                        encode(lastTag, count, compiledCode);
                        // BEGIN Android-changed: Dead code because we use ICU.
                        // FormatWeekday reimplemented using ICU data and no longer uses
                        // forceStandaloneForm.
                        /*
                            tagcount++;
                            prevTag = lastTag;
                            */
                        // END Android-removed: Dead code because we use ICU.
                        lastTag = -1;
                        count = 0;
                    }
                    if (inQuote) {
                        tmpBuffer.append(c);
                    } else {
                        compiledCode.append((char) (TAG_QUOTE_ASCII_CHAR << 8 | c));
                    }
                    continue;
                }
            }
            if (!inQuote) {
                if (count != 0) {
                    encode(lastTag, count, compiledCode);
                    // BEGIN Android-removed: Dead code because we use ICU.
                    // FormatWeekday reimplemented using ICU data and no longer uses
                    // forceStandaloneForm.
                    /*
                        tagcount++;
                        prevTag = lastTag;
                        */
                    // END Android-removed: Dead code because we use ICU.
                    lastTag = -1;
                    count = 0;
                }
                if (tmpBuffer == null) {
                    tmpBuffer = new StringBuilder(length);
                } else {
                    tmpBuffer.setLength(0);
                }
                inQuote = true;
            } else {
                int len = tmpBuffer.length();
                if (len == 1) {
                    char ch = tmpBuffer.charAt(0);
                    if (ch < 128) {
                        compiledCode.append((char) (TAG_QUOTE_ASCII_CHAR << 8 | ch));
                    } else {
                        compiledCode.append((char) (TAG_QUOTE_CHARS << 8 | 1));
                        compiledCode.append(ch);
                    }
                } else {
                    encode(TAG_QUOTE_CHARS, len, compiledCode);
                    compiledCode.append(tmpBuffer);
                }
                inQuote = false;
            }
            continue;
        }
        if (inQuote) {
            tmpBuffer.append(c);
            continue;
        }
        if (!(c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z')) {
            if (count != 0) {
                encode(lastTag, count, compiledCode);
                // BEGIN Android-removed: Dead code because we use ICU.
                // FormatWeekday reimplemented using ICU data and no longer uses
                // forceStandaloneForm.
                /*
                    tagcount++;
                    prevTag = lastTag;
                    */
                // END Android-removed: Dead code because we use ICU.
                lastTag = -1;
                count = 0;
            }
            if (c < 128) {
                // In most cases, c would be a delimiter, such as ':'.
                compiledCode.append((char) (TAG_QUOTE_ASCII_CHAR << 8 | c));
            } else {
                // Take any contiguous non-ASCII alphabet characters and
                // put them in a single TAG_QUOTE_CHARS.
                int j;
                for (j = i + 1; j < length; j++) {
                    char d = pattern.charAt(j);
                    if (d == '\'' || (d >= 'a' && d <= 'z' || d >= 'A' && d <= 'Z')) {
                        break;
                    }
                }
                compiledCode.append((char) (TAG_QUOTE_CHARS << 8 | (j - i)));
                for (; i < j; i++) {
                    compiledCode.append(pattern.charAt(i));
                }
                i--;
            }
            continue;
        }
        int tag;
        if ((tag = DateFormatSymbols.patternChars.indexOf(c)) == -1) {
            throw new IllegalArgumentException("Illegal pattern character " + "'" + c + "'");
        }
        if (lastTag == -1 || lastTag == tag) {
            lastTag = tag;
            count++;
            continue;
        }
        encode(lastTag, count, compiledCode);
        // BEGIN Android-removed: Dead code because we use ICU.
        // FormatWeekday reimplemented using ICU data and no longer uses forceStandaloneForm.
        /*
            tagcount++;
            prevTag = lastTag;
            */
        // END Android-removed: Dead code because we use ICU.
        lastTag = tag;
        count = 1;
    }
    if (inQuote) {
        throw new IllegalArgumentException("Unterminated quote");
    }
    if (count != 0) {
        encode(lastTag, count, compiledCode);
    // BEGIN Android-removed: Dead code because we use ICU.
    // FormatWeekday reimplemented using ICU data and no longer uses forceStandaloneForm.
    /*
            tagcount++;
            prevTag = lastTag;
            */
    // END Android-removed: Dead code because we use ICU.
    }
    // Android-removed: Dead code because we use ICU.
    // FormatWeekday reimplemented using ICU data and no longer uses forceStandaloneForm.
    // forceStandaloneForm = (tagcount == 1 && prevTag == PATTERN_MONTH);
    // Copy the compiled pattern to a char array
    int len = compiledCode.length();
    char[] r = new char[len];
    compiledCode.getChars(0, len, r, 0);
    return r;
}
#method_after
private char[] compile(String pattern) {
    int length = pattern.length();
    boolean inQuote = false;
    StringBuilder compiledCode = new StringBuilder(length * 2);
    StringBuilder tmpBuffer = null;
    // BEGIN Android-removed: App compat for formatting pattern letter M.
    // See forceStandaloneForm field
    /*
        int count = 0, tagcount = 0;
        int lastTag = -1, prevTag = -1;
        */
    int count = 0;
    int lastTag = -1;
    for (int i = 0; i < length; i++) {
        char c = pattern.charAt(i);
        if (c == '\'') {
            // in a quoted section.
            if ((i + 1) < length) {
                c = pattern.charAt(i + 1);
                if (c == '\'') {
                    i++;
                    if (count != 0) {
                        encode(lastTag, count, compiledCode);
                        // BEGIN Android-removed: App compat for formatting pattern letter M.
                        // See forceStandaloneForm field
                        /*
                            tagcount++;
                            prevTag = lastTag;
                            */
                        // END Android-removed: App compat for formatting pattern letter M.
                        lastTag = -1;
                        count = 0;
                    }
                    if (inQuote) {
                        tmpBuffer.append(c);
                    } else {
                        compiledCode.append((char) (TAG_QUOTE_ASCII_CHAR << 8 | c));
                    }
                    continue;
                }
            }
            if (!inQuote) {
                if (count != 0) {
                    encode(lastTag, count, compiledCode);
                    // BEGIN Android-removed: App compat for formatting pattern letter M.
                    // See forceStandaloneForm field
                    /*
                        tagcount++;
                        prevTag = lastTag;
                        */
                    // END Android-removed: App compat for formatting pattern letter M.
                    lastTag = -1;
                    count = 0;
                }
                if (tmpBuffer == null) {
                    tmpBuffer = new StringBuilder(length);
                } else {
                    tmpBuffer.setLength(0);
                }
                inQuote = true;
            } else {
                int len = tmpBuffer.length();
                if (len == 1) {
                    char ch = tmpBuffer.charAt(0);
                    if (ch < 128) {
                        compiledCode.append((char) (TAG_QUOTE_ASCII_CHAR << 8 | ch));
                    } else {
                        compiledCode.append((char) (TAG_QUOTE_CHARS << 8 | 1));
                        compiledCode.append(ch);
                    }
                } else {
                    encode(TAG_QUOTE_CHARS, len, compiledCode);
                    compiledCode.append(tmpBuffer);
                }
                inQuote = false;
            }
            continue;
        }
        if (inQuote) {
            tmpBuffer.append(c);
            continue;
        }
        if (!(c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z')) {
            if (count != 0) {
                encode(lastTag, count, compiledCode);
                // BEGIN Android-removed: App compat for formatting pattern letter M.
                // See forceStandaloneForm field
                /*
                    tagcount++;
                    prevTag = lastTag;
                    */
                // END Android-removed: App compat for formatting pattern letter M.
                lastTag = -1;
                count = 0;
            }
            if (c < 128) {
                // In most cases, c would be a delimiter, such as ':'.
                compiledCode.append((char) (TAG_QUOTE_ASCII_CHAR << 8 | c));
            } else {
                // Take any contiguous non-ASCII alphabet characters and
                // put them in a single TAG_QUOTE_CHARS.
                int j;
                for (j = i + 1; j < length; j++) {
                    char d = pattern.charAt(j);
                    if (d == '\'' || (d >= 'a' && d <= 'z' || d >= 'A' && d <= 'Z')) {
                        break;
                    }
                }
                compiledCode.append((char) (TAG_QUOTE_CHARS << 8 | (j - i)));
                for (; i < j; i++) {
                    compiledCode.append(pattern.charAt(i));
                }
                i--;
            }
            continue;
        }
        int tag;
        if ((tag = DateFormatSymbols.patternChars.indexOf(c)) == -1) {
            throw new IllegalArgumentException("Illegal pattern character " + "'" + c + "'");
        }
        if (lastTag == -1 || lastTag == tag) {
            lastTag = tag;
            count++;
            continue;
        }
        encode(lastTag, count, compiledCode);
        // BEGIN Android-removed: App compat for formatting pattern letter M.
        // See forceStandaloneForm field
        /*
            tagcount++;
            prevTag = lastTag;
            */
        // END Android-removed: App compat for formatting pattern letter M.
        lastTag = tag;
        count = 1;
    }
    if (inQuote) {
        throw new IllegalArgumentException("Unterminated quote");
    }
    if (count != 0) {
        encode(lastTag, count, compiledCode);
    // BEGIN Android-removed: App compat for formatting pattern letter M.
    // See forceStandaloneForm field
    /*
            tagcount++;
            prevTag = lastTag;
            */
    // END Android-removed: App compat for formatting pattern letter M.
    }
    // Android-removed: App compat for formatting pattern letter M.
    // See forceStandaloneForm field
    // forceStandaloneForm = (tagcount == 1 && prevTag == PATTERN_MONTH);
    // Copy the compiled pattern to a char array
    int len = compiledCode.length();
    char[] r = new char[len];
    compiledCode.getChars(0, len, r, 0);
    return r;
}
#end_block

#method_before
private void subFormat(int patternCharIndex, int count, FieldDelegate delegate, StringBuffer buffer, boolean useDateFormatSymbols) {
    int maxIntCount = Integer.MAX_VALUE;
    String current = null;
    int beginOffset = buffer.length();
    int field = PATTERN_INDEX_TO_CALENDAR_FIELD[patternCharIndex];
    int value;
    if (field == CalendarBuilder.WEEK_YEAR) {
        if (calendar.isWeekDateSupported()) {
            value = calendar.getWeekYear();
        } else {
            // use calendar year 'y' instead
            patternCharIndex = PATTERN_YEAR;
            field = PATTERN_INDEX_TO_CALENDAR_FIELD[patternCharIndex];
            value = calendar.get(field);
        }
    } else if (field == CalendarBuilder.ISO_DAY_OF_WEEK) {
        value = CalendarBuilder.toISODayOfWeek(calendar.get(Calendar.DAY_OF_WEEK));
    } else {
        value = calendar.get(field);
    }
    int style = (count >= 4) ? Calendar.LONG : Calendar.SHORT;
    // && patternCharIndex != PATTERN_MONTH_STANDALONE) {
    if (!useDateFormatSymbols && field != CalendarBuilder.ISO_DAY_OF_WEEK) {
        current = calendar.getDisplayName(field, style, locale);
    }
    switch(patternCharIndex) {
        case // 'G'
        PATTERN_ERA:
            if (useDateFormatSymbols) {
                String[] eras = formatData.getEras();
                if (value < eras.length) {
                    current = eras[value];
                }
            }
            if (current == null) {
                current = "";
            }
            break;
        // 'Y'
        case PATTERN_WEEK_YEAR:
        case // 'y'
        PATTERN_YEAR:
            if (calendar instanceof GregorianCalendar) {
                if (count != 2) {
                    zeroPaddingNumber(value, count, maxIntCount, buffer);
                } else {
                    zeroPaddingNumber(value, 2, 2, buffer);
                }
            // clip 1996 to 96
            } else {
                if (current == null) {
                    zeroPaddingNumber(value, style == Calendar.LONG ? 1 : count, maxIntCount, buffer);
                }
            }
            break;
        case // 'M' (context seinsive)
        PATTERN_MONTH:
            if (useDateFormatSymbols) {
                // BEGIN Android-changed: FormatMonth method to format using ICU data.
                /*
                String[] months;
                if (count >= 4) {
                    months = formatData.getMonths();
                    current = months[value];
                } else if (count == 3) {
                    months = formatData.getShortMonths();
                    current = months[value];
                }
            } else {
                if (count < 3) {
                    current = null;
                } else if (forceStandaloneForm) {
                    current = calendar.getDisplayName(field, style | 0x8000, locale);
                    if (current == null) {
                        current = calendar.getDisplayName(field, style, locale);
                    }
                }
            }
            if (current == null) {
                zeroPaddingNumber(value+1, count, maxIntCount, buffer);
            }
                */
                current = formatMonth(count, value, maxIntCount, buffer, useDateFormatSymbols, false);
            // END Android-changed: FormatMonth method to format using ICU data.
            }
            break;
        case // 'L'
        PATTERN_MONTH_STANDALONE:
            /*
            assert current == null;
            if (locale == null) {
                String[] months;
                if (count >= 4) {
                    months = formatData.getMonths();
                    current = months[value];
                } else if (count == 3) {
                    months = formatData.getShortMonths();
                    current = months[value];
                }
            } else {
                if (count >= 3) {
                    current = calendar.getDisplayName(field, style | 0x8000, locale);
                }
            }
            if (current == null) {
                zeroPaddingNumber(value+1, count, maxIntCount, buffer);
            */
            if (useDateFormatSymbols) {
                current = formatMonth(count, value, maxIntCount, buffer, useDateFormatSymbols, true);
            // END Android-changed: FormatMonth method to format using ICU data.
            }
            break;
        case // 'k' 1-based.  eg, 23:59 + 1 hour =>> 24:59
        PATTERN_HOUR_OF_DAY1:
            if (current == null) {
                if (value == 0) {
                    zeroPaddingNumber(calendar.getMaximum(Calendar.HOUR_OF_DAY) + 1, count, maxIntCount, buffer);
                } else {
                    zeroPaddingNumber(value, count, maxIntCount, buffer);
                }
            }
            break;
        case // 'E'
        PATTERN_DAY_OF_WEEK:
            /*
            if (useDateFormatSymbols) {
                String[] weekdays;
                if (count >= 4) {
                    weekdays = formatData.getWeekdays();
                    current = weekdays[value];
                } else { // count < 4, use abbreviated form if exists
                    weekdays = formatData.getShortWeekdays();
                    current = weekdays[value];
                }
            }
            */
            if (current == null) {
                current = formatWeekday(count, value, useDateFormatSymbols, false);
            }
            // END Android-changed: FormatWeekday method to format using ICU data.
            break;
        // BEGIN Android-added: support for 'c' (standalone day of week).
        case // 'c'
        PATTERN_STANDALONE_DAY_OF_WEEK:
            if (current == null) {
                current = formatWeekday(count, value, useDateFormatSymbols, true);
            }
            break;
        case // 'a'
        PATTERN_AM_PM:
            if (useDateFormatSymbols) {
                String[] ampm = formatData.getAmPmStrings();
                current = ampm[value];
            }
            break;
        // Not currently supported here.
        case PATTERN_DAY_PERIOD:
        case PATTERN_FLEXIBLE_DAY_PERIOD:
            current = "";
            break;
        case // 'h' 1-based.  eg, 11PM + 1 hour =>> 12 AM
        PATTERN_HOUR1:
            if (current == null) {
                if (value == 0) {
                    zeroPaddingNumber(calendar.getLeastMaximum(Calendar.HOUR) + 1, count, maxIntCount, buffer);
                } else {
                    zeroPaddingNumber(value, count, maxIntCount, buffer);
                }
            }
            break;
        case // 'z'
        PATTERN_ZONE_NAME:
            if (current == null) {
                // BEGIN Android-changed: Format time zone name using ICU.
                /*
                if (formatData.locale == null || formatData.isZoneStringsSet) {
                    int zoneIndex =
                        formatData.getZoneIndex(calendar.getTimeZone().getID());
                    if (zoneIndex == -1) {
                        value = calendar.get(Calendar.ZONE_OFFSET) +
                            calendar.get(Calendar.DST_OFFSET);
                        buffer.append(ZoneInfoFile.toCustomID(value));
                    } else {
                        int index = (calendar.get(Calendar.DST_OFFSET) == 0) ? 1: 3;
                        if (count < 4) {
                            // Use the short name
                            index++;
                        }
                        String[][] zoneStrings = formatData.getZoneStringsWrapper();
                        buffer.append(zoneStrings[zoneIndex][index]);
                    }
                } else {
                    TimeZone tz = calendar.getTimeZone();
                    boolean daylight = (calendar.get(Calendar.DST_OFFSET) != 0);
                    int tzstyle = (count < 4 ? TimeZone.SHORT : TimeZone.LONG);
                    buffer.append(tz.getDisplayName(daylight, tzstyle, formatData.locale));
                }
                */
                TimeZone tz = calendar.getTimeZone();
                boolean daylight = (calendar.get(Calendar.DST_OFFSET) != 0);
                String zoneString;
                if (formatData.isZoneStringsSet) {
                    // DateFormatSymbols.setZoneStrings() has be used, use those values instead of
                    // ICU code.
                    int tzstyle = count < 4 ? TimeZone.SHORT : TimeZone.LONG;
                    zoneString = libcore.icu.TimeZoneNames.getDisplayName(formatData.getZoneStringsWrapper(), tz.getID(), daylight, tzstyle);
                } else {
                    TimeZoneNames.NameType nameType;
                    if (count < 4) {
                        nameType = daylight ? TimeZoneNames.NameType.SHORT_DAYLIGHT : TimeZoneNames.NameType.SHORT_STANDARD;
                    } else {
                        nameType = daylight ? TimeZoneNames.NameType.LONG_DAYLIGHT : TimeZoneNames.NameType.LONG_STANDARD;
                    }
                    String canonicalID = android.icu.util.TimeZone.getCanonicalID(tz.getID());
                    zoneString = getTimeZoneNames().getDisplayName(canonicalID, nameType, calendar.getTimeInMillis());
                }
                if (zoneString != null) {
                    buffer.append(zoneString);
                } else {
                    int offsetMillis = calendar.get(Calendar.ZONE_OFFSET) + calendar.get(Calendar.DST_OFFSET);
                    buffer.append(TimeZone.createGmtOffsetString(true, true, offsetMillis));
                }
            // END Android-changed: Format time zone name using ICU.
            }
            break;
        case // 'Z' ("-/+hhmm" form)
        PATTERN_ZONE_VALUE:
            // BEGIN Android-changed: Use shared code in TimeZone for zone offset string.
            /*
            value = (calendar.get(Calendar.ZONE_OFFSET) +
                     calendar.get(Calendar.DST_OFFSET)) / 60000;

            int width = 4;
            if (value >= 0) {
                buffer.append('+');
            } else {
                width++;
            }

            int num = (value / 60) * 100 + (value % 60);
            CalendarUtils.sprintf0d(buffer, num, width);
        */
            value = calendar.get(Calendar.ZONE_OFFSET) + calendar.get(Calendar.DST_OFFSET);
            final boolean includeSeparator = (count >= 4);
            final boolean includeGmt = (count == 4);
            buffer.append(TimeZone.createGmtOffsetString(includeGmt, includeSeparator, value));
            break;
        case // 'X'
        PATTERN_ISO_ZONE:
            value = calendar.get(Calendar.ZONE_OFFSET) + calendar.get(Calendar.DST_OFFSET);
            if (value == 0) {
                buffer.append('Z');
                break;
            }
            value /= 60000;
            if (value >= 0) {
                buffer.append('+');
            } else {
                buffer.append('-');
                value = -value;
            }
            CalendarUtils.sprintf0d(buffer, value / 60, 2);
            if (count == 1) {
                break;
            }
            if (count == 3) {
                buffer.append(':');
            }
            CalendarUtils.sprintf0d(buffer, value % 60, 2);
            break;
        // BEGIN Android-added: Better UTS#35 conformity for fractional seconds.
        case // 'S'
        PATTERN_MILLISECOND:
            // in the resulting formatted output.
            if (current == null) {
                value = (int) (((double) value / 1000) * Math.pow(10, count));
                zeroPaddingNumber(value, count, count, buffer);
            }
            break;
        default:
            // case PATTERN_ISO_DAY_OF_WEEK:      // 'u' pseudo field, Monday = 1, ..., Sunday = 7
            if (current == null) {
                zeroPaddingNumber(value, count, maxIntCount, buffer);
            }
            break;
    }
    if (current != null) {
        buffer.append(current);
    }
    int fieldID = PATTERN_INDEX_TO_DATE_FORMAT_FIELD[patternCharIndex];
    Field f = PATTERN_INDEX_TO_DATE_FORMAT_FIELD_ID[patternCharIndex];
    delegate.formatted(fieldID, f, f, beginOffset, buffer.length(), buffer);
}
#method_after
private void subFormat(int patternCharIndex, int count, FieldDelegate delegate, StringBuffer buffer, boolean useDateFormatSymbols) {
    int maxIntCount = Integer.MAX_VALUE;
    String current = null;
    int beginOffset = buffer.length();
    int field = PATTERN_INDEX_TO_CALENDAR_FIELD[patternCharIndex];
    int value;
    if (field == CalendarBuilder.WEEK_YEAR) {
        if (calendar.isWeekDateSupported()) {
            value = calendar.getWeekYear();
        } else {
            // use calendar year 'y' instead
            patternCharIndex = PATTERN_YEAR;
            field = PATTERN_INDEX_TO_CALENDAR_FIELD[patternCharIndex];
            value = calendar.get(field);
        }
    } else if (field == CalendarBuilder.ISO_DAY_OF_WEEK) {
        value = CalendarBuilder.toISODayOfWeek(calendar.get(Calendar.DAY_OF_WEEK));
    } else {
        value = calendar.get(field);
    }
    int style = (count >= 4) ? Calendar.LONG : Calendar.SHORT;
    if (!useDateFormatSymbols && field != CalendarBuilder.ISO_DAY_OF_WEEK) {
        current = calendar.getDisplayName(field, style, locale);
    }
    switch(patternCharIndex) {
        case // 'G'
        PATTERN_ERA:
            if (useDateFormatSymbols) {
                String[] eras = formatData.getEras();
                if (value < eras.length) {
                    current = eras[value];
                }
            }
            if (current == null) {
                current = "";
            }
            break;
        // 'Y'
        case PATTERN_WEEK_YEAR:
        case // 'y'
        PATTERN_YEAR:
            if (calendar instanceof GregorianCalendar) {
                if (count != 2) {
                    zeroPaddingNumber(value, count, maxIntCount, buffer);
                } else {
                    zeroPaddingNumber(value, 2, 2, buffer);
                }
            // clip 1996 to 96
            } else {
                if (current == null) {
                    zeroPaddingNumber(value, style == Calendar.LONG ? 1 : count, maxIntCount, buffer);
                }
            }
            break;
        case // 'M' (context seinsive)
        PATTERN_MONTH:
            if (useDateFormatSymbols) {
                // BEGIN Android-changed: formatMonth() method to format using ICU data.
                /*
                String[] months;
                if (count >= 4) {
                    months = formatData.getMonths();
                    current = months[value];
                } else if (count == 3) {
                    months = formatData.getShortMonths();
                    current = months[value];
                }
            } else {
                if (count < 3) {
                    current = null;
                } else if (forceStandaloneForm) {
                    current = calendar.getDisplayName(field, style | 0x8000, locale);
                    if (current == null) {
                        current = calendar.getDisplayName(field, style, locale);
                    }
                }
            }
            if (current == null) {
                zeroPaddingNumber(value+1, count, maxIntCount, buffer);
            }
            */
                current = formatMonth(count, value, maxIntCount, buffer, useDateFormatSymbols, false);
            // END Android-changed: formatMonth() method to format using ICU data.
            }
            break;
        case // 'L'
        PATTERN_MONTH_STANDALONE:
            /*
            assert current == null;
            if (locale == null) {
                String[] months;
                if (count >= 4) {
                    months = formatData.getMonths();
                    current = months[value];
                } else if (count == 3) {
                    months = formatData.getShortMonths();
                    current = months[value];
                }
            } else {
                if (count >= 3) {
                    current = calendar.getDisplayName(field, style | 0x8000, locale);
                }
            }
            if (current == null) {
                zeroPaddingNumber(value+1, count, maxIntCount, buffer);
            */
            if (useDateFormatSymbols) {
                current = formatMonth(count, value, maxIntCount, buffer, useDateFormatSymbols, true);
            // END Android-changed: formatMonth() method to format using ICU data.
            }
            break;
        case // 'k' 1-based.  eg, 23:59 + 1 hour =>> 24:59
        PATTERN_HOUR_OF_DAY1:
            if (current == null) {
                if (value == 0) {
                    zeroPaddingNumber(calendar.getMaximum(Calendar.HOUR_OF_DAY) + 1, count, maxIntCount, buffer);
                } else {
                    zeroPaddingNumber(value, count, maxIntCount, buffer);
                }
            }
            break;
        case // 'E'
        PATTERN_DAY_OF_WEEK:
            /*
            if (useDateFormatSymbols) {
                String[] weekdays;
                if (count >= 4) {
                    weekdays = formatData.getWeekdays();
                    current = weekdays[value];
                } else { // count < 4, use abbreviated form if exists
                    weekdays = formatData.getShortWeekdays();
                    current = weekdays[value];
                }
            }
            */
            if (current == null) {
                current = formatWeekday(count, value, useDateFormatSymbols, false);
            }
            // END Android-removed: App compat for formatting pattern letter M.
            break;
        // BEGIN Android-added: support for 'c' (standalone day of week).
        case // 'c'
        PATTERN_STANDALONE_DAY_OF_WEEK:
            if (current == null) {
                current = formatWeekday(count, value, useDateFormatSymbols, true);
            }
            break;
        case // 'a'
        PATTERN_AM_PM:
            if (useDateFormatSymbols) {
                String[] ampm = formatData.getAmPmStrings();
                current = ampm[value];
            }
            break;
        // Not currently supported here.
        case PATTERN_DAY_PERIOD:
        case PATTERN_FLEXIBLE_DAY_PERIOD:
            current = "";
            break;
        case // 'h' 1-based.  eg, 11PM + 1 hour =>> 12 AM
        PATTERN_HOUR1:
            if (current == null) {
                if (value == 0) {
                    zeroPaddingNumber(calendar.getLeastMaximum(Calendar.HOUR) + 1, count, maxIntCount, buffer);
                } else {
                    zeroPaddingNumber(value, count, maxIntCount, buffer);
                }
            }
            break;
        case // 'z'
        PATTERN_ZONE_NAME:
            if (current == null) {
                // BEGIN Android-changed: Format time zone name using ICU.
                /*
                if (formatData.locale == null || formatData.isZoneStringsSet) {
                    int zoneIndex =
                        formatData.getZoneIndex(calendar.getTimeZone().getID());
                    if (zoneIndex == -1) {
                        value = calendar.get(Calendar.ZONE_OFFSET) +
                            calendar.get(Calendar.DST_OFFSET);
                        buffer.append(ZoneInfoFile.toCustomID(value));
                    } else {
                        int index = (calendar.get(Calendar.DST_OFFSET) == 0) ? 1: 3;
                        if (count < 4) {
                            // Use the short name
                            index++;
                        }
                        String[][] zoneStrings = formatData.getZoneStringsWrapper();
                        buffer.append(zoneStrings[zoneIndex][index]);
                    }
                } else {
                    TimeZone tz = calendar.getTimeZone();
                    boolean daylight = (calendar.get(Calendar.DST_OFFSET) != 0);
                    int tzstyle = (count < 4 ? TimeZone.SHORT : TimeZone.LONG);
                    buffer.append(tz.getDisplayName(daylight, tzstyle, formatData.locale));
                }
                */
                TimeZone tz = calendar.getTimeZone();
                boolean daylight = (calendar.get(Calendar.DST_OFFSET) != 0);
                String zoneString;
                if (formatData.isZoneStringsSet) {
                    // DateFormatSymbols.setZoneStrings() has be used, use those values instead of
                    // ICU code.
                    int tzstyle = count < 4 ? TimeZone.SHORT : TimeZone.LONG;
                    zoneString = libcore.icu.TimeZoneNames.getDisplayName(formatData.getZoneStringsWrapper(), tz.getID(), daylight, tzstyle);
                } else {
                    TimeZoneNames.NameType nameType;
                    if (count < 4) {
                        nameType = daylight ? TimeZoneNames.NameType.SHORT_DAYLIGHT : TimeZoneNames.NameType.SHORT_STANDARD;
                    } else {
                        nameType = daylight ? TimeZoneNames.NameType.LONG_DAYLIGHT : TimeZoneNames.NameType.LONG_STANDARD;
                    }
                    String canonicalID = android.icu.util.TimeZone.getCanonicalID(tz.getID());
                    zoneString = getTimeZoneNames().getDisplayName(canonicalID, nameType, calendar.getTimeInMillis());
                }
                if (zoneString != null) {
                    buffer.append(zoneString);
                } else {
                    int offsetMillis = calendar.get(Calendar.ZONE_OFFSET) + calendar.get(Calendar.DST_OFFSET);
                    buffer.append(TimeZone.createGmtOffsetString(true, true, offsetMillis));
                }
            // END Android-changed: Format time zone name using ICU.
            }
            break;
        case // 'Z' ("-/+hhmm" form)
        PATTERN_ZONE_VALUE:
            // BEGIN Android-changed: Use shared code in TimeZone for zone offset string.
            /*
            value = (calendar.get(Calendar.ZONE_OFFSET) +
                     calendar.get(Calendar.DST_OFFSET)) / 60000;

            int width = 4;
            if (value >= 0) {
                buffer.append('+');
            } else {
                width++;
            }

            int num = (value / 60) * 100 + (value % 60);
            CalendarUtils.sprintf0d(buffer, num, width);
            */
            value = calendar.get(Calendar.ZONE_OFFSET) + calendar.get(Calendar.DST_OFFSET);
            final boolean includeSeparator = (count >= 4);
            final boolean includeGmt = (count == 4);
            buffer.append(TimeZone.createGmtOffsetString(includeGmt, includeSeparator, value));
            break;
        case // 'X'
        PATTERN_ISO_ZONE:
            value = calendar.get(Calendar.ZONE_OFFSET) + calendar.get(Calendar.DST_OFFSET);
            if (value == 0) {
                buffer.append('Z');
                break;
            }
            value /= 60000;
            if (value >= 0) {
                buffer.append('+');
            } else {
                buffer.append('-');
                value = -value;
            }
            CalendarUtils.sprintf0d(buffer, value / 60, 2);
            if (count == 1) {
                break;
            }
            if (count == 3) {
                buffer.append(':');
            }
            CalendarUtils.sprintf0d(buffer, value % 60, 2);
            break;
        // BEGIN Android-added: Better UTS#35 conformity for fractional seconds.
        case // 'S'
        PATTERN_MILLISECOND:
            // in the resulting formatted output.
            if (current == null) {
                value = (int) (((double) value / 1000) * Math.pow(10, count));
                zeroPaddingNumber(value, count, count, buffer);
            }
            break;
        default:
            // case PATTERN_ISO_DAY_OF_WEEK:      // 'u' pseudo field, Monday = 1, ..., Sunday = 7
            if (current == null) {
                zeroPaddingNumber(value, count, maxIntCount, buffer);
            }
            break;
    }
    if (current != null) {
        buffer.append(current);
    }
    int fieldID = PATTERN_INDEX_TO_DATE_FORMAT_FIELD[patternCharIndex];
    Field f = PATTERN_INDEX_TO_DATE_FORMAT_FIELD_ID[patternCharIndex];
    delegate.formatted(fieldID, f, f, beginOffset, buffer.length(), buffer);
}
#end_block

#method_before
// END Android-added: FormatWeekday and formatMonth methods to format using ICU data.
private void zeroPaddingNumber(int value, int minDigits, int maxDigits, StringBuffer buffer) {
    // either 2 or Integer.MAX_VALUE (maxIntCount in format()).
    try {
        if (zeroDigit == 0) {
            zeroDigit = ((DecimalFormat) numberFormat).getDecimalFormatSymbols().getZeroDigit();
        }
        if (value >= 0) {
            if (value < 100 && minDigits >= 1 && minDigits <= 2) {
                if (value < 10) {
                    if (minDigits == 2) {
                        buffer.append(zeroDigit);
                    }
                    buffer.append((char) (zeroDigit + value));
                } else {
                    buffer.append((char) (zeroDigit + value / 10));
                    buffer.append((char) (zeroDigit + value % 10));
                }
                return;
            } else if (value >= 1000 && value < 10000) {
                if (minDigits == 4) {
                    buffer.append((char) (zeroDigit + value / 1000));
                    value %= 1000;
                    buffer.append((char) (zeroDigit + value / 100));
                    value %= 100;
                    buffer.append((char) (zeroDigit + value / 10));
                    buffer.append((char) (zeroDigit + value % 10));
                    return;
                }
                if (minDigits == 2 && maxDigits == 2) {
                    zeroPaddingNumber(value % 100, 2, 2, buffer);
                    return;
                }
            }
        }
    } catch (Exception e) {
    }
    numberFormat.setMinimumIntegerDigits(minDigits);
    numberFormat.setMaximumIntegerDigits(maxDigits);
    numberFormat.format((long) value, buffer, DontCareFieldPosition.INSTANCE);
}
#method_after
// END Android-added: formatWeekday() and formatMonth() methods to format using ICU data.
private void zeroPaddingNumber(int value, int minDigits, int maxDigits, StringBuffer buffer) {
    // either 2 or Integer.MAX_VALUE (maxIntCount in format()).
    try {
        if (zeroDigit == 0) {
            zeroDigit = ((DecimalFormat) numberFormat).getDecimalFormatSymbols().getZeroDigit();
        }
        if (value >= 0) {
            if (value < 100 && minDigits >= 1 && minDigits <= 2) {
                if (value < 10) {
                    if (minDigits == 2) {
                        buffer.append(zeroDigit);
                    }
                    buffer.append((char) (zeroDigit + value));
                } else {
                    buffer.append((char) (zeroDigit + value / 10));
                    buffer.append((char) (zeroDigit + value % 10));
                }
                return;
            } else if (value >= 1000 && value < 10000) {
                if (minDigits == 4) {
                    buffer.append((char) (zeroDigit + value / 1000));
                    value %= 1000;
                    buffer.append((char) (zeroDigit + value / 100));
                    value %= 100;
                    buffer.append((char) (zeroDigit + value / 10));
                    buffer.append((char) (zeroDigit + value % 10));
                    return;
                }
                if (minDigits == 2 && maxDigits == 2) {
                    zeroPaddingNumber(value % 100, 2, 2, buffer);
                    return;
                }
            }
        }
    } catch (Exception e) {
    }
    numberFormat.setMinimumIntegerDigits(minDigits);
    numberFormat.setMaximumIntegerDigits(maxDigits);
    numberFormat.format((long) value, buffer, DontCareFieldPosition.INSTANCE);
}
#end_block

#method_before
private int matchString(String text, int start, int field, Map<String, Integer> data, CalendarBuilder calb) {
    if (data != null) {
        // BEGIN Android-removed: Appeared in 8u121-b13, not present in current code.
        /*
            // TODO: make this default when it's in the spec.
            if (data instanceof SortedMap) {
                for (String name : data.keySet()) {
                    if (text.regionMatches(true, start, name, 0, name.length())) {
                        calb.set(field, data.get(name));
                        return start + name.length();
                    }
                }
                return -start;
            }
            */
        // END Android-removed: Appeared in 8u121-b13, not present in current code.
        String bestMatch = null;
        for (String name : data.keySet()) {
            int length = name.length();
            if (bestMatch == null || length > bestMatch.length()) {
                if (text.regionMatches(true, start, name, 0, length)) {
                    bestMatch = name;
                }
            }
        }
        if (bestMatch != null) {
            calb.set(field, data.get(bestMatch));
            return start + bestMatch.length();
        }
    }
    return -start;
}
#method_after
private int matchString(String text, int start, int field, Map<String, Integer> data, CalendarBuilder calb) {
    if (data != null) {
        // BEGIN Android-removed: SortedMap instance lookup optimization in matchString().
        // RI returns not the longest match as matchString(String[]) does. http://b/119913354
        /*
            // TODO: make this default when it's in the spec.
            if (data instanceof SortedMap) {
                for (String name : data.keySet()) {
                    if (text.regionMatches(true, start, name, 0, name.length())) {
                        calb.set(field, data.get(name));
                        return start + name.length();
                    }
                }
                return -start;
            }
            */
        // END Android-removed: SortedMap instance lookup optimization in matchString().
        String bestMatch = null;
        for (String name : data.keySet()) {
            int length = name.length();
            if (bestMatch == null || length > bestMatch.length()) {
                if (text.regionMatches(true, start, name, 0, length)) {
                    bestMatch = name;
                }
            }
        }
        if (bestMatch != null) {
            calb.set(field, data.get(bestMatch));
            return start + bestMatch.length();
        }
    }
    return -start;
}
#end_block

#method_before
private int subParseNumericZone(String text, int start, int sign, int count, boolean colonRequired, CalendarBuilder calb) {
    int index = start;
    parse: try {
        char c = text.charAt(index++);
        // Parse hh
        int hours;
        if (!isDigit(c)) {
            break parse;
        }
        hours = c - '0';
        c = text.charAt(index++);
        if (isDigit(c)) {
            hours = hours * 10 + (c - '0');
        } else {
            // BEGIN Android-removed: Appeared in 8u121-b13, not present in current code.
            /*
                // If no colon in RFC 822 or 'X' (ISO), two digits are
                // required.
                if (count > 0 || !colon) {
                    break parse;
                }
                */
            // END Android-removed: Appeared in 8u121-b13, not present in current code.
            --index;
        }
        if (hours > 23) {
            break parse;
        }
        int minutes = 0;
        if (count != 1) {
            // Proceed with parsing mm
            c = text.charAt(index++);
            /*
                if (colon) {
                    if (c != ':') {
                        break parse;
                    }
                */
            if (c == ':') {
                c = text.charAt(index++);
            } else if (colonRequired) {
                break parse;
            }
            // END Android-changed: Intentional change in behavior from OpenJDK.
            if (!isDigit(c)) {
                break parse;
            }
            minutes = c - '0';
            c = text.charAt(index++);
            if (!isDigit(c)) {
                break parse;
            }
            minutes = minutes * 10 + (c - '0');
            if (minutes > 59) {
                break parse;
            }
        }
        minutes += hours * 60;
        calb.set(Calendar.ZONE_OFFSET, minutes * MILLIS_PER_MINUTE * sign).set(Calendar.DST_OFFSET, 0);
        return index;
    } catch (IndexOutOfBoundsException e) {
    }
    // -(index - 1)
    return 1 - index;
}
#method_after
private int subParseNumericZone(String text, int start, int sign, int count, boolean colon, CalendarBuilder calb) {
    int index = start;
    parse: try {
        char c = text.charAt(index++);
        // Parse hh
        int hours;
        if (!isDigit(c)) {
            break parse;
        }
        hours = c - '0';
        c = text.charAt(index++);
        if (isDigit(c)) {
            hours = hours * 10 + (c - '0');
        } else {
            // BEGIN Android-removed: Be more tolerant of colon. b/26426526
            /*
                // If no colon in RFC 822 or 'X' (ISO), two digits are
                // required.
                if (count > 0 || !colon) {
                    break parse;
                }
                */
            // END Android-removed: Be more tolerant of colon. b/26426526
            --index;
        }
        if (hours > 23) {
            break parse;
        }
        int minutes = 0;
        if (count != 1) {
            // Proceed with parsing mm
            c = text.charAt(index++);
            /*
                if (colon) {
                    if (c != ':') {
                        break parse;
                    }
                */
            if (c == ':') {
                c = text.charAt(index++);
            } else if (colon) {
                break parse;
            }
            // END Android-changed: Be more tolerant of colon. b/26426526
            if (!isDigit(c)) {
                break parse;
            }
            minutes = c - '0';
            c = text.charAt(index++);
            if (!isDigit(c)) {
                break parse;
            }
            minutes = minutes * 10 + (c - '0');
            if (minutes > 59) {
                break parse;
            }
        }
        minutes += hours * 60;
        calb.set(Calendar.ZONE_OFFSET, minutes * MILLIS_PER_MINUTE * sign).set(Calendar.DST_OFFSET, 0);
        return index;
    } catch (IndexOutOfBoundsException e) {
    }
    // -(index - 1)
    return 1 - index;
}
#end_block

#method_before
private int subParse(String text, int start, int patternCharIndex, int count, boolean obeyCount, boolean[] ambiguousYear, ParsePosition origPos, boolean useFollowingMinusSignAsDelimiter, CalendarBuilder calb) {
    Number number;
    int value = 0;
    ParsePosition pos = new ParsePosition(0);
    pos.index = start;
    if (patternCharIndex == PATTERN_WEEK_YEAR && !calendar.isWeekDateSupported()) {
        // use calendar year 'y' instead
        patternCharIndex = PATTERN_YEAR;
    }
    int field = PATTERN_INDEX_TO_CALENDAR_FIELD[patternCharIndex];
    // of the string, then fail.
    for (; ; ) {
        if (pos.index >= text.length()) {
            origPos.errorIndex = start;
            return -1;
        }
        char c = text.charAt(pos.index);
        if (c != ' ' && c != '\t') {
            break;
        }
        ++pos.index;
    }
    parsing: {
        // the parsed value.
        if (patternCharIndex == PATTERN_HOUR_OF_DAY1 || patternCharIndex == PATTERN_HOUR1 || (patternCharIndex == PATTERN_MONTH && count <= 2) || patternCharIndex == PATTERN_YEAR || patternCharIndex == PATTERN_WEEK_YEAR) {
            // but that's going to be difficult.
            if (obeyCount) {
                if ((start + count) > text.length()) {
                    break parsing;
                }
                number = numberFormat.parse(text.substring(0, start + count), pos);
            } else {
                number = numberFormat.parse(text, pos);
            }
            if (number == null) {
                if (patternCharIndex != PATTERN_YEAR || calendar instanceof GregorianCalendar) {
                    break parsing;
                }
            } else {
                value = number.intValue();
                if (useFollowingMinusSignAsDelimiter && (value < 0) && (((pos.index < text.length()) && (text.charAt(pos.index) != minusSign)) || ((pos.index == text.length()) && (text.charAt(pos.index - 1) == minusSign)))) {
                    value = -value;
                    pos.index--;
                }
            }
        }
        boolean useDateFormatSymbols = useDateFormatSymbols();
        int index;
        switch(patternCharIndex) {
            case // 'G'
            PATTERN_ERA:
                if (useDateFormatSymbols) {
                    if ((index = matchString(text, start, Calendar.ERA, formatData.getEras(), calb)) > 0) {
                        return index;
                    }
                } else {
                    // BEGIN Android-changed: Remove helper methods after extracting formatMonth().
                    /*
                    Map<String, Integer> map = getDisplayNamesMap(field, locale);
                    */
                    Map<String, Integer> map = calendar.getDisplayNames(field, Calendar.ALL_STYLES, locale);
                    // END Android-changed: Remove helper methods after extracting formatMonth().
                    if ((index = matchString(text, start, field, map, calb)) > 0) {
                        return index;
                    }
                }
                break parsing;
            // 'Y'
            case PATTERN_WEEK_YEAR:
            case // 'y'
            PATTERN_YEAR:
                if (!(calendar instanceof GregorianCalendar)) {
                    // calendar might have text representations for year values,
                    // such as "\u5143" in JapaneseImperialCalendar.
                    int style = (count >= 4) ? Calendar.LONG : Calendar.SHORT;
                    Map<String, Integer> map = calendar.getDisplayNames(field, style, locale);
                    if (map != null) {
                        if ((index = matchString(text, start, field, map, calb)) > 0) {
                            return index;
                        }
                    }
                    calb.set(field, value);
                    return pos.index;
                }
                // is treated literally:  "2250", "-1", "1", "002".
                if (count <= 2 && (pos.index - start) == 2 && Character.isDigit(text.charAt(start)) && Character.isDigit(text.charAt(start + 1))) {
                    // Assume for example that the defaultCenturyStart is 6/18/1903.
                    // This means that two-digit years will be forced into the range
                    // 6/18/1903 to 6/17/2003.  As a result, years 00, 01, and 02
                    // correspond to 2000, 2001, and 2002.  Years 04, 05, etc. correspond
                    // to 1904, 1905, etc.  If the year is 03, then it is 2003 if the
                    // other fields specify a date before 6/18, or 1903 if they specify a
                    // date afterwards.  As a result, 03 is an ambiguous year.  All other
                    // two-digit years are unambiguous.
                    int ambiguousTwoDigitYear = defaultCenturyStartYear % 100;
                    ambiguousYear[0] = value == ambiguousTwoDigitYear;
                    value += (defaultCenturyStartYear / 100) * 100 + (value < ambiguousTwoDigitYear ? 100 : 0);
                }
                calb.set(field, value);
                return pos.index;
            case // 'M'
            PATTERN_MONTH:
                // BEGIN Android-changed: extract parseMonth method.
                /*
                if (count <= 2) // i.e., M or MM.
                {
                    // Don't want to parse the month if it is a string
                    // while pattern uses numeric style: M or MM.
                    // [We computed 'value' above.]
                    calb.set(Calendar.MONTH, value - 1);
                    return pos.index;
                }

                if (useDateFormatSymbols) {
                    // count >= 3 // i.e., MMM or MMMM
                    // Want to be able to parse both short and long forms.
                    // Try count == 4 first:
                    int newStart;
                    if ((newStart = matchString(text, start, Calendar.MONTH,
                                                formatData.getMonths(), calb)) > 0) {
                        return newStart;
                    }
                    // count == 4 failed, now try count == 3
                    if ((index = matchString(text, start, Calendar.MONTH,
                                             formatData.getShortMonths(), calb)) > 0) {
                        return index;
                    }
                } else {
                    Map<String, Integer> map = getDisplayNamesMap(field, locale);
                    if ((index = matchString(text, start, field, map, calb)) > 0) {
                        return index;
                    }
                }
            */
                {
                    final int idx = parseMonth(text, count, value, start, field, pos, useDateFormatSymbols, false, /* isStandalone */
                    calb);
                    if (idx > 0) {
                        return idx;
                    }
                    break parsing;
                }
            case // 'L'.
            PATTERN_MONTH_STANDALONE:
                {
                    final int idx = parseMonth(text, count, value, start, field, pos, useDateFormatSymbols, true, /* isStandalone */
                    calb);
                    if (idx > 0) {
                        return idx;
                    }
                    break parsing;
                }
            case // 'k' 1-based.  eg, 23:59 + 1 hour =>> 24:59
            PATTERN_HOUR_OF_DAY1:
                if (!isLenient()) {
                    // Validate the hour value in non-lenient
                    if (value < 1 || value > 24) {
                        break parsing;
                    }
                }
                // [We computed 'value' above.]
                if (value == calendar.getMaximum(Calendar.HOUR_OF_DAY) + 1) {
                    value = 0;
                }
                calb.set(Calendar.HOUR_OF_DAY, value);
                return pos.index;
            case // 'E'
            PATTERN_DAY_OF_WEEK:
                // BEGIN Android-changed: extract parseWeekday method.
                /*
                {
                    if (useDateFormatSymbols) {
                        // Want to be able to parse both short and long forms.
                        // Try count == 4 (DDDD) first:
                        int newStart;
                        if ((newStart=matchString(text, start, Calendar.DAY_OF_WEEK,
                                                  formatData.getWeekdays(), calb)) > 0) {
                            return newStart;
                        }
                        // DDDD failed, now try DDD
                        if ((index = matchString(text, start, Calendar.DAY_OF_WEEK,
                                                 formatData.getShortWeekdays(), calb)) > 0) {
                            return index;
                        }
                    } else {
                        int[] styles = { Calendar.LONG, Calendar.SHORT };
                        for (int style : styles) {
                            Map<String,Integer> map = calendar.getDisplayNames(field, style, locale);
                            if ((index = matchString(text, start, field, map, calb)) > 0) {
                                return index;
                            }
                        }
                    }
                }
            */
                {
                    final int idx = parseWeekday(text, start, field, useDateFormatSymbols, false, /* standalone */
                    calb);
                    if (idx > 0) {
                        return idx;
                    }
                    break parsing;
                }
            // BEGIN Android-added: support for 'c' (standalone day of week).
            case // 'c'
            PATTERN_STANDALONE_DAY_OF_WEEK:
                {
                    final int idx = parseWeekday(text, start, field, useDateFormatSymbols, true, /* standalone */
                    calb);
                    if (idx > 0) {
                        return idx;
                    }
                    break parsing;
                }
            case // 'a'
            PATTERN_AM_PM:
                if (useDateFormatSymbols) {
                    if ((index = matchString(text, start, Calendar.AM_PM, formatData.getAmPmStrings(), calb)) > 0) {
                        return index;
                    }
                } else {
                    // Android-changed:
                    // Map<String,Integer> map = getDisplayNamesMap(field, locale);
                    Map<String, Integer> map = calendar.getDisplayNames(field, Calendar.ALL_STYLES, locale);
                    if ((index = matchString(text, start, field, map, calb)) > 0) {
                        return index;
                    }
                }
                break parsing;
            case // 'h' 1-based.  eg, 11PM + 1 hour =>> 12 AM
            PATTERN_HOUR1:
                if (!isLenient()) {
                    // Validate the hour value in non-lenient
                    if (value < 1 || value > 12) {
                        break parsing;
                    }
                }
                // [We computed 'value' above.]
                if (value == calendar.getLeastMaximum(Calendar.HOUR) + 1) {
                    value = 0;
                }
                calb.set(Calendar.HOUR, value);
                return pos.index;
            // 'z'
            case PATTERN_ZONE_NAME:
            case // 'Z'
            PATTERN_ZONE_VALUE:
                {
                    int sign = 0;
                    try {
                        char c = text.charAt(pos.index);
                        if (c == '+') {
                            sign = 1;
                        } else if (c == '-') {
                            sign = -1;
                        }
                        if (sign == 0) {
                            // Try parsing a custom time zone "GMT+hh:mm" or "GMT".
                            if ((c == 'G' || c == 'g') && (text.length() - start) >= GMT.length() && text.regionMatches(true, start, GMT, 0, GMT.length())) {
                                pos.index = start + GMT.length();
                                if ((text.length() - pos.index) > 0) {
                                    c = text.charAt(pos.index);
                                    if (c == '+') {
                                        sign = 1;
                                    } else if (c == '-') {
                                        sign = -1;
                                    }
                                }
                                if (sign == 0) {
                                    /* "GMT" without offset */
                                    calb.set(Calendar.ZONE_OFFSET, 0).set(Calendar.DST_OFFSET, 0);
                                    return pos.index;
                                }
                                // BEGIN Android-changed: tolerate colon in zone offset.
                                /*
                                // Parse the rest as "hh:mm"
                                int i = subParseNumericZone(text, ++pos.index,
                                                            sign, 0, true, calb);
                                */
                                // Parse the rest as "hh[:]?mm"
                                int i = subParseNumericZone(text, ++pos.index, sign, 0, false, calb);
                                // END Android-changed: tolerate colon in zone offset.
                                if (i > 0) {
                                    return i;
                                }
                                pos.index = -i;
                            } else {
                                // Try parsing the text as a time zone
                                // name or abbreviation.
                                int i = subParseZoneString(text, pos.index, calb);
                                if (i > 0) {
                                    return i;
                                }
                                pos.index = -i;
                            }
                        } else {
                            // BEGIN Android-changed: tolerate colon in zone offset.
                            // Parse the rest as "hh[:]?mm" (RFC 822)
                            /*
                            // Parse the rest as "hhmm" (RFC 822)
                            int i = subParseNumericZone(text, ++pos.index,
                                                        sign, 0, false, calb);
                            */
                            int i = subParseNumericZone(text, ++pos.index, sign, 0, false, calb);
                            // END Android-changed: tolerate colon in zone offset.
                            if (i > 0) {
                                return i;
                            }
                            pos.index = -i;
                        }
                    } catch (IndexOutOfBoundsException e) {
                    }
                }
                break parsing;
            case // 'X'
            PATTERN_ISO_ZONE:
                {
                    if ((text.length() - pos.index) <= 0) {
                        break parsing;
                    }
                    int sign;
                    char c = text.charAt(pos.index);
                    if (c == 'Z') {
                        calb.set(Calendar.ZONE_OFFSET, 0).set(Calendar.DST_OFFSET, 0);
                        return ++pos.index;
                    }
                    // parse text as "+/-hh[[:]mm]" based on count
                    if (c == '+') {
                        sign = 1;
                    } else if (c == '-') {
                        sign = -1;
                    } else {
                        ++pos.index;
                        break parsing;
                    }
                    int i = subParseNumericZone(text, ++pos.index, sign, count, count == 3, calb);
                    if (i > 0) {
                        return i;
                    }
                    pos.index = -i;
                }
                break parsing;
            default:
                // case PATTERN_DAY_OF_MONTH:         // 'd'
                // case PATTERN_HOUR_OF_DAY0:         // 'H' 0-based.  eg, 23:59 + 1 hour =>> 00:59
                // case PATTERN_MINUTE:               // 'm'
                // case PATTERN_SECOND:               // 's'
                // case PATTERN_MILLISECOND:          // 'S'
                // case PATTERN_DAY_OF_YEAR:          // 'D'
                // case PATTERN_DAY_OF_WEEK_IN_MONTH: // 'F'
                // case PATTERN_WEEK_OF_YEAR:         // 'w'
                // case PATTERN_WEEK_OF_MONTH:        // 'W'
                // case PATTERN_HOUR0:                // 'K' 0-based.  eg, 11PM + 1 hour =>> 0 AM
                // case PATTERN_ISO_DAY_OF_WEEK:      // 'u' (pseudo field);
                // Handle "generic" fields
                // BEGIN Android-changed: Better UTS#35 conformity for fractional seconds.
                int parseStart = pos.getIndex();
                // END Android-changed: Better UTS#35 conformity for fractional seconds.
                if (obeyCount) {
                    if ((start + count) > text.length()) {
                        break parsing;
                    }
                    number = numberFormat.parse(text.substring(0, start + count), pos);
                } else {
                    number = numberFormat.parse(text, pos);
                }
                if (number != null) {
                    /*
                    value = number.intValue();
                    */
                    if (patternCharIndex == PATTERN_MILLISECOND) {
                        // Fractional seconds must be treated specially. We must always
                        // normalize them to their fractional second value [0, 1) before we attempt
                        // to parse them.
                        // 
                        // Case 1: 11.78 seconds is 11 seconds and 780 (not 78) milliseconds.
                        // Case 2: 11.7890567 seconds is 11 seconds and 789 (not 7890567) milliseconds.
                        double doubleValue = number.doubleValue();
                        int width = pos.getIndex() - parseStart;
                        final double divisor = Math.pow(10, width);
                        value = (int) ((doubleValue / divisor) * 1000);
                    } else {
                        value = number.intValue();
                    }
                    if (useFollowingMinusSignAsDelimiter && (value < 0) && (((pos.index < text.length()) && (text.charAt(pos.index) != minusSign)) || ((pos.index == text.length()) && (text.charAt(pos.index - 1) == minusSign)))) {
                        value = -value;
                        pos.index--;
                    }
                    calb.set(field, value);
                    return pos.index;
                }
                break parsing;
        }
    }
    // Parsing failed.
    origPos.errorIndex = pos.index;
    return -1;
}
#method_after
private int subParse(String text, int start, int patternCharIndex, int count, boolean obeyCount, boolean[] ambiguousYear, ParsePosition origPos, boolean useFollowingMinusSignAsDelimiter, CalendarBuilder calb) {
    Number number;
    int value = 0;
    ParsePosition pos = new ParsePosition(0);
    pos.index = start;
    if (patternCharIndex == PATTERN_WEEK_YEAR && !calendar.isWeekDateSupported()) {
        // use calendar year 'y' instead
        patternCharIndex = PATTERN_YEAR;
    }
    int field = PATTERN_INDEX_TO_CALENDAR_FIELD[patternCharIndex];
    // of the string, then fail.
    for (; ; ) {
        if (pos.index >= text.length()) {
            origPos.errorIndex = start;
            return -1;
        }
        char c = text.charAt(pos.index);
        if (c != ' ' && c != '\t') {
            break;
        }
        ++pos.index;
    }
    // Remember the actual start index
    int actualStart = pos.index;
    parsing: {
        // the parsed value.
        if (patternCharIndex == PATTERN_HOUR_OF_DAY1 || patternCharIndex == PATTERN_HOUR1 || (patternCharIndex == PATTERN_MONTH && count <= 2) || patternCharIndex == PATTERN_YEAR || patternCharIndex == PATTERN_WEEK_YEAR) {
            // but that's going to be difficult.
            if (obeyCount) {
                if ((start + count) > text.length()) {
                    break parsing;
                }
                number = numberFormat.parse(text.substring(0, start + count), pos);
            } else {
                number = numberFormat.parse(text, pos);
            }
            if (number == null) {
                if (patternCharIndex != PATTERN_YEAR || calendar instanceof GregorianCalendar) {
                    break parsing;
                }
            } else {
                value = number.intValue();
                if (useFollowingMinusSignAsDelimiter && (value < 0) && (((pos.index < text.length()) && (text.charAt(pos.index) != minusSign)) || ((pos.index == text.length()) && (text.charAt(pos.index - 1) == minusSign)))) {
                    value = -value;
                    pos.index--;
                }
            }
        }
        boolean useDateFormatSymbols = useDateFormatSymbols();
        int index;
        switch(patternCharIndex) {
            case // 'G'
            PATTERN_ERA:
                if (useDateFormatSymbols) {
                    if ((index = matchString(text, start, Calendar.ERA, formatData.getEras(), calb)) > 0) {
                        return index;
                    }
                } else {
                    Map<String, Integer> map = calendar.getDisplayNames(field, Calendar.ALL_STYLES, locale);
                    if ((index = matchString(text, start, field, map, calb)) > 0) {
                        return index;
                    }
                }
                break parsing;
            // 'Y'
            case PATTERN_WEEK_YEAR:
            case // 'y'
            PATTERN_YEAR:
                if (!(calendar instanceof GregorianCalendar)) {
                    // calendar might have text representations for year values,
                    // such as "\u5143" in JapaneseImperialCalendar.
                    int style = (count >= 4) ? Calendar.LONG : Calendar.SHORT;
                    Map<String, Integer> map = calendar.getDisplayNames(field, style, locale);
                    if (map != null) {
                        if ((index = matchString(text, start, field, map, calb)) > 0) {
                            return index;
                        }
                    }
                    calb.set(field, value);
                    return pos.index;
                }
                // is treated literally:  "2250", "-1", "1", "002".
                if (count <= 2 && (pos.index - actualStart) == 2 && Character.isDigit(text.charAt(actualStart)) && Character.isDigit(text.charAt(actualStart + 1))) {
                    // Assume for example that the defaultCenturyStart is 6/18/1903.
                    // This means that two-digit years will be forced into the range
                    // 6/18/1903 to 6/17/2003.  As a result, years 00, 01, and 02
                    // correspond to 2000, 2001, and 2002.  Years 04, 05, etc. correspond
                    // to 1904, 1905, etc.  If the year is 03, then it is 2003 if the
                    // other fields specify a date before 6/18, or 1903 if they specify a
                    // date afterwards.  As a result, 03 is an ambiguous year.  All other
                    // two-digit years are unambiguous.
                    int ambiguousTwoDigitYear = defaultCenturyStartYear % 100;
                    ambiguousYear[0] = value == ambiguousTwoDigitYear;
                    value += (defaultCenturyStartYear / 100) * 100 + (value < ambiguousTwoDigitYear ? 100 : 0);
                }
                calb.set(field, value);
                return pos.index;
            case // 'M'
            PATTERN_MONTH:
                // BEGIN Android-changed: extract parseMonth method.
                /*
                if (count <= 2) // i.e., M or MM.
                {
                    // Don't want to parse the month if it is a string
                    // while pattern uses numeric style: M or MM.
                    // [We computed 'value' above.]
                    calb.set(Calendar.MONTH, value - 1);
                    return pos.index;
                }

                if (useDateFormatSymbols) {
                    // count >= 3 // i.e., MMM or MMMM
                    // Want to be able to parse both short and long forms.
                    // Try count == 4 first:
                    int newStart;
                    if ((newStart = matchString(text, start, Calendar.MONTH,
                                                formatData.getMonths(), calb)) > 0) {
                        return newStart;
                    }
                    // count == 4 failed, now try count == 3
                    if ((index = matchString(text, start, Calendar.MONTH,
                                             formatData.getShortMonths(), calb)) > 0) {
                        return index;
                    }
                } else {
                    Map<String, Integer> map = getDisplayNamesMap(field, locale);
                    if ((index = matchString(text, start, field, map, calb)) > 0) {
                        return index;
                    }
                }
            */
                {
                    final int idx = parseMonth(text, count, value, start, field, pos, useDateFormatSymbols, false, /* isStandalone */
                    calb);
                    if (idx > 0) {
                        return idx;
                    }
                    break parsing;
                }
            case // 'L'.
            PATTERN_MONTH_STANDALONE:
                {
                    final int idx = parseMonth(text, count, value, start, field, pos, useDateFormatSymbols, true, /* isStandalone */
                    calb);
                    if (idx > 0) {
                        return idx;
                    }
                    break parsing;
                }
            case // 'k' 1-based.  eg, 23:59 + 1 hour =>> 24:59
            PATTERN_HOUR_OF_DAY1:
                if (!isLenient()) {
                    // Validate the hour value in non-lenient
                    if (value < 1 || value > 24) {
                        break parsing;
                    }
                }
                // [We computed 'value' above.]
                if (value == calendar.getMaximum(Calendar.HOUR_OF_DAY) + 1) {
                    value = 0;
                }
                calb.set(Calendar.HOUR_OF_DAY, value);
                return pos.index;
            case // 'E'
            PATTERN_DAY_OF_WEEK:
                // BEGIN Android-changed: extract parseWeekday method.
                /*
                {
                    if (useDateFormatSymbols) {
                        // Want to be able to parse both short and long forms.
                        // Try count == 4 (DDDD) first:
                        int newStart;
                        if ((newStart=matchString(text, start, Calendar.DAY_OF_WEEK,
                                                  formatData.getWeekdays(), calb)) > 0) {
                            return newStart;
                        }
                        // DDDD failed, now try DDD
                        if ((index = matchString(text, start, Calendar.DAY_OF_WEEK,
                                                 formatData.getShortWeekdays(), calb)) > 0) {
                            return index;
                        }
                    } else {
                        int[] styles = { Calendar.LONG, Calendar.SHORT };
                        for (int style : styles) {
                            Map<String,Integer> map = calendar.getDisplayNames(field, style, locale);
                            if ((index = matchString(text, start, field, map, calb)) > 0) {
                                return index;
                            }
                        }
                    }
                }
            */
                {
                    final int idx = parseWeekday(text, start, field, useDateFormatSymbols, false, /* standalone */
                    calb);
                    if (idx > 0) {
                        return idx;
                    }
                    break parsing;
                }
            // BEGIN Android-added: support for 'c' (standalone day of week).
            case // 'c'
            PATTERN_STANDALONE_DAY_OF_WEEK:
                {
                    final int idx = parseWeekday(text, start, field, useDateFormatSymbols, true, /* standalone */
                    calb);
                    if (idx > 0) {
                        return idx;
                    }
                    break parsing;
                }
            case // 'a'
            PATTERN_AM_PM:
                if (useDateFormatSymbols) {
                    if ((index = matchString(text, start, Calendar.AM_PM, formatData.getAmPmStrings(), calb)) > 0) {
                        return index;
                    }
                } else {
                    Map<String, Integer> map = calendar.getDisplayNames(field, Calendar.ALL_STYLES, locale);
                    if ((index = matchString(text, start, field, map, calb)) > 0) {
                        return index;
                    }
                }
                break parsing;
            case // 'h' 1-based.  eg, 11PM + 1 hour =>> 12 AM
            PATTERN_HOUR1:
                if (!isLenient()) {
                    // Validate the hour value in non-lenient
                    if (value < 1 || value > 12) {
                        break parsing;
                    }
                }
                // [We computed 'value' above.]
                if (value == calendar.getLeastMaximum(Calendar.HOUR) + 1) {
                    value = 0;
                }
                calb.set(Calendar.HOUR, value);
                return pos.index;
            // 'z'
            case PATTERN_ZONE_NAME:
            case // 'Z'
            PATTERN_ZONE_VALUE:
                {
                    int sign = 0;
                    try {
                        char c = text.charAt(pos.index);
                        if (c == '+') {
                            sign = 1;
                        } else if (c == '-') {
                            sign = -1;
                        }
                        if (sign == 0) {
                            // Try parsing a custom time zone "GMT+hh:mm" or "GMT".
                            if ((c == 'G' || c == 'g') && (text.length() - start) >= GMT.length() && text.regionMatches(true, start, GMT, 0, GMT.length())) {
                                pos.index = start + GMT.length();
                                if ((text.length() - pos.index) > 0) {
                                    c = text.charAt(pos.index);
                                    if (c == '+') {
                                        sign = 1;
                                    } else if (c == '-') {
                                        sign = -1;
                                    }
                                }
                                if (sign == 0) {
                                    /* "GMT" without offset */
                                    calb.set(Calendar.ZONE_OFFSET, 0).set(Calendar.DST_OFFSET, 0);
                                    return pos.index;
                                }
                                // BEGIN Android-changed: Be more tolerant of colon. b/26426526
                                /*
                                // Parse the rest as "hh:mm"
                                int i = subParseNumericZone(text, ++pos.index,
                                                            sign, 0, true, calb);
                                */
                                // Parse the rest as "hh[:]?mm"
                                int i = subParseNumericZone(text, ++pos.index, sign, 0, false, calb);
                                // END Android-changed: Be more tolerant of colon. b/26426526
                                if (i > 0) {
                                    return i;
                                }
                                pos.index = -i;
                            } else {
                                // Try parsing the text as a time zone
                                // name or abbreviation.
                                int i = subParseZoneString(text, pos.index, calb);
                                if (i > 0) {
                                    return i;
                                }
                                pos.index = -i;
                            }
                        } else {
                            // BEGIN Android-changed: Be more tolerant of colon. b/26426526
                            // Parse the rest as "hh[:]?mm" (RFC 822)
                            /*
                            // Parse the rest as "hhmm" (RFC 822)
                            int i = subParseNumericZone(text, ++pos.index,
                                                        sign, 0, false, calb);
                            */
                            int i = subParseNumericZone(text, ++pos.index, sign, 0, false, calb);
                            // END Android-changed: Be more tolerant of colon. b/26426526
                            if (i > 0) {
                                return i;
                            }
                            pos.index = -i;
                        }
                    } catch (IndexOutOfBoundsException e) {
                    }
                }
                break parsing;
            case // 'X'
            PATTERN_ISO_ZONE:
                {
                    if ((text.length() - pos.index) <= 0) {
                        break parsing;
                    }
                    int sign;
                    char c = text.charAt(pos.index);
                    if (c == 'Z') {
                        calb.set(Calendar.ZONE_OFFSET, 0).set(Calendar.DST_OFFSET, 0);
                        return ++pos.index;
                    }
                    // parse text as "+/-hh[[:]mm]" based on count
                    if (c == '+') {
                        sign = 1;
                    } else if (c == '-') {
                        sign = -1;
                    } else {
                        ++pos.index;
                        break parsing;
                    }
                    int i = subParseNumericZone(text, ++pos.index, sign, count, count == 3, calb);
                    if (i > 0) {
                        return i;
                    }
                    pos.index = -i;
                }
                break parsing;
            default:
                // case PATTERN_DAY_OF_MONTH:         // 'd'
                // case PATTERN_HOUR_OF_DAY0:         // 'H' 0-based.  eg, 23:59 + 1 hour =>> 00:59
                // case PATTERN_MINUTE:               // 'm'
                // case PATTERN_SECOND:               // 's'
                // case PATTERN_MILLISECOND:          // 'S'
                // case PATTERN_DAY_OF_YEAR:          // 'D'
                // case PATTERN_DAY_OF_WEEK_IN_MONTH: // 'F'
                // case PATTERN_WEEK_OF_YEAR:         // 'w'
                // case PATTERN_WEEK_OF_MONTH:        // 'W'
                // case PATTERN_HOUR0:                // 'K' 0-based.  eg, 11PM + 1 hour =>> 0 AM
                // case PATTERN_ISO_DAY_OF_WEEK:      // 'u' (pseudo field);
                // Handle "generic" fields
                // BEGIN Android-changed: Better UTS#35 conformity for fractional seconds.
                // http://b/25863120
                int parseStart = pos.getIndex();
                // END Android-changed: Better UTS#35 conformity for fractional seconds.
                if (obeyCount) {
                    if ((start + count) > text.length()) {
                        break parsing;
                    }
                    number = numberFormat.parse(text.substring(0, start + count), pos);
                } else {
                    number = numberFormat.parse(text, pos);
                }
                if (number != null) {
                    /*
                    value = number.intValue();
                    */
                    if (patternCharIndex == PATTERN_MILLISECOND) {
                        // Fractional seconds must be treated specially. We must always
                        // normalize them to their fractional second value [0, 1) before we attempt
                        // to parse them.
                        // 
                        // Case 1: 11.78 seconds is 11 seconds and 780 (not 78) milliseconds.
                        // Case 2: 11.7890567 seconds is 11 seconds and 789 (not 7890567) milliseconds.
                        double doubleValue = number.doubleValue();
                        int width = pos.getIndex() - parseStart;
                        final double divisor = Math.pow(10, width);
                        value = (int) ((doubleValue / divisor) * 1000);
                    } else {
                        value = number.intValue();
                    }
                    if (useFollowingMinusSignAsDelimiter && (value < 0) && (((pos.index < text.length()) && (text.charAt(pos.index) != minusSign)) || ((pos.index == text.length()) && (text.charAt(pos.index - 1) == minusSign)))) {
                        value = -value;
                        pos.index--;
                    }
                    calb.set(field, value);
                    return pos.index;
                }
                break parsing;
        }
    }
    // Parsing failed.
    origPos.errorIndex = pos.index;
    return -1;
}
#end_block

#method_before
private boolean useDateFormatSymbols() {
    /*
        return useDateFormatSymbols || locale == null;
        */
    if (useDateFormatSymbols) {
        return true;
    }
    return isGregorianCalendar() || locale == null;
}
#method_after
// END Android-added: parseMonth and parseWeekday methods to parse using ICU data.
// Android-changed: Always useDateFormatSymbols() for GregorianCalendar.
private boolean useDateFormatSymbols() {
    // return useDateFormatSymbols || locale == null;
    return useDateFormatSymbols || "java.util.GregorianCalendar".equals(calendar.getClass().getName()) || locale == null;
}
#end_block

#method_before
// END Android-changed: Add private helper isGregorianCalendar() for useDateFormatSymbols().
private String translatePattern(String pattern, String from, String to) {
    StringBuilder result = new StringBuilder();
    boolean inQuote = false;
    for (int i = 0; i < pattern.length(); ++i) {
        char c = pattern.charAt(i);
        if (inQuote) {
            if (c == '\'') {
                inQuote = false;
            }
        } else {
            if (c == '\'') {
                inQuote = true;
            } else if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')) {
                int ci = from.indexOf(c);
                if (ci >= 0) {
                    // unsupported by localPatternChars pass through.
                    if (ci < to.length()) {
                        c = to.charAt(ci);
                    }
                } else {
                    throw new IllegalArgumentException("Illegal pattern " + " character '" + c + "'");
                }
            }
        }
        result.append(c);
    }
    if (inQuote) {
        throw new IllegalArgumentException("Unfinished quote in pattern");
    }
    return result.toString();
}
#method_after
private String translatePattern(String pattern, String from, String to) {
    StringBuilder result = new StringBuilder();
    boolean inQuote = false;
    for (int i = 0; i < pattern.length(); ++i) {
        char c = pattern.charAt(i);
        if (inQuote) {
            if (c == '\'') {
                inQuote = false;
            }
        } else {
            if (c == '\'') {
                inQuote = true;
            } else if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')) {
                int ci = from.indexOf(c);
                if (ci >= 0) {
                    // unsupported by localPatternChars pass through.
                    if (ci < to.length()) {
                        c = to.charAt(ci);
                    }
                } else {
                    throw new IllegalArgumentException("Illegal pattern " + " character '" + c + "'");
                }
            }
        }
        result.append(c);
    }
    if (inQuote) {
        throw new IllegalArgumentException("Unfinished quote in pattern");
    }
    return result.toString();
}
#end_block

#method_before
public void applyPattern(String pattern) {
    // BEGIN Android-removed: Revert splitting to applyPattern() and applyPatternImpl().
    /*
        applyPatternImpl(pattern);
    }

    private void applyPatternImpl(String pattern) {
    */
    compiledPattern = compile(pattern);
    this.pattern = pattern;
}
#method_after
public void applyPattern(String pattern) {
    applyPatternImpl(pattern);
}
#end_block

#method_before
// END Android-removed: Revert splitting to applyPattern() and applyPatternImpl().
public void applyLocalizedPattern(String pattern) {
    String p = translatePattern(pattern, formatData.getLocalPatternChars(), DateFormatSymbols.patternChars);
    compiledPattern = compile(p);
    this.pattern = p;
}
#method_after
public void applyLocalizedPattern(String pattern) {
    String p = translatePattern(pattern, formatData.getLocalPatternChars(), DateFormatSymbols.patternChars);
    compiledPattern = compile(p);
    this.pattern = p;
}
#end_block

#method_before
// BEGIN Android-removed: Remove helper methods after extracting formatMonth().
/*
    private static final int[] REST_OF_STYLES = {
        Calendar.SHORT_STANDALONE, Calendar.LONG_FORMAT, Calendar.LONG_STANDALONE,
    };
    private Map<String, Integer> getDisplayNamesMap(int field, Locale locale) {
        Map<String, Integer> map = calendar.getDisplayNames(field, Calendar.SHORT_FORMAT, locale);
        // Get all SHORT and LONG styles (avoid NARROW styles).
        for (int style : REST_OF_STYLES) {
            Map<String, Integer> m = calendar.getDisplayNames(field, style, locale);
            if (m != null) {
                map.putAll(m);
            }
        }
        return map;
    }
    */
// END Android-removed: Remove helper methods after extracting formatMonth().
private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException {
    stream.defaultReadObject();
    try {
        compiledPattern = compile(pattern);
    } catch (Exception e) {
        throw new InvalidObjectException("invalid pattern");
    }
    if (serialVersionOnStream < 1) {
        // didn't have defaultCenturyStart field
        initializeDefaultCentury();
    } else {
        // fill in dependent transient field
        parseAmbiguousDatesAsAfter(defaultCenturyStart);
    }
    serialVersionOnStream = currentSerialVersion;
    // If the deserialized object has a SimpleTimeZone, try
    // to replace it with a ZoneInfo equivalent in order to
    // be compatible with the SimpleTimeZone-based
    // implementation as much as possible.
    TimeZone tz = getTimeZone();
    if (tz instanceof SimpleTimeZone) {
        String id = tz.getID();
        TimeZone zi = TimeZone.getTimeZone(id);
        if (zi != null && zi.hasSameRules(tz) && zi.getID().equals(id)) {
            setTimeZone(zi);
        }
    }
}
#method_after
private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException {
    stream.defaultReadObject();
    try {
        compiledPattern = compile(pattern);
    } catch (Exception e) {
        throw new InvalidObjectException("invalid pattern");
    }
    if (serialVersionOnStream < 1) {
        // didn't have defaultCenturyStart field
        initializeDefaultCentury();
    } else {
        // fill in dependent transient field
        parseAmbiguousDatesAsAfter(defaultCenturyStart);
    }
    serialVersionOnStream = currentSerialVersion;
    // If the deserialized object has a SimpleTimeZone, try
    // to replace it with a ZoneInfo equivalent in order to
    // be compatible with the SimpleTimeZone-based
    // implementation as much as possible.
    TimeZone tz = getTimeZone();
    if (tz instanceof SimpleTimeZone) {
        String id = tz.getID();
        TimeZone zi = TimeZone.getTimeZone(id);
        if (zi != null && zi.hasSameRules(tz) && zi.getID().equals(id)) {
            setTimeZone(zi);
        }
    }
}
#end_block

#method_before
@Test
public void testPostsNotifications() throws Throwable {
    TestableNotificationPressureRule rule = new TestableNotificationPressureRule();
    Statement testStatement = new Statement() {

        @Override
        public void evaluate() throws Throwable {
            // Assert that device posted new notifications.
            verify(rule.getNotificationHelper()).postNotifications(TEST_NOTIFICATION_COUNT);
        }
    };
    rule.apply(testStatement, Description.createTestDescription("clzz", "mthd")).evaluate();
    // Assert that all notifications are cancelled at the end of the test.
    verify(rule.getNotificationHelper()).cancelNotifications();
}
#method_after
@Test
public void testPostsNotifications() throws Throwable {
    TestableNotificationPressureRule rule = new TestableNotificationPressureRule();
    Statement testStatement = new Statement() {

        @Override
        public void evaluate() throws Throwable {
            // Assert that device posted new notifications.
            verify(rule.initNotificationHelper()).postNotifications(TEST_NOTIFICATION_COUNT);
        }
    };
    rule.apply(testStatement, Description.createTestDescription("clzz", "mthd")).evaluate();
    // Assert that all notifications are cancelled at the end of the test.
    verify(rule.initNotificationHelper()).cancelNotifications();
}
#end_block

#method_before
@Override
protected void starting(Description description) {
    sNotificationHelper.postNotifications(mNotificationCount);
}
#method_after
@Override
protected void starting(Description description) {
    mNotificationHelper.postNotifications(mNotificationCount);
}
#end_block

#method_before
@Override
protected void finished(Description description) {
    sNotificationHelper.cancelNotifications();
}
#method_after
@Override
protected void finished(Description description) {
    mNotificationHelper.cancelNotifications();
}
#end_block

#method_before
@Override
public int getVolumeControlStream() {
    if (Build.VERSION.SDK_INT >= 26) {
        return mAudioAttributes.getVolumeControlStream();
    }
    return AudioAttributesCompat.toVolumeStreamType(true, getFlags(), getUsage());
}
#method_after
@Override
public int getVolumeControlStream() {
    // TODO: address the framework change ag/4995785.
    return AudioAttributesCompat.toVolumeStreamType(true, getFlags(), getUsage());
}
#end_block

#method_before
@Test
@SmallTest
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.P)
public void testGetCurrentPosition() throws Exception {
    assertEquals(MediaPlayer.PLAYER_STATE_IDLE, mPlayer.getPlayerState());
    assertEquals(MediaPlayer.UNKNOWN_TIME, mPlayer.getCurrentPosition());
}
#method_after
@Test
@SmallTest
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.KITKAT)
public void testGetCurrentPosition() throws Exception {
    assertEquals(MediaPlayer.PLAYER_STATE_IDLE, mPlayer.getPlayerState());
    assertEquals(MediaPlayer.UNKNOWN_TIME, mPlayer.getCurrentPosition());
}
#end_block

#method_before
@Test
@SmallTest
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.P)
public void testGetBufferedPosition() throws Exception {
    assertEquals(MediaPlayer.PLAYER_STATE_IDLE, mPlayer.getPlayerState());
    assertEquals(MediaPlayer.UNKNOWN_TIME, mPlayer.getBufferedPosition());
}
#method_after
@Test
@SmallTest
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.KITKAT)
public void testGetBufferedPosition() throws Exception {
    assertEquals(MediaPlayer.PLAYER_STATE_IDLE, mPlayer.getPlayerState());
    assertEquals(MediaPlayer.UNKNOWN_TIME, mPlayer.getBufferedPosition());
}
#end_block

#method_before
@Test
@LargeTest
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.P)
public void testPlaybackFailsIfMedia2DataSourceThrows() throws Exception {
    final int resid = R.raw.video_480x360_mp4_h264_1350kbps_30fps_aac_stereo_192kbps_44100hz;
    MediaPlayer.PlayerCallback callback = new MediaPlayer.PlayerCallback() {

        @Override
        public void onError(MediaPlayer mp, MediaItem dsd, int what, int extra) {
            mOnErrorCalled.signal();
        }
    };
    mPlayer.registerPlayerCallback(mExecutor, callback);
    TestDataSourceCallback dataSource = TestDataSourceCallback.fromAssetFd(mResources.openRawResourceFd(resid));
    // Ensure that we throw after reading enough data for preparation to complete.
    dataSource.throwFromReadAtPosition(500_000);
    mPlayer.setMediaItem(new CallbackMediaItem.Builder(dataSource).build());
    mPlayer.prepare().get();
    mOnErrorCalled.reset();
    mPlayer.play();
    assertTrue(mOnErrorCalled.waitForSignal());
}
#method_after
@Test
@LargeTest
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.KITKAT)
public void testPlaybackFailsIfMedia2DataSourceThrows() throws Exception {
    final int resid = R.raw.video_480x360_mp4_h264_1350kbps_30fps_aac_stereo_192kbps_44100hz;
    MediaPlayer.PlayerCallback callback = new MediaPlayer.PlayerCallback() {

        @Override
        public void onError(MediaPlayer mp, MediaItem dsd, int what, int extra) {
            mOnErrorCalled.signal();
        }
    };
    mPlayer.registerPlayerCallback(mExecutor, callback);
    TestDataSourceCallback dataSource = TestDataSourceCallback.fromAssetFd(mResources.openRawResourceFd(resid));
    // Ensure that we throw after reading enough data for preparation to complete.
    dataSource.throwFromReadAtPosition(500_000);
    mPlayer.setMediaItem(new CallbackMediaItem.Builder(dataSource).build());
    mPlayer.prepare().get();
    mOnErrorCalled.reset();
    mPlayer.play();
    assertTrue(mOnErrorCalled.waitForSignal());
}
#end_block

#method_before
@Test
@LargeTest
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.P)
public void testPlaybackFailsIfMedia2DataSourceReturnsAnError() throws Exception {
    final int resid = R.raw.video_480x360_mp4_h264_1350kbps_30fps_aac_stereo_192kbps_44100hz;
    TestDataSourceCallback dataSource = TestDataSourceCallback.fromAssetFd(mResources.openRawResourceFd(resid));
    mPlayer.setMediaItem(new CallbackMediaItem.Builder(dataSource).build());
    MediaPlayer.PlayerCallback callback = new MediaPlayer.PlayerCallback() {

        @Override
        public void onError(MediaPlayer mp, MediaItem dsd, int what, int extra) {
            mOnErrorCalled.signal();
        }
    };
    mPlayer.registerPlayerCallback(mExecutor, callback);
    mPlayer.prepare().get();
    dataSource.returnFromReadAt(-2);
    mPlayer.play();
    assertTrue(mOnErrorCalled.waitForSignal());
}
#method_after
@Test
@LargeTest
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.KITKAT)
public void testPlaybackFailsIfMedia2DataSourceReturnsAnError() throws Exception {
    final int resid = R.raw.video_480x360_mp4_h264_1350kbps_30fps_aac_stereo_192kbps_44100hz;
    TestDataSourceCallback dataSource = TestDataSourceCallback.fromAssetFd(mResources.openRawResourceFd(resid));
    mPlayer.setMediaItem(new CallbackMediaItem.Builder(dataSource).build());
    MediaPlayer.PlayerCallback callback = new MediaPlayer.PlayerCallback() {

        @Override
        public void onError(MediaPlayer mp, MediaItem dsd, int what, int extra) {
            mOnErrorCalled.signal();
        }
    };
    mPlayer.registerPlayerCallback(mExecutor, callback);
    mPlayer.prepare().get();
    dataSource.returnFromReadAt(-2);
    mPlayer.play();
    assertTrue(mOnErrorCalled.waitForSignal());
}
#end_block

#method_before
public void setSlice(@Nullable Slice slice) {
    initSliceMetrics(slice);
    boolean isUpdate = slice != null && mCurrentSlice != null && slice.getUri().equals(mCurrentSlice.getUri());
    if (isUpdate) {
        // If its an update check the loading state
        SliceMetadata oldSliceData = SliceMetadata.from(getContext(), mCurrentSlice);
        SliceMetadata newSliceData = SliceMetadata.from(getContext(), slice);
        if (oldSliceData.getLoadingState() == SliceMetadata.LOADED_ALL && newSliceData.getLoadingState() == SliceMetadata.LOADED_NONE) {
            // ignore the update.
            return;
        }
    } else {
        mCurrentView.resetView();
    }
    mCurrentSlice = slice;
    mListContent = new ListContent(mCurrentSlice);
    if (mShowHeaderDivider) {
        showHeaderDivider(true);
    }
    if (mShowActionDividers) {
        showActionDividers(true);
    }
    if (!mListContent.isValid()) {
        mActions = null;
        mCurrentView.resetView();
        updateActions();
        return;
    }
    // New slice means we shouldn't have any actions loading
    mCurrentView.setLoadingActions(null);
    // Check if the slice content is expired and show when it was last updated
    mSliceMetadata = SliceMetadata.from(getContext(), mCurrentSlice);
    mActions = mSliceMetadata.getSliceActions();
    mCurrentView.setLastUpdated(mSliceMetadata.getLastUpdatedTime());
    mCurrentView.setShowLastUpdated(mShowLastUpdated && mSliceMetadata.isExpired());
    mCurrentView.setAllowTwoLines(mSliceMetadata.isPermissionSlice());
    // Tint color can come with the slice, so may need to update it
    mCurrentView.setTint(getTintColor());
    if (mListContent.getLayoutDir() != -1) {
        mCurrentView.setLayoutDirection(mListContent.getLayoutDir());
    } else {
        mCurrentView.setLayoutDirection(View.LAYOUT_DIRECTION_INHERIT);
    }
    // Set the slice
    mCurrentView.setSliceContent(mListContent);
    updateActions();
    // Log slice metrics visible.
    logSliceMetricsVisibilityChange(true);
    // Automatically refresh the last updated label when the slice TTL isn't infinity.
    refreshLastUpdatedLabel(true);
}
#method_after
public void setSlice(@Nullable Slice slice) {
    initSliceMetrics(slice);
    boolean isUpdate = slice != null && mCurrentSlice != null && slice.getUri().equals(mCurrentSlice.getUri());
    SliceMetadata oldSliceData = mSliceMetadata;
    mCurrentSlice = slice;
    mSliceMetadata = mCurrentSlice != null ? SliceMetadata.from(getContext(), mCurrentSlice) : null;
    if (isUpdate) {
        // If its an update check the loading state
        SliceMetadata newSliceData = mSliceMetadata;
        if (oldSliceData.getLoadingState() == SliceMetadata.LOADED_ALL && newSliceData.getLoadingState() == SliceMetadata.LOADED_NONE) {
            // ignore the update.
            return;
        }
    } else {
        mCurrentView.resetView();
    }
    mListContent = mSliceMetadata != null ? mSliceMetadata.getListContent() : null;
    if (mShowHeaderDivider) {
        showHeaderDivider(true);
    }
    if (mShowActionDividers) {
        showActionDividers(true);
    }
    if (mListContent == null || !mListContent.isValid()) {
        mActions = null;
        mCurrentView.resetView();
        updateActions();
        return;
    }
    // New slice means we shouldn't have any actions loading
    mCurrentView.setLoadingActions(null);
    // Check if the slice content is expired and show when it was last updated
    mActions = mSliceMetadata.getSliceActions();
    mCurrentView.setLastUpdated(mSliceMetadata.getLastUpdatedTime());
    mCurrentView.setShowLastUpdated(mShowLastUpdated && mSliceMetadata.isExpired());
    mCurrentView.setAllowTwoLines(mSliceMetadata.isPermissionSlice());
    // Tint color can come with the slice, so may need to update it
    mCurrentView.setTint(getTintColor());
    if (mListContent.getLayoutDir() != -1) {
        mCurrentView.setLayoutDirection(mListContent.getLayoutDir());
    } else {
        mCurrentView.setLayoutDirection(View.LAYOUT_DIRECTION_INHERIT);
    }
    // Set the slice
    mCurrentView.setSliceContent(mListContent);
    updateActions();
    // Log slice metrics visible.
    logSliceMetricsVisibilityChange(true);
    // Automatically refresh the last updated label when the slice TTL isn't infinity.
    refreshLastUpdatedLabel(true);
}
#end_block

#method_before
@Test
public void queryByCollection() {
    User[] users = TestUtil.createUsersArray(3, 5, 7, 9);
    mUserDao.insertAll(users);
    List<Integer> ids = Arrays.asList(3, 5, 7, 9);
    List<User> loadedUsers = mUserDao.loadByIds(ids);
    assertThat(loadedUsers, hasSize(4));
    assertThat(loadedUsers, hasItems(users));
}
#method_after
@Test
public void queryByCollection() {
    User[] users = TestUtil.createUsersArray(3, 5, 7, 9);
    mUserDao.insertAll(users);
    List<Integer> ids = Arrays.asList(3, 5, 7, 9);
    List<User> loadedUsers = mUserDao.loadByIdCollection(ids);
    assertThat(loadedUsers, hasSize(4));
    assertThat(loadedUsers, hasItems(users));
}
#end_block

#method_before
private void broadcast(Intent intent, Set<ComponentName> receivers, boolean wakeup) {
    final PackageManager packageManager = mPhone.getContext().getPackageManager();
    for (ComponentName name : receivers) {
        Intent signal = new Intent(intent);
        signal.setComponent(name);
        if (wakeup && packageManager.queryBroadcastReceivers(signal, PackageManager.MATCH_DEFAULT_ONLY).isEmpty()) {
            loge("Carrier signal receivers are configured but unavailable: " + signal.getComponent());
            return;
        }
        if (!wakeup && !packageManager.queryBroadcastReceivers(signal, PackageManager.MATCH_DEFAULT_ONLY).isEmpty()) {
            loge("Runtime signals shouldn't be configured in Manifest: " + signal.getComponent());
            return;
        }
        signal.putExtra(PhoneConstants.SUBSCRIPTION_KEY, mPhone.getSubId());
        signal.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);
        signal.addFlags(Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND);
        if (!wakeup)
            signal.setFlags(Intent.FLAG_EXCLUDE_STOPPED_PACKAGES);
        try {
            mPhone.getContext().sendBroadcastAsUser(signal, UserHandle.ALL);
            if (DBG) {
                log("Sending signal " + signal.getAction() + ((signal.getComponent() != null) ? " to the carrier signal receiver: " + signal.getComponent() : ""));
            }
        } catch (ActivityNotFoundException e) {
            loge("Send broadcast failed: " + e);
        }
    }
}
#method_after
private void broadcast(Intent intent, Set<ComponentName> receivers, boolean wakeup) {
    final PackageManager packageManager = mPhone.getContext().getPackageManager();
    for (ComponentName name : receivers) {
        Intent signal = new Intent(intent);
        signal.setComponent(name);
        if (wakeup && packageManager.queryBroadcastReceivers(signal, PackageManager.MATCH_DEFAULT_ONLY).isEmpty()) {
            loge("Carrier signal receivers are configured but unavailable: " + signal.getComponent());
            return;
        }
        if (!wakeup && !packageManager.queryBroadcastReceivers(signal, PackageManager.MATCH_DEFAULT_ONLY).isEmpty()) {
            loge("Runtime signals shouldn't be configured in Manifest: " + signal.getComponent());
            return;
        }
        signal.putExtra(PhoneConstants.SUBSCRIPTION_KEY, mPhone.getSubId());
        signal.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);
        if (!wakeup)
            signal.setFlags(Intent.FLAG_EXCLUDE_STOPPED_PACKAGES);
        try {
            mPhone.getContext().sendBroadcastAsUser(signal, UserHandle.ALL);
            if (DBG) {
                log("Sending signal " + signal.getAction() + ((signal.getComponent() != null) ? " to the carrier signal receiver: " + signal.getComponent() : ""));
            }
        } catch (ActivityNotFoundException e) {
            loge("Send broadcast failed: " + e);
        }
    }
}
#end_block

#method_before
public void run() {
    Log.i(LOG_TAG, "Staring looper thread");
    Looper.prepare();
    mHandler = new Handler();
    Looper.loop();
    Log.i(LOG_TAG, "Terminating looper thread");
}
#method_after
public void run() {
    Log.i(LOG_TAG, "Starting looper thread");
    Looper.prepare();
    mHandler = new Handler();
    Looper.loop();
    Log.i(LOG_TAG, "Terminating looper thread");
}
#end_block

#method_before
@Test
public void testRequiredSensorsForDrivingState() throws Exception {
    int[] supportedSensors = mCarSensorManager.getSupportedSensors();
    assertNotNull(supportedSensors);
    boolean foundSpeed = false;
    boolean foundGear = false;
    for (int sensor : supportedSensors) {
        if (sensor == CarSensorManager.SENSOR_TYPE_CAR_SPEED) {
            foundSpeed = true;
        } else if (sensor == CarSensorManager.SENSOR_TYPE_GEAR) {
            foundGear = true;
        }
        if (foundGear && foundSpeed) {
            break;
        }
    }
    assertTrue(foundGear && foundSpeed);
}
#method_after
@Test
// Enable when b/120125891 is fixed
@Ignore
public void testRequiredSensorsForDrivingState() throws Exception {
    int[] supportedSensors = mCarSensorManager.getSupportedSensors();
    assertNotNull(supportedSensors);
    boolean foundSpeed = false;
    boolean foundGear = false;
    for (int sensor : supportedSensors) {
        if (sensor == CarSensorManager.SENSOR_TYPE_CAR_SPEED) {
            foundSpeed = true;
        } else if (sensor == CarSensorManager.SENSOR_TYPE_GEAR) {
            foundGear = true;
        }
        if (foundGear && foundSpeed) {
            break;
        }
    }
    assertTrue(foundGear && foundSpeed);
}
#end_block

#method_before
@Test
public void testServiceDistractionOptimized() throws Exception {
    assertFalse(mCarPm.isServiceDistractionOptimized("com.basic.package", ""));
    assertTrue(mCarPm.isServiceDistractionOptimized("com.android.settings", "Any"));
    assertTrue(mCarPm.isServiceDistractionOptimized("com.android.settings", ""));
    assertTrue(mCarPm.isServiceDistractionOptimized("com.android.settings", null));
    try {
        mCarPm.isServiceDistractionOptimized(null, "Any");
        fail();
    } catch (IllegalArgumentException expected) {
    // Expected.
    }
}
#method_after
@Test
// Enable when b/120125891 is fixed
@Ignore
public void testServiceDistractionOptimized() throws Exception {
    assertFalse(mCarPm.isServiceDistractionOptimized("com.basic.package", ""));
    assertTrue(mCarPm.isServiceDistractionOptimized("com.android.settings", "Any"));
    assertTrue(mCarPm.isServiceDistractionOptimized("com.android.settings", ""));
    assertTrue(mCarPm.isServiceDistractionOptimized("com.android.settings", null));
    try {
        mCarPm.isServiceDistractionOptimized(null, "Any");
        fail();
    } catch (IllegalArgumentException expected) {
    // Expected.
    }
}
#end_block

#method_before
@NonNull
public static <F extends Fragment> FragmentScenario<F> launch(@NonNull Class<F> fragmentClass, @Nullable Bundle fragmentArgs, @Nullable FragmentFactory factory) {
    return launch(fragmentClass, fragmentArgs, factory, R.style.FragmentScenarioEmptyFragmentActivityTheme);
}
#method_after
@NonNull
public static <F extends Fragment> FragmentScenario<F> launch(@NonNull Class<F> fragmentClass, @Nullable Bundle fragmentArgs, @Nullable FragmentFactory factory) {
    return launch(fragmentClass, fragmentArgs, R.style.FragmentScenarioEmptyFragmentActivityTheme, factory);
}
#end_block

#method_before
@NonNull
public static <F extends Fragment> FragmentScenario<F> launch(@NonNull Class<F> fragmentClass, @Nullable Bundle fragmentArgs, @Nullable FragmentFactory factory, int themeResId) {
    return internalLaunch(fragmentClass, fragmentArgs, factory, /*containerViewId=*/
    0, themeResId);
}
#method_after
@NonNull
public static <F extends Fragment> FragmentScenario<F> launch(@NonNull Class<F> fragmentClass, @Nullable Bundle fragmentArgs, int themeResId, @Nullable FragmentFactory factory) {
    return internalLaunch(fragmentClass, fragmentArgs, themeResId, factory, /*containerViewId=*/
    0);
}
#end_block

#method_before
@NonNull
public static <F extends Fragment> FragmentScenario<F> launchInContainer(@NonNull Class<F> fragmentClass, @Nullable Bundle fragmentArgs, @Nullable FragmentFactory factory) {
    return launchInContainer(fragmentClass, fragmentArgs, factory, R.style.FragmentScenarioEmptyFragmentActivityTheme);
}
#method_after
@NonNull
public static <F extends Fragment> FragmentScenario<F> launchInContainer(@NonNull Class<F> fragmentClass, @Nullable Bundle fragmentArgs, @Nullable FragmentFactory factory) {
    return launchInContainer(fragmentClass, fragmentArgs, R.style.FragmentScenarioEmptyFragmentActivityTheme, factory);
}
#end_block

#method_before
@NonNull
public static <F extends Fragment> FragmentScenario<F> launchInContainer(@NonNull Class<F> fragmentClass, @Nullable Bundle fragmentArgs, @Nullable FragmentFactory factory, int themeResId) {
    return internalLaunch(fragmentClass, fragmentArgs, factory, /*containerViewId=*/
    android.R.id.content, themeResId);
}
#method_after
@NonNull
public static <F extends Fragment> FragmentScenario<F> launchInContainer(@NonNull Class<F> fragmentClass, @Nullable Bundle fragmentArgs, int themeResId, @Nullable FragmentFactory factory) {
    return internalLaunch(fragmentClass, fragmentArgs, themeResId, factory, /*containerViewId=*/
    android.R.id.content);
}
#end_block

#method_before
@NonNull
private static <F extends Fragment> FragmentScenario<F> internalLaunch(@NonNull final Class<F> fragmentClass, @Nullable final Bundle fragmentArgs, @Nullable final FragmentFactory factory, final int containerViewId, final int themeResId) {
    Intent startActivityIntent = Intent.makeMainActivity(new ComponentName(getApplicationContext(), EmptyFragmentActivity.class)).putExtra(EmptyFragmentActivity.THEME_EXTRAS_BUNDLE_KEY, themeResId);
    FragmentScenario<F> scenario = new FragmentScenario<>(fragmentClass, factory, ActivityScenario.<EmptyFragmentActivity>launch(startActivityIntent));
    scenario.mActivityScenario.onActivity(new ActivityScenario.ActivityAction<EmptyFragmentActivity>() {

        @Override
        public void perform(EmptyFragmentActivity activity) {
            if (factory != null) {
                ViewModelProvider viewModelProvider = new ViewModelProvider(activity, ViewModelProvider.AndroidViewModelFactory.getInstance(activity.getApplication()));
                viewModelProvider.get(FragmentFactoryHolderViewModel.class).setFragmentFactory(factory);
                activity.getSupportFragmentManager().setFragmentFactory(factory);
            }
            Fragment fragment = activity.getSupportFragmentManager().getFragmentFactory().instantiate(Preconditions.checkNotNull(fragmentClass.getClassLoader()), fragmentClass.getName(), fragmentArgs);
            fragment.setArguments(fragmentArgs);
            activity.getSupportFragmentManager().beginTransaction().add(containerViewId, fragment, FRAGMENT_TAG).commitNow();
        }
    });
    return scenario;
}
#method_after
@NonNull
private static <F extends Fragment> FragmentScenario<F> internalLaunch(@NonNull final Class<F> fragmentClass, @Nullable final Bundle fragmentArgs, final int themeResId, @Nullable final FragmentFactory factory, final int containerViewId) {
    Intent startActivityIntent = Intent.makeMainActivity(new ComponentName(getApplicationContext(), EmptyFragmentActivity.class)).putExtra(EmptyFragmentActivity.THEME_EXTRAS_BUNDLE_KEY, themeResId);
    FragmentScenario<F> scenario = new FragmentScenario<>(fragmentClass, factory, ActivityScenario.<EmptyFragmentActivity>launch(startActivityIntent));
    scenario.mActivityScenario.onActivity(new ActivityScenario.ActivityAction<EmptyFragmentActivity>() {

        @Override
        public void perform(EmptyFragmentActivity activity) {
            if (factory != null) {
                ViewModelProvider viewModelProvider = new ViewModelProvider(activity, ViewModelProvider.AndroidViewModelFactory.getInstance(activity.getApplication()));
                viewModelProvider.get(FragmentFactoryHolderViewModel.class).setFragmentFactory(factory);
                activity.getSupportFragmentManager().setFragmentFactory(factory);
            }
            Fragment fragment = activity.getSupportFragmentManager().getFragmentFactory().instantiate(Preconditions.checkNotNull(fragmentClass.getClassLoader()), fragmentClass.getName(), fragmentArgs);
            fragment.setArguments(fragmentArgs);
            activity.getSupportFragmentManager().beginTransaction().add(containerViewId, fragment, FRAGMENT_TAG).commitNow();
        }
    });
    return scenario;
}
#end_block

#method_before
public static ComponentName getDefaultWallpaperComponent(Context context) {
    ComponentName cn = null;
    String flat = SystemProperties.get(PROP_WALLPAPER_COMPONENT);
    if (!TextUtils.isEmpty(flat)) {
        cn = ComponentName.unflattenFromString(flat);
    }
    if (cn == null) {
        flat = context.getString(com.android.internal.R.string.default_wallpaper_component);
        if (!TextUtils.isEmpty(flat)) {
            cn = ComponentName.unflattenFromString(flat);
        }
    }
    // Check if the package is existing
    if (cn != null) {
        try {
            final PackageManager packageManager = context.getPackageManager();
            packageManager.getPackageInfo(cn.getPackageName(), 0);
        } catch (PackageManager.NameNotFoundException e) {
            cn = null;
        }
    }
    return cn;
}
#method_after
public static ComponentName getDefaultWallpaperComponent(Context context) {
    ComponentName cn = null;
    String flat = SystemProperties.get(PROP_WALLPAPER_COMPONENT);
    if (!TextUtils.isEmpty(flat)) {
        cn = ComponentName.unflattenFromString(flat);
    }
    if (cn == null) {
        flat = context.getString(com.android.internal.R.string.default_wallpaper_component);
        if (!TextUtils.isEmpty(flat)) {
            cn = ComponentName.unflattenFromString(flat);
        }
    }
    // Check if the package exists
    if (cn != null) {
        try {
            final PackageManager packageManager = context.getPackageManager();
            packageManager.getPackageInfo(cn.getPackageName(), PackageManager.MATCH_DIRECT_BOOT_AWARE | PackageManager.MATCH_DIRECT_BOOT_UNAWARE);
        } catch (PackageManager.NameNotFoundException e) {
            cn = null;
        }
    }
    return cn;
}
#end_block

#method_before
@Before
public void setUp() throws PackageManager.NameNotFoundException {
    if (Looper.myLooper() == null) {
        Looper.prepare();
    }
    Assert.assertNotNull(Looper.myLooper());
    InstrumentationRegistry.getInstrumentation().runOnMainSync(new Runnable() {

        @Override
        public void run() {
            mAdapterService = new AdapterService();
        }
    });
    mMockPackageManager = mock(PackageManager.class);
    mMockContentResolver = new MockContentResolver(mMockContext);
    MockitoAnnotations.initMocks(this);
    mPowerManager = (PowerManager) InstrumentationRegistry.getTargetContext().getSystemService(Context.POWER_SERVICE);
    when(mMockContext.getApplicationInfo()).thenReturn(mMockApplicationInfo);
    when(mMockContext.getContentResolver()).thenReturn(mMockContentResolver);
    when(mMockContext.getApplicationContext()).thenReturn(mMockContext);
    when(mMockContext.getResources()).thenReturn(mMockResources);
    when(mMockContext.getUserId()).thenReturn(Process.BLUETOOTH_UID);
    when(mMockContext.getPackageManager()).thenReturn(mMockPackageManager);
    when(mMockContext.getSystemService(Context.USER_SERVICE)).thenReturn(mMockUserManager);
    when(mMockContext.getSystemService(Context.POWER_SERVICE)).thenReturn(mPowerManager);
    when(mMockContext.getSystemService(Context.ALARM_SERVICE)).thenReturn(mMockAlarmManager);
    when(mMockContext.getSystemService(Context.AUDIO_SERVICE)).thenReturn(mAudioManager);
    when(mMockResources.getBoolean(R.bool.profile_supported_gatt)).thenReturn(true);
    when(mMockResources.getBoolean(R.bool.profile_supported_pbap)).thenReturn(true);
    when(mMockResources.getBoolean(R.bool.profile_supported_pan)).thenReturn(true);
    when(mIBluetoothCallback.asBinder()).thenReturn(mBinder);
    doReturn(Process.BLUETOOTH_UID).when(mMockPackageManager).getPackageUidAsUser(any(), anyInt(), anyInt());
    when(mMockGattService.getName()).thenReturn("GattService");
    when(mMockService.getName()).thenReturn("Service1");
    when(mMockService2.getName()).thenReturn("Service2");
    // Attach a context to the service for permission checks.
    mAdapterService.attach(mMockContext, null, null, null, null, null);
    mAdapterService.onCreate();
    mAdapterService.registerCallback(mIBluetoothCallback);
    Config.init(mMockContext);
}
#method_after
@Before
public void setUp() throws PackageManager.NameNotFoundException {
    if (Looper.myLooper() == null) {
        Looper.prepare();
    }
    Assert.assertNotNull(Looper.myLooper());
    InstrumentationRegistry.getInstrumentation().runOnMainSync(() -> mAdapterService = new AdapterService());
    mMockPackageManager = mock(PackageManager.class);
    mMockContentResolver = new MockContentResolver(mMockContext);
    MockitoAnnotations.initMocks(this);
    mPowerManager = (PowerManager) InstrumentationRegistry.getTargetContext().getSystemService(Context.POWER_SERVICE);
    when(mMockContext.getApplicationInfo()).thenReturn(mMockApplicationInfo);
    when(mMockContext.getContentResolver()).thenReturn(mMockContentResolver);
    when(mMockContext.getApplicationContext()).thenReturn(mMockContext);
    when(mMockContext.getResources()).thenReturn(mMockResources);
    when(mMockContext.getUserId()).thenReturn(Process.BLUETOOTH_UID);
    when(mMockContext.getPackageManager()).thenReturn(mMockPackageManager);
    when(mMockContext.getSystemService(Context.USER_SERVICE)).thenReturn(mMockUserManager);
    when(mMockContext.getSystemService(Context.POWER_SERVICE)).thenReturn(mPowerManager);
    when(mMockContext.getSystemService(Context.ALARM_SERVICE)).thenReturn(mMockAlarmManager);
    when(mMockContext.getSystemService(Context.AUDIO_SERVICE)).thenReturn(mAudioManager);
    when(mMockResources.getBoolean(R.bool.profile_supported_gatt)).thenReturn(true);
    when(mMockResources.getBoolean(R.bool.profile_supported_pbap)).thenReturn(true);
    when(mMockResources.getBoolean(R.bool.profile_supported_pan)).thenReturn(true);
    when(mIBluetoothCallback.asBinder()).thenReturn(mBinder);
    doReturn(Process.BLUETOOTH_UID).when(mMockPackageManager).getPackageUidAsUser(any(), anyInt(), anyInt());
    when(mMockGattService.getName()).thenReturn("GattService");
    when(mMockService.getName()).thenReturn("Service1");
    when(mMockService2.getName()).thenReturn("Service2");
    // Attach a context to the service for permission checks.
    mAdapterService.attach(mMockContext, null, null, null, null, null);
    mAdapterService.onCreate();
    mAdapterService.registerCallback(mIBluetoothCallback);
    Config.init(mMockContext);
    mAdapterConfig = TestUtils.readAdapterConfig();
    Assert.assertNotNull(mAdapterConfig);
}
#end_block

#method_before
@Test
public void testObfuscateBluetoothAddress_BluetoothDisabled() {
    Assert.assertFalse(mAdapterService.isEnabled());
    BluetoothDevice device = TestUtils.getTestDevice(BluetoothAdapter.getDefaultAdapter(), 0);
    ByteString obfuscatedAddress = mAdapterService.obfuscateBluetoothAddress(device);
    Assert.assertFalse(obfuscatedAddress.isEmpty());
    Assert.assertFalse(isByteArrayAllZero(obfuscatedAddress.toByteArray()));
}
#method_after
@Test
public void testObfuscateBluetoothAddress_BluetoothDisabled() {
    Assert.assertFalse(mAdapterService.isEnabled());
    byte[] metricsSalt = getMetricsSalt(mAdapterConfig);
    Assert.assertNotNull(metricsSalt);
    BluetoothDevice device = TestUtils.getTestDevice(BluetoothAdapter.getDefaultAdapter(), 0);
    ByteString obfuscatedAddress = mAdapterService.obfuscateAddress(device);
    Assert.assertFalse(obfuscatedAddress.isEmpty());
    Assert.assertFalse(isByteArrayAllZero(obfuscatedAddress.toByteArray()));
    Assert.assertArrayEquals(obfuscateInJava(metricsSalt, device), obfuscatedAddress.toByteArray());
}
#end_block

#method_before
@Test
public void testObfuscateBluetoothAddress_BluetoothEnabled() {
    Assert.assertFalse(mAdapterService.isEnabled());
    doEnable(0, false);
    Assert.assertTrue(mAdapterService.isEnabled());
    BluetoothDevice device = TestUtils.getTestDevice(BluetoothAdapter.getDefaultAdapter(), 0);
    ByteString obfuscatedAddress = mAdapterService.obfuscateBluetoothAddress(device);
    Assert.assertFalse(obfuscatedAddress.isEmpty());
    Assert.assertFalse(isByteArrayAllZero(obfuscatedAddress.toByteArray()));
}
#method_after
@Test
public void testObfuscateBluetoothAddress_BluetoothEnabled() {
    Assert.assertFalse(mAdapterService.isEnabled());
    doEnable(0, false);
    Assert.assertTrue(mAdapterService.isEnabled());
    byte[] metricsSalt = getMetricsSalt(mAdapterConfig);
    Assert.assertNotNull(metricsSalt);
    BluetoothDevice device = TestUtils.getTestDevice(BluetoothAdapter.getDefaultAdapter(), 0);
    ByteString obfuscatedAddress = mAdapterService.obfuscateAddress(device);
    Assert.assertFalse(obfuscatedAddress.isEmpty());
    Assert.assertFalse(isByteArrayAllZero(obfuscatedAddress.toByteArray()));
    Assert.assertArrayEquals(obfuscateInJava(metricsSalt, device), obfuscatedAddress.toByteArray());
}
#end_block

#method_before
@Test
public void testObfuscateBluetoothAddress_PersistentBetweenToggle() {
    Assert.assertFalse(mAdapterService.isEnabled());
    BluetoothDevice device = TestUtils.getTestDevice(BluetoothAdapter.getDefaultAdapter(), 0);
    ByteString obfuscatedAddress1 = mAdapterService.obfuscateBluetoothAddress(device);
    Assert.assertFalse(obfuscatedAddress1.isEmpty());
    Assert.assertFalse(isByteArrayAllZero(obfuscatedAddress1.toByteArray()));
    // Enable
    doEnable(0, false);
    Assert.assertTrue(mAdapterService.isEnabled());
    ByteString obfuscatedAddress3 = mAdapterService.obfuscateBluetoothAddress(device);
    Assert.assertFalse(obfuscatedAddress3.isEmpty());
    Assert.assertFalse(isByteArrayAllZero(obfuscatedAddress3.toByteArray()));
    Assert.assertArrayEquals(obfuscatedAddress3.toByteArray(), obfuscatedAddress1.toByteArray());
    // Disable
    doDisable(0, false);
    Assert.assertFalse(mAdapterService.isEnabled());
    ByteString obfuscatedAddress4 = mAdapterService.obfuscateBluetoothAddress(device);
    Assert.assertFalse(obfuscatedAddress4.isEmpty());
    Assert.assertFalse(isByteArrayAllZero(obfuscatedAddress4.toByteArray()));
    Assert.assertArrayEquals(obfuscatedAddress4.toByteArray(), obfuscatedAddress1.toByteArray());
}
#method_after
@Test
public void testObfuscateBluetoothAddress_PersistentBetweenToggle() {
    Assert.assertFalse(mAdapterService.isEnabled());
    byte[] metricsSalt = getMetricsSalt(mAdapterConfig);
    Assert.assertNotNull(metricsSalt);
    BluetoothDevice device = TestUtils.getTestDevice(BluetoothAdapter.getDefaultAdapter(), 0);
    ByteString obfuscatedAddress1 = mAdapterService.obfuscateAddress(device);
    Assert.assertFalse(obfuscatedAddress1.isEmpty());
    Assert.assertFalse(isByteArrayAllZero(obfuscatedAddress1.toByteArray()));
    Assert.assertArrayEquals(obfuscateInJava(metricsSalt, device), obfuscatedAddress1.toByteArray());
    // Enable
    doEnable(0, false);
    Assert.assertTrue(mAdapterService.isEnabled());
    ByteString obfuscatedAddress3 = mAdapterService.obfuscateAddress(device);
    Assert.assertFalse(obfuscatedAddress3.isEmpty());
    Assert.assertFalse(isByteArrayAllZero(obfuscatedAddress3.toByteArray()));
    Assert.assertArrayEquals(obfuscatedAddress3.toByteArray(), obfuscatedAddress1.toByteArray());
    // Disable
    doDisable(0, false);
    Assert.assertFalse(mAdapterService.isEnabled());
    ByteString obfuscatedAddress4 = mAdapterService.obfuscateAddress(device);
    Assert.assertFalse(obfuscatedAddress4.isEmpty());
    Assert.assertFalse(isByteArrayAllZero(obfuscatedAddress4.toByteArray()));
    Assert.assertArrayEquals(obfuscatedAddress4.toByteArray(), obfuscatedAddress1.toByteArray());
}
#end_block

#method_before
@Test
public void testObfuscateBluetoothAddress_PersistentBetweenAdapterServiceInitialization() throws PackageManager.NameNotFoundException {
    Assert.assertFalse(mAdapterService.isEnabled());
    BluetoothDevice device = TestUtils.getTestDevice(BluetoothAdapter.getDefaultAdapter(), 0);
    ByteString obfuscatedAddress1 = mAdapterService.obfuscateBluetoothAddress(device);
    Assert.assertFalse(obfuscatedAddress1.isEmpty());
    Assert.assertFalse(isByteArrayAllZero(obfuscatedAddress1.toByteArray()));
    tearDown();
    setUp();
    Assert.assertFalse(mAdapterService.isEnabled());
    ByteString obfuscatedAddress2 = mAdapterService.obfuscateBluetoothAddress(device);
    Assert.assertFalse(obfuscatedAddress2.isEmpty());
    Assert.assertFalse(isByteArrayAllZero(obfuscatedAddress2.toByteArray()));
    Assert.assertArrayEquals(obfuscatedAddress2.toByteArray(), obfuscatedAddress1.toByteArray());
}
#method_after
@Test
public void testObfuscateBluetoothAddress_PersistentBetweenAdapterServiceInitialization() throws PackageManager.NameNotFoundException {
    byte[] metricsSalt = getMetricsSalt(mAdapterConfig);
    Assert.assertNotNull(metricsSalt);
    Assert.assertFalse(mAdapterService.isEnabled());
    BluetoothDevice device = TestUtils.getTestDevice(BluetoothAdapter.getDefaultAdapter(), 0);
    ByteString obfuscatedAddress1 = mAdapterService.obfuscateAddress(device);
    Assert.assertFalse(obfuscatedAddress1.isEmpty());
    Assert.assertFalse(isByteArrayAllZero(obfuscatedAddress1.toByteArray()));
    Assert.assertArrayEquals(obfuscateInJava(metricsSalt, device), obfuscatedAddress1.toByteArray());
    tearDown();
    setUp();
    Assert.assertFalse(mAdapterService.isEnabled());
    ByteString obfuscatedAddress2 = mAdapterService.obfuscateAddress(device);
    Assert.assertFalse(obfuscatedAddress2.isEmpty());
    Assert.assertFalse(isByteArrayAllZero(obfuscatedAddress2.toByteArray()));
    Assert.assertArrayEquals(obfuscatedAddress2.toByteArray(), obfuscatedAddress1.toByteArray());
}
#end_block

#method_before
@Ignore("Factory reset does not reload config into memory and hence old salt is still used" + " until next time Bluetooth library is initialized. However Bluetooth cannot be used" + " until Bluetooth process restart any way. Thus it is almost guaranteed that user" + " has to re-enable Bluetooth and hence re-generate new salt after factory reset")
@Test
public void testObfuscateBluetoothAddress_FactoryReset() {
    Assert.assertFalse(mAdapterService.isEnabled());
    BluetoothDevice device = TestUtils.getTestDevice(BluetoothAdapter.getDefaultAdapter(), 0);
    ByteString obfuscatedAddress1 = mAdapterService.obfuscateBluetoothAddress(device);
    Assert.assertFalse(obfuscatedAddress1.isEmpty());
    Assert.assertFalse(isByteArrayAllZero(obfuscatedAddress1.toByteArray()));
    mAdapterService.factoryReset();
    ByteString obfuscatedAddress2 = mAdapterService.obfuscateBluetoothAddress(device);
    Assert.assertFalse(obfuscatedAddress2.isEmpty());
    Assert.assertFalse(isByteArrayAllZero(obfuscatedAddress2.toByteArray()));
    Assert.assertFalse(Arrays.equals(obfuscatedAddress2.toByteArray(), obfuscatedAddress1.toByteArray()));
    doEnable(0, false);
    ByteString obfuscatedAddress3 = mAdapterService.obfuscateBluetoothAddress(device);
    Assert.assertFalse(obfuscatedAddress3.isEmpty());
    Assert.assertFalse(isByteArrayAllZero(obfuscatedAddress3.toByteArray()));
    Assert.assertArrayEquals(obfuscatedAddress3.toByteArray(), obfuscatedAddress2.toByteArray());
    mAdapterService.factoryReset();
    ByteString obfuscatedAddress4 = mAdapterService.obfuscateBluetoothAddress(device);
    Assert.assertFalse(obfuscatedAddress4.isEmpty());
    Assert.assertFalse(isByteArrayAllZero(obfuscatedAddress4.toByteArray()));
    Assert.assertFalse(Arrays.equals(obfuscatedAddress4.toByteArray(), obfuscatedAddress3.toByteArray()));
}
#method_after
@Ignore("AdapterService.factoryReset() does not reload config into memory and hence old salt" + " is still used until next time Bluetooth library is initialized. However Bluetooth" + " cannot be used until Bluetooth process restart any way. Thus it is almost" + " guaranteed that user has to re-enable Bluetooth and hence re-generate new salt" + " after factory reset")
@Test
public void testObfuscateBluetoothAddress_FactoryReset() {
    Assert.assertFalse(mAdapterService.isEnabled());
    BluetoothDevice device = TestUtils.getTestDevice(BluetoothAdapter.getDefaultAdapter(), 0);
    ByteString obfuscatedAddress1 = mAdapterService.obfuscateAddress(device);
    Assert.assertFalse(obfuscatedAddress1.isEmpty());
    Assert.assertFalse(isByteArrayAllZero(obfuscatedAddress1.toByteArray()));
    mAdapterService.factoryReset();
    ByteString obfuscatedAddress2 = mAdapterService.obfuscateAddress(device);
    Assert.assertFalse(obfuscatedAddress2.isEmpty());
    Assert.assertFalse(isByteArrayAllZero(obfuscatedAddress2.toByteArray()));
    Assert.assertFalse(Arrays.equals(obfuscatedAddress2.toByteArray(), obfuscatedAddress1.toByteArray()));
    doEnable(0, false);
    ByteString obfuscatedAddress3 = mAdapterService.obfuscateAddress(device);
    Assert.assertFalse(obfuscatedAddress3.isEmpty());
    Assert.assertFalse(isByteArrayAllZero(obfuscatedAddress3.toByteArray()));
    Assert.assertArrayEquals(obfuscatedAddress3.toByteArray(), obfuscatedAddress2.toByteArray());
    mAdapterService.factoryReset();
    ByteString obfuscatedAddress4 = mAdapterService.obfuscateAddress(device);
    Assert.assertFalse(obfuscatedAddress4.isEmpty());
    Assert.assertFalse(isByteArrayAllZero(obfuscatedAddress4.toByteArray()));
    Assert.assertFalse(Arrays.equals(obfuscatedAddress4.toByteArray(), obfuscatedAddress3.toByteArray()));
}
#end_block

#method_before
@Test
public void testObfuscateBluetoothAddress_FactoryResetAndReloadNativeLayer() throws PackageManager.NameNotFoundException {
    Assert.assertFalse(mAdapterService.isEnabled());
    BluetoothDevice device = TestUtils.getTestDevice(BluetoothAdapter.getDefaultAdapter(), 0);
    ByteString obfuscatedAddress1 = mAdapterService.obfuscateBluetoothAddress(device);
    Assert.assertFalse(obfuscatedAddress1.isEmpty());
    Assert.assertFalse(isByteArrayAllZero(obfuscatedAddress1.toByteArray()));
    mAdapterService.factoryReset();
    tearDown();
    setUp();
    ByteString obfuscatedAddress2 = mAdapterService.obfuscateBluetoothAddress(device);
    Assert.assertFalse(obfuscatedAddress2.isEmpty());
    Assert.assertFalse(isByteArrayAllZero(obfuscatedAddress2.toByteArray()));
    Assert.assertFalse(Arrays.equals(obfuscatedAddress2.toByteArray(), obfuscatedAddress1.toByteArray()));
}
#method_after
@Test
public void testObfuscateBluetoothAddress_FactoryResetAndReloadNativeLayer() throws PackageManager.NameNotFoundException {
    byte[] metricsSalt1 = getMetricsSalt(mAdapterConfig);
    Assert.assertNotNull(metricsSalt1);
    Assert.assertFalse(mAdapterService.isEnabled());
    BluetoothDevice device = TestUtils.getTestDevice(BluetoothAdapter.getDefaultAdapter(), 0);
    ByteString obfuscatedAddress1 = mAdapterService.obfuscateAddress(device);
    Assert.assertFalse(obfuscatedAddress1.isEmpty());
    Assert.assertFalse(isByteArrayAllZero(obfuscatedAddress1.toByteArray()));
    Assert.assertArrayEquals(obfuscateInJava(metricsSalt1, device), obfuscatedAddress1.toByteArray());
    mAdapterService.factoryReset();
    tearDown();
    setUp();
    // Cannot verify metrics salt since it is not written to disk until native cleanup
    ByteString obfuscatedAddress2 = mAdapterService.obfuscateAddress(device);
    Assert.assertFalse(obfuscatedAddress2.isEmpty());
    Assert.assertFalse(isByteArrayAllZero(obfuscatedAddress2.toByteArray()));
    Assert.assertFalse(Arrays.equals(obfuscatedAddress2.toByteArray(), obfuscatedAddress1.toByteArray()));
}
#end_block

#method_before
public void test_112162449_audio() {
    // According to https://en.wikipedia.org/wiki/M3U#Internet_media_types
    // this is a giant mess, so we pick "audio/x-mpegurl" because a similar
    // playlist format uses "audio/x-scpls".
    assertMimeTypeFromExtension("audio/x-mpegurl", "m3u");
    assertMimeTypeFromExtension("audio/x-mpegurl", "m3u8");
    assertExtensionFromMimeType("m3u", "audio/x-mpegurl");
    assertExtensionFromMimeType("m4a", "audio/mp4");
    assertBidirectional("audio/aac", "aac");
}
#method_after
public void test_112162449_audio() {
    // According to https://en.wikipedia.org/wiki/M3U#Internet_media_types
    // this is a giant mess, so we pick "audio/x-mpegurl" because a similar
    // playlist format uses "audio/x-scpls".
    assertMimeTypeFromExtension("audio/x-mpegurl", "m3u");
    assertMimeTypeFromExtension("audio/x-mpegurl", "m3u8");
    assertExtensionFromMimeType("m3u", "audio/x-mpegurl");
    assertExtensionFromMimeType("m4a", "audio/mp4");
    assertMimeTypeFromExtension("audio/mpeg", "m4a");
    assertBidirectional("audio/aac", "aac");
}
#end_block

#method_before
public void test_120135571_audio() {
    assertMimeTypeFromExtension("audio/aac", "m4a");
    assertMimeTypeFromExtension("audio/aac", "m4r");
}
#method_after
public void test_120135571_audio() {
    assertMimeTypeFromExtension("audio/mpeg", "m4r");
}
#end_block

#method_before
public void setSlice(@Nullable Slice slice) {
    initSliceMetrics(slice);
    boolean isUpdate = slice != null && mCurrentSlice != null && slice.getUri().equals(mCurrentSlice.getUri());
    if (isUpdate) {
        // If its an update check the loading state
        SliceMetadata oldSliceData = mSliceMetadata;
        SliceMetadata newSliceData = SliceMetadata.from(getContext(), slice);
        if (oldSliceData.getLoadingState() == SliceMetadata.LOADED_ALL && newSliceData.getLoadingState() == SliceMetadata.LOADED_NONE) {
            // ignore the update.
            return;
        }
    } else {
        mCurrentView.resetView();
    }
    mCurrentSlice = slice;
    mSliceMetadata = mCurrentSlice != null ? SliceMetadata.from(getContext(), mCurrentSlice) : null;
    mListContent = mSliceMetadata != null ? mSliceMetadata.getListContent() : null;
    if (mShowActionDividers) {
        showActionDividers(true);
    }
    if (mListContent == null || !mListContent.isValid()) {
        mActions = null;
        mCurrentView.resetView();
        updateActions();
        return;
    }
    // New slice means we shouldn't have any actions loading
    mCurrentView.setLoadingActions(null);
    // Check if the slice content is expired and show when it was last updated
    mActions = mSliceMetadata.getSliceActions();
    mCurrentView.setLastUpdated(mSliceMetadata.getLastUpdatedTime());
    mCurrentView.setShowLastUpdated(mShowLastUpdated && mSliceMetadata.isExpired());
    mCurrentView.setAllowTwoLines(mSliceMetadata.isPermissionSlice());
    // Tint color can come with the slice, so may need to update it
    mCurrentView.setTint(getTintColor());
    if (mListContent.getLayoutDir() != -1) {
        mCurrentView.setLayoutDirection(mListContent.getLayoutDir());
    } else {
        mCurrentView.setLayoutDirection(View.LAYOUT_DIRECTION_INHERIT);
    }
    // Set the slice
    mCurrentView.setSliceContent(mListContent);
    updateActions();
    // Log slice metrics visible.
    logSliceMetricsVisibilityChange(true);
    // Automatically refresh the last updated label when the slice TTL isn't infinity.
    refreshLastUpdatedLabel(true);
}
#method_after
public void setSlice(@Nullable Slice slice) {
    initSliceMetrics(slice);
    boolean isUpdate = slice != null && mCurrentSlice != null && slice.getUri().equals(mCurrentSlice.getUri());
    SliceMetadata oldSliceData = mSliceMetadata;
    mCurrentSlice = slice;
    mSliceMetadata = mCurrentSlice != null ? SliceMetadata.from(getContext(), mCurrentSlice) : null;
    if (isUpdate) {
        // If its an update check the loading state
        SliceMetadata newSliceData = mSliceMetadata;
        if (oldSliceData.getLoadingState() == SliceMetadata.LOADED_ALL && newSliceData.getLoadingState() == SliceMetadata.LOADED_NONE) {
            // ignore the update.
            return;
        }
    } else {
        mCurrentView.resetView();
    }
    mListContent = mSliceMetadata != null ? mSliceMetadata.getListContent() : null;
    if (mShowActionDividers) {
        showActionDividers(true);
    }
    if (mListContent == null || !mListContent.isValid()) {
        mActions = null;
        mCurrentView.resetView();
        updateActions();
        return;
    }
    // New slice means we shouldn't have any actions loading
    mCurrentView.setLoadingActions(null);
    // Check if the slice content is expired and show when it was last updated
    mActions = mSliceMetadata.getSliceActions();
    mCurrentView.setLastUpdated(mSliceMetadata.getLastUpdatedTime());
    mCurrentView.setShowLastUpdated(mShowLastUpdated && mSliceMetadata.isExpired());
    mCurrentView.setAllowTwoLines(mSliceMetadata.isPermissionSlice());
    // Tint color can come with the slice, so may need to update it
    mCurrentView.setTint(getTintColor());
    if (mListContent.getLayoutDir() != -1) {
        mCurrentView.setLayoutDirection(mListContent.getLayoutDir());
    } else {
        mCurrentView.setLayoutDirection(View.LAYOUT_DIRECTION_INHERIT);
    }
    // Set the slice
    mCurrentView.setSliceContent(mListContent);
    updateActions();
    // Log slice metrics visible.
    logSliceMetricsVisibilityChange(true);
    // Automatically refresh the last updated label when the slice TTL isn't infinity.
    refreshLastUpdatedLabel(true);
}
#end_block

#method_before
@Override
public void writeToParcel(Parcel dest, int flags) {
    dest.writeInt(mId);
    dest.writeString(mIccId);
    dest.writeInt(mSimSlotIndex);
    dest.writeCharSequence(mDisplayName);
    dest.writeCharSequence(mCarrierName);
    dest.writeInt(mNameSource);
    dest.writeInt(mIconTint);
    dest.writeString(mNumber);
    dest.writeInt(mDataRoaming);
    dest.writeString(mMcc);
    dest.writeString(mMnc);
    dest.writeString(mCountryIso);
    mIconBitmap.writeToParcel(dest, flags);
    dest.writeBoolean(mIsEmbedded);
    dest.writeTypedArray(mAccessRules, flags);
    dest.writeString(mCardId);
    dest.writeBoolean(mIsOpportunistic);
    dest.writeInt(mParentSubId);
    dest.writeBoolean(mIsMetered);
}
#method_after
@Override
public void writeToParcel(Parcel dest, int flags) {
    dest.writeInt(mId);
    dest.writeString(mIccId);
    dest.writeInt(mSimSlotIndex);
    dest.writeCharSequence(mDisplayName);
    dest.writeCharSequence(mCarrierName);
    dest.writeInt(mNameSource);
    dest.writeInt(mIconTint);
    dest.writeString(mNumber);
    dest.writeInt(mDataRoaming);
    dest.writeString(mMcc);
    dest.writeString(mMnc);
    dest.writeString(mCountryIso);
    mIconBitmap.writeToParcel(dest, flags);
    dest.writeBoolean(mIsEmbedded);
    dest.writeTypedArray(mAccessRules, flags);
    dest.writeString(mCardId);
    dest.writeBoolean(mIsOpportunistic);
    dest.writeString(mGroupUUID);
    dest.writeBoolean(mIsMetered);
}
#end_block

#method_before
@Override
public String toString() {
    String iccIdToPrint = givePrintableIccid(mIccId);
    String cardIdToPrint = givePrintableIccid(mCardId);
    return "{id=" + mId + ", iccId=" + iccIdToPrint + " simSlotIndex=" + mSimSlotIndex + " displayName=" + mDisplayName + " carrierName=" + mCarrierName + " nameSource=" + mNameSource + " iconTint=" + mIconTint + " mNumber=" + mNumber + " dataRoaming=" + mDataRoaming + " iconBitmap=" + mIconBitmap + " mcc " + mMcc + " mnc " + mMnc + "mCountryIso=" + mCountryIso + " isEmbedded " + mIsEmbedded + " accessRules " + Arrays.toString(mAccessRules) + " cardId=" + cardIdToPrint + " isOpportunistic " + mIsOpportunistic + " parentSubId=" + mParentSubId + " isMetered=" + mIsMetered + "}";
}
#method_after
@Override
public String toString() {
    String iccIdToPrint = givePrintableIccid(mIccId);
    String cardIdToPrint = givePrintableIccid(mCardId);
    return "{id=" + mId + ", iccId=" + iccIdToPrint + " simSlotIndex=" + mSimSlotIndex + " displayName=" + mDisplayName + " carrierName=" + mCarrierName + " nameSource=" + mNameSource + " iconTint=" + mIconTint + " mNumber=" + mNumber + " dataRoaming=" + mDataRoaming + " iconBitmap=" + mIconBitmap + " mcc " + mMcc + " mnc " + mMnc + "mCountryIso=" + mCountryIso + " isEmbedded " + mIsEmbedded + " accessRules " + Arrays.toString(mAccessRules) + " cardId=" + cardIdToPrint + " isOpportunistic " + mIsOpportunistic + " mGroupUUID=" + mGroupUUID + " isMetered=" + mIsMetered + "}";
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hash(mId, mSimSlotIndex, mNameSource, mIconTint, mDataRoaming, mIsEmbedded, mIsOpportunistic, mParentSubId, mIsMetered, mIccId, mNumber, mMcc, mMnc, mCountryIso, mCardId, mDisplayName, mCarrierName, mAccessRules);
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(mId, mSimSlotIndex, mNameSource, mIconTint, mDataRoaming, mIsEmbedded, mIsOpportunistic, mGroupUUID, mIsMetered, mIccId, mNumber, mMcc, mMnc, mCountryIso, mCardId, mDisplayName, mCarrierName, mAccessRules);
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (obj == null)
        return false;
    if (obj == this)
        return true;
    SubscriptionInfo toCompare;
    try {
        toCompare = (SubscriptionInfo) obj;
    } catch (ClassCastException ex) {
        return false;
    }
    return mId == toCompare.mId && mSimSlotIndex == toCompare.mSimSlotIndex && mNameSource == toCompare.mNameSource && mIconTint == toCompare.mIconTint && mDataRoaming == toCompare.mDataRoaming && mIsEmbedded == toCompare.mIsEmbedded && mIsOpportunistic == toCompare.mIsOpportunistic && mParentSubId == toCompare.mParentSubId && mIsMetered == toCompare.mIsMetered && Objects.equals(mIccId, toCompare.mIccId) && Objects.equals(mNumber, toCompare.mNumber) && Objects.equals(mMcc, toCompare.mMcc) && Objects.equals(mMnc, toCompare.mMnc) && Objects.equals(mCountryIso, toCompare.mCountryIso) && Objects.equals(mCardId, toCompare.mCardId) && TextUtils.equals(mDisplayName, toCompare.mDisplayName) && TextUtils.equals(mCarrierName, toCompare.mCarrierName) && Arrays.equals(mAccessRules, toCompare.mAccessRules);
}
#method_after
@Override
public boolean equals(Object obj) {
    if (obj == null)
        return false;
    if (obj == this)
        return true;
    SubscriptionInfo toCompare;
    try {
        toCompare = (SubscriptionInfo) obj;
    } catch (ClassCastException ex) {
        return false;
    }
    return mId == toCompare.mId && mSimSlotIndex == toCompare.mSimSlotIndex && mNameSource == toCompare.mNameSource && mIconTint == toCompare.mIconTint && mDataRoaming == toCompare.mDataRoaming && mIsEmbedded == toCompare.mIsEmbedded && mIsOpportunistic == toCompare.mIsOpportunistic && Objects.equals(mGroupUUID, toCompare.mGroupUUID) && mIsMetered == toCompare.mIsMetered && Objects.equals(mIccId, toCompare.mIccId) && Objects.equals(mNumber, toCompare.mNumber) && Objects.equals(mMcc, toCompare.mMcc) && Objects.equals(mMnc, toCompare.mMnc) && Objects.equals(mCountryIso, toCompare.mCountryIso) && Objects.equals(mCardId, toCompare.mCardId) && TextUtils.equals(mDisplayName, toCompare.mDisplayName) && TextUtils.equals(mCarrierName, toCompare.mCarrierName) && Arrays.equals(mAccessRules, toCompare.mAccessRules);
}
#end_block

#method_before
@RequiresPermission(android.Manifest.permission.READ_PHONE_STATE)
@NonNull
public List<SubscriptionInfo> getOpportunisticSubscriptions(int slotIndex) {
    String pkgForDebug = mContext != null ? mContext.getOpPackageName() : "<unknown>";
    List<SubscriptionInfo> subInfoList = null;
    try {
        ISub iSub = ISub.Stub.asInterface(ServiceManager.getService("isub"));
        if (iSub != null) {
            subInfoList = iSub.getOpportunisticSubscriptions(slotIndex, pkgForDebug);
        }
    } catch (RemoteException ex) {
    // ignore it
    }
    if (subInfoList == null) {
        subInfoList = new ArrayList<>();
    }
    return subInfoList;
}
#method_after
// Blocked by b/72967236 - no support for carrier privileges
@SuppressAutoDoc
@RequiresPermission(android.Manifest.permission.READ_PHONE_STATE)
@NonNull
public List<SubscriptionInfo> getOpportunisticSubscriptions() {
    String pkgForDebug = mContext != null ? mContext.getOpPackageName() : "<unknown>";
    List<SubscriptionInfo> subInfoList = null;
    try {
        ISub iSub = ISub.Stub.asInterface(ServiceManager.getService("isub"));
        if (iSub != null) {
            subInfoList = iSub.getOpportunisticSubscriptions(pkgForDebug);
        }
    } catch (RemoteException ex) {
    // ignore it
    }
    if (subInfoList == null) {
        subInfoList = new ArrayList<>();
    }
    return subInfoList;
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    super.setUp("SubscriptionControllerTest");
    doReturn(SINGLE_SIM).when(mTelephonyManager).getSimCount();
    doReturn(SINGLE_SIM).when(mTelephonyManager).getPhoneCount();
    replaceInstance(SubscriptionController.class, "sInstance", null, null);
    SubscriptionController.init(mContext, null);
    mSubscriptionControllerUT = SubscriptionController.getInstance();
    mCallingPackage = mContext.getOpPackageName();
    doReturn(1).when(mProxyController).getMaxRafSupported();
    mContextFixture.putIntArrayResource(com.android.internal.R.array.sim_colors, new int[] { 5 });
    mSubscriptionControllerUT.getInstance().updatePhonesAvailability(new Phone[] { mPhone });
    mMockContentResolver = (MockContentResolver) mContext.getContentResolver();
    mMockContentResolver.addProvider(SubscriptionManager.CONTENT_URI.getAuthority(), new FakeTelephonyProvider());
}
#method_after
@Before
public void setUp() throws Exception {
    super.setUp("SubscriptionControllerTest");
    doReturn(SINGLE_SIM).when(mTelephonyManager).getSimCount();
    doReturn(SINGLE_SIM).when(mTelephonyManager).getPhoneCount();
    replaceInstance(SubscriptionController.class, "sInstance", null, null);
    SubscriptionController.init(mContext, null);
    mSubscriptionControllerUT = SubscriptionController.getInstance();
    mCallingPackage = mContext.getOpPackageName();
    doReturn(1).when(mProxyController).getMaxRafSupported();
    mContextFixture.putIntArrayResource(com.android.internal.R.array.sim_colors, new int[] { 5 });
    mSubscriptionControllerUT.getInstance().updatePhonesAvailability(new Phone[] { mPhone });
    mMockContentResolver = (MockContentResolver) mContext.getContentResolver();
    mFakeTelephonyProvider = new FakeTelephonyProvider();
    mMockContentResolver.addProvider(SubscriptionManager.CONTENT_URI.getAuthority(), mFakeTelephonyProvider);
}
#end_block

#method_before
@After
public void tearDown() throws Exception {
    /* should clear fake content provider and resolver here */
    mContext.getContentResolver().delete(SubscriptionManager.CONTENT_URI, null, null);
    /*clear sub info in mSubscriptionControllerUT since they will otherwise be persistent
         * between each test case. */
    mSubscriptionControllerUT.clearSubInfo();
    /* clear settings for default voice/data/sms sub ID */
    Settings.Global.putInt(mContext.getContentResolver(), Settings.Global.MULTI_SIM_VOICE_CALL_SUBSCRIPTION, SubscriptionManager.INVALID_SUBSCRIPTION_ID);
    Settings.Global.putInt(mContext.getContentResolver(), Settings.Global.MULTI_SIM_DATA_CALL_SUBSCRIPTION, SubscriptionManager.INVALID_SUBSCRIPTION_ID);
    Settings.Global.putInt(mContext.getContentResolver(), Settings.Global.MULTI_SIM_SMS_SUBSCRIPTION, SubscriptionManager.INVALID_SUBSCRIPTION_ID);
    mSubscriptionControllerUT = null;
    super.tearDown();
}
#method_after
@After
public void tearDown() throws Exception {
    mContextFixture.addCallingOrSelfPermission(ContextFixture.PERMISSION_ENABLE_ALL);
    /* should clear fake content provider and resolver here */
    mContext.getContentResolver().delete(SubscriptionManager.CONTENT_URI, null, null);
    /*clear sub info in mSubscriptionControllerUT since they will otherwise be persistent
         * between each test case. */
    mSubscriptionControllerUT.clearSubInfo();
    /* clear settings for default voice/data/sms sub ID */
    Settings.Global.putInt(mContext.getContentResolver(), Settings.Global.MULTI_SIM_VOICE_CALL_SUBSCRIPTION, SubscriptionManager.INVALID_SUBSCRIPTION_ID);
    Settings.Global.putInt(mContext.getContentResolver(), Settings.Global.MULTI_SIM_DATA_CALL_SUBSCRIPTION, SubscriptionManager.INVALID_SUBSCRIPTION_ID);
    Settings.Global.putInt(mContext.getContentResolver(), Settings.Global.MULTI_SIM_SMS_SUBSCRIPTION, SubscriptionManager.INVALID_SUBSCRIPTION_ID);
    mSubscriptionControllerUT = null;
    super.tearDown();
}
#end_block

#method_before
@Test
@SmallTest
public void testChangeSIMProperty() {
    int dataRoaming = 1;
    int iconTint = 1;
    String disName = "TESTING";
    String disNum = "12345";
    boolean isOpportunistic = true;
    boolean isMetered = true;
    testInsertSim();
    /* Get SUB ID */
    int[] subIds = mSubscriptionControllerUT.getActiveSubIdList();
    assertTrue(subIds != null && subIds.length != 0);
    int subID = subIds[0];
    /* Setting */
    mSubscriptionControllerUT.setDisplayName(disName, subID);
    mSubscriptionControllerUT.setDataRoaming(dataRoaming, subID);
    mSubscriptionControllerUT.setDisplayNumber(disNum, subID);
    mSubscriptionControllerUT.setIconTint(iconTint, subID);
    mSubscriptionControllerUT.setOpportunistic(isOpportunistic, subID);
    mSubscriptionControllerUT.setOpportunistic(isMetered, subID);
    /* Getting, there is no direct getter function for each fields of property */
    SubscriptionInfo subInfo = mSubscriptionControllerUT.getActiveSubscriptionInfo(subID, mCallingPackage);
    assertNotNull(subInfo);
    assertEquals(dataRoaming, subInfo.getDataRoaming());
    assertEquals(disName, subInfo.getDisplayName());
    assertEquals(iconTint, subInfo.getIconTint());
    assertEquals(disNum, subInfo.getNumber());
    assertEquals(isOpportunistic, subInfo.isOpportunistic());
    assertEquals(isMetered, subInfo.isMetered());
    /* verify broadcast intent */
    ArgumentCaptor<Intent> captorIntent = ArgumentCaptor.forClass(Intent.class);
    verify(mContext, atLeast(1)).sendBroadcast(captorIntent.capture());
    assertEquals(TelephonyIntents.ACTION_SUBINFO_RECORD_UPDATED, captorIntent.getValue().getAction());
}
#method_after
@Test
@SmallTest
public void testChangeSIMProperty() {
    int dataRoaming = 1;
    int iconTint = 1;
    String disName = "TESTING";
    String disNum = "12345";
    boolean isOpportunistic = true;
    boolean isMetered = false;
    testInsertSim();
    /* Get SUB ID */
    int[] subIds = mSubscriptionControllerUT.getActiveSubIdList();
    assertTrue(subIds != null && subIds.length != 0);
    int subID = subIds[0];
    /* Getting, there is no direct getter function for each fields of property */
    SubscriptionInfo subInfo = mSubscriptionControllerUT.getActiveSubscriptionInfo(subID, mCallingPackage);
    // isMetered should initialize as true
    assertTrue(subInfo.isMetered());
    /* Setting */
    mSubscriptionControllerUT.setDisplayName(disName, subID);
    mSubscriptionControllerUT.setDataRoaming(dataRoaming, subID);
    mSubscriptionControllerUT.setDisplayNumber(disNum, subID);
    mSubscriptionControllerUT.setIconTint(iconTint, subID);
    mSubscriptionControllerUT.setOpportunistic(isOpportunistic, subID);
    mSubscriptionControllerUT.setMetered(isMetered, subID);
    subInfo = mSubscriptionControllerUT.getActiveSubscriptionInfo(subID, mCallingPackage);
    assertNotNull(subInfo);
    assertEquals(dataRoaming, subInfo.getDataRoaming());
    assertEquals(disName, subInfo.getDisplayName());
    assertEquals(iconTint, subInfo.getIconTint());
    assertEquals(disNum, subInfo.getNumber());
    assertEquals(isOpportunistic, subInfo.isOpportunistic());
    assertEquals(isMetered, subInfo.isMetered());
    /* verify broadcast intent */
    ArgumentCaptor<Intent> captorIntent = ArgumentCaptor.forClass(Intent.class);
    verify(mContext, atLeast(1)).sendBroadcast(captorIntent.capture());
    assertEquals(TelephonyIntents.ACTION_SUBINFO_RECORD_UPDATED, captorIntent.getValue().getAction());
}
#end_block

#method_before
@Test
@SmallTest
public void testOpptSubInfoListChanged() throws Exception {
    registerMockTelephonyRegistry();
    verify(mTelephonyRegisteryMock, times(0)).notifyOpportunisticSubscriptionInfoChanged();
    testInsertSim();
    testInsertSim2();
    // Neither sub1 or sub2 are opportunistic. So getOpportunisticSubscriptions
    // should return empty list and no callback triggered.
    List<SubscriptionInfo> opptSubList = mSubscriptionControllerUT.getOpportunisticSubscriptions(0, mCallingPackage);
    assertTrue(opptSubList.isEmpty());
    verify(mTelephonyRegisteryMock, times(0)).notifyOpportunisticSubscriptionInfoChanged();
    // Setting sub2 as opportunistic should trigger callback.
    mSubscriptionControllerUT.setOpportunistic(true, 2);
    verify(mTelephonyRegisteryMock, times(1)).notifyOpportunisticSubscriptionInfoChanged();
    opptSubList = mSubscriptionControllerUT.getOpportunisticSubscriptions(0, mCallingPackage);
    assertEquals(1, opptSubList.size());
    assertEquals("test2", opptSubList.get(0).getIccId());
    // Changing non-opportunistic sub1 shouldn't trigger callback.
    mSubscriptionControllerUT.setDisplayName("DisplayName", 1);
    verify(mTelephonyRegisteryMock, times(1)).notifyOpportunisticSubscriptionInfoChanged();
    mSubscriptionControllerUT.setDisplayName("DisplayName", 2);
    verify(mTelephonyRegisteryMock, times(2)).notifyOpportunisticSubscriptionInfoChanged();
}
#method_after
@Test
@SmallTest
public void testOpptSubInfoListChanged() throws Exception {
    registerMockTelephonyRegistry();
    verify(mTelephonyRegisteryMock, times(0)).notifyOpportunisticSubscriptionInfoChanged();
    testInsertSim();
    mSubscriptionControllerUT.addSubInfoRecord("test2", 0);
    // Neither sub1 or sub2 are opportunistic. So getOpportunisticSubscriptions
    // should return empty list and no callback triggered.
    List<SubscriptionInfo> opptSubList = mSubscriptionControllerUT.getOpportunisticSubscriptions(mCallingPackage);
    assertTrue(opptSubList.isEmpty());
    verify(mTelephonyRegisteryMock, times(0)).notifyOpportunisticSubscriptionInfoChanged();
    // Setting sub2 as opportunistic should trigger callback.
    mSubscriptionControllerUT.setOpportunistic(true, 2);
    verify(mTelephonyRegisteryMock, times(1)).notifyOpportunisticSubscriptionInfoChanged();
    opptSubList = mSubscriptionControllerUT.getOpportunisticSubscriptions(mCallingPackage);
    assertEquals(1, opptSubList.size());
    assertEquals("test2", opptSubList.get(0).getIccId());
    // Changing non-opportunistic sub1 shouldn't trigger callback.
    mSubscriptionControllerUT.setDisplayName("DisplayName", 1);
    verify(mTelephonyRegisteryMock, times(1)).notifyOpportunisticSubscriptionInfoChanged();
    mSubscriptionControllerUT.setDisplayName("DisplayName", 2);
    verify(mTelephonyRegisteryMock, times(2)).notifyOpportunisticSubscriptionInfoChanged();
}
#end_block

#method_before
private SubscriptionInfo getSubInfoRecord(Cursor cursor) {
    int id = cursor.getInt(cursor.getColumnIndexOrThrow(SubscriptionManager.UNIQUE_KEY_SUBSCRIPTION_ID));
    String iccId = cursor.getString(cursor.getColumnIndexOrThrow(SubscriptionManager.ICC_ID));
    int simSlotIndex = cursor.getInt(cursor.getColumnIndexOrThrow(SubscriptionManager.SIM_SLOT_INDEX));
    String displayName = cursor.getString(cursor.getColumnIndexOrThrow(SubscriptionManager.DISPLAY_NAME));
    String carrierName = cursor.getString(cursor.getColumnIndexOrThrow(SubscriptionManager.CARRIER_NAME));
    int nameSource = cursor.getInt(cursor.getColumnIndexOrThrow(SubscriptionManager.NAME_SOURCE));
    int iconTint = cursor.getInt(cursor.getColumnIndexOrThrow(SubscriptionManager.COLOR));
    String number = cursor.getString(cursor.getColumnIndexOrThrow(SubscriptionManager.NUMBER));
    int dataRoaming = cursor.getInt(cursor.getColumnIndexOrThrow(SubscriptionManager.DATA_ROAMING));
    // Get the blank bitmap for this SubInfoRecord
    Bitmap iconBitmap = BitmapFactory.decodeResource(mContext.getResources(), com.android.internal.R.drawable.ic_sim_card_multi_24px_clr);
    String mcc = cursor.getString(cursor.getColumnIndexOrThrow(SubscriptionManager.MCC_STRING));
    String mnc = cursor.getString(cursor.getColumnIndexOrThrow(SubscriptionManager.MNC_STRING));
    String cardId = cursor.getString(cursor.getColumnIndexOrThrow(SubscriptionManager.CARD_ID));
    // FIXME: consider stick this into database too
    String countryIso = getSubscriptionCountryIso(id);
    boolean isEmbedded = cursor.getInt(cursor.getColumnIndexOrThrow(SubscriptionManager.IS_EMBEDDED)) == 1;
    UiccAccessRule[] accessRules;
    if (isEmbedded) {
        accessRules = UiccAccessRule.decodeRules(cursor.getBlob(cursor.getColumnIndexOrThrow(SubscriptionManager.ACCESS_RULES)));
    } else {
        accessRules = null;
    }
    boolean isOpportunistic = cursor.getInt(cursor.getColumnIndexOrThrow(SubscriptionManager.IS_OPPORTUNISTIC)) == 1;
    int parentSubId = cursor.getInt(cursor.getColumnIndexOrThrow(SubscriptionManager.PARENT_SUB_ID));
    boolean isMetered = cursor.getInt(cursor.getColumnIndexOrThrow(SubscriptionManager.IS_METERED)) == 1;
    if (VDBG) {
        String iccIdToPrint = SubscriptionInfo.givePrintableIccid(iccId);
        String cardIdToPrint = SubscriptionInfo.givePrintableIccid(cardId);
        logd("[getSubInfoRecord] id:" + id + " iccid:" + iccIdToPrint + " simSlotIndex:" + simSlotIndex + " displayName:" + displayName + " nameSource:" + nameSource + " iconTint:" + iconTint + " dataRoaming:" + dataRoaming + " mcc:" + mcc + " mnc:" + mnc + " countIso:" + countryIso + " isEmbedded:" + isEmbedded + " accessRules:" + Arrays.toString(accessRules) + " cardId:" + cardIdToPrint + " isOpportunistic:" + isOpportunistic + " parentSubId:" + parentSubId + " isMetered:" + isMetered);
    }
    // If line1number has been set to a different number, use it instead.
    String line1Number = mTelephonyManager.getLine1Number(id);
    if (!TextUtils.isEmpty(line1Number) && !line1Number.equals(number)) {
        number = line1Number;
    }
    return new SubscriptionInfo(id, iccId, simSlotIndex, displayName, carrierName, nameSource, iconTint, number, dataRoaming, iconBitmap, mcc, mnc, countryIso, isEmbedded, accessRules, cardId, isOpportunistic, parentSubId, isMetered);
}
#method_after
private SubscriptionInfo getSubInfoRecord(Cursor cursor) {
    int id = cursor.getInt(cursor.getColumnIndexOrThrow(SubscriptionManager.UNIQUE_KEY_SUBSCRIPTION_ID));
    String iccId = cursor.getString(cursor.getColumnIndexOrThrow(SubscriptionManager.ICC_ID));
    int simSlotIndex = cursor.getInt(cursor.getColumnIndexOrThrow(SubscriptionManager.SIM_SLOT_INDEX));
    String displayName = cursor.getString(cursor.getColumnIndexOrThrow(SubscriptionManager.DISPLAY_NAME));
    String carrierName = cursor.getString(cursor.getColumnIndexOrThrow(SubscriptionManager.CARRIER_NAME));
    int nameSource = cursor.getInt(cursor.getColumnIndexOrThrow(SubscriptionManager.NAME_SOURCE));
    int iconTint = cursor.getInt(cursor.getColumnIndexOrThrow(SubscriptionManager.COLOR));
    String number = cursor.getString(cursor.getColumnIndexOrThrow(SubscriptionManager.NUMBER));
    int dataRoaming = cursor.getInt(cursor.getColumnIndexOrThrow(SubscriptionManager.DATA_ROAMING));
    // Get the blank bitmap for this SubInfoRecord
    Bitmap iconBitmap = BitmapFactory.decodeResource(mContext.getResources(), com.android.internal.R.drawable.ic_sim_card_multi_24px_clr);
    String mcc = cursor.getString(cursor.getColumnIndexOrThrow(SubscriptionManager.MCC_STRING));
    String mnc = cursor.getString(cursor.getColumnIndexOrThrow(SubscriptionManager.MNC_STRING));
    String cardId = cursor.getString(cursor.getColumnIndexOrThrow(SubscriptionManager.CARD_ID));
    // FIXME: consider stick this into database too
    String countryIso = getSubscriptionCountryIso(id);
    boolean isEmbedded = cursor.getInt(cursor.getColumnIndexOrThrow(SubscriptionManager.IS_EMBEDDED)) == 1;
    UiccAccessRule[] accessRules;
    if (isEmbedded) {
        accessRules = UiccAccessRule.decodeRules(cursor.getBlob(cursor.getColumnIndexOrThrow(SubscriptionManager.ACCESS_RULES)));
    } else {
        accessRules = null;
    }
    boolean isOpportunistic = cursor.getInt(cursor.getColumnIndexOrThrow(SubscriptionManager.IS_OPPORTUNISTIC)) == 1;
    String groupUUID = cursor.getString(cursor.getColumnIndexOrThrow(SubscriptionManager.GROUP_UUID));
    boolean isMetered = cursor.getInt(cursor.getColumnIndexOrThrow(SubscriptionManager.IS_METERED)) == 1;
    if (VDBG) {
        String iccIdToPrint = SubscriptionInfo.givePrintableIccid(iccId);
        String cardIdToPrint = SubscriptionInfo.givePrintableIccid(cardId);
        logd("[getSubInfoRecord] id:" + id + " iccid:" + iccIdToPrint + " simSlotIndex:" + simSlotIndex + " displayName:" + displayName + " nameSource:" + nameSource + " iconTint:" + iconTint + " dataRoaming:" + dataRoaming + " mcc:" + mcc + " mnc:" + mnc + " countIso:" + countryIso + " isEmbedded:" + isEmbedded + " accessRules:" + Arrays.toString(accessRules) + " cardId:" + cardIdToPrint + " isOpportunistic:" + isOpportunistic + " groupUUID:" + groupUUID + " isMetered:" + isMetered);
    }
    // If line1number has been set to a different number, use it instead.
    String line1Number = mTelephonyManager.getLine1Number(id);
    if (!TextUtils.isEmpty(line1Number) && !line1Number.equals(number)) {
        number = line1Number;
    }
    return new SubscriptionInfo(id, iccId, simSlotIndex, displayName, carrierName, nameSource, iconTint, number, dataRoaming, iconBitmap, mcc, mnc, countryIso, isEmbedded, accessRules, cardId, isOpportunistic, groupUUID, isMetered);
}
#end_block

#method_before
private static int setSubscriptionPropertyIntoContentResolver(int subId, String propKey, String propValue, ContentResolver resolver) {
    ContentValues value = new ContentValues();
    switch(propKey) {
        case SubscriptionManager.CB_EXTREME_THREAT_ALERT:
        case SubscriptionManager.CB_SEVERE_THREAT_ALERT:
        case SubscriptionManager.CB_AMBER_ALERT:
        case SubscriptionManager.CB_EMERGENCY_ALERT:
        case SubscriptionManager.CB_ALERT_SOUND_DURATION:
        case SubscriptionManager.CB_ALERT_REMINDER_INTERVAL:
        case SubscriptionManager.CB_ALERT_VIBRATE:
        case SubscriptionManager.CB_ALERT_SPEECH:
        case SubscriptionManager.CB_ETWS_TEST_ALERT:
        case SubscriptionManager.CB_CHANNEL_50_ALERT:
        case SubscriptionManager.CB_CMAS_TEST_ALERT:
        case SubscriptionManager.CB_OPT_OUT_DIALOG:
        case SubscriptionManager.ENHANCED_4G_MODE_ENABLED:
        case SubscriptionManager.IS_OPPORTUNISTIC:
        case SubscriptionManager.PARENT_SUB_ID:
        case SubscriptionManager.IS_METERED:
        case SubscriptionManager.VT_IMS_ENABLED:
        case SubscriptionManager.WFC_IMS_ENABLED:
        case SubscriptionManager.WFC_IMS_MODE:
        case SubscriptionManager.WFC_IMS_ROAMING_MODE:
        case SubscriptionManager.WFC_IMS_ROAMING_ENABLED:
            value.put(propKey, Integer.parseInt(propValue));
            break;
        default:
            if (DBG)
                slogd("Invalid column name");
            break;
    }
    return resolver.update(SubscriptionManager.getUriForSubscriptionId(subId), value, null, null);
}
#method_after
private static int setSubscriptionPropertyIntoContentResolver(int subId, String propKey, String propValue, ContentResolver resolver) {
    ContentValues value = new ContentValues();
    switch(propKey) {
        case SubscriptionManager.CB_EXTREME_THREAT_ALERT:
        case SubscriptionManager.CB_SEVERE_THREAT_ALERT:
        case SubscriptionManager.CB_AMBER_ALERT:
        case SubscriptionManager.CB_EMERGENCY_ALERT:
        case SubscriptionManager.CB_ALERT_SOUND_DURATION:
        case SubscriptionManager.CB_ALERT_REMINDER_INTERVAL:
        case SubscriptionManager.CB_ALERT_VIBRATE:
        case SubscriptionManager.CB_ALERT_SPEECH:
        case SubscriptionManager.CB_ETWS_TEST_ALERT:
        case SubscriptionManager.CB_CHANNEL_50_ALERT:
        case SubscriptionManager.CB_CMAS_TEST_ALERT:
        case SubscriptionManager.CB_OPT_OUT_DIALOG:
        case SubscriptionManager.ENHANCED_4G_MODE_ENABLED:
        case SubscriptionManager.IS_OPPORTUNISTIC:
        case SubscriptionManager.IS_METERED:
        case SubscriptionManager.VT_IMS_ENABLED:
        case SubscriptionManager.WFC_IMS_ENABLED:
        case SubscriptionManager.WFC_IMS_MODE:
        case SubscriptionManager.WFC_IMS_ROAMING_MODE:
        case SubscriptionManager.WFC_IMS_ROAMING_ENABLED:
            value.put(propKey, Integer.parseInt(propValue));
            break;
        default:
            if (DBG)
                slogd("Invalid column name");
            break;
    }
    return resolver.update(SubscriptionManager.getUriForSubscriptionId(subId), value, null, null);
}
#end_block

#method_before
@Override
public String getSubscriptionProperty(int subId, String propKey, String callingPackage) {
    if (!TelephonyPermissions.checkCallingOrSelfReadPhoneState(mContext, subId, callingPackage, "getSubscriptionProperty")) {
        return null;
    }
    String resultValue = null;
    ContentResolver resolver = mContext.getContentResolver();
    Cursor cursor = resolver.query(SubscriptionManager.CONTENT_URI, new String[] { propKey }, SubscriptionManager.UNIQUE_KEY_SUBSCRIPTION_ID + "=?", new String[] { subId + "" }, null);
    try {
        if (cursor != null) {
            if (cursor.moveToFirst()) {
                switch(propKey) {
                    case SubscriptionManager.CB_EXTREME_THREAT_ALERT:
                    case SubscriptionManager.CB_SEVERE_THREAT_ALERT:
                    case SubscriptionManager.CB_AMBER_ALERT:
                    case SubscriptionManager.CB_EMERGENCY_ALERT:
                    case SubscriptionManager.CB_ALERT_SOUND_DURATION:
                    case SubscriptionManager.CB_ALERT_REMINDER_INTERVAL:
                    case SubscriptionManager.CB_ALERT_VIBRATE:
                    case SubscriptionManager.CB_ALERT_SPEECH:
                    case SubscriptionManager.CB_ETWS_TEST_ALERT:
                    case SubscriptionManager.CB_CHANNEL_50_ALERT:
                    case SubscriptionManager.CB_CMAS_TEST_ALERT:
                    case SubscriptionManager.CB_OPT_OUT_DIALOG:
                    case SubscriptionManager.ENHANCED_4G_MODE_ENABLED:
                    case SubscriptionManager.VT_IMS_ENABLED:
                    case SubscriptionManager.WFC_IMS_ENABLED:
                    case SubscriptionManager.WFC_IMS_MODE:
                    case SubscriptionManager.WFC_IMS_ROAMING_MODE:
                    case SubscriptionManager.WFC_IMS_ROAMING_ENABLED:
                    case SubscriptionManager.IS_OPPORTUNISTIC:
                    case SubscriptionManager.PARENT_SUB_ID:
                    case SubscriptionManager.IS_METERED:
                        resultValue = cursor.getInt(0) + "";
                        break;
                    default:
                        if (DBG)
                            logd("Invalid column name");
                        break;
                }
            } else {
                if (DBG)
                    logd("Valid row not present in db");
            }
        } else {
            if (DBG)
                logd("Query failed");
        }
    } finally {
        if (cursor != null) {
            cursor.close();
        }
    }
    if (DBG)
        logd("getSubscriptionProperty Query value = " + resultValue);
    return resultValue;
}
#method_after
@Override
public String getSubscriptionProperty(int subId, String propKey, String callingPackage) {
    if (!TelephonyPermissions.checkCallingOrSelfReadPhoneState(mContext, subId, callingPackage, "getSubscriptionProperty")) {
        return null;
    }
    String resultValue = null;
    ContentResolver resolver = mContext.getContentResolver();
    Cursor cursor = resolver.query(SubscriptionManager.CONTENT_URI, new String[] { propKey }, SubscriptionManager.UNIQUE_KEY_SUBSCRIPTION_ID + "=?", new String[] { subId + "" }, null);
    try {
        if (cursor != null) {
            if (cursor.moveToFirst()) {
                switch(propKey) {
                    case SubscriptionManager.CB_EXTREME_THREAT_ALERT:
                    case SubscriptionManager.CB_SEVERE_THREAT_ALERT:
                    case SubscriptionManager.CB_AMBER_ALERT:
                    case SubscriptionManager.CB_EMERGENCY_ALERT:
                    case SubscriptionManager.CB_ALERT_SOUND_DURATION:
                    case SubscriptionManager.CB_ALERT_REMINDER_INTERVAL:
                    case SubscriptionManager.CB_ALERT_VIBRATE:
                    case SubscriptionManager.CB_ALERT_SPEECH:
                    case SubscriptionManager.CB_ETWS_TEST_ALERT:
                    case SubscriptionManager.CB_CHANNEL_50_ALERT:
                    case SubscriptionManager.CB_CMAS_TEST_ALERT:
                    case SubscriptionManager.CB_OPT_OUT_DIALOG:
                    case SubscriptionManager.ENHANCED_4G_MODE_ENABLED:
                    case SubscriptionManager.VT_IMS_ENABLED:
                    case SubscriptionManager.WFC_IMS_ENABLED:
                    case SubscriptionManager.WFC_IMS_MODE:
                    case SubscriptionManager.WFC_IMS_ROAMING_MODE:
                    case SubscriptionManager.WFC_IMS_ROAMING_ENABLED:
                    case SubscriptionManager.IS_OPPORTUNISTIC:
                    case SubscriptionManager.GROUP_UUID:
                    case SubscriptionManager.IS_METERED:
                        resultValue = cursor.getInt(0) + "";
                        break;
                    default:
                        if (DBG)
                            logd("Invalid column name");
                        break;
                }
            } else {
                if (DBG)
                    logd("Valid row not present in db");
            }
        } else {
            if (DBG)
                logd("Query failed");
        }
    } finally {
        if (cursor != null) {
            cursor.close();
        }
    }
    if (DBG)
        logd("getSubscriptionProperty Query value = " + resultValue);
    return resultValue;
}
#end_block

#method_before
@Override
public List<SubscriptionInfo> getOpportunisticSubscriptions(int slotId, String callingPackage) {
    return getSubscriptionInfoListFromCacheHelper(callingPackage, mCacheOpportunisticSubInfoList);
}
#method_after
@Override
public List<SubscriptionInfo> getOpportunisticSubscriptions(String callingPackage) {
    return getSubscriptionInfoListFromCacheHelper(callingPackage, mCacheOpportunisticSubInfoList);
}
#end_block

#method_before
// Helper function of getOpportunisticSubscriptions and getActiveSubscriptionInfoList.
private List<SubscriptionInfo> getSubscriptionInfoListFromCacheHelper(String callingPackage, List<SubscriptionInfo> cacheSubList) {
    if (!isSubInfoReady()) {
        if (DBG)
            logdl("[getSubscriptionInfoList] Sub Controller not ready");
        return null;
    }
    boolean canReadAllPhoneState;
    try {
        canReadAllPhoneState = TelephonyPermissions.checkReadPhoneState(mContext, SubscriptionManager.INVALID_SUBSCRIPTION_ID, Binder.getCallingPid(), Binder.getCallingUid(), callingPackage, "getSubscriptionInfoList");
    } catch (SecurityException e) {
        canReadAllPhoneState = false;
    }
    synchronized (mSubInfoListLock) {
        // If the caller can read all phone state, just return the full list.
        if (canReadAllPhoneState) {
            return new ArrayList<>(cacheSubList);
        }
        // Filter the list to only include subscriptions which the caller can manage.
        return cacheSubList.stream().filter(subscriptionInfo -> {
            try {
                return TelephonyPermissions.checkCallingOrSelfReadPhoneState(mContext, subscriptionInfo.getSubscriptionId(), callingPackage, "getOpportunisticSubscriptions");
            } catch (SecurityException e) {
                return false;
            }
        }).collect(Collectors.toList());
    }
}
#method_after
// Helper function of getOpportunisticSubscriptions and getActiveSubscriptionInfoList.
private List<SubscriptionInfo> getSubscriptionInfoListFromCacheHelper(String callingPackage, List<SubscriptionInfo> cacheSubList) {
    if (!isSubInfoReady()) {
        if (DBG)
            logdl("[getSubscriptionInfoList] Sub Controller not ready");
        return null;
    }
    boolean canReadAllPhoneState;
    try {
        canReadAllPhoneState = TelephonyPermissions.checkReadPhoneState(mContext, SubscriptionManager.INVALID_SUBSCRIPTION_ID, Binder.getCallingPid(), Binder.getCallingUid(), callingPackage, "getSubscriptionInfoList");
    } catch (SecurityException e) {
        canReadAllPhoneState = false;
    }
    synchronized (mSubInfoListLock) {
        // If the caller can read all phone state, just return the full list.
        if (canReadAllPhoneState) {
            return new ArrayList<>(cacheSubList);
        }
        // Filter the list to only include subscriptions which the caller can manage.
        return cacheSubList.stream().filter(subscriptionInfo -> {
            try {
                return TelephonyPermissions.checkCallingOrSelfReadPhoneState(mContext, subscriptionInfo.getSubscriptionId(), callingPackage, "getSubscriptionInfoList");
            } catch (SecurityException e) {
                return false;
            }
        }).collect(Collectors.toList());
    }
}
#end_block

#method_before
public int getProvisionStatus() {
    return mProvisionStatus;
}
#method_after
@ServiceProvisionStatus
public int getProvisionStatus() {
    return mProvisionStatus;
}
#end_block

#method_before
@Override
public void invocationStarted(IInvocationContext context) {
    mContext = context;
    InvocationStartedEventInfo info = new InvocationStartedEventInfo(context.getTestTag(), System.currentTimeMillis());
    printEvent(SubprocessTestResultsParser.StatusKeys.INVOCATION_STARTED, info);
}
#method_after
@Override
public void invocationStarted(IInvocationContext context) {
    InvocationStartedEventInfo info = new InvocationStartedEventInfo(context.getTestTag(), System.currentTimeMillis());
    printEvent(SubprocessTestResultsParser.StatusKeys.INVOCATION_STARTED, info);
    // Save off primary build info so that we can parse it later during invocation ended.
    List<IBuildInfo> infos = context.getBuildInfos();
    mPrimaryBuildInfo = infos.isEmpty() ? null : infos.get(0);
}
#end_block

#method_before
@Override
public void invocationEnded(long elapsedTime) {
    if (mContext == null) {
        return;
    }
    // If no primary build exists, don't bother outputting the event.
    for (IBuildInfo info : mContext.getBuildInfos()) {
        InvocationEndedEventInfo eventEnd = new InvocationEndedEventInfo(info.getBuildAttributes());
        printEvent(SubprocessTestResultsParser.StatusKeys.INVOCATION_ENDED, info);
        break;
    }
}
#method_after
@Override
public void invocationEnded(long elapsedTime) {
    if (mPrimaryBuildInfo == null) {
        return;
    }
    InvocationEndedEventInfo eventEnd = new InvocationEndedEventInfo(mPrimaryBuildInfo.getBuildAttributes());
    printEvent(SubprocessTestResultsParser.StatusKeys.INVOCATION_ENDED, eventEnd);
}
#end_block

#method_before
@Override
public void handleEvent(String eventJson) throws JSONException {
    InvocationEndedEventInfo eventEnd = new InvocationEndedEventInfo(new JSONObject(eventJson));
    // provider of the running configurationl.
    for (IBuildInfo info : mContext.getBuildInfos()) {
        Map<String, String> parentAttributes = info.getBuildAttributes();
        for (String key : eventEnd.mBuildAttributes.keySet()) {
            if (!parentAttributes.containsKey(key)) {
                info.addBuildAttribute(key, eventEnd.mBuildAttributes.get(key));
            }
        }
        break;
    }
}
#method_after
@Override
public void handleEvent(String eventJson) throws JSONException {
    JSONObject json = new JSONObject(eventJson);
    InvocationEndedEventInfo eventEnd = new InvocationEndedEventInfo(json);
    // Add build attributes to the primary build (the first build
    // provider of the running configuration).
    List<IBuildInfo> infos = mContext.getBuildInfos();
    if (!infos.isEmpty()) {
        infos.get(0).addBuildAttributes(eventEnd.mBuildAttributes);
    }
}
#end_block

#method_before
@Override
protected void onPostExecute(MediaMetadata metadata) {
    if (metadata != null) {
        mMediaItem.setMetadata(metadata);
    }
    if (mCurrentItemIsMusic) {
        // Update Music View to reflect the new metadata
        mInstance.removeView(mSurfaceView);
        mInstance.removeView(mTextureView);
        updateCurrentMusicView(mMusicEmbeddedView);
    }
}
#method_after
@Override
protected void onPostExecute(MediaMetadata metadata) {
    if (metadata != null) {
        mMediaItem.setMetadata(metadata);
    }
    synchronized (mLock) {
        if (mCurrentItemIsMusic) {
            // Update Music View to reflect the new metadata
            mInstance.removeView(mSurfaceView);
            mInstance.removeView(mTextureView);
            updateCurrentMusicView(mMusicEmbeddedView);
        }
    }
}
#end_block

#method_before
@Test
public void testEmptyProcessName() {
    assertFalse(mShowmapHelper.sampleOnTestStart(""));
}
#method_after
@Test
public void testEmptyProcessName() {
    mShowmapHelper.setUp("");
    assertFalse(mShowmapHelper.startCollecting());
}
#end_block

#method_before
@Test
public void testSamplesMemory() {
    assertTrue(mShowmapHelper.sampleOnTestStart(TEST_PROCESS_NAME));
    assertTrue(mShowmapHelper.sampleOnTestEnd());
}
#method_after
@Test
public void testSamplesMemory() {
    mShowmapHelper.setUp(TEST_PROCESS_NAME);
    assertTrue(mShowmapHelper.startCollecting());
}
#end_block

#method_before
@Test
public void testGetMetrics() {
    assertTrue(mShowmapHelper.sampleOnTestStart(TEST_PROCESS_NAME));
    assertTrue(mShowmapHelper.sampleOnTestEnd());
    Map<String, Long> showmapMetrics = mShowmapHelper.getMetrics();
    assertTrue(!showmapMetrics.isEmpty());
}
#method_after
@Test
public void testGetMetrics() {
    mShowmapHelper.setUp(TEST_PROCESS_NAME);
    assertTrue(mShowmapHelper.startCollecting());
    Map<String, Long> showmapMetrics = mShowmapHelper.getMetrics();
    assertTrue(!showmapMetrics.isEmpty());
    assertTrue(showmapMetrics.containsKey(constructKey(TEST_PROCESS_NAME, PSS)));
    assertTrue(showmapMetrics.containsKey(constructKey(TEST_PROCESS_NAME, PSS, DELTA)));
}
#end_block

#method_before
public Map<String, Long> getMetrics() {
    HashMap<String, Long> showmapFinalMap = new HashMap<>();
    if (mTestEndMetrics == null) {
        Log.e(TAG, "Unable to sample showmap memory at test end.");
        return showmapFinalMap;
    }
    showmapFinalMap.put(String.format("%s_%s", mProcessName, "pss"), mTestEndMetrics.pss);
    showmapFinalMap.put(String.format("%s_%s", mProcessName, "rss"), mTestEndMetrics.rss);
    showmapFinalMap.put(String.format("%s_%s", mProcessName, "vss"), mTestEndMetrics.vss);
    if (mTestStartMetrics == null) {
        Log.i(TAG, "Unable to get deltas because we were unable to sample memory when the " + "test began");
        return showmapFinalMap;
    }
    showmapFinalMap.put(String.format("%s_%s", mProcessName, "pssDelta"), mTestEndMetrics.pss - mTestStartMetrics.pss);
    showmapFinalMap.put(String.format("%s_%s", mProcessName, "rssDelta"), mTestEndMetrics.rss - mTestStartMetrics.rss);
    showmapFinalMap.put(String.format("%s_%s", mProcessName, "vssDelta"), mTestEndMetrics.vss - mTestStartMetrics.vss);
    return showmapFinalMap;
}
#method_after
@Override
public Map<String, Long> getMetrics() {
    // Collect end sample.
    HashMap<String, Long> showmapFinalMap = new HashMap<>();
    mTestEndMetrics = sampleMemory(mProcessName);
    if (mTestEndMetrics == null) {
        Log.e(TAG, "Unable to collect showmap memory at test end.");
        return showmapFinalMap;
    }
    // Calculate and determine final metrics.
    showmapFinalMap.put(constructKey(mProcessName, PSS), mTestEndMetrics.pss);
    showmapFinalMap.put(constructKey(mProcessName, RSS), mTestEndMetrics.rss);
    showmapFinalMap.put(constructKey(mProcessName, VSS), mTestEndMetrics.vss);
    if (mTestStartMetrics == null) {
        Log.i(TAG, "Unable to get deltas because we were unable to sample memory when the " + "test began");
        return showmapFinalMap;
    }
    showmapFinalMap.put(constructKey(mProcessName, PSS, DELTA), mTestEndMetrics.pss - mTestStartMetrics.pss);
    showmapFinalMap.put(constructKey(mProcessName, RSS, DELTA), mTestEndMetrics.rss - mTestStartMetrics.rss);
    showmapFinalMap.put(constructKey(mProcessName, VSS, DELTA), mTestEndMetrics.vss - mTestStartMetrics.vss);
    return showmapFinalMap;
}
#end_block

#method_before
private ShowmapMetrics sampleMemory(String processName) {
    ShowmapMetrics metrics = new ShowmapMetrics();
    // Get pid
    int pid;
    try {
        // Note that only the first pid returned by "pidof" will be used.
        String pidofOutput = mUIDevice.executeShellCommand(String.format(PIDOF_CMD, processName));
        pid = NumberFormat.getInstance().parse(pidofOutput).intValue();
    } catch (Exception e) {
        Log.e(TAG, "Unable to get pid of process", e);
        return null;
    }
    // Read showmap for process
    String showmapOutput;
    try {
        showmapOutput = mUIDevice.executeShellCommand(String.format(SHOWMAP_CMD, pid));
    } catch (IOException e) {
        Log.e(TAG, "Failed to get showmap output", e);
        return null;
    }
    // CHECKSTYLE:ON Generated code
    try {
        int pos = showmapOutput.lastIndexOf("----");
        Scanner sc = new Scanner(showmapOutput.substring(pos));
        sc.next();
        metrics.vss = sc.nextLong();
        metrics.rss = sc.nextLong();
        metrics.pss = sc.nextLong();
    } catch (Exception e) {
        Log.e(TAG, "Unexpected showmap format", e);
        return null;
    }
    return metrics;
}
#method_after
private ShowmapMetrics sampleMemory(String processName) {
    if (processName == null || mUiDevice == null) {
        Log.e(TAG, "Process name or UI device is null. Make sure you've called setup.");
        return null;
    }
    // Get pid
    int pid;
    try {
        // Note that only the first pid returned by "pidof" will be used.
        String pidofOutput = mUiDevice.executeShellCommand(String.format(PIDOF_CMD, processName));
        pid = NumberFormat.getInstance().parse(pidofOutput).intValue();
    } catch (IOException | ParseException e) {
        Log.e(TAG, "Unable to get pid of process", e);
        return null;
    }
    // Read showmap for process
    String showmapOutput;
    try {
        showmapOutput = mUiDevice.executeShellCommand(String.format(SHOWMAP_CMD, pid));
    } catch (IOException e) {
        Log.e(TAG, String.format("Failed to get showmap output for %s ", processName), e);
        return null;
    }
    ShowmapMetrics metrics = new ShowmapMetrics();
    // CHECKSTYLE:ON Generated code
    try {
        int pos = showmapOutput.lastIndexOf("----");
        Scanner sc = new Scanner(showmapOutput.substring(pos));
        sc.next();
        metrics.vss = sc.nextLong();
        metrics.rss = sc.nextLong();
        metrics.pss = sc.nextLong();
    } catch (IndexOutOfBoundsException | InputMismatchException e) {
        Log.e(TAG, "Unexpected showmap format", e);
        return null;
    }
    return metrics;
}
#end_block

#method_before
@Override
public boolean isExternal() {
    return true;
}
#method_after
@Override
public boolean isExternal() {
    return false;
}
#end_block

#method_before
private ClassLoader createLoaderDirect(File... files) throws IOException {
    assertNotNull(files);
    assertTrue(files.length > 0);
    ClassLoader result = ClassLoader.getSystemClassLoader();
    for (int i = 0; i < files.length; ++i) {
        ByteBuffer buffer = ReadFileToByteBufferDirect(files[i]);
        result = new InMemoryDexClassLoader(new ByteBuffer[] { buffer }, srcDir.getAbsolutePath(), result);
    }
    return result;
}
#method_after
private ClassLoader createLoaderDirect(File... files) throws IOException {
    assertNotNull(files);
    assertTrue(files.length > 0);
    ClassLoader result = ClassLoader.getSystemClassLoader();
    for (int i = 0; i < files.length; ++i) {
        ByteBuffer buffer = readFileToByteBufferDirect(files[i]);
        result = new InMemoryDexClassLoader(new ByteBuffer[] { buffer }, result);
    }
    return result;
}
#end_block

#method_before
private ClassLoader createLoaderIndirect(File... files) throws IOException {
    assertNotNull(files);
    assertTrue(files.length > 0);
    ClassLoader result = ClassLoader.getSystemClassLoader();
    for (int i = 0; i < files.length; ++i) {
        ByteBuffer buffer = ReadFileToByteBufferIndirect(files[i]);
        result = new InMemoryDexClassLoader(new ByteBuffer[] { buffer }, srcDir.getAbsolutePath(), result);
    }
    return result;
}
#method_after
private ClassLoader createLoaderIndirect(File... files) throws IOException {
    assertNotNull(files);
    assertTrue(files.length > 0);
    ClassLoader result = ClassLoader.getSystemClassLoader();
    for (int i = 0; i < files.length; ++i) {
        ByteBuffer buffer = readFileToByteBufferIndirect(files[i]);
        result = new InMemoryDexClassLoader(new ByteBuffer[] { buffer }, result);
    }
    return result;
}
#end_block

#method_before
public void testLibraryPath() throws IOException {
    File tmp = new File(System.getProperty("java.io.tmpdir"));
    File applicationLibPath = new File(tmp, "applicationLibPath");
    File applicationLib = makeTempFile(applicationLibPath, "libtestlibpath.so");
    InMemoryDexClassLoader classLoader = createLoaderLibPath(dex1, applicationLibPath);
    String path = classLoader.findLibrary("testlibpath");
    assertEquals(applicationLib.toString(), path);
}
#method_after
public void testLibraryPath() throws IOException {
    File applicationLibPath = new File(srcDir, "applicationLibPath");
    File applicationLib = makeEmptyFile(applicationLibPath, "libtestlibpath.so");
    InMemoryDexClassLoader classLoader = createLoaderWithLibPath(dex1, applicationLibPath);
    String path = classLoader.findLibrary("testlibpath");
    assertEquals(applicationLib.toString(), path);
}
#end_block

#method_before
public void testLibraryPathSearchOrder() throws IOException {
    File tmp = new File(System.getProperty("java.io.tmpdir"));
    File systemLibPath = new File(tmp, "systemLibPath");
    File applicationLibPath = new File(tmp, "applicationLibPath");
    makeTempFile(systemLibPath, "libduplicated.so");
    File applicationLib = makeTempFile(applicationLibPath, "libduplicated.so");
    System.setProperty("java.library.path", systemLibPath.toString());
    InMemoryDexClassLoader classLoader = createLoaderLibPath(dex1, applicationLibPath);
    String path = classLoader.findLibrary("duplicated");
    assertEquals(applicationLib.toString(), path);
}
#method_after
public void testLibraryPathSearchOrder() throws IOException {
    File systemLibPath = new File(srcDir, "systemLibPath");
    File applicationLibPath = new File(srcDir, "applicationLibPath");
    makeEmptyFile(systemLibPath, "libduplicated.so");
    File applicationLib = makeEmptyFile(applicationLibPath, "libduplicated.so");
    System.setProperty("java.library.path", systemLibPath.toString());
    InMemoryDexClassLoader classLoader = createLoaderWithLibPath(dex1, applicationLibPath);
    String path = classLoader.findLibrary("duplicated");
    assertEquals(applicationLib.toString(), path);
}
#end_block

#method_before
private Object implCompute(Object key, BiFunction<? super Object, ? super Object, ? extends Object> remappingFunction) {
    if (key instanceof String) {
        if (!checkLegacy(key)) {
            return null;
        }
        // BEGIN Android-changed: use compute() instead of computeIfAbsent() to avoid cast fails
        // legacyStrings.computeIfAbsent((String) key,
        // (Function<? super String, ? extends String>) remappingFunction);
        // which cannot ever succeed as the cast from BiFunction to Function always fails
        legacyStrings.compute((String) key, (BiFunction<? super String, ? super String, ? extends String>) remappingFunction);
    // END Android-changed: use compute() instead of computeIfAbsent() to avoid cast fails
    }
    return super.compute(key, remappingFunction);
}
#method_after
private Object implCompute(Object key, BiFunction<? super Object, ? super Object, ? extends Object> remappingFunction) {
    if (key instanceof String) {
        if (!checkLegacy(key)) {
            return null;
        }
        // BEGIN Android-changed: use compute() instead of computeIfAbsent() to avoid cast fails
        // The upstream code cannot ever succeed as the cast from BiFunction to Function
        // always fails.
        // legacyStrings.computeIfAbsent((String) key,
        // (Function<? super String, ? extends String>) remappingFunction);
        legacyStrings.compute((String) key, (BiFunction<? super String, ? super String, ? extends String>) remappingFunction);
    // END Android-changed: use compute() instead of computeIfAbsent() to avoid cast fails
    }
    return super.compute(key, remappingFunction);
}
#end_block

#method_before
// BEGIN Android-added:  Add ALPN-related methods from OpenJDK 9.
// Also removed references to DTLS in documentation; Android doesn't support DTLS.
public String getApplicationProtocol() {
    throw new UnsupportedOperationException();
}
#method_after
// BEGIN Android-added: Integrate ALPN-related methods from OpenJDK 9+181
// Also removed references to DTLS in documentation; Android doesn't support DTLS.
public String getApplicationProtocol() {
    throw new UnsupportedOperationException();
}
#end_block

#method_before
// BEGIN Android-added: Add ALPN-related methods from OpenJDK 9.
// Also removed references to DTLS in documentation; Android doesn't support DTLS.
public String[] getApplicationProtocols() {
    return applicationProtocols.clone();
}
#method_after
// BEGIN Android-added: Integrate ALPN-related methods from OpenJDK 9+181
// Also removed references to DTLS in documentation; Android doesn't support DTLS.
public String[] getApplicationProtocols() {
    return applicationProtocols.clone();
}
#end_block

#method_before
@Override
public void onBindViewHolder(PreferenceViewHolder view) {
    super.onBindViewHolder(view);
    View widget = view.findViewById(R.id.apn_radiobutton);
    if ((widget != null) && widget instanceof RadioButton) {
        RadioButton rb = (RadioButton) widget;
        if (mSelectable) {
            rb.setOnCheckedChangeListener(this);
            boolean isChecked = getKey().equals(mSelectedKey);
            if (isChecked) {
                mCurrentChecked = rb;
                mSelectedKey = getKey();
            }
            mProtectFromCheckedChange = true;
            rb.setChecked(isChecked);
            mProtectFromCheckedChange = false;
            rb.setVisibility(View.VISIBLE);
        } else {
            rb.setVisibility(View.GONE);
        }
    }
    View textLayout = view.findViewById(R.id.text_layout);
    if ((textLayout != null) && textLayout instanceof RelativeLayout) {
        textLayout.setOnClickListener(this);
    }
}
#method_after
@Override
public void onBindViewHolder(PreferenceViewHolder view) {
    super.onBindViewHolder(view);
    View widget = view.findViewById(R.id.apn_radiobutton);
    if ((widget != null) && widget instanceof RadioButton) {
        RadioButton rb = (RadioButton) widget;
        if (mSelectable) {
            rb.setOnCheckedChangeListener(this);
            boolean isChecked = getKey().equals(mSelectedKey);
            if (isChecked) {
                mCurrentChecked = rb;
                mSelectedKey = getKey();
            }
            mProtectFromCheckedChange = true;
            rb.setChecked(isChecked);
            mProtectFromCheckedChange = false;
            rb.setVisibility(View.VISIBLE);
        } else {
            rb.setVisibility(View.GONE);
        }
    }
}
#end_block

#method_before
public void onClick(android.view.View v) {
    if ((v != null) && (R.id.text_layout == v.getId())) {
        Context context = getContext();
        if (context != null) {
            if (!mEditable) {
                PresetApnUtil.showMessage(context);
                return;
            }
            int pos = Integer.parseInt(getKey());
            Uri url = ContentUris.withAppendedId(Telephony.Carriers.CONTENT_URI, pos);
            Intent editIntent = new Intent(Intent.ACTION_EDIT, url);
            editIntent.putExtra(ApnSettings.SUB_ID, mSubId);
            context.startActivity(editIntent);
        }
    }
}
#method_after
@Override
protected void onClick() {
    super.onClick();
    Context context = getContext();
    if (context != null) {
        if (mHideDetails) {
            Toast.makeText(context, context.getString(R.string.cannot_change_apn_toast), Toast.LENGTH_LONG).show();
            return;
        }
        int pos = Integer.parseInt(getKey());
        Uri url = ContentUris.withAppendedId(Telephony.Carriers.CONTENT_URI, pos);
        Intent editIntent = new Intent(Intent.ACTION_EDIT, url);
        editIntent.putExtra(ApnSettings.SUB_ID, mSubId);
        context.startActivity(editIntent);
    }
}
#end_block

#method_before
@Override
public void onCreate(Bundle icicle) {
    super.onCreate(icicle);
    final Activity activity = getActivity();
    mSubId = activity.getIntent().getIntExtra(SUB_ID, SubscriptionManager.INVALID_SUBSCRIPTION_ID);
    mIntentFilter = new IntentFilter(TelephonyIntents.ACTION_ANY_DATA_CONNECTION_STATE_CHANGED);
    mIntentFilter.addAction(TelephonyManager.ACTION_SUBSCRIPTION_CARRIER_IDENTITY_CHANGED);
    setIfOnlyAvailableForAdmins(true);
    mSubscriptionInfo = getSubscriptionInfo(mSubId);
    mUiccController = UiccController.getInstance();
    CarrierConfigManager configManager = (CarrierConfigManager) getSystemService(Context.CARRIER_CONFIG_SERVICE);
    PersistableBundle b = configManager.getConfig();
    mHideImsApn = b.getBoolean(CarrierConfigManager.KEY_HIDE_IMS_APN_BOOL);
    mAllowAddingApns = b.getBoolean(CarrierConfigManager.KEY_ALLOW_ADDING_APNS_BOOL);
    if (mAllowAddingApns) {
        String[] readOnlyApnTypes = b.getStringArray(CarrierConfigManager.KEY_READ_ONLY_APN_TYPES_STRING_ARRAY);
        // if no apn type can be edited, do not allow adding APNs
        if (ApnEditor.hasAllApns(readOnlyApnTypes)) {
            Log.d(TAG, "not allowing adding APN because all APN types are read only");
            mAllowAddingApns = false;
        }
    }
    mHidePresetApnDetail = b.getBoolean(CarrierConfigManager.KEY_HIDE_PRESET_APN_DETAIL_BOOL);
    mUserManager = UserManager.get(activity);
}
#method_after
@Override
public void onCreate(Bundle icicle) {
    super.onCreate(icicle);
    final Activity activity = getActivity();
    mSubId = activity.getIntent().getIntExtra(SUB_ID, SubscriptionManager.INVALID_SUBSCRIPTION_ID);
    mIntentFilter = new IntentFilter(TelephonyIntents.ACTION_ANY_DATA_CONNECTION_STATE_CHANGED);
    mIntentFilter.addAction(TelephonyManager.ACTION_SUBSCRIPTION_CARRIER_IDENTITY_CHANGED);
    setIfOnlyAvailableForAdmins(true);
    mSubscriptionInfo = getSubscriptionInfo(mSubId);
    mUiccController = UiccController.getInstance();
    CarrierConfigManager configManager = (CarrierConfigManager) getSystemService(Context.CARRIER_CONFIG_SERVICE);
    PersistableBundle b = configManager.getConfigForSubId(mSubId);
    mHideImsApn = b.getBoolean(CarrierConfigManager.KEY_HIDE_IMS_APN_BOOL);
    mAllowAddingApns = b.getBoolean(CarrierConfigManager.KEY_ALLOW_ADDING_APNS_BOOL);
    if (mAllowAddingApns) {
        String[] readOnlyApnTypes = b.getStringArray(CarrierConfigManager.KEY_READ_ONLY_APN_TYPES_STRING_ARRAY);
        // if no apn type can be edited, do not allow adding APNs
        if (ApnEditor.hasAllApns(readOnlyApnTypes)) {
            Log.d(TAG, "not allowing adding APN because all APN types are read only");
            mAllowAddingApns = false;
        }
    }
    mHidePresetApnDetails = b.getBoolean(CarrierConfigManager.KEY_HIDE_PRESET_APN_DETAILS_BOOL);
    mUserManager = UserManager.get(activity);
}
#end_block

#method_before
private void fillList() {
    final TelephonyManager tm = (TelephonyManager) getSystemService(Context.TELEPHONY_SERVICE);
    final int subId = mSubscriptionInfo != null ? mSubscriptionInfo.getSubscriptionId() : SubscriptionManager.INVALID_SUBSCRIPTION_ID;
    final String mccmnc = mSubscriptionInfo == null ? "" : tm.getSimOperator(subId);
    Log.d(TAG, "mccmnc = " + mccmnc);
    StringBuilder where = new StringBuilder("numeric=\"" + mccmnc + "\" AND NOT (type='ia' AND (apn=\"\" OR apn IS NULL)) AND user_visible!=0");
    if (mHideImsApn) {
        where.append(" AND NOT (type='ims')");
    }
    Cursor cursor = getContentResolver().query(Telephony.Carriers.CONTENT_URI, new String[] { "_id", "name", "apn", "type", "mvno_type", "mvno_match_data" }, where.toString(), null, Telephony.Carriers.DEFAULT_SORT_ORDER);
    if (cursor != null) {
        IccRecords r = null;
        if (mUiccController != null && mSubscriptionInfo != null) {
            r = mUiccController.getIccRecords(SubscriptionManager.getPhoneId(subId), UiccController.APP_FAM_3GPP);
        }
        PreferenceGroup apnList = (PreferenceGroup) findPreference("apn_list");
        apnList.removeAll();
        ArrayList<ApnPreference> mnoApnList = new ArrayList<ApnPreference>();
        ArrayList<ApnPreference> mvnoApnList = new ArrayList<ApnPreference>();
        ArrayList<ApnPreference> mnoMmsApnList = new ArrayList<ApnPreference>();
        ArrayList<ApnPreference> mvnoMmsApnList = new ArrayList<ApnPreference>();
        mSelectedKey = getSelectedApnKey();
        cursor.moveToFirst();
        while (!cursor.isAfterLast()) {
            String name = cursor.getString(NAME_INDEX);
            String apn = cursor.getString(APN_INDEX);
            String key = cursor.getString(ID_INDEX);
            String type = cursor.getString(TYPES_INDEX);
            String mvnoType = cursor.getString(MVNO_TYPE_INDEX);
            String mvnoMatchData = cursor.getString(MVNO_MATCH_DATA_INDEX);
            ApnPreference pref = new ApnPreference(getPrefContext());
            pref.setKey(key);
            pref.setTitle(name);
            pref.setSummary(apn);
            pref.setPersistent(false);
            pref.setOnPreferenceChangeListener(this);
            pref.setSubId(subId);
            if (mHidePresetApnDetail) {
                pref.setNonEditableByKey(key);
            }
            boolean selectable = ((type == null) || !type.equals("mms"));
            pref.setSelectable(selectable);
            if (selectable) {
                if ((mSelectedKey != null) && mSelectedKey.equals(key)) {
                    pref.setChecked();
                }
                addApnToList(pref, mnoApnList, mvnoApnList, r, mvnoType, mvnoMatchData);
            } else {
                addApnToList(pref, mnoMmsApnList, mvnoMmsApnList, r, mvnoType, mvnoMatchData);
            }
            cursor.moveToNext();
        }
        cursor.close();
        if (!mvnoApnList.isEmpty()) {
            mnoApnList = mvnoApnList;
            mnoMmsApnList = mvnoMmsApnList;
        // Also save the mvno info
        }
        for (Preference preference : mnoApnList) {
            apnList.addPreference(preference);
        }
        for (Preference preference : mnoMmsApnList) {
            apnList.addPreference(preference);
        }
    }
}
#method_after
private void fillList() {
    final TelephonyManager tm = (TelephonyManager) getSystemService(Context.TELEPHONY_SERVICE);
    final int subId = mSubscriptionInfo != null ? mSubscriptionInfo.getSubscriptionId() : SubscriptionManager.INVALID_SUBSCRIPTION_ID;
    final String mccmnc = mSubscriptionInfo == null ? "" : tm.getSimOperator(subId);
    Log.d(TAG, "mccmnc = " + mccmnc);
    StringBuilder where = new StringBuilder("numeric=\"" + mccmnc + "\" AND NOT (type='ia' AND (apn=\"\" OR apn IS NULL)) AND user_visible!=0");
    if (mHideImsApn) {
        where.append(" AND NOT (type='ims')");
    }
    Cursor cursor = getContentResolver().query(Telephony.Carriers.CONTENT_URI, CARRIERS_PROJECTION, where.toString(), null, Telephony.Carriers.DEFAULT_SORT_ORDER);
    if (cursor != null) {
        IccRecords r = null;
        if (mUiccController != null && mSubscriptionInfo != null) {
            r = mUiccController.getIccRecords(SubscriptionManager.getPhoneId(subId), UiccController.APP_FAM_3GPP);
        }
        PreferenceGroup apnList = (PreferenceGroup) findPreference("apn_list");
        apnList.removeAll();
        ArrayList<ApnPreference> mnoApnList = new ArrayList<ApnPreference>();
        ArrayList<ApnPreference> mvnoApnList = new ArrayList<ApnPreference>();
        ArrayList<ApnPreference> mnoMmsApnList = new ArrayList<ApnPreference>();
        ArrayList<ApnPreference> mvnoMmsApnList = new ArrayList<ApnPreference>();
        mSelectedKey = getSelectedApnKey();
        cursor.moveToFirst();
        while (!cursor.isAfterLast()) {
            String name = cursor.getString(NAME_INDEX);
            String apn = cursor.getString(APN_INDEX);
            String key = cursor.getString(ID_INDEX);
            String type = cursor.getString(TYPES_INDEX);
            String mvnoType = cursor.getString(MVNO_TYPE_INDEX);
            String mvnoMatchData = cursor.getString(MVNO_MATCH_DATA_INDEX);
            int edited = cursor.getInt(EDITED_INDEX);
            ApnPreference pref = new ApnPreference(getPrefContext());
            pref.setKey(key);
            pref.setTitle(name);
            pref.setPersistent(false);
            pref.setSubId(subId);
            if (mHidePresetApnDetails && edited == Telephony.Carriers.UNEDITED) {
                pref.setHideDetails();
            } else {
                pref.setSummary(apn);
            }
            boolean selectable = ((type == null) || !type.equals("mms"));
            pref.setSelectable(selectable);
            if (selectable) {
                if ((mSelectedKey != null) && mSelectedKey.equals(key)) {
                    pref.setChecked();
                }
                addApnToList(pref, mnoApnList, mvnoApnList, r, mvnoType, mvnoMatchData);
            } else {
                addApnToList(pref, mnoMmsApnList, mvnoMmsApnList, r, mvnoType, mvnoMatchData);
            }
            cursor.moveToNext();
        }
        cursor.close();
        if (!mvnoApnList.isEmpty()) {
            mnoApnList = mvnoApnList;
            mnoMmsApnList = mvnoMmsApnList;
        // Also save the mvno info
        }
        for (Preference preference : mnoApnList) {
            apnList.addPreference(preference);
        }
        for (Preference preference : mnoMmsApnList) {
            apnList.addPreference(preference);
        }
    }
}
#end_block

#method_before
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    // Change the title for accessibility so we announce "Compose" instead
    // of the app_name while still showing the app_name in recents.
    setTitle(R.string.compose_title);
    webViewComposeEnabled = isWebViewComposeEnabledDynamic();
    setContentView(R.layout.compose);
    final ActionBar actionBar = getSupportActionBar();
    if (actionBar != null) {
        // Hide the app icon.
        actionBar.setIcon(null);
        actionBar.setDisplayUseLogoEnabled(false);
    }
    mInnerSavedState = (savedInstanceState != null) ? savedInstanceState.getBundle(KEY_INNER_SAVED_STATE) : null;
    checkValidAccounts();
}
#method_after
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    // Change the title for accessibility so we announce "Compose" instead
    // of the app_name while still showing the app_name in recents.
    setTitle(R.string.compose_title);
    setContentView(R.layout.compose);
    final ActionBar actionBar = getSupportActionBar();
    if (actionBar != null) {
        // Hide the app icon.
        actionBar.setIcon(null);
        actionBar.setDisplayUseLogoEnabled(false);
    }
    mInnerSavedState = (savedInstanceState != null) ? savedInstanceState.getBundle(KEY_INNER_SAVED_STATE) : null;
    checkValidAccounts();
}
#end_block

#method_before
private void finishCreate() {
    final Bundle savedState = mInnerSavedState;
    findViews();
    final Intent intent = getIntent();
    final Message message;
    final ArrayList<AttachmentPreview> previews;
    mShowQuotedText = false;
    final CharSequence quotedText;
    int action;
    // Check for any of the possibly supplied accounts.;
    final Account account;
    if (hadSavedInstanceStateMessage(savedState)) {
        action = savedState.getInt(EXTRA_ACTION, COMPOSE);
        account = savedState.getParcelable(Utils.EXTRA_ACCOUNT);
        message = savedState.getParcelable(EXTRA_MESSAGE);
        previews = savedState.getParcelableArrayList(EXTRA_ATTACHMENT_PREVIEWS);
        mRefMessage = savedState.getParcelable(EXTRA_IN_REFERENCE_TO_MESSAGE);
        quotedText = savedState.getCharSequence(EXTRA_QUOTED_TEXT);
        mExtraValues = savedState.getParcelable(EXTRA_VALUES);
        // Get the draft id from the request id if there is one.
        if (savedState.containsKey(EXTRA_REQUEST_ID)) {
            final int requestId = savedState.getInt(EXTRA_REQUEST_ID);
            if (sRequestMessageIdMap.containsKey(requestId)) {
                synchronized (mDraftLock) {
                    mDraftId = sRequestMessageIdMap.get(requestId);
                }
            }
        }
    } else {
        account = obtainAccount(intent);
        action = intent.getIntExtra(EXTRA_ACTION, COMPOSE);
        // Initialize the message from the message in the intent
        final Bundle extras = intent.getExtras();
        final String temp_action = intent.getAction();
        if (extras != null) {
            if (extras.containsKey(EXTRA_MESSAGE) && temp_action.equals(ACTION_LAUNCH_COMPOSE) && !isExternal()) {
                message = extras.getParcelable(EXTRA_MESSAGE);
            } else {
                message = null;
            }
        } else {
            message = intent.getParcelableExtra(ORIGINAL_DRAFT_MESSAGE);
        }
        previews = intent.getParcelableArrayListExtra(EXTRA_ATTACHMENT_PREVIEWS);
        mRefMessage = intent.getParcelableExtra(EXTRA_IN_REFERENCE_TO_MESSAGE);
        if (isExternal() && mRefMessage != null && !TextUtils.isEmpty(mRefMessage.bodyHtml)) {
            mRefMessage.bodyHtml = escapeAndReplaceHtml(mRefMessage.bodyHtml);
        }
        mRefMessageUri = intent.getParcelableExtra(EXTRA_IN_REFERENCE_TO_MESSAGE_URI);
        quotedText = null;
        if (Analytics.isLoggable()) {
            if (intent.getBooleanExtra(Utils.EXTRA_FROM_NOTIFICATION, false)) {
                Analytics.getInstance().sendEvent("notification_action", "compose", getActionString(action), 0);
            }
        }
    }
    mAttachmentsView.setAttachmentPreviews(previews);
    setAccount(account);
    if (mAccount == null) {
        return;
    }
    initRecipients();
    // Clear the notification and mark the conversation as seen, if necessary
    final Folder notificationFolder = intent.getParcelableExtra(EXTRA_NOTIFICATION_FOLDER);
    if (notificationFolder != null) {
        final Uri conversationUri = intent.getParcelableExtra(EXTRA_NOTIFICATION_CONVERSATION);
        Intent actionIntent;
        if (conversationUri != null) {
            actionIntent = new Intent(MailIntentService.ACTION_RESEND_NOTIFICATIONS_WEAR);
            actionIntent.putExtra(Utils.EXTRA_CONVERSATION, conversationUri);
        } else {
            actionIntent = new Intent(MailIntentService.ACTION_CLEAR_NEW_MAIL_NOTIFICATIONS);
            actionIntent.setData(Utils.appendVersionQueryParameter(this, notificationFolder.folderUri.fullUri));
        }
        actionIntent.setPackage(getPackageName());
        actionIntent.putExtra(Utils.EXTRA_ACCOUNT, account);
        actionIntent.putExtra(Utils.EXTRA_FOLDER, notificationFolder);
        startService(actionIntent);
    }
    if (intent.getBooleanExtra(EXTRA_FROM_EMAIL_TASK, false)) {
        mLaunchedFromEmail = true;
    } else if (Intent.ACTION_SEND.equals(intent.getAction())) {
        final Uri dataUri = intent.getData();
        if (dataUri != null) {
            final String dataScheme = intent.getData().getScheme();
            final String accountScheme = mAccount.composeIntentUri.getScheme();
            mLaunchedFromEmail = TextUtils.equals(dataScheme, accountScheme);
        }
    }
    if (mRefMessageUri != null) {
        mShowQuotedText = true;
        mComposeMode = action;
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN) {
            Bundle remoteInput = RemoteInput.getResultsFromIntent(intent);
            String wearReply = null;
            if (remoteInput != null) {
                LogUtils.d(LOG_TAG, "Got remote input from new api");
                CharSequence input = remoteInput.getCharSequence(NotificationActionUtils.WEAR_REPLY_INPUT);
                if (input != null) {
                    wearReply = input.toString();
                }
            } else {
                // TODO: remove after legacy code has been removed.
                LogUtils.d(LOG_TAG, "No remote input from new api, falling back to compatibility mode");
                ClipData clipData = intent.getClipData();
                if (clipData != null && LEGACY_WEAR_EXTRA.equals(clipData.getDescription().getLabel())) {
                    Bundle extras = clipData.getItemAt(0).getIntent().getExtras();
                    if (extras != null) {
                        wearReply = extras.getString(NotificationActionUtils.WEAR_REPLY_INPUT);
                    }
                }
            }
            if (!TextUtils.isEmpty(wearReply)) {
                createWearReplyTask(this, mRefMessageUri, UIProvider.MESSAGE_PROJECTION, mComposeMode, wearReply).execute();
                finish();
                return;
            } else {
                LogUtils.w(LOG_TAG, "remote input string is null");
            }
        }
        getLoaderManager().initLoader(INIT_DRAFT_USING_REFERENCE_MESSAGE, null, this);
        return;
    } else if (message != null && action != EDIT_DRAFT) {
        initFromDraftMessage(message);
        initQuotedTextFromRefMessage(mRefMessage, action);
        mShowQuotedText = message.appendRefMessageContent;
        // and we have some quotedText, display that
        if (mShowQuotedText && mRefMessage == null) {
            if (quotedText != null) {
                initQuotedText(quotedText, false);
            } else if (mExtraValues != null) {
                initExtraValues(mExtraValues);
                return;
            }
        }
    } else if (action == EDIT_DRAFT) {
        if (message == null) {
            throw new IllegalStateException("Message must not be null to edit draft");
        }
        initFromDraftMessage(message);
        // Update the action to the draft type of the previous draft
        switch(message.draftType) {
            case UIProvider.DraftType.REPLY:
                action = REPLY;
                break;
            case UIProvider.DraftType.REPLY_ALL:
                action = REPLY_ALL;
                break;
            case UIProvider.DraftType.FORWARD:
                action = FORWARD;
                break;
            case UIProvider.DraftType.COMPOSE:
            default:
                action = COMPOSE;
                break;
        }
        LogUtils.d(LOG_TAG, "Previous draft had action type: %d", action);
        mShowQuotedText = message.appendRefMessageContent;
        if (message.refMessageUri != null) {
            // If we're editing an existing draft that was in reference to an existing message,
            // still need to load that original message since we might need to refer to the
            // original sender and recipients if user switches "reply <-> reply-all".
            mRefMessageUri = message.refMessageUri;
            mComposeMode = action;
            getLoaderManager().initLoader(REFERENCE_MESSAGE_LOADER, null, this);
            return;
        }
    } else if ((action == REPLY || action == REPLY_ALL || action == FORWARD)) {
        if (mRefMessage != null) {
            initFromRefMessage(action);
            mShowQuotedText = true;
        }
    } else {
        if (initFromExtras(intent)) {
            return;
        }
    }
    mComposeMode = action;
    finishSetup(action, intent, savedState);
}
#method_after
private void finishCreate() {
    final Bundle savedState = mInnerSavedState;
    findViews();
    final Intent intent = getIntent();
    final Message message;
    final ArrayList<AttachmentPreview> previews;
    mShowQuotedText = false;
    final CharSequence quotedText;
    int action;
    // Check for any of the possibly supplied accounts.;
    final Account account;
    if (hadSavedInstanceStateMessage(savedState)) {
        action = savedState.getInt(EXTRA_ACTION, COMPOSE);
        account = savedState.getParcelable(Utils.EXTRA_ACCOUNT);
        message = savedState.getParcelable(EXTRA_MESSAGE);
        previews = savedState.getParcelableArrayList(EXTRA_ATTACHMENT_PREVIEWS);
        mRefMessage = savedState.getParcelable(EXTRA_IN_REFERENCE_TO_MESSAGE);
        quotedText = savedState.getCharSequence(EXTRA_QUOTED_TEXT);
        mExtraValues = savedState.getParcelable(EXTRA_VALUES);
        // Get the draft id from the request id if there is one.
        if (savedState.containsKey(EXTRA_REQUEST_ID)) {
            final int requestId = savedState.getInt(EXTRA_REQUEST_ID);
            if (sRequestMessageIdMap.containsKey(requestId)) {
                synchronized (mDraftLock) {
                    mDraftId = sRequestMessageIdMap.get(requestId);
                }
            }
        }
    } else {
        account = obtainAccount(intent);
        action = intent.getIntExtra(EXTRA_ACTION, COMPOSE);
        // Initialize the message from the message in the intent
        message = intent.getParcelableExtra(ORIGINAL_DRAFT_MESSAGE);
        previews = intent.getParcelableArrayListExtra(EXTRA_ATTACHMENT_PREVIEWS);
        mRefMessage = intent.getParcelableExtra(EXTRA_IN_REFERENCE_TO_MESSAGE);
        if (isExternal() && mRefMessage != null && !TextUtils.isEmpty(mRefMessage.bodyHtml)) {
            mRefMessage.bodyHtml = escapeAndReplaceHtml(mRefMessage.bodyHtml);
        }
        mRefMessageUri = intent.getParcelableExtra(EXTRA_IN_REFERENCE_TO_MESSAGE_URI);
        quotedText = null;
        if (Analytics.isLoggable()) {
            if (intent.getBooleanExtra(Utils.EXTRA_FROM_NOTIFICATION, false)) {
                Analytics.getInstance().sendEvent("notification_action", "compose", getActionString(action), 0);
            }
        }
    }
    mAttachmentsView.setAttachmentPreviews(previews);
    setAccount(account);
    if (mAccount == null) {
        return;
    }
    initRecipients();
    // Clear the notification and mark the conversation as seen, if necessary
    final Folder notificationFolder = intent.getParcelableExtra(EXTRA_NOTIFICATION_FOLDER);
    if (notificationFolder != null) {
        final Uri conversationUri = intent.getParcelableExtra(EXTRA_NOTIFICATION_CONVERSATION);
        Intent actionIntent;
        if (conversationUri != null) {
            actionIntent = new Intent(MailIntentService.ACTION_RESEND_NOTIFICATIONS_WEAR);
            actionIntent.putExtra(Utils.EXTRA_CONVERSATION, conversationUri);
        } else {
            actionIntent = new Intent(MailIntentService.ACTION_CLEAR_NEW_MAIL_NOTIFICATIONS);
            actionIntent.setData(Utils.appendVersionQueryParameter(this, notificationFolder.folderUri.fullUri));
        }
        actionIntent.setPackage(getPackageName());
        actionIntent.putExtra(Utils.EXTRA_ACCOUNT, account);
        actionIntent.putExtra(Utils.EXTRA_FOLDER, notificationFolder);
        startService(actionIntent);
    }
    if (intent.getBooleanExtra(EXTRA_FROM_EMAIL_TASK, false)) {
        mLaunchedFromEmail = true;
    } else if (Intent.ACTION_SEND.equals(intent.getAction())) {
        final Uri dataUri = intent.getData();
        if (dataUri != null) {
            final String dataScheme = intent.getData().getScheme();
            final String accountScheme = mAccount.composeIntentUri.getScheme();
            mLaunchedFromEmail = TextUtils.equals(dataScheme, accountScheme);
        }
    }
    if (mRefMessageUri != null) {
        mShowQuotedText = true;
        mComposeMode = action;
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN) {
            Bundle remoteInput = RemoteInput.getResultsFromIntent(intent);
            String wearReply = null;
            if (remoteInput != null) {
                LogUtils.d(LOG_TAG, "Got remote input from new api");
                CharSequence input = remoteInput.getCharSequence(NotificationActionUtils.WEAR_REPLY_INPUT);
                if (input != null) {
                    wearReply = input.toString();
                }
            } else {
                // TODO: remove after legacy code has been removed.
                LogUtils.d(LOG_TAG, "No remote input from new api, falling back to compatibility mode");
                ClipData clipData = intent.getClipData();
                if (clipData != null && LEGACY_WEAR_EXTRA.equals(clipData.getDescription().getLabel())) {
                    Bundle extras = clipData.getItemAt(0).getIntent().getExtras();
                    if (extras != null) {
                        wearReply = extras.getString(NotificationActionUtils.WEAR_REPLY_INPUT);
                    }
                }
            }
            if (!TextUtils.isEmpty(wearReply)) {
                createWearReplyTask(this, mRefMessageUri, UIProvider.MESSAGE_PROJECTION, mComposeMode, wearReply).execute();
                finish();
                return;
            } else {
                LogUtils.w(LOG_TAG, "remote input string is null");
            }
        }
        getLoaderManager().initLoader(INIT_DRAFT_USING_REFERENCE_MESSAGE, null, this);
        return;
    } else if (message != null && action != EDIT_DRAFT) {
        initFromDraftMessage(message);
        initQuotedTextFromRefMessage(mRefMessage, action);
        mShowQuotedText = message.appendRefMessageContent;
        // and we have some quotedText, display that
        if (mShowQuotedText && mRefMessage == null) {
            if (quotedText != null) {
                initQuotedText(quotedText, false);
            } else if (mExtraValues != null) {
                initExtraValues(mExtraValues);
                return;
            }
        }
    } else if (action == EDIT_DRAFT) {
        if (message == null) {
            throw new IllegalStateException("Message must not be null to edit draft");
        }
        initFromDraftMessage(message);
        // Update the action to the draft type of the previous draft
        switch(message.draftType) {
            case UIProvider.DraftType.REPLY:
                action = REPLY;
                break;
            case UIProvider.DraftType.REPLY_ALL:
                action = REPLY_ALL;
                break;
            case UIProvider.DraftType.FORWARD:
                action = FORWARD;
                break;
            case UIProvider.DraftType.COMPOSE:
            default:
                action = COMPOSE;
                break;
        }
        LogUtils.d(LOG_TAG, "Previous draft had action type: %d", action);
        mShowQuotedText = message.appendRefMessageContent;
        if (message.refMessageUri != null) {
            // If we're editing an existing draft that was in reference to an existing message,
            // still need to load that original message since we might need to refer to the
            // original sender and recipients if user switches "reply <-> reply-all".
            mRefMessageUri = message.refMessageUri;
            mComposeMode = action;
            getLoaderManager().initLoader(REFERENCE_MESSAGE_LOADER, null, this);
            return;
        }
    } else if ((action == REPLY || action == REPLY_ALL || action == FORWARD)) {
        if (mRefMessage != null) {
            initFromRefMessage(action);
            mShowQuotedText = true;
        }
    } else {
        if (initFromExtras(intent)) {
            return;
        }
    }
    mComposeMode = action;
    finishSetup(action, intent, savedState);
}
#end_block

#method_before
protected void checkNavigationBarDivider(LightBarBaseActivity activity, int dividerColor, int backgroundColor, String methodName) {
    final Bitmap bitmap = takeNavigationBarScreenshot(activity);
    int[] pixels = new int[bitmap.getHeight() * bitmap.getWidth()];
    bitmap.getPixels(pixels, 0, bitmap.getWidth(), 0, 0, bitmap.getWidth(), bitmap.getHeight());
    loadCutout(activity);
    int backgroundColorPixelCount = 0;
    int shiftY = activity.getBottom();
    for (int i = 0; i < pixels.length; i++) {
        int x = i % bitmap.getWidth();
        int y = i / bitmap.getWidth();
        if (pixels[i] == backgroundColor || isInsideCutout(x, shiftY + y)) {
            backgroundColorPixelCount++;
        }
    }
    assumeNavigationBarChangesColor(backgroundColorPixelCount, pixels.length);
    int diffCount = 0;
    for (int col = 0; col < bitmap.getWidth(); col++) {
        if (isInsideCutout(col, shiftY)) {
            continue;
        }
        if (dividerColor != pixels[col]) {
            diffCount++;
        }
    }
    boolean success = true;
    try {
        assertLessThan(String.format(Locale.ENGLISH, "There are invalid color pixels. expected= 0x%08x", dividerColor), 0.3f, (float) diffCount / (float) bitmap.getWidth(), "is the divider colored according to the spec ");
        success = false;
    } finally {
        if (!success) {
            dumpBitmap(bitmap, methodName);
        }
    }
}
#method_after
protected void checkNavigationBarDivider(LightBarBaseActivity activity, int dividerColor, int backgroundColor, String methodName) {
    final Bitmap bitmap = takeNavigationBarScreenshot(activity);
    int[] pixels = new int[bitmap.getHeight() * bitmap.getWidth()];
    bitmap.getPixels(pixels, 0, bitmap.getWidth(), 0, 0, bitmap.getWidth(), bitmap.getHeight());
    loadCutout(activity);
    int backgroundColorPixelCount = 0;
    int shiftY = activity.getBottom();
    for (int i = 0; i < pixels.length; i++) {
        int x = i % bitmap.getWidth();
        int y = i / bitmap.getWidth();
        if (pixels[i] == backgroundColor || isInsideCutout(x, shiftY + y)) {
            backgroundColorPixelCount++;
        }
    }
    assumeNavigationBarChangesColor(backgroundColorPixelCount, pixels.length);
    int diffCount = 0;
    for (int col = 0; col < bitmap.getWidth(); col++) {
        if (isInsideCutout(col, shiftY)) {
            continue;
        }
        if (dividerColor != pixels[col]) {
            diffCount++;
        }
    }
    boolean success = false;
    try {
        assertLessThan(String.format(Locale.ENGLISH, "There are invalid color pixels. expected= 0x%08x", dividerColor), 0.3f, (float) diffCount / (float) bitmap.getWidth(), "Is the divider colored according to android:navigationBarDividerColor " + " in the theme?");
        success = true;
    } finally {
        if (!success) {
            dumpBitmap(bitmap, methodName);
        }
    }
}
#end_block

#method_before
public void updateConfiguration(TetheringConfiguration ctx) {
    mConfig = ctx;
}
#method_after
public void updateConfiguration(TetheringConfiguration conf) {
    mConfig = conf;
}
#end_block

#method_before
public void reevaluateSimCardProvisioning() {
    // TODO: refine provisioning check to isTetherProvisioningRequired() ??
    if (!mConfig.hasMobileHotspotProvisionApp() || carrierConfigAffirmsEntitlementCheckNotRequired()) {
        for (int i = 0; i < mMobilePermittedMap.size(); i++) {
            int type = mMobilePermittedMap.keyAt(i);
            addDownStreamMapping(type, TETHER_ERROR_PROVISION_NOT_REQUIRED);
        }
        return;
    }
    for (int i = 0; i < mMobilePermittedMap.size(); i++) {
        int type = mMobilePermittedMap.keyAt(i);
        ResultReceiver build = buildReceiver(type);
        runUiTetherProvisioning(type, build);
    }
}
#method_after
public void reevaluateSimCardProvisioning() {
    if (!mConfig.hasMobileHotspotProvisionApp())
        return;
    if (carrierConfigAffirmsEntitlementCheckNotRequired())
        return;
    final ArraySet<Integer> reevaluateType;
    synchronized (mCurrentTethers) {
        reevaluateType = new ArraySet<Integer>(mCurrentTethers);
    }
    for (Integer type : reevaluateType) {
        startProvisionIntent(type);
    }
}
#end_block

#method_before
private void cancelTetherProvisioningRechecks(int type) {
    Intent intent = new Intent();
    intent.putExtra(EXTRA_REM_TETHER_TYPE, type);
    intent.setComponent(TETHER_SERVICE);
    final long ident = Binder.clearCallingIdentity();
    try {
        mContext.startServiceAsUser(intent, UserHandle.CURRENT);
    } finally {
        Binder.restoreCallingIdentity(ident);
    }
}
#method_after
public void cancelTetherProvisioningRechecks(int type) {
    Intent intent = new Intent();
    intent.putExtra(EXTRA_REM_TETHER_TYPE, type);
    intent.setComponent(TETHER_SERVICE);
    final long ident = Binder.clearCallingIdentity();
    try {
        mContext.startServiceAsUser(intent, UserHandle.CURRENT);
    } finally {
        Binder.restoreCallingIdentity(ident);
    }
}
#end_block

#method_before
public boolean isCurrentlyServing() {
    switch(lastState) {
        case IControlsTethering.STATE_TETHERED:
        case IControlsTethering.STATE_LOCAL_ONLY:
            return true;
        default:
            return false;
    }
}
#method_after
public boolean isCurrentlyServing() {
    switch(lastState) {
        case IpServer.STATE_TETHERED:
        case IpServer.STATE_LOCAL_ONLY:
            return true;
        default:
            return false;
    }
}
#end_block

#method_before
private void updateConfiguration() {
    mConfig = new TetheringConfiguration(mContext, mLog);
    mUpstreamNetworkMonitor.updateMobileRequiresDun(mConfig.isDunRequired);
    mEntitleMgr.updateConfiguration(mConfig);
}
#method_after
private void updateConfiguration() {
    mConfig = new TetheringConfiguration(mContext, mLog);
    mUpstreamNetworkMonitor.updateMobileRequiresDun(mConfig.isDunRequired);
    mEntitlementMgr.updateConfiguration(mConfig);
}
#end_block

#method_before
public void startTethering(int type, ResultReceiver receiver, boolean showProvisioningUi) {
    if (!mEntitleMgr.isTetherProvisioningRequired()) {
        mEntitleMgr.addDownStreamMapping(type, TETHER_ERROR_PROVISION_NOT_REQUIRED);
        enableTetheringInternal(type, true, receiver);
    } else {
        // run provision check before enabling tethering
        ResultReceiver proxyReceiver = getProxyReceiver(type, receiver);
        mEntitleMgr.runSilentTetherProvisioning(type, proxyReceiver);
    }
}
#method_after
public void startTethering(int type, ResultReceiver receiver, boolean showProvisioningUi) {
    mEntitlementMgr.startTethering(type);
    if (!mEntitlementMgr.isTetherProvisioningRequired()) {
        enableTetheringInternal(type, true, receiver);
        return;
    }
    final ResultReceiver proxyReceiver = getProxyReceiver(type, receiver);
    if (showProvisioningUi) {
        mEntitlementMgr.runUiTetherProvisioningAndEnable(type, proxyReceiver);
    } else {
        mEntitlementMgr.runSilentTetherProvisioningAndEnable(type, proxyReceiver);
    }
}
#end_block

#method_before
public void stopTethering(int type) {
    enableTetheringInternal(type, false, null);
    mEntitleMgr.removeDownStreamMapping(type);
}
#method_after
public void stopTethering(int type) {
    enableTetheringInternal(type, false, null);
    mEntitlementMgr.stopTethering(type);
    if (mEntitlementMgr.isTetherProvisioningRequired()) {
        // TODO: cancel re-check all the time
        if (mDeps.isTetheringSupported()) {
            mEntitlementMgr.cancelTetherProvisioningRechecks(type);
        }
    }
}
#end_block

#method_before
private void enableTetheringInternal(int type, boolean enable, ResultReceiver receiver) {
    boolean isProvisioningRequired = enable && mEntitleMgr.isTetherProvisioningRequired();
    int result;
    switch(type) {
        case TETHERING_WIFI:
            result = setWifiTethering(enable);
            if (isProvisioningRequired && result == TETHER_ERROR_NO_ERROR) {
                mEntitleMgr.scheduleProvisioningRechecks(type);
            }
            sendTetherResult(receiver, result);
            break;
        case TETHERING_USB:
            result = setUsbTethering(enable);
            if (isProvisioningRequired && result == TETHER_ERROR_NO_ERROR) {
                mEntitleMgr.scheduleProvisioningRechecks(type);
            }
            sendTetherResult(receiver, result);
            break;
        case TETHERING_BLUETOOTH:
            setBluetoothTethering(enable, receiver);
            break;
        default:
            Log.w(TAG, "Invalid tether type.");
            mEntitleMgr.removeDownStreamMapping(type);
            sendTetherResult(receiver, TETHER_ERROR_UNKNOWN_IFACE);
    }
}
#method_after
private void enableTetheringInternal(int type, boolean enable, ResultReceiver receiver) {
    boolean isProvisioningRequired = enable && mEntitlementMgr.isTetherProvisioningRequired();
    int result;
    switch(type) {
        case TETHERING_WIFI:
            result = setWifiTethering(enable);
            if (isProvisioningRequired && result == TETHER_ERROR_NO_ERROR) {
                mEntitlementMgr.scheduleProvisioningRechecks(type);
            }
            sendTetherResult(receiver, result);
            break;
        case TETHERING_USB:
            result = setUsbTethering(enable);
            if (isProvisioningRequired && result == TETHER_ERROR_NO_ERROR) {
                mEntitlementMgr.scheduleProvisioningRechecks(type);
            }
            sendTetherResult(receiver, result);
            break;
        case TETHERING_BLUETOOTH:
            setBluetoothTethering(enable, receiver);
            break;
        default:
            Log.w(TAG, "Invalid tether type.");
            sendTetherResult(receiver, TETHER_ERROR_UNKNOWN_IFACE);
    }
}
#end_block

#method_before
private void setBluetoothTethering(final boolean enable, final ResultReceiver receiver) {
    final BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
    if (adapter == null || !adapter.isEnabled()) {
        Log.w(TAG, "Tried to enable bluetooth tethering with null or disabled adapter. null: " + (adapter == null));
        sendTetherResult(receiver, TETHER_ERROR_SERVICE_UNAVAIL);
        return;
    }
    adapter.getProfileProxy(mContext, new ServiceListener() {

        @Override
        public void onServiceDisconnected(int profile) {
        }

        @Override
        public void onServiceConnected(int profile, BluetoothProfile proxy) {
            ((BluetoothPan) proxy).setBluetoothTethering(enable);
            // TODO: Enabling bluetooth tethering can fail asynchronously here.
            // We should figure out a way to bubble up that failure instead of sending success.
            final int result = (((BluetoothPan) proxy).isTetheringOn() == enable) ? TETHER_ERROR_NO_ERROR : TETHER_ERROR_MASTER_ERROR;
            sendTetherResult(receiver, result);
            if (enable && mEntitleMgr.isTetherProvisioningRequired()) {
                mEntitleMgr.scheduleProvisioningRechecks(TETHERING_BLUETOOTH);
            }
            adapter.closeProfileProxy(BluetoothProfile.PAN, proxy);
        }
    }, BluetoothProfile.PAN);
}
#method_after
private void setBluetoothTethering(final boolean enable, final ResultReceiver receiver) {
    final BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
    if (adapter == null || !adapter.isEnabled()) {
        Log.w(TAG, "Tried to enable bluetooth tethering with null or disabled adapter. null: " + (adapter == null));
        sendTetherResult(receiver, TETHER_ERROR_SERVICE_UNAVAIL);
        return;
    }
    adapter.getProfileProxy(mContext, new ServiceListener() {

        @Override
        public void onServiceDisconnected(int profile) {
        }

        @Override
        public void onServiceConnected(int profile, BluetoothProfile proxy) {
            ((BluetoothPan) proxy).setBluetoothTethering(enable);
            // TODO: Enabling bluetooth tethering can fail asynchronously here.
            // We should figure out a way to bubble up that failure instead of sending success.
            final int result = (((BluetoothPan) proxy).isTetheringOn() == enable) ? TETHER_ERROR_NO_ERROR : TETHER_ERROR_MASTER_ERROR;
            sendTetherResult(receiver, result);
            if (enable && mEntitlementMgr.isTetherProvisioningRequired()) {
                mEntitlementMgr.scheduleProvisioningRechecks(TETHERING_BLUETOOTH);
            }
            adapter.closeProfileProxy(BluetoothProfile.PAN, proxy);
        }
    }, BluetoothProfile.PAN);
}
#end_block

#method_before
private ResultReceiver getProxyReceiver(final int type, final ResultReceiver receiver) {
    ResultReceiver rr = new ResultReceiver(null) {

        @Override
        protected void onReceiveResult(int resultCode, Bundle resultData) {
            mEntitleMgr.addDownStreamMapping(type, resultCode);
            enableTetheringInternal(type, true, receiver);
        }
    };
    // The following is necessary to avoid unmarshalling issues when sending the receiver
    // across processes.
    Parcel parcel = Parcel.obtain();
    rr.writeToParcel(parcel, 0);
    parcel.setDataPosition(0);
    ResultReceiver receiverForSending = ResultReceiver.CREATOR.createFromParcel(parcel);
    parcel.recycle();
    return receiverForSending;
}
#method_after
private ResultReceiver getProxyReceiver(final int type, final ResultReceiver receiver) {
    ResultReceiver rr = new ResultReceiver(null) {

        @Override
        protected void onReceiveResult(int resultCode, Bundle resultData) {
            // If provisioning is successful, enable tethering, otherwise just send the error.
            if (resultCode == TETHER_ERROR_NO_ERROR) {
                enableTetheringInternal(type, true, receiver);
            } else {
                sendTetherResult(receiver, resultCode);
            }
        }
    };
    // The following is necessary to avoid unmarshalling issues when sending the receiver
    // across processes.
    Parcel parcel = Parcel.obtain();
    rr.writeToParcel(parcel, 0);
    parcel.setDataPosition(0);
    ResultReceiver receiverForSending = ResultReceiver.CREATOR.createFromParcel(parcel);
    parcel.recycle();
    return receiverForSending;
}
#end_block

#method_before
public int tether(String iface) {
    return tether(iface, IControlsTethering.STATE_TETHERED);
}
#method_after
public int tether(String iface) {
    return tether(iface, IpServer.STATE_TETHERED);
}
#end_block

#method_before
private int tether(String iface, int requestedState) {
    if (DBG)
        Log.d(TAG, "Tethering " + iface);
    synchronized (mPublicSync) {
        TetherState tetherState = mTetherStates.get(iface);
        if (tetherState == null) {
            Log.e(TAG, "Tried to Tether an unknown iface: " + iface + ", ignoring");
            return TETHER_ERROR_UNKNOWN_IFACE;
        }
        // the errors are referring to past tethering attempts anyway.
        if (tetherState.lastState != IControlsTethering.STATE_AVAILABLE) {
            Log.e(TAG, "Tried to Tether an unavailable iface: " + iface + ", ignoring");
            return TETHER_ERROR_UNAVAIL_IFACE;
        }
        // NOTE: If a CMD_TETHER_REQUESTED message is already in the TISM's
        // queue but not yet processed, this will be a no-op and it will not
        // return an error.
        // 
        // TODO: reexamine the threading and messaging model.
        tetherState.stateMachine.sendMessage(TetherInterfaceStateMachine.CMD_TETHER_REQUESTED, requestedState);
        return TETHER_ERROR_NO_ERROR;
    }
}
#method_after
private int tether(String iface, int requestedState) {
    if (DBG)
        Log.d(TAG, "Tethering " + iface);
    synchronized (mPublicSync) {
        TetherState tetherState = mTetherStates.get(iface);
        if (tetherState == null) {
            Log.e(TAG, "Tried to Tether an unknown iface: " + iface + ", ignoring");
            return TETHER_ERROR_UNKNOWN_IFACE;
        }
        // the errors are referring to past tethering attempts anyway.
        if (tetherState.lastState != IpServer.STATE_AVAILABLE) {
            Log.e(TAG, "Tried to Tether an unavailable iface: " + iface + ", ignoring");
            return TETHER_ERROR_UNAVAIL_IFACE;
        }
        // NOTE: If a CMD_TETHER_REQUESTED message is already in the TISM's
        // queue but not yet processed, this will be a no-op and it will not
        // return an error.
        // 
        // TODO: reexamine the threading and messaging model.
        tetherState.ipServer.sendMessage(IpServer.CMD_TETHER_REQUESTED, requestedState);
        return TETHER_ERROR_NO_ERROR;
    }
}
#end_block

#method_before
public int untether(String iface) {
    if (DBG)
        Log.d(TAG, "Untethering " + iface);
    synchronized (mPublicSync) {
        TetherState tetherState = mTetherStates.get(iface);
        if (tetherState == null) {
            Log.e(TAG, "Tried to Untether an unknown iface :" + iface + ", ignoring");
            return TETHER_ERROR_UNKNOWN_IFACE;
        }
        if (!tetherState.isCurrentlyServing()) {
            Log.e(TAG, "Tried to untether an inactive iface :" + iface + ", ignoring");
            return TETHER_ERROR_UNAVAIL_IFACE;
        }
        tetherState.stateMachine.sendMessage(TetherInterfaceStateMachine.CMD_TETHER_UNREQUESTED);
        return TETHER_ERROR_NO_ERROR;
    }
}
#method_after
public int untether(String iface) {
    if (DBG)
        Log.d(TAG, "Untethering " + iface);
    synchronized (mPublicSync) {
        TetherState tetherState = mTetherStates.get(iface);
        if (tetherState == null) {
            Log.e(TAG, "Tried to Untether an unknown iface :" + iface + ", ignoring");
            return TETHER_ERROR_UNKNOWN_IFACE;
        }
        if (!tetherState.isCurrentlyServing()) {
            Log.e(TAG, "Tried to untether an inactive iface :" + iface + ", ignoring");
            return TETHER_ERROR_UNAVAIL_IFACE;
        }
        tetherState.ipServer.sendMessage(IpServer.CMD_TETHER_UNREQUESTED);
        return TETHER_ERROR_NO_ERROR;
    }
}
#end_block

#method_before
private void sendTetherStateChangedBroadcast() {
    if (!mDeps.isTetheringSupported())
        return;
    final ArrayList<String> availableList = new ArrayList<>();
    final ArrayList<String> tetherList = new ArrayList<>();
    final ArrayList<String> localOnlyList = new ArrayList<>();
    final ArrayList<String> erroredList = new ArrayList<>();
    boolean wifiTethered = false;
    boolean usbTethered = false;
    boolean bluetoothTethered = false;
    final TetheringConfiguration cfg = mConfig;
    synchronized (mPublicSync) {
        for (int i = 0; i < mTetherStates.size(); i++) {
            TetherState tetherState = mTetherStates.valueAt(i);
            String iface = mTetherStates.keyAt(i);
            if (tetherState.lastError != TETHER_ERROR_NO_ERROR) {
                erroredList.add(iface);
            } else if (tetherState.lastState == IControlsTethering.STATE_AVAILABLE) {
                availableList.add(iface);
            } else if (tetherState.lastState == IControlsTethering.STATE_LOCAL_ONLY) {
                localOnlyList.add(iface);
            } else if (tetherState.lastState == IControlsTethering.STATE_TETHERED) {
                if (cfg.isUsb(iface)) {
                    usbTethered = true;
                } else if (cfg.isWifi(iface)) {
                    wifiTethered = true;
                } else if (cfg.isBluetooth(iface)) {
                    bluetoothTethered = true;
                }
                tetherList.add(iface);
            }
        }
    }
    final Intent bcast = new Intent(ACTION_TETHER_STATE_CHANGED);
    bcast.addFlags(Intent.FLAG_RECEIVER_REPLACE_PENDING | Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
    bcast.putStringArrayListExtra(EXTRA_AVAILABLE_TETHER, availableList);
    bcast.putStringArrayListExtra(EXTRA_ACTIVE_LOCAL_ONLY, localOnlyList);
    bcast.putStringArrayListExtra(EXTRA_ACTIVE_TETHER, tetherList);
    bcast.putStringArrayListExtra(EXTRA_ERRORED_TETHER, erroredList);
    mContext.sendStickyBroadcastAsUser(bcast, UserHandle.ALL);
    if (DBG) {
        Log.d(TAG, String.format("sendTetherStateChangedBroadcast %s=[%s] %s=[%s] %s=[%s] %s=[%s]", "avail", TextUtils.join(",", availableList), "local_only", TextUtils.join(",", localOnlyList), "tether", TextUtils.join(",", tetherList), "error", TextUtils.join(",", erroredList)));
    }
    if (usbTethered) {
        if (wifiTethered || bluetoothTethered) {
            showTetheredNotification(SystemMessage.NOTE_TETHER_GENERAL);
        } else {
            showTetheredNotification(SystemMessage.NOTE_TETHER_USB);
        }
    } else if (wifiTethered) {
        if (bluetoothTethered) {
            showTetheredNotification(SystemMessage.NOTE_TETHER_GENERAL);
        } else {
            /* We now have a status bar icon for WifiTethering, so drop the notification */
            clearTetheredNotification();
        }
    } else if (bluetoothTethered) {
        showTetheredNotification(SystemMessage.NOTE_TETHER_BLUETOOTH);
    } else {
        clearTetheredNotification();
    }
}
#method_after
private void sendTetherStateChangedBroadcast() {
    if (!mDeps.isTetheringSupported())
        return;
    final ArrayList<String> availableList = new ArrayList<>();
    final ArrayList<String> tetherList = new ArrayList<>();
    final ArrayList<String> localOnlyList = new ArrayList<>();
    final ArrayList<String> erroredList = new ArrayList<>();
    boolean wifiTethered = false;
    boolean usbTethered = false;
    boolean bluetoothTethered = false;
    final TetheringConfiguration cfg = mConfig;
    synchronized (mPublicSync) {
        for (int i = 0; i < mTetherStates.size(); i++) {
            TetherState tetherState = mTetherStates.valueAt(i);
            String iface = mTetherStates.keyAt(i);
            if (tetherState.lastError != TETHER_ERROR_NO_ERROR) {
                erroredList.add(iface);
            } else if (tetherState.lastState == IpServer.STATE_AVAILABLE) {
                availableList.add(iface);
            } else if (tetherState.lastState == IpServer.STATE_LOCAL_ONLY) {
                localOnlyList.add(iface);
            } else if (tetherState.lastState == IpServer.STATE_TETHERED) {
                if (cfg.isUsb(iface)) {
                    usbTethered = true;
                } else if (cfg.isWifi(iface)) {
                    wifiTethered = true;
                } else if (cfg.isBluetooth(iface)) {
                    bluetoothTethered = true;
                }
                tetherList.add(iface);
            }
        }
    }
    final Intent bcast = new Intent(ACTION_TETHER_STATE_CHANGED);
    bcast.addFlags(Intent.FLAG_RECEIVER_REPLACE_PENDING | Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
    bcast.putStringArrayListExtra(EXTRA_AVAILABLE_TETHER, availableList);
    bcast.putStringArrayListExtra(EXTRA_ACTIVE_LOCAL_ONLY, localOnlyList);
    bcast.putStringArrayListExtra(EXTRA_ACTIVE_TETHER, tetherList);
    bcast.putStringArrayListExtra(EXTRA_ERRORED_TETHER, erroredList);
    mContext.sendStickyBroadcastAsUser(bcast, UserHandle.ALL);
    if (DBG) {
        Log.d(TAG, String.format("sendTetherStateChangedBroadcast %s=[%s] %s=[%s] %s=[%s] %s=[%s]", "avail", TextUtils.join(",", availableList), "local_only", TextUtils.join(",", localOnlyList), "tether", TextUtils.join(",", tetherList), "error", TextUtils.join(",", erroredList)));
    }
    if (usbTethered) {
        if (wifiTethered || bluetoothTethered) {
            showTetheredNotification(SystemMessage.NOTE_TETHER_GENERAL);
        } else {
            showTetheredNotification(SystemMessage.NOTE_TETHER_USB);
        }
    } else if (wifiTethered) {
        if (bluetoothTethered) {
            showTetheredNotification(SystemMessage.NOTE_TETHER_GENERAL);
        } else {
            /* We now have a status bar icon for WifiTethering, so drop the notification */
            clearTetheredNotification();
        }
    } else if (bluetoothTethered) {
        showTetheredNotification(SystemMessage.NOTE_TETHER_BLUETOOTH);
    } else {
        clearTetheredNotification();
    }
}
#end_block

#method_before
private void handleUsbAction(Intent intent) {
    final boolean usbConnected = intent.getBooleanExtra(USB_CONNECTED, false);
    final boolean usbConfigured = intent.getBooleanExtra(USB_CONFIGURED, false);
    final boolean rndisEnabled = intent.getBooleanExtra(USB_FUNCTION_RNDIS, false);
    mLog.log(String.format("USB bcast connected:%s configured:%s rndis:%s", usbConnected, usbConfigured, rndisEnabled));
    // For more explanation, see b/62552150 .
    synchronized (Tethering.this.mPublicSync) {
        if (!usbConnected && mRndisEnabled) {
            // Turn off tethering if it was enabled and there is a disconnect.
            tetherMatchingInterfaces(IControlsTethering.STATE_AVAILABLE, TETHERING_USB);
        } else if (usbConfigured && rndisEnabled) {
            // Tether if rndis is enabled and usb is configured.
            tetherMatchingInterfaces(IControlsTethering.STATE_TETHERED, TETHERING_USB);
        }
        mRndisEnabled = usbConfigured && rndisEnabled;
    }
}
#method_after
private void handleUsbAction(Intent intent) {
    final boolean usbConnected = intent.getBooleanExtra(USB_CONNECTED, false);
    final boolean usbConfigured = intent.getBooleanExtra(USB_CONFIGURED, false);
    final boolean rndisEnabled = intent.getBooleanExtra(USB_FUNCTION_RNDIS, false);
    mLog.log(String.format("USB bcast connected:%s configured:%s rndis:%s", usbConnected, usbConfigured, rndisEnabled));
    // For more explanation, see b/62552150 .
    synchronized (Tethering.this.mPublicSync) {
        if (!usbConnected && mRndisEnabled) {
            // Turn off tethering if it was enabled and there is a disconnect.
            tetherMatchingInterfaces(IpServer.STATE_AVAILABLE, TETHERING_USB);
        } else if (usbConfigured && rndisEnabled) {
            // Tether if rndis is enabled and usb is configured.
            tetherMatchingInterfaces(IpServer.STATE_TETHERED, TETHERING_USB);
        }
        mRndisEnabled = usbConfigured && rndisEnabled;
    }
}
#end_block

#method_before
private void disableWifiIpServingLocked(String ifname, int apState) {
    mLog.log("Canceling WiFi tethering request - AP_STATE=" + apState);
    // Regardless of whether we requested this transition, the AP has gone
    // down.  Don't try to tether again unless we're requested to do so.
    // TODO: Remove this altogether, once Wi-Fi reliably gives us an
    // interface name with every broadcast.
    mWifiTetherRequested = false;
    if (!TextUtils.isEmpty(ifname)) {
        final TetherState ts = mTetherStates.get(ifname);
        if (ts != null) {
            ts.stateMachine.unwanted();
            return;
        }
    }
    for (int i = 0; i < mTetherStates.size(); i++) {
        TetherInterfaceStateMachine tism = mTetherStates.valueAt(i).stateMachine;
        if (tism.interfaceType() == TETHERING_WIFI) {
            tism.unwanted();
            return;
        }
    }
    mLog.log("Error disabling Wi-Fi IP serving; " + (TextUtils.isEmpty(ifname) ? "no interface name specified" : "specified interface: " + ifname));
}
#method_after
private void disableWifiIpServingLocked(String ifname, int apState) {
    mLog.log("Canceling WiFi tethering request - AP_STATE=" + apState);
    // Regardless of whether we requested this transition, the AP has gone
    // down.  Don't try to tether again unless we're requested to do so.
    // TODO: Remove this altogether, once Wi-Fi reliably gives us an
    // interface name with every broadcast.
    mWifiTetherRequested = false;
    if (!TextUtils.isEmpty(ifname)) {
        final TetherState ts = mTetherStates.get(ifname);
        if (ts != null) {
            ts.ipServer.unwanted();
            return;
        }
    }
    for (int i = 0; i < mTetherStates.size(); i++) {
        final IpServer ipServer = mTetherStates.valueAt(i).ipServer;
        if (ipServer.interfaceType() == TETHERING_WIFI) {
            ipServer.unwanted();
            return;
        }
    }
    mLog.log("Error disabling Wi-Fi IP serving; " + (TextUtils.isEmpty(ifname) ? "no interface name specified" : "specified interface: " + ifname));
}
#end_block

#method_before
private void enableWifiIpServingLocked(String ifname, int wifiIpMode) {
    // Map wifiIpMode values to IControlsTethering serving states, inferring
    // from mWifiTetherRequested as a final "best guess".
    final int ipServingMode;
    switch(wifiIpMode) {
        case IFACE_IP_MODE_TETHERED:
            ipServingMode = IControlsTethering.STATE_TETHERED;
            break;
        case IFACE_IP_MODE_LOCAL_ONLY:
            ipServingMode = IControlsTethering.STATE_LOCAL_ONLY;
            break;
        default:
            mLog.e("Cannot enable IP serving in unknown WiFi mode: " + wifiIpMode);
            return;
    }
    if (!TextUtils.isEmpty(ifname)) {
        maybeTrackNewInterfaceLocked(ifname, TETHERING_WIFI);
        changeInterfaceState(ifname, ipServingMode);
    } else {
        mLog.e(String.format("Cannot enable IP serving in mode %s on missing interface name", ipServingMode));
    }
}
#method_after
private void enableWifiIpServingLocked(String ifname, int wifiIpMode) {
    // Map wifiIpMode values to IpServer.Callback serving states, inferring
    // from mWifiTetherRequested as a final "best guess".
    final int ipServingMode;
    switch(wifiIpMode) {
        case IFACE_IP_MODE_TETHERED:
            ipServingMode = IpServer.STATE_TETHERED;
            break;
        case IFACE_IP_MODE_LOCAL_ONLY:
            ipServingMode = IpServer.STATE_LOCAL_ONLY;
            break;
        default:
            mLog.e("Cannot enable IP serving in unknown WiFi mode: " + wifiIpMode);
            return;
    }
    if (!TextUtils.isEmpty(ifname)) {
        maybeTrackNewInterfaceLocked(ifname, TETHERING_WIFI);
        changeInterfaceState(ifname, ipServingMode);
    } else {
        mLog.e(String.format("Cannot enable IP serving in mode %s on missing interface name", ipServingMode));
    }
}
#end_block

#method_before
private void changeInterfaceState(String ifname, int requestedState) {
    final int result;
    switch(requestedState) {
        case IControlsTethering.STATE_UNAVAILABLE:
        case IControlsTethering.STATE_AVAILABLE:
            result = untether(ifname);
            break;
        case IControlsTethering.STATE_TETHERED:
        case IControlsTethering.STATE_LOCAL_ONLY:
            result = tether(ifname, requestedState);
            break;
        default:
            Log.wtf(TAG, "Unknown interface state: " + requestedState);
            return;
    }
    if (result != TETHER_ERROR_NO_ERROR) {
        Log.e(TAG, "unable start or stop tethering on iface " + ifname);
        return;
    }
}
#method_after
private void changeInterfaceState(String ifname, int requestedState) {
    final int result;
    switch(requestedState) {
        case IpServer.STATE_UNAVAILABLE:
        case IpServer.STATE_AVAILABLE:
            result = untether(ifname);
            break;
        case IpServer.STATE_TETHERED:
        case IpServer.STATE_LOCAL_ONLY:
            result = tether(ifname, requestedState);
            break;
        default:
            Log.wtf(TAG, "Unknown interface state: " + requestedState);
            return;
    }
    if (result != TETHER_ERROR_NO_ERROR) {
        Log.e(TAG, "unable start or stop tethering on iface " + ifname);
        return;
    }
}
#end_block

#method_before
public String[] getTetheredIfaces() {
    ArrayList<String> list = new ArrayList<String>();
    synchronized (mPublicSync) {
        for (int i = 0; i < mTetherStates.size(); i++) {
            TetherState tetherState = mTetherStates.valueAt(i);
            if (tetherState.lastState == IControlsTethering.STATE_TETHERED) {
                list.add(mTetherStates.keyAt(i));
            }
        }
    }
    return list.toArray(new String[list.size()]);
}
#method_after
public String[] getTetheredIfaces() {
    ArrayList<String> list = new ArrayList<String>();
    synchronized (mPublicSync) {
        for (int i = 0; i < mTetherStates.size(); i++) {
            TetherState tetherState = mTetherStates.valueAt(i);
            if (tetherState.lastState == IpServer.STATE_TETHERED) {
                list.add(mTetherStates.keyAt(i));
            }
        }
    }
    return list.toArray(new String[list.size()]);
}
#end_block

#method_before
public String[] getTetherableIfaces() {
    ArrayList<String> list = new ArrayList<String>();
    synchronized (mPublicSync) {
        for (int i = 0; i < mTetherStates.size(); i++) {
            TetherState tetherState = mTetherStates.valueAt(i);
            if (tetherState.lastState == IControlsTethering.STATE_AVAILABLE) {
                list.add(mTetherStates.keyAt(i));
            }
        }
    }
    return list.toArray(new String[list.size()]);
}
#method_after
public String[] getTetherableIfaces() {
    ArrayList<String> list = new ArrayList<String>();
    synchronized (mPublicSync) {
        for (int i = 0; i < mTetherStates.size(); i++) {
            TetherState tetherState = mTetherStates.valueAt(i);
            if (tetherState.lastState == IpServer.STATE_AVAILABLE) {
                list.add(mTetherStates.keyAt(i));
            }
        }
    }
    return list.toArray(new String[list.size()]);
}
#end_block

#method_before
public String[] getTetheredDhcpRanges() {
    return mConfig.dhcpRanges;
}
#method_after
public String[] getTetheredDhcpRanges() {
    // by WifiP2pServiceImpl to start dnsmasq: remove/deprecate after migrating callers.
    return mConfig.legacyDhcpRanges;
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    logMessage(this, message.what);
    switch(message.what) {
        case EVENT_IFACE_SERVING_STATE_ACTIVE:
            TetherInterfaceStateMachine who = (TetherInterfaceStateMachine) message.obj;
            if (VDBG)
                Log.d(TAG, "Tether Mode requested by " + who);
            handleInterfaceServingStateActive(message.arg1, who);
            transitionTo(mTetherModeAliveState);
            break;
        case EVENT_IFACE_SERVING_STATE_INACTIVE:
            who = (TetherInterfaceStateMachine) message.obj;
            if (VDBG)
                Log.d(TAG, "Tether Mode unrequested by " + who);
            handleInterfaceServingStateInactive(who);
            break;
        case EVENT_IFACE_UPDATE_LINKPROPERTIES:
            // Silently ignore these for now.
            break;
        case EVENT_MOBILE_UPSTREAM_PERMITTED_CHANGE:
            boolean permitted = mEntitleMgr.isMobileUpstreamPermitted();
            mUpstreamNetworkMonitor.updateMobileUpstreamPermitted(permitted);
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#method_after
@Override
public boolean processMessage(Message message) {
    logMessage(this, message.what);
    switch(message.what) {
        case EVENT_IFACE_SERVING_STATE_ACTIVE:
            {
                final IpServer who = (IpServer) message.obj;
                if (VDBG)
                    Log.d(TAG, "Tether Mode requested by " + who);
                handleInterfaceServingStateActive(message.arg1, who);
                transitionTo(mTetherModeAliveState);
                break;
            }
        case EVENT_IFACE_SERVING_STATE_INACTIVE:
            {
                final IpServer who = (IpServer) message.obj;
                if (VDBG)
                    Log.d(TAG, "Tether Mode unrequested by " + who);
                handleInterfaceServingStateInactive(who);
                break;
            }
        case EVENT_IFACE_UPDATE_LINKPROPERTIES:
            // Silently ignore these for now.
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#end_block

#method_before
protected boolean turnOnMasterTetherSettings() {
    final TetheringConfiguration cfg = mConfig;
    try {
        mNMService.setIpForwardingEnabled(true);
    } catch (Exception e) {
        mLog.e(e);
        transitionTo(mSetIpForwardingEnabledErrorState);
        return false;
    }
    // TODO: Randomize DHCPv4 ranges, especially in hotspot mode.
    try {
        // TODO: Find a more accurate method name (startDHCPv4()?).
        mNMService.startTethering(cfg.dhcpRanges);
    } catch (Exception e) {
        try {
            mNMService.stopTethering();
            mNMService.startTethering(cfg.dhcpRanges);
        } catch (Exception ee) {
            mLog.e(ee);
            transitionTo(mStartTetheringErrorState);
            return false;
        }
    }
    mLog.log("SET master tether settings: ON");
    return true;
}
#method_after
protected boolean turnOnMasterTetherSettings() {
    final TetheringConfiguration cfg = mConfig;
    try {
        mNMService.setIpForwardingEnabled(true);
    } catch (Exception e) {
        mLog.e(e);
        transitionTo(mSetIpForwardingEnabledErrorState);
        return false;
    }
    // TODO: Randomize DHCPv4 ranges, especially in hotspot mode.
    // Legacy DHCP server is disabled if passed an empty ranges array
    final String[] dhcpRanges = cfg.enableLegacyDhcpServer ? cfg.legacyDhcpRanges : new String[0];
    try {
        // TODO: Find a more accurate method name (startDHCPv4()?).
        mNMService.startTethering(dhcpRanges);
    } catch (Exception e) {
        try {
            mNMService.stopTethering();
            mNMService.startTethering(dhcpRanges);
        } catch (Exception ee) {
            mLog.e(ee);
            transitionTo(mStartTetheringErrorState);
            return false;
        }
    }
    mLog.log("SET master tether settings: ON");
    return true;
}
#end_block

#method_before
protected void notifyDownstreamsOfNewUpstreamIface(InterfaceSet ifaces) {
    mCurrentUpstreamIfaceSet = ifaces;
    for (TetherInterfaceStateMachine sm : mNotifyList) {
        sm.sendMessage(TetherInterfaceStateMachine.CMD_TETHER_CONNECTION_CHANGED, ifaces);
    }
}
#method_after
protected void notifyDownstreamsOfNewUpstreamIface(InterfaceSet ifaces) {
    mCurrentUpstreamIfaceSet = ifaces;
    for (IpServer ipServer : mNotifyList) {
        ipServer.sendMessage(IpServer.CMD_TETHER_CONNECTION_CHANGED, ifaces);
    }
}
#end_block

#method_before
private void handleInterfaceServingStateActive(int mode, TetherInterfaceStateMachine who) {
    if (mNotifyList.indexOf(who) < 0) {
        mNotifyList.add(who);
        mIPv6TetheringCoordinator.addActiveDownstream(who, mode);
    }
    if (mode == IControlsTethering.STATE_TETHERED) {
        // No need to notify OffloadController just yet as there are no
        // "offload-able" prefixes to pass along. This will handled
        // when the TISM informs Tethering of its LinkProperties.
        mForwardedDownstreams.add(who);
    } else {
        mOffload.excludeDownstreamInterface(who.interfaceName());
        mForwardedDownstreams.remove(who);
    }
    // If this is a Wi-Fi interface, notify WifiManager of the active serving state.
    if (who.interfaceType() == TETHERING_WIFI) {
        final WifiManager mgr = getWifiManager();
        final String iface = who.interfaceName();
        switch(mode) {
            case IControlsTethering.STATE_TETHERED:
                mgr.updateInterfaceIpState(iface, IFACE_IP_MODE_TETHERED);
                break;
            case IControlsTethering.STATE_LOCAL_ONLY:
                mgr.updateInterfaceIpState(iface, IFACE_IP_MODE_LOCAL_ONLY);
                break;
            default:
                Log.wtf(TAG, "Unknown active serving mode: " + mode);
                break;
        }
    }
}
#method_after
private void handleInterfaceServingStateActive(int mode, IpServer who) {
    if (mNotifyList.indexOf(who) < 0) {
        mNotifyList.add(who);
        mIPv6TetheringCoordinator.addActiveDownstream(who, mode);
    }
    if (mode == IpServer.STATE_TETHERED) {
        // No need to notify OffloadController just yet as there are no
        // "offload-able" prefixes to pass along. This will handled
        // when the TISM informs Tethering of its LinkProperties.
        mForwardedDownstreams.add(who);
    } else {
        mOffload.excludeDownstreamInterface(who.interfaceName());
        mForwardedDownstreams.remove(who);
    }
    // If this is a Wi-Fi interface, notify WifiManager of the active serving state.
    if (who.interfaceType() == TETHERING_WIFI) {
        final WifiManager mgr = getWifiManager();
        final String iface = who.interfaceName();
        switch(mode) {
            case IpServer.STATE_TETHERED:
                mgr.updateInterfaceIpState(iface, IFACE_IP_MODE_TETHERED);
                break;
            case IpServer.STATE_LOCAL_ONLY:
                mgr.updateInterfaceIpState(iface, IFACE_IP_MODE_LOCAL_ONLY);
                break;
            default:
                Log.wtf(TAG, "Unknown active serving mode: " + mode);
                break;
        }
    }
}
#end_block

#method_before
private void handleInterfaceServingStateInactive(TetherInterfaceStateMachine who) {
    mNotifyList.remove(who);
    mIPv6TetheringCoordinator.removeActiveDownstream(who);
    mOffload.excludeDownstreamInterface(who.interfaceName());
    mForwardedDownstreams.remove(who);
    // If this is a Wi-Fi interface, tell WifiManager of any errors.
    if (who.interfaceType() == TETHERING_WIFI) {
        if (who.lastError() != TETHER_ERROR_NO_ERROR) {
            getWifiManager().updateInterfaceIpState(who.interfaceName(), IFACE_IP_MODE_CONFIGURATION_ERROR);
        }
    }
}
#method_after
private void handleInterfaceServingStateInactive(IpServer who) {
    mNotifyList.remove(who);
    mIPv6TetheringCoordinator.removeActiveDownstream(who);
    mOffload.excludeDownstreamInterface(who.interfaceName());
    mForwardedDownstreams.remove(who);
    // If this is a Wi-Fi interface, tell WifiManager of any errors.
    if (who.interfaceType() == TETHERING_WIFI) {
        if (who.lastError() != TETHER_ERROR_NO_ERROR) {
            getWifiManager().updateInterfaceIpState(who.interfaceName(), IFACE_IP_MODE_CONFIGURATION_ERROR);
        }
    }
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    logMessage(this, message.what);
    boolean retValue = true;
    switch(message.what) {
        case EVENT_IFACE_SERVING_STATE_ACTIVE:
            {
                TetherInterfaceStateMachine who = (TetherInterfaceStateMachine) message.obj;
                if (VDBG)
                    Log.d(TAG, "Tether Mode requested by " + who);
                handleInterfaceServingStateActive(message.arg1, who);
                who.sendMessage(TetherInterfaceStateMachine.CMD_TETHER_CONNECTION_CHANGED, mCurrentUpstreamIfaceSet);
                // If there has been a change and an upstream is now
                // desired, kick off the selection process.
                final boolean previousUpstreamWanted = updateUpstreamWanted();
                if (!previousUpstreamWanted && mUpstreamWanted) {
                    chooseUpstreamType(true);
                }
                break;
            }
        case EVENT_IFACE_SERVING_STATE_INACTIVE:
            {
                TetherInterfaceStateMachine who = (TetherInterfaceStateMachine) message.obj;
                if (VDBG)
                    Log.d(TAG, "Tether Mode unrequested by " + who);
                handleInterfaceServingStateInactive(who);
                if (mNotifyList.isEmpty()) {
                    // This transitions us out of TetherModeAliveState,
                    // either to InitialState or an error state.
                    turnOffMasterTetherSettings();
                    break;
                }
                if (DBG) {
                    Log.d(TAG, "TetherModeAlive still has " + mNotifyList.size() + " live requests:");
                    for (TetherInterfaceStateMachine o : mNotifyList) {
                        Log.d(TAG, "  " + o);
                    }
                }
                // If there has been a change and an upstream is no
                // longer desired, release any mobile requests.
                final boolean previousUpstreamWanted = updateUpstreamWanted();
                if (previousUpstreamWanted && !mUpstreamWanted) {
                    mUpstreamNetworkMonitor.releaseMobileNetworkRequest();
                }
                break;
            }
        case EVENT_IFACE_UPDATE_LINKPROPERTIES:
            {
                final LinkProperties newLp = (LinkProperties) message.obj;
                if (message.arg1 == IControlsTethering.STATE_TETHERED) {
                    mOffload.updateDownstreamLinkProperties(newLp);
                } else {
                    mOffload.excludeDownstreamInterface(newLp.getInterfaceName());
                }
                break;
            }
        case CMD_UPSTREAM_CHANGED:
            updateUpstreamWanted();
            if (!mUpstreamWanted)
                break;
            // Need to try DUN immediately if Wi-Fi goes down.
            chooseUpstreamType(true);
            mTryCell = false;
            break;
        case CMD_RETRY_UPSTREAM:
            updateUpstreamWanted();
            if (!mUpstreamWanted)
                break;
            chooseUpstreamType(mTryCell);
            mTryCell = !mTryCell;
            break;
        case EVENT_UPSTREAM_CALLBACK:
            {
                updateUpstreamWanted();
                if (mUpstreamWanted) {
                    handleUpstreamNetworkMonitorCallback(message.arg1, message.obj);
                }
                break;
            }
        case EVENT_MOBILE_UPSTREAM_PERMITTED_CHANGE:
            {
                boolean permitted = mEntitleMgr.isMobileUpstreamPermitted();
                mUpstreamNetworkMonitor.updateMobileUpstreamPermitted(permitted);
                if (!mUpstreamWanted)
                    break;
                chooseUpstreamType(true);
                mTryCell = false;
                break;
            }
        default:
            retValue = false;
            break;
    }
    return retValue;
}
#method_after
@Override
public boolean processMessage(Message message) {
    logMessage(this, message.what);
    boolean retValue = true;
    switch(message.what) {
        case EVENT_IFACE_SERVING_STATE_ACTIVE:
            {
                IpServer who = (IpServer) message.obj;
                if (VDBG)
                    Log.d(TAG, "Tether Mode requested by " + who);
                handleInterfaceServingStateActive(message.arg1, who);
                who.sendMessage(IpServer.CMD_TETHER_CONNECTION_CHANGED, mCurrentUpstreamIfaceSet);
                // If there has been a change and an upstream is now
                // desired, kick off the selection process.
                final boolean previousUpstreamWanted = updateUpstreamWanted();
                if (!previousUpstreamWanted && mUpstreamWanted) {
                    chooseUpstreamType(true);
                }
                break;
            }
        case EVENT_IFACE_SERVING_STATE_INACTIVE:
            {
                IpServer who = (IpServer) message.obj;
                if (VDBG)
                    Log.d(TAG, "Tether Mode unrequested by " + who);
                handleInterfaceServingStateInactive(who);
                if (mNotifyList.isEmpty()) {
                    // This transitions us out of TetherModeAliveState,
                    // either to InitialState or an error state.
                    turnOffMasterTetherSettings();
                    break;
                }
                if (DBG) {
                    Log.d(TAG, "TetherModeAlive still has " + mNotifyList.size() + " live requests:");
                    for (IpServer o : mNotifyList) {
                        Log.d(TAG, "  " + o);
                    }
                }
                // If there has been a change and an upstream is no
                // longer desired, release any mobile requests.
                final boolean previousUpstreamWanted = updateUpstreamWanted();
                if (previousUpstreamWanted && !mUpstreamWanted) {
                    mUpstreamNetworkMonitor.releaseMobileNetworkRequest();
                }
                break;
            }
        case EVENT_IFACE_UPDATE_LINKPROPERTIES:
            {
                final LinkProperties newLp = (LinkProperties) message.obj;
                if (message.arg1 == IpServer.STATE_TETHERED) {
                    mOffload.updateDownstreamLinkProperties(newLp);
                } else {
                    mOffload.excludeDownstreamInterface(newLp.getInterfaceName());
                }
                break;
            }
        case CMD_UPSTREAM_CHANGED:
            updateUpstreamWanted();
            if (!mUpstreamWanted)
                break;
            // Need to try DUN immediately if Wi-Fi goes down.
            chooseUpstreamType(true);
            mTryCell = false;
            break;
        case CMD_RETRY_UPSTREAM:
            updateUpstreamWanted();
            if (!mUpstreamWanted)
                break;
            chooseUpstreamType(mTryCell);
            mTryCell = !mTryCell;
            break;
        case EVENT_UPSTREAM_CALLBACK:
            {
                updateUpstreamWanted();
                if (mUpstreamWanted) {
                    handleUpstreamNetworkMonitorCallback(message.arg1, message.obj);
                }
                break;
            }
        default:
            retValue = false;
            break;
    }
    return retValue;
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    boolean retValue = true;
    switch(message.what) {
        case EVENT_IFACE_SERVING_STATE_ACTIVE:
            TetherInterfaceStateMachine who = (TetherInterfaceStateMachine) message.obj;
            who.sendMessage(mErrorNotification);
            break;
        case CMD_CLEAR_ERROR:
            mErrorNotification = TETHER_ERROR_NO_ERROR;
            transitionTo(mInitialState);
            break;
        case EVENT_MOBILE_UPSTREAM_PERMITTED_CHANGE:
            boolean permitted = mEntitleMgr.isMobileUpstreamPermitted();
            mUpstreamNetworkMonitor.updateMobileUpstreamPermitted(permitted);
            break;
        default:
            retValue = false;
    }
    return retValue;
}
#method_after
@Override
public boolean processMessage(Message message) {
    boolean retValue = true;
    switch(message.what) {
        case EVENT_IFACE_SERVING_STATE_ACTIVE:
            IpServer who = (IpServer) message.obj;
            who.sendMessage(mErrorNotification);
            break;
        case CMD_CLEAR_ERROR:
            mErrorNotification = TETHER_ERROR_NO_ERROR;
            transitionTo(mInitialState);
            break;
        default:
            retValue = false;
    }
    return retValue;
}
#end_block

#method_before
void notify(int msgType) {
    mErrorNotification = msgType;
    for (TetherInterfaceStateMachine sm : mNotifyList) {
        sm.sendMessage(msgType);
    }
}
#method_after
void notify(int msgType) {
    mErrorNotification = msgType;
    for (IpServer ipServer : mNotifyList) {
        ipServer.sendMessage(msgType);
    }
}
#end_block

#method_before
@Override
public void enter() {
    Log.e(TAG, "Error in setIpForwardingEnabled");
    notify(TetherInterfaceStateMachine.CMD_IP_FORWARDING_ENABLE_ERROR);
}
#method_after
@Override
public void enter() {
    Log.e(TAG, "Error in setIpForwardingEnabled");
    notify(IpServer.CMD_IP_FORWARDING_ENABLE_ERROR);
}
#end_block

#method_before
@Override
public void enter() {
    Log.e(TAG, "Error in setIpForwardingDisabled");
    notify(TetherInterfaceStateMachine.CMD_IP_FORWARDING_DISABLE_ERROR);
}
#method_after
@Override
public void enter() {
    Log.e(TAG, "Error in setIpForwardingDisabled");
    notify(IpServer.CMD_IP_FORWARDING_DISABLE_ERROR);
}
#end_block

#method_before
@Override
public void enter() {
    Log.e(TAG, "Error in startTethering");
    notify(TetherInterfaceStateMachine.CMD_START_TETHERING_ERROR);
    try {
        mNMService.setIpForwardingEnabled(false);
    } catch (Exception e) {
    }
}
#method_after
@Override
public void enter() {
    Log.e(TAG, "Error in startTethering");
    notify(IpServer.CMD_START_TETHERING_ERROR);
    try {
        mNMService.setIpForwardingEnabled(false);
    } catch (Exception e) {
    }
}
#end_block

#method_before
@Override
public void enter() {
    Log.e(TAG, "Error in stopTethering");
    notify(TetherInterfaceStateMachine.CMD_STOP_TETHERING_ERROR);
    try {
        mNMService.setIpForwardingEnabled(false);
    } catch (Exception e) {
    }
}
#method_after
@Override
public void enter() {
    Log.e(TAG, "Error in stopTethering");
    notify(IpServer.CMD_STOP_TETHERING_ERROR);
    try {
        mNMService.setIpForwardingEnabled(false);
    } catch (Exception e) {
    }
}
#end_block

#method_before
@Override
public void enter() {
    Log.e(TAG, "Error in setDnsForwarders");
    notify(TetherInterfaceStateMachine.CMD_SET_DNS_FORWARDERS_ERROR);
    try {
        mNMService.stopTethering();
    } catch (Exception e) {
    }
    try {
        mNMService.setIpForwardingEnabled(false);
    } catch (Exception e) {
    }
}
#method_after
@Override
public void enter() {
    Log.e(TAG, "Error in setDnsForwarders");
    notify(IpServer.CMD_SET_DNS_FORWARDERS_ERROR);
    try {
        mNMService.stopTethering();
    } catch (Exception e) {
    }
    try {
        mNMService.setIpForwardingEnabled(false);
    } catch (Exception e) {
    }
}
#end_block

#method_before
public void sendOffloadExemptPrefixes(final Set<IpPrefix> localPrefixes) {
    // Add in well-known minimum set.
    PrefixUtils.addNonForwardablePrefixes(localPrefixes);
    // Add tragically hardcoded prefixes.
    localPrefixes.add(PrefixUtils.DEFAULT_WIFI_P2P_PREFIX);
    // the IP serving mode of each.
    for (TetherInterfaceStateMachine tism : mNotifyList) {
        final LinkProperties lp = tism.linkProperties();
        switch(tism.servingMode()) {
            case IControlsTethering.STATE_UNAVAILABLE:
            case IControlsTethering.STATE_AVAILABLE:
                // No usable LinkProperties in these states.
                continue;
            case IControlsTethering.STATE_TETHERED:
                // downstream "offload-able" prefixes.
                for (LinkAddress addr : lp.getAllLinkAddresses()) {
                    final InetAddress ip = addr.getAddress();
                    if (ip.isLinkLocalAddress())
                        continue;
                    localPrefixes.add(PrefixUtils.ipAddressAsPrefix(ip));
                }
                break;
            case IControlsTethering.STATE_LOCAL_ONLY:
                // Add prefixes covering all local IPs.
                localPrefixes.addAll(PrefixUtils.localPrefixesFrom(lp));
                break;
        }
    }
    mOffloadController.setLocalPrefixes(localPrefixes);
}
#method_after
public void sendOffloadExemptPrefixes(final Set<IpPrefix> localPrefixes) {
    // Add in well-known minimum set.
    PrefixUtils.addNonForwardablePrefixes(localPrefixes);
    // Add tragically hardcoded prefixes.
    localPrefixes.add(PrefixUtils.DEFAULT_WIFI_P2P_PREFIX);
    // the IP serving mode of each.
    for (IpServer ipServer : mNotifyList) {
        final LinkProperties lp = ipServer.linkProperties();
        switch(ipServer.servingMode()) {
            case IpServer.STATE_UNAVAILABLE:
            case IpServer.STATE_AVAILABLE:
                // No usable LinkProperties in these states.
                continue;
            case IpServer.STATE_TETHERED:
                // downstream "offload-able" prefixes.
                for (LinkAddress addr : lp.getAllLinkAddresses()) {
                    final InetAddress ip = addr.getAddress();
                    if (ip.isLinkLocalAddress())
                        continue;
                    localPrefixes.add(PrefixUtils.ipAddressAsPrefix(ip));
                }
                break;
            case IpServer.STATE_LOCAL_ONLY:
                // Add prefixes covering all local IPs.
                localPrefixes.addAll(PrefixUtils.localPrefixesFrom(lp));
                break;
        }
    }
    mOffloadController.setLocalPrefixes(localPrefixes);
}
#end_block

#method_before
@Override
public void dump(FileDescriptor fd, PrintWriter writer, String[] args) {
    // Binder.java closes the resource for us.
    @SuppressWarnings("resource")
    final IndentingPrintWriter pw = new IndentingPrintWriter(writer, "  ");
    if (!DumpUtils.checkDumpPermission(mContext, TAG, pw))
        return;
    pw.println("Tethering:");
    pw.increaseIndent();
    pw.println("Configuration:");
    pw.increaseIndent();
    final TetheringConfiguration cfg = mConfig;
    cfg.dump(pw);
    pw.decreaseIndent();
    pw.println("Entitlement:");
    pw.increaseIndent();
    mEntitleMgr.dump(pw);
    pw.decreaseIndent();
    synchronized (mPublicSync) {
        pw.println("Tether state:");
        pw.increaseIndent();
        for (int i = 0; i < mTetherStates.size(); i++) {
            final String iface = mTetherStates.keyAt(i);
            final TetherState tetherState = mTetherStates.valueAt(i);
            pw.print(iface + " - ");
            switch(tetherState.lastState) {
                case IControlsTethering.STATE_UNAVAILABLE:
                    pw.print("UnavailableState");
                    break;
                case IControlsTethering.STATE_AVAILABLE:
                    pw.print("AvailableState");
                    break;
                case IControlsTethering.STATE_TETHERED:
                    pw.print("TetheredState");
                    break;
                case IControlsTethering.STATE_LOCAL_ONLY:
                    pw.print("LocalHotspotState");
                    break;
                default:
                    pw.print("UnknownState");
                    break;
            }
            pw.println(" - lastError = " + tetherState.lastError);
        }
        pw.println("Upstream wanted: " + upstreamWanted());
        pw.println("Current upstream interface(s): " + mCurrentUpstreamIfaceSet);
        pw.decreaseIndent();
    }
    pw.println("Hardware offload:");
    pw.increaseIndent();
    mOffloadController.dump(pw);
    pw.decreaseIndent();
    pw.println("Log:");
    pw.increaseIndent();
    if (argsContain(args, SHORT_ARG)) {
        pw.println("<log removed for brevity>");
    } else {
        mLog.dump(fd, pw, args);
    }
    pw.decreaseIndent();
    pw.decreaseIndent();
}
#method_after
@Override
public void dump(FileDescriptor fd, PrintWriter writer, String[] args) {
    // Binder.java closes the resource for us.
    @SuppressWarnings("resource")
    final IndentingPrintWriter pw = new IndentingPrintWriter(writer, "  ");
    if (!DumpUtils.checkDumpPermission(mContext, TAG, pw))
        return;
    pw.println("Tethering:");
    pw.increaseIndent();
    pw.println("Configuration:");
    pw.increaseIndent();
    final TetheringConfiguration cfg = mConfig;
    cfg.dump(pw);
    pw.decreaseIndent();
    synchronized (mPublicSync) {
        pw.println("Tether state:");
        pw.increaseIndent();
        for (int i = 0; i < mTetherStates.size(); i++) {
            final String iface = mTetherStates.keyAt(i);
            final TetherState tetherState = mTetherStates.valueAt(i);
            pw.print(iface + " - ");
            switch(tetherState.lastState) {
                case IpServer.STATE_UNAVAILABLE:
                    pw.print("UnavailableState");
                    break;
                case IpServer.STATE_AVAILABLE:
                    pw.print("AvailableState");
                    break;
                case IpServer.STATE_TETHERED:
                    pw.print("TetheredState");
                    break;
                case IpServer.STATE_LOCAL_ONLY:
                    pw.print("LocalHotspotState");
                    break;
                default:
                    pw.print("UnknownState");
                    break;
            }
            pw.println(" - lastError = " + tetherState.lastError);
        }
        pw.println("Upstream wanted: " + upstreamWanted());
        pw.println("Current upstream interface(s): " + mCurrentUpstreamIfaceSet);
        pw.decreaseIndent();
    }
    pw.println("Hardware offload:");
    pw.increaseIndent();
    mOffloadController.dump(pw);
    pw.decreaseIndent();
    pw.println("Log:");
    pw.increaseIndent();
    if (argsContain(args, SHORT_ARG)) {
        pw.println("<log removed for brevity>");
    } else {
        mLog.dump(fd, pw, args);
    }
    pw.decreaseIndent();
    pw.decreaseIndent();
}
#end_block

#method_before
private IControlsTethering makeControlCallback(String ifname) {
    return new IControlsTethering() {

        @Override
        public void updateInterfaceState(TetherInterfaceStateMachine who, int state, int lastError) {
            notifyInterfaceStateChange(ifname, who, state, lastError);
        }

        @Override
        public void updateLinkProperties(TetherInterfaceStateMachine who, LinkProperties newLp) {
            notifyLinkPropertiesChanged(ifname, who, newLp);
        }
    };
}
#method_after
private IpServer.Callback makeControlCallback() {
    return new IpServer.Callback() {

        @Override
        public void updateInterfaceState(IpServer who, int state, int lastError) {
            notifyInterfaceStateChange(who, state, lastError);
        }

        @Override
        public void updateLinkProperties(IpServer who, LinkProperties newLp) {
            notifyLinkPropertiesChanged(who, newLp);
        }
    };
}
#end_block

#method_before
private void notifyInterfaceStateChange(String iface, TetherInterfaceStateMachine who, int state, int error) {
    synchronized (mPublicSync) {
        final TetherState tetherState = mTetherStates.get(iface);
        if (tetherState != null && tetherState.stateMachine.equals(who)) {
            tetherState.lastState = state;
            tetherState.lastError = error;
        } else {
            if (DBG)
                Log.d(TAG, "got notification from stale iface " + iface);
        }
    }
    mLog.log(String.format("OBSERVED iface=%s state=%s error=%s", iface, state, error));
    try {
        // Notify that we're tethering (or not) this interface.
        // This is how data saver for instance knows if the user explicitly
        // turned on tethering (thus keeping us from being in data saver mode).
        mPolicyManager.onTetheringChanged(iface, state == IControlsTethering.STATE_TETHERED);
    } catch (RemoteException e) {
    // Not really very much we can do here.
    }
    // by sending CMD_CLEAR_ERROR
    if (error == TETHER_ERROR_MASTER_ERROR) {
        mTetherMasterSM.sendMessage(TetherMasterSM.CMD_CLEAR_ERROR, who);
    }
    int which;
    switch(state) {
        case IControlsTethering.STATE_UNAVAILABLE:
        case IControlsTethering.STATE_AVAILABLE:
            which = TetherMasterSM.EVENT_IFACE_SERVING_STATE_INACTIVE;
            break;
        case IControlsTethering.STATE_TETHERED:
        case IControlsTethering.STATE_LOCAL_ONLY:
            which = TetherMasterSM.EVENT_IFACE_SERVING_STATE_ACTIVE;
            break;
        default:
            Log.wtf(TAG, "Unknown interface state: " + state);
            return;
    }
    mTetherMasterSM.sendMessage(which, state, 0, who);
    sendTetherStateChangedBroadcast();
}
#method_after
private void notifyInterfaceStateChange(IpServer who, int state, int error) {
    final String iface = who.interfaceName();
    synchronized (mPublicSync) {
        final TetherState tetherState = mTetherStates.get(iface);
        if (tetherState != null && tetherState.ipServer.equals(who)) {
            tetherState.lastState = state;
            tetherState.lastError = error;
        } else {
            if (DBG)
                Log.d(TAG, "got notification from stale iface " + iface);
        }
    }
    mLog.log(String.format("OBSERVED iface=%s state=%s error=%s", iface, state, error));
    try {
        // Notify that we're tethering (or not) this interface.
        // This is how data saver for instance knows if the user explicitly
        // turned on tethering (thus keeping us from being in data saver mode).
        mPolicyManager.onTetheringChanged(iface, state == IpServer.STATE_TETHERED);
    } catch (RemoteException e) {
    // Not really very much we can do here.
    }
    // by sending CMD_CLEAR_ERROR
    if (error == TETHER_ERROR_MASTER_ERROR) {
        mTetherMasterSM.sendMessage(TetherMasterSM.CMD_CLEAR_ERROR, who);
    }
    int which;
    switch(state) {
        case IpServer.STATE_UNAVAILABLE:
        case IpServer.STATE_AVAILABLE:
            which = TetherMasterSM.EVENT_IFACE_SERVING_STATE_INACTIVE;
            break;
        case IpServer.STATE_TETHERED:
        case IpServer.STATE_LOCAL_ONLY:
            which = TetherMasterSM.EVENT_IFACE_SERVING_STATE_ACTIVE;
            break;
        default:
            Log.wtf(TAG, "Unknown interface state: " + state);
            return;
    }
    mTetherMasterSM.sendMessage(which, state, 0, who);
    sendTetherStateChangedBroadcast();
}
#end_block

#method_before
private void notifyLinkPropertiesChanged(String iface, TetherInterfaceStateMachine who, LinkProperties newLp) {
    final int state;
    synchronized (mPublicSync) {
        final TetherState tetherState = mTetherStates.get(iface);
        if (tetherState != null && tetherState.stateMachine.equals(who)) {
            state = tetherState.lastState;
        } else {
            mLog.log("got notification from stale iface " + iface);
            return;
        }
    }
    mLog.log(String.format("OBSERVED LinkProperties update iface=%s state=%s lp=%s", iface, IControlsTethering.getStateString(state), newLp));
    final int which = TetherMasterSM.EVENT_IFACE_UPDATE_LINKPROPERTIES;
    mTetherMasterSM.sendMessage(which, state, 0, newLp);
}
#method_after
private void notifyLinkPropertiesChanged(IpServer who, LinkProperties newLp) {
    final String iface = who.interfaceName();
    final int state;
    synchronized (mPublicSync) {
        final TetherState tetherState = mTetherStates.get(iface);
        if (tetherState != null && tetherState.ipServer.equals(who)) {
            state = tetherState.lastState;
        } else {
            mLog.log("got notification from stale iface " + iface);
            return;
        }
    }
    mLog.log(String.format("OBSERVED LinkProperties update iface=%s state=%s lp=%s", iface, IpServer.getStateString(state), newLp));
    final int which = TetherMasterSM.EVENT_IFACE_UPDATE_LINKPROPERTIES;
    mTetherMasterSM.sendMessage(which, state, 0, newLp);
}
#end_block

#method_before
private void maybeTrackNewInterfaceLocked(final String iface, int interfaceType) {
    // If we have already started a TISM for this interface, skip.
    if (mTetherStates.containsKey(iface)) {
        mLog.log("active iface (" + iface + ") reported as added, ignoring");
        return;
    }
    mLog.log("adding TetheringInterfaceStateMachine for: " + iface);
    final TetherState tetherState = new TetherState(new TetherInterfaceStateMachine(iface, mLooper, interfaceType, mLog, mNMService, mStatsService, makeControlCallback(iface), mDeps));
    mTetherStates.put(iface, tetherState);
    tetherState.stateMachine.start();
}
#method_after
private void maybeTrackNewInterfaceLocked(final String iface, int interfaceType) {
    // If we have already started a TISM for this interface, skip.
    if (mTetherStates.containsKey(iface)) {
        mLog.log("active iface (" + iface + ") reported as added, ignoring");
        return;
    }
    mLog.log("adding TetheringInterfaceStateMachine for: " + iface);
    final TetherState tetherState = new TetherState(new IpServer(iface, mLooper, interfaceType, mLog, mNMService, mStatsService, makeControlCallback(), mConfig.enableLegacyDhcpServer, mDeps.getIpServerDependencies()));
    mTetherStates.put(iface, tetherState);
    tetherState.ipServer.start();
}
#end_block

#method_before
private void stopTrackingInterfaceLocked(final String iface) {
    final TetherState tetherState = mTetherStates.get(iface);
    if (tetherState == null) {
        mLog.log("attempting to remove unknown iface (" + iface + "), ignoring");
        return;
    }
    tetherState.stateMachine.stop();
    mLog.log("removing TetheringInterfaceStateMachine for: " + iface);
    mTetherStates.remove(iface);
}
#method_after
private void stopTrackingInterfaceLocked(final String iface) {
    final TetherState tetherState = mTetherStates.get(iface);
    if (tetherState == null) {
        mLog.log("attempting to remove unknown iface (" + iface + "), ignoring");
        return;
    }
    tetherState.ipServer.stop();
    mLog.log("removing TetheringInterfaceStateMachine for: " + iface);
    mTetherStates.remove(iface);
}
#end_block

#method_before
public void reset() {
    upstreamNetworkMonitorMasterSM = null;
    ipv6CoordinatorNotifyList = null;
    isTetheringSupportedCalls = 0;
    mEnMgr = null;
}
#method_after
public void reset() {
    upstreamNetworkMonitorMasterSM = null;
    ipv6CoordinatorNotifyList = null;
    isTetheringSupportedCalls = 0;
}
#end_block

#method_before
@Override
public IPv6TetheringCoordinator getIPv6TetheringCoordinator(ArrayList<TetherInterfaceStateMachine> notifyList, SharedLog log) {
    ipv6CoordinatorNotifyList = notifyList;
    return mIPv6TetheringCoordinator;
}
#method_after
@Override
public IPv6TetheringCoordinator getIPv6TetheringCoordinator(ArrayList<IpServer> notifyList, SharedLog log) {
    ipv6CoordinatorNotifyList = notifyList;
    return mIPv6TetheringCoordinator;
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    MockitoAnnotations.initMocks(this);
    when(mResources.getStringArray(com.android.internal.R.array.config_tether_dhcp_range)).thenReturn(new String[0]);
    when(mResources.getStringArray(com.android.internal.R.array.config_tether_usb_regexs)).thenReturn(new String[] { "test_rndis\\d" });
    when(mResources.getStringArray(com.android.internal.R.array.config_tether_wifi_regexs)).thenReturn(new String[] { "test_wlan\\d" });
    when(mResources.getStringArray(com.android.internal.R.array.config_tether_bluetooth_regexs)).thenReturn(new String[0]);
    when(mResources.getIntArray(com.android.internal.R.array.config_tether_upstream_types)).thenReturn(new int[0]);
    when(mResources.getBoolean(com.android.internal.R.bool.config_tether_upstream_automatic)).thenReturn(false);
    when(mNMService.listInterfaces()).thenReturn(new String[] { TEST_MOBILE_IFNAME, TEST_WLAN_IFNAME, TEST_USB_IFNAME });
    when(mNMService.getInterfaceConfig(anyString())).thenReturn(new InterfaceConfiguration());
    when(mRouterAdvertisementDaemon.start()).thenReturn(true);
    mServiceContext = new MockContext(mContext);
    mContentResolver = new MockContentResolver(mServiceContext);
    mContentResolver.addProvider(Settings.AUTHORITY, new FakeSettingsProvider());
    mIntents = new Vector<>();
    mBroadcastReceiver = new BroadcastReceiver() {

        @Override
        public void onReceive(Context context, Intent intent) {
            mIntents.addElement(intent);
        }
    };
    mServiceContext.registerReceiver(mBroadcastReceiver, new IntentFilter(ACTION_TETHER_STATE_CHANGED));
    mTetheringDependencies.reset();
    mTethering = new Tethering(mServiceContext, mNMService, mStatsService, mPolicyManager, mLooper.getLooper(), mSystemProperties, mTetheringDependencies);
    verify(mNMService).registerTetheringStatsProvider(any(), anyString());
}
#method_after
@Before
public void setUp() throws Exception {
    MockitoAnnotations.initMocks(this);
    when(mResources.getStringArray(com.android.internal.R.array.config_tether_dhcp_range)).thenReturn(new String[0]);
    when(mResources.getStringArray(com.android.internal.R.array.config_tether_usb_regexs)).thenReturn(new String[] { "test_rndis\\d" });
    when(mResources.getStringArray(com.android.internal.R.array.config_tether_wifi_regexs)).thenReturn(new String[] { "test_wlan\\d" });
    when(mResources.getStringArray(com.android.internal.R.array.config_tether_bluetooth_regexs)).thenReturn(new String[0]);
    when(mResources.getIntArray(com.android.internal.R.array.config_tether_upstream_types)).thenReturn(new int[0]);
    when(mResources.getBoolean(com.android.internal.R.bool.config_tether_upstream_automatic)).thenReturn(false);
    when(mNMService.listInterfaces()).thenReturn(new String[] { TEST_MOBILE_IFNAME, TEST_WLAN_IFNAME, TEST_USB_IFNAME });
    when(mNMService.getInterfaceConfig(anyString())).thenReturn(new InterfaceConfiguration());
    when(mRouterAdvertisementDaemon.start()).thenReturn(true);
    mServiceContext = new MockContext(mContext);
    mContentResolver = new MockContentResolver(mServiceContext);
    mContentResolver.addProvider(Settings.AUTHORITY, new FakeSettingsProvider());
    Settings.Global.putInt(mContentResolver, TETHER_ENABLE_LEGACY_DHCP_SERVER, 0);
    mIntents = new Vector<>();
    mBroadcastReceiver = new BroadcastReceiver() {

        @Override
        public void onReceive(Context context, Intent intent) {
            mIntents.addElement(intent);
        }
    };
    mServiceContext.registerReceiver(mBroadcastReceiver, new IntentFilter(ACTION_TETHER_STATE_CHANGED));
    mTetheringDependencies.reset();
    mTethering = makeTethering();
    verify(mNMService).registerTetheringStatsProvider(any(), anyString());
}
#end_block

#method_before
public void failingLocalOnlyHotspotLegacyApBroadcast(boolean emulateInterfaceStatusChanged) throws Exception {
    // hotspot mode is to be started.
    if (emulateInterfaceStatusChanged) {
        mTethering.interfaceStatusChanged(TEST_WLAN_IFNAME, true);
    }
    sendWifiApStateChanged(WIFI_AP_STATE_ENABLED);
    mLooper.dispatchAll();
    // broadcast indicating that the interface is "available".
    if (emulateInterfaceStatusChanged) {
        assertEquals(1, mTetheringDependencies.isTetheringSupportedCalls);
        verifyTetheringBroadcast(TEST_WLAN_IFNAME, EXTRA_AVAILABLE_TETHER);
    }
    verifyNoMoreInteractions(mNMService);
    verifyNoMoreInteractions(mWifiManager);
}
#method_after
public void failingLocalOnlyHotspotLegacyApBroadcast(boolean emulateInterfaceStatusChanged) throws Exception {
    // hotspot mode is to be started.
    if (emulateInterfaceStatusChanged) {
        mTethering.interfaceStatusChanged(TEST_WLAN_IFNAME, true);
    }
    sendWifiApStateChanged(WIFI_AP_STATE_ENABLED);
    mLooper.dispatchAll();
    // interface is "available".
    if (emulateInterfaceStatusChanged) {
        assertEquals(1, mTetheringDependencies.isTetheringSupportedCalls);
        verifyTetheringBroadcast(TEST_WLAN_IFNAME, EXTRA_AVAILABLE_TETHER);
    }
    verifyNoMoreInteractions(mNMService);
    verifyNoMoreInteractions(mWifiManager);
}
#end_block

#method_before
private void sendIPv6TetherUpdates(NetworkState upstreamState) {
    // IPv6TetheringCoordinator must have been notified of downstream
    verify(mIPv6TetheringCoordinator, times(1)).addActiveDownstream(argThat(sm -> sm.linkProperties().getInterfaceName().equals(TEST_USB_IFNAME)), eq(IControlsTethering.STATE_TETHERED));
    for (TetherInterfaceStateMachine tism : mTetheringDependencies.ipv6CoordinatorNotifyList) {
        NetworkState ipv6OnlyState = buildMobileUpstreamState(false, true, false);
        tism.sendMessage(TetherInterfaceStateMachine.CMD_IPV6_TETHER_UPDATE, 0, 0, upstreamState.linkProperties.isIPv6Provisioned() ? ipv6OnlyState.linkProperties : null);
    }
    mLooper.dispatchAll();
}
#method_after
private void sendIPv6TetherUpdates(NetworkState upstreamState) {
    // IPv6TetheringCoordinator must have been notified of downstream
    verify(mIPv6TetheringCoordinator, times(1)).addActiveDownstream(argThat(sm -> sm.linkProperties().getInterfaceName().equals(TEST_USB_IFNAME)), eq(IpServer.STATE_TETHERED));
    for (IpServer ipSrv : mTetheringDependencies.ipv6CoordinatorNotifyList) {
        NetworkState ipv6OnlyState = buildMobileUpstreamState(false, true, false);
        ipSrv.sendMessage(IpServer.CMD_IPV6_TETHER_UPDATE, 0, 0, upstreamState.linkProperties.isIPv6Provisioned() ? ipv6OnlyState.linkProperties : null);
    }
    mLooper.dispatchAll();
}
#end_block

#method_before
@Test
public void workingMobileUsbTethering_IPv4() throws Exception {
    NetworkState upstreamState = buildMobileIPv4UpstreamState();
    runUsbTethering(upstreamState);
    verify(mNMService, times(1)).enableNat(TEST_USB_IFNAME, TEST_MOBILE_IFNAME);
    verify(mNMService, times(1)).startInterfaceForwarding(TEST_USB_IFNAME, TEST_MOBILE_IFNAME);
    sendIPv6TetherUpdates(upstreamState);
    verify(mRouterAdvertisementDaemon, never()).buildNewRa(any(), notNull());
}
#method_after
@Test
public void workingMobileUsbTethering_IPv4() throws Exception {
    NetworkState upstreamState = buildMobileIPv4UpstreamState();
    runUsbTethering(upstreamState);
    verify(mNMService, times(1)).enableNat(TEST_USB_IFNAME, TEST_MOBILE_IFNAME);
    verify(mNMService, times(1)).startInterfaceForwarding(TEST_USB_IFNAME, TEST_MOBILE_IFNAME);
    sendIPv6TetherUpdates(upstreamState);
    verify(mRouterAdvertisementDaemon, never()).buildNewRa(any(), notNull());
    verify(mDhcpServer, times(1)).start();
}
#end_block

#method_before
@Test
public void workingMobileUsbTethering_DualStack() throws Exception {
    NetworkState upstreamState = buildMobileDualStackUpstreamState();
    runUsbTethering(upstreamState);
    verify(mNMService, times(1)).enableNat(TEST_USB_IFNAME, TEST_MOBILE_IFNAME);
    verify(mNMService, times(1)).startInterfaceForwarding(TEST_USB_IFNAME, TEST_MOBILE_IFNAME);
    verify(mRouterAdvertisementDaemon, times(1)).start();
    sendIPv6TetherUpdates(upstreamState);
    verify(mRouterAdvertisementDaemon, times(1)).buildNewRa(any(), notNull());
    verify(mNetd, times(1)).tetherApplyDnsInterfaces();
}
#method_after
@Test
public void workingMobileUsbTethering_DualStack() throws Exception {
    NetworkState upstreamState = buildMobileDualStackUpstreamState();
    runUsbTethering(upstreamState);
    verify(mNMService, times(1)).enableNat(TEST_USB_IFNAME, TEST_MOBILE_IFNAME);
    verify(mNMService, times(1)).startInterfaceForwarding(TEST_USB_IFNAME, TEST_MOBILE_IFNAME);
    verify(mRouterAdvertisementDaemon, times(1)).start();
    verify(mDhcpServer, times(1)).start();
    sendIPv6TetherUpdates(upstreamState);
    verify(mRouterAdvertisementDaemon, times(1)).buildNewRa(any(), notNull());
    verify(mNetd, times(1)).tetherApplyDnsInterfaces();
}
#end_block

#method_before
@Test
public void workingMobileUsbTethering_MultipleUpstreams() throws Exception {
    NetworkState upstreamState = buildMobile464xlatUpstreamState();
    runUsbTethering(upstreamState);
    verify(mNMService, times(1)).enableNat(TEST_USB_IFNAME, TEST_XLAT_MOBILE_IFNAME);
    verify(mNMService, times(1)).enableNat(TEST_USB_IFNAME, TEST_MOBILE_IFNAME);
    verify(mNMService, times(1)).startInterfaceForwarding(TEST_USB_IFNAME, TEST_MOBILE_IFNAME);
    verify(mNMService, times(1)).startInterfaceForwarding(TEST_USB_IFNAME, TEST_XLAT_MOBILE_IFNAME);
    sendIPv6TetherUpdates(upstreamState);
    verify(mRouterAdvertisementDaemon, times(1)).buildNewRa(any(), notNull());
    verify(mNetd, times(1)).tetherApplyDnsInterfaces();
}
#method_after
@Test
public void workingMobileUsbTethering_MultipleUpstreams() throws Exception {
    NetworkState upstreamState = buildMobile464xlatUpstreamState();
    runUsbTethering(upstreamState);
    verify(mNMService, times(1)).enableNat(TEST_USB_IFNAME, TEST_XLAT_MOBILE_IFNAME);
    verify(mNMService, times(1)).enableNat(TEST_USB_IFNAME, TEST_MOBILE_IFNAME);
    verify(mDhcpServer, times(1)).start();
    verify(mNMService, times(1)).startInterfaceForwarding(TEST_USB_IFNAME, TEST_MOBILE_IFNAME);
    verify(mNMService, times(1)).startInterfaceForwarding(TEST_USB_IFNAME, TEST_XLAT_MOBILE_IFNAME);
    sendIPv6TetherUpdates(upstreamState);
    verify(mRouterAdvertisementDaemon, times(1)).buildNewRa(any(), notNull());
    verify(mNetd, times(1)).tetherApplyDnsInterfaces();
}
#end_block

#method_before
@Test
public void workingMobileUsbTethering_v6Then464xlat() throws Exception {
    // Setup IPv6
    NetworkState upstreamState = buildMobileIPv6UpstreamState();
    runUsbTethering(upstreamState);
    verify(mNMService, times(1)).enableNat(TEST_USB_IFNAME, TEST_MOBILE_IFNAME);
    verify(mNMService, times(1)).startInterfaceForwarding(TEST_USB_IFNAME, TEST_MOBILE_IFNAME);
    // Then 464xlat comes up
    upstreamState = buildMobile464xlatUpstreamState();
    when(mUpstreamNetworkMonitor.selectPreferredUpstreamType(any())).thenReturn(upstreamState);
    // Upstream LinkProperties changed: UpstreamNetworkMonitor sends EVENT_ON_LINKPROPERTIES.
    mTetheringDependencies.upstreamNetworkMonitorMasterSM.sendMessage(Tethering.TetherMasterSM.EVENT_UPSTREAM_CALLBACK, UpstreamNetworkMonitor.EVENT_ON_LINKPROPERTIES, 0, upstreamState);
    mLooper.dispatchAll();
    // Forwarding is added for 464xlat
    verify(mNMService, times(1)).enableNat(TEST_USB_IFNAME, TEST_XLAT_MOBILE_IFNAME);
    verify(mNMService, times(1)).startInterfaceForwarding(TEST_USB_IFNAME, TEST_XLAT_MOBILE_IFNAME);
    // Forwarding was not re-added for v6 (still times(1))
    verify(mNMService, times(1)).enableNat(TEST_USB_IFNAME, TEST_MOBILE_IFNAME);
    verify(mNMService, times(1)).startInterfaceForwarding(TEST_USB_IFNAME, TEST_MOBILE_IFNAME);
}
#method_after
@Test
public void workingMobileUsbTethering_v6Then464xlat() throws Exception {
    // Setup IPv6
    NetworkState upstreamState = buildMobileIPv6UpstreamState();
    runUsbTethering(upstreamState);
    verify(mNMService, times(1)).enableNat(TEST_USB_IFNAME, TEST_MOBILE_IFNAME);
    verify(mDhcpServer, times(1)).start();
    verify(mNMService, times(1)).startInterfaceForwarding(TEST_USB_IFNAME, TEST_MOBILE_IFNAME);
    // Then 464xlat comes up
    upstreamState = buildMobile464xlatUpstreamState();
    when(mUpstreamNetworkMonitor.selectPreferredUpstreamType(any())).thenReturn(upstreamState);
    // Upstream LinkProperties changed: UpstreamNetworkMonitor sends EVENT_ON_LINKPROPERTIES.
    mTetheringDependencies.upstreamNetworkMonitorMasterSM.sendMessage(Tethering.TetherMasterSM.EVENT_UPSTREAM_CALLBACK, UpstreamNetworkMonitor.EVENT_ON_LINKPROPERTIES, 0, upstreamState);
    mLooper.dispatchAll();
    // Forwarding is added for 464xlat
    verify(mNMService, times(1)).enableNat(TEST_USB_IFNAME, TEST_XLAT_MOBILE_IFNAME);
    verify(mNMService, times(1)).startInterfaceForwarding(TEST_USB_IFNAME, TEST_XLAT_MOBILE_IFNAME);
    // Forwarding was not re-added for v6 (still times(1))
    verify(mNMService, times(1)).enableNat(TEST_USB_IFNAME, TEST_MOBILE_IFNAME);
    verify(mNMService, times(1)).startInterfaceForwarding(TEST_USB_IFNAME, TEST_MOBILE_IFNAME);
    // DHCP not restarted on downstream (still times(1))
    verify(mDhcpServer, times(1)).start();
}
#end_block

#method_before
@Test
public void failureEnablingIpForwarding() throws Exception {
    when(mWifiManager.startSoftAp(any(WifiConfiguration.class))).thenReturn(true);
    doThrow(new RemoteException()).when(mNMService).setIpForwardingEnabled(true);
    // Emulate pressing the WiFi tethering button.
    mTethering.startTethering(TETHERING_WIFI, null, false);
    mLooper.dispatchAll();
    verify(mWifiManager, times(1)).startSoftAp(null);
    verifyNoMoreInteractions(mWifiManager);
    verifyNoMoreInteractions(mNMService);
    // Emulate externally-visible WifiManager effects, causing the
    // per-interface state machine to start up, and telling us that
    // tethering mode is to be started.
    mTethering.interfaceStatusChanged(TEST_WLAN_IFNAME, true);
    sendWifiApStateChanged(WIFI_AP_STATE_ENABLED, TEST_WLAN_IFNAME, IFACE_IP_MODE_TETHERED);
    mLooper.dispatchAll();
    // We verify get/set called thrice here: once for setup and twice during
    // teardown because all events happen over the course of the single
    // dispatchAll() above. Note that once the TISM IPv4 address config
    // code is refactored the two calls during shutdown will revert to one.
    verify(mNMService, times(2)).getInterfaceConfig(TEST_WLAN_IFNAME);
    verify(mNMService, times(3)).setInterfaceConfig(eq(TEST_WLAN_IFNAME), any(InterfaceConfiguration.class));
    verify(mNMService, times(1)).tetherInterface(TEST_WLAN_IFNAME);
    verify(mWifiManager).updateInterfaceIpState(TEST_WLAN_IFNAME, WifiManager.IFACE_IP_MODE_TETHERED);
    // TODO: Figure out why this isn't exactly once, for sendTetherStateChangedBroadcast().
    assertTrue(1 <= mTetheringDependencies.isTetheringSupportedCalls);
    verifyTetheringBroadcast(TEST_WLAN_IFNAME, EXTRA_AVAILABLE_TETHER);
    // This is called, but will throw.
    verify(mNMService, times(1)).setIpForwardingEnabled(true);
    // This never gets called because of the exception thrown above.
    verify(mNMService, times(0)).startTethering(any(String[].class));
    // When the master state machine transitions to an error state it tells
    // downstream interfaces, which causes us to tell Wi-Fi about the error
    // so it can take down AP mode.
    verify(mNMService, times(1)).untetherInterface(TEST_WLAN_IFNAME);
    verify(mWifiManager).updateInterfaceIpState(TEST_WLAN_IFNAME, WifiManager.IFACE_IP_MODE_CONFIGURATION_ERROR);
    verifyNoMoreInteractions(mWifiManager);
    verifyNoMoreInteractions(mNMService);
}
#method_after
@Test
public void failureEnablingIpForwarding() throws Exception {
    when(mWifiManager.startSoftAp(any(WifiConfiguration.class))).thenReturn(true);
    doThrow(new RemoteException()).when(mNMService).setIpForwardingEnabled(true);
    // Emulate pressing the WiFi tethering button.
    mTethering.startTethering(TETHERING_WIFI, null, false);
    mLooper.dispatchAll();
    verify(mWifiManager, times(1)).startSoftAp(null);
    verifyNoMoreInteractions(mWifiManager);
    verifyNoMoreInteractions(mNMService);
    // Emulate externally-visible WifiManager effects, causing the
    // per-interface state machine to start up, and telling us that
    // tethering mode is to be started.
    mTethering.interfaceStatusChanged(TEST_WLAN_IFNAME, true);
    sendWifiApStateChanged(WIFI_AP_STATE_ENABLED, TEST_WLAN_IFNAME, IFACE_IP_MODE_TETHERED);
    mLooper.dispatchAll();
    // We verify get/set called thrice here: once for setup and twice during
    // teardown because all events happen over the course of the single
    // dispatchAll() above. Note that once the IpServer IPv4 address config
    // code is refactored the two calls during shutdown will revert to one.
    verify(mNMService, times(2)).getInterfaceConfig(TEST_WLAN_IFNAME);
    verify(mNMService, times(3)).setInterfaceConfig(eq(TEST_WLAN_IFNAME), any(InterfaceConfiguration.class));
    verify(mNMService, times(1)).tetherInterface(TEST_WLAN_IFNAME);
    verify(mWifiManager).updateInterfaceIpState(TEST_WLAN_IFNAME, WifiManager.IFACE_IP_MODE_TETHERED);
    // TODO: Figure out why this isn't exactly once, for sendTetherStateChangedBroadcast().
    assertTrue(1 <= mTetheringDependencies.isTetheringSupportedCalls);
    verifyTetheringBroadcast(TEST_WLAN_IFNAME, EXTRA_AVAILABLE_TETHER);
    // This is called, but will throw.
    verify(mNMService, times(1)).setIpForwardingEnabled(true);
    // This never gets called because of the exception thrown above.
    verify(mNMService, times(0)).startTethering(any(String[].class));
    // When the master state machine transitions to an error state it tells
    // downstream interfaces, which causes us to tell Wi-Fi about the error
    // so it can take down AP mode.
    verify(mNMService, times(1)).untetherInterface(TEST_WLAN_IFNAME);
    verify(mWifiManager).updateInterfaceIpState(TEST_WLAN_IFNAME, WifiManager.IFACE_IP_MODE_CONFIGURATION_ERROR);
    verifyNoMoreInteractions(mWifiManager);
    verifyNoMoreInteractions(mNMService);
}
#end_block

#method_before
@Before
public void setUp() {
    MockitoAnnotations.initMocks(this);
    when(mContext.getResources()).thenReturn(mResources);
    when(mResources.getStringArray(R.array.config_tether_dhcp_range)).thenReturn(new String[0]);
    when(mResources.getStringArray(R.array.config_tether_usb_regexs)).thenReturn(new String[0]);
    when(mResources.getStringArray(R.array.config_tether_wifi_regexs)).thenReturn(new String[0]);
    when(mResources.getStringArray(R.array.config_tether_bluetooth_regexs)).thenReturn(new String[0]);
    // Produce some acceptable looking provision app setting if requested.
    when(mResources.getStringArray(R.array.config_mobile_hotspot_provision_app)).thenReturn(PROVISIONING_APP_NAME);
    when(mResources.getIntArray(R.array.config_tether_upstream_types)).thenReturn(new int[0]);
    when(mLog.forSubComponent(anyString())).thenReturn(mLog);
    when(mSystemProperties.getBoolean(eq(EntitlementManager.DISABLE_PROVISIONING_SYSPROP_KEY), anyBoolean())).thenReturn(false);
    when(mSystemProperties.getBoolean(eq(EntitlementManager.DISABLE_PROVISIONING_SYSPROP_KEY), anyBoolean())).thenReturn(false);
    // Act like the CarrierConfigManager is present and ready unless told otherwise.
    when(mContext.getSystemService(Context.CARRIER_CONFIG_SERVICE)).thenReturn(mCarrierConfigManager);
    when(mCarrierConfigManager.getConfig()).thenReturn(mCarrierConfig);
    mCarrierConfig.putBoolean(CarrierConfigManager.KEY_REQUIRE_ENTITLEMENT_CHECKS_BOOL, true);
    mSM = new TestStateMachine();
    mEnMgr = new EntitlementManager(mContext, mSM, mLog, EVENT_EM_UPDATE, mSystemProperties);
}
#method_after
@Before
public void setUp() {
    MockitoAnnotations.initMocks(this);
    when(mContext.getResources()).thenReturn(mResources);
    when(mContext.getContentResolver()).thenReturn(mContent);
    when(mResources.getStringArray(R.array.config_tether_dhcp_range)).thenReturn(new String[0]);
    when(mResources.getStringArray(R.array.config_tether_usb_regexs)).thenReturn(new String[0]);
    when(mResources.getStringArray(R.array.config_tether_wifi_regexs)).thenReturn(new String[0]);
    when(mResources.getStringArray(R.array.config_tether_bluetooth_regexs)).thenReturn(new String[0]);
    when(mResources.getIntArray(R.array.config_tether_upstream_types)).thenReturn(new int[0]);
    when(mLog.forSubComponent(anyString())).thenReturn(mLog);
    mEnMgr = new EntitlementManager(mContext, mLog, mSystemProperties);
    mEnMgr.updateConfiguration(new TetheringConfiguration(mContext, mLog));
}
#end_block

#method_before
@After
public void tearDown() throws Exception {
    if (mSM != null) {
        mSM.quit();
        mSM = null;
    }
}
#method_after
@After
public void tearDown() throws Exception {
}
#end_block

#method_before
@Test
public void canRequireProvisioning() {
    mEnMgr.updateConfiguration(new TetheringConfiguration(mContext, mLog));
    assertTrue(mEnMgr.isTetherProvisioningRequired());
}
#method_after
@Test
public void canRequireProvisioning() {
    setupForRequiredProvisioning();
    mEnMgr.updateConfiguration(new TetheringConfiguration(mContext, mLog));
    assertTrue(mEnMgr.isTetherProvisioningRequired());
}
#end_block

#method_before
@Test
public void toleratesCarrierConfigManagerMissing() {
    when(mContext.getSystemService(Context.CARRIER_CONFIG_SERVICE)).thenReturn(null);
    mEnMgr.updateConfiguration(new TetheringConfiguration(mContext, mLog));
    // Couldn't get the CarrierConfigManager, but still had a declared provisioning app.
    // We therefore still require provisioning.
    assertTrue(mEnMgr.isTetherProvisioningRequired());
}
#method_after
@Test
public void toleratesCarrierConfigManagerMissing() {
    setupForRequiredProvisioning();
    when(mContext.getSystemService(Context.CARRIER_CONFIG_SERVICE)).thenReturn(null);
    mEnMgr.updateConfiguration(new TetheringConfiguration(mContext, mLog));
    // Couldn't get the CarrierConfigManager, but still had a declared provisioning app.
    // Therefore provisioning still be required.
    assertTrue(mEnMgr.isTetherProvisioningRequired());
}
#end_block

#method_before
@Test
public void toleratesCarrierConfigMissing() {
    when(mCarrierConfigManager.getConfig()).thenReturn(null);
    mEnMgr.updateConfiguration(new TetheringConfiguration(mContext, mLog));
    // We still have a provisioning app configured, so still require provisioning.
    assertTrue(mEnMgr.isTetherProvisioningRequired());
}
#method_after
@Test
public void toleratesCarrierConfigMissing() {
    setupForRequiredProvisioning();
    when(mCarrierConfigManager.getConfig()).thenReturn(null);
    mEnMgr.updateConfiguration(new TetheringConfiguration(mContext, mLog));
    // We still have a provisioning app configured, so still require provisioning.
    assertTrue(mEnMgr.isTetherProvisioningRequired());
}
#end_block

#method_before
@Test
public void provisioningNotRequiredWhenAppNotFound() {
    when(mResources.getStringArray(R.array.config_mobile_hotspot_provision_app)).thenReturn(null);
    mEnMgr.updateConfiguration(new TetheringConfiguration(mContext, mLog));
    assertTrue(!mEnMgr.isTetherProvisioningRequired());
    when(mResources.getStringArray(R.array.config_mobile_hotspot_provision_app)).thenReturn(new String[] { "malformedApp" });
    mEnMgr.updateConfiguration(new TetheringConfiguration(mContext, mLog));
    assertTrue(!mEnMgr.isTetherProvisioningRequired());
}
#method_after
@Test
public void provisioningNotRequiredWhenAppNotFound() {
    setupForRequiredProvisioning();
    when(mResources.getStringArray(R.array.config_mobile_hotspot_provision_app)).thenReturn(null);
    mEnMgr.updateConfiguration(new TetheringConfiguration(mContext, mLog));
    assertFalse(mEnMgr.isTetherProvisioningRequired());
    when(mResources.getStringArray(R.array.config_mobile_hotspot_provision_app)).thenReturn(new String[] { "malformedApp" });
    mEnMgr.updateConfiguration(new TetheringConfiguration(mContext, mLog));
    assertFalse(mEnMgr.isTetherProvisioningRequired());
}
#end_block

#method_before
public IPv6TetheringCoordinator getIPv6TetheringCoordinator(ArrayList<TetherInterfaceStateMachine> notifyList, SharedLog log) {
    return new IPv6TetheringCoordinator(notifyList, log);
}
#method_after
public IPv6TetheringCoordinator getIPv6TetheringCoordinator(ArrayList<IpServer> notifyList, SharedLog log) {
    return new IPv6TetheringCoordinator(notifyList, log);
}
#end_block

#method_before
public EntitlementManager getEntitlementManager(Context ctx, StateMachine target, SharedLog log, int what, MockableSystemProperties systemProperties) {
    return new EntitlementManager(ctx, target, log, what, systemProperties);
}
#method_after
public EntitlementManager getEntitlementManager(Context ctx, SharedLog log, MockableSystemProperties systemProperties) {
    return new EntitlementManager(ctx, log, systemProperties);
}
#end_block

#method_before
public static AddAnnotation fromJsonFile(AnnotationClass annotationClass, Path file) throws IOException {
    Gson gson = new GsonBuilder().create();
    BodyDeclarationLocatorStore<AnnotationInfo> annotationStore = new BodyDeclarationLocatorStore<>();
    String contents = Files.lines(file, Charset.forName("UTF-8")).filter(l -> !l.trim().startsWith("//")).collect(Collectors.joining("\n"));
    try (JsonReader reader = gson.newJsonReader(new StringReader(contents))) {
        try {
            reader.beginArray();
            while (reader.hasNext()) {
                reader.beginObject();
                BodyDeclarationLocator locator = null;
                String annotationClassName = annotationClass.getName();
                Map<String, Object> annotationProperties = new LinkedHashMap<>();
                while (reader.hasNext()) {
                    String name = reader.nextName();
                    switch(name) {
                        case "@location":
                            locator = BodyDeclarationLocators.fromStringForm(reader.nextString());
                            break;
                        default:
                            Class<?> propertyType = annotationClass.getPropertyType(name);
                            Object value;
                            JsonToken token = reader.peek();
                            if (token == JsonToken.STRING) {
                                String text = reader.nextString();
                                if (propertyType != String.class) {
                                    value = new Placeholder(text);
                                } else {
                                    // Literal string.
                                    value = text;
                                }
                            } else {
                                if (propertyType == boolean.class) {
                                    value = reader.nextBoolean();
                                } else if (propertyType == int.class) {
                                    value = reader.nextInt();
                                } else if (propertyType == double.class) {
                                    value = reader.nextDouble();
                                } else {
                                    throw new IllegalStateException("Unknown property type: " + propertyType + " for " + annotationClassName);
                                }
                            }
                            annotationProperties.put(name, value);
                    }
                }
                if (locator == null) {
                    throw new IllegalStateException("Missing location");
                }
                AnnotationInfo annotationInfo = new AnnotationInfo(annotationClass, annotationProperties);
                annotationStore.add(locator, annotationInfo);
                reader.endObject();
            }
            reader.endArray();
        } catch (RuntimeException e) {
            throw new MalformedJsonException("Error parsing JSON at " + reader.getPath(), e);
        }
    }
    return new AddAnnotation(annotationStore);
}
#method_after
public static AddAnnotation fromJsonFile(AnnotationClass annotationClass, Path file) throws IOException {
    Gson gson = new GsonBuilder().create();
    BodyDeclarationLocatorStore<AnnotationInfo> annotationStore = new BodyDeclarationLocatorStore<>();
    String jsonStringWithoutComments = Files.lines(file, StandardCharsets.UTF_8).filter(l -> !l.trim().startsWith("//")).collect(Collectors.joining("\n"));
    try (JsonReader reader = gson.newJsonReader(new StringReader(jsonStringWithoutComments))) {
        try {
            reader.beginArray();
            while (reader.hasNext()) {
                reader.beginObject();
                BodyDeclarationLocator locator = null;
                String annotationClassName = annotationClass.getName();
                Map<String, Object> annotationProperties = new LinkedHashMap<>();
                while (reader.hasNext()) {
                    String name = reader.nextName();
                    switch(name) {
                        case "@location":
                            locator = BodyDeclarationLocators.fromStringForm(reader.nextString());
                            break;
                        default:
                            Class<?> propertyType = annotationClass.getPropertyType(name);
                            Object value;
                            JsonToken token = reader.peek();
                            if (token == JsonToken.STRING) {
                                String text = reader.nextString();
                                if (propertyType != String.class) {
                                    value = new Placeholder(text);
                                } else {
                                    // Literal string.
                                    value = text;
                                }
                            } else {
                                if (propertyType == boolean.class) {
                                    value = reader.nextBoolean();
                                } else if (propertyType == int.class) {
                                    value = reader.nextInt();
                                } else if (propertyType == double.class) {
                                    value = reader.nextDouble();
                                } else {
                                    throw new IllegalStateException("Unknown property type: " + propertyType + " for " + annotationClassName);
                                }
                            }
                            annotationProperties.put(name, value);
                    }
                }
                if (locator == null) {
                    throw new IllegalStateException("Missing location");
                }
                AnnotationInfo annotationInfo = new AnnotationInfo(annotationClass, annotationProperties);
                annotationStore.add(locator, annotationInfo);
                reader.endObject();
            }
            reader.endArray();
        } catch (RuntimeException e) {
            throw new MalformedJsonException("Error parsing JSON at " + reader.getPath(), e);
        }
    }
    return new AddAnnotation(annotationStore);
}
#end_block

#method_before
public void bindRouteViewHolder(Item item) {
    MediaRouter.RouteInfo route = (MediaRouter.RouteInfo) item.getData();
    bindRouteVolumeSliderHolder(route);
    // Get icons for route and checkbox.
    mImageView.setImageDrawable(getIconDrawable(route));
    mTextView.setText(route.getName());
    if (mSelectedRoute instanceof MediaRouter.DynamicGroupInfo) {
        mCheckBox.setVisibility(View.VISIBLE);
        boolean selected = isSelected(route);
        boolean enabled = isEnabled(route);
        // Set checked state of checkbox and replace progress bar with route type icon.
        mCheckBox.setChecked(selected);
        mProgressBar.setVisibility(View.INVISIBLE);
        mImageView.setVisibility(View.VISIBLE);
        // Set enabled states of views, height of volume slider layout and alpha value
        // of itemView.
        mItemView.setEnabled(enabled && !selected);
        mCheckBox.setEnabled(enabled);
        mMuteButton.setEnabled(enabled);
        mVolumeSlider.setEnabled(enabled);
        mCheckBox.setOnClickListener(mCheckBoxClickListener);
        setLayoutHeight(mVolumeSliderLayout, selected ? mExpandedLayoutHeight : mCollapsedLayoutHeight);
        mItemView.setAlpha(enabled ? 1.0f : mDisabledAlpha);
    } else {
        mCheckBox.setVisibility(View.GONE);
        mProgressBar.setVisibility(View.INVISIBLE);
        mImageView.setVisibility(View.VISIBLE);
        setLayoutHeight(mVolumeSliderLayout, mExpandedLayoutHeight);
        mItemView.setAlpha(1.0f);
    }
}
#method_after
public void bindRouteViewHolder(Item item) {
    MediaRouter.RouteInfo route = (MediaRouter.RouteInfo) item.getData();
    bindRouteVolumeSliderHolder(route);
    // Get icons for route and checkbox.
    mImageView.setImageDrawable(getIconDrawable(route));
    mTextView.setText(route.getName());
    if (mSelectedRoute instanceof MediaRouter.DynamicGroupInfo) {
        mCheckBox.setVisibility(View.VISIBLE);
        boolean selected = isSelected(route);
        boolean enabled = isEnabled(route);
        // Set checked state of checkbox and replace progress bar with route type icon.
        mCheckBox.setChecked(selected);
        mProgressBar.setVisibility(View.INVISIBLE);
        mImageView.setVisibility(View.VISIBLE);
        // Set enabled states of views, height of volume slider layout and alpha value
        // of itemView.
        mItemView.setEnabled(enabled);
        mCheckBox.setEnabled(enabled);
        mMuteButton.setEnabled(enabled);
        mVolumeSlider.setEnabled(enabled);
        mItemView.setOnClickListener(mCheckBoxClickListener);
        mCheckBox.setOnClickListener(mCheckBoxClickListener);
        setLayoutHeight(mVolumeSliderLayout, selected ? mExpandedLayoutHeight : mCollapsedLayoutHeight);
        mItemView.setAlpha(enabled ? 1.0f : mDisabledAlpha);
    } else {
        mCheckBox.setVisibility(View.GONE);
        mProgressBar.setVisibility(View.INVISIBLE);
        mImageView.setVisibility(View.VISIBLE);
        setLayoutHeight(mVolumeSliderLayout, mExpandedLayoutHeight);
        mItemView.setAlpha(1.0f);
    }
}
#end_block

#method_before
private void initialize(Context context, AttributeSet attrs) {
    mRecyclerView = new RecyclerView(context);
    mRecyclerView.setId(ViewCompat.generateViewId());
    mLayoutManager = new LinearLayoutManager(context);
    mRecyclerView.setLayoutManager(mLayoutManager);
    setOrientation(context, attrs);
    mRecyclerView.setLayoutParams(new ViewGroup.LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT));
    mRecyclerView.addOnChildAttachStateChangeListener(enforceChildFillListener());
    new PagerSnapHelper().attachToRecyclerView(mRecyclerView);
    mScrollEventAdapter = new ScrollEventAdapter(mLayoutManager);
    mRecyclerView.addOnScrollListener(mScrollEventAdapter);
    mEventDispatcher = new CompositeOnPageChangeListener(3);
    mScrollEventAdapter.setOnPageChangeListener(mEventDispatcher);
    // Listener that updates mCurrentItem after swipes. Also triggered in other cases, but in
    // all those cases mCurrentItem will only be overwritten with the same value.
    final OnPageChangeListener currentItemUpdater = new OnPageChangeListener() {

        @Override
        public void onPageScrolled(int position, float positionOffset, int positionOffsetPx) {
        }

        @Override
        public void onPageSelected(int position) {
            mCurrentItem = position;
        }

        @Override
        public void onPageScrollStateChanged(int state) {
        }
    };
    // Add currentItemUpdater before mExternalPageChangeListeners, because we need to update
    // internal state first
    mEventDispatcher.addOnPageChangeListener(currentItemUpdater);
    mEventDispatcher.addOnPageChangeListener(mExternalPageChangeListeners);
    // Add mPageTransformerAdapter after mExternalPageChangeListeners, because page transform
    // events must be fired after scroll events
    mPageTransformerAdapter = new PageTransformerAdapter(mLayoutManager);
    mEventDispatcher.addOnPageChangeListener(mPageTransformerAdapter);
    attachViewToParent(mRecyclerView, 0, mRecyclerView.getLayoutParams());
}
#method_after
private void initialize(Context context, AttributeSet attrs) {
    mRecyclerView = new RecyclerView(context);
    mRecyclerView.setId(ViewCompat.generateViewId());
    mLayoutManager = new LinearLayoutManager(context);
    mRecyclerView.setLayoutManager(mLayoutManager);
    setOrientation(context, attrs);
    mRecyclerView.setLayoutParams(new ViewGroup.LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT));
    mRecyclerView.addOnChildAttachStateChangeListener(enforceChildFillListener());
    new PagerSnapHelper().attachToRecyclerView(mRecyclerView);
    mScrollEventAdapter = new ScrollEventAdapter(mLayoutManager);
    mRecyclerView.addOnScrollListener(mScrollEventAdapter);
    mPageChangeEventDispatcher = new CompositeOnPageChangeListener(3);
    mScrollEventAdapter.setOnPageChangeListener(mPageChangeEventDispatcher);
    // Listener that updates mCurrentItem after swipes. Also triggered in other cases, but in
    // all those cases mCurrentItem will only be overwritten with the same value.
    final OnPageChangeListener currentItemUpdater = new OnPageChangeListener() {

        @Override
        public void onPageScrolled(int position, float positionOffset, int positionOffsetPx) {
        }

        @Override
        public void onPageSelected(int position) {
            mCurrentItem = position;
        }

        @Override
        public void onPageScrollStateChanged(int state) {
        }
    };
    // Add currentItemUpdater before mExternalPageChangeListeners, because we need to update
    // internal state first
    mPageChangeEventDispatcher.addOnPageChangeListener(currentItemUpdater);
    mPageChangeEventDispatcher.addOnPageChangeListener(mExternalPageChangeListeners);
    // Add mPageTransformerAdapter after mExternalPageChangeListeners, because page transform
    // events must be fired after scroll events
    mPageTransformerAdapter = new PageTransformerAdapter(mLayoutManager);
    mPageChangeEventDispatcher.addOnPageChangeListener(mPageTransformerAdapter);
    attachViewToParent(mRecyclerView, 0, mRecyclerView.getLayoutParams());
}
#end_block

#method_before
@Override
protected void onRestoreInstanceState(Parcelable state) {
    if (!(state instanceof SavedState)) {
        super.onRestoreInstanceState(state);
        return;
    }
    SavedState ss = (SavedState) state;
    super.onRestoreInstanceState(ss.getSuperState());
    setOrientation(ss.mOrientation);
    mCurrentItem = ss.mCurrentItem;
    if (ss.mScrollInProgress) {
        // A scroll was in progress, so the RecyclerView is not at mCurrentItem right now. Move
        // it to mCurrentItem instantly in the _next_ frame, as RecyclerView is not yet fired up
        // at this moment. Remove the event dispatcher during this time, as it will fire a
        // scroll event for the current position, which has already been fired before the config
        // change.
        final ScrollEventAdapter scrollEventAdapter = mScrollEventAdapter;
        final OnPageChangeListener eventDispatcher = mEventDispatcher;
        scrollEventAdapter.setOnPageChangeListener(null);
        mRecyclerView.post(new Runnable() {

            @Override
            public void run() {
                scrollEventAdapter.setOnPageChangeListener(eventDispatcher);
                mRecyclerView.scrollToPosition(mCurrentItem);
            }
        });
    }
    if (ss.mAdapterState != null) {
        Adapter adapter = mRecyclerView.getAdapter();
        if (adapter instanceof FragmentStateAdapter) {
            ((FragmentStateAdapter) adapter).restoreState(ss.mAdapterState);
        }
    }
}
#method_after
@Override
protected void onRestoreInstanceState(Parcelable state) {
    if (!(state instanceof SavedState)) {
        super.onRestoreInstanceState(state);
        return;
    }
    SavedState ss = (SavedState) state;
    super.onRestoreInstanceState(ss.getSuperState());
    setOrientation(ss.mOrientation);
    mCurrentItem = ss.mCurrentItem;
    if (ss.mScrollInProgress) {
        // A scroll was in progress, so the RecyclerView is not at mCurrentItem right now. Move
        // it to mCurrentItem instantly in the _next_ frame, as RecyclerView is not yet fired up
        // at this moment. Remove the event dispatcher during this time, as it will fire a
        // scroll event for the current position, which has already been fired before the config
        // change.
        final ScrollEventAdapter scrollEventAdapter = mScrollEventAdapter;
        final OnPageChangeListener eventDispatcher = mPageChangeEventDispatcher;
        scrollEventAdapter.setOnPageChangeListener(null);
        mRecyclerView.post(new Runnable() {

            @Override
            public void run() {
                scrollEventAdapter.setOnPageChangeListener(eventDispatcher);
                scrollEventAdapter.notifyRestoreCurrentItem(mCurrentItem);
                mRecyclerView.scrollToPosition(mCurrentItem);
            }
        });
    } else {
        mScrollEventAdapter.notifyRestoreCurrentItem(mCurrentItem);
    }
    if (ss.mAdapterState != null) {
        Adapter adapter = mRecyclerView.getAdapter();
        if (adapter instanceof FragmentStateAdapter) {
            ((FragmentStateAdapter) adapter).restoreState(ss.mAdapterState);
        }
    }
}
#end_block

#method_before
@Test
public void onBindEditTextListenerTest() throws Throwable {
    final InputFilter[] filters = { new InputFilter.LengthFilter(15) };
    mActivityRule.runOnUiThread(new Runnable() {

        @Override
        public void run() {
            assertNull(mEditTextPreference.getOnBindEditTextListener());
            mEditTextPreference.setOnBindEditTextListener(new EditTextPreference.OnBindEditTextListener() {

                @Override
                public void onBindEditText(EditText editText) {
                    editText.setFilters(filters);
                }
            });
        }
    });
    onView(withText(PREFERENCE)).perform(click());
    onView(withId(android.R.id.edit)).check(matches(isDisplayed()));
    EditText editText = ((DialogFragment) mActivityRule.getActivity().getSupportFragmentManager().findFragmentByTag("androidx.preference.PreferenceFragment.DIALOG")).getDialog().findViewById(android.R.id.edit);
    assertEquals(filters, editText.getFilters());
}
#method_after
@Test
public void onBindEditTextListenerTest() throws Throwable {
    final InputFilter[] filters = { new InputFilter.LengthFilter(15) };
    mActivityRule.runOnUiThread(new Runnable() {

        @Override
        public void run() {
            assertNull(mEditTextPreference.getOnBindEditTextListener());
            mEditTextPreference.setOnBindEditTextListener(new EditTextPreference.OnBindEditTextListener() {

                @Override
                public void onBindEditText(@NonNull EditText editText) {
                    editText.setFilters(filters);
                }
            });
        }
    });
    onView(withText(PREFERENCE)).perform(click());
    onView(withId(android.R.id.edit)).check(matches(isDisplayed()));
    EditText editText = ((DialogFragment) mActivityRule.getActivity().getSupportFragmentManager().findFragmentByTag("androidx.preference.PreferenceFragment.DIALOG")).getDialog().findViewById(android.R.id.edit);
    assertEquals(filters, editText.getFilters());
}
#end_block

#method_before
// ////////////////////////////////////////////////////////////////////
// Other public methods
public static AudioAttributesImpl fromBundle(Bundle bundle) {
    if (bundle == null) {
        return null;
    }
    int usage = bundle.getInt(AUDIO_ATTRIBUTES_USAGE, USAGE_UNKNOWN);
    int contentType = bundle.getInt(AUDIO_ATTRIBUTES_CONTENT_TYPE, CONTENT_TYPE_UNKNOWN);
    int flags = bundle.getInt(AUDIO_ATTRIBUTES_FLAGS, 0);
    int legacyStream = bundle.getInt(AUDIO_ATTRIBUTES_LEGACY_STREAM_TYPE, INVALID_STREAM_TYPE);
    return new AudioAttributesImplBase(contentType, flags, usage, legacyStream);
}
#method_after
public static AudioAttributesImpl fromBundle(Bundle bundle) {
    if (bundle == null) {
        return null;
    }
    int usage = bundle.getInt(AUDIO_ATTRIBUTES_USAGE, USAGE_UNKNOWN);
    int contentType = bundle.getInt(AUDIO_ATTRIBUTES_CONTENT_TYPE, CONTENT_TYPE_UNKNOWN);
    int flags = bundle.getInt(AUDIO_ATTRIBUTES_FLAGS, 0);
    int legacyStream = bundle.getInt(AUDIO_ATTRIBUTES_LEGACY_STREAM_TYPE, INVALID_STREAM_TYPE);
    return new AudioAttributesImplBase(contentType, flags, usage, legacyStream);
}
#end_block

#method_before
@Override
public int getVolumeControlStream() {
    return AudioAttributesCompat.toVolumeStreamType(true, getFlags(), getUsage());
}
#method_after
@Override
public int getVolumeControlStream() {
    // TODO: check the change of AudioAttributes.toVolumeStreamType() after API 21.
    return mAudioAttributes.getVolumeControlStream();
}
#end_block

#method_before
@Override
public Builder setUsage(int usage) {
    if (usage == 16) /* USAGE_ASSISTANT */
    {
        // TODO: shouldn't we keep the origin usage?
        usage = AudioAttributes.USAGE_ASSISTANCE_NAVIGATION_GUIDANCE;
    }
    mFwkBuilder.setUsage(usage);
    return this;
}
#method_after
@Override
public Builder setUsage(int usage) {
    if (usage == AudioAttributes.USAGE_ASSISTANT) {
        // TODO: shouldn't we keep the origin usage?
        usage = AudioAttributes.USAGE_ASSISTANCE_NAVIGATION_GUIDANCE;
    }
    mFwkBuilder.setUsage(usage);
    return this;
}
#end_block

#method_before
private void checkIsEuiccSupported() {
    // eUICC is supported only if the b8 and b2 of the first tB after T=15 are set to 1.
    for (int i = 0; i < mInterfaceBytes.size() - 1; i++) {
        if (mInterfaceBytes.get(i).getTD() != null && (mInterfaceBytes.get(i).getTD() & T_MASK) == T_VALUE_FOR_GLOBAL_INTERFACE && mInterfaceBytes.get(i + 1).getTB() != null && (mInterfaceBytes.get(i + 1).getTB() & B8_MASK) > 0 && (mInterfaceBytes.get(i + 1).getTB() & B2_MASK) > 0) {
            mIsEuiccSupported = true;
            return;
        }
    }
}
#method_after
private void checkIsEuiccSupported() {
    // eUICC is supported only if the b8 and b2 of the first tB after T=15 are set to 1.
    for (int i = 0; i < mInterfaceBytes.size() - 1; i++) {
        if (mInterfaceBytes.get(i).getTD() != null && (mInterfaceBytes.get(i).getTD() & T_MASK) == T_VALUE_FOR_GLOBAL_INTERFACE && mInterfaceBytes.get(i + 1).getTB() != null && (mInterfaceBytes.get(i + 1).getTB() & B8_MASK) != 0 && (mInterfaceBytes.get(i + 1).getTB() & B2_MASK) != 0) {
            mIsEuiccSupported = true;
            return;
        }
    }
}
#end_block

#method_before
private boolean processChld(int chld) {
    Call activeCall = mCallsManager.getActiveCall();
    Call ringingCall = mCallsManager.getRingingCall();
    Call heldCall = mCallsManager.getHeldCall();
    // TODO: Keeping as Log.i for now.  Move to Log.d after L release if BT proves stable.
    Log.i(TAG, "Active: %s\nRinging: %s\nHeld: %s", activeCall, ringingCall, heldCall);
    if (chld == CHLD_TYPE_RELEASEHELD) {
        if (ringingCall != null) {
            mCallsManager.rejectCall(ringingCall, false, null);
            return true;
        } else if (heldCall != null) {
            mCallsManager.disconnectCall(heldCall);
            return true;
        }
    } else if (chld == CHLD_TYPE_RELEASEACTIVE_ACCEPTHELD) {
        if (activeCall == null && ringingCall == null && heldCall == null)
            return false;
        if (activeCall != null) {
            mCallsManager.disconnectCall(activeCall);
            if (ringingCall != null) {
                mCallsManager.answerCall(ringingCall, VideoProfile.STATE_AUDIO_ONLY);
            } else if (heldCall != null) {
                mCallsManager.unholdCall(heldCall);
            }
            return true;
        }
        if (ringingCall != null) {
            mCallsManager.answerCall(ringingCall, ringingCall.getVideoState());
        } else if (heldCall != null) {
            mCallsManager.unholdCall(heldCall);
        }
        return true;
    } else if (chld == CHLD_TYPE_HOLDACTIVE_ACCEPTHELD) {
        if (activeCall != null && activeCall.can(Connection.CAPABILITY_SWAP_CONFERENCE)) {
            activeCall.swapConference();
            Log.i(TAG, "CDMA calls in conference swapped, updating headset");
            updateHeadsetWithCallState(true);
            return true;
        } else if (ringingCall != null) {
            mCallsManager.answerCall(ringingCall, VideoProfile.STATE_AUDIO_ONLY);
            return true;
        } else if (heldCall != null) {
            // CallsManager will hold any active calls when unhold() is called on a
            // currently-held call.
            mCallsManager.unholdCall(heldCall);
            return true;
        } else if (activeCall != null && activeCall.can(Connection.CAPABILITY_HOLD)) {
            mCallsManager.holdCall(activeCall);
            return true;
        }
    } else if (chld == CHLD_TYPE_ADDHELDTOCONF) {
        if (activeCall != null) {
            if (activeCall.can(Connection.CAPABILITY_MERGE_CONFERENCE)) {
                activeCall.mergeConference();
                return true;
            } else {
                List<Call> conferenceable = activeCall.getConferenceableCalls();
                if (!conferenceable.isEmpty()) {
                    mCallsManager.conference(activeCall, conferenceable.get(0));
                    return true;
                }
            }
        }
    }
    return false;
}
#method_after
private boolean processChld(int chld) {
    Call activeCall = mCallsManager.getActiveCall();
    Call ringingCall = mCallsManager.getRingingCall();
    Call heldCall = mCallsManager.getHeldCall();
    // TODO: Keeping as Log.i for now.  Move to Log.d after L release if BT proves stable.
    Log.i(TAG, "Active: %s\nRinging: %s\nHeld: %s", activeCall, ringingCall, heldCall);
    if (chld == CHLD_TYPE_RELEASEHELD) {
        if (ringingCall != null) {
            mCallsManager.rejectCall(ringingCall, false, null);
            return true;
        } else if (heldCall != null) {
            mCallsManager.disconnectCall(heldCall);
            return true;
        }
    } else if (chld == CHLD_TYPE_RELEASEACTIVE_ACCEPTHELD) {
        if (activeCall == null && ringingCall == null && heldCall == null)
            return false;
        if (activeCall != null) {
            mCallsManager.disconnectCall(activeCall);
            if (ringingCall != null) {
                mCallsManager.answerCall(ringingCall, VideoProfile.STATE_AUDIO_ONLY);
            }
            return true;
        }
        if (ringingCall != null) {
            mCallsManager.answerCall(ringingCall, ringingCall.getVideoState());
        } else if (heldCall != null) {
            mCallsManager.unholdCall(heldCall);
        }
        return true;
    } else if (chld == CHLD_TYPE_HOLDACTIVE_ACCEPTHELD) {
        if (activeCall != null && activeCall.can(Connection.CAPABILITY_SWAP_CONFERENCE)) {
            activeCall.swapConference();
            Log.i(TAG, "CDMA calls in conference swapped, updating headset");
            updateHeadsetWithCallState(true);
            return true;
        } else if (ringingCall != null) {
            mCallsManager.answerCall(ringingCall, VideoProfile.STATE_AUDIO_ONLY);
            return true;
        } else if (heldCall != null) {
            // CallsManager will hold any active calls when unhold() is called on a
            // currently-held call.
            mCallsManager.unholdCall(heldCall);
            return true;
        } else if (activeCall != null && activeCall.can(Connection.CAPABILITY_HOLD)) {
            mCallsManager.holdCall(activeCall);
            return true;
        }
    } else if (chld == CHLD_TYPE_ADDHELDTOCONF) {
        if (activeCall != null) {
            if (activeCall.can(Connection.CAPABILITY_MERGE_CONFERENCE)) {
                activeCall.mergeConference();
                return true;
            } else {
                List<Call> conferenceable = activeCall.getConferenceableCalls();
                if (!conferenceable.isEmpty()) {
                    mCallsManager.conference(activeCall, conferenceable.get(0));
                    return true;
                }
            }
        }
    }
    return false;
}
#end_block

#method_before
private void updateHeadsetWithCallState(boolean force) {
    Call activeCall = mCallsManager.getActiveCall();
    Call ringingCall = mCallsManager.getRingingCall();
    Call heldCall = mCallsManager.getHeldCall();
    int bluetoothCallState = getBluetoothCallStateForUpdate();
    String ringingAddress = null;
    int ringingAddressType = 128;
    String name = null;
    if (ringingCall != null && ringingCall.getHandle() != null) {
        ringingAddress = ringingCall.getHandle().getSchemeSpecificPart();
        if (ringingAddress != null) {
            ringingAddressType = PhoneNumberUtils.toaFromString(ringingAddress);
        }
        name = ringingCall.getCallerDisplayName();
        if (TextUtils.isEmpty(name)) {
            name = ringingCall.getName();
        }
    }
    if (ringingAddress == null) {
        ringingAddress = "";
    }
    int numActiveCalls = activeCall == null ? 0 : 1;
    int numHeldCalls = mCallsManager.getNumHeldCalls();
    int numChildrenOfActiveCall = activeCall == null ? 0 : activeCall.getChildCalls().size();
    // Intermediate state for GSM calls which are in the process of being swapped.
    // TODO: Should we be hardcoding this value to 2 or should we check if all top level calls
    // are held?
    boolean callsPendingSwitch = (numHeldCalls == 2);
    // For conference calls which support swapping the active call within the conference
    // (namely CDMA calls) we need to expose that as a held call in order for the BT device
    // to show "swap" and "merge" functionality.
    boolean ignoreHeldCallChange = false;
    if (activeCall != null && activeCall.isConference() && !activeCall.can(Connection.CAPABILITY_CONFERENCE_HAS_NO_CHILDREN)) {
        if (activeCall.can(Connection.CAPABILITY_SWAP_CONFERENCE)) {
            // Indicate that BT device should show SWAP command by indicating that there is a
            // call on hold, but only if the conference wasn't previously merged.
            numHeldCalls = activeCall.wasConferencePreviouslyMerged() ? 0 : 1;
        } else if (activeCall.can(Connection.CAPABILITY_MERGE_CONFERENCE)) {
            // Merge is available, so expose via numHeldCalls.
            numHeldCalls = 1;
        }
        for (Call childCall : activeCall.getChildCalls()) {
            // a call change.
            if (mOldHeldCall == childCall) {
                ignoreHeldCallChange = true;
                break;
            }
        }
    }
    if (mBluetoothHeadset != null && (force || (!callsPendingSwitch && (numActiveCalls != mNumActiveCalls || numChildrenOfActiveCall != mNumChildrenOfActiveCall || numHeldCalls != mNumHeldCalls || bluetoothCallState != mBluetoothCallState || !TextUtils.equals(ringingAddress, mRingingAddress) || ringingAddressType != mRingingAddressType || (heldCall != mOldHeldCall && !ignoreHeldCallChange))))) {
        // If the call is transitioning into the alerting state, send DIALING first.
        // Some devices expect to see a DIALING state prior to seeing an ALERTING state
        // so we need to send it first.
        boolean sendDialingFirst = mBluetoothCallState != bluetoothCallState && bluetoothCallState == CALL_STATE_ALERTING;
        mOldHeldCall = heldCall;
        mNumActiveCalls = numActiveCalls;
        mNumChildrenOfActiveCall = numChildrenOfActiveCall;
        mNumHeldCalls = numHeldCalls;
        mBluetoothCallState = bluetoothCallState;
        mRingingAddress = ringingAddress;
        mRingingAddressType = ringingAddressType;
        if (sendDialingFirst) {
            // Log in full to make logs easier to debug.
            Log.i(TAG, "updateHeadsetWithCallState " + "numActive %s, " + "numHeld %s, " + "callState %s, " + "ringing number %s, " + "ringing type %s", mNumActiveCalls, mNumHeldCalls, CALL_STATE_DIALING, Log.pii(mRingingAddress), mRingingAddressType);
            mBluetoothHeadset.phoneStateChanged(mNumActiveCalls, mNumHeldCalls, CALL_STATE_DIALING, mRingingAddress, mRingingAddressType, name);
        }
        Log.i(TAG, "updateHeadsetWithCallState " + "numActive %s, " + "numHeld %s, " + "callState %s, " + "ringing number %s, " + "ringing type %s", mNumActiveCalls, mNumHeldCalls, mBluetoothCallState, Log.pii(mRingingAddress), mRingingAddressType);
        mBluetoothHeadset.phoneStateChanged(mNumActiveCalls, mNumHeldCalls, mBluetoothCallState, mRingingAddress, mRingingAddressType, name);
        mHeadsetUpdatedRecently = true;
    }
}
#method_after
private void updateHeadsetWithCallState(boolean force) {
    Call activeCall = mCallsManager.getActiveCall();
    Call ringingCall = mCallsManager.getRingingCall();
    Call heldCall = mCallsManager.getHeldCall();
    int bluetoothCallState = getBluetoothCallStateForUpdate();
    String ringingAddress = null;
    int ringingAddressType = 128;
    String ringingName = null;
    if (ringingCall != null && ringingCall.getHandle() != null) {
        ringingAddress = ringingCall.getHandle().getSchemeSpecificPart();
        if (ringingAddress != null) {
            ringingAddressType = PhoneNumberUtils.toaFromString(ringingAddress);
        }
        ringingName = ringingCall.getCallerDisplayName();
        if (TextUtils.isEmpty(ringingName)) {
            ringingName = ringingCall.getName();
        }
    }
    if (ringingAddress == null) {
        ringingAddress = "";
    }
    int numActiveCalls = activeCall == null ? 0 : 1;
    int numHeldCalls = mCallsManager.getNumHeldCalls();
    int numChildrenOfActiveCall = activeCall == null ? 0 : activeCall.getChildCalls().size();
    // Intermediate state for GSM calls which are in the process of being swapped.
    // TODO: Should we be hardcoding this value to 2 or should we check if all top level calls
    // are held?
    boolean callsPendingSwitch = (numHeldCalls == 2);
    // For conference calls which support swapping the active call within the conference
    // (namely CDMA calls) we need to expose that as a held call in order for the BT device
    // to show "swap" and "merge" functionality.
    boolean ignoreHeldCallChange = false;
    if (activeCall != null && activeCall.isConference() && !activeCall.can(Connection.CAPABILITY_CONFERENCE_HAS_NO_CHILDREN)) {
        if (activeCall.can(Connection.CAPABILITY_SWAP_CONFERENCE)) {
            // Indicate that BT device should show SWAP command by indicating that there is a
            // call on hold, but only if the conference wasn't previously merged.
            numHeldCalls = activeCall.wasConferencePreviouslyMerged() ? 0 : 1;
        } else if (activeCall.can(Connection.CAPABILITY_MERGE_CONFERENCE)) {
            // Merge is available, so expose via numHeldCalls.
            numHeldCalls = 1;
        }
        for (Call childCall : activeCall.getChildCalls()) {
            // a call change.
            if (mOldHeldCall == childCall) {
                ignoreHeldCallChange = true;
                break;
            }
        }
    }
    if (mBluetoothHeadset != null && (force || (!callsPendingSwitch && (numActiveCalls != mNumActiveCalls || numChildrenOfActiveCall != mNumChildrenOfActiveCall || numHeldCalls != mNumHeldCalls || bluetoothCallState != mBluetoothCallState || !TextUtils.equals(ringingAddress, mRingingAddress) || ringingAddressType != mRingingAddressType || (heldCall != mOldHeldCall && !ignoreHeldCallChange))))) {
        // If the call is transitioning into the alerting state, send DIALING first.
        // Some devices expect to see a DIALING state prior to seeing an ALERTING state
        // so we need to send it first.
        boolean sendDialingFirst = mBluetoothCallState != bluetoothCallState && bluetoothCallState == CALL_STATE_ALERTING;
        mOldHeldCall = heldCall;
        mNumActiveCalls = numActiveCalls;
        mNumChildrenOfActiveCall = numChildrenOfActiveCall;
        mNumHeldCalls = numHeldCalls;
        mBluetoothCallState = bluetoothCallState;
        mRingingAddress = ringingAddress;
        mRingingAddressType = ringingAddressType;
        if (sendDialingFirst) {
            // Log in full to make logs easier to debug.
            Log.i(TAG, "updateHeadsetWithCallState " + "numActive %s, " + "numHeld %s, " + "callState %s, " + "ringing number %s, " + "ringing type %s, " + "ringing name %s", mNumActiveCalls, mNumHeldCalls, CALL_STATE_DIALING, Log.pii(mRingingAddress), mRingingAddressType, Log.pii(ringingName));
            mBluetoothHeadset.phoneStateChanged(mNumActiveCalls, mNumHeldCalls, CALL_STATE_DIALING, mRingingAddress, mRingingAddressType, ringingName);
        }
        Log.i(TAG, "updateHeadsetWithCallState " + "numActive %s, " + "numHeld %s, " + "callState %s, " + "ringing number %s, " + "ringing type %s, " + "ringing name %s", mNumActiveCalls, mNumHeldCalls, mBluetoothCallState, Log.pii(mRingingAddress), mRingingAddressType, Log.pii(ringingName));
        mBluetoothHeadset.phoneStateChanged(mNumActiveCalls, mNumHeldCalls, mBluetoothCallState, mRingingAddress, mRingingAddressType, ringingName);
        mHeadsetUpdatedRecently = true;
    }
}
#end_block

#method_before
@MediumTest
@Test
public void testProcessChldReleaseActiveHold() throws Exception {
    Call activeCall = createActiveCall();
    Call heldCall = createHeldCall();
    boolean didProcess = mBluetoothPhoneService.mBinder.processChld(CHLD_TYPE_RELEASEACTIVE_ACCEPTHELD);
    verify(mMockCallsManager).disconnectCall(eq(activeCall));
    verify(mMockCallsManager).unholdCall(eq(heldCall));
    assertEquals(didProcess, true);
}
#method_after
@MediumTest
@Test
public void testProcessChldReleaseActiveHold() throws Exception {
    Call activeCall = createActiveCall();
    Call heldCall = createHeldCall();
    boolean didProcess = mBluetoothPhoneService.mBinder.processChld(CHLD_TYPE_RELEASEACTIVE_ACCEPTHELD);
    verify(mMockCallsManager).disconnectCall(eq(activeCall));
    // Call unhold will occur as part of CallsManager auto-unholding the background call on its
    // own.
    assertEquals(didProcess, true);
}
#end_block

#method_before
// BEGIN Android-removed: private StringBuffer format(double, StringBuffer, FieldDelegate).
/*
    /**
     * Formats a double to produce a string.
     * @param number    The double to format
     * @param result    where the text is to be appended
     * @param delegate notified of locations of sub fields
     * @exception       ArithmeticException if rounding is needed with rounding
     *                  mode being set to RoundingMode.UNNECESSARY
     * @return The formatted number string
     *
    private StringBuffer format(double number, StringBuffer result,
                                FieldDelegate delegate) {
        if (Double.isNaN(number) ||
           (Double.isInfinite(number) && multiplier == 0)) {
            int iFieldStart = result.length();
            result.append(symbols.getNaN());
            delegate.formatted(INTEGER_FIELD, Field.INTEGER, Field.INTEGER,
                               iFieldStart, result.length(), result);
            return result;
        }

        /* Detecting whether a double is negative is easy with the exception of
         * the value -0.0.  This is a double which has a zero mantissa (and
         * exponent), but a negative sign bit.  It is semantically distinct from
         * a zero with a positive sign bit, and this distinction is important
         * to certain kinds of computations.  However, it's a little tricky to
         * detect, since (-0.0 == 0.0) and !(-0.0 < 0.0).  How then, you may
         * ask, does it behave distinctly from +0.0?  Well, 1/(-0.0) ==
         * -Infinity.  Proper detection of -0.0 is needed to deal with the
         * issues raised by bugs 4106658, 4106667, and 4147706.  Liu 7/6/98.
         *
        boolean isNegative = ((number < 0.0) || (number == 0.0 && 1/number < 0.0)) ^ (multiplier < 0);

        if (multiplier != 1) {
            number *= multiplier;
        }

        if (Double.isInfinite(number)) {
            if (isNegative) {
                append(result, negativePrefix, delegate,
                       getNegativePrefixFieldPositions(), Field.SIGN);
            } else {
                append(result, positivePrefix, delegate,
                       getPositivePrefixFieldPositions(), Field.SIGN);
            }

            int iFieldStart = result.length();
            result.append(symbols.getInfinity());
            delegate.formatted(INTEGER_FIELD, Field.INTEGER, Field.INTEGER,
                               iFieldStart, result.length(), result);

            if (isNegative) {
                append(result, negativeSuffix, delegate,
                       getNegativeSuffixFieldPositions(), Field.SIGN);
            } else {
                append(result, positiveSuffix, delegate,
                       getPositiveSuffixFieldPositions(), Field.SIGN);
            }

            return result;
        }

        if (isNegative) {
            number = -number;
        }

        // at this point we are guaranteed a nonnegative finite number.
        assert(number >= 0 && !Double.isInfinite(number));

        synchronized(digitList) {
            int maxIntDigits = super.getMaximumIntegerDigits();
            int minIntDigits = super.getMinimumIntegerDigits();
            int maxFraDigits = super.getMaximumFractionDigits();
            int minFraDigits = super.getMinimumFractionDigits();

            digitList.set(isNegative, number, useExponentialNotation ?
                          maxIntDigits + maxFraDigits : maxFraDigits,
                          !useExponentialNotation);
            return subformat(result, delegate, isNegative, false,
                       maxIntDigits, minIntDigits, maxFraDigits, minFraDigits);
        }
    }
    */
// END Android-removed: private StringBuffer format(double, StringBuffer, FieldDelegate).
@Override
public StringBuffer format(long number, StringBuffer result, FieldPosition fieldPosition) {
    // BEGIN Android-changed: Use ICU.
    /*
        fieldPosition.setBeginIndex(0);
        fieldPosition.setEndIndex(0);

        return format(number, result, fieldPosition.getFieldDelegate());
        */
    FieldPosition icuFieldPosition = getIcuFieldPosition(fieldPosition);
    icuDecimalFormat.format(number, result, icuFieldPosition);
    fieldPosition.setBeginIndex(icuFieldPosition.getBeginIndex());
    fieldPosition.setEndIndex(icuFieldPosition.getEndIndex());
    return result;
// END Android-changed: Use ICU.
}
#method_after
// BEGIN Android-removed: Use ICU.
// Removed unused helper function that was only used from (unused on Android) code
// in format(double, StringBuffer, FieldPosition).
/*
    /**
     * Formats a double to produce a string.
     * @param number    The double to format
     * @param result    where the text is to be appended
     * @param delegate notified of locations of sub fields
     * @exception       ArithmeticException if rounding is needed with rounding
     *                  mode being set to RoundingMode.UNNECESSARY
     * @return The formatted number string
     *
    private StringBuffer format(double number, StringBuffer result,
                                FieldDelegate delegate) {
        if (Double.isNaN(number) ||
           (Double.isInfinite(number) && multiplier == 0)) {
            int iFieldStart = result.length();
            result.append(symbols.getNaN());
            delegate.formatted(INTEGER_FIELD, Field.INTEGER, Field.INTEGER,
                               iFieldStart, result.length(), result);
            return result;
        }

        /* Detecting whether a double is negative is easy with the exception of
         * the value -0.0.  This is a double which has a zero mantissa (and
         * exponent), but a negative sign bit.  It is semantically distinct from
         * a zero with a positive sign bit, and this distinction is important
         * to certain kinds of computations.  However, it's a little tricky to
         * detect, since (-0.0 == 0.0) and !(-0.0 < 0.0).  How then, you may
         * ask, does it behave distinctly from +0.0?  Well, 1/(-0.0) ==
         * -Infinity.  Proper detection of -0.0 is needed to deal with the
         * issues raised by bugs 4106658, 4106667, and 4147706.  Liu 7/6/98.
         *
        boolean isNegative = ((number < 0.0) || (number == 0.0 && 1/number < 0.0)) ^ (multiplier < 0);

        if (multiplier != 1) {
            number *= multiplier;
        }

        if (Double.isInfinite(number)) {
            if (isNegative) {
                append(result, negativePrefix, delegate,
                       getNegativePrefixFieldPositions(), Field.SIGN);
            } else {
                append(result, positivePrefix, delegate,
                       getPositivePrefixFieldPositions(), Field.SIGN);
            }

            int iFieldStart = result.length();
            result.append(symbols.getInfinity());
            delegate.formatted(INTEGER_FIELD, Field.INTEGER, Field.INTEGER,
                               iFieldStart, result.length(), result);

            if (isNegative) {
                append(result, negativeSuffix, delegate,
                       getNegativeSuffixFieldPositions(), Field.SIGN);
            } else {
                append(result, positiveSuffix, delegate,
                       getPositiveSuffixFieldPositions(), Field.SIGN);
            }

            return result;
        }

        if (isNegative) {
            number = -number;
        }

        // at this point we are guaranteed a nonnegative finite number.
        assert(number >= 0 && !Double.isInfinite(number));

        synchronized(digitList) {
            int maxIntDigits = super.getMaximumIntegerDigits();
            int minIntDigits = super.getMinimumIntegerDigits();
            int maxFraDigits = super.getMaximumFractionDigits();
            int minFraDigits = super.getMinimumFractionDigits();

            digitList.set(isNegative, number, useExponentialNotation ?
                          maxIntDigits + maxFraDigits : maxFraDigits,
                          !useExponentialNotation);
            return subformat(result, delegate, isNegative, false,
                       maxIntDigits, minIntDigits, maxFraDigits, minFraDigits);
        }
    }
    */
// END Android-removed: Use ICU.
@Override
public StringBuffer format(long number, StringBuffer result, FieldPosition fieldPosition) {
    // BEGIN Android-changed: Use ICU.
    /*
        fieldPosition.setBeginIndex(0);
        fieldPosition.setEndIndex(0);

        return format(number, result, fieldPosition.getFieldDelegate());
        */
    FieldPosition icuFieldPosition = getIcuFieldPosition(fieldPosition);
    icuDecimalFormat.format(number, result, icuFieldPosition);
    fieldPosition.setBeginIndex(icuFieldPosition.getBeginIndex());
    fieldPosition.setEndIndex(icuFieldPosition.getEndIndex());
    return result;
// END Android-changed: Use ICU.
}
#end_block

#method_before
// BEGIN Android-removed: private StringBuffer format(long, StringBuffer, FieldDelegate).
/*
    /**
     * Format a long to produce a string.
     * @param number    The long to format
     * @param result    where the text is to be appended
     * @param delegate notified of locations of sub fields
     * @return The formatted number string
     * @exception        ArithmeticException if rounding is needed with rounding
     *                   mode being set to RoundingMode.UNNECESSARY
     * @see java.text.FieldPosition
     *
    private StringBuffer format(long number, StringBuffer result,
                               FieldDelegate delegate) {
        boolean isNegative = (number < 0);
        if (isNegative) {
            number = -number;
        }

        // In general, long values always represent real finite numbers, so
        // we don't have to check for +/- Infinity or NaN.  However, there
        // is one case we have to be careful of:  The multiplier can push
        // a number near MIN_VALUE or MAX_VALUE outside the legal range.  We
        // check for this before multiplying, and if it happens we use
        // BigInteger instead.
        boolean useBigInteger = false;
        if (number < 0) { // This can only happen if number == Long.MIN_VALUE.
            if (multiplier != 0) {
                useBigInteger = true;
            }
        } else if (multiplier != 1 && multiplier != 0) {
            long cutoff = Long.MAX_VALUE / multiplier;
            if (cutoff < 0) {
                cutoff = -cutoff;
            }
            useBigInteger = (number > cutoff);
        }

        if (useBigInteger) {
            if (isNegative) {
                number = -number;
            }
            BigInteger bigIntegerValue = BigInteger.valueOf(number);
            return format(bigIntegerValue, result, delegate, true);
        }

        number *= multiplier;
        if (number == 0) {
            isNegative = false;
        } else {
            if (multiplier < 0) {
                number = -number;
                isNegative = !isNegative;
            }
        }

        synchronized(digitList) {
            int maxIntDigits = super.getMaximumIntegerDigits();
            int minIntDigits = super.getMinimumIntegerDigits();
            int maxFraDigits = super.getMaximumFractionDigits();
            int minFraDigits = super.getMinimumFractionDigits();

            digitList.set(isNegative, number,
                     useExponentialNotation ? maxIntDigits + maxFraDigits : 0);

            return subformat(result, delegate, isNegative, true,
                       maxIntDigits, minIntDigits, maxFraDigits, minFraDigits);
        }
    }
    */
// END Android-removed: private StringBuffer format(long, StringBuffer, FieldDelegate).
private StringBuffer format(BigDecimal number, StringBuffer result, FieldPosition fieldPosition) {
    // BEGIN Android-changed: Use ICU.
    /*
        fieldPosition.setBeginIndex(0);
        fieldPosition.setEndIndex(0);
        return format(number, result, fieldPosition.getFieldDelegate());
        */
    FieldPosition icuFieldPosition = getIcuFieldPosition(fieldPosition);
    icuDecimalFormat.format(number, result, fieldPosition);
    fieldPosition.setBeginIndex(icuFieldPosition.getBeginIndex());
    fieldPosition.setEndIndex(icuFieldPosition.getEndIndex());
    return result;
// END Android-changed: Use ICU.
}
#method_after
// BEGIN Android-removed: Use ICU.
// Removed unused helper function that was only used from (unused on Android) code
// in format(long, StringBuffer, FieldDelegate).
/*
    /**
     * Format a long to produce a string.
     * @param number    The long to format
     * @param result    where the text is to be appended
     * @param delegate notified of locations of sub fields
     * @return The formatted number string
     * @exception        ArithmeticException if rounding is needed with rounding
     *                   mode being set to RoundingMode.UNNECESSARY
     * @see java.text.FieldPosition
     *
    private StringBuffer format(long number, StringBuffer result,
                               FieldDelegate delegate) {
        boolean isNegative = (number < 0);
        if (isNegative) {
            number = -number;
        }

        // In general, long values always represent real finite numbers, so
        // we don't have to check for +/- Infinity or NaN.  However, there
        // is one case we have to be careful of:  The multiplier can push
        // a number near MIN_VALUE or MAX_VALUE outside the legal range.  We
        // check for this before multiplying, and if it happens we use
        // BigInteger instead.
        boolean useBigInteger = false;
        if (number < 0) { // This can only happen if number == Long.MIN_VALUE.
            if (multiplier != 0) {
                useBigInteger = true;
            }
        } else if (multiplier != 1 && multiplier != 0) {
            long cutoff = Long.MAX_VALUE / multiplier;
            if (cutoff < 0) {
                cutoff = -cutoff;
            }
            useBigInteger = (number > cutoff);
        }

        if (useBigInteger) {
            if (isNegative) {
                number = -number;
            }
            BigInteger bigIntegerValue = BigInteger.valueOf(number);
            return format(bigIntegerValue, result, delegate, true);
        }

        number *= multiplier;
        if (number == 0) {
            isNegative = false;
        } else {
            if (multiplier < 0) {
                number = -number;
                isNegative = !isNegative;
            }
        }

        synchronized(digitList) {
            int maxIntDigits = super.getMaximumIntegerDigits();
            int minIntDigits = super.getMinimumIntegerDigits();
            int maxFraDigits = super.getMaximumFractionDigits();
            int minFraDigits = super.getMinimumFractionDigits();

            digitList.set(isNegative, number,
                     useExponentialNotation ? maxIntDigits + maxFraDigits : 0);

            return subformat(result, delegate, isNegative, true,
                       maxIntDigits, minIntDigits, maxFraDigits, minFraDigits);
        }
    }
    */
// END Android-removed: Use ICU.
private StringBuffer format(BigDecimal number, StringBuffer result, FieldPosition fieldPosition) {
    // BEGIN Android-changed: Use ICU.
    /*
        fieldPosition.setBeginIndex(0);
        fieldPosition.setEndIndex(0);
        return format(number, result, fieldPosition.getFieldDelegate());
        */
    FieldPosition icuFieldPosition = getIcuFieldPosition(fieldPosition);
    icuDecimalFormat.format(number, result, fieldPosition);
    fieldPosition.setBeginIndex(icuFieldPosition.getBeginIndex());
    fieldPosition.setEndIndex(icuFieldPosition.getEndIndex());
    return result;
// END Android-changed: Use ICU.
}
#end_block

#method_before
// BEGIN Android-removed: private StringBuffer format(BigDecimal, StringBuffer, FieldDelegate).
/*
    /**
     * Formats a BigDecimal to produce a string.
     * @param number    The BigDecimal to format
     * @param result    where the text is to be appended
     * @param delegate notified of locations of sub fields
     * @exception        ArithmeticException if rounding is needed with rounding
     *                   mode being set to RoundingMode.UNNECESSARY
     * @return The formatted number string
     *
    private StringBuffer format(BigDecimal number, StringBuffer result,
                                FieldDelegate delegate) {
        if (multiplier != 1) {
            number = number.multiply(getBigDecimalMultiplier());
        }
        boolean isNegative = number.signum() == -1;
        if (isNegative) {
            number = number.negate();
        }

        synchronized(digitList) {
            int maxIntDigits = getMaximumIntegerDigits();
            int minIntDigits = getMinimumIntegerDigits();
            int maxFraDigits = getMaximumFractionDigits();
            int minFraDigits = getMinimumFractionDigits();
            int maximumDigits = maxIntDigits + maxFraDigits;

            digitList.set(isNegative, number, useExponentialNotation ?
                ((maximumDigits < 0) ? Integer.MAX_VALUE : maximumDigits) :
                maxFraDigits, !useExponentialNotation);

            return subformat(result, delegate, isNegative, false,
                maxIntDigits, minIntDigits, maxFraDigits, minFraDigits);
        }
    }
    */
// END Android-removed: private StringBuffer format(BigDecimal, StringBuffer, FieldDelegate).
private StringBuffer format(BigInteger number, StringBuffer result, FieldPosition fieldPosition) {
    // BEGIN Android-changed: Use ICU.
    /*
        fieldPosition.setBeginIndex(0);
        fieldPosition.setEndIndex(0);

        return format(number, result, fieldPosition.getFieldDelegate(), false);
        */
    FieldPosition icuFieldPosition = getIcuFieldPosition(fieldPosition);
    icuDecimalFormat.format(number, result, fieldPosition);
    fieldPosition.setBeginIndex(icuFieldPosition.getBeginIndex());
    fieldPosition.setEndIndex(icuFieldPosition.getEndIndex());
    return result;
// END Android-changed: Use ICU.
}
#method_after
// BEGIN Android-removed: Use ICU.
// Removed unused helper function that was only used from (unused on Android) code
// in format(BigDecimal, StringBuffer, FieldDelegate).
/*
    /**
     * Formats a BigDecimal to produce a string.
     * @param number    The BigDecimal to format
     * @param result    where the text is to be appended
     * @param delegate notified of locations of sub fields
     * @exception        ArithmeticException if rounding is needed with rounding
     *                   mode being set to RoundingMode.UNNECESSARY
     * @return The formatted number string
     *
    private StringBuffer format(BigDecimal number, StringBuffer result,
                                FieldDelegate delegate) {
        if (multiplier != 1) {
            number = number.multiply(getBigDecimalMultiplier());
        }
        boolean isNegative = number.signum() == -1;
        if (isNegative) {
            number = number.negate();
        }

        synchronized(digitList) {
            int maxIntDigits = getMaximumIntegerDigits();
            int minIntDigits = getMinimumIntegerDigits();
            int maxFraDigits = getMaximumFractionDigits();
            int minFraDigits = getMinimumFractionDigits();
            int maximumDigits = maxIntDigits + maxFraDigits;

            digitList.set(isNegative, number, useExponentialNotation ?
                ((maximumDigits < 0) ? Integer.MAX_VALUE : maximumDigits) :
                maxFraDigits, !useExponentialNotation);

            return subformat(result, delegate, isNegative, false,
                maxIntDigits, minIntDigits, maxFraDigits, minFraDigits);
        }
    }
    */
// END Android-removed: Use ICU.
private StringBuffer format(BigInteger number, StringBuffer result, FieldPosition fieldPosition) {
    // BEGIN Android-changed: Use ICU.
    /*
        fieldPosition.setBeginIndex(0);
        fieldPosition.setEndIndex(0);

        return format(number, result, fieldPosition.getFieldDelegate(), false);
        */
    FieldPosition icuFieldPosition = getIcuFieldPosition(fieldPosition);
    icuDecimalFormat.format(number, result, fieldPosition);
    fieldPosition.setBeginIndex(icuFieldPosition.getBeginIndex());
    fieldPosition.setEndIndex(icuFieldPosition.getEndIndex());
    return result;
// END Android-changed: Use ICU.
}
#end_block

#method_before
// BEGIN Android-removed: private StringBuffer format(BigInteger, StringBuffer, FieldDelegate).
/*
    /**
     * Format a BigInteger to produce a string.
     * @param number    The BigInteger to format
     * @param result    where the text is to be appended
     * @param delegate notified of locations of sub fields
     * @return The formatted number string
     * @exception        ArithmeticException if rounding is needed with rounding
     *                   mode being set to RoundingMode.UNNECESSARY
     * @see java.text.FieldPosition
     *
    private StringBuffer format(BigInteger number, StringBuffer result,
                               FieldDelegate delegate, boolean formatLong) {
        if (multiplier != 1) {
            number = number.multiply(getBigIntegerMultiplier());
        }
        boolean isNegative = number.signum() == -1;
        if (isNegative) {
            number = number.negate();
        }

        synchronized(digitList) {
            int maxIntDigits, minIntDigits, maxFraDigits, minFraDigits, maximumDigits;
            if (formatLong) {
                maxIntDigits = super.getMaximumIntegerDigits();
                minIntDigits = super.getMinimumIntegerDigits();
                maxFraDigits = super.getMaximumFractionDigits();
                minFraDigits = super.getMinimumFractionDigits();
                maximumDigits = maxIntDigits + maxFraDigits;
            } else {
                maxIntDigits = getMaximumIntegerDigits();
                minIntDigits = getMinimumIntegerDigits();
                maxFraDigits = getMaximumFractionDigits();
                minFraDigits = getMinimumFractionDigits();
                maximumDigits = maxIntDigits + maxFraDigits;
                if (maximumDigits < 0) {
                    maximumDigits = Integer.MAX_VALUE;
                }
            }

            digitList.set(isNegative, number,
                          useExponentialNotation ? maximumDigits : 0);

            return subformat(result, delegate, isNegative, true,
                maxIntDigits, minIntDigits, maxFraDigits, minFraDigits);
        }
    }
    */
// END Android-removed: private StringBuffer format(BigInteger, StringBuffer, FieldDelegate).
@Override
public AttributedCharacterIterator formatToCharacterIterator(Object obj) {
    /*
        CharacterIteratorFieldDelegate delegate =
                         new CharacterIteratorFieldDelegate();
        StringBuffer sb = new StringBuffer();

        if (obj instanceof Double || obj instanceof Float) {
            format(((Number)obj).doubleValue(), sb, delegate);
        } else if (obj instanceof Long || obj instanceof Integer ||
                   obj instanceof Short || obj instanceof Byte ||
                   obj instanceof AtomicInteger || obj instanceof AtomicLong) {
            format(((Number)obj).longValue(), sb, delegate);
        } else if (obj instanceof BigDecimal) {
            format((BigDecimal)obj, sb, delegate);
        } else if (obj instanceof BigInteger) {
            format((BigInteger)obj, sb, delegate, false);
        } else if (obj == null) {
            throw new NullPointerException(
                "formatToCharacterIterator must be passed non-null object");
        } else {
            throw new IllegalArgumentException(
                "Cannot format given Object as a Number");
        }
        return delegate.getIterator(sb.toString());
        */
    if (obj == null) {
        throw new NullPointerException("object == null");
    }
    // Note: formatToCharacterIterator cannot be used directly because it returns attributes
    // in terms of its own class: icu.text.NumberFormat instead of java.text.NumberFormat.
    // http://bugs.icu-project.org/trac/ticket/11931 Proposes to use the NumberFormat constants.
    AttributedCharacterIterator original = icuDecimalFormat.formatToCharacterIterator(obj);
    // Extract the text out of the ICU iterator.
    StringBuilder textBuilder = new StringBuilder(original.getEndIndex() - original.getBeginIndex());
    for (int i = original.getBeginIndex(); i < original.getEndIndex(); i++) {
        textBuilder.append(original.current());
        original.next();
    }
    AttributedString result = new AttributedString(textBuilder.toString());
    for (int i = original.getBeginIndex(); i < original.getEndIndex(); i++) {
        original.setIndex(i);
        for (AttributedCharacterIterator.Attribute attribute : original.getAttributes().keySet()) {
            int start = original.getRunStart();
            int end = original.getRunLimit();
            Field javaAttr = toJavaFieldAttribute(attribute);
            result.addAttribute(javaAttr, javaAttr, start, end);
        }
    }
    return result.getIterator();
// END Android-changed: Use ICU.
}
#method_after
// BEGIN Android-removed: Use ICU.
// Removed unused helper function that was only used from (unused on Android) code
// in format(BigInteger, StringBuffer, FieldDelegate).
/*
    /**
     * Format a BigInteger to produce a string.
     * @param number    The BigInteger to format
     * @param result    where the text is to be appended
     * @param delegate notified of locations of sub fields
     * @return The formatted number string
     * @exception        ArithmeticException if rounding is needed with rounding
     *                   mode being set to RoundingMode.UNNECESSARY
     * @see java.text.FieldPosition
     *
    private StringBuffer format(BigInteger number, StringBuffer result,
                               FieldDelegate delegate, boolean formatLong) {
        if (multiplier != 1) {
            number = number.multiply(getBigIntegerMultiplier());
        }
        boolean isNegative = number.signum() == -1;
        if (isNegative) {
            number = number.negate();
        }

        synchronized(digitList) {
            int maxIntDigits, minIntDigits, maxFraDigits, minFraDigits, maximumDigits;
            if (formatLong) {
                maxIntDigits = super.getMaximumIntegerDigits();
                minIntDigits = super.getMinimumIntegerDigits();
                maxFraDigits = super.getMaximumFractionDigits();
                minFraDigits = super.getMinimumFractionDigits();
                maximumDigits = maxIntDigits + maxFraDigits;
            } else {
                maxIntDigits = getMaximumIntegerDigits();
                minIntDigits = getMinimumIntegerDigits();
                maxFraDigits = getMaximumFractionDigits();
                minFraDigits = getMinimumFractionDigits();
                maximumDigits = maxIntDigits + maxFraDigits;
                if (maximumDigits < 0) {
                    maximumDigits = Integer.MAX_VALUE;
                }
            }

            digitList.set(isNegative, number,
                          useExponentialNotation ? maximumDigits : 0);

            return subformat(result, delegate, isNegative, true,
                maxIntDigits, minIntDigits, maxFraDigits, minFraDigits);
        }
    }
    */
// END Android-removed: Use ICU.
@Override
public AttributedCharacterIterator formatToCharacterIterator(Object obj) {
    /*
        CharacterIteratorFieldDelegate delegate =
                         new CharacterIteratorFieldDelegate();
        StringBuffer sb = new StringBuffer();

        if (obj instanceof Double || obj instanceof Float) {
            format(((Number)obj).doubleValue(), sb, delegate);
        } else if (obj instanceof Long || obj instanceof Integer ||
                   obj instanceof Short || obj instanceof Byte ||
                   obj instanceof AtomicInteger || obj instanceof AtomicLong) {
            format(((Number)obj).longValue(), sb, delegate);
        } else if (obj instanceof BigDecimal) {
            format((BigDecimal)obj, sb, delegate);
        } else if (obj instanceof BigInteger) {
            format((BigInteger)obj, sb, delegate, false);
        } else if (obj == null) {
            throw new NullPointerException(
                "formatToCharacterIterator must be passed non-null object");
        } else {
            throw new IllegalArgumentException(
                "Cannot format given Object as a Number");
        }
        return delegate.getIterator(sb.toString());
        */
    if (obj == null) {
        throw new NullPointerException("object == null");
    }
    // Note: formatToCharacterIterator cannot be used directly because it returns attributes
    // in terms of its own class: icu.text.NumberFormat instead of java.text.NumberFormat.
    // http://bugs.icu-project.org/trac/ticket/11931 Proposes to use the NumberFormat constants.
    AttributedCharacterIterator original = icuDecimalFormat.formatToCharacterIterator(obj);
    // Extract the text out of the ICU iterator.
    StringBuilder textBuilder = new StringBuilder(original.getEndIndex() - original.getBeginIndex());
    for (int i = original.getBeginIndex(); i < original.getEndIndex(); i++) {
        textBuilder.append(original.current());
        original.next();
    }
    AttributedString result = new AttributedString(textBuilder.toString());
    for (int i = original.getBeginIndex(); i < original.getEndIndex(); i++) {
        original.setIndex(i);
        for (AttributedCharacterIterator.Attribute attribute : original.getAttributes().keySet()) {
            int start = original.getRunStart();
            int end = original.getRunLimit();
            Field javaAttr = toJavaFieldAttribute(attribute);
            result.addAttribute(javaAttr, javaAttr, start, end);
        }
    }
    return result.getIterator();
// END Android-changed: Use ICU.
}
#end_block

#method_before
// BEGIN Android-removed: "fast-path formatting logic for double", subformat(), append().
// ==== Begin fast-path formating logic for double =========================
@Override
public Number parse(String text, ParsePosition pos) {
    /*
        // special case NaN
        if (text.regionMatches(pos.index, symbols.getNaN(), 0, symbols.getNaN().length())) {
            pos.index = pos.index + symbols.getNaN().length();
            return new Double(Double.NaN);
        }

        boolean[] status = new boolean[STATUS_LENGTH];
        if (!subparse(text, pos, positivePrefix, negativePrefix, digitList, false, status)) {
            return null;
        }

        // special case INFINITY
        if (status[STATUS_INFINITE]) {
            if (status[STATUS_POSITIVE] == (multiplier >= 0)) {
                return new Double(Double.POSITIVE_INFINITY);
            } else {
                return new Double(Double.NEGATIVE_INFINITY);
            }
        }

        if (multiplier == 0) {
            if (digitList.isZero()) {
                return new Double(Double.NaN);
            } else if (status[STATUS_POSITIVE]) {
                return new Double(Double.POSITIVE_INFINITY);
            } else {
                return new Double(Double.NEGATIVE_INFINITY);
            }
        }

        if (isParseBigDecimal()) {
            BigDecimal bigDecimalResult = digitList.getBigDecimal();

            if (multiplier != 1) {
                try {
                    bigDecimalResult = bigDecimalResult.divide(getBigDecimalMultiplier());
                }
                catch (ArithmeticException e) {  // non-terminating decimal expansion
                    bigDecimalResult = bigDecimalResult.divide(getBigDecimalMultiplier(), roundingMode);
                }
            }

            if (!status[STATUS_POSITIVE]) {
                bigDecimalResult = bigDecimalResult.negate();
            }
            return bigDecimalResult;
        } else {
            boolean gotDouble = true;
            boolean gotLongMinimum = false;
            double  doubleResult = 0.0;
            long    longResult = 0;

            // Finally, have DigitList parse the digits into a value.
            if (digitList.fitsIntoLong(status[STATUS_POSITIVE], isParseIntegerOnly())) {
                gotDouble = false;
                longResult = digitList.getLong();
                if (longResult < 0) {  // got Long.MIN_VALUE
                    gotLongMinimum = true;
                }
            } else {
                doubleResult = digitList.getDouble();
            }

            // Divide by multiplier. We have to be careful here not to do
            // unneeded conversions between double and long.
            if (multiplier != 1) {
                if (gotDouble) {
                    doubleResult /= multiplier;
                } else {
                    // Avoid converting to double if we can
                    if (longResult % multiplier == 0) {
                        longResult /= multiplier;
                    } else {
                        doubleResult = ((double)longResult) / multiplier;
                        gotDouble = true;
                    }
                }
            }

            if (!status[STATUS_POSITIVE] && !gotLongMinimum) {
                doubleResult = -doubleResult;
                longResult = -longResult;
            }

            // At this point, if we divided the result by the multiplier, the
            // result may fit into a long.  We check for this case and return
            // a long if possible.
            // We must do this AFTER applying the negative (if appropriate)
            // in order to handle the case of LONG_MIN; otherwise, if we do
            // this with a positive value -LONG_MIN, the double is > 0, but
            // the long is < 0. We also must retain a double in the case of
            // -0.0, which will compare as == to a long 0 cast to a double
            // (bug 4162852).
            if (multiplier != 1 && gotDouble) {
                longResult = (long)doubleResult;
                gotDouble = ((doubleResult != (double)longResult) ||
                            (doubleResult == 0.0 && 1/doubleResult < 0.0)) &&
                            !isParseIntegerOnly();
            }

            return gotDouble ?
                (Number)new Double(doubleResult) : (Number)new Long(longResult);
        }
        */
    if (pos.index < 0 || pos.index >= text.length()) {
        return null;
    }
    // This might return android.icu.math.BigDecimal, java.math.BigInteger or a primitive type.
    Number number = icuDecimalFormat.parse(text, pos);
    if (number == null) {
        return null;
    }
    if (isParseBigDecimal()) {
        if (number instanceof Long) {
            return new BigDecimal(number.longValue());
        }
        if ((number instanceof Double) && !((Double) number).isInfinite() && !((Double) number).isNaN()) {
            return new BigDecimal(number.toString());
        }
        if ((number instanceof Double) && (((Double) number).isNaN() || ((Double) number).isInfinite())) {
            return number;
        }
        if (number instanceof android.icu.math.BigDecimal) {
            return ((android.icu.math.BigDecimal) number).toBigDecimal();
        }
    }
    if ((number instanceof android.icu.math.BigDecimal) || (number instanceof BigInteger)) {
        return number.doubleValue();
    }
    if (isParseIntegerOnly() && number.equals(new Double(-0.0))) {
        return 0L;
    }
    return number;
// END Android-changed: Use ICU.
}
#method_after
// BEGIN Android-removed: "fast-path formatting logic for double", subformat(), append().
/*
    // ==== Begin fast-path formating logic for double =========================

    /* Fast-path formatting will be used for format(double ...) methods iff a
     * number of conditions are met (see checkAndSetFastPathStatus()):
     * - Only if instance properties meet the right predefined conditions.
     * - The abs value of the double to format is <= Integer.MAX_VALUE.
     *
     * The basic approach is to split the binary to decimal conversion of a
     * double value into two phases:
     * * The conversion of the integer portion of the double.
     * * The conversion of the fractional portion of the double
     *   (limited to two or three digits).
     *
     * The isolation and conversion of the integer portion of the double is
     * straightforward. The conversion of the fraction is more subtle and relies
     * on some rounding properties of double to the decimal precisions in
     * question.  Using the terminology of BigDecimal, this fast-path algorithm
     * is applied when a double value has a magnitude less than Integer.MAX_VALUE
     * and rounding is to nearest even and the destination format has two or
     * three digits of *scale* (digits after the decimal point).
     *
     * Under a rounding to nearest even policy, the returned result is a digit
     * string of a number in the (in this case decimal) destination format
     * closest to the exact numerical value of the (in this case binary) input
     * value.  If two destination format numbers are equally distant, the one
     * with the last digit even is returned.  To compute such a correctly rounded
     * value, some information about digits beyond the smallest returned digit
     * position needs to be consulted.
     *
     * In general, a guard digit, a round digit, and a sticky *bit* are needed
     * beyond the returned digit position.  If the discarded portion of the input
     * is sufficiently large, the returned digit string is incremented.  In round
     * to nearest even, this threshold to increment occurs near the half-way
     * point between digits.  The sticky bit records if there are any remaining
     * trailing digits of the exact input value in the new format; the sticky bit
     * is consulted only in close to half-way rounding cases.
     *
     * Given the computation of the digit and bit values, rounding is then
     * reduced to a table lookup problem.  For decimal, the even/odd cases look
     * like this:
     *
     * Last   Round   Sticky
     * 6      5       0      => 6   // exactly halfway, return even digit.
     * 6      5       1      => 7   // a little bit more than halfway, round up.
     * 7      5       0      => 8   // exactly halfway, round up to even.
     * 7      5       1      => 8   // a little bit more than halfway, round up.
     * With analogous entries for other even and odd last-returned digits.
     *
     * However, decimal negative powers of 5 smaller than 0.5 are *not* exactly
     * representable as binary fraction.  In particular, 0.005 (the round limit
     * for a two-digit scale) and 0.0005 (the round limit for a three-digit
     * scale) are not representable. Therefore, for input values near these cases
     * the sticky bit is known to be set which reduces the rounding logic to:
     *
     * Last   Round   Sticky
     * 6      5       1      => 7   // a little bit more than halfway, round up.
     * 7      5       1      => 8   // a little bit more than halfway, round up.
     *
     * In other words, if the round digit is 5, the sticky bit is known to be
     * set.  If the round digit is something other than 5, the sticky bit is not
     * relevant.  Therefore, some of the logic about whether or not to increment
     * the destination *decimal* value can occur based on tests of *binary*
     * computations of the binary input number.
     *

    /**
     * Check validity of using fast-path for this instance. If fast-path is valid
     * for this instance, sets fast-path state as true and initializes fast-path
     * utility fields as needed.
     *
     * This method is supposed to be called rarely, otherwise that will break the
     * fast-path performance. That means avoiding frequent changes of the
     * properties of the instance, since for most properties, each time a change
     * happens, a call to this method is needed at the next format call.
     *
     * FAST-PATH RULES:
     *  Similar to the default DecimalFormat instantiation case.
     *  More precisely:
     *  - HALF_EVEN rounding mode,
     *  - isGroupingUsed() is true,
     *  - groupingSize of 3,
     *  - multiplier is 1,
     *  - Decimal separator not mandatory,
     *  - No use of exponential notation,
     *  - minimumIntegerDigits is exactly 1 and maximumIntegerDigits at least 10
     *  - For number of fractional digits, the exact values found in the default case:
     *     Currency : min = max = 2.
     *     Decimal  : min = 0. max = 3.
     *
     *
    private void checkAndSetFastPathStatus() {

        boolean fastPathWasOn = isFastPath;

        if ((roundingMode == RoundingMode.HALF_EVEN) &&
            (isGroupingUsed()) &&
            (groupingSize == 3) &&
            (multiplier == 1) &&
            (!decimalSeparatorAlwaysShown) &&
            (!useExponentialNotation)) {

            // The fast-path algorithm is semi-hardcoded against
            //  minimumIntegerDigits and maximumIntegerDigits.
            isFastPath = ((minimumIntegerDigits == 1) &&
                          (maximumIntegerDigits >= 10));

            // The fast-path algorithm is hardcoded against
            //  minimumFractionDigits and maximumFractionDigits.
            if (isFastPath) {
                if (isCurrencyFormat) {
                    if ((minimumFractionDigits != 2) ||
                        (maximumFractionDigits != 2))
                        isFastPath = false;
                } else if ((minimumFractionDigits != 0) ||
                           (maximumFractionDigits != 3))
                    isFastPath = false;
            }
        } else
            isFastPath = false;

        // Since some instance properties may have changed while still falling
        // in the fast-path case, we need to reinitialize fastPathData anyway.
        if (isFastPath) {
            // We need to instantiate fastPathData if not already done.
            if (fastPathData == null)
                fastPathData = new FastPathData();

            // Sets up the locale specific constants used when formatting.
            // '0' is our default representation of zero.
            fastPathData.zeroDelta = symbols.getZeroDigit() - '0';
            fastPathData.groupingChar = symbols.getGroupingSeparator();

            // Sets up fractional constants related to currency/decimal pattern.
            fastPathData.fractionalMaxIntBound = (isCurrencyFormat) ? 99 : 999;
            fastPathData.fractionalScaleFactor = (isCurrencyFormat) ? 100.0d : 1000.0d;

            // Records the need for adding prefix or suffix
            fastPathData.positiveAffixesRequired =
                (positivePrefix.length() != 0) || (positiveSuffix.length() != 0);
            fastPathData.negativeAffixesRequired =
                (negativePrefix.length() != 0) || (negativeSuffix.length() != 0);

            // Creates a cached char container for result, with max possible size.
            int maxNbIntegralDigits = 10;
            int maxNbGroups = 3;
            int containerSize =
                Math.max(positivePrefix.length(), negativePrefix.length()) +
                maxNbIntegralDigits + maxNbGroups + 1 + maximumFractionDigits +
                Math.max(positiveSuffix.length(), negativeSuffix.length());

            fastPathData.fastPathContainer = new char[containerSize];

            // Sets up prefix and suffix char arrays constants.
            fastPathData.charsPositiveSuffix = positiveSuffix.toCharArray();
            fastPathData.charsNegativeSuffix = negativeSuffix.toCharArray();
            fastPathData.charsPositivePrefix = positivePrefix.toCharArray();
            fastPathData.charsNegativePrefix = negativePrefix.toCharArray();

            // Sets up fixed index positions for integral and fractional digits.
            // Sets up decimal point in cached result container.
            int longestPrefixLength =
                Math.max(positivePrefix.length(), negativePrefix.length());
            int decimalPointIndex =
                maxNbIntegralDigits + maxNbGroups + longestPrefixLength;

            fastPathData.integralLastIndex    = decimalPointIndex - 1;
            fastPathData.fractionalFirstIndex = decimalPointIndex + 1;
            fastPathData.fastPathContainer[decimalPointIndex] =
                isCurrencyFormat ?
                symbols.getMonetaryDecimalSeparator() :
                symbols.getDecimalSeparator();

        } else if (fastPathWasOn) {
            // Previous state was fast-path and is no more.
            // Resets cached array constants.
            fastPathData.fastPathContainer = null;
            fastPathData.charsPositiveSuffix = null;
            fastPathData.charsNegativeSuffix = null;
            fastPathData.charsPositivePrefix = null;
            fastPathData.charsNegativePrefix = null;
        }

        fastPathCheckNeeded = false;
    }

    /**
     * Returns true if rounding-up must be done on {@code scaledFractionalPartAsInt},
     * false otherwise.
     *
     * This is a utility method that takes correct half-even rounding decision on
     * passed fractional value at the scaled decimal point (2 digits for currency
     * case and 3 for decimal case), when the approximated fractional part after
     * scaled decimal point is exactly 0.5d.  This is done by means of exact
     * calculations on the {@code fractionalPart} floating-point value.
     *
     * This method is supposed to be called by private {@code fastDoubleFormat}
     * method only.
     *
     * The algorithms used for the exact calculations are :
     *
     * The <b><i>FastTwoSum</i></b> algorithm, from T.J.Dekker, described in the
     * papers  "<i>A  Floating-Point   Technique  for  Extending  the  Available
     * Precision</i>"  by Dekker, and  in "<i>Adaptive  Precision Floating-Point
     * Arithmetic and Fast Robust Geometric Predicates</i>" from J.Shewchuk.
     *
     * A modified version of <b><i>Sum2S</i></b> cascaded summation described in
     * "<i>Accurate Sum and Dot Product</i>" from Takeshi Ogita and All.  As
     * Ogita says in this paper this is an equivalent of the Kahan-Babuska's
     * summation algorithm because we order the terms by magnitude before summing
     * them. For this reason we can use the <i>FastTwoSum</i> algorithm rather
     * than the more expensive Knuth's <i>TwoSum</i>.
     *
     * We do this to avoid a more expensive exact "<i>TwoProduct</i>" algorithm,
     * like those described in Shewchuk's paper above. See comments in the code
     * below.
     *
     * @param  fractionalPart The  fractional value  on which  we  take rounding
     * decision.
     * @param scaledFractionalPartAsInt The integral part of the scaled
     * fractional value.
     *
     * @return the decision that must be taken regarding half-even rounding.
     *
    private boolean exactRoundUp(double fractionalPart,
                                 int scaledFractionalPartAsInt) {

        /* exactRoundUp() method is called by fastDoubleFormat() only.
         * The precondition expected to be verified by the passed parameters is :
         * scaledFractionalPartAsInt ==
         *     (int) (fractionalPart * fastPathData.fractionalScaleFactor).
         * This is ensured by fastDoubleFormat() code.
         *

        /* We first calculate roundoff error made by fastDoubleFormat() on
         * the scaled fractional part. We do this with exact calculation on the
         * passed fractionalPart. Rounding decision will then be taken from roundoff.
         *

        /* ---- TwoProduct(fractionalPart, scale factor (i.e. 1000.0d or 100.0d)).
         *
         * The below is an optimized exact "TwoProduct" calculation of passed
         * fractional part with scale factor, using Ogita's Sum2S cascaded
         * summation adapted as Kahan-Babuska equivalent by using FastTwoSum
         * (much faster) rather than Knuth's TwoSum.
         *
         * We can do this because we order the summation from smallest to
         * greatest, so that FastTwoSum can be used without any additional error.
         *
         * The "TwoProduct" exact calculation needs 17 flops. We replace this by
         * a cascaded summation of FastTwoSum calculations, each involving an
         * exact multiply by a power of 2.
         *
         * Doing so saves overall 4 multiplications and 1 addition compared to
         * using traditional "TwoProduct".
         *
         * The scale factor is either 100 (currency case) or 1000 (decimal case).
         * - when 1000, we replace it by (1024 - 16 - 8) = 1000.
         * - when 100,  we replace it by (128  - 32 + 4) =  100.
         * Every multiplication by a power of 2 (1024, 128, 32, 16, 8, 4) is exact.
         *
         *
        double approxMax;    // Will always be positive.
        double approxMedium; // Will always be negative.
        double approxMin;

        double fastTwoSumApproximation = 0.0d;
        double fastTwoSumRoundOff = 0.0d;
        double bVirtual = 0.0d;

        if (isCurrencyFormat) {
            // Scale is 100 = 128 - 32 + 4.
            // Multiply by 2**n is a shift. No roundoff. No error.
            approxMax    = fractionalPart * 128.00d;
            approxMedium = - (fractionalPart * 32.00d);
            approxMin    = fractionalPart * 4.00d;
        } else {
            // Scale is 1000 = 1024 - 16 - 8.
            // Multiply by 2**n is a shift. No roundoff. No error.
            approxMax    = fractionalPart * 1024.00d;
            approxMedium = - (fractionalPart * 16.00d);
            approxMin    = - (fractionalPart * 8.00d);
        }

        // Shewchuk/Dekker's FastTwoSum(approxMedium, approxMin).
        assert(-approxMedium >= Math.abs(approxMin));
        fastTwoSumApproximation = approxMedium + approxMin;
        bVirtual = fastTwoSumApproximation - approxMedium;
        fastTwoSumRoundOff = approxMin - bVirtual;
        double approxS1 = fastTwoSumApproximation;
        double roundoffS1 = fastTwoSumRoundOff;

        // Shewchuk/Dekker's FastTwoSum(approxMax, approxS1);
        assert(approxMax >= Math.abs(approxS1));
        fastTwoSumApproximation = approxMax + approxS1;
        bVirtual = fastTwoSumApproximation - approxMax;
        fastTwoSumRoundOff = approxS1 - bVirtual;
        double roundoff1000 = fastTwoSumRoundOff;
        double approx1000 = fastTwoSumApproximation;
        double roundoffTotal = roundoffS1 + roundoff1000;

        // Shewchuk/Dekker's FastTwoSum(approx1000, roundoffTotal);
        assert(approx1000 >= Math.abs(roundoffTotal));
        fastTwoSumApproximation = approx1000 + roundoffTotal;
        bVirtual = fastTwoSumApproximation - approx1000;

        // Now we have got the roundoff for the scaled fractional
        double scaledFractionalRoundoff = roundoffTotal - bVirtual;

        // ---- TwoProduct(fractionalPart, scale (i.e. 1000.0d or 100.0d)) end.

        /* ---- Taking the rounding decision
         *
         * We take rounding decision based on roundoff and half-even rounding
         * rule.
         *
         * The above TwoProduct gives us the exact roundoff on the approximated
         * scaled fractional, and we know that this approximation is exactly
         * 0.5d, since that has already been tested by the caller
         * (fastDoubleFormat).
         *
         * Decision comes first from the sign of the calculated exact roundoff.
         * - Since being exact roundoff, it cannot be positive with a scaled
         *   fractional less than 0.5d, as well as negative with a scaled
         *   fractional greater than 0.5d. That leaves us with following 3 cases.
         * - positive, thus scaled fractional == 0.500....0fff ==> round-up.
         * - negative, thus scaled fractional == 0.499....9fff ==> don't round-up.
         * - is zero,  thus scaled fractioanl == 0.5 ==> half-even rounding applies :
         *    we round-up only if the integral part of the scaled fractional is odd.
         *
         *
        if (scaledFractionalRoundoff > 0.0) {
            return true;
        } else if (scaledFractionalRoundoff < 0.0) {
            return false;
        } else if ((scaledFractionalPartAsInt & 1) != 0) {
            return true;
        }

        return false;

        // ---- Taking the rounding decision end
    }

    /**
     * Collects integral digits from passed {@code number}, while setting
     * grouping chars as needed. Updates {@code firstUsedIndex} accordingly.
     *
     * Loops downward starting from {@code backwardIndex} position (inclusive).
     *
     * @param number  The int value from which we collect digits.
     * @param digitsBuffer The char array container where digits and grouping chars
     *  are stored.
     * @param backwardIndex the position from which we start storing digits in
     *  digitsBuffer.
     *
     *
    private void collectIntegralDigits(int number,
                                       char[] digitsBuffer,
                                       int backwardIndex) {
        int index = backwardIndex;
        int q;
        int r;
        while (number > 999) {
            // Generates 3 digits per iteration.
            q = number / 1000;
            r = number - (q << 10) + (q << 4) + (q << 3); // -1024 +16 +8 = 1000.
            number = q;

            digitsBuffer[index--] = DigitArrays.DigitOnes1000[r];
            digitsBuffer[index--] = DigitArrays.DigitTens1000[r];
            digitsBuffer[index--] = DigitArrays.DigitHundreds1000[r];
            digitsBuffer[index--] = fastPathData.groupingChar;
        }

        // Collects last 3 or less digits.
        digitsBuffer[index] = DigitArrays.DigitOnes1000[number];
        if (number > 9) {
            digitsBuffer[--index]  = DigitArrays.DigitTens1000[number];
            if (number > 99)
                digitsBuffer[--index]   = DigitArrays.DigitHundreds1000[number];
        }

        fastPathData.firstUsedIndex = index;
    }

    /**
     * Collects the 2 (currency) or 3 (decimal) fractional digits from passed
     * {@code number}, starting at {@code startIndex} position
     * inclusive.  There is no punctuation to set here (no grouping chars).
     * Updates {@code fastPathData.lastFreeIndex} accordingly.
     *
     *
     * @param number  The int value from which we collect digits.
     * @param digitsBuffer The char array container where digits are stored.
     * @param startIndex the position from which we start storing digits in
     *  digitsBuffer.
     *
     *
    private void collectFractionalDigits(int number,
                                         char[] digitsBuffer,
                                         int startIndex) {
        int index = startIndex;

        char digitOnes = DigitArrays.DigitOnes1000[number];
        char digitTens = DigitArrays.DigitTens1000[number];

        if (isCurrencyFormat) {
            // Currency case. Always collects fractional digits.
            digitsBuffer[index++] = digitTens;
            digitsBuffer[index++] = digitOnes;
        } else if (number != 0) {
            // Decimal case. Hundreds will always be collected
            digitsBuffer[index++] = DigitArrays.DigitHundreds1000[number];

            // Ending zeros won't be collected.
            if (digitOnes != '0') {
                digitsBuffer[index++] = digitTens;
                digitsBuffer[index++] = digitOnes;
            } else if (digitTens != '0')
                digitsBuffer[index++] = digitTens;

        } else
            // This is decimal pattern and fractional part is zero.
            // We must remove decimal point from result.
            index--;

        fastPathData.lastFreeIndex = index;
    }

    /**
     * Internal utility.
     * Adds the passed {@code prefix} and {@code suffix} to {@code container}.
     *
     * @param container  Char array container which to prepend/append the
     *  prefix/suffix.
     * @param prefix     Char sequence to prepend as a prefix.
     * @param suffix     Char sequence to append as a suffix.
     *
     *
    //    private void addAffixes(boolean isNegative, char[] container) {
    private void addAffixes(char[] container, char[] prefix, char[] suffix) {

        // We add affixes only if needed (affix length > 0).
        int pl = prefix.length;
        int sl = suffix.length;
        if (pl != 0) prependPrefix(prefix, pl, container);
        if (sl != 0) appendSuffix(suffix, sl, container);

    }

    /**
     * Prepends the passed {@code prefix} chars to given result
     * {@code container}.  Updates {@code fastPathData.firstUsedIndex}
     * accordingly.
     *
     * @param prefix The prefix characters to prepend to result.
     * @param len The number of chars to prepend.
     * @param container Char array container which to prepend the prefix
     *
    private void prependPrefix(char[] prefix,
                               int len,
                               char[] container) {

        fastPathData.firstUsedIndex -= len;
        int startIndex = fastPathData.firstUsedIndex;

        // If prefix to prepend is only 1 char long, just assigns this char.
        // If prefix is less or equal 4, we use a dedicated algorithm that
        //  has shown to run faster than System.arraycopy.
        // If more than 4, we use System.arraycopy.
        if (len == 1)
            container[startIndex] = prefix[0];
        else if (len <= 4) {
            int dstLower = startIndex;
            int dstUpper = dstLower + len - 1;
            int srcUpper = len - 1;
            container[dstLower] = prefix[0];
            container[dstUpper] = prefix[srcUpper];

            if (len > 2)
                container[++dstLower] = prefix[1];
            if (len == 4)
                container[--dstUpper] = prefix[2];
        } else
            System.arraycopy(prefix, 0, container, startIndex, len);
    }

    /**
     * Appends the passed {@code suffix} chars to given result
     * {@code container}.  Updates {@code fastPathData.lastFreeIndex}
     * accordingly.
     *
     * @param suffix The suffix characters to append to result.
     * @param len The number of chars to append.
     * @param container Char array container which to append the suffix
     *
    private void appendSuffix(char[] suffix,
                              int len,
                              char[] container) {

        int startIndex = fastPathData.lastFreeIndex;

        // If suffix to append is only 1 char long, just assigns this char.
        // If suffix is less or equal 4, we use a dedicated algorithm that
        //  has shown to run faster than System.arraycopy.
        // If more than 4, we use System.arraycopy.
        if (len == 1)
            container[startIndex] = suffix[0];
        else if (len <= 4) {
            int dstLower = startIndex;
            int dstUpper = dstLower + len - 1;
            int srcUpper = len - 1;
            container[dstLower] = suffix[0];
            container[dstUpper] = suffix[srcUpper];

            if (len > 2)
                container[++dstLower] = suffix[1];
            if (len == 4)
                container[--dstUpper] = suffix[2];
        } else
            System.arraycopy(suffix, 0, container, startIndex, len);

        fastPathData.lastFreeIndex += len;
    }

    /**
     * Converts digit chars from {@code digitsBuffer} to current locale.
     *
     * Must be called before adding affixes since we refer to
     * {@code fastPathData.firstUsedIndex} and {@code fastPathData.lastFreeIndex},
     * and do not support affixes (for speed reason).
     *
     * We loop backward starting from last used index in {@code fastPathData}.
     *
     * @param digitsBuffer The char array container where the digits are stored.
     *
    private void localizeDigits(char[] digitsBuffer) {

        // We will localize only the digits, using the groupingSize,
        // and taking into account fractional part.

        // First take into account fractional part.
        int digitsCounter =
            fastPathData.lastFreeIndex - fastPathData.fractionalFirstIndex;

        // The case when there is no fractional digits.
        if (digitsCounter < 0)
            digitsCounter = groupingSize;

        // Only the digits remains to localize.
        for (int cursor = fastPathData.lastFreeIndex - 1;
             cursor >= fastPathData.firstUsedIndex;
             cursor--) {
            if (digitsCounter != 0) {
                // This is a digit char, we must localize it.
                digitsBuffer[cursor] += fastPathData.zeroDelta;
                digitsCounter--;
            } else {
                // Decimal separator or grouping char. Reinit counter only.
                digitsCounter = groupingSize;
            }
        }
    }

    /**
     * This is the main entry point for the fast-path format algorithm.
     *
     * At this point we are sure to be in the expected conditions to run it.
     * This algorithm builds the formatted result and puts it in the dedicated
     * {@code fastPathData.fastPathContainer}.
     *
     * @param d the double value to be formatted.
     * @param negative Flag precising if {@code d} is negative.
     *
    private void fastDoubleFormat(double d,
                                  boolean negative) {

        char[] container = fastPathData.fastPathContainer;

        /*
         * The principle of the algorithm is to :
         * - Break the passed double into its integral and fractional parts
         *    converted into integers.
         * - Then decide if rounding up must be applied or not by following
         *    the half-even rounding rule, first using approximated scaled
         *    fractional part.
         * - For the difficult cases (approximated scaled fractional part
         *    being exactly 0.5d), we refine the rounding decision by calling
         *    exactRoundUp utility method that both calculates the exact roundoff
         *    on the approximation and takes correct rounding decision.
         * - We round-up the fractional part if needed, possibly propagating the
         *    rounding to integral part if we meet a "all-nine" case for the
         *    scaled fractional part.
         * - We then collect digits from the resulting integral and fractional
         *   parts, also setting the required grouping chars on the fly.
         * - Then we localize the collected digits if needed, and
         * - Finally prepend/append prefix/suffix if any is needed.
         *

        // Exact integral part of d.
        int integralPartAsInt = (int) d;

        // Exact fractional part of d (since we subtract it's integral part).
        double exactFractionalPart = d - (double) integralPartAsInt;

        // Approximated scaled fractional part of d (due to multiplication).
        double scaledFractional =
            exactFractionalPart * fastPathData.fractionalScaleFactor;

        // Exact integral part of scaled fractional above.
        int fractionalPartAsInt = (int) scaledFractional;

        // Exact fractional part of scaled fractional above.
        scaledFractional = scaledFractional - (double) fractionalPartAsInt;

        // Only when scaledFractional is exactly 0.5d do we have to do exact
        // calculations and take fine-grained rounding decision, since
        // approximated results above may lead to incorrect decision.
        // Otherwise comparing against 0.5d (strictly greater or less) is ok.
        boolean roundItUp = false;
        if (scaledFractional >= 0.5d) {
            if (scaledFractional == 0.5d)
                // Rounding need fine-grained decision.
                roundItUp = exactRoundUp(exactFractionalPart, fractionalPartAsInt);
            else
                roundItUp = true;

            if (roundItUp) {
                // Rounds up both fractional part (and also integral if needed).
                if (fractionalPartAsInt < fastPathData.fractionalMaxIntBound) {
                    fractionalPartAsInt++;
                } else {
                    // Propagates rounding to integral part since "all nines" case.
                    fractionalPartAsInt = 0;
                    integralPartAsInt++;
                }
            }
        }

        // Collecting digits.
        collectFractionalDigits(fractionalPartAsInt, container,
                                fastPathData.fractionalFirstIndex);
        collectIntegralDigits(integralPartAsInt, container,
                              fastPathData.integralLastIndex);

        // Localizing digits.
        if (fastPathData.zeroDelta != 0)
            localizeDigits(container);

        // Adding prefix and suffix.
        if (negative) {
            if (fastPathData.negativeAffixesRequired)
                addAffixes(container,
                           fastPathData.charsNegativePrefix,
                           fastPathData.charsNegativeSuffix);
        } else if (fastPathData.positiveAffixesRequired)
            addAffixes(container,
                       fastPathData.charsPositivePrefix,
                       fastPathData.charsPositiveSuffix);
    }

    /**
     * A fast-path shortcut of format(double) to be called by NumberFormat, or by
     * format(double, ...) public methods.
     *
     * If instance can be applied fast-path and passed double is not NaN or
     * Infinity, is in the integer range, we call {@code fastDoubleFormat}
     * after changing {@code d} to its positive value if necessary.
     *
     * Otherwise returns null by convention since fast-path can't be exercized.
     *
     * @param d The double value to be formatted
     *
     * @return the formatted result for {@code d} as a string.
     *
    String fastFormat(double d) {
        // (Re-)Evaluates fast-path status if needed.
        if (fastPathCheckNeeded)
            checkAndSetFastPathStatus();

        if (!isFastPath )
            // DecimalFormat instance is not in a fast-path state.
            return null;

        if (!Double.isFinite(d))
            // Should not use fast-path for Infinity and NaN.
            return null;

        // Extracts and records sign of double value, possibly changing it
        // to a positive one, before calling fastDoubleFormat().
        boolean negative = false;
        if (d < 0.0d) {
            negative = true;
            d = -d;
        } else if (d == 0.0d) {
            negative = (Math.copySign(1.0d, d) == -1.0d);
            d = +0.0d;
        }

        if (d > MAX_INT_AS_DOUBLE)
            // Filters out values that are outside expected fast-path range
            return null;
        else
            fastDoubleFormat(d, negative);

        // Returns a new string from updated fastPathContainer.
        return new String(fastPathData.fastPathContainer,
                          fastPathData.firstUsedIndex,
                          fastPathData.lastFreeIndex - fastPathData.firstUsedIndex);

    }

    // ======== End fast-path formating logic for double =========================

    /**
     * Complete the formatting of a finite number.  On entry, the digitList must
     * be filled in with the correct digits.
     *
    private StringBuffer subformat(StringBuffer result, FieldDelegate delegate,
                                   boolean isNegative, boolean isInteger,
                                   int maxIntDigits, int minIntDigits,
                                   int maxFraDigits, int minFraDigits) {
        // NOTE: This isn't required anymore because DigitList takes care of this.
        //
        //  // The negative of the exponent represents the number of leading
        //  // zeros between the decimal and the first non-zero digit, for
        //  // a value < 0.1 (e.g., for 0.00123, -fExponent == 2).  If this
        //  // is more than the maximum fraction digits, then we have an underflow
        //  // for the printed representation.  We recognize this here and set
        //  // the DigitList representation to zero in this situation.
        //
        //  if (-digitList.decimalAt >= getMaximumFractionDigits())
        //  {
        //      digitList.count = 0;
        //  }

        char zero = symbols.getZeroDigit();
        int zeroDelta = zero - '0'; // '0' is the DigitList representation of zero
        char grouping = symbols.getGroupingSeparator();
        char decimal = isCurrencyFormat ?
            symbols.getMonetaryDecimalSeparator() :
            symbols.getDecimalSeparator();

        /* Per bug 4147706, DecimalFormat must respect the sign of numbers which
         * format as zero.  This allows sensible computations and preserves
         * relations such as signum(1/x) = signum(x), where x is +Infinity or
         * -Infinity.  Prior to this fix, we always formatted zero values as if
         * they were positive.  Liu 7/6/98.
         *
        if (digitList.isZero()) {
            digitList.decimalAt = 0; // Normalize
        }

        if (isNegative) {
            append(result, negativePrefix, delegate,
                   getNegativePrefixFieldPositions(), Field.SIGN);
        } else {
            append(result, positivePrefix, delegate,
                   getPositivePrefixFieldPositions(), Field.SIGN);
        }

        if (useExponentialNotation) {
            int iFieldStart = result.length();
            int iFieldEnd = -1;
            int fFieldStart = -1;

            // Minimum integer digits are handled in exponential format by
            // adjusting the exponent.  For example, 0.01234 with 3 minimum
            // integer digits is "123.4E-4".

            // Maximum integer digits are interpreted as indicating the
            // repeating range.  This is useful for engineering notation, in
            // which the exponent is restricted to a multiple of 3.  For
            // example, 0.01234 with 3 maximum integer digits is "12.34e-3".
            // If maximum integer digits are > 1 and are larger than
            // minimum integer digits, then minimum integer digits are
            // ignored.
            int exponent = digitList.decimalAt;
            int repeat = maxIntDigits;
            int minimumIntegerDigits = minIntDigits;
            if (repeat > 1 && repeat > minIntDigits) {
                // A repeating range is defined; adjust to it as follows.
                // If repeat == 3, we have 6,5,4=>3; 3,2,1=>0; 0,-1,-2=>-3;
                // -3,-4,-5=>-6, etc. This takes into account that the
                // exponent we have here is off by one from what we expect;
                // it is for the format 0.MMMMMx10^n.
                if (exponent >= 1) {
                    exponent = ((exponent - 1) / repeat) * repeat;
                } else {
                    // integer division rounds towards 0
                    exponent = ((exponent - repeat) / repeat) * repeat;
                }
                minimumIntegerDigits = 1;
            } else {
                // No repeating range is defined; use minimum integer digits.
                exponent -= minimumIntegerDigits;
            }

            // We now output a minimum number of digits, and more if there
            // are more digits, up to the maximum number of digits.  We
            // place the decimal point after the "integer" digits, which
            // are the first (decimalAt - exponent) digits.
            int minimumDigits = minIntDigits + minFraDigits;
            if (minimumDigits < 0) {    // overflow?
                minimumDigits = Integer.MAX_VALUE;
            }

            // The number of integer digits is handled specially if the number
            // is zero, since then there may be no digits.
            int integerDigits = digitList.isZero() ? minimumIntegerDigits :
                    digitList.decimalAt - exponent;
            if (minimumDigits < integerDigits) {
                minimumDigits = integerDigits;
            }
            int totalDigits = digitList.count;
            if (minimumDigits > totalDigits) {
                totalDigits = minimumDigits;
            }
            boolean addedDecimalSeparator = false;

            for (int i=0; i<totalDigits; ++i) {
                if (i == integerDigits) {
                    // Record field information for caller.
                    iFieldEnd = result.length();

                    result.append(decimal);
                    addedDecimalSeparator = true;

                    // Record field information for caller.
                    fFieldStart = result.length();
                }
                result.append((i < digitList.count) ?
                              (char)(digitList.digits[i] + zeroDelta) :
                              zero);
            }

            if (decimalSeparatorAlwaysShown && totalDigits == integerDigits) {
                // Record field information for caller.
                iFieldEnd = result.length();

                result.append(decimal);
                addedDecimalSeparator = true;

                // Record field information for caller.
                fFieldStart = result.length();
            }

            // Record field information
            if (iFieldEnd == -1) {
                iFieldEnd = result.length();
            }
            delegate.formatted(INTEGER_FIELD, Field.INTEGER, Field.INTEGER,
                               iFieldStart, iFieldEnd, result);
            if (addedDecimalSeparator) {
                delegate.formatted(Field.DECIMAL_SEPARATOR,
                                   Field.DECIMAL_SEPARATOR,
                                   iFieldEnd, fFieldStart, result);
            }
            if (fFieldStart == -1) {
                fFieldStart = result.length();
            }
            delegate.formatted(FRACTION_FIELD, Field.FRACTION, Field.FRACTION,
                               fFieldStart, result.length(), result);

            // The exponent is output using the pattern-specified minimum
            // exponent digits.  There is no maximum limit to the exponent
            // digits, since truncating the exponent would result in an
            // unacceptable inaccuracy.
            int fieldStart = result.length();

            result.append(symbols.getExponentSeparator());

            delegate.formatted(Field.EXPONENT_SYMBOL, Field.EXPONENT_SYMBOL,
                               fieldStart, result.length(), result);

            // For zero values, we force the exponent to zero.  We
            // must do this here, and not earlier, because the value
            // is used to determine integer digit count above.
            if (digitList.isZero()) {
                exponent = 0;
            }

            boolean negativeExponent = exponent < 0;
            if (negativeExponent) {
                exponent = -exponent;
                fieldStart = result.length();
                result.append(symbols.getMinusSign());
                delegate.formatted(Field.EXPONENT_SIGN, Field.EXPONENT_SIGN,
                                   fieldStart, result.length(), result);
            }
            digitList.set(negativeExponent, exponent);

            int eFieldStart = result.length();

            for (int i=digitList.decimalAt; i<minExponentDigits; ++i) {
                result.append(zero);
            }
            for (int i=0; i<digitList.decimalAt; ++i) {
                result.append((i < digitList.count) ?
                          (char)(digitList.digits[i] + zeroDelta) : zero);
            }
            delegate.formatted(Field.EXPONENT, Field.EXPONENT, eFieldStart,
                               result.length(), result);
        } else {
            int iFieldStart = result.length();

            // Output the integer portion.  Here 'count' is the total
            // number of integer digits we will display, including both
            // leading zeros required to satisfy getMinimumIntegerDigits,
            // and actual digits present in the number.
            int count = minIntDigits;
            int digitIndex = 0; // Index into digitList.fDigits[]
            if (digitList.decimalAt > 0 && count < digitList.decimalAt) {
                count = digitList.decimalAt;
            }

            // Handle the case where getMaximumIntegerDigits() is smaller
            // than the real number of integer digits.  If this is so, we
            // output the least significant max integer digits.  For example,
            // the value 1997 printed with 2 max integer digits is just "97".
            if (count > maxIntDigits) {
                count = maxIntDigits;
                digitIndex = digitList.decimalAt - count;
            }

            int sizeBeforeIntegerPart = result.length();
            for (int i=count-1; i>=0; --i) {
                if (i < digitList.decimalAt && digitIndex < digitList.count) {
                    // Output a real digit
                    result.append((char)(digitList.digits[digitIndex++] + zeroDelta));
                } else {
                    // Output a leading zero
                    result.append(zero);
                }

                // Output grouping separator if necessary.  Don't output a
                // grouping separator if i==0 though; that's at the end of
                // the integer part.
                if (isGroupingUsed() && i>0 && (groupingSize != 0) &&
                    (i % groupingSize == 0)) {
                    int gStart = result.length();
                    result.append(grouping);
                    delegate.formatted(Field.GROUPING_SEPARATOR,
                                       Field.GROUPING_SEPARATOR, gStart,
                                       result.length(), result);
                }
            }

            // Determine whether or not there are any printable fractional
            // digits.  If we've used up the digits we know there aren't.
            boolean fractionPresent = (minFraDigits > 0) ||
                (!isInteger && digitIndex < digitList.count);

            // If there is no fraction present, and we haven't printed any
            // integer digits, then print a zero.  Otherwise we won't print
            // _any_ digits, and we won't be able to parse this string.
            if (!fractionPresent && result.length() == sizeBeforeIntegerPart) {
                result.append(zero);
            }

            delegate.formatted(INTEGER_FIELD, Field.INTEGER, Field.INTEGER,
                               iFieldStart, result.length(), result);

            // Output the decimal separator if we always do so.
            int sStart = result.length();
            if (decimalSeparatorAlwaysShown || fractionPresent) {
                result.append(decimal);
            }

            if (sStart != result.length()) {
                delegate.formatted(Field.DECIMAL_SEPARATOR,
                                   Field.DECIMAL_SEPARATOR,
                                   sStart, result.length(), result);
            }
            int fFieldStart = result.length();

            for (int i=0; i < maxFraDigits; ++i) {
                // Here is where we escape from the loop.  We escape if we've
                // output the maximum fraction digits (specified in the for
                // expression above).
                // We also stop when we've output the minimum digits and either:
                // we have an integer, so there is no fractional stuff to
                // display, or we're out of significant digits.
                if (i >= minFraDigits &&
                    (isInteger || digitIndex >= digitList.count)) {
                    break;
                }

                // Output leading fractional zeros. These are zeros that come
                // after the decimal but before any significant digits. These
                // are only output if abs(number being formatted) < 1.0.
                if (-1-i > (digitList.decimalAt-1)) {
                    result.append(zero);
                    continue;
                }

                // Output a digit, if we have any precision left, or a
                // zero if we don't.  We don't want to output noise digits.
                if (!isInteger && digitIndex < digitList.count) {
                    result.append((char)(digitList.digits[digitIndex++] + zeroDelta));
                } else {
                    result.append(zero);
                }
            }

            // Record field information for caller.
            delegate.formatted(FRACTION_FIELD, Field.FRACTION, Field.FRACTION,
                               fFieldStart, result.length(), result);
        }

        if (isNegative) {
            append(result, negativeSuffix, delegate,
                   getNegativeSuffixFieldPositions(), Field.SIGN);
        } else {
            append(result, positiveSuffix, delegate,
                   getPositiveSuffixFieldPositions(), Field.SIGN);
        }

        return result;
    }

    /**
     * Appends the String <code>string</code> to <code>result</code>.
     * <code>delegate</code> is notified of all  the
     * <code>FieldPosition</code>s in <code>positions</code>.
     * <p>
     * If one of the <code>FieldPosition</code>s in <code>positions</code>
     * identifies a <code>SIGN</code> attribute, it is mapped to
     * <code>signAttribute</code>. This is used
     * to map the <code>SIGN</code> attribute to the <code>EXPONENT</code>
     * attribute as necessary.
     * <p>
     * This is used by <code>subformat</code> to add the prefix/suffix.
     *
    private void append(StringBuffer result, String string,
                        FieldDelegate delegate,
                        FieldPosition[] positions,
                        Format.Field signAttribute) {
        int start = result.length();

        if (string.length() > 0) {
            result.append(string);
            for (int counter = 0, max = positions.length; counter < max;
                 counter++) {
                FieldPosition fp = positions[counter];
                Format.Field attribute = fp.getFieldAttribute();

                if (attribute == Field.SIGN) {
                    attribute = signAttribute;
                }
                delegate.formatted(attribute, attribute,
                                   start + fp.getBeginIndex(),
                                   start + fp.getEndIndex(), result);
            }
        }
    }
    */
// END Android-removed: "fast-path formatting logic for double", subformat(), append().
@Override
public Number parse(String text, ParsePosition pos) {
    /*
        // special case NaN
        if (text.regionMatches(pos.index, symbols.getNaN(), 0, symbols.getNaN().length())) {
            pos.index = pos.index + symbols.getNaN().length();
            return new Double(Double.NaN);
        }

        boolean[] status = new boolean[STATUS_LENGTH];
        if (!subparse(text, pos, positivePrefix, negativePrefix, digitList, false, status)) {
            return null;
        }

        // special case INFINITY
        if (status[STATUS_INFINITE]) {
            if (status[STATUS_POSITIVE] == (multiplier >= 0)) {
                return new Double(Double.POSITIVE_INFINITY);
            } else {
                return new Double(Double.NEGATIVE_INFINITY);
            }
        }

        if (multiplier == 0) {
            if (digitList.isZero()) {
                return new Double(Double.NaN);
            } else if (status[STATUS_POSITIVE]) {
                return new Double(Double.POSITIVE_INFINITY);
            } else {
                return new Double(Double.NEGATIVE_INFINITY);
            }
        }

        if (isParseBigDecimal()) {
            BigDecimal bigDecimalResult = digitList.getBigDecimal();

            if (multiplier != 1) {
                try {
                    bigDecimalResult = bigDecimalResult.divide(getBigDecimalMultiplier());
                }
                catch (ArithmeticException e) {  // non-terminating decimal expansion
                    bigDecimalResult = bigDecimalResult.divide(getBigDecimalMultiplier(), roundingMode);
                }
            }

            if (!status[STATUS_POSITIVE]) {
                bigDecimalResult = bigDecimalResult.negate();
            }
            return bigDecimalResult;
        } else {
            boolean gotDouble = true;
            boolean gotLongMinimum = false;
            double  doubleResult = 0.0;
            long    longResult = 0;

            // Finally, have DigitList parse the digits into a value.
            if (digitList.fitsIntoLong(status[STATUS_POSITIVE], isParseIntegerOnly())) {
                gotDouble = false;
                longResult = digitList.getLong();
                if (longResult < 0) {  // got Long.MIN_VALUE
                    gotLongMinimum = true;
                }
            } else {
                doubleResult = digitList.getDouble();
            }

            // Divide by multiplier. We have to be careful here not to do
            // unneeded conversions between double and long.
            if (multiplier != 1) {
                if (gotDouble) {
                    doubleResult /= multiplier;
                } else {
                    // Avoid converting to double if we can
                    if (longResult % multiplier == 0) {
                        longResult /= multiplier;
                    } else {
                        doubleResult = ((double)longResult) / multiplier;
                        gotDouble = true;
                    }
                }
            }

            if (!status[STATUS_POSITIVE] && !gotLongMinimum) {
                doubleResult = -doubleResult;
                longResult = -longResult;
            }

            // At this point, if we divided the result by the multiplier, the
            // result may fit into a long.  We check for this case and return
            // a long if possible.
            // We must do this AFTER applying the negative (if appropriate)
            // in order to handle the case of LONG_MIN; otherwise, if we do
            // this with a positive value -LONG_MIN, the double is > 0, but
            // the long is < 0. We also must retain a double in the case of
            // -0.0, which will compare as == to a long 0 cast to a double
            // (bug 4162852).
            if (multiplier != 1 && gotDouble) {
                longResult = (long)doubleResult;
                gotDouble = ((doubleResult != (double)longResult) ||
                            (doubleResult == 0.0 && 1/doubleResult < 0.0)) &&
                            !isParseIntegerOnly();
            }

            return gotDouble ?
                (Number)new Double(doubleResult) : (Number)new Long(longResult);
        }
        */
    if (pos.index < 0 || pos.index >= text.length()) {
        return null;
    }
    // This might return android.icu.math.BigDecimal, java.math.BigInteger or a primitive type.
    Number number = icuDecimalFormat.parse(text, pos);
    if (number == null) {
        return null;
    }
    if (isParseBigDecimal()) {
        if (number instanceof Long) {
            return new BigDecimal(number.longValue());
        }
        if ((number instanceof Double) && !((Double) number).isInfinite() && !((Double) number).isNaN()) {
            return new BigDecimal(number.toString());
        }
        if ((number instanceof Double) && (((Double) number).isNaN() || ((Double) number).isInfinite())) {
            return number;
        }
        if (number instanceof android.icu.math.BigDecimal) {
            return ((android.icu.math.BigDecimal) number).toBigDecimal();
        }
    }
    if ((number instanceof android.icu.math.BigDecimal) || (number instanceof BigInteger)) {
        return number.doubleValue();
    }
    if (isParseIntegerOnly() && number.equals(new Double(-0.0))) {
        return 0L;
    }
    return number;
// END Android-changed: Use ICU.
}
#end_block

#method_before
// BEGIN Android-removed: STATUS_* constants, multiplier fields and methods and subparse(String, ...).
/*
    /**
     * Return a BigInteger multiplier.
     *
    private BigInteger getBigIntegerMultiplier() {
        if (bigIntegerMultiplier == null) {
            bigIntegerMultiplier = BigInteger.valueOf(multiplier);
        }
        return bigIntegerMultiplier;
    }
    private transient BigInteger bigIntegerMultiplier;

    /**
     * Return a BigDecimal multiplier.
     *
    private BigDecimal getBigDecimalMultiplier() {
        if (bigDecimalMultiplier == null) {
            bigDecimalMultiplier = new BigDecimal(multiplier);
        }
        return bigDecimalMultiplier;
    }
    private transient BigDecimal bigDecimalMultiplier;

    private static final int STATUS_INFINITE = 0;
    private static final int STATUS_POSITIVE = 1;
    private static final int STATUS_LENGTH   = 2;

    /**
     * Parse the given text into a number.  The text is parsed beginning at
     * parsePosition, until an unparseable character is seen.
     * @param text The string to parse.
     * @param parsePosition The position at which to being parsing.  Upon
     * return, the first unparseable character.
     * @param digits The DigitList to set to the parsed value.
     * @param isExponent If true, parse an exponent.  This means no
     * infinite values and integer only.
     * @param status Upon return contains boolean status flags indicating
     * whether the value was infinite and whether it was positive.
     *
    private final boolean subparse(String text, ParsePosition parsePosition,
                   String positivePrefix, String negativePrefix,
                   DigitList digits, boolean isExponent,
                   boolean status[]) {
        int position = parsePosition.index;
        int oldStart = parsePosition.index;
        int backup;
        boolean gotPositive, gotNegative;

        // check for positivePrefix; take longest
        gotPositive = text.regionMatches(position, positivePrefix, 0,
                                         positivePrefix.length());
        gotNegative = text.regionMatches(position, negativePrefix, 0,
                                         negativePrefix.length());

        if (gotPositive && gotNegative) {
            if (positivePrefix.length() > negativePrefix.length()) {
                gotNegative = false;
            } else if (positivePrefix.length() < negativePrefix.length()) {
                gotPositive = false;
            }
        }

        if (gotPositive) {
            position += positivePrefix.length();
        } else if (gotNegative) {
            position += negativePrefix.length();
        } else {
            parsePosition.errorIndex = position;
            return false;
        }

        // process digits or Inf, find decimal position
        status[STATUS_INFINITE] = false;
        if (!isExponent && text.regionMatches(position,symbols.getInfinity(),0,
                          symbols.getInfinity().length())) {
            position += symbols.getInfinity().length();
            status[STATUS_INFINITE] = true;
        } else {
            // We now have a string of digits, possibly with grouping symbols,
            // and decimal points.  We want to process these into a DigitList.
            // We don't want to put a bunch of leading zeros into the DigitList
            // though, so we keep track of the location of the decimal point,
            // put only significant digits into the DigitList, and adjust the
            // exponent as needed.

            digits.decimalAt = digits.count = 0;
            char zero = symbols.getZeroDigit();
            char decimal = isCurrencyFormat ?
                symbols.getMonetaryDecimalSeparator() :
                symbols.getDecimalSeparator();
            char grouping = symbols.getGroupingSeparator();
            String exponentString = symbols.getExponentSeparator();
            boolean sawDecimal = false;
            boolean sawExponent = false;
            boolean sawDigit = false;
            int exponent = 0; // Set to the exponent value, if any

            // We have to track digitCount ourselves, because digits.count will
            // pin when the maximum allowable digits is reached.
            int digitCount = 0;

            backup = -1;
            for (; position < text.length(); ++position) {
                char ch = text.charAt(position);

                /* We recognize all digit ranges, not only the Latin digit range
                 * '0'..'9'.  We do so by using the Character.digit() method,
                 * which converts a valid Unicode digit to the range 0..9.
                 *
                 * The character 'ch' may be a digit.  If so, place its value
                 * from 0 to 9 in 'digit'.  First try using the locale digit,
                 * which may or MAY NOT be a standard Unicode digit range.  If
                 * this fails, try using the standard Unicode digit ranges by
                 * calling Character.digit().  If this also fails, digit will
                 * have a value outside the range 0..9.
                 *
                int digit = ch - zero;
                if (digit < 0 || digit > 9) {
                    digit = Character.digit(ch, 10);
                }

                if (digit == 0) {
                    // Cancel out backup setting (see grouping handler below)
                    backup = -1; // Do this BEFORE continue statement below!!!
                    sawDigit = true;

                    // Handle leading zeros
                    if (digits.count == 0) {
                        // Ignore leading zeros in integer part of number.
                        if (!sawDecimal) {
                            continue;
                        }

                        // If we have seen the decimal, but no significant
                        // digits yet, then we account for leading zeros by
                        // decrementing the digits.decimalAt into negative
                        // values.
                        --digits.decimalAt;
                    } else {
                        ++digitCount;
                        digits.append((char)(digit + '0'));
                    }
                } else if (digit > 0 && digit <= 9) { // [sic] digit==0 handled above
                    sawDigit = true;
                    ++digitCount;
                    digits.append((char)(digit + '0'));

                    // Cancel out backup setting (see grouping handler below)
                    backup = -1;
                } else if (!isExponent && ch == decimal) {
                    // If we're only parsing integers, or if we ALREADY saw the
                    // decimal, then don't parse this one.
                    if (isParseIntegerOnly() || sawDecimal) {
                        break;
                    }
                    digits.decimalAt = digitCount; // Not digits.count!
                    sawDecimal = true;
                } else if (!isExponent && ch == grouping && isGroupingUsed()) {
                    if (sawDecimal) {
                        break;
                    }
                    // Ignore grouping characters, if we are using them, but
                    // require that they be followed by a digit.  Otherwise
                    // we backup and reprocess them.
                    backup = position;
                } else if (!isExponent && text.regionMatches(position, exponentString, 0, exponentString.length())
                             && !sawExponent) {
                    // Process the exponent by recursively calling this method.
                     ParsePosition pos = new ParsePosition(position + exponentString.length());
                    boolean[] stat = new boolean[STATUS_LENGTH];
                    DigitList exponentDigits = new DigitList();

                    if (subparse(text, pos, "", Character.toString(symbols.getMinusSign()), exponentDigits, true, stat) &&
                        exponentDigits.fitsIntoLong(stat[STATUS_POSITIVE], true)) {
                        position = pos.index; // Advance past the exponent
                        exponent = (int)exponentDigits.getLong();
                        if (!stat[STATUS_POSITIVE]) {
                            exponent = -exponent;
                        }
                        sawExponent = true;
                    }
                    break; // Whether we fail or succeed, we exit this loop
                } else {
                    break;
                }
            }

            if (backup != -1) {
                position = backup;
            }

            // If there was no decimal point we have an integer
            if (!sawDecimal) {
                digits.decimalAt = digitCount; // Not digits.count!
            }

            // Adjust for exponent, if any
            digits.decimalAt += exponent;

            // If none of the text string was recognized.  For example, parse
            // "x" with pattern "#0.00" (return index and error index both 0)
            // parse "$" with pattern "$#0.00". (return index 0 and error
            // index 1).
            if (!sawDigit && digitCount == 0) {
                parsePosition.index = oldStart;
                parsePosition.errorIndex = oldStart;
                return false;
            }
        }

        // check for suffix
        if (!isExponent) {
            if (gotPositive) {
                gotPositive = text.regionMatches(position,positiveSuffix,0,
                                                 positiveSuffix.length());
            }
            if (gotNegative) {
                gotNegative = text.regionMatches(position,negativeSuffix,0,
                                                 negativeSuffix.length());
            }

        // if both match, take longest
        if (gotPositive && gotNegative) {
            if (positiveSuffix.length() > negativeSuffix.length()) {
                gotNegative = false;
            } else if (positiveSuffix.length() < negativeSuffix.length()) {
                gotPositive = false;
            }
        }

        // fail if neither or both
        if (gotPositive == gotNegative) {
            parsePosition.errorIndex = position;
            return false;
        }

        parsePosition.index = position +
            (gotPositive ? positiveSuffix.length() : negativeSuffix.length()); // mark success!
        } else {
            parsePosition.index = position;
        }

        status[STATUS_POSITIVE] = gotPositive;
        if (parsePosition.index == oldStart) {
            parsePosition.errorIndex = position;
            return false;
        }
        return true;
    }
    */
// END Android-removed: STATUS_* constants, multiplier fields and methods and subparse(String, ...).
public DecimalFormatSymbols getDecimalFormatSymbols() {
    /*
        try {
            // don't allow multiple references
            return (DecimalFormatSymbols) symbols.clone();
        } catch (Exception foo) {
            return null; // should never happen
        }
        */
    return DecimalFormatSymbols.fromIcuInstance(icuDecimalFormat.getDecimalFormatSymbols());
// END Android-changed: Use ICU.
}
#method_after
// BEGIN Android-removed: Unused private helpers.
/*
    /**
     * Return a BigInteger multiplier.
     *
    private BigInteger getBigIntegerMultiplier() {
        if (bigIntegerMultiplier == null) {
            bigIntegerMultiplier = BigInteger.valueOf(multiplier);
        }
        return bigIntegerMultiplier;
    }
    private transient BigInteger bigIntegerMultiplier;

    /**
     * Return a BigDecimal multiplier.
     *
    private BigDecimal getBigDecimalMultiplier() {
        if (bigDecimalMultiplier == null) {
            bigDecimalMultiplier = new BigDecimal(multiplier);
        }
        return bigDecimalMultiplier;
    }
    private transient BigDecimal bigDecimalMultiplier;

    private static final int STATUS_INFINITE = 0;
    private static final int STATUS_POSITIVE = 1;
    private static final int STATUS_LENGTH   = 2;

    /**
     * Parse the given text into a number.  The text is parsed beginning at
     * parsePosition, until an unparseable character is seen.
     * @param text The string to parse.
     * @param parsePosition The position at which to being parsing.  Upon
     * return, the first unparseable character.
     * @param digits The DigitList to set to the parsed value.
     * @param isExponent If true, parse an exponent.  This means no
     * infinite values and integer only.
     * @param status Upon return contains boolean status flags indicating
     * whether the value was infinite and whether it was positive.
     *
    private final boolean subparse(String text, ParsePosition parsePosition,
                   String positivePrefix, String negativePrefix,
                   DigitList digits, boolean isExponent,
                   boolean status[]) {
        int position = parsePosition.index;
        int oldStart = parsePosition.index;
        int backup;
        boolean gotPositive, gotNegative;

        // check for positivePrefix; take longest
        gotPositive = text.regionMatches(position, positivePrefix, 0,
                                         positivePrefix.length());
        gotNegative = text.regionMatches(position, negativePrefix, 0,
                                         negativePrefix.length());

        if (gotPositive && gotNegative) {
            if (positivePrefix.length() > negativePrefix.length()) {
                gotNegative = false;
            } else if (positivePrefix.length() < negativePrefix.length()) {
                gotPositive = false;
            }
        }

        if (gotPositive) {
            position += positivePrefix.length();
        } else if (gotNegative) {
            position += negativePrefix.length();
        } else {
            parsePosition.errorIndex = position;
            return false;
        }

        // process digits or Inf, find decimal position
        status[STATUS_INFINITE] = false;
        if (!isExponent && text.regionMatches(position,symbols.getInfinity(),0,
                          symbols.getInfinity().length())) {
            position += symbols.getInfinity().length();
            status[STATUS_INFINITE] = true;
        } else {
            // We now have a string of digits, possibly with grouping symbols,
            // and decimal points.  We want to process these into a DigitList.
            // We don't want to put a bunch of leading zeros into the DigitList
            // though, so we keep track of the location of the decimal point,
            // put only significant digits into the DigitList, and adjust the
            // exponent as needed.

            digits.decimalAt = digits.count = 0;
            char zero = symbols.getZeroDigit();
            char decimal = isCurrencyFormat ?
                symbols.getMonetaryDecimalSeparator() :
                symbols.getDecimalSeparator();
            char grouping = symbols.getGroupingSeparator();
            String exponentString = symbols.getExponentSeparator();
            boolean sawDecimal = false;
            boolean sawExponent = false;
            boolean sawDigit = false;
            int exponent = 0; // Set to the exponent value, if any

            // We have to track digitCount ourselves, because digits.count will
            // pin when the maximum allowable digits is reached.
            int digitCount = 0;

            backup = -1;
            for (; position < text.length(); ++position) {
                char ch = text.charAt(position);

                /* We recognize all digit ranges, not only the Latin digit range
                 * '0'..'9'.  We do so by using the Character.digit() method,
                 * which converts a valid Unicode digit to the range 0..9.
                 *
                 * The character 'ch' may be a digit.  If so, place its value
                 * from 0 to 9 in 'digit'.  First try using the locale digit,
                 * which may or MAY NOT be a standard Unicode digit range.  If
                 * this fails, try using the standard Unicode digit ranges by
                 * calling Character.digit().  If this also fails, digit will
                 * have a value outside the range 0..9.
                 *
                int digit = ch - zero;
                if (digit < 0 || digit > 9) {
                    digit = Character.digit(ch, 10);
                }

                if (digit == 0) {
                    // Cancel out backup setting (see grouping handler below)
                    backup = -1; // Do this BEFORE continue statement below!!!
                    sawDigit = true;

                    // Handle leading zeros
                    if (digits.count == 0) {
                        // Ignore leading zeros in integer part of number.
                        if (!sawDecimal) {
                            continue;
                        }

                        // If we have seen the decimal, but no significant
                        // digits yet, then we account for leading zeros by
                        // decrementing the digits.decimalAt into negative
                        // values.
                        --digits.decimalAt;
                    } else {
                        ++digitCount;
                        digits.append((char)(digit + '0'));
                    }
                } else if (digit > 0 && digit <= 9) { // [sic] digit==0 handled above
                    sawDigit = true;
                    ++digitCount;
                    digits.append((char)(digit + '0'));

                    // Cancel out backup setting (see grouping handler below)
                    backup = -1;
                } else if (!isExponent && ch == decimal) {
                    // If we're only parsing integers, or if we ALREADY saw the
                    // decimal, then don't parse this one.
                    if (isParseIntegerOnly() || sawDecimal) {
                        break;
                    }
                    digits.decimalAt = digitCount; // Not digits.count!
                    sawDecimal = true;
                } else if (!isExponent && ch == grouping && isGroupingUsed()) {
                    if (sawDecimal) {
                        break;
                    }
                    // Ignore grouping characters, if we are using them, but
                    // require that they be followed by a digit.  Otherwise
                    // we backup and reprocess them.
                    backup = position;
                } else if (!isExponent && text.regionMatches(position, exponentString, 0, exponentString.length())
                             && !sawExponent) {
                    // Process the exponent by recursively calling this method.
                     ParsePosition pos = new ParsePosition(position + exponentString.length());
                    boolean[] stat = new boolean[STATUS_LENGTH];
                    DigitList exponentDigits = new DigitList();

                    if (subparse(text, pos, "", Character.toString(symbols.getMinusSign()), exponentDigits, true, stat) &&
                        exponentDigits.fitsIntoLong(stat[STATUS_POSITIVE], true)) {
                        position = pos.index; // Advance past the exponent
                        exponent = (int)exponentDigits.getLong();
                        if (!stat[STATUS_POSITIVE]) {
                            exponent = -exponent;
                        }
                        sawExponent = true;
                    }
                    break; // Whether we fail or succeed, we exit this loop
                } else {
                    break;
                }
            }

            if (backup != -1) {
                position = backup;
            }

            // If there was no decimal point we have an integer
            if (!sawDecimal) {
                digits.decimalAt = digitCount; // Not digits.count!
            }

            // Adjust for exponent, if any
            digits.decimalAt += exponent;

            // If none of the text string was recognized.  For example, parse
            // "x" with pattern "#0.00" (return index and error index both 0)
            // parse "$" with pattern "$#0.00". (return index 0 and error
            // index 1).
            if (!sawDigit && digitCount == 0) {
                parsePosition.index = oldStart;
                parsePosition.errorIndex = oldStart;
                return false;
            }
        }

        // check for suffix
        if (!isExponent) {
            if (gotPositive) {
                gotPositive = text.regionMatches(position,positiveSuffix,0,
                                                 positiveSuffix.length());
            }
            if (gotNegative) {
                gotNegative = text.regionMatches(position,negativeSuffix,0,
                                                 negativeSuffix.length());
            }

        // if both match, take longest
        if (gotPositive && gotNegative) {
            if (positiveSuffix.length() > negativeSuffix.length()) {
                gotNegative = false;
            } else if (positiveSuffix.length() < negativeSuffix.length()) {
                gotPositive = false;
            }
        }

        // fail if neither or both
        if (gotPositive == gotNegative) {
            parsePosition.errorIndex = position;
            return false;
        }

        parsePosition.index = position +
            (gotPositive ? positiveSuffix.length() : negativeSuffix.length()); // mark success!
        } else {
            parsePosition.index = position;
        }

        status[STATUS_POSITIVE] = gotPositive;
        if (parsePosition.index == oldStart) {
            parsePosition.errorIndex = position;
            return false;
        }
        return true;
    }
    */
// END Android-removed: Unused private helpers.
public DecimalFormatSymbols getDecimalFormatSymbols() {
    /*
        try {
            // don't allow multiple references
            return (DecimalFormatSymbols) symbols.clone();
        } catch (Exception foo) {
            return null; // should never happen
        }
        */
    return DecimalFormatSymbols.fromIcuInstance(icuDecimalFormat.getDecimalFormatSymbols());
// END Android-changed: Use ICU.
}
#end_block

#method_before
// BEGIN Android-removed: private helper methods expandAffixes(), expandAffix(), toPattern(boolean).
/*
    /**
     * Expand the affix pattern strings into the expanded affix strings.  If any
     * affix pattern string is null, do not expand it.  This method should be
     * called any time the symbols or the affix patterns change in order to keep
     * the expanded affix strings up to date.
     *
    private void expandAffixes() {
        // Reuse one StringBuffer for better performance
        StringBuffer buffer = new StringBuffer();
        if (posPrefixPattern != null) {
            positivePrefix = expandAffix(posPrefixPattern, buffer);
            positivePrefixFieldPositions = null;
        }
        if (posSuffixPattern != null) {
            positiveSuffix = expandAffix(posSuffixPattern, buffer);
            positiveSuffixFieldPositions = null;
        }
        if (negPrefixPattern != null) {
            negativePrefix = expandAffix(negPrefixPattern, buffer);
            negativePrefixFieldPositions = null;
        }
        if (negSuffixPattern != null) {
            negativeSuffix = expandAffix(negSuffixPattern, buffer);
            negativeSuffixFieldPositions = null;
        }
    }

    /**
     * Expand an affix pattern into an affix string.  All characters in the
     * pattern are literal unless prefixed by QUOTE.  The following characters
     * after QUOTE are recognized: PATTERN_PERCENT, PATTERN_PER_MILLE,
     * PATTERN_MINUS, and CURRENCY_SIGN.  If CURRENCY_SIGN is doubled (QUOTE +
     * CURRENCY_SIGN + CURRENCY_SIGN), it is interpreted as an ISO 4217
     * currency code.  Any other character after a QUOTE represents itself.
     * QUOTE must be followed by another character; QUOTE may not occur by
     * itself at the end of the pattern.
     *
     * @param pattern the non-null, possibly empty pattern
     * @param buffer a scratch StringBuffer; its contents will be lost
     * @return the expanded equivalent of pattern
     *
    private String expandAffix(String pattern, StringBuffer buffer) {
        buffer.setLength(0);
        for (int i=0; i<pattern.length(); ) {
            char c = pattern.charAt(i++);
            if (c == QUOTE) {
                c = pattern.charAt(i++);
                switch (c) {
                case CURRENCY_SIGN:
                    if (i<pattern.length() &&
                        pattern.charAt(i) == CURRENCY_SIGN) {
                        ++i;
                        buffer.append(symbols.getInternationalCurrencySymbol());
                    } else {
                        buffer.append(symbols.getCurrencySymbol());
                    }
                    continue;
                case PATTERN_PERCENT:
                    c = symbols.getPercent();
                    break;
                case PATTERN_PER_MILLE:
                    c = symbols.getPerMill();
                    break;
                case PATTERN_MINUS:
                    c = symbols.getMinusSign();
                    break;
                }
            }
            buffer.append(c);
        }
        return buffer.toString();
    }

    /**
     * Expand an affix pattern into an array of FieldPositions describing
     * how the pattern would be expanded.
     * All characters in the
     * pattern are literal unless prefixed by QUOTE.  The following characters
     * after QUOTE are recognized: PATTERN_PERCENT, PATTERN_PER_MILLE,
     * PATTERN_MINUS, and CURRENCY_SIGN.  If CURRENCY_SIGN is doubled (QUOTE +
     * CURRENCY_SIGN + CURRENCY_SIGN), it is interpreted as an ISO 4217
     * currency code.  Any other character after a QUOTE represents itself.
     * QUOTE must be followed by another character; QUOTE may not occur by
     * itself at the end of the pattern.
     *
     * @param pattern the non-null, possibly empty pattern
     * @return FieldPosition array of the resulting fields.
     *
    private FieldPosition[] expandAffix(String pattern) {
        ArrayList<FieldPosition> positions = null;
        int stringIndex = 0;
        for (int i=0; i<pattern.length(); ) {
            char c = pattern.charAt(i++);
            if (c == QUOTE) {
                int field = -1;
                Format.Field fieldID = null;
                c = pattern.charAt(i++);
                switch (c) {
                case CURRENCY_SIGN:
                    String string;
                    if (i<pattern.length() &&
                        pattern.charAt(i) == CURRENCY_SIGN) {
                        ++i;
                        string = symbols.getInternationalCurrencySymbol();
                    } else {
                        string = symbols.getCurrencySymbol();
                    }
                    if (string.length() > 0) {
                        if (positions == null) {
                            positions = new ArrayList<>(2);
                        }
                        FieldPosition fp = new FieldPosition(Field.CURRENCY);
                        fp.setBeginIndex(stringIndex);
                        fp.setEndIndex(stringIndex + string.length());
                        positions.add(fp);
                        stringIndex += string.length();
                    }
                    continue;
                case PATTERN_PERCENT:
                    c = symbols.getPercent();
                    field = -1;
                    fieldID = Field.PERCENT;
                    break;
                case PATTERN_PER_MILLE:
                    c = symbols.getPerMill();
                    field = -1;
                    fieldID = Field.PERMILLE;
                    break;
                case PATTERN_MINUS:
                    c = symbols.getMinusSign();
                    field = -1;
                    fieldID = Field.SIGN;
                    break;
                }
                if (fieldID != null) {
                    if (positions == null) {
                        positions = new ArrayList<>(2);
                    }
                    FieldPosition fp = new FieldPosition(fieldID, field);
                    fp.setBeginIndex(stringIndex);
                    fp.setEndIndex(stringIndex + 1);
                    positions.add(fp);
                }
            }
            stringIndex++;
        }
        if (positions != null) {
            return positions.toArray(EmptyFieldPositionArray);
        }
        return EmptyFieldPositionArray;
    }

    /**
     * Appends an affix pattern to the given StringBuffer, quoting special
     * characters as needed.  Uses the internal affix pattern, if that exists,
     * or the literal affix, if the internal affix pattern is null.  The
     * appended string will generate the same affix pattern (or literal affix)
     * when passed to toPattern().
     *
     * @param buffer the affix string is appended to this
     * @param affixPattern a pattern such as posPrefixPattern; may be null
     * @param expAffix a corresponding expanded affix, such as positivePrefix.
     * Ignored unless affixPattern is null.  If affixPattern is null, then
     * expAffix is appended as a literal affix.
     * @param localized true if the appended pattern should contain localized
     * pattern characters; otherwise, non-localized pattern chars are appended
     *
    private void appendAffix(StringBuffer buffer, String affixPattern,
                             String expAffix, boolean localized) {
        if (affixPattern == null) {
            appendAffix(buffer, expAffix, localized);
        } else {
            int i;
            for (int pos=0; pos<affixPattern.length(); pos=i) {
                i = affixPattern.indexOf(QUOTE, pos);
                if (i < 0) {
                    appendAffix(buffer, affixPattern.substring(pos), localized);
                    break;
                }
                if (i > pos) {
                    appendAffix(buffer, affixPattern.substring(pos, i), localized);
                }
                char c = affixPattern.charAt(++i);
                ++i;
                if (c == QUOTE) {
                    buffer.append(c);
                    // Fall through and append another QUOTE below
                } else if (c == CURRENCY_SIGN &&
                           i<affixPattern.length() &&
                           affixPattern.charAt(i) == CURRENCY_SIGN) {
                    ++i;
                    buffer.append(c);
                    // Fall through and append another CURRENCY_SIGN below
                } else if (localized) {
                    switch (c) {
                    case PATTERN_PERCENT:
                        c = symbols.getPercent();
                        break;
                    case PATTERN_PER_MILLE:
                        c = symbols.getPerMill();
                        break;
                    case PATTERN_MINUS:
                        c = symbols.getMinusSign();
                        break;
                    }
                }
                buffer.append(c);
            }
        }
    }

    /**
     * Append an affix to the given StringBuffer, using quotes if
     * there are special characters.  Single quotes themselves must be
     * escaped in either case.
     *
    private void appendAffix(StringBuffer buffer, String affix, boolean localized) {
        boolean needQuote;
        if (localized) {
            needQuote = affix.indexOf(symbols.getZeroDigit()) >= 0
                || affix.indexOf(symbols.getGroupingSeparator()) >= 0
                || affix.indexOf(symbols.getDecimalSeparator()) >= 0
                || affix.indexOf(symbols.getPercent()) >= 0
                || affix.indexOf(symbols.getPerMill()) >= 0
                || affix.indexOf(symbols.getDigit()) >= 0
                || affix.indexOf(symbols.getPatternSeparator()) >= 0
                || affix.indexOf(symbols.getMinusSign()) >= 0
                || affix.indexOf(CURRENCY_SIGN) >= 0;
        } else {
            needQuote = affix.indexOf(PATTERN_ZERO_DIGIT) >= 0
                || affix.indexOf(PATTERN_GROUPING_SEPARATOR) >= 0
                || affix.indexOf(PATTERN_DECIMAL_SEPARATOR) >= 0
                || affix.indexOf(PATTERN_PERCENT) >= 0
                || affix.indexOf(PATTERN_PER_MILLE) >= 0
                || affix.indexOf(PATTERN_DIGIT) >= 0
                || affix.indexOf(PATTERN_SEPARATOR) >= 0
                || affix.indexOf(PATTERN_MINUS) >= 0
                || affix.indexOf(CURRENCY_SIGN) >= 0;
        }
        if (needQuote) buffer.append('\'');
        if (affix.indexOf('\'') < 0) buffer.append(affix);
        else {
            for (int j=0; j<affix.length(); ++j) {
                char c = affix.charAt(j);
                buffer.append(c);
                if (c == '\'') buffer.append(c);
            }
        }
        if (needQuote) buffer.append('\'');
    }

    /**
     * Does the real work of generating a pattern.  *
    private String toPattern(boolean localized) {
        StringBuffer result = new StringBuffer();
        for (int j = 1; j >= 0; --j) {
            if (j == 1)
                appendAffix(result, posPrefixPattern, positivePrefix, localized);
            else appendAffix(result, negPrefixPattern, negativePrefix, localized);
            int i;
            int digitCount = useExponentialNotation
                        ? getMaximumIntegerDigits()
                        : Math.max(groupingSize, getMinimumIntegerDigits())+1;
            for (i = digitCount; i > 0; --i) {
                if (i != digitCount && isGroupingUsed() && groupingSize != 0 &&
                    i % groupingSize == 0) {
                    result.append(localized ? symbols.getGroupingSeparator() :
                                  PATTERN_GROUPING_SEPARATOR);
                }
                result.append(i <= getMinimumIntegerDigits()
                    ? (localized ? symbols.getZeroDigit() : PATTERN_ZERO_DIGIT)
                    : (localized ? symbols.getDigit() : PATTERN_DIGIT));
            }
            if (getMaximumFractionDigits() > 0 || decimalSeparatorAlwaysShown)
                result.append(localized ? symbols.getDecimalSeparator() :
                              PATTERN_DECIMAL_SEPARATOR);
            for (i = 0; i < getMaximumFractionDigits(); ++i) {
                if (i < getMinimumFractionDigits()) {
                    result.append(localized ? symbols.getZeroDigit() :
                                  PATTERN_ZERO_DIGIT);
                } else {
                    result.append(localized ? symbols.getDigit() :
                                  PATTERN_DIGIT);
                }
            }
        if (useExponentialNotation)
        {
            result.append(localized ? symbols.getExponentSeparator() :
                  PATTERN_EXPONENT);
        for (i=0; i<minExponentDigits; ++i)
                    result.append(localized ? symbols.getZeroDigit() :
                                  PATTERN_ZERO_DIGIT);
        }
            if (j == 1) {
                appendAffix(result, posSuffixPattern, positiveSuffix, localized);
                if ((negSuffixPattern == posSuffixPattern && // n == p == null
                     negativeSuffix.equals(positiveSuffix))
                    || (negSuffixPattern != null &&
                        negSuffixPattern.equals(posSuffixPattern))) {
                    if ((negPrefixPattern != null && posPrefixPattern != null &&
                         negPrefixPattern.equals("'-" + posPrefixPattern)) ||
                        (negPrefixPattern == posPrefixPattern && // n == p == null
                         negativePrefix.equals(symbols.getMinusSign() + positivePrefix)))
                        break;
                }
                result.append(localized ? symbols.getPatternSeparator() :
                              PATTERN_SEPARATOR);
            } else appendAffix(result, negSuffixPattern, negativeSuffix, localized);
        }
        return result.toString();
    }
    */
// END Android-removed: private helper methods expandAffixes(), expandAffix(), toPattern(boolean).
public void applyPattern(String pattern) {
    // Android-changed: use ICU.
    // applyPattern(pattern, false);
    icuDecimalFormat.applyPattern(pattern);
    updateFieldsFromIcu();
}
#method_after
// BEGIN Android-removed: Unused private helpers.
/*
    /**
     * Expand the affix pattern strings into the expanded affix strings.  If any
     * affix pattern string is null, do not expand it.  This method should be
     * called any time the symbols or the affix patterns change in order to keep
     * the expanded affix strings up to date.
     *
    private void expandAffixes() {
        // Reuse one StringBuffer for better performance
        StringBuffer buffer = new StringBuffer();
        if (posPrefixPattern != null) {
            positivePrefix = expandAffix(posPrefixPattern, buffer);
            positivePrefixFieldPositions = null;
        }
        if (posSuffixPattern != null) {
            positiveSuffix = expandAffix(posSuffixPattern, buffer);
            positiveSuffixFieldPositions = null;
        }
        if (negPrefixPattern != null) {
            negativePrefix = expandAffix(negPrefixPattern, buffer);
            negativePrefixFieldPositions = null;
        }
        if (negSuffixPattern != null) {
            negativeSuffix = expandAffix(negSuffixPattern, buffer);
            negativeSuffixFieldPositions = null;
        }
    }

    /**
     * Expand an affix pattern into an affix string.  All characters in the
     * pattern are literal unless prefixed by QUOTE.  The following characters
     * after QUOTE are recognized: PATTERN_PERCENT, PATTERN_PER_MILLE,
     * PATTERN_MINUS, and CURRENCY_SIGN.  If CURRENCY_SIGN is doubled (QUOTE +
     * CURRENCY_SIGN + CURRENCY_SIGN), it is interpreted as an ISO 4217
     * currency code.  Any other character after a QUOTE represents itself.
     * QUOTE must be followed by another character; QUOTE may not occur by
     * itself at the end of the pattern.
     *
     * @param pattern the non-null, possibly empty pattern
     * @param buffer a scratch StringBuffer; its contents will be lost
     * @return the expanded equivalent of pattern
     *
    private String expandAffix(String pattern, StringBuffer buffer) {
        buffer.setLength(0);
        for (int i=0; i<pattern.length(); ) {
            char c = pattern.charAt(i++);
            if (c == QUOTE) {
                c = pattern.charAt(i++);
                switch (c) {
                case CURRENCY_SIGN:
                    if (i<pattern.length() &&
                        pattern.charAt(i) == CURRENCY_SIGN) {
                        ++i;
                        buffer.append(symbols.getInternationalCurrencySymbol());
                    } else {
                        buffer.append(symbols.getCurrencySymbol());
                    }
                    continue;
                case PATTERN_PERCENT:
                    c = symbols.getPercent();
                    break;
                case PATTERN_PER_MILLE:
                    c = symbols.getPerMill();
                    break;
                case PATTERN_MINUS:
                    c = symbols.getMinusSign();
                    break;
                }
            }
            buffer.append(c);
        }
        return buffer.toString();
    }

    /**
     * Expand an affix pattern into an array of FieldPositions describing
     * how the pattern would be expanded.
     * All characters in the
     * pattern are literal unless prefixed by QUOTE.  The following characters
     * after QUOTE are recognized: PATTERN_PERCENT, PATTERN_PER_MILLE,
     * PATTERN_MINUS, and CURRENCY_SIGN.  If CURRENCY_SIGN is doubled (QUOTE +
     * CURRENCY_SIGN + CURRENCY_SIGN), it is interpreted as an ISO 4217
     * currency code.  Any other character after a QUOTE represents itself.
     * QUOTE must be followed by another character; QUOTE may not occur by
     * itself at the end of the pattern.
     *
     * @param pattern the non-null, possibly empty pattern
     * @return FieldPosition array of the resulting fields.
     *
    private FieldPosition[] expandAffix(String pattern) {
        ArrayList<FieldPosition> positions = null;
        int stringIndex = 0;
        for (int i=0; i<pattern.length(); ) {
            char c = pattern.charAt(i++);
            if (c == QUOTE) {
                int field = -1;
                Format.Field fieldID = null;
                c = pattern.charAt(i++);
                switch (c) {
                case CURRENCY_SIGN:
                    String string;
                    if (i<pattern.length() &&
                        pattern.charAt(i) == CURRENCY_SIGN) {
                        ++i;
                        string = symbols.getInternationalCurrencySymbol();
                    } else {
                        string = symbols.getCurrencySymbol();
                    }
                    if (string.length() > 0) {
                        if (positions == null) {
                            positions = new ArrayList<>(2);
                        }
                        FieldPosition fp = new FieldPosition(Field.CURRENCY);
                        fp.setBeginIndex(stringIndex);
                        fp.setEndIndex(stringIndex + string.length());
                        positions.add(fp);
                        stringIndex += string.length();
                    }
                    continue;
                case PATTERN_PERCENT:
                    c = symbols.getPercent();
                    field = -1;
                    fieldID = Field.PERCENT;
                    break;
                case PATTERN_PER_MILLE:
                    c = symbols.getPerMill();
                    field = -1;
                    fieldID = Field.PERMILLE;
                    break;
                case PATTERN_MINUS:
                    c = symbols.getMinusSign();
                    field = -1;
                    fieldID = Field.SIGN;
                    break;
                }
                if (fieldID != null) {
                    if (positions == null) {
                        positions = new ArrayList<>(2);
                    }
                    FieldPosition fp = new FieldPosition(fieldID, field);
                    fp.setBeginIndex(stringIndex);
                    fp.setEndIndex(stringIndex + 1);
                    positions.add(fp);
                }
            }
            stringIndex++;
        }
        if (positions != null) {
            return positions.toArray(EmptyFieldPositionArray);
        }
        return EmptyFieldPositionArray;
    }

    /**
     * Appends an affix pattern to the given StringBuffer, quoting special
     * characters as needed.  Uses the internal affix pattern, if that exists,
     * or the literal affix, if the internal affix pattern is null.  The
     * appended string will generate the same affix pattern (or literal affix)
     * when passed to toPattern().
     *
     * @param buffer the affix string is appended to this
     * @param affixPattern a pattern such as posPrefixPattern; may be null
     * @param expAffix a corresponding expanded affix, such as positivePrefix.
     * Ignored unless affixPattern is null.  If affixPattern is null, then
     * expAffix is appended as a literal affix.
     * @param localized true if the appended pattern should contain localized
     * pattern characters; otherwise, non-localized pattern chars are appended
     *
    private void appendAffix(StringBuffer buffer, String affixPattern,
                             String expAffix, boolean localized) {
        if (affixPattern == null) {
            appendAffix(buffer, expAffix, localized);
        } else {
            int i;
            for (int pos=0; pos<affixPattern.length(); pos=i) {
                i = affixPattern.indexOf(QUOTE, pos);
                if (i < 0) {
                    appendAffix(buffer, affixPattern.substring(pos), localized);
                    break;
                }
                if (i > pos) {
                    appendAffix(buffer, affixPattern.substring(pos, i), localized);
                }
                char c = affixPattern.charAt(++i);
                ++i;
                if (c == QUOTE) {
                    buffer.append(c);
                    // Fall through and append another QUOTE below
                } else if (c == CURRENCY_SIGN &&
                           i<affixPattern.length() &&
                           affixPattern.charAt(i) == CURRENCY_SIGN) {
                    ++i;
                    buffer.append(c);
                    // Fall through and append another CURRENCY_SIGN below
                } else if (localized) {
                    switch (c) {
                    case PATTERN_PERCENT:
                        c = symbols.getPercent();
                        break;
                    case PATTERN_PER_MILLE:
                        c = symbols.getPerMill();
                        break;
                    case PATTERN_MINUS:
                        c = symbols.getMinusSign();
                        break;
                    }
                }
                buffer.append(c);
            }
        }
    }

    /**
     * Append an affix to the given StringBuffer, using quotes if
     * there are special characters.  Single quotes themselves must be
     * escaped in either case.
     *
    private void appendAffix(StringBuffer buffer, String affix, boolean localized) {
        boolean needQuote;
        if (localized) {
            needQuote = affix.indexOf(symbols.getZeroDigit()) >= 0
                || affix.indexOf(symbols.getGroupingSeparator()) >= 0
                || affix.indexOf(symbols.getDecimalSeparator()) >= 0
                || affix.indexOf(symbols.getPercent()) >= 0
                || affix.indexOf(symbols.getPerMill()) >= 0
                || affix.indexOf(symbols.getDigit()) >= 0
                || affix.indexOf(symbols.getPatternSeparator()) >= 0
                || affix.indexOf(symbols.getMinusSign()) >= 0
                || affix.indexOf(CURRENCY_SIGN) >= 0;
        } else {
            needQuote = affix.indexOf(PATTERN_ZERO_DIGIT) >= 0
                || affix.indexOf(PATTERN_GROUPING_SEPARATOR) >= 0
                || affix.indexOf(PATTERN_DECIMAL_SEPARATOR) >= 0
                || affix.indexOf(PATTERN_PERCENT) >= 0
                || affix.indexOf(PATTERN_PER_MILLE) >= 0
                || affix.indexOf(PATTERN_DIGIT) >= 0
                || affix.indexOf(PATTERN_SEPARATOR) >= 0
                || affix.indexOf(PATTERN_MINUS) >= 0
                || affix.indexOf(CURRENCY_SIGN) >= 0;
        }
        if (needQuote) buffer.append('\'');
        if (affix.indexOf('\'') < 0) buffer.append(affix);
        else {
            for (int j=0; j<affix.length(); ++j) {
                char c = affix.charAt(j);
                buffer.append(c);
                if (c == '\'') buffer.append(c);
            }
        }
        if (needQuote) buffer.append('\'');
    }

    /**
     * Does the real work of generating a pattern.  *
    private String toPattern(boolean localized) {
        StringBuffer result = new StringBuffer();
        for (int j = 1; j >= 0; --j) {
            if (j == 1)
                appendAffix(result, posPrefixPattern, positivePrefix, localized);
            else appendAffix(result, negPrefixPattern, negativePrefix, localized);
            int i;
            int digitCount = useExponentialNotation
                        ? getMaximumIntegerDigits()
                        : Math.max(groupingSize, getMinimumIntegerDigits())+1;
            for (i = digitCount; i > 0; --i) {
                if (i != digitCount && isGroupingUsed() && groupingSize != 0 &&
                    i % groupingSize == 0) {
                    result.append(localized ? symbols.getGroupingSeparator() :
                                  PATTERN_GROUPING_SEPARATOR);
                }
                result.append(i <= getMinimumIntegerDigits()
                    ? (localized ? symbols.getZeroDigit() : PATTERN_ZERO_DIGIT)
                    : (localized ? symbols.getDigit() : PATTERN_DIGIT));
            }
            if (getMaximumFractionDigits() > 0 || decimalSeparatorAlwaysShown)
                result.append(localized ? symbols.getDecimalSeparator() :
                              PATTERN_DECIMAL_SEPARATOR);
            for (i = 0; i < getMaximumFractionDigits(); ++i) {
                if (i < getMinimumFractionDigits()) {
                    result.append(localized ? symbols.getZeroDigit() :
                                  PATTERN_ZERO_DIGIT);
                } else {
                    result.append(localized ? symbols.getDigit() :
                                  PATTERN_DIGIT);
                }
            }
        if (useExponentialNotation)
        {
            result.append(localized ? symbols.getExponentSeparator() :
                  PATTERN_EXPONENT);
        for (i=0; i<minExponentDigits; ++i)
                    result.append(localized ? symbols.getZeroDigit() :
                                  PATTERN_ZERO_DIGIT);
        }
            if (j == 1) {
                appendAffix(result, posSuffixPattern, positiveSuffix, localized);
                if ((negSuffixPattern == posSuffixPattern && // n == p == null
                     negativeSuffix.equals(positiveSuffix))
                    || (negSuffixPattern != null &&
                        negSuffixPattern.equals(posSuffixPattern))) {
                    if ((negPrefixPattern != null && posPrefixPattern != null &&
                         negPrefixPattern.equals("'-" + posPrefixPattern)) ||
                        (negPrefixPattern == posPrefixPattern && // n == p == null
                         negativePrefix.equals(symbols.getMinusSign() + positivePrefix)))
                        break;
                }
                result.append(localized ? symbols.getPatternSeparator() :
                              PATTERN_SEPARATOR);
            } else appendAffix(result, negSuffixPattern, negativeSuffix, localized);
        }
        return result.toString();
    }
    */
// END Android-removed: Unused private helpers.
public void applyPattern(String pattern) {
    // Android-changed: use ICU.
    // applyPattern(pattern, false);
    icuDecimalFormat.applyPattern(pattern);
    updateFieldsFromIcu();
}
#end_block

#method_before
// BEGIN Android-removed: applyPattern(String, boolean) as apply[Localized]Pattern calls ICU directly.
/*
    /**
     * Does the real work of applying a pattern.
     *
    private void applyPattern(String pattern, boolean localized) {
        char zeroDigit         = PATTERN_ZERO_DIGIT;
        char groupingSeparator = PATTERN_GROUPING_SEPARATOR;
        char decimalSeparator  = PATTERN_DECIMAL_SEPARATOR;
        char percent           = PATTERN_PERCENT;
        char perMill           = PATTERN_PER_MILLE;
        char digit             = PATTERN_DIGIT;
        char separator         = PATTERN_SEPARATOR;
        String exponent          = PATTERN_EXPONENT;
        char minus             = PATTERN_MINUS;
        if (localized) {
            zeroDigit         = symbols.getZeroDigit();
            groupingSeparator = symbols.getGroupingSeparator();
            decimalSeparator  = symbols.getDecimalSeparator();
            percent           = symbols.getPercent();
            perMill           = symbols.getPerMill();
            digit             = symbols.getDigit();
            separator         = symbols.getPatternSeparator();
            exponent          = symbols.getExponentSeparator();
            minus             = symbols.getMinusSign();
        }
        boolean gotNegative = false;
        decimalSeparatorAlwaysShown = false;
        isCurrencyFormat = false;
        useExponentialNotation = false;

        // Two variables are used to record the subrange of the pattern
        // occupied by phase 1.  This is used during the processing of the
        // second pattern (the one representing negative numbers) to ensure
        // that no deviation exists in phase 1 between the two patterns.
        int phaseOneStart = 0;
        int phaseOneLength = 0;

        int start = 0;
        for (int j = 1; j >= 0 && start < pattern.length(); --j) {
            boolean inQuote = false;
            StringBuffer prefix = new StringBuffer();
            StringBuffer suffix = new StringBuffer();
            int decimalPos = -1;
            int multiplier = 1;
            int digitLeftCount = 0, zeroDigitCount = 0, digitRightCount = 0;
            byte groupingCount = -1;

            // The phase ranges from 0 to 2.  Phase 0 is the prefix.  Phase 1 is
            // the section of the pattern with digits, decimal separator,
            // grouping characters.  Phase 2 is the suffix.  In phases 0 and 2,
            // percent, per mille, and currency symbols are recognized and
            // translated.  The separation of the characters into phases is
            // strictly enforced; if phase 1 characters are to appear in the
            // suffix, for example, they must be quoted.
            int phase = 0;

            // The affix is either the prefix or the suffix.
            StringBuffer affix = prefix;

            for (int pos = start; pos < pattern.length(); ++pos) {
                char ch = pattern.charAt(pos);
                switch (phase) {
                case 0:
                case 2:
                    // Process the prefix / suffix characters
                    if (inQuote) {
                        // A quote within quotes indicates either the closing
                        // quote or two quotes, which is a quote literal. That
                        // is, we have the second quote in 'do' or 'don''t'.
                        if (ch == QUOTE) {
                            if ((pos+1) < pattern.length() &&
                                pattern.charAt(pos+1) == QUOTE) {
                                ++pos;
                                affix.append("''"); // 'don''t'
                            } else {
                                inQuote = false; // 'do'
                            }
                            continue;
                        }
                    } else {
                        // Process unquoted characters seen in prefix or suffix
                        // phase.
                        if (ch == digit ||
                            ch == zeroDigit ||
                            ch == groupingSeparator ||
                            ch == decimalSeparator) {
                            phase = 1;
                            if (j == 1) {
                                phaseOneStart = pos;
                            }
                            --pos; // Reprocess this character
                            continue;
                        } else if (ch == CURRENCY_SIGN) {
                            // Use lookahead to determine if the currency sign
                            // is doubled or not.
                            boolean doubled = (pos + 1) < pattern.length() &&
                                pattern.charAt(pos + 1) == CURRENCY_SIGN;
                            if (doubled) { // Skip over the doubled character
                             ++pos;
                            }
                            isCurrencyFormat = true;
                            affix.append(doubled ? "'\u00A4\u00A4" : "'\u00A4");
                            continue;
                        } else if (ch == QUOTE) {
                            // A quote outside quotes indicates either the
                            // opening quote or two quotes, which is a quote
                            // literal. That is, we have the first quote in 'do'
                            // or o''clock.
                            if (ch == QUOTE) {
                                if ((pos+1) < pattern.length() &&
                                    pattern.charAt(pos+1) == QUOTE) {
                                    ++pos;
                                    affix.append("''"); // o''clock
                                } else {
                                    inQuote = true; // 'do'
                                }
                                continue;
                            }
                        } else if (ch == separator) {
                            // Don't allow separators before we see digit
                            // characters of phase 1, and don't allow separators
                            // in the second pattern (j == 0).
                            if (phase == 0 || j == 0) {
                                throw new IllegalArgumentException("Unquoted special character '" +
                                    ch + "' in pattern \"" + pattern + '"');
                            }
                            start = pos + 1;
                            pos = pattern.length();
                            continue;
                        }

                        // Next handle characters which are appended directly.
                        else if (ch == percent) {
                            if (multiplier != 1) {
                                throw new IllegalArgumentException("Too many percent/per mille characters in pattern \"" +
                                    pattern + '"');
                            }
                            multiplier = 100;
                            affix.append("'%");
                            continue;
                        } else if (ch == perMill) {
                            if (multiplier != 1) {
                                throw new IllegalArgumentException("Too many percent/per mille characters in pattern \"" +
                                    pattern + '"');
                            }
                            multiplier = 1000;
                            affix.append("'\u2030");
                            continue;
                        } else if (ch == minus) {
                            affix.append("'-");
                            continue;
                        }
                    }
                    // Note that if we are within quotes, or if this is an
                    // unquoted, non-special character, then we usually fall
                    // through to here.
                    affix.append(ch);
                    break;

                case 1:
                    // Phase one must be identical in the two sub-patterns. We
                    // enforce this by doing a direct comparison. While
                    // processing the first sub-pattern, we just record its
                    // length. While processing the second, we compare
                    // characters.
                    if (j == 1) {
                        ++phaseOneLength;
                    } else {
                        if (--phaseOneLength == 0) {
                            phase = 2;
                            affix = suffix;
                        }
                        continue;
                    }

                    // Process the digits, decimal, and grouping characters. We
                    // record five pieces of information. We expect the digits
                    // to occur in the pattern ####0000.####, and we record the
                    // number of left digits, zero (central) digits, and right
                    // digits. The position of the last grouping character is
                    // recorded (should be somewhere within the first two blocks
                    // of characters), as is the position of the decimal point,
                    // if any (should be in the zero digits). If there is no
                    // decimal point, then there should be no right digits.
                    if (ch == digit) {
                        if (zeroDigitCount > 0) {
                            ++digitRightCount;
                        } else {
                            ++digitLeftCount;
                        }
                        if (groupingCount >= 0 && decimalPos < 0) {
                            ++groupingCount;
                        }
                    } else if (ch == zeroDigit) {
                        if (digitRightCount > 0) {
                            throw new IllegalArgumentException("Unexpected '0' in pattern \"" +
                                pattern + '"');
                        }
                        ++zeroDigitCount;
                        if (groupingCount >= 0 && decimalPos < 0) {
                            ++groupingCount;
                        }
                    } else if (ch == groupingSeparator) {
                        groupingCount = 0;
                    } else if (ch == decimalSeparator) {
                        if (decimalPos >= 0) {
                            throw new IllegalArgumentException("Multiple decimal separators in pattern \"" +
                                pattern + '"');
                        }
                        decimalPos = digitLeftCount + zeroDigitCount + digitRightCount;
                    } else if (pattern.regionMatches(pos, exponent, 0, exponent.length())){
                        if (useExponentialNotation) {
                            throw new IllegalArgumentException("Multiple exponential " +
                                "symbols in pattern \"" + pattern + '"');
                        }
                        useExponentialNotation = true;
                        minExponentDigits = 0;

                        // Use lookahead to parse out the exponential part
                        // of the pattern, then jump into phase 2.
                        pos = pos+exponent.length();
                         while (pos < pattern.length() &&
                               pattern.charAt(pos) == zeroDigit) {
                            ++minExponentDigits;
                            ++phaseOneLength;
                            ++pos;
                        }

                        if ((digitLeftCount + zeroDigitCount) < 1 ||
                            minExponentDigits < 1) {
                            throw new IllegalArgumentException("Malformed exponential " +
                                "pattern \"" + pattern + '"');
                        }

                        // Transition to phase 2
                        phase = 2;
                        affix = suffix;
                        --pos;
                        continue;
                    } else {
                        phase = 2;
                        affix = suffix;
                        --pos;
                        --phaseOneLength;
                        continue;
                    }
                    break;
                }
            }

            // Handle patterns with no '0' pattern character. These patterns
            // are legal, but must be interpreted.  "##.###" -> "#0.###".
            // ".###" -> ".0##".
            /* We allow patterns of the form "####" to produce a zeroDigitCount
             * of zero (got that?); although this seems like it might make it
             * possible for format() to produce empty strings, format() checks
             * for this condition and outputs a zero digit in this situation.
             * Having a zeroDigitCount of zero yields a minimum integer digits
             * of zero, which allows proper round-trip patterns.  That is, we
             * don't want "#" to become "#0" when toPattern() is called (even
             * though that's what it really is, semantically).
             *
            if (zeroDigitCount == 0 && digitLeftCount > 0 && decimalPos >= 0) {
                // Handle "###.###" and "###." and ".###"
                int n = decimalPos;
                if (n == 0) { // Handle ".###"
                    ++n;
                }
                digitRightCount = digitLeftCount - n;
                digitLeftCount = n - 1;
                zeroDigitCount = 1;
            }

            // Do syntax checking on the digits.
            if ((decimalPos < 0 && digitRightCount > 0) ||
                (decimalPos >= 0 && (decimalPos < digitLeftCount ||
                 decimalPos > (digitLeftCount + zeroDigitCount))) ||
                 groupingCount == 0 || inQuote) {
                throw new IllegalArgumentException("Malformed pattern \"" +
                    pattern + '"');
            }

            if (j == 1) {
                posPrefixPattern = prefix.toString();
                posSuffixPattern = suffix.toString();
                negPrefixPattern = posPrefixPattern;   // assume these for now
                negSuffixPattern = posSuffixPattern;
                int digitTotalCount = digitLeftCount + zeroDigitCount + digitRightCount;
                /* The effectiveDecimalPos is the position the decimal is at or
                 * would be at if there is no decimal. Note that if decimalPos<0,
                 * then digitTotalCount == digitLeftCount + zeroDigitCount.
                 *
                int effectiveDecimalPos = decimalPos >= 0 ?
                    decimalPos : digitTotalCount;
                setMinimumIntegerDigits(effectiveDecimalPos - digitLeftCount);
                setMaximumIntegerDigits(useExponentialNotation ?
                    digitLeftCount + getMinimumIntegerDigits() :
                    MAXIMUM_INTEGER_DIGITS);
                setMaximumFractionDigits(decimalPos >= 0 ?
                    (digitTotalCount - decimalPos) : 0);
                setMinimumFractionDigits(decimalPos >= 0 ?
                    (digitLeftCount + zeroDigitCount - decimalPos) : 0);
                setGroupingUsed(groupingCount > 0);
                this.groupingSize = (groupingCount > 0) ? groupingCount : 0;
                this.multiplier = multiplier;
                setDecimalSeparatorAlwaysShown(decimalPos == 0 ||
                    decimalPos == digitTotalCount);
            } else {
                negPrefixPattern = prefix.toString();
                negSuffixPattern = suffix.toString();
                gotNegative = true;
            }
        }

        if (pattern.length() == 0) {
            posPrefixPattern = posSuffixPattern = "";
            setMinimumIntegerDigits(0);
            setMaximumIntegerDigits(MAXIMUM_INTEGER_DIGITS);
            setMinimumFractionDigits(0);
            setMaximumFractionDigits(MAXIMUM_FRACTION_DIGITS);
        }

        // If there was no negative pattern, or if the negative pattern is
        // identical to the positive pattern, then prepend the minus sign to
        // the positive pattern to form the negative pattern.
        if (!gotNegative ||
            (negPrefixPattern.equals(posPrefixPattern)
             && negSuffixPattern.equals(posSuffixPattern))) {
            negSuffixPattern = posSuffixPattern;
            negPrefixPattern = "'-" + posPrefixPattern;
        }

        expandAffixes();
    }
    */
// END Android-removed: applyPattern(String, boolean) as apply[Localized]Pattern calls ICU directly.
@Override
public void setMaximumIntegerDigits(int newValue) {
    maximumIntegerDigits = Math.min(Math.max(0, newValue), MAXIMUM_INTEGER_DIGITS);
    super.setMaximumIntegerDigits((maximumIntegerDigits > DOUBLE_INTEGER_DIGITS) ? DOUBLE_INTEGER_DIGITS : maximumIntegerDigits);
    if (minimumIntegerDigits > maximumIntegerDigits) {
        minimumIntegerDigits = maximumIntegerDigits;
        super.setMinimumIntegerDigits((minimumIntegerDigits > DOUBLE_INTEGER_DIGITS) ? DOUBLE_INTEGER_DIGITS : minimumIntegerDigits);
    }
    // Android-changed: use ICU.
    icuDecimalFormat.setMaximumIntegerDigits(getMaximumIntegerDigits());
// Android-removed: fast path related code.
// fastPathCheckNeeded = true;
}
#method_after
// BEGIN Android-removed: applyPattern(String, boolean) as apply[Localized]Pattern calls ICU directly.
/*
    /**
     * Does the real work of applying a pattern.
     *
    private void applyPattern(String pattern, boolean localized) {
        char zeroDigit         = PATTERN_ZERO_DIGIT;
        char groupingSeparator = PATTERN_GROUPING_SEPARATOR;
        char decimalSeparator  = PATTERN_DECIMAL_SEPARATOR;
        char percent           = PATTERN_PERCENT;
        char perMill           = PATTERN_PER_MILLE;
        char digit             = PATTERN_DIGIT;
        char separator         = PATTERN_SEPARATOR;
        String exponent          = PATTERN_EXPONENT;
        char minus             = PATTERN_MINUS;
        if (localized) {
            zeroDigit         = symbols.getZeroDigit();
            groupingSeparator = symbols.getGroupingSeparator();
            decimalSeparator  = symbols.getDecimalSeparator();
            percent           = symbols.getPercent();
            perMill           = symbols.getPerMill();
            digit             = symbols.getDigit();
            separator         = symbols.getPatternSeparator();
            exponent          = symbols.getExponentSeparator();
            minus             = symbols.getMinusSign();
        }
        boolean gotNegative = false;
        decimalSeparatorAlwaysShown = false;
        isCurrencyFormat = false;
        useExponentialNotation = false;

        // Two variables are used to record the subrange of the pattern
        // occupied by phase 1.  This is used during the processing of the
        // second pattern (the one representing negative numbers) to ensure
        // that no deviation exists in phase 1 between the two patterns.
        int phaseOneStart = 0;
        int phaseOneLength = 0;

        int start = 0;
        for (int j = 1; j >= 0 && start < pattern.length(); --j) {
            boolean inQuote = false;
            StringBuffer prefix = new StringBuffer();
            StringBuffer suffix = new StringBuffer();
            int decimalPos = -1;
            int multiplier = 1;
            int digitLeftCount = 0, zeroDigitCount = 0, digitRightCount = 0;
            byte groupingCount = -1;

            // The phase ranges from 0 to 2.  Phase 0 is the prefix.  Phase 1 is
            // the section of the pattern with digits, decimal separator,
            // grouping characters.  Phase 2 is the suffix.  In phases 0 and 2,
            // percent, per mille, and currency symbols are recognized and
            // translated.  The separation of the characters into phases is
            // strictly enforced; if phase 1 characters are to appear in the
            // suffix, for example, they must be quoted.
            int phase = 0;

            // The affix is either the prefix or the suffix.
            StringBuffer affix = prefix;

            for (int pos = start; pos < pattern.length(); ++pos) {
                char ch = pattern.charAt(pos);
                switch (phase) {
                case 0:
                case 2:
                    // Process the prefix / suffix characters
                    if (inQuote) {
                        // A quote within quotes indicates either the closing
                        // quote or two quotes, which is a quote literal. That
                        // is, we have the second quote in 'do' or 'don''t'.
                        if (ch == QUOTE) {
                            if ((pos+1) < pattern.length() &&
                                pattern.charAt(pos+1) == QUOTE) {
                                ++pos;
                                affix.append("''"); // 'don''t'
                            } else {
                                inQuote = false; // 'do'
                            }
                            continue;
                        }
                    } else {
                        // Process unquoted characters seen in prefix or suffix
                        // phase.
                        if (ch == digit ||
                            ch == zeroDigit ||
                            ch == groupingSeparator ||
                            ch == decimalSeparator) {
                            phase = 1;
                            if (j == 1) {
                                phaseOneStart = pos;
                            }
                            --pos; // Reprocess this character
                            continue;
                        } else if (ch == CURRENCY_SIGN) {
                            // Use lookahead to determine if the currency sign
                            // is doubled or not.
                            boolean doubled = (pos + 1) < pattern.length() &&
                                pattern.charAt(pos + 1) == CURRENCY_SIGN;
                            if (doubled) { // Skip over the doubled character
                             ++pos;
                            }
                            isCurrencyFormat = true;
                            affix.append(doubled ? "'\u00A4\u00A4" : "'\u00A4");
                            continue;
                        } else if (ch == QUOTE) {
                            // A quote outside quotes indicates either the
                            // opening quote or two quotes, which is a quote
                            // literal. That is, we have the first quote in 'do'
                            // or o''clock.
                            if (ch == QUOTE) {
                                if ((pos+1) < pattern.length() &&
                                    pattern.charAt(pos+1) == QUOTE) {
                                    ++pos;
                                    affix.append("''"); // o''clock
                                } else {
                                    inQuote = true; // 'do'
                                }
                                continue;
                            }
                        } else if (ch == separator) {
                            // Don't allow separators before we see digit
                            // characters of phase 1, and don't allow separators
                            // in the second pattern (j == 0).
                            if (phase == 0 || j == 0) {
                                throw new IllegalArgumentException("Unquoted special character '" +
                                    ch + "' in pattern \"" + pattern + '"');
                            }
                            start = pos + 1;
                            pos = pattern.length();
                            continue;
                        }

                        // Next handle characters which are appended directly.
                        else if (ch == percent) {
                            if (multiplier != 1) {
                                throw new IllegalArgumentException("Too many percent/per mille characters in pattern \"" +
                                    pattern + '"');
                            }
                            multiplier = 100;
                            affix.append("'%");
                            continue;
                        } else if (ch == perMill) {
                            if (multiplier != 1) {
                                throw new IllegalArgumentException("Too many percent/per mille characters in pattern \"" +
                                    pattern + '"');
                            }
                            multiplier = 1000;
                            affix.append("'\u2030");
                            continue;
                        } else if (ch == minus) {
                            affix.append("'-");
                            continue;
                        }
                    }
                    // Note that if we are within quotes, or if this is an
                    // unquoted, non-special character, then we usually fall
                    // through to here.
                    affix.append(ch);
                    break;

                case 1:
                    // Phase one must be identical in the two sub-patterns. We
                    // enforce this by doing a direct comparison. While
                    // processing the first sub-pattern, we just record its
                    // length. While processing the second, we compare
                    // characters.
                    if (j == 1) {
                        ++phaseOneLength;
                    } else {
                        if (--phaseOneLength == 0) {
                            phase = 2;
                            affix = suffix;
                        }
                        continue;
                    }

                    // Process the digits, decimal, and grouping characters. We
                    // record five pieces of information. We expect the digits
                    // to occur in the pattern ####0000.####, and we record the
                    // number of left digits, zero (central) digits, and right
                    // digits. The position of the last grouping character is
                    // recorded (should be somewhere within the first two blocks
                    // of characters), as is the position of the decimal point,
                    // if any (should be in the zero digits). If there is no
                    // decimal point, then there should be no right digits.
                    if (ch == digit) {
                        if (zeroDigitCount > 0) {
                            ++digitRightCount;
                        } else {
                            ++digitLeftCount;
                        }
                        if (groupingCount >= 0 && decimalPos < 0) {
                            ++groupingCount;
                        }
                    } else if (ch == zeroDigit) {
                        if (digitRightCount > 0) {
                            throw new IllegalArgumentException("Unexpected '0' in pattern \"" +
                                pattern + '"');
                        }
                        ++zeroDigitCount;
                        if (groupingCount >= 0 && decimalPos < 0) {
                            ++groupingCount;
                        }
                    } else if (ch == groupingSeparator) {
                        groupingCount = 0;
                    } else if (ch == decimalSeparator) {
                        if (decimalPos >= 0) {
                            throw new IllegalArgumentException("Multiple decimal separators in pattern \"" +
                                pattern + '"');
                        }
                        decimalPos = digitLeftCount + zeroDigitCount + digitRightCount;
                    } else if (pattern.regionMatches(pos, exponent, 0, exponent.length())){
                        if (useExponentialNotation) {
                            throw new IllegalArgumentException("Multiple exponential " +
                                "symbols in pattern \"" + pattern + '"');
                        }
                        useExponentialNotation = true;
                        minExponentDigits = 0;

                        // Use lookahead to parse out the exponential part
                        // of the pattern, then jump into phase 2.
                        pos = pos+exponent.length();
                         while (pos < pattern.length() &&
                               pattern.charAt(pos) == zeroDigit) {
                            ++minExponentDigits;
                            ++phaseOneLength;
                            ++pos;
                        }

                        if ((digitLeftCount + zeroDigitCount) < 1 ||
                            minExponentDigits < 1) {
                            throw new IllegalArgumentException("Malformed exponential " +
                                "pattern \"" + pattern + '"');
                        }

                        // Transition to phase 2
                        phase = 2;
                        affix = suffix;
                        --pos;
                        continue;
                    } else {
                        phase = 2;
                        affix = suffix;
                        --pos;
                        --phaseOneLength;
                        continue;
                    }
                    break;
                }
            }

            // Handle patterns with no '0' pattern character. These patterns
            // are legal, but must be interpreted.  "##.###" -> "#0.###".
            // ".###" -> ".0##".
            /* We allow patterns of the form "####" to produce a zeroDigitCount
             * of zero (got that?); although this seems like it might make it
             * possible for format() to produce empty strings, format() checks
             * for this condition and outputs a zero digit in this situation.
             * Having a zeroDigitCount of zero yields a minimum integer digits
             * of zero, which allows proper round-trip patterns.  That is, we
             * don't want "#" to become "#0" when toPattern() is called (even
             * though that's what it really is, semantically).
             *
            if (zeroDigitCount == 0 && digitLeftCount > 0 && decimalPos >= 0) {
                // Handle "###.###" and "###." and ".###"
                int n = decimalPos;
                if (n == 0) { // Handle ".###"
                    ++n;
                }
                digitRightCount = digitLeftCount - n;
                digitLeftCount = n - 1;
                zeroDigitCount = 1;
            }

            // Do syntax checking on the digits.
            if ((decimalPos < 0 && digitRightCount > 0) ||
                (decimalPos >= 0 && (decimalPos < digitLeftCount ||
                 decimalPos > (digitLeftCount + zeroDigitCount))) ||
                 groupingCount == 0 || inQuote) {
                throw new IllegalArgumentException("Malformed pattern \"" +
                    pattern + '"');
            }

            if (j == 1) {
                posPrefixPattern = prefix.toString();
                posSuffixPattern = suffix.toString();
                negPrefixPattern = posPrefixPattern;   // assume these for now
                negSuffixPattern = posSuffixPattern;
                int digitTotalCount = digitLeftCount + zeroDigitCount + digitRightCount;
                /* The effectiveDecimalPos is the position the decimal is at or
                 * would be at if there is no decimal. Note that if decimalPos<0,
                 * then digitTotalCount == digitLeftCount + zeroDigitCount.
                 *
                int effectiveDecimalPos = decimalPos >= 0 ?
                    decimalPos : digitTotalCount;
                setMinimumIntegerDigits(effectiveDecimalPos - digitLeftCount);
                setMaximumIntegerDigits(useExponentialNotation ?
                    digitLeftCount + getMinimumIntegerDigits() :
                    MAXIMUM_INTEGER_DIGITS);
                setMaximumFractionDigits(decimalPos >= 0 ?
                    (digitTotalCount - decimalPos) : 0);
                setMinimumFractionDigits(decimalPos >= 0 ?
                    (digitLeftCount + zeroDigitCount - decimalPos) : 0);
                setGroupingUsed(groupingCount > 0);
                this.groupingSize = (groupingCount > 0) ? groupingCount : 0;
                this.multiplier = multiplier;
                setDecimalSeparatorAlwaysShown(decimalPos == 0 ||
                    decimalPos == digitTotalCount);
            } else {
                negPrefixPattern = prefix.toString();
                negSuffixPattern = suffix.toString();
                gotNegative = true;
            }
        }

        if (pattern.length() == 0) {
            posPrefixPattern = posSuffixPattern = "";
            setMinimumIntegerDigits(0);
            setMaximumIntegerDigits(MAXIMUM_INTEGER_DIGITS);
            setMinimumFractionDigits(0);
            setMaximumFractionDigits(MAXIMUM_FRACTION_DIGITS);
        }

        // If there was no negative pattern, or if the negative pattern is
        // identical to the positive pattern, then prepend the minus sign to
        // the positive pattern to form the negative pattern.
        if (!gotNegative ||
            (negPrefixPattern.equals(posPrefixPattern)
             && negSuffixPattern.equals(posSuffixPattern))) {
            negSuffixPattern = posSuffixPattern;
            negPrefixPattern = "'-" + posPrefixPattern;
        }

        expandAffixes();
    }
    */
// END Android-removed: applyPattern(String, boolean) as apply[Localized]Pattern calls ICU directly.
@Override
public void setMaximumIntegerDigits(int newValue) {
    maximumIntegerDigits = Math.min(Math.max(0, newValue), MAXIMUM_INTEGER_DIGITS);
    super.setMaximumIntegerDigits((maximumIntegerDigits > DOUBLE_INTEGER_DIGITS) ? DOUBLE_INTEGER_DIGITS : maximumIntegerDigits);
    if (minimumIntegerDigits > maximumIntegerDigits) {
        minimumIntegerDigits = maximumIntegerDigits;
        super.setMinimumIntegerDigits((minimumIntegerDigits > DOUBLE_INTEGER_DIGITS) ? DOUBLE_INTEGER_DIGITS : minimumIntegerDigits);
    }
    // Android-added: use ICU.
    icuDecimalFormat.setMaximumIntegerDigits(getMaximumIntegerDigits());
// Android-removed: fast path related code.
// fastPathCheckNeeded = true;
}
#end_block

#method_before
@Override
public void setMinimumIntegerDigits(int newValue) {
    minimumIntegerDigits = Math.min(Math.max(0, newValue), MAXIMUM_INTEGER_DIGITS);
    super.setMinimumIntegerDigits((minimumIntegerDigits > DOUBLE_INTEGER_DIGITS) ? DOUBLE_INTEGER_DIGITS : minimumIntegerDigits);
    if (minimumIntegerDigits > maximumIntegerDigits) {
        maximumIntegerDigits = minimumIntegerDigits;
        super.setMaximumIntegerDigits((maximumIntegerDigits > DOUBLE_INTEGER_DIGITS) ? DOUBLE_INTEGER_DIGITS : maximumIntegerDigits);
    }
    // Android-changed: use ICU.
    icuDecimalFormat.setMinimumIntegerDigits(getMinimumIntegerDigits());
// Android-removed: fast path related code.
// fastPathCheckNeeded = true;
}
#method_after
@Override
public void setMinimumIntegerDigits(int newValue) {
    minimumIntegerDigits = Math.min(Math.max(0, newValue), MAXIMUM_INTEGER_DIGITS);
    super.setMinimumIntegerDigits((minimumIntegerDigits > DOUBLE_INTEGER_DIGITS) ? DOUBLE_INTEGER_DIGITS : minimumIntegerDigits);
    if (minimumIntegerDigits > maximumIntegerDigits) {
        maximumIntegerDigits = minimumIntegerDigits;
        super.setMaximumIntegerDigits((maximumIntegerDigits > DOUBLE_INTEGER_DIGITS) ? DOUBLE_INTEGER_DIGITS : maximumIntegerDigits);
    }
    // Android-added: use ICU.
    icuDecimalFormat.setMinimumIntegerDigits(getMinimumIntegerDigits());
// Android-removed: fast path related code.
// fastPathCheckNeeded = true;
}
#end_block

#method_before
@Override
public void setMaximumFractionDigits(int newValue) {
    maximumFractionDigits = Math.min(Math.max(0, newValue), MAXIMUM_FRACTION_DIGITS);
    super.setMaximumFractionDigits((maximumFractionDigits > DOUBLE_FRACTION_DIGITS) ? DOUBLE_FRACTION_DIGITS : maximumFractionDigits);
    if (minimumFractionDigits > maximumFractionDigits) {
        minimumFractionDigits = maximumFractionDigits;
        super.setMinimumFractionDigits((minimumFractionDigits > DOUBLE_FRACTION_DIGITS) ? DOUBLE_FRACTION_DIGITS : minimumFractionDigits);
    }
    // Android-changed: use ICU.
    icuDecimalFormat.setMaximumFractionDigits(getMaximumFractionDigits());
// Android-removed: fast path related code.
// fastPathCheckNeeded = true;
}
#method_after
@Override
public void setMaximumFractionDigits(int newValue) {
    maximumFractionDigits = Math.min(Math.max(0, newValue), MAXIMUM_FRACTION_DIGITS);
    super.setMaximumFractionDigits((maximumFractionDigits > DOUBLE_FRACTION_DIGITS) ? DOUBLE_FRACTION_DIGITS : maximumFractionDigits);
    if (minimumFractionDigits > maximumFractionDigits) {
        minimumFractionDigits = maximumFractionDigits;
        super.setMinimumFractionDigits((minimumFractionDigits > DOUBLE_FRACTION_DIGITS) ? DOUBLE_FRACTION_DIGITS : minimumFractionDigits);
    }
    // Android-added: use ICU.
    icuDecimalFormat.setMaximumFractionDigits(getMaximumFractionDigits());
// Android-removed: fast path related code.
// fastPathCheckNeeded = true;
}
#end_block

#method_before
@Override
public void setMinimumFractionDigits(int newValue) {
    minimumFractionDigits = Math.min(Math.max(0, newValue), MAXIMUM_FRACTION_DIGITS);
    super.setMinimumFractionDigits((minimumFractionDigits > DOUBLE_FRACTION_DIGITS) ? DOUBLE_FRACTION_DIGITS : minimumFractionDigits);
    if (minimumFractionDigits > maximumFractionDigits) {
        maximumFractionDigits = minimumFractionDigits;
        super.setMaximumFractionDigits((maximumFractionDigits > DOUBLE_FRACTION_DIGITS) ? DOUBLE_FRACTION_DIGITS : maximumFractionDigits);
    }
    // Android-changed: use ICU.
    icuDecimalFormat.setMinimumFractionDigits(getMinimumFractionDigits());
// Android-removed: fast path related code.
// fastPathCheckNeeded = true;
}
#method_after
@Override
public void setMinimumFractionDigits(int newValue) {
    minimumFractionDigits = Math.min(Math.max(0, newValue), MAXIMUM_FRACTION_DIGITS);
    super.setMinimumFractionDigits((minimumFractionDigits > DOUBLE_FRACTION_DIGITS) ? DOUBLE_FRACTION_DIGITS : minimumFractionDigits);
    if (minimumFractionDigits > maximumFractionDigits) {
        maximumFractionDigits = minimumFractionDigits;
        super.setMaximumFractionDigits((maximumFractionDigits > DOUBLE_FRACTION_DIGITS) ? DOUBLE_FRACTION_DIGITS : maximumFractionDigits);
    }
    // Android-added: use ICU.
    icuDecimalFormat.setMinimumFractionDigits(getMinimumFractionDigits());
// Android-removed: fast path related code.
// fastPathCheckNeeded = true;
}
#end_block

#method_before
// BEGIN Android-added: Upstream code from earlier OpenJDK release.
// This method was removed in OpenJDK 8 in favor of doing equivalent work in the provider. Since
// Android removed support for providers for NumberFormat we keep this method around as an
// "Android addition".
void adjustForCurrencyDefaultFractionDigits() {
    Currency currency = symbols.getCurrency();
    if (currency == null) {
        try {
            currency = Currency.getInstance(symbols.getInternationalCurrencySymbol());
        } catch (IllegalArgumentException e) {
        }
    }
    if (currency != null) {
        int digits = currency.getDefaultFractionDigits();
        if (digits != -1) {
            int oldMinDigits = getMinimumFractionDigits();
            // Try to adjust all of them in a reasonable way.
            if (oldMinDigits == getMaximumFractionDigits()) {
                setMinimumFractionDigits(digits);
                setMaximumFractionDigits(digits);
            } else {
                setMinimumFractionDigits(Math.min(digits, oldMinDigits));
                setMaximumFractionDigits(digits);
            }
        }
    }
}
#method_after
// BEGIN Android-added: Upstream code from OpenJDK 7u40 release.
// This method was removed in OpenJDK 8 in favor of doing equivalent work in the provider. Since
// Android removed support for providers for NumberFormat we keep this method around as an
// "Android addition".
void adjustForCurrencyDefaultFractionDigits() {
    Currency currency = symbols.getCurrency();
    if (currency == null) {
        try {
            currency = Currency.getInstance(symbols.getInternationalCurrencySymbol());
        } catch (IllegalArgumentException e) {
        }
    }
    if (currency != null) {
        int digits = currency.getDefaultFractionDigits();
        if (digits != -1) {
            int oldMinDigits = getMinimumFractionDigits();
            // Try to adjust all of them in a reasonable way.
            if (oldMinDigits == getMaximumFractionDigits()) {
                setMinimumFractionDigits(digits);
                setMaximumFractionDigits(digits);
            } else {
                setMinimumFractionDigits(Math.min(digits, oldMinDigits));
                setMaximumFractionDigits(digits);
            }
        }
    }
}
#end_block

#method_before
// END Android-added: Custom serialization code for compatibility with RI serialization.
private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException {
    // BEGIN Android-added: Custom serialization code for compatibility with RI serialization.
    /*
        stream.defaultReadObject();
        digitList = new DigitList();

        // We force complete fast-path reinitialization when the instance is
        // deserialized. See clone() comment on fastPathCheckNeeded.
        fastPathCheckNeeded = true;
        isFastPath = false;
        fastPathData = null;

        if (serialVersionOnStream < 4) {
            setRoundingMode(RoundingMode.HALF_EVEN);
        } else {
            setRoundingMode(getRoundingMode());
        }

        // We only need to check the maximum counts because NumberFormat
        // .readObject has already ensured that the maximum is greater than the
        // minimum count.
        if (super.getMaximumIntegerDigits() > DOUBLE_INTEGER_DIGITS ||
            super.getMaximumFractionDigits() > DOUBLE_FRACTION_DIGITS) {
            throw new InvalidObjectException("Digit count out of range");
        }
        if (serialVersionOnStream < 3) {
            setMaximumIntegerDigits(super.getMaximumIntegerDigits());
            setMinimumIntegerDigits(super.getMinimumIntegerDigits());
            setMaximumFractionDigits(super.getMaximumFractionDigits());
            setMinimumFractionDigits(super.getMinimumFractionDigits());
        }
        if (serialVersionOnStream < 1) {
            // Didn't have exponential fields
            useExponentialNotation = false;
        }
        serialVersionOnStream = currentSerialVersion;
        */
    ObjectInputStream.GetField fields = stream.readFields();
    this.symbols = (DecimalFormatSymbols) fields.get("symbols", null);
    initPattern("#");
    // Calling a setter method on an ICU DecimalFormat object will change the object's internal
    // state, even if the value set is the same as the default value (ICU Ticket #13266).
    // 
    // In an attempt to create objects that are equals() to the ones that were serialized, it's
    // therefore assumed here that any values that are the same as the default values were the
    // default values (ie. no setter was called to explicitly set that value).
    String positivePrefix = (String) fields.get("positivePrefix", "");
    if (!Objects.equals(positivePrefix, icuDecimalFormat.getPositivePrefix())) {
        icuDecimalFormat.setPositivePrefix(positivePrefix);
    }
    String positiveSuffix = (String) fields.get("positiveSuffix", "");
    if (!Objects.equals(positiveSuffix, icuDecimalFormat.getPositiveSuffix())) {
        icuDecimalFormat.setPositiveSuffix(positiveSuffix);
    }
    String negativePrefix = (String) fields.get("negativePrefix", "-");
    if (!Objects.equals(negativePrefix, icuDecimalFormat.getNegativePrefix())) {
        icuDecimalFormat.setNegativePrefix(negativePrefix);
    }
    String negativeSuffix = (String) fields.get("negativeSuffix", "");
    if (!Objects.equals(negativeSuffix, icuDecimalFormat.getNegativeSuffix())) {
        icuDecimalFormat.setNegativeSuffix(negativeSuffix);
    }
    int multiplier = fields.get("multiplier", 1);
    if (multiplier != icuDecimalFormat.getMultiplier()) {
        icuDecimalFormat.setMultiplier(multiplier);
    }
    boolean groupingUsed = fields.get("groupingUsed", true);
    if (groupingUsed != icuDecimalFormat.isGroupingUsed()) {
        icuDecimalFormat.setGroupingUsed(groupingUsed);
    }
    int groupingSize = fields.get("groupingSize", (byte) 3);
    if (groupingSize != icuDecimalFormat.getGroupingSize()) {
        icuDecimalFormat.setGroupingSize(groupingSize);
    }
    boolean decimalSeparatorAlwaysShown = fields.get("decimalSeparatorAlwaysShown", false);
    if (decimalSeparatorAlwaysShown != icuDecimalFormat.isDecimalSeparatorAlwaysShown()) {
        icuDecimalFormat.setDecimalSeparatorAlwaysShown(decimalSeparatorAlwaysShown);
    }
    RoundingMode roundingMode = (RoundingMode) fields.get("roundingMode", RoundingMode.HALF_EVEN);
    if (convertRoundingMode(roundingMode) != icuDecimalFormat.getRoundingMode()) {
        setRoundingMode(roundingMode);
    }
    int maximumIntegerDigits = fields.get("maximumIntegerDigits", 309);
    if (maximumIntegerDigits != icuDecimalFormat.getMaximumIntegerDigits()) {
        icuDecimalFormat.setMaximumIntegerDigits(maximumIntegerDigits);
    }
    int minimumIntegerDigits = fields.get("minimumIntegerDigits", 309);
    if (minimumIntegerDigits != icuDecimalFormat.getMinimumIntegerDigits()) {
        icuDecimalFormat.setMinimumIntegerDigits(minimumIntegerDigits);
    }
    int maximumFractionDigits = fields.get("maximumFractionDigits", 340);
    if (maximumFractionDigits != icuDecimalFormat.getMaximumFractionDigits()) {
        icuDecimalFormat.setMaximumFractionDigits(maximumFractionDigits);
    }
    int minimumFractionDigits = fields.get("minimumFractionDigits", 340);
    if (minimumFractionDigits != icuDecimalFormat.getMinimumFractionDigits()) {
        icuDecimalFormat.setMinimumFractionDigits(minimumFractionDigits);
    }
    boolean parseBigDecimal = fields.get("parseBigDecimal", true);
    if (parseBigDecimal != icuDecimalFormat.isParseBigDecimal()) {
        icuDecimalFormat.setParseBigDecimal(parseBigDecimal);
    }
    updateFieldsFromIcu();
    if (fields.get("serialVersionOnStream", 0) < 3) {
        setMaximumIntegerDigits(super.getMaximumIntegerDigits());
        setMinimumIntegerDigits(super.getMinimumIntegerDigits());
        setMaximumFractionDigits(super.getMaximumFractionDigits());
        setMinimumFractionDigits(super.getMinimumFractionDigits());
    }
// END Android-added: Custom serialization code for compatibility with RI serialization.
}
#method_after
// END Android-added: Custom serialization code for compatibility with RI serialization.
private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException {
    // BEGIN Android-changed: Custom serialization code for compatibility with RI serialization.
    /*
        stream.defaultReadObject();
        digitList = new DigitList();

        // We force complete fast-path reinitialization when the instance is
        // deserialized. See clone() comment on fastPathCheckNeeded.
        fastPathCheckNeeded = true;
        isFastPath = false;
        fastPathData = null;

        if (serialVersionOnStream < 4) {
            setRoundingMode(RoundingMode.HALF_EVEN);
        } else {
            setRoundingMode(getRoundingMode());
        }

        // We only need to check the maximum counts because NumberFormat
        // .readObject has already ensured that the maximum is greater than the
        // minimum count.
        if (super.getMaximumIntegerDigits() > DOUBLE_INTEGER_DIGITS ||
            super.getMaximumFractionDigits() > DOUBLE_FRACTION_DIGITS) {
            throw new InvalidObjectException("Digit count out of range");
        }
        if (serialVersionOnStream < 3) {
            setMaximumIntegerDigits(super.getMaximumIntegerDigits());
            setMinimumIntegerDigits(super.getMinimumIntegerDigits());
            setMaximumFractionDigits(super.getMaximumFractionDigits());
            setMinimumFractionDigits(super.getMinimumFractionDigits());
        }
        if (serialVersionOnStream < 1) {
            // Didn't have exponential fields
            useExponentialNotation = false;
        }
        serialVersionOnStream = currentSerialVersion;
        */
    ObjectInputStream.GetField fields = stream.readFields();
    this.symbols = (DecimalFormatSymbols) fields.get("symbols", null);
    initPattern("#");
    // Calling a setter method on an ICU DecimalFormat object will change the object's internal
    // state, even if the value set is the same as the default value (ICU Ticket #13266).
    // 
    // In an attempt to create objects that are equals() to the ones that were serialized, it's
    // therefore assumed here that any values that are the same as the default values were the
    // default values (ie. no setter was called to explicitly set that value).
    String positivePrefix = (String) fields.get("positivePrefix", "");
    if (!Objects.equals(positivePrefix, icuDecimalFormat.getPositivePrefix())) {
        icuDecimalFormat.setPositivePrefix(positivePrefix);
    }
    String positiveSuffix = (String) fields.get("positiveSuffix", "");
    if (!Objects.equals(positiveSuffix, icuDecimalFormat.getPositiveSuffix())) {
        icuDecimalFormat.setPositiveSuffix(positiveSuffix);
    }
    String negativePrefix = (String) fields.get("negativePrefix", "-");
    if (!Objects.equals(negativePrefix, icuDecimalFormat.getNegativePrefix())) {
        icuDecimalFormat.setNegativePrefix(negativePrefix);
    }
    String negativeSuffix = (String) fields.get("negativeSuffix", "");
    if (!Objects.equals(negativeSuffix, icuDecimalFormat.getNegativeSuffix())) {
        icuDecimalFormat.setNegativeSuffix(negativeSuffix);
    }
    int multiplier = fields.get("multiplier", 1);
    if (multiplier != icuDecimalFormat.getMultiplier()) {
        icuDecimalFormat.setMultiplier(multiplier);
    }
    boolean groupingUsed = fields.get("groupingUsed", true);
    if (groupingUsed != icuDecimalFormat.isGroupingUsed()) {
        icuDecimalFormat.setGroupingUsed(groupingUsed);
    }
    int groupingSize = fields.get("groupingSize", (byte) 3);
    if (groupingSize != icuDecimalFormat.getGroupingSize()) {
        icuDecimalFormat.setGroupingSize(groupingSize);
    }
    boolean decimalSeparatorAlwaysShown = fields.get("decimalSeparatorAlwaysShown", false);
    if (decimalSeparatorAlwaysShown != icuDecimalFormat.isDecimalSeparatorAlwaysShown()) {
        icuDecimalFormat.setDecimalSeparatorAlwaysShown(decimalSeparatorAlwaysShown);
    }
    RoundingMode roundingMode = (RoundingMode) fields.get("roundingMode", RoundingMode.HALF_EVEN);
    if (convertRoundingMode(roundingMode) != icuDecimalFormat.getRoundingMode()) {
        setRoundingMode(roundingMode);
    }
    int maximumIntegerDigits = fields.get("maximumIntegerDigits", 309);
    if (maximumIntegerDigits != icuDecimalFormat.getMaximumIntegerDigits()) {
        icuDecimalFormat.setMaximumIntegerDigits(maximumIntegerDigits);
    }
    int minimumIntegerDigits = fields.get("minimumIntegerDigits", 309);
    if (minimumIntegerDigits != icuDecimalFormat.getMinimumIntegerDigits()) {
        icuDecimalFormat.setMinimumIntegerDigits(minimumIntegerDigits);
    }
    int maximumFractionDigits = fields.get("maximumFractionDigits", 340);
    if (maximumFractionDigits != icuDecimalFormat.getMaximumFractionDigits()) {
        icuDecimalFormat.setMaximumFractionDigits(maximumFractionDigits);
    }
    int minimumFractionDigits = fields.get("minimumFractionDigits", 340);
    if (minimumFractionDigits != icuDecimalFormat.getMinimumFractionDigits()) {
        icuDecimalFormat.setMinimumFractionDigits(minimumFractionDigits);
    }
    boolean parseBigDecimal = fields.get("parseBigDecimal", true);
    if (parseBigDecimal != icuDecimalFormat.isParseBigDecimal()) {
        icuDecimalFormat.setParseBigDecimal(parseBigDecimal);
    }
    updateFieldsFromIcu();
    if (fields.get("serialVersionOnStream", 0) < 3) {
        setMaximumIntegerDigits(super.getMaximumIntegerDigits());
        setMinimumIntegerDigits(super.getMinimumIntegerDigits());
        setMaximumFractionDigits(super.getMaximumFractionDigits());
        setMinimumFractionDigits(super.getMinimumFractionDigits());
    }
// END Android-changed: Custom serialization code for compatibility with RI serialization.
}
#end_block

#method_before
private void updateEndItems() {
    if (mRowContent == null) {
        return;
    }
    mEndContainer.removeAllViews();
    // If we're here we can can show end items; check for top level actions first
    List endItems = mRowContent.getEndItems();
    if (mHeaderActions != null) {
        // Use these if we have them instead
        endItems = mHeaderActions;
    }
    // Add start item to end of row for the top row if end items are empty.
    if (mRowIndex == 0 && mStartItem != null && endItems.isEmpty()) {
        endItems.add(mStartItem);
    }
    // If we're here we might be able to show end items
    int endItemCount = 0;
    boolean firstItemIsADefaultToggle = false;
    SliceItem endAction = null;
    for (int i = 0; i < endItems.size(); i++) {
        final SliceItem endItem = (endItems.get(i) instanceof SliceItem) ? (SliceItem) endItems.get(i) : ((SliceActionImpl) endItems.get(i)).getSliceItem();
        if (endItemCount < MAX_END_ITEMS) {
            if (addItem(endItem, mTintColor, false)) {
                if (endAction == null && SliceQuery.find(endItem, FORMAT_ACTION) != null) {
                    endAction = endItem;
                }
                endItemCount++;
                if (endItemCount == 1) {
                    firstItemIsADefaultToggle = !mToggles.isEmpty() && SliceQuery.find(endItem.getSlice(), FORMAT_IMAGE) == null;
                }
            }
        }
    }
    mEndContainer.setVisibility(endItemCount > 0 ? VISIBLE : GONE);
    // If there is a row action and the first end item is a default toggle, or action divider
    // is set by builder, show the divider.
    mDivider.setVisibility((mRowAction != null && firstItemIsADefaultToggle) || mRowContent.hasActionDivider() ? View.VISIBLE : View.GONE);
    boolean hasStartAction = mStartItem != null && SliceQuery.find(mStartItem, FORMAT_ACTION) != null;
    boolean hasEndItemAction = endAction != null;
    boolean endAndRowActionTheSame = false;
    if (mRowAction != null) {
        setViewClickable(mRootView, true);
    } else if (hasEndItemAction != hasStartAction && (endItemCount == 1 || hasStartAction)) {
        // This row only has 1 action in start or end position; make whole row clickable for it
        endAndRowActionTheSame = true;
        if (!mToggles.isEmpty()) {
            mRowAction = mToggles.keySet().iterator().next();
        } else if (!mActions.isEmpty() && mActions.size() == 1) {
            mRowAction = mActions.valueAt(0).getAction();
        }
        setViewClickable(mRootView, true);
    }
    if (mRowAction != null && !endAndRowActionTheSame && mLoadingActions.contains(mRowAction.getSliceItem())) {
        mShowActionSpinner = true;
    }
}
#method_after
private void updateEndItems() {
    if (mRowContent == null) {
        return;
    }
    mEndContainer.removeAllViews();
    // If we're here we can can show end items; check for top level actions first
    List endItems = mRowContent.getEndItems();
    if (mHeaderActions != null) {
        // Use these if we have them instead
        endItems = mHeaderActions;
    }
    // Add start item to end of row for the top row if end items are empty.
    if (mRowIndex == 0 && mStartItem != null && endItems.isEmpty()) {
        endItems.add(mStartItem);
    }
    // If we're here we might be able to show end items
    int endItemCount = 0;
    boolean firstItemIsADefaultToggle = false;
    boolean singleActionAtTheEnd = false;
    SliceItem endAction = null;
    for (int i = 0; i < endItems.size(); i++) {
        final SliceItem endItem = (endItems.get(i) instanceof SliceItem) ? (SliceItem) endItems.get(i) : ((SliceActionImpl) endItems.get(i)).getSliceItem();
        if (endItemCount < MAX_END_ITEMS) {
            if (addItem(endItem, mTintColor, false)) {
                if (endAction == null && SliceQuery.find(endItem, FORMAT_ACTION) != null) {
                    endAction = endItem;
                }
                endItemCount++;
                if (endItemCount == 1) {
                    firstItemIsADefaultToggle = !mToggles.isEmpty() && SliceQuery.find(endItem.getSlice(), FORMAT_IMAGE) == null;
                    singleActionAtTheEnd = endItems.size() == 1 && SliceQuery.find(endItem, FORMAT_ACTION) != null;
                }
            }
        }
    }
    mEndContainer.setVisibility(endItemCount > 0 ? VISIBLE : GONE);
    // If there is a row action and the first end item is a default toggle, or action divider
    // is set by presenter and a single action is at the end of the row, show the divider.
    mDivider.setVisibility(mRowAction != null && (firstItemIsADefaultToggle || (mRowContent.hasActionDivider() && singleActionAtTheEnd)) ? View.VISIBLE : View.GONE);
    boolean hasStartAction = mStartItem != null && SliceQuery.find(mStartItem, FORMAT_ACTION) != null;
    boolean hasEndItemAction = endAction != null;
    boolean endAndRowActionTheSame = false;
    if (mRowAction != null) {
        setViewClickable(mRootView, true);
    } else if (hasEndItemAction != hasStartAction && (endItemCount == 1 || hasStartAction)) {
        // This row only has 1 action in start or end position; make whole row clickable for it
        endAndRowActionTheSame = true;
        if (!mToggles.isEmpty()) {
            mRowAction = mToggles.keySet().iterator().next();
        } else if (!mActions.isEmpty() && mActions.size() == 1) {
            mRowAction = mActions.valueAt(0).getAction();
        }
        setViewClickable(mRootView, true);
    }
    if (mRowAction != null && !endAndRowActionTheSame && mLoadingActions.contains(mRowAction.getSliceItem())) {
        mShowActionSpinner = true;
    }
}
#end_block

#method_before
void sendSliderValue() {
    if (mRangeItem != null) {
        try {
            mLastSentRangeUpdate = System.currentTimeMillis();
            mRangeItem.fireAction(getContext(), new Intent().addFlags(Intent.FLAG_RECEIVER_FOREGROUND).putExtra(EXTRA_RANGE_VALUE, mRangeValue));
        } catch (CanceledException e) {
            Log.e(TAG, "PendingIntent for slice cannot be sent", e);
        }
    }
}
#method_after
void sendSliderValue() {
    if (mRangeItem != null) {
        try {
            mLastSentRangeUpdate = System.currentTimeMillis();
            mRangeItem.fireAction(getContext(), new Intent().addFlags(Intent.FLAG_RECEIVER_FOREGROUND).putExtra(EXTRA_RANGE_VALUE, mRangeValue));
            if (mObserver != null) {
                EventInfo info = new EventInfo(getMode(), ACTION_TYPE_SLIDER, ROW_TYPE_SLIDER, mRowIndex);
                info.state = mRangeValue;
                mObserver.onSliceAction(info, mRangeItem);
            }
        } catch (CanceledException e) {
            Log.e(TAG, "PendingIntent for slice cannot be sent", e);
        }
    }
}
#end_block

#method_before
private boolean populate(SliceItem rowSlice, boolean isHeader) {
    mIsHeader = isHeader;
    if (!isValidRow(rowSlice)) {
        Log.w(TAG, "Provided SliceItem is invalid for RowContent");
        return false;
    }
    determineStartAndPrimaryAction(rowSlice);
    // Filter anything not viable for displaying in a row
    ArrayList<SliceItem> rowItems = filterInvalidItems(rowSlice);
    // If we've only got one item that's a slice / action use those items instead
    if (rowItems.size() == 1 && (FORMAT_ACTION.equals(rowItems.get(0).getFormat()) || FORMAT_SLICE.equals(rowItems.get(0).getFormat())) && !rowItems.get(0).hasAnyHints(HINT_SHORTCUT, HINT_TITLE)) {
        if (isValidRow(rowItems.get(0))) {
            rowSlice = rowItems.get(0);
            rowItems = filterInvalidItems(rowSlice);
        }
    }
    if (SUBTYPE_RANGE.equals(rowSlice.getSubType())) {
        mRange = rowSlice;
    }
    if (rowItems.size() > 0) {
        // Remove the things we already know about
        if (mStartItem != null) {
            rowItems.remove(mStartItem);
        }
        if (mPrimaryAction != null) {
            rowItems.remove(mPrimaryAction);
        }
        // Text + end items
        ArrayList<SliceItem> endItems = new ArrayList<>();
        for (int i = 0; i < rowItems.size(); i++) {
            final SliceItem item = rowItems.get(i);
            final String format = item.getFormat();
            if (FORMAT_TEXT.equals(format)) {
                if ((mTitleItem == null || !mTitleItem.hasHint(HINT_TITLE)) && item.hasHint(HINT_TITLE) && !item.hasHint(HINT_SUMMARY)) {
                    mTitleItem = item;
                } else if (mSubtitleItem == null && !item.hasHint(HINT_SUMMARY)) {
                    mSubtitleItem = item;
                } else if (mSummaryItem == null && item.hasHint(HINT_SUMMARY)) {
                    mSummaryItem = item;
                }
            } else if (FORMAT_INT.equals(format) && item.hasHint(HINT_SHOW_ACTION_DIVIDER)) {
                mShowActionDivider = item.getInt() != 0 ? true : false;
            } else {
                endItems.add(item);
            }
        }
        if (hasText(mTitleItem)) {
            mLineCount++;
        }
        if (hasText(mSubtitleItem)) {
            mLineCount++;
        }
        // Special rules for end items: only one timestamp
        boolean hasTimestamp = mStartItem != null && FORMAT_LONG.equals(mStartItem.getFormat());
        for (int i = 0; i < endItems.size(); i++) {
            final SliceItem item = endItems.get(i);
            boolean isAction = SliceQuery.find(item, FORMAT_ACTION) != null;
            if (FORMAT_LONG.equals(item.getFormat())) {
                if (!hasTimestamp) {
                    hasTimestamp = true;
                    mEndItems.add(item);
                }
            } else {
                processContent(item, isAction);
            }
        }
    }
    return isValid();
}
#method_after
private boolean populate(SliceItem rowSlice, boolean isHeader) {
    mIsHeader = isHeader;
    if (!isValidRow(rowSlice)) {
        Log.w(TAG, "Provided SliceItem is invalid for RowContent");
        return false;
    }
    determineStartAndPrimaryAction(rowSlice);
    // Filter anything not viable for displaying in a row
    ArrayList<SliceItem> rowItems = filterInvalidItems(rowSlice);
    // If we've only got one item that's a slice / action use those items instead
    if (rowItems.size() == 1 && (FORMAT_ACTION.equals(rowItems.get(0).getFormat()) || FORMAT_SLICE.equals(rowItems.get(0).getFormat())) && !rowItems.get(0).hasAnyHints(HINT_SHORTCUT, HINT_TITLE)) {
        if (isValidRow(rowItems.get(0))) {
            rowSlice = rowItems.get(0);
            rowItems = filterInvalidItems(rowSlice);
        }
    }
    if (SUBTYPE_RANGE.equals(rowSlice.getSubType())) {
        mRange = rowSlice;
    }
    if (rowItems.size() > 0) {
        // Remove the things we already know about
        if (mStartItem != null) {
            rowItems.remove(mStartItem);
        }
        if (mPrimaryAction != null) {
            rowItems.remove(mPrimaryAction);
        }
        // Text + end items
        ArrayList<SliceItem> endItems = new ArrayList<>();
        for (int i = 0; i < rowItems.size(); i++) {
            final SliceItem item = rowItems.get(i);
            if (FORMAT_TEXT.equals(item.getFormat())) {
                if ((mTitleItem == null || !mTitleItem.hasHint(HINT_TITLE)) && item.hasHint(HINT_TITLE) && !item.hasHint(HINT_SUMMARY)) {
                    mTitleItem = item;
                } else if (mSubtitleItem == null && !item.hasHint(HINT_SUMMARY)) {
                    mSubtitleItem = item;
                } else if (mSummaryItem == null && item.hasHint(HINT_SUMMARY)) {
                    mSummaryItem = item;
                }
            } else {
                endItems.add(item);
            }
        }
        if (hasText(mTitleItem)) {
            mLineCount++;
        }
        if (hasText(mSubtitleItem)) {
            mLineCount++;
        }
        // Special rules for end items: only one timestamp
        boolean hasTimestamp = mStartItem != null && FORMAT_LONG.equals(mStartItem.getFormat());
        for (int i = 0; i < endItems.size(); i++) {
            final SliceItem item = endItems.get(i);
            boolean isAction = SliceQuery.find(item, FORMAT_ACTION) != null;
            if (FORMAT_LONG.equals(item.getFormat())) {
                if (!hasTimestamp) {
                    hasTimestamp = true;
                    mEndItems.add(item);
                }
            } else {
                processContent(item, isAction);
            }
        }
    }
    return isValid();
}
#end_block

#method_before
@Override
public int getHeight(SliceStyle style, SliceViewPolicy policy) {
    int maxHeight = policy.getMaxSmallHeight() > 0 ? policy.getMaxSmallHeight() : mMaxHeight;
    if (getRange() != null || policy.getMode() == MODE_LARGE) {
        if (getRange() != null) {
            // Range element always has set height and then the height of the text
            // area on the row will vary depending on if 1 or 2 lines of text.
            int textAreaHeight = getLineCount() > 1 ? mTextWithRangeHeight : mSingleTextWithRangeHeight;
            return textAreaHeight + mRangeHeight;
        } else {
            return (getLineCount() > 1 || mIsHeader) ? maxHeight : mMinHeight;
        }
    } else {
        return maxHeight;
    }
}
#method_after
@Override
public int getHeight(SliceStyle style, SliceViewPolicy policy) {
    return style.getRowHeight(this, policy);
}
#end_block

#method_before
private static boolean isValidRowContent(SliceItem slice, SliceItem item) {
    if (item.hasAnyHints(HINT_KEYWORDS, HINT_TTL, HINT_LAST_UPDATED, HINT_HORIZONTAL) || SUBTYPE_CONTENT_DESCRIPTION.equals(item.getSubType())) {
        return false;
    }
    final String itemFormat = item.getFormat();
    return FORMAT_IMAGE.equals(itemFormat) || FORMAT_TEXT.equals(itemFormat) || FORMAT_LONG.equals(itemFormat) || FORMAT_ACTION.equals(itemFormat) || FORMAT_REMOTE_INPUT.equals(itemFormat) || FORMAT_SLICE.equals(itemFormat) || (FORMAT_INT.equals(itemFormat) && (SUBTYPE_RANGE.equals(slice.getSubType()) || item.hasHint(HINT_SHOW_ACTION_DIVIDER)));
}
#method_after
private static boolean isValidRowContent(SliceItem slice, SliceItem item) {
    if (item.hasAnyHints(HINT_KEYWORDS, HINT_TTL, HINT_LAST_UPDATED, HINT_HORIZONTAL) || SUBTYPE_CONTENT_DESCRIPTION.equals(item.getSubType())) {
        return false;
    }
    final String itemFormat = item.getFormat();
    return FORMAT_IMAGE.equals(itemFormat) || FORMAT_TEXT.equals(itemFormat) || FORMAT_LONG.equals(itemFormat) || FORMAT_ACTION.equals(itemFormat) || FORMAT_REMOTE_INPUT.equals(itemFormat) || FORMAT_SLICE.equals(itemFormat) || (FORMAT_INT.equals(itemFormat) && SUBTYPE_RANGE.equals(slice.getSubType()));
}
#end_block

#method_before
// / CHECK-START-ARM64: java.lang.Integer DivTest.$noinline$IntDivBy2(int) disassembly (after)
// / CHECK:                 add w{{\d+}}, w{{\d+}}, w{{\d+}}, lsr #31
// / CHECK:                 asr w{{\d+}}, w{{\d+}}, #1
// / CHECK-START-X86_64: java.lang.Integer DivTest.$noinline$IntDivBy2(int) disassembly (after)
// / CHECK-NOT:             test
// / CHECK-NOT:             cmovnl/geq
// / CHECK:                 shr
private static Integer $noinline$IntDivBy2(int v) {
    int r = v / 2;
    return r;
}
#method_after
// / CHECK-START-ARM64: java.lang.Integer DivTest.$noinline$IntDivBy2(int) disassembly (after)
// / CHECK:                 add w{{\d+}}, w{{\d+}}, w{{\d+}}, lsr #31
// / CHECK:                 asr w{{\d+}}, w{{\d+}}, #1
// / CHECK-START-X86_64: java.lang.Integer DivTest.$noinline$IntDivBy2(int) disassembly (after)
// / CHECK-NOT:             cmovnl/geq
private static Integer $noinline$IntDivBy2(int v) {
    int r = v / 2;
    return r;
}
#end_block

#method_before
// / CHECK-START-ARM64: java.lang.Integer DivTest.$noinline$IntDivByMinus2(int) disassembly (after)
// / CHECK:                 add w{{\d+}}, w{{\d+}}, w{{\d+}}, lsr #31
// / CHECK:                 neg w{{\d+}}, w{{\d+}}, asr #1
// / CHECK-START-X86_64: java.lang.Integer DivTest.$noinline$IntDivByMinus2(int) disassembly (after)
// / CHECK-NOT:             test
// / CHECK-NOT:             cmovnl/geq
// / CHECK:                 shr
private static Integer $noinline$IntDivByMinus2(int v) {
    int r = v / -2;
    return r;
}
#method_after
// / CHECK-START-ARM64: java.lang.Integer DivTest.$noinline$IntDivByMinus2(int) disassembly (after)
// / CHECK:                 add w{{\d+}}, w{{\d+}}, w{{\d+}}, lsr #31
// / CHECK:                 neg w{{\d+}}, w{{\d+}}, asr #1
// / CHECK-START-X86_64: java.lang.Integer DivTest.$noinline$IntDivByMinus2(int) disassembly (after)
// / CHECK-NOT:             cmovnl/geq
private static Integer $noinline$IntDivByMinus2(int v) {
    int r = v / -2;
    return r;
}
#end_block

#method_before
// / CHECK-START-ARM64: java.lang.Long DivTest.$noinline$LongDivBy2(long) disassembly (after)
// / CHECK:                 add x{{\d+}}, x{{\d+}}, x{{\d+}}, lsr #63
// / CHECK:                 asr x{{\d+}}, x{{\d+}}, #1
// / CHECK-START-X86_64: java.lang.Long DivTest.$noinline$LongDivBy2(long) disassembly (after)
// / CHECK-NOT:             mov
// / CHECK-NOT:             addq
// / CHECK-NOT:             testq
// / CHECK-NOT:             cmovnl/geq
// / CHECK:                 movq
// / CHECK:                 shrq
private static Long $noinline$LongDivBy2(long v) {
    long r = v / 2;
    return r;
}
#method_after
// / CHECK-START-ARM64: java.lang.Long DivTest.$noinline$LongDivBy2(long) disassembly (after)
// / CHECK:                 add x{{\d+}}, x{{\d+}}, x{{\d+}}, lsr #63
// / CHECK:                 asr x{{\d+}}, x{{\d+}}, #1
// / CHECK-START-X86_64: java.lang.Long DivTest.$noinline$LongDivBy2(long) disassembly (after)
// / CHECK-NOT:             cmovnl/geq
private static Long $noinline$LongDivBy2(long v) {
    long r = v / 2;
    return r;
}
#end_block

#method_before
// / CHECK-START-ARM64: java.lang.Long DivTest.$noinline$LongDivByMinus2(long) disassembly (after)
// / CHECK:                 add x{{\d+}}, x{{\d+}}, x{{\d+}}, lsr #63
// / CHECK:                 neg x{{\d+}}, x{{\d+}}, asr #1
// / CHECK-START-X86_64: java.lang.Long DivTest.$noinline$LongDivByMinus2(long) disassembly (after)
// / CHECK-NOT:             mov
// / CHECK-NOT:             addq
// / CHECK-NOT:             testq
// / CHECK-NOT:             cmovnl/geq
// / CHECK:                 movq
// / CHECK:                 shrq
private static Long $noinline$LongDivByMinus2(long v) {
    long r = v / -2;
    return r;
}
#method_after
// / CHECK-START-ARM64: java.lang.Long DivTest.$noinline$LongDivByMinus2(long) disassembly (after)
// / CHECK:                 add x{{\d+}}, x{{\d+}}, x{{\d+}}, lsr #63
// / CHECK:                 neg x{{\d+}}, x{{\d+}}, asr #1
// / CHECK-START-X86_64: java.lang.Long DivTest.$noinline$LongDivByMinus2(long) disassembly (after)
// / CHECK-NOT:             cmovnl/geq
private static Long $noinline$LongDivByMinus2(long v) {
    long r = v / -2;
    return r;
}
#end_block

#method_before
@Override
public void onStopped(boolean cancelled) {
    super.onStopped(cancelled);
    final Disposable disposable = mDisposable;
    if (disposable != null) {
        disposable.dispose();
    }
}
#method_after
@Override
public void onStopped() {
    super.onStopped();
    final SingleFutureAdapter observer = mSingleFutureObserverAdapter;
    if (observer != null) {
        observer.dispose();
        mSingleFutureObserverAdapter = null;
    }
}
#end_block

#method_before
void setShowAlphaJump(boolean show) {
    mAlphaJumpButton.setVisibility(show ? View.VISIBLE : View.GONE);
}
#method_after
void setShowAlphaJump(boolean show) {
    mAlphaJumpButtonEnabled = show;
    mAlphaJumpButton.setVisibility(show ? VISIBLE : GONE);
}
#end_block

#method_before
public void setScrollbarThumbEnabled(boolean show) {
    mShowScrollBarThumb = show;
    mScrollThumb.setVisibility(mShowScrollBarThumb ? View.VISIBLE : View.GONE);
}
#method_after
public void setScrollbarThumbEnabled(boolean show) {
    mShowScrollBarThumb = show;
    mScrollThumb.setVisibility(mShowScrollBarThumb ? VISIBLE : GONE);
}
#end_block

#method_before
public void setParameters(@IntRange(from = 0) int range, @IntRange(from = 0) int offset, @IntRange(from = 0) int extent, boolean animate) {
    // Not laid out yet, so values cannot be calculated.
    if (!isLaidOut()) {
        return;
    }
    // If the scroll bars aren't visible, then no need to update.
    if (getVisibility() == View.GONE || range == 0) {
        return;
    }
    int thumbLength = calculateScrollThumbLength(range, extent);
    // Sets the size of the thumb and request a redraw if needed.
    ViewGroup.LayoutParams lp = mScrollThumb.getLayoutParams();
    if (lp.height != thumbLength) {
        lp.height = thumbLength;
        // need to update the measured thumb height
        measureScrollThumb();
    }
    int thumbOffset = calculateScrollThumbOffset(range, offset, thumbLength);
    moveTranslationY(mScrollThumb, thumbOffset, animate);
}
#method_after
public void setParameters(@IntRange(from = 0) int range, @IntRange(from = 0) int offset, @IntRange(from = 0) int extent, boolean animate) {
    // Not laid out yet or not during layout process, so values cannot be calculated.
    if (!isLaidOut() || isInLayout()) {
        return;
    }
    // If the scroll bars aren't visible, then no need to update.
    if (getVisibility() == GONE || range == 0) {
        return;
    }
    int thumbLength = calculateScrollThumbLength(range, extent);
    // Sets the size of the thumb and request a redraw if needed.
    ViewGroup.LayoutParams lp = mScrollThumb.getLayoutParams();
    if (lp.height != thumbLength) {
        lp.height = thumbLength;
        mScrollThumb.requestLayout();
    }
    int thumbOffset = calculateScrollThumbOffset(range, offset, thumbLength);
    moveTranslationY(mScrollThumb, thumbOffset, animate);
}
#end_block

#method_before
void setParametersInLayout(int range, int offset, int extent) {
    // If the scroll bars aren't visible, then no need to update.
    if (getVisibility() == View.GONE || range == 0) {
        return;
    }
    int thumbLength = calculateScrollThumbLength(range, extent);
    // Sets the size of the thumb and request a redraw if needed.
    ViewGroup.LayoutParams lp = mScrollThumb.getLayoutParams();
    if (lp.height != thumbLength) {
        lp.height = thumbLength;
        measureAndLayoutScrollThumb();
    }
    int thumbOffset = calculateScrollThumbOffset(range, offset, thumbLength);
    moveTranslationY(mScrollThumb, thumbOffset, /* animate= */
    false);
}
#method_after
void setParametersInLayout(int range, int offset, int extent) {
    // If the scroll bars aren't visible, then no need to update.
    if (getVisibility() == GONE || range == 0) {
        return;
    }
    int thumbLength = calculateScrollThumbLength(range, extent);
    // Sets the size of the thumb and request a redraw if needed.
    ViewGroup.LayoutParams lp = mScrollThumb.getLayoutParams();
    if (lp.height != thumbLength) {
        lp.height = thumbLength;
        measureAndLayoutScrollThumb();
    }
    int thumbOffset = calculateScrollThumbOffset(range, offset, thumbLength);
    moveTranslationY(mScrollThumb, thumbOffset, /* animate= */
    false);
}
#end_block

#method_before
@Override
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    int requestedWidth = MeasureSpec.getSize(widthMeasureSpec);
    int requestedHeight = MeasureSpec.getSize(heightMeasureSpec);
    int wrapMeasureSpec = MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED);
    mUpButton.measure(wrapMeasureSpec, wrapMeasureSpec);
    mDownButton.measure(wrapMeasureSpec, wrapMeasureSpec);
    // Values which set the minimum height to draw scroll bar
    int buttonHeight = mUpButton.getMeasuredHeight() + mDownButton.getMeasuredHeight();
    // When no enough space to draw up and down buttons
    if (buttonHeight > requestedHeight) {
        mUpButton.setVisibility(GONE);
        mDownButton.setVisibility(GONE);
    } else {
        mUpButton.setVisibility(VISIBLE);
        mDownButton.setVisibility(VISIBLE);
    }
    measureScrollThumb();
    // When no enough space to draw thumb
    if (mScrollThumb.getMeasuredHeight() + buttonHeight > requestedHeight) {
        setScrollbarThumbEnabled(false);
    } else {
        setScrollbarThumbEnabled(true);
    }
    if (mAlphaJumpButton.getVisibility() != GONE) {
        mAlphaJumpButton.measure(wrapMeasureSpec, wrapMeasureSpec);
        // when no enough space to draw Alpha jump button
        if (mAlphaJumpButton.getMeasuredHeight() + buttonHeight + mScrollThumb.getMeasuredHeight() > requestedHeight) {
            mShowAlphaJumpButton = false;
        } else {
            mShowAlphaJumpButton = true;
        }
    }
    setMeasuredDimension(requestedWidth, requestedHeight);
}
#method_after
@Override
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    int requestedWidth = MeasureSpec.getSize(widthMeasureSpec);
    int requestedHeight = MeasureSpec.getSize(heightMeasureSpec);
    int wrapMeasureSpec = MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED);
    mUpButton.measure(wrapMeasureSpec, wrapMeasureSpec);
    mDownButton.measure(wrapMeasureSpec, wrapMeasureSpec);
    // A seperating margin is needed between up and down button.
    int currentHeight = getPaddingTop() + mUpButton.getMeasuredHeight() + mSeparatingMargin + mDownButton.getMeasuredHeight() + getPaddingBottom();
    // Check if there is enough room to draw buttons
    if (currentHeight > requestedHeight) {
        mUpButton.setVisibility(GONE);
        mDownButton.setVisibility(GONE);
    } else {
        mUpButton.setVisibility(VISIBLE);
        mDownButton.setVisibility(VISIBLE);
    }
    if (mShowScrollBarThumb) {
        measureScrollThumb();
        currentHeight += mScrollThumb.getMeasuredHeight() + mSeparatingMargin;
        // Check if there is enough room to draw thumb
        mScrollThumb.setVisibility(currentHeight > requestedHeight ? GONE : VISIBLE);
    }
    if (mAlphaJumpButtonEnabled) {
        mAlphaJumpButton.measure(wrapMeasureSpec, wrapMeasureSpec);
        currentHeight += mAlphaJumpButton.getMeasuredHeight() + mSeparatingMargin;
        // Check if there is enough room to draw alpha jump button
        mAlphaJumpButton.setVisibility(currentHeight > requestedHeight ? GONE : VISIBLE);
    }
    setMeasuredDimension(requestedWidth, requestedHeight);
}
#end_block

#method_before
@Override
public void onLayout(boolean changed, int left, int top, int right, int bottom) {
    int width = right - left;
    int height = bottom - top;
    // This value will keep track of the top of the current view being laid out.
    int layoutTop = getPaddingTop();
    if (mUpButton.getVisibility() != GONE) {
        // Lay out the up button at the top of the view.
        layoutViewCenteredFromTop(mUpButton, layoutTop, width);
        layoutTop = mUpButton.getBottom();
        if (mAlphaJumpButton.getVisibility() != GONE && mShowAlphaJumpButton) {
            // Lay out the alpha jump button if it exists. This button goes below the up button.
            layoutTop += mSeparatingMargin;
            layoutViewCenteredFromTop(mAlphaJumpButton, layoutTop, width);
            layoutTop = mAlphaJumpButton.getBottom();
        }
        if (mShowScrollBarThumb) {
            // Lay out the scroll thumb
            layoutTop += mSeparatingMargin;
            layoutViewCenteredFromTop(mScrollThumb, layoutTop, width);
        }
        // Lay out the bottom button at the bottom of the view.
        int downBottom = height - getPaddingBottom();
        layoutViewCenteredFromBottom(mDownButton, downBottom, width);
        calculateScrollThumbTrackHeight();
    }
}
#method_after
@Override
public void onLayout(boolean changed, int left, int top, int right, int bottom) {
    // rest of the views.
    if (mUpButton.getVisibility() == GONE) {
        return;
    }
    int width = right - left;
    int height = bottom - top;
    // This value will keep track of the top of the current view being laid out.
    int layoutTop = getPaddingTop();
    // Lay out the up button at the top of the view.
    layoutViewCenteredFromTop(mUpButton, layoutTop, width);
    layoutTop = mUpButton.getBottom();
    if (mAlphaJumpButton.getVisibility() != GONE) {
        // Lay out the alpha jump button if it exists. This button goes below the up button.
        layoutTop += mSeparatingMargin;
        layoutViewCenteredFromTop(mAlphaJumpButton, layoutTop, width);
        layoutTop = mAlphaJumpButton.getBottom();
    }
    if (mScrollThumb.getVisibility() != GONE) {
        // Lay out the scroll thumb
        layoutTop += mSeparatingMargin;
        layoutViewCenteredFromTop(mScrollThumb, layoutTop, width);
    }
    // Lay out the bottom button at the bottom of the view.
    int downBottom = height - getPaddingBottom();
    layoutViewCenteredFromBottom(mDownButton, downBottom, width);
    calculateScrollThumbTrackHeight();
}
#end_block

#method_before
private void calculateScrollThumbTrackHeight() {
    // Subtracting (2 * mSeparatingMargin) for the top/bottom margin above and below the
    // scroll bar thumb.
    mScrollThumbTrackHeight = mDownButton.getTop() - (2 * mSeparatingMargin);
    // If there's an alpha jump button, then the thumb is laid out starting from below that.
    if (mAlphaJumpButton.getVisibility() != GONE) {
        mScrollThumbTrackHeight -= mAlphaJumpButton.getBottom();
    } else {
        mScrollThumbTrackHeight -= mUpButton.getBottom();
    }
}
#method_after
private void calculateScrollThumbTrackHeight() {
    // Subtracting (2 * mSeparatingMargin) for the top/bottom margin above and below the
    // scroll bar thumb.
    mScrollThumbTrackHeight = mDownButton.getTop() - (2 * mSeparatingMargin);
    // If there's an alpha jump button, then the thumb is laid out starting from below that.
    if (mAlphaJumpButton.getVisibility() != GONE) {
        mScrollThumbTrackHeight -= mAlphaJumpButton.getBottom();
    } else {
        mScrollThumbTrackHeight -= mUpButton.getBottom();
    }
    mScrollThumbTrackHeight = Math.max(0, mScrollThumbTrackHeight);
}
#end_block

#method_before
private URLConnection openGifURLConnection() throws IOException {
    String cts = System.getProperty("java.io.tmpdir");
    File tmpDir = new File(cts);
    Support_Resources.copyFile(tmpDir, null, "Harmony.GIF");
    URL fUrl1 = new URL("file://" + tmpDir.getPath() + "/Harmony.GIF");
    URLConnection con1 = fUrl1.openConnection();
    // http://b/119607552
    assertTrue(con1.toString(), con1 instanceof FileURLConnection);
    return con1;
}
#method_after
private URLConnection openGifURLConnection() throws IOException {
    String cts = System.getProperty("java.io.tmpdir");
    File tmpDir = new File(cts);
    Support_Resources.copyFile(tmpDir, null, "Harmony.GIF");
    URL fUrl1 = new URL("file://" + tmpDir.getPath() + "/Harmony.GIF");
    URLConnection con1 = fUrl1.openConnection();
    // http://b/119607552
    assertEquals("file", con1.getURL().getProtocol());
    return con1;
}
#end_block

#method_before
private URLConnection openHTMLFile() throws IOException {
    String cts = System.getProperty("java.io.tmpdir");
    File tmpDir = new File(cts);
    Support_Resources.copyFile(tmpDir, null, "hyts_htmltest.html");
    URL fUrl1 = new URL("file://" + tmpDir.getPath() + "/hyts_htmltest.html");
    URLConnection con1 = fUrl1.openConnection();
    // http://b/119607552
    assertTrue(con1.toString(), con1 instanceof FileURLConnection);
    return con1;
}
#method_after
private URLConnection openHTMLFile() throws IOException {
    String cts = System.getProperty("java.io.tmpdir");
    File tmpDir = new File(cts);
    Support_Resources.copyFile(tmpDir, null, "hyts_htmltest.html");
    URL fUrl1 = new URL("file://" + tmpDir.getPath() + "/hyts_htmltest.html");
    URLConnection con1 = fUrl1.openConnection();
    // http://b/119607552
    assertEquals("file", con1.getURL().getProtocol());
    return con1;
}
#end_block

#method_before
@SuppressLint("ResourceType")
@NonNull
public NavGraph inflate(@NavigationRes int graphResId) {
    Resources res = mContext.getResources();
    XmlResourceParser parser = res.getXml(graphResId);
    final AttributeSet attrs = Xml.asAttributeSet(parser);
    try {
        int type;
        while ((type = parser.next()) != XmlPullParser.START_TAG && type != XmlPullParser.END_DOCUMENT) {
        // Empty loop
        }
        if (type != XmlPullParser.START_TAG) {
            throw new XmlPullParserException("No start tag found");
        }
        String rootElement = parser.getName();
        NavDestination destination = inflate(res, parser, attrs);
        if (!(destination instanceof NavGraph)) {
            throw new IllegalArgumentException("Root element <" + rootElement + ">" + " did not inflate into a NavGraph");
        }
        return (NavGraph) destination;
    } catch (Exception e) {
        throw new RuntimeException("Exception inflating " + res.getResourceName(graphResId) + " line " + parser.getLineNumber(), e);
    } finally {
        parser.close();
    }
}
#method_after
@SuppressLint("ResourceType")
@NonNull
public NavGraph inflate(@NavigationRes int graphResId) {
    Resources res = mContext.getResources();
    XmlResourceParser parser = res.getXml(graphResId);
    final AttributeSet attrs = Xml.asAttributeSet(parser);
    try {
        int type;
        while ((type = parser.next()) != XmlPullParser.START_TAG && type != XmlPullParser.END_DOCUMENT) {
        // Empty loop
        }
        if (type != XmlPullParser.START_TAG) {
            throw new XmlPullParserException("No start tag found");
        }
        String rootElement = parser.getName();
        NavDestination destination = inflate(res, parser, attrs, graphResId);
        if (!(destination instanceof NavGraph)) {
            throw new IllegalArgumentException("Root element <" + rootElement + ">" + " did not inflate into a NavGraph");
        }
        return (NavGraph) destination;
    } catch (Exception e) {
        throw new RuntimeException("Exception inflating " + res.getResourceName(graphResId) + " line " + parser.getLineNumber(), e);
    } finally {
        parser.close();
    }
}
#end_block

#method_before
@NonNull
private NavDestination inflate(@NonNull Resources res, @NonNull XmlResourceParser parser, @NonNull AttributeSet attrs) throws XmlPullParserException, IOException {
    Navigator navigator = mNavigatorProvider.getNavigator(parser.getName());
    final NavDestination dest = navigator.createDestination();
    dest.onInflate(mContext, attrs);
    final int innerDepth = parser.getDepth() + 1;
    int type;
    int depth;
    while ((type = parser.next()) != XmlPullParser.END_DOCUMENT && ((depth = parser.getDepth()) >= innerDepth || type != XmlPullParser.END_TAG)) {
        if (type != XmlPullParser.START_TAG) {
            continue;
        }
        if (depth > innerDepth) {
            continue;
        }
        final String name = parser.getName();
        if (TAG_ARGUMENT.equals(name)) {
            inflateArgument(res, dest, attrs);
        } else if (TAG_DEEP_LINK.equals(name)) {
            inflateDeepLink(res, dest, attrs);
        } else if (TAG_ACTION.equals(name)) {
            inflateAction(res, dest, attrs);
        } else if (TAG_INCLUDE.equals(name) && dest instanceof NavGraph) {
            final TypedArray a = res.obtainAttributes(attrs, R.styleable.NavInclude);
            final int id = a.getResourceId(R.styleable.NavInclude_graph, 0);
            ((NavGraph) dest).addDestination(inflate(id));
            a.recycle();
        } else if (dest instanceof NavGraph) {
            ((NavGraph) dest).addDestination(inflate(res, parser, attrs));
        }
    }
    return dest;
}
#method_after
@NonNull
private NavDestination inflate(@NonNull Resources res, @NonNull XmlResourceParser parser, @NonNull AttributeSet attrs, int graphResId) throws XmlPullParserException, IOException {
    Navigator navigator = mNavigatorProvider.getNavigator(parser.getName());
    final NavDestination dest = navigator.createDestination();
    dest.onInflate(mContext, attrs);
    final int innerDepth = parser.getDepth() + 1;
    int type;
    int depth;
    while ((type = parser.next()) != XmlPullParser.END_DOCUMENT && ((depth = parser.getDepth()) >= innerDepth || type != XmlPullParser.END_TAG)) {
        if (type != XmlPullParser.START_TAG) {
            continue;
        }
        if (depth > innerDepth) {
            continue;
        }
        final String name = parser.getName();
        if (TAG_ARGUMENT.equals(name)) {
            inflateArgument(res, dest, attrs, graphResId);
        } else if (TAG_DEEP_LINK.equals(name)) {
            inflateDeepLink(res, dest, attrs);
        } else if (TAG_ACTION.equals(name)) {
            inflateAction(res, dest, attrs);
        } else if (TAG_INCLUDE.equals(name) && dest instanceof NavGraph) {
            final TypedArray a = res.obtainAttributes(attrs, R.styleable.NavInclude);
            final int id = a.getResourceId(R.styleable.NavInclude_graph, 0);
            ((NavGraph) dest).addDestination(inflate(id));
            a.recycle();
        } else if (dest instanceof NavGraph) {
            ((NavGraph) dest).addDestination(inflate(res, parser, attrs, graphResId));
        }
    }
    return dest;
}
#end_block

#method_before
private void inflateArgument(@NonNull Resources res, @NonNull NavDestination dest, @NonNull AttributeSet attrs) throws XmlPullParserException {
    final TypedArray a = res.obtainAttributes(attrs, R.styleable.NavArgument);
    String name = a.getString(R.styleable.NavArgument_android_name);
    TypedValue value = sTmpValue.get();
    if (value == null) {
        value = new TypedValue();
        sTmpValue.set(value);
    }
    String argType = a.getString(R.styleable.NavArgument_argType);
    if (a.getValue(R.styleable.NavArgument_android_defaultValue, value)) {
        if ("string".equals(argType)) {
            dest.getDefaultArguments().putString(name, a.getString(R.styleable.NavArgument_android_defaultValue));
        } else {
            switch(value.type) {
                case TypedValue.TYPE_STRING:
                    String stringValue = value.string.toString();
                    if (argType == null) {
                        Long longValue = parseLongValue(stringValue);
                        if (longValue != null) {
                            dest.getDefaultArguments().putLong(name, longValue);
                            break;
                        }
                    } else if ("long".equals(argType)) {
                        Long longValue = parseLongValue(stringValue);
                        if (longValue != null) {
                            dest.getDefaultArguments().putLong(name, longValue);
                            break;
                        }
                        throw new XmlPullParserException("unsupported long value " + value.string);
                    } else {
                        // this might be an Enum
                        try {
                            Class<?> cls = Class.forName(argType);
                            if (cls.isEnum()) {
                                boolean found = false;
                                for (Object constant : cls.getEnumConstants()) {
                                    if (((Enum) constant).name().equals(stringValue)) {
                                        dest.getDefaultArguments().putSerializable(name, (Enum) constant);
                                        found = true;
                                        break;
                                    }
                                }
                                if (!found) {
                                    throw new XmlPullParserException("Cannot find Enum value '" + stringValue + "' for " + "'" + argType + "'");
                                }
                                // from switch statement
                                break;
                            } else {
                                throw new XmlPullParserException("Unsupported argument type '" + argType + "' with " + "non-null defaultValue. Class '" + argType + " does not exist or is not an Enum.");
                            }
                        } catch (ClassNotFoundException e) {
                            e.printStackTrace();
                        }
                    }
                    dest.getDefaultArguments().putString(name, stringValue);
                    break;
                case TypedValue.TYPE_DIMENSION:
                    dest.getDefaultArguments().putInt(name, (int) value.getDimension(res.getDisplayMetrics()));
                    break;
                case TypedValue.TYPE_FLOAT:
                    dest.getDefaultArguments().putFloat(name, value.getFloat());
                    break;
                case TypedValue.TYPE_REFERENCE:
                    dest.getDefaultArguments().putInt(name, value.data);
                    break;
                default:
                    if (value.type >= TypedValue.TYPE_FIRST_INT && value.type <= TypedValue.TYPE_LAST_INT) {
                        if (value.type == TypedValue.TYPE_INT_BOOLEAN) {
                            dest.getDefaultArguments().putBoolean(name, value.data != 0);
                        } else {
                            dest.getDefaultArguments().putInt(name, value.data);
                        }
                    } else {
                        throw new XmlPullParserException("Unsupported argument type " + value.type);
                    }
            }
        }
    }
    a.recycle();
}
#method_after
private void inflateArgument(@NonNull Resources res, @NonNull NavDestination dest, @NonNull AttributeSet attrs, int graphResId) throws XmlPullParserException {
    final TypedArray a = res.obtainAttributes(attrs, R.styleable.NavArgument);
    String name = a.getString(R.styleable.NavArgument_android_name);
    TypedValue value = sTmpValue.get();
    if (value == null) {
        value = new TypedValue();
        sTmpValue.set(value);
    }
    String argType = a.getString(R.styleable.NavArgument_argType);
    if (a.getValue(R.styleable.NavArgument_android_defaultValue, value)) {
        if ("string".equals(argType)) {
            dest.getDefaultArguments().putString(name, a.getString(R.styleable.NavArgument_android_defaultValue));
        } else {
            switch(value.type) {
                case TypedValue.TYPE_STRING:
                    String stringValue = value.string.toString();
                    if (argType == null) {
                        Long longValue = parseLongValue(stringValue);
                        if (longValue != null) {
                            dest.getDefaultArguments().putLong(name, longValue);
                            break;
                        }
                    } else if ("long".equals(argType)) {
                        Long longValue = parseLongValue(stringValue);
                        if (longValue != null) {
                            dest.getDefaultArguments().putLong(name, longValue);
                            break;
                        }
                        throw new XmlPullParserException("unsupported long value " + value.string);
                    } else {
                        // this might be an Enum
                        Class<?> cls = null;
                        String className;
                        if (argType.startsWith(".")) {
                            className = res.getResourcePackageName(graphResId) + argType;
                        } else {
                            className = argType;
                        }
                        try {
                            cls = Class.forName(className);
                        } catch (ClassNotFoundException e) {
                            e.printStackTrace();
                        }
                        if (cls != null && cls.isEnum()) {
                            boolean found = false;
                            for (Object constant : cls.getEnumConstants()) {
                                if (((Enum) constant).name().equals(stringValue)) {
                                    dest.getDefaultArguments().putSerializable(name, (Enum) constant);
                                    found = true;
                                    break;
                                }
                            }
                            if (!found) {
                                throw new XmlPullParserException("Cannot find Enum value '" + stringValue + "' for " + "'" + className + "'");
                            }
                            // from switch statement
                            break;
                        } else {
                            throw new XmlPullParserException("Unsupported argument type '" + argType + "' with " + "non-null defaultValue. Class '" + className + " does not exist or is not an Enum.");
                        }
                    }
                    dest.getDefaultArguments().putString(name, stringValue);
                    break;
                case TypedValue.TYPE_DIMENSION:
                    dest.getDefaultArguments().putInt(name, (int) value.getDimension(res.getDisplayMetrics()));
                    break;
                case TypedValue.TYPE_FLOAT:
                    dest.getDefaultArguments().putFloat(name, value.getFloat());
                    break;
                case TypedValue.TYPE_REFERENCE:
                    dest.getDefaultArguments().putInt(name, value.data);
                    break;
                default:
                    if (value.type >= TypedValue.TYPE_FIRST_INT && value.type <= TypedValue.TYPE_LAST_INT) {
                        if (value.type == TypedValue.TYPE_INT_BOOLEAN) {
                            dest.getDefaultArguments().putBoolean(name, value.data != 0);
                        } else {
                            dest.getDefaultArguments().putInt(name, value.data);
                        }
                    } else {
                        throw new XmlPullParserException("Unsupported argument type " + value.type);
                    }
            }
        }
    }
    a.recycle();
}
#end_block

#method_before
@SuppressWarnings("deprecation")
private void inflateAction(@NonNull Resources res, @NonNull NavDestination dest, @NonNull AttributeSet attrs) {
    final TypedArray a = res.obtainAttributes(attrs, R.styleable.NavAction);
    final int id = a.getResourceId(R.styleable.NavAction_android_id, 0);
    final int destId = a.getResourceId(R.styleable.NavAction_destination, 0);
    NavAction action = new NavAction(destId);
    NavOptions.Builder builder = new NavOptions.Builder();
    builder.setLaunchSingleTop(a.getBoolean(R.styleable.NavAction_launchSingleTop, false));
    builder.setLaunchDocument(a.getBoolean(R.styleable.NavAction_launchDocument, false));
    builder.setClearTask(a.getBoolean(R.styleable.NavAction_clearTask, false));
    builder.setPopUpTo(a.getResourceId(R.styleable.NavAction_popUpTo, 0), a.getBoolean(R.styleable.NavAction_popUpToInclusive, false));
    builder.setEnterAnim(a.getResourceId(R.styleable.NavAction_enterAnim, -1));
    builder.setExitAnim(a.getResourceId(R.styleable.NavAction_exitAnim, -1));
    builder.setPopEnterAnim(a.getResourceId(R.styleable.NavAction_popEnterAnim, -1));
    builder.setPopExitAnim(a.getResourceId(R.styleable.NavAction_popExitAnim, -1));
    action.setNavOptions(builder.build());
    dest.putAction(id, action);
    a.recycle();
}
#method_after
private void inflateAction(@NonNull Resources res, @NonNull NavDestination dest, @NonNull AttributeSet attrs) {
    final TypedArray a = res.obtainAttributes(attrs, R.styleable.NavAction);
    final int id = a.getResourceId(R.styleable.NavAction_android_id, 0);
    final int destId = a.getResourceId(R.styleable.NavAction_destination, 0);
    NavAction action = new NavAction(destId);
    NavOptions.Builder builder = new NavOptions.Builder();
    builder.setLaunchSingleTop(a.getBoolean(R.styleable.NavAction_launchSingleTop, false));
    builder.setPopUpTo(a.getResourceId(R.styleable.NavAction_popUpTo, 0), a.getBoolean(R.styleable.NavAction_popUpToInclusive, false));
    builder.setEnterAnim(a.getResourceId(R.styleable.NavAction_enterAnim, -1));
    builder.setExitAnim(a.getResourceId(R.styleable.NavAction_exitAnim, -1));
    builder.setPopEnterAnim(a.getResourceId(R.styleable.NavAction_popEnterAnim, -1));
    builder.setPopExitAnim(a.getResourceId(R.styleable.NavAction_popExitAnim, -1));
    action.setNavOptions(builder.build());
    dest.putAction(id, action);
    a.recycle();
}
#end_block

#method_before
@Override
public int hashCode() {
    int result = super.hashCode();
    result = 31 * result + (main != null ? main.hashCode() : 0);
    result = 31 * result + optional;
    result = 31 * result + reference;
    result = 31 * result + Float.floatToIntBits(floatArg);
    result = 31 * result + (floatArrayArg != null ? floatArrayArg.hashCode() : 0);
    result = 31 * result + (objectArrayArg != null ? objectArrayArg.hashCode() : 0);
    result = 31 * result + (boolArg ? 1 : 0);
    result = 31 * result + (optionalParcelable != null ? optionalParcelable.hashCode() : 0);
    result = 31 * result + (enumArg != null ? enumArg.hashCode() : 0);
    return result;
}
#method_after
@Override
public int hashCode() {
    int result = super.hashCode();
    result = 31 * result + (main != null ? main.hashCode() : 0);
    result = 31 * result + optional;
    result = 31 * result + reference;
    result = 31 * result + Float.floatToIntBits(floatArg);
    result = 31 * result + java.util.Arrays.hashCode(floatArrayArg);
    result = 31 * result + java.util.Arrays.hashCode(objectArrayArg);
    result = 31 * result + (boolArg ? 1 : 0);
    result = 31 * result + (optionalParcelable != null ? optionalParcelable.hashCode() : 0);
    result = 31 * result + (enumArg != null ? enumArg.hashCode() : 0);
    return result;
}
#end_block

#method_before
@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)
@Nullable
Bundle addInDefaultArgs(@Nullable Bundle args) {
    Bundle defaultArgs = getDefaultArguments();
    if (args == null && defaultArgs.isEmpty()) {
        return null;
    }
    Bundle finalArgs = new Bundle();
    finalArgs.putAll(defaultArgs);
    if (args != null) {
        finalArgs.putAll(args);
    }
    return finalArgs;
}
#method_after
@Nullable
Bundle addInDefaultArgs(@Nullable Bundle args) {
    Bundle defaultArgs = getDefaultArguments();
    if (args == null && defaultArgs.isEmpty()) {
        return null;
    }
    Bundle finalArgs = new Bundle();
    finalArgs.putAll(defaultArgs);
    if (args != null) {
        finalArgs.putAll(args);
    }
    return finalArgs;
}
#end_block

#method_before
@NonNull
public <T extends Navigator<?>> T getNavigator(@NonNull Class<T> navigatorClass) {
    String name = getNameForNavigator(navigatorClass);
    return getNavigator(name);
}
#method_after
@NonNull
public final <T extends Navigator<?>> T getNavigator(@NonNull Class<T> navigatorClass) {
    String name = getNameForNavigator(navigatorClass);
    return getNavigator(name);
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@NonNull
public <T extends Navigator<?>> T getNavigator(@NonNull String name) {
    if (!validateName(name)) {
        throw new IllegalArgumentException("navigator name cannot be an empty string");
    }
    Navigator<? extends NavDestination> navigator = mNavigators.get(name);
    if (navigator == null) {
        throw new IllegalStateException("Could not find Navigator with name \"" + name + "\". You must call NavController.addNavigator() for each navigation type.");
    }
    return (T) navigator;
}
#method_after
@SuppressWarnings("unchecked")
@CallSuper
@NonNull
public <T extends Navigator<?>> T getNavigator(@NonNull String name) {
    if (!validateName(name)) {
        throw new IllegalArgumentException("navigator name cannot be an empty string");
    }
    Navigator<? extends NavDestination> navigator = mNavigators.get(name);
    if (navigator == null) {
        throw new IllegalStateException("Could not find Navigator with name \"" + name + "\". You must call NavController.addNavigator() for each navigation type.");
    }
    return (T) navigator;
}
#end_block

#method_before
@Nullable
public Navigator<? extends NavDestination> addNavigator(@NonNull Navigator<? extends NavDestination> navigator) {
    String name = getNameForNavigator(navigator.getClass());
    return addNavigator(name, navigator);
}
#method_after
@Nullable
public final Navigator<? extends NavDestination> addNavigator(@NonNull Navigator<? extends NavDestination> navigator) {
    String name = getNameForNavigator(navigator.getClass());
    return addNavigator(name, navigator);
}
#end_block

#method_before
@Nullable
public Navigator<? extends NavDestination> addNavigator(@NonNull String name, @NonNull Navigator<? extends NavDestination> navigator) {
    if (!validateName(name)) {
        throw new IllegalArgumentException("navigator name cannot be an empty string");
    }
    Navigator<? extends NavDestination> previousNavigator = mNavigators.put(name, navigator);
    if (previousNavigator != navigator) {
        if (previousNavigator != null) {
            previousNavigator.onRemoved(this);
        }
        navigator.onAdded(this);
    }
    return previousNavigator;
}
#method_after
@CallSuper
@Nullable
public Navigator<? extends NavDestination> addNavigator(@NonNull String name, @NonNull Navigator<? extends NavDestination> navigator) {
    if (!validateName(name)) {
        throw new IllegalArgumentException("navigator name cannot be an empty string");
    }
    return mNavigators.put(name, navigator);
}
#end_block

#method_before
@Override
public void navigate(@NonNull NavGraph destination, @Nullable Bundle args, @Nullable NavOptions navOptions, @Nullable Extras navigatorExtras) {
    if (mNavigatorProvider == null) {
        throw new IllegalStateException("Called navigate on " + this + " when it is not added to a NavController");
    }
    int startId = destination.getStartDestination();
    if (startId == 0) {
        throw new IllegalStateException("no start destination defined via" + " app:startDestination for " + (destination.getId() != 0 ? NavDestination.getDisplayName(mContext, destination.getId()) : "the root navigation"));
    }
    NavDestination startDestination = destination.findNode(startId, false);
    if (startDestination == null) {
        final String dest = NavDestination.getDisplayName(mContext, startId);
        throw new IllegalArgumentException("navigation destination " + dest + " is not a direct child of this NavGraph");
    }
    if (navOptions != null && navOptions.shouldLaunchSingleTop() && isAlreadyTop(destination)) {
        dispatchOnNavigatorNavigated(destination.getId(), BACK_STACK_UNCHANGED);
    } else {
        mBackStack.add(destination.getId());
        dispatchOnNavigatorNavigated(destination.getId(), BACK_STACK_DESTINATION_ADDED);
    }
    Navigator<NavDestination> navigator = mNavigatorProvider.getNavigator(startDestination.getNavigatorName());
    navigator.navigate(startDestination, startDestination.addInDefaultArgs(args), navOptions, navigatorExtras);
}
#method_after
@Override
public void navigate(@NonNull NavGraph destination, @Nullable Bundle args, @Nullable NavOptions navOptions, @Nullable Extras navigatorExtras) {
    int startId = destination.getStartDestination();
    if (startId == 0) {
        throw new IllegalStateException("no start destination defined via" + " app:startDestination for " + (destination.getId() != 0 ? NavDestination.getDisplayName(mContext, destination.getId()) : "the root navigation"));
    }
    NavDestination startDestination = destination.findNode(startId, false);
    if (startDestination == null) {
        final String dest = NavDestination.getDisplayName(mContext, startId);
        throw new IllegalArgumentException("navigation destination " + dest + " is not a direct child of this NavGraph");
    }
    if (navOptions != null && navOptions.shouldLaunchSingleTop() && isAlreadyTop(destination)) {
        dispatchOnNavigatorNavigated(destination.getId(), BACK_STACK_UNCHANGED);
    } else {
        mBackStack.add(destination.getId());
        dispatchOnNavigatorNavigated(destination.getId(), BACK_STACK_DESTINATION_ADDED);
    }
    Navigator<NavDestination> navigator = mNavigatorProvider.getNavigator(startDestination.getNavigatorName());
    navigator.navigate(startDestination, startDestination.addInDefaultArgs(args), navOptions, navigatorExtras);
}
#end_block

#method_before
@NonNull
public <T extends Navigator<?>> T getNavigator(@NonNull Class<T> navigatorClass) {
    String name = getNameForNavigator(navigatorClass);
    return getNavigator(name);
}
#method_after
@NonNull
public final <T extends Navigator<?>> T getNavigator(@NonNull Class<T> navigatorClass) {
    String name = getNameForNavigator(navigatorClass);
    return getNavigator(name);
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@NonNull
public <T extends Navigator<?>> T getNavigator(@NonNull String name) {
    if (!validateName(name)) {
        throw new IllegalArgumentException("navigator name cannot be an empty string");
    }
    Navigator<? extends NavDestination> navigator = mNavigators.get(name);
    if (navigator == null) {
        throw new IllegalStateException("Could not find Navigator with name \"" + name + "\". You must call NavController.addNavigator() for each navigation type.");
    }
    return (T) navigator;
}
#method_after
@SuppressWarnings("unchecked")
@CallSuper
@NonNull
public <T extends Navigator<?>> T getNavigator(@NonNull String name) {
    if (!validateName(name)) {
        throw new IllegalArgumentException("navigator name cannot be an empty string");
    }
    Navigator<? extends NavDestination> navigator = mNavigators.get(name);
    if (navigator == null) {
        throw new IllegalStateException("Could not find Navigator with name \"" + name + "\". You must call NavController.addNavigator() for each navigation type.");
    }
    return (T) navigator;
}
#end_block

#method_before
@Nullable
public Navigator<? extends NavDestination> addNavigator(@NonNull Navigator<? extends NavDestination> navigator) {
    String name = getNameForNavigator(navigator.getClass());
    return addNavigator(name, navigator);
}
#method_after
@Nullable
public final Navigator<? extends NavDestination> addNavigator(@NonNull Navigator<? extends NavDestination> navigator) {
    String name = getNameForNavigator(navigator.getClass());
    return addNavigator(name, navigator);
}
#end_block

#method_before
@Nullable
public Navigator<? extends NavDestination> addNavigator(@NonNull String name, @NonNull Navigator<? extends NavDestination> navigator) {
    if (!validateName(name)) {
        throw new IllegalArgumentException("navigator name cannot be an empty string");
    }
    return mNavigators.put(name, navigator);
}
#method_after
@CallSuper
@Nullable
public Navigator<? extends NavDestination> addNavigator(@NonNull String name, @NonNull Navigator<? extends NavDestination> navigator) {
    if (!validateName(name)) {
        throw new IllegalArgumentException("navigator name cannot be an empty string");
    }
    return mNavigators.put(name, navigator);
}
#end_block

#method_before
public void addController(T controller, ControllerInfo controllerInfo, SessionCommandGroup commands) {
    if (controller == null || controllerInfo == null) {
        if (DEBUG) {
            throw new IllegalArgumentException("controller nor controllerInfo shouldn't be" + " null");
        }
        return;
    }
    synchronized (mLock) {
        ControllerInfo savedInfo = getController(controller);
        if (savedInfo == null) {
            mControllerInfoMap.put(controller, controllerInfo);
            mControllerRecords.put(controllerInfo, new ConnectedControllerRecord(controller, new SequencedFutureManager(), commands));
        } else if (!controllerInfo.equals(savedInfo)) {
            // already exist, but controllerInfo is changed.
            mControllerInfoMap.put(controller, controllerInfo);
            ConnectedControllerRecord record = mControllerRecords.remove(savedInfo);
            record.allowedCommands = commands;
            mControllerRecords.put(controllerInfo, record);
        } else {
            // already exist. Only update allowed commands.
            ConnectedControllerRecord record = mControllerRecords.get(controllerInfo);
            record.allowedCommands = commands;
        }
    }
// TODO: Also notify controller connected.
}
#method_after
public void addController(T controllerKey, ControllerInfo controllerInfo, SessionCommandGroup commands) {
    if (controllerKey == null || controllerInfo == null) {
        if (DEBUG) {
            throw new IllegalArgumentException("controllerKey and controllerInfo shouldn't be" + " null");
        }
        return;
    }
    synchronized (mLock) {
        ControllerInfo savedInfo = getController(controllerKey);
        if (savedInfo == null) {
            mControllerInfoMap.put(controllerKey, controllerInfo);
            mControllerRecords.put(controllerInfo, new ConnectedControllerRecord(controllerKey, new SequencedFutureManager(), commands));
        } else if (!controllerInfo.equals(savedInfo)) {
            // already exist, but controllerInfo is changed.
            mControllerInfoMap.put(controllerKey, controllerInfo);
            ConnectedControllerRecord record = mControllerRecords.remove(savedInfo);
            record.allowedCommands = commands;
            mControllerRecords.put(controllerInfo, record);
        } else {
            // already exist. Only update allowed commands.
            ConnectedControllerRecord record = mControllerRecords.get(controllerInfo);
            record.allowedCommands = commands;
        }
    }
// TODO: Also notify controller connected.
}
#end_block

#method_before
public void removeController(T controller) {
    if (controller == null) {
        return;
    }
    removeController(getController(controller));
}
#method_after
public void removeController(T controllerKey) {
    if (controllerKey == null) {
        return;
    }
    removeController(getController(controllerKey));
}
#end_block

#method_before
public void removeController(final ControllerInfo controllerInfo) {
    if (controllerInfo == null) {
        return;
    }
    ConnectedControllerRecord record;
    synchronized (mLock) {
        record = mControllerRecords.remove(controllerInfo);
        mControllerInfoMap.remove(record.controller);
    }
    if (DEBUG) {
        Log.d(TAG, "Controller " + controllerInfo + " is disconnected");
    }
    record.sequencedFutureManager.close();
    mSessionImpl.getCallbackExecutor().execute(new Runnable() {

        @Override
        public void run() {
            if (mSessionImpl.isClosed()) {
                return;
            }
            mSessionImpl.getCallback().onDisconnected(mSessionImpl.getInstance(), controllerInfo);
        }
    });
}
#method_after
public void removeController(final ControllerInfo controllerInfo) {
    if (controllerInfo == null) {
        return;
    }
    ConnectedControllerRecord record;
    synchronized (mLock) {
        record = mControllerRecords.remove(controllerInfo);
        if (record == null) {
            return;
        }
        mControllerInfoMap.remove(record.controllerKey);
    }
    if (DEBUG) {
        Log.d(TAG, "Controller " + controllerInfo + " is disconnected");
    }
    record.sequencedFutureManager.close();
    mSessionImpl.getCallbackExecutor().execute(new Runnable() {

        @Override
        public void run() {
            if (mSessionImpl.isClosed()) {
                return;
            }
            mSessionImpl.getCallback().onDisconnected(mSessionImpl.getInstance(), controllerInfo);
        }
    });
}
#end_block

#method_before
public SequencedFutureManager getSequencedFutureManager(@Nullable T controller) {
    ConnectedControllerRecord info;
    synchronized (mLock) {
        info = mControllerRecords.get(getController(controller));
    }
    return info != null ? info.sequencedFutureManager : null;
}
#method_after
public SequencedFutureManager getSequencedFutureManager(@Nullable T controllerKey) {
    ConnectedControllerRecord info;
    synchronized (mLock) {
        info = mControllerRecords.get(getController(controllerKey));
    }
    return info != null ? info.sequencedFutureManager : null;
}
#end_block

#method_before
public ControllerInfo getController(T controller) {
    synchronized (mLock) {
        for (Map.Entry<T, ControllerInfo> e : mControllerInfoMap.entrySet()) {
            if (e.getKey() instanceof RemoteUserInfo) {
                // Only checks the package name and UID to workaround two things.
                // 1. In MediaBrowserServiceCompat, RemoteUserInfo from onGetRoot and other
                // methods are differ even for the same controller.
                // 2. For key presses, RemoteUserInfo differs for individual key events.
                RemoteUserInfo remoteUserInfo = (RemoteUserInfo) e.getKey();
                RemoteUserInfo other = (RemoteUserInfo) controller;
                if (TextUtils.equals(remoteUserInfo.getPackageName(), other.getPackageName()) && remoteUserInfo.getUid() == other.getUid()) {
                    return e.getValue();
                }
            } else if (ObjectsCompat.equals(e.getKey(), controller)) {
                return e.getValue();
            }
        }
    }
    return null;
}
#method_after
public ControllerInfo getController(T controllerKey) {
    synchronized (mLock) {
        for (Map.Entry<T, ControllerInfo> e : mControllerInfoMap.entrySet()) {
            if (e.getKey() instanceof RemoteUserInfo) {
                // Only checks the package name and UID to workaround two things.
                // 1. In MediaBrowserServiceCompat, RemoteUserInfo from onGetRoot and other
                // methods are differ even for the same controller.
                // 2. For key presses, RemoteUserInfo differs for individual key events.
                RemoteUserInfo remoteUserInfo = (RemoteUserInfo) e.getKey();
                RemoteUserInfo other = (RemoteUserInfo) controllerKey;
                if (TextUtils.equals(remoteUserInfo.getPackageName(), other.getPackageName()) && remoteUserInfo.getUid() == other.getUid()) {
                    return e.getValue();
                }
            } else if (ObjectsCompat.equals(e.getKey(), controllerKey)) {
                return e.getValue();
            }
        }
    }
    return null;
}
#end_block

