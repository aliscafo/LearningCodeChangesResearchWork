109
#method_before
// Android-changed: Removed broken @see tag:
// @see     javax.lang.model.SourceVersion#isIdentifier(CharSequence)
public static boolean isJavaIdentifierStart(char ch) {
    return isJavaIdentifierStart((int) ch);
}
#method_after
// Android-changed: Removed @see tag (target does not exist on Android):
// @see     javax.lang.model.SourceVersion#isIdentifier(CharSequence)
public static boolean isJavaIdentifierStart(char ch) {
    return isJavaIdentifierStart((int) ch);
}
#end_block

#method_before
// Android-changed: Removed broken @see tag:
// @see     javax.lang.model.SourceVersion#isIdentifier(CharSequence)
public static boolean isJavaIdentifierStart(int codePoint) {
    // Use precomputed bitmasks to optimize the ASCII range.
    if (codePoint < 64) {
        // There's only one character in this range.
        return (codePoint == '$');
    } else if (codePoint < 128) {
        return (0x7fffffe87fffffeL & (1L << (codePoint - 64))) != 0;
    }
    return ((1 << getType(codePoint)) & ((1 << UPPERCASE_LETTER) | (1 << LOWERCASE_LETTER) | (1 << TITLECASE_LETTER) | (1 << MODIFIER_LETTER) | (1 << OTHER_LETTER) | (1 << CURRENCY_SYMBOL) | (1 << CONNECTOR_PUNCTUATION) | (1 << LETTER_NUMBER))) != 0;
}
#method_after
// Android-changed: Removed @see tag (target does not exist on Android):
// @see     javax.lang.model.SourceVersion#isIdentifier(CharSequence)
public static boolean isJavaIdentifierStart(int codePoint) {
    // Use precomputed bitmasks to optimize the ASCII range.
    if (codePoint < 64) {
        // There's only one character in this range.
        return (codePoint == '$');
    } else if (codePoint < 128) {
        return (0x7fffffe87fffffeL & (1L << (codePoint - 64))) != 0;
    }
    return ((1 << getType(codePoint)) & ((1 << UPPERCASE_LETTER) | (1 << LOWERCASE_LETTER) | (1 << TITLECASE_LETTER) | (1 << MODIFIER_LETTER) | (1 << OTHER_LETTER) | (1 << CURRENCY_SYMBOL) | (1 << CONNECTOR_PUNCTUATION) | (1 << LETTER_NUMBER))) != 0;
}
#end_block

#method_before
// Android-changed: Removed broken @see tag:
// @see     javax.lang.model.SourceVersion#isIdentifier(CharSequence)
public static boolean isJavaIdentifierPart(char ch) {
    return isJavaIdentifierPart((int) ch);
}
#method_after
// Android-changed: Removed @see tag (target does not exist on Android):
// @see     javax.lang.model.SourceVersion#isIdentifier(CharSequence)
public static boolean isJavaIdentifierPart(char ch) {
    return isJavaIdentifierPart((int) ch);
}
#end_block

#method_before
// Android-changed: Removed broken @see tag:
// @see     javax.lang.model.SourceVersion#isIdentifier(CharSequence)
public static boolean isJavaIdentifierPart(int codePoint) {
    // Use precomputed bitmasks to optimize the ASCII range.
    if (codePoint < 64) {
        return (0x3ff00100fffc1ffL & (1L << codePoint)) != 0;
    } else if (codePoint < 128) {
        return (0x87fffffe87fffffeL & (1L << (codePoint - 64))) != 0;
    }
    return ((1 << getType(codePoint)) & ((1 << UPPERCASE_LETTER) | (1 << LOWERCASE_LETTER) | (1 << TITLECASE_LETTER) | (1 << MODIFIER_LETTER) | (1 << OTHER_LETTER) | (1 << CURRENCY_SYMBOL) | (1 << CONNECTOR_PUNCTUATION) | (1 << DECIMAL_DIGIT_NUMBER) | (1 << LETTER_NUMBER) | (1 << FORMAT) | (1 << COMBINING_SPACING_MARK) | (1 << NON_SPACING_MARK))) != 0 || (codePoint >= 0 && codePoint <= 8) || (codePoint >= 0xe && codePoint <= 0x1b) || (codePoint >= 0x7f && codePoint <= 0x9f);
}
#method_after
// Android-changed: Removed @see tag (target does not exist on Android):
// @see     javax.lang.model.SourceVersion#isIdentifier(CharSequence)
public static boolean isJavaIdentifierPart(int codePoint) {
    // Use precomputed bitmasks to optimize the ASCII range.
    if (codePoint < 64) {
        return (0x3ff00100fffc1ffL & (1L << codePoint)) != 0;
    } else if (codePoint < 128) {
        return (0x87fffffe87fffffeL & (1L << (codePoint - 64))) != 0;
    }
    return ((1 << getType(codePoint)) & ((1 << UPPERCASE_LETTER) | (1 << LOWERCASE_LETTER) | (1 << TITLECASE_LETTER) | (1 << MODIFIER_LETTER) | (1 << OTHER_LETTER) | (1 << CURRENCY_SYMBOL) | (1 << CONNECTOR_PUNCTUATION) | (1 << DECIMAL_DIGIT_NUMBER) | (1 << LETTER_NUMBER) | (1 << FORMAT) | (1 << COMBINING_SPACING_MARK) | (1 << NON_SPACING_MARK))) != 0 || (codePoint >= 0 && codePoint <= 8) || (codePoint >= 0xe && codePoint <= 0x1b) || (codePoint >= 0x7f && codePoint <= 0x9f);
}
#end_block

#method_before
// Android-changed: Removed broken @see tag:
// @see     java.net.URL#set(java.lang.String, java.lang.String, int, java.lang.String, java.lang.String)
protected void setURL(URL u, String protocol, String host, int port, String authority, String userInfo, String path, String query, String ref) {
    if (this != u.handler) {
        throw new SecurityException("handler for url different from " + "this handler");
    }
    // ensure that no one can reset the protocol on a given URL.
    u.set(u.getProtocol(), host, port, authority, userInfo, path, query, ref);
}
#method_after
// Android-changed: Removed @see tag (target is package-private):
// @see     java.net.URL#set(java.lang.String, java.lang.String, int, java.lang.String, java.lang.String)
protected void setURL(URL u, String protocol, String host, int port, String authority, String userInfo, String path, String query, String ref) {
    if (this != u.handler) {
        throw new SecurityException("handler for url different from " + "this handler");
    }
    // ensure that no one can reset the protocol on a given URL.
    u.set(u.getProtocol(), host, port, authority, userInfo, path, query, ref);
}
#end_block

#method_before
@Override
public void handleMessage(Message msg) {
    AsyncResult ar = (AsyncResult) msg.obj;
    if (DBG)
        logd("handleMessage what=" + msg.what);
    switch(msg.what) {
        case EVENT_SET_CALL_FORWARD_DONE:
            IccRecords r = mDefaultPhone.getIccRecords();
            Cf cf = (Cf) ar.userObj;
            if (cf.mIsCfu && ar.exception == null && r != null) {
                setVoiceCallForwardingFlag(r, 1, msg.arg1 == 1, cf.mSetCfNumber);
            }
            sendResponse(cf.mOnComplete, null, ar.exception);
            break;
        case EVENT_GET_CALL_FORWARD_DONE:
            CallForwardInfo[] cfInfos = null;
            if (ar.exception == null) {
                cfInfos = handleCfQueryResult((ImsCallForwardInfo[]) ar.result);
            }
            sendResponse((Message) ar.userObj, cfInfos, ar.exception);
            break;
        case EVENT_GET_CALL_BARRING_DONE:
        case EVENT_GET_CALL_WAITING_DONE:
            int[] ssInfos = null;
            if (ar.exception == null) {
                if (msg.what == EVENT_GET_CALL_BARRING_DONE) {
                    ssInfos = handleCbQueryResult((ImsSsInfo[]) ar.result);
                } else if (msg.what == EVENT_GET_CALL_WAITING_DONE) {
                    ssInfos = handleCwQueryResult((ImsSsInfo[]) ar.result);
                }
            }
            sendResponse((Message) ar.userObj, ssInfos, ar.exception);
            break;
        case EVENT_GET_CLIR_DONE:
            Bundle ssInfo = (Bundle) ar.result;
            int[] clirInfo = null;
            if (ssInfo != null) {
                clirInfo = ssInfo.getIntArray(ImsPhoneMmiCode.UT_BUNDLE_KEY_CLIR);
            }
            sendResponse((Message) ar.userObj, clirInfo, ar.exception);
            break;
        case EVENT_SET_CLIR_DONE:
            if (ar.exception == null) {
                saveClirSetting(msg.arg1);
            }
        // (Intentional fallthrough)
        case EVENT_SET_CALL_BARRING_DONE:
        case EVENT_SET_CALL_WAITING_DONE:
            sendResponse((Message) ar.userObj, null, ar.exception);
            break;
        case EVENT_DEFAULT_PHONE_DATA_STATE_CHANGED:
            if (DBG)
                logd("EVENT_DEFAULT_PHONE_DATA_STATE_CHANGED");
            updateDataServiceState();
            break;
        case EVENT_SERVICE_STATE_CHANGED:
            if (VDBG)
                logd("EVENT_SERVICE_STATE_CHANGED");
            ar = (AsyncResult) msg.obj;
            ServiceState newServiceState = (ServiceState) ar.result;
            // only update if roaming status changed
            if (mRoaming != newServiceState.getRoaming()) {
                if (DBG)
                    logd("Roaming state changed - " + mRoaming);
                // Update WFC mode only if voice or data is in service.
                // The STATE_IN_SERVICE is checked to prevent wifi calling mode change when phone
                // moves from roaming to no service.
                boolean canupdateWfc = (newServiceState.getVoiceRegState() == ServiceState.STATE_IN_SERVICE || newServiceState.getDataRegState() == ServiceState.STATE_IN_SERVICE);
                updateRoamingState(newServiceState.getRoaming(), canUpdateWfc);
            }
            break;
        case EVENT_VOICE_CALL_ENDED:
            if (DBG)
                logd("Voice call ended. Handle pending updateRoamingState.");
            mCT.unregisterForVoiceCallEnded(this);
            // only update if roaming status changed
            boolean newRoaming = getCurrentRoaming();
            if (mRoaming != newRoaming) {
                updateRoamingState(newRoaming, true);
            }
            break;
        default:
            super.handleMessage(msg);
            break;
    }
}
#method_after
@Override
public void handleMessage(Message msg) {
    AsyncResult ar = (AsyncResult) msg.obj;
    if (DBG)
        logd("handleMessage what=" + msg.what);
    switch(msg.what) {
        case EVENT_SET_CALL_FORWARD_DONE:
            IccRecords r = mDefaultPhone.getIccRecords();
            Cf cf = (Cf) ar.userObj;
            if (cf.mIsCfu && ar.exception == null && r != null) {
                setVoiceCallForwardingFlag(r, 1, msg.arg1 == 1, cf.mSetCfNumber);
            }
            sendResponse(cf.mOnComplete, null, ar.exception);
            break;
        case EVENT_GET_CALL_FORWARD_DONE:
            CallForwardInfo[] cfInfos = null;
            if (ar.exception == null) {
                cfInfos = handleCfQueryResult((ImsCallForwardInfo[]) ar.result);
            }
            sendResponse((Message) ar.userObj, cfInfos, ar.exception);
            break;
        case EVENT_GET_CALL_BARRING_DONE:
        case EVENT_GET_CALL_WAITING_DONE:
            int[] ssInfos = null;
            if (ar.exception == null) {
                if (msg.what == EVENT_GET_CALL_BARRING_DONE) {
                    ssInfos = handleCbQueryResult((ImsSsInfo[]) ar.result);
                } else if (msg.what == EVENT_GET_CALL_WAITING_DONE) {
                    ssInfos = handleCwQueryResult((ImsSsInfo[]) ar.result);
                }
            }
            sendResponse((Message) ar.userObj, ssInfos, ar.exception);
            break;
        case EVENT_GET_CLIR_DONE:
            Bundle ssInfo = (Bundle) ar.result;
            int[] clirInfo = null;
            if (ssInfo != null) {
                clirInfo = ssInfo.getIntArray(ImsPhoneMmiCode.UT_BUNDLE_KEY_CLIR);
            }
            sendResponse((Message) ar.userObj, clirInfo, ar.exception);
            break;
        case EVENT_SET_CLIR_DONE:
            if (ar.exception == null) {
                saveClirSetting(msg.arg1);
            }
        // (Intentional fallthrough)
        case EVENT_SET_CALL_BARRING_DONE:
        case EVENT_SET_CALL_WAITING_DONE:
            sendResponse((Message) ar.userObj, null, ar.exception);
            break;
        case EVENT_DEFAULT_PHONE_DATA_STATE_CHANGED:
            if (DBG)
                logd("EVENT_DEFAULT_PHONE_DATA_STATE_CHANGED");
            updateDataServiceState();
            break;
        case EVENT_SERVICE_STATE_CHANGED:
            if (VDBG)
                logd("EVENT_SERVICE_STATE_CHANGED");
            ar = (AsyncResult) msg.obj;
            ServiceState newServiceState = (ServiceState) ar.result;
            // only update if roaming status changed
            if (mRoaming != newServiceState.getRoaming()) {
                if (DBG)
                    logd("Roaming state changed - " + mRoaming);
                // Update WFC mode only if voice or data is in service.
                // The STATE_IN_SERVICE is checked to prevent wifi calling mode change
                // when phone moves from roaming to no service.
                boolean isInService = (newServiceState.getVoiceRegState() == ServiceState.STATE_IN_SERVICE || newServiceState.getDataRegState() == ServiceState.STATE_IN_SERVICE);
                updateRoamingState(newServiceState.getRoaming(), isInService);
            }
            break;
        case EVENT_VOICE_CALL_ENDED:
            if (DBG)
                logd("Voice call ended. Handle pending updateRoamingState.");
            mCT.unregisterForVoiceCallEnded(this);
            // only update if roaming status changed
            boolean newRoaming = getCurrentRoaming();
            if (mRoaming != newRoaming) {
                updateRoamingState(newRoaming, true);
            }
            break;
        default:
            super.handleMessage(msg);
            break;
    }
}
#end_block

#method_before
private void updateRoamingState(boolean newRoaming, boolean canUpdateWfc) {
    if (mCT.getState() == PhoneConstants.State.IDLE) {
        if (DBG)
            logd("updateRoamingState now: " + newRoaming);
        mRoaming = newRoaming;
        if (canUpdateWfc) {
            ImsManager imsManager = ImsManager.getInstance(mContext, mPhoneId);
            imsManager.setWfcMode(imsManager.getWfcMode(newRoaming), newRoaming);
        } else {
            if (DBG)
                Rlog.d(LOG_TAG, "updateRoamingState service state is Out_of_service");
        }
    } else {
        if (DBG)
            logd("updateRoamingState postponed: " + newRoaming);
        mCT.registerForVoiceCallEnded(this, EVENT_VOICE_CALL_ENDED, null);
    }
}
#method_after
private void updateRoamingState(boolean newRoaming, boolean isInService) {
    if (mCT.getState() == PhoneConstants.State.IDLE) {
        if (DBG)
            logd("updateRoamingState now: " + newRoaming);
        mRoaming = newRoaming;
        if (isInService) {
            ImsManager imsManager = ImsManager.getInstance(mContext, mPhoneId);
            imsManager.setWfcMode(imsManager.getWfcMode(newRoaming), newRoaming);
        } else {
            if (DBG)
                Rlog.d(LOG_TAG, "updateRoamingState service state is OUT_OF_SERVICE");
        }
    } else {
        if (DBG)
            logd("updateRoamingState postponed: " + newRoaming);
        mCT.registerForVoiceCallEnded(this, EVENT_VOICE_CALL_ENDED, null);
    }
}
#end_block

#method_before
private boolean getCurrentRoaming() {
    TelephonyManager tm = (TelephonyManager) mContext.getSystemService(Context.TELEPHONY_SERVICE);
    return tm.isNetworkRoaming();
}
#method_after
private boolean getCurrentRoaming() {
    TelephonyManager tm = (TelephonyManager) mContext.getSystemService(Context.TELEPHONY_SERVICE);
    return tm.isNetworkRoaming(getSubId());
}
#end_block

#method_before
public void sendDtmf(char c, Message result) {
    logi("sendDtmf :: code=" + Rlog.pii(TAG, c));
    synchronized (mLockObj) {
        if (mSession != null) {
            mSession.sendDtmf(c, result);
        }
    }
}
#method_after
public void sendDtmf(char c, Message result) {
    logi("sendDtmf :: ");
    synchronized (mLockObj) {
        if (mSession != null) {
            mSession.sendDtmf(c, result);
        }
    }
}
#end_block

#method_before
public void startDtmf(char c) {
    logi("startDtmf :: code=" + Rlog.pii(TAG, c));
    synchronized (mLockObj) {
        if (mSession != null) {
            mSession.startDtmf(c);
        }
    }
}
#method_after
public void startDtmf(char c) {
    logi("startDtmf :: ");
    synchronized (mLockObj) {
        if (mSession != null) {
            mSession.startDtmf(c);
        }
    }
}
#end_block

#method_before
@RequiresPermission(android.Manifest.permission.ACCESS_NETWORK_STATE)
public void registerDefaultNetworkCallback(NetworkCallback networkCallback, Handler handler) {
    // This works because if the NetworkCapabilities are null,
    // ConnectivityService takes them from the default request.
    // 
    // Since the capabilities are exactly the same as the default request's
    // capabilities, this request is guaranteed, at all times, to be
    // satisfied by the same network, if any, that satisfies the default
    // request, i.e., the system default network.
    CallbackHandler cbHandler = new CallbackHandler(handler);
    sendRequestForNetwork(null, networkCallback, 0, REQUEST, TYPE_NONE, cbHandler);
}
#method_after
@RequiresPermission(android.Manifest.permission.ACCESS_NETWORK_STATE)
public void registerDefaultNetworkCallback(NetworkCallback networkCallback, Handler handler) {
    // This works because if the NetworkCapabilities are null,
    // ConnectivityService takes them from the default request.
    // 
    // Since the capabilities are exactly the same as the default request's
    // capabilities, this request is guaranteed, at all times, to be
    // satisfied by the same network, if any, that satisfies the default
    // request, i.e., the system default network.
    CallbackHandler cbHandler = new CallbackHandler(handler);
    sendRequestForNetwork(null, /* NetworkCapabilities need */
    networkCallback, 0, REQUEST, TYPE_NONE, cbHandler);
}
#end_block

#method_before
private void addValidationLogs(ReadOnlyLocalLog log, Network network, String networkExtraInfo) {
    synchronized (mValidationLogs) {
        while (mValidationLogs.size() >= MAX_VALIDATION_LOGS) {
            mValidationLogs.removeLast();
        }
        mValidationLogs.addFirst(new ValidationLog(network, networkExtraInfo, log));
    }
}
#method_after
private void addValidationLogs(ReadOnlyLocalLog log, Network network, String name) {
    synchronized (mValidationLogs) {
        while (mValidationLogs.size() >= MAX_VALIDATION_LOGS) {
            mValidationLogs.removeLast();
        }
        mValidationLogs.addFirst(new ValidationLog(network, name, log));
    }
}
#end_block

#method_before
private Network getActiveNetworkForUidInternal(final int uid, boolean ignoreBlocked) {
    final int user = UserHandle.getUserId(uid);
    int vpnNetId = NETID_UNSET;
    synchronized (mVpns) {
        final Vpn vpn = mVpns.get(user);
        if (vpn != null && vpn.appliesToUid(uid))
            vpnNetId = vpn.getNetId();
    }
    NetworkAgentInfo nai;
    if (vpnNetId != NETID_UNSET) {
        nai = getNetworkAgentInfoForNetId(vpnNetId);
        if (nai != null)
            return nai.network;
    }
    nai = getDefaultNetwork();
    if (nai != null && isNetworkWithLinkPropertiesBlocked(nai.linkProperties, uid, ignoreBlocked)) {
        nai = null;
    }
    return nai != null ? nai.network : null;
}
#method_after
private Network getActiveNetworkForUidInternal(final int uid, boolean ignoreBlocked) {
    final int user = UserHandle.getUserId(uid);
    int vpnNetId = NETID_UNSET;
    synchronized (mVpns) {
        final Vpn vpn = mVpns.get(user);
        // be removed as the satisfying test below should be enough.
        if (vpn != null && vpn.appliesToUid(uid))
            vpnNetId = vpn.getNetId();
    }
    NetworkAgentInfo nai;
    if (vpnNetId != NETID_UNSET) {
        nai = getNetworkAgentInfoForNetId(vpnNetId);
        if (nai != null) {
            final NetworkCapabilities requiredCaps = createDefaultNetworkCapabilitiesForUid(uid);
            if (requiredCaps.satisfiedByNetworkCapabilities(nai.networkCapabilities)) {
                return nai.network;
            }
        }
    }
    nai = getDefaultNetwork();
    if (nai != null && isNetworkWithLinkPropertiesBlocked(nai.linkProperties, uid, ignoreBlocked)) {
        nai = null;
    }
    return nai != null ? nai.network : null;
}
#end_block

#method_before
private NetworkCapabilities getNetworkCapabilitiesInternal(NetworkAgentInfo nai) {
    if (nai != null) {
        synchronized (nai) {
            if (nai.networkCapabilities != null) {
                return networkCapabilitiesWithoutUidsUnlessAllowed(nai.networkCapabilities, Binder.getCallingPid(), Binder.getCallingUid());
            }
        }
    }
    return null;
}
#method_after
private NetworkCapabilities getNetworkCapabilitiesInternal(NetworkAgentInfo nai) {
    if (nai != null) {
        synchronized (nai) {
            if (nai.networkCapabilities != null) {
                return networkCapabilitiesRestrictedForCallerPermissions(nai.networkCapabilities, Binder.getCallingPid(), Binder.getCallingUid());
            }
        }
    }
    return null;
}
#end_block

#method_before
@Override
public boolean isActiveNetworkMetered() {
    enforceAccessPermission();
    final NetworkCapabilities caps = getNetworkCapabilities(getActiveNetwork());
    if (caps != null) {
        return !caps.hasCapability(NetworkCapabilities.NET_CAPABILITY_NOT_METERED);
    } else {
        // Always return the most conservative value
        return true;
    }
}
#method_after
@Override
public boolean isActiveNetworkMetered() {
    enforceAccessPermission();
    final int uid = Binder.getCallingUid();
    final NetworkCapabilities caps = getUnfilteredActiveNetworkState(uid).networkCapabilities;
    if (caps != null) {
        return !caps.hasCapability(NetworkCapabilities.NET_CAPABILITY_NOT_METERED);
    } else {
        // Always return the most conservative value
        return true;
    }
}
#end_block

#method_before
private void sendStickyBroadcast(Intent intent) {
    synchronized (this) {
        if (!mSystemReady) {
            mInitialBroadcast = new Intent(intent);
        }
        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
        if (VDBG) {
            log("sendStickyBroadcast: action=" + intent.getAction());
        }
        Bundle options = null;
        final long ident = Binder.clearCallingIdentity();
        if (ConnectivityManager.CONNECTIVITY_ACTION.equals(intent.getAction())) {
            final NetworkInfo ni = intent.getParcelableExtra(ConnectivityManager.EXTRA_NETWORK_INFO);
            if (ni.getType() == ConnectivityManager.TYPE_MOBILE_SUPL) {
                intent.setAction(ConnectivityManager.CONNECTIVITY_ACTION_SUPL);
                intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
            } else {
                BroadcastOptions opts = BroadcastOptions.makeBasic();
                opts.setMaxManifestReceiverApiLevel(Build.VERSION_CODES.M);
                options = opts.toBundle();
            }
            final IBatteryStats bs = BatteryStatsService.getService();
            try {
                bs.noteConnectivityChanged(intent.getIntExtra(ConnectivityManager.EXTRA_NETWORK_TYPE, ConnectivityManager.TYPE_NONE), ni.getState().toString());
            } catch (RemoteException e) {
            }
        }
        try {
            mContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL, options);
        } finally {
            Binder.restoreCallingIdentity(ident);
        }
    }
}
#method_after
private void sendStickyBroadcast(Intent intent) {
    synchronized (this) {
        if (!mSystemReady) {
            mInitialBroadcast = new Intent(intent);
        }
        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
        if (VDBG) {
            log("sendStickyBroadcast: action=" + intent.getAction());
        }
        Bundle options = null;
        final long ident = Binder.clearCallingIdentity();
        if (ConnectivityManager.CONNECTIVITY_ACTION.equals(intent.getAction())) {
            final NetworkInfo ni = intent.getParcelableExtra(ConnectivityManager.EXTRA_NETWORK_INFO);
            if (ni.getType() == ConnectivityManager.TYPE_MOBILE_SUPL) {
                intent.setAction(ConnectivityManager.CONNECTIVITY_ACTION_SUPL);
                intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
            } else {
                BroadcastOptions opts = BroadcastOptions.makeBasic();
                opts.setMaxManifestReceiverApiLevel(Build.VERSION_CODES.M);
                options = opts.toBundle();
            }
            final IBatteryStats bs = BatteryStatsService.getService();
            try {
                bs.noteConnectivityChanged(intent.getIntExtra(ConnectivityManager.EXTRA_NETWORK_TYPE, ConnectivityManager.TYPE_NONE), ni.getState().toString());
            } catch (RemoteException e) {
            }
            intent.addFlags(Intent.FLAG_RECEIVER_VISIBLE_TO_INSTANT_APPS);
        }
        try {
            mContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL, options);
        } finally {
            Binder.restoreCallingIdentity(ident);
        }
    }
}
#end_block

#method_before
@Override
protected void dump(FileDescriptor fd, PrintWriter writer, String[] args) {
    final IndentingPrintWriter pw = new IndentingPrintWriter(writer, "  ");
    if (!DumpUtils.checkDumpPermission(mContext, TAG, pw))
        return;
    if (ArrayUtils.contains(args, DIAG_ARG)) {
        dumpNetworkDiagnostics(pw);
        return;
    } else if (ArrayUtils.contains(args, TETHERING_ARG)) {
        mTethering.dump(fd, pw, args);
        return;
    }
    pw.print("NetworkFactories for:");
    for (NetworkFactoryInfo nfi : mNetworkFactoryInfos.values()) {
        pw.print(" " + nfi.name);
    }
    pw.println();
    pw.println();
    final NetworkAgentInfo defaultNai = getDefaultNetwork();
    pw.print("Active default network: ");
    if (defaultNai == null) {
        pw.println("none");
    } else {
        pw.println(defaultNai.network.netId);
    }
    pw.println();
    pw.println("Current Networks:");
    pw.increaseIndent();
    for (NetworkAgentInfo nai : mNetworkAgentInfos.values()) {
        pw.println(nai.toString());
        pw.increaseIndent();
        pw.println(String.format("Requests: REQUEST:%d LISTEN:%d BACKGROUND_REQUEST:%d total:%d", nai.numForegroundNetworkRequests(), nai.numNetworkRequests() - nai.numRequestNetworkRequests(), nai.numBackgroundNetworkRequests(), nai.numNetworkRequests()));
        pw.increaseIndent();
        for (int i = 0; i < nai.numNetworkRequests(); i++) {
            pw.println(nai.requestAt(i).toString());
        }
        pw.decreaseIndent();
        pw.println("Lingered:");
        pw.increaseIndent();
        nai.dumpLingerTimers(pw);
        pw.decreaseIndent();
        pw.decreaseIndent();
    }
    pw.decreaseIndent();
    pw.println();
    pw.println("Network Requests:");
    pw.increaseIndent();
    for (NetworkRequestInfo nri : mNetworkRequests.values()) {
        pw.println(nri.toString());
    }
    pw.println();
    pw.decreaseIndent();
    mLegacyTypeTracker.dump(pw);
    pw.println();
    mTethering.dump(fd, pw, args);
    pw.println();
    mKeepaliveTracker.dump(pw);
    pw.println();
    dumpAvoidBadWifiSettings(pw);
    if (ArrayUtils.contains(args, SHORT_ARG) == false) {
        pw.println();
        synchronized (mValidationLogs) {
            pw.println("mValidationLogs (most recent first):");
            for (ValidationLog p : mValidationLogs) {
                pw.println(p.mNetwork + " - " + p.mNetworkExtraInfo);
                pw.increaseIndent();
                p.mLog.dump(fd, pw, args);
                pw.decreaseIndent();
            }
        }
        pw.println();
        pw.println("mNetworkRequestInfoLogs (most recent first):");
        pw.increaseIndent();
        mNetworkRequestInfoLogs.reverseDump(fd, pw, args);
        pw.decreaseIndent();
        pw.println();
        pw.println("mNetworkInfoBlockingLogs (most recent first):");
        pw.increaseIndent();
        mNetworkInfoBlockingLogs.reverseDump(fd, pw, args);
        pw.decreaseIndent();
        pw.println();
        pw.println("NetTransition WakeLock activity (most recent first):");
        pw.increaseIndent();
        pw.println("total acquisitions: " + mTotalWakelockAcquisitions);
        pw.println("total releases: " + mTotalWakelockReleases);
        pw.println("cumulative duration: " + (mTotalWakelockDurationMs / 1000) + "s");
        pw.println("longest duration: " + (mMaxWakelockDurationMs / 1000) + "s");
        if (mTotalWakelockAcquisitions > mTotalWakelockReleases) {
            long duration = SystemClock.elapsedRealtime() - mLastWakeLockAcquireTimestamp;
            pw.println("currently holding WakeLock for: " + (duration / 1000) + "s");
        }
        mWakelockLogs.reverseDump(fd, pw, args);
        pw.decreaseIndent();
    }
}
#method_after
@Override
protected void dump(FileDescriptor fd, PrintWriter writer, String[] args) {
    final IndentingPrintWriter pw = new IndentingPrintWriter(writer, "  ");
    if (!DumpUtils.checkDumpPermission(mContext, TAG, pw))
        return;
    if (ArrayUtils.contains(args, DIAG_ARG)) {
        dumpNetworkDiagnostics(pw);
        return;
    } else if (ArrayUtils.contains(args, TETHERING_ARG)) {
        mTethering.dump(fd, pw, args);
        return;
    }
    pw.print("NetworkFactories for:");
    for (NetworkFactoryInfo nfi : mNetworkFactoryInfos.values()) {
        pw.print(" " + nfi.name);
    }
    pw.println();
    pw.println();
    final NetworkAgentInfo defaultNai = getDefaultNetwork();
    pw.print("Active default network: ");
    if (defaultNai == null) {
        pw.println("none");
    } else {
        pw.println(defaultNai.network.netId);
    }
    pw.println();
    pw.println("Current Networks:");
    pw.increaseIndent();
    for (NetworkAgentInfo nai : mNetworkAgentInfos.values()) {
        pw.println(nai.toString());
        pw.increaseIndent();
        pw.println(String.format("Requests: REQUEST:%d LISTEN:%d BACKGROUND_REQUEST:%d total:%d", nai.numForegroundNetworkRequests(), nai.numNetworkRequests() - nai.numRequestNetworkRequests(), nai.numBackgroundNetworkRequests(), nai.numNetworkRequests()));
        pw.increaseIndent();
        for (int i = 0; i < nai.numNetworkRequests(); i++) {
            pw.println(nai.requestAt(i).toString());
        }
        pw.decreaseIndent();
        pw.println("Lingered:");
        pw.increaseIndent();
        nai.dumpLingerTimers(pw);
        pw.decreaseIndent();
        pw.decreaseIndent();
    }
    pw.decreaseIndent();
    pw.println();
    pw.println("Network Requests:");
    pw.increaseIndent();
    for (NetworkRequestInfo nri : mNetworkRequests.values()) {
        pw.println(nri.toString());
    }
    pw.println();
    pw.decreaseIndent();
    mLegacyTypeTracker.dump(pw);
    pw.println();
    mTethering.dump(fd, pw, args);
    pw.println();
    mKeepaliveTracker.dump(pw);
    pw.println();
    dumpAvoidBadWifiSettings(pw);
    if (ArrayUtils.contains(args, SHORT_ARG) == false) {
        pw.println();
        synchronized (mValidationLogs) {
            pw.println("mValidationLogs (most recent first):");
            for (ValidationLog p : mValidationLogs) {
                pw.println(p.mNetwork + " - " + p.mName);
                pw.increaseIndent();
                p.mLog.dump(fd, pw, args);
                pw.decreaseIndent();
            }
        }
        pw.println();
        pw.println("mNetworkRequestInfoLogs (most recent first):");
        pw.increaseIndent();
        mNetworkRequestInfoLogs.reverseDump(fd, pw, args);
        pw.decreaseIndent();
        pw.println();
        pw.println("mNetworkInfoBlockingLogs (most recent first):");
        pw.increaseIndent();
        mNetworkInfoBlockingLogs.reverseDump(fd, pw, args);
        pw.decreaseIndent();
        pw.println();
        pw.println("NetTransition WakeLock activity (most recent first):");
        pw.increaseIndent();
        pw.println("total acquisitions: " + mTotalWakelockAcquisitions);
        pw.println("total releases: " + mTotalWakelockReleases);
        pw.println("cumulative duration: " + (mTotalWakelockDurationMs / 1000) + "s");
        pw.println("longest duration: " + (mMaxWakelockDurationMs / 1000) + "s");
        if (mTotalWakelockAcquisitions > mTotalWakelockReleases) {
            long duration = SystemClock.elapsedRealtime() - mLastWakeLockAcquireTimestamp;
            pw.println("currently holding WakeLock for: " + (duration / 1000) + "s");
        }
        mWakelockLogs.reverseDump(fd, pw, args);
        pw.decreaseIndent();
    }
}
#end_block

#method_before
private void maybeHandleNetworkAgentMessage(Message msg) {
    NetworkAgentInfo nai = mNetworkAgentInfos.get(msg.replyTo);
    if (nai == null) {
        if (VDBG) {
            log(String.format("%s from unknown NetworkAgent", eventName(msg.what)));
        }
        return;
    }
    switch(msg.what) {
        case NetworkAgent.EVENT_NETWORK_CAPABILITIES_CHANGED:
            {
                final NetworkCapabilities networkCapabilities = (NetworkCapabilities) msg.obj;
                if (networkCapabilities.hasCapability(NET_CAPABILITY_CAPTIVE_PORTAL) || networkCapabilities.hasCapability(NET_CAPABILITY_VALIDATED) || networkCapabilities.hasCapability(NET_CAPABILITY_FOREGROUND)) {
                    Slog.wtf(TAG, "BUG: " + nai + " has CS-managed capability.");
                }
                updateCapabilities(nai.getCurrentScore(), nai, networkCapabilities);
                break;
            }
        case NetworkAgent.EVENT_NETWORK_PROPERTIES_CHANGED:
            {
                handleUpdateLinkProperties(nai, (LinkProperties) msg.obj);
                break;
            }
        case NetworkAgent.EVENT_NETWORK_INFO_CHANGED:
            {
                NetworkInfo info = (NetworkInfo) msg.obj;
                updateNetworkInfo(nai, info);
                break;
            }
        case NetworkAgent.EVENT_NETWORK_SCORE_CHANGED:
            {
                Integer score = (Integer) msg.obj;
                if (score != null)
                    updateNetworkScore(nai, score);
                break;
            }
        case NetworkAgent.EVENT_SET_EXPLICITLY_SELECTED:
            {
                if (nai.everConnected && !nai.networkMisc.explicitlySelected) {
                    loge("ERROR: already-connected network explicitly selected.");
                }
                nai.networkMisc.explicitlySelected = true;
                nai.networkMisc.acceptUnvalidated = (boolean) msg.obj;
                break;
            }
        case NetworkAgent.EVENT_PACKET_KEEPALIVE:
            {
                mKeepaliveTracker.handleEventPacketKeepalive(nai, msg);
                break;
            }
    }
}
#method_after
private void maybeHandleNetworkAgentMessage(Message msg) {
    NetworkAgentInfo nai = mNetworkAgentInfos.get(msg.replyTo);
    if (nai == null) {
        if (VDBG) {
            log(String.format("%s from unknown NetworkAgent", eventName(msg.what)));
        }
        return;
    }
    switch(msg.what) {
        case NetworkAgent.EVENT_NETWORK_CAPABILITIES_CHANGED:
            {
                final NetworkCapabilities networkCapabilities = (NetworkCapabilities) msg.obj;
                if (networkCapabilities.hasCapability(NET_CAPABILITY_CAPTIVE_PORTAL) || networkCapabilities.hasCapability(NET_CAPABILITY_VALIDATED) || networkCapabilities.hasCapability(NET_CAPABILITY_FOREGROUND)) {
                    Slog.wtf(TAG, "BUG: " + nai + " has CS-managed capability.");
                }
                updateCapabilities(nai.getCurrentScore(), nai, networkCapabilities);
                break;
            }
        case NetworkAgent.EVENT_NETWORK_PROPERTIES_CHANGED:
            {
                handleUpdateLinkProperties(nai, (LinkProperties) msg.obj);
                break;
            }
        case NetworkAgent.EVENT_NETWORK_INFO_CHANGED:
            {
                NetworkInfo info = (NetworkInfo) msg.obj;
                updateNetworkInfo(nai, info);
                break;
            }
        case NetworkAgent.EVENT_NETWORK_SCORE_CHANGED:
            {
                Integer score = (Integer) msg.obj;
                if (score != null)
                    updateNetworkScore(nai, score.intValue());
                break;
            }
        case NetworkAgent.EVENT_SET_EXPLICITLY_SELECTED:
            {
                if (nai.everConnected && !nai.networkMisc.explicitlySelected) {
                    loge("ERROR: already-connected network explicitly selected.");
                }
                nai.networkMisc.explicitlySelected = true;
                nai.networkMisc.acceptUnvalidated = (boolean) msg.obj;
                break;
            }
        case NetworkAgent.EVENT_PACKET_KEEPALIVE:
            {
                mKeepaliveTracker.handleEventPacketKeepalive(nai, msg);
                break;
            }
    }
}
#end_block

#method_before
private void handleAsyncChannelDisconnected(Message msg) {
    NetworkAgentInfo nai = mNetworkAgentInfos.get(msg.replyTo);
    if (nai != null) {
        if (DBG) {
            log(nai.name() + " got DISCONNECTED, was satisfying " + nai.numNetworkRequests());
        }
        // disconnect the channel.
        if (nai.networkInfo.isConnected()) {
            nai.networkInfo.setDetailedState(NetworkInfo.DetailedState.DISCONNECTED, null, null);
        }
        final boolean wasDefault = isDefaultNetwork(nai);
        if (wasDefault) {
            mDefaultInetConditionPublished = 0;
            // Log default network disconnection before required book-keeping.
            // Let rematchAllNetworksAndRequests() below record a new default network event
            // if there is a fallback. Taken together, the two form a X -> 0, 0 -> Y sequence
            // whose timestamps tell how long it takes to recover a default network.
            long now = SystemClock.elapsedRealtime();
            metricsLogger().defaultNetworkMetrics().logDefaultNetworkEvent(now, null, nai);
        }
        notifyIfacesChangedForNetworkStats();
        // TODO - we shouldn't send CALLBACK_LOST to requests that can be satisfied
        // by other networks that are already connected. Perhaps that can be done by
        // sending all CALLBACK_LOST messages (for requests, not listens) at the end
        // of rematchAllNetworksAndRequests
        notifyNetworkCallbacks(nai, ConnectivityManager.CALLBACK_LOST);
        mKeepaliveTracker.handleStopAllKeepalives(nai, ConnectivityManager.PacketKeepalive.ERROR_INVALID_NETWORK);
        for (String iface : nai.linkProperties.getAllInterfaceNames()) {
            // Disable wakeup packet monitoring for each interface.
            wakeupModifyInterface(iface, nai.networkCapabilities, false);
        }
        nai.networkMonitor.sendMessage(NetworkMonitor.CMD_NETWORK_DISCONNECTED);
        mNetworkAgentInfos.remove(msg.replyTo);
        nai.maybeStopClat();
        synchronized (mNetworkForNetId) {
            // Remove the NetworkAgent, but don't mark the netId as
            // available until we've told netd to delete it below.
            mNetworkForNetId.remove(nai.network.netId);
        }
        // Remove all previously satisfied requests.
        for (int i = 0; i < nai.numNetworkRequests(); i++) {
            NetworkRequest request = nai.requestAt(i);
            NetworkAgentInfo currentNetwork = getNetworkForRequest(request.requestId);
            if (currentNetwork != null && currentNetwork.network.netId == nai.network.netId) {
                clearNetworkForRequest(request.requestId);
                sendUpdatedScoreToFactories(request, 0);
            }
        }
        nai.clearLingerState();
        if (nai.isSatisfyingRequest(mDefaultRequest.requestId)) {
            removeDataActivityTracking(nai);
            notifyLockdownVpn(nai);
            ensureNetworkTransitionWakelock(nai.name());
        }
        mLegacyTypeTracker.remove(nai, wasDefault);
        rematchAllNetworksAndRequests(null, 0);
        mLingerMonitor.noteDisconnect(nai);
        if (nai.created) {
            // long time.
            try {
                mNetd.removeNetwork(nai.network.netId);
            } catch (Exception e) {
                loge("Exception removing network: " + e);
            }
            mDnsManager.removeNetwork(nai.network);
        }
        synchronized (mNetworkForNetId) {
            mNetIdInUse.delete(nai.network.netId);
        }
    } else {
        NetworkFactoryInfo nfi = mNetworkFactoryInfos.remove(msg.replyTo);
        if (DBG && nfi != null)
            log("unregisterNetworkFactory for " + nfi.name);
    }
}
#method_after
// This is a no-op if it's called with a message designating a network that has
// already been destroyed, because its reference will not be found in the relevant
private void handleAsyncChannelDisconnected(Message msg) {
    NetworkAgentInfo nai = mNetworkAgentInfos.get(msg.replyTo);
    if (nai != null) {
        disconnectAndDestroyNetwork(nai);
    } else {
        NetworkFactoryInfo nfi = mNetworkFactoryInfos.remove(msg.replyTo);
        if (DBG && nfi != null)
            log("unregisterNetworkFactory for " + nfi.name);
    }
}
#end_block

#method_before
private void handleDeprecatedGlobalHttpProxy() {
    String proxy = Settings.Global.getString(mContext.getContentResolver(), Settings.Global.HTTP_PROXY);
    if (!TextUtils.isEmpty(proxy)) {
        String[] data = proxy.split(":");
        if (data.length == 0) {
            return;
        }
        int proxyPort = 8080;
        if (data.length > 1) {
            try {
                proxyPort = Integer.parseInt(data[1]);
            } catch (NumberFormatException e) {
                return;
            }
        }
        ProxyInfo p = new ProxyInfo(data[0], proxyPort, "");
        setGlobalProxy(p);
    }
}
#method_after
private void handleDeprecatedGlobalHttpProxy() {
    final String proxy = Settings.Global.getString(mContext.getContentResolver(), Settings.Global.HTTP_PROXY);
    if (!TextUtils.isEmpty(proxy)) {
        String[] data = proxy.split(":");
        if (data.length == 0) {
            return;
        }
        final String proxyHost = data[0];
        int proxyPort = 8080;
        if (data.length > 1) {
            try {
                proxyPort = Integer.parseInt(data[1]);
            } catch (NumberFormatException e) {
                return;
            }
        }
        final ProxyInfo p = new ProxyInfo(proxyHost, proxyPort, "");
        setGlobalProxy(p);
    }
}
#end_block

#method_before
@Override
public void onChange(boolean selfChange, Uri uri) {
    final Integer what = mUriEventMap.get(uri);
    if (what != null) {
        mHandler.obtainMessage(what).sendToTarget();
    } else {
        loge("No matching event to send for URI=" + uri);
    }
}
#method_after
@Override
public void onChange(boolean selfChange, Uri uri) {
    final Integer what = mUriEventMap.get(uri);
    if (what != null) {
        mHandler.obtainMessage(what.intValue()).sendToTarget();
    } else {
        loge("No matching event to send for URI=" + uri);
    }
}
#end_block

#method_before
@Override
public NetworkRequest requestNetwork(NetworkCapabilities networkCapabilities, Messenger messenger, int timeoutMs, IBinder binder, int legacyType) {
    final NetworkRequest.Type type = (networkCapabilities == null) ? NetworkRequest.Type.TRACK_DEFAULT : NetworkRequest.Type.REQUEST;
    // the system default network.
    if (type == NetworkRequest.Type.TRACK_DEFAULT) {
        networkCapabilities = new NetworkCapabilities(mDefaultRequest.networkCapabilities);
        networkCapabilities.removeCapability(NET_CAPABILITY_NOT_VPN);
        enforceAccessPermission();
    } else {
        networkCapabilities = new NetworkCapabilities(networkCapabilities);
        enforceNetworkRequestPermissions(networkCapabilities);
        // TODO: this is incorrect. We mark the request as metered or not depending on the state
        // of the app when the request is filed, but we never change the request if the app
        // changes network state. http://b/29964605
        enforceMeteredApnPolicy(networkCapabilities);
    }
    ensureRequestableCapabilities(networkCapabilities);
    // Set the UID range for this request to the single UID of the requester, or to an empty
    // set of UIDs if the caller has the appropriate permission and UIDs have not been set.
    // This will overwrite any allowed UIDs in the requested capabilities. Though there
    // are no visible methods to set the UIDs, an app could use reflection to try and get
    // networks for other apps so it's essential that the UIDs are overwritten.
    restrictRequestUidsForCaller(networkCapabilities);
    if (timeoutMs < 0) {
        throw new IllegalArgumentException("Bad timeout specified");
    }
    ensureValidNetworkSpecifier(networkCapabilities);
    NetworkRequest networkRequest = new NetworkRequest(networkCapabilities, legacyType, nextNetworkRequestId(), type);
    NetworkRequestInfo nri = new NetworkRequestInfo(messenger, networkRequest, binder);
    if (DBG)
        log("requestNetwork for " + nri);
    mHandler.sendMessage(mHandler.obtainMessage(EVENT_REGISTER_NETWORK_REQUEST, nri));
    if (timeoutMs > 0) {
        mHandler.sendMessageDelayed(mHandler.obtainMessage(EVENT_TIMEOUT_NETWORK_REQUEST, nri), timeoutMs);
    }
    return networkRequest;
}
#method_after
@Override
public NetworkRequest requestNetwork(NetworkCapabilities networkCapabilities, Messenger messenger, int timeoutMs, IBinder binder, int legacyType) {
    final NetworkRequest.Type type = (networkCapabilities == null) ? NetworkRequest.Type.TRACK_DEFAULT : NetworkRequest.Type.REQUEST;
    // the system default network.
    if (type == NetworkRequest.Type.TRACK_DEFAULT) {
        networkCapabilities = createDefaultNetworkCapabilitiesForUid(Binder.getCallingUid());
        enforceAccessPermission();
    } else {
        networkCapabilities = new NetworkCapabilities(networkCapabilities);
        enforceNetworkRequestPermissions(networkCapabilities);
        // TODO: this is incorrect. We mark the request as metered or not depending on the state
        // of the app when the request is filed, but we never change the request if the app
        // changes network state. http://b/29964605
        enforceMeteredApnPolicy(networkCapabilities);
    }
    ensureRequestableCapabilities(networkCapabilities);
    ensureSufficientPermissionsForRequest(networkCapabilities, Binder.getCallingPid(), Binder.getCallingUid());
    // Set the UID range for this request to the single UID of the requester, or to an empty
    // set of UIDs if the caller has the appropriate permission and UIDs have not been set.
    // This will overwrite any allowed UIDs in the requested capabilities. Though there
    // are no visible methods to set the UIDs, an app could use reflection to try and get
    // networks for other apps so it's essential that the UIDs are overwritten.
    restrictRequestUidsForCaller(networkCapabilities);
    if (timeoutMs < 0) {
        throw new IllegalArgumentException("Bad timeout specified");
    }
    ensureValidNetworkSpecifier(networkCapabilities);
    NetworkRequest networkRequest = new NetworkRequest(networkCapabilities, legacyType, nextNetworkRequestId(), type);
    NetworkRequestInfo nri = new NetworkRequestInfo(messenger, networkRequest, binder);
    if (DBG)
        log("requestNetwork for " + nri);
    mHandler.sendMessage(mHandler.obtainMessage(EVENT_REGISTER_NETWORK_REQUEST, nri));
    if (timeoutMs > 0) {
        mHandler.sendMessageDelayed(mHandler.obtainMessage(EVENT_TIMEOUT_NETWORK_REQUEST, nri), timeoutMs);
    }
    return networkRequest;
}
#end_block

#method_before
@Override
public NetworkRequest pendingRequestForNetwork(NetworkCapabilities networkCapabilities, PendingIntent operation) {
    checkNotNull(operation, "PendingIntent cannot be null.");
    networkCapabilities = new NetworkCapabilities(networkCapabilities);
    enforceNetworkRequestPermissions(networkCapabilities);
    enforceMeteredApnPolicy(networkCapabilities);
    ensureRequestableCapabilities(networkCapabilities);
    ensureValidNetworkSpecifier(networkCapabilities);
    restrictRequestUidsForCaller(networkCapabilities);
    NetworkRequest networkRequest = new NetworkRequest(networkCapabilities, TYPE_NONE, nextNetworkRequestId(), NetworkRequest.Type.REQUEST);
    NetworkRequestInfo nri = new NetworkRequestInfo(networkRequest, operation);
    if (DBG)
        log("pendingRequest for " + nri);
    mHandler.sendMessage(mHandler.obtainMessage(EVENT_REGISTER_NETWORK_REQUEST_WITH_INTENT, nri));
    return networkRequest;
}
#method_after
@Override
public NetworkRequest pendingRequestForNetwork(NetworkCapabilities networkCapabilities, PendingIntent operation) {
    checkNotNull(operation, "PendingIntent cannot be null.");
    networkCapabilities = new NetworkCapabilities(networkCapabilities);
    enforceNetworkRequestPermissions(networkCapabilities);
    enforceMeteredApnPolicy(networkCapabilities);
    ensureRequestableCapabilities(networkCapabilities);
    ensureSufficientPermissionsForRequest(networkCapabilities, Binder.getCallingPid(), Binder.getCallingUid());
    ensureValidNetworkSpecifier(networkCapabilities);
    restrictRequestUidsForCaller(networkCapabilities);
    NetworkRequest networkRequest = new NetworkRequest(networkCapabilities, TYPE_NONE, nextNetworkRequestId(), NetworkRequest.Type.REQUEST);
    NetworkRequestInfo nri = new NetworkRequestInfo(networkRequest, operation);
    if (DBG)
        log("pendingRequest for " + nri);
    mHandler.sendMessage(mHandler.obtainMessage(EVENT_REGISTER_NETWORK_REQUEST_WITH_INTENT, nri));
    return networkRequest;
}
#end_block

#method_before
@Override
public NetworkRequest listenForNetwork(NetworkCapabilities networkCapabilities, Messenger messenger, IBinder binder) {
    if (!hasWifiNetworkListenPermission(networkCapabilities)) {
        enforceAccessPermission();
    }
    NetworkCapabilities nc = new NetworkCapabilities(networkCapabilities);
    restrictRequestUidsForCaller(nc);
    // Apps without the CHANGE_NETWORK_STATE permission can't use background networks, so
    // make all their listens include NET_CAPABILITY_FOREGROUND. That way, they will get
    // onLost and onAvailable callbacks when networks move in and out of the background.
    // There is no need to do this for requests because an app without CHANGE_NETWORK_STATE
    // can't request networks.
    restrictBackgroundRequestForCaller(nc);
    ensureValidNetworkSpecifier(nc);
    NetworkRequest networkRequest = new NetworkRequest(nc, TYPE_NONE, nextNetworkRequestId(), NetworkRequest.Type.LISTEN);
    NetworkRequestInfo nri = new NetworkRequestInfo(messenger, networkRequest, binder);
    if (VDBG)
        log("listenForNetwork for " + nri);
    mHandler.sendMessage(mHandler.obtainMessage(EVENT_REGISTER_NETWORK_LISTENER, nri));
    return networkRequest;
}
#method_after
@Override
public NetworkRequest listenForNetwork(NetworkCapabilities networkCapabilities, Messenger messenger, IBinder binder) {
    if (!hasWifiNetworkListenPermission(networkCapabilities)) {
        enforceAccessPermission();
    }
    NetworkCapabilities nc = new NetworkCapabilities(networkCapabilities);
    ensureSufficientPermissionsForRequest(networkCapabilities, Binder.getCallingPid(), Binder.getCallingUid());
    restrictRequestUidsForCaller(nc);
    // Apps without the CHANGE_NETWORK_STATE permission can't use background networks, so
    // make all their listens include NET_CAPABILITY_FOREGROUND. That way, they will get
    // onLost and onAvailable callbacks when networks move in and out of the background.
    // There is no need to do this for requests because an app without CHANGE_NETWORK_STATE
    // can't request networks.
    restrictBackgroundRequestForCaller(nc);
    ensureValidNetworkSpecifier(nc);
    NetworkRequest networkRequest = new NetworkRequest(nc, TYPE_NONE, nextNetworkRequestId(), NetworkRequest.Type.LISTEN);
    NetworkRequestInfo nri = new NetworkRequestInfo(messenger, networkRequest, binder);
    if (VDBG)
        log("listenForNetwork for " + nri);
    mHandler.sendMessage(mHandler.obtainMessage(EVENT_REGISTER_NETWORK_LISTENER, nri));
    return networkRequest;
}
#end_block

#method_before
@Override
public void pendingListenForNetwork(NetworkCapabilities networkCapabilities, PendingIntent operation) {
    checkNotNull(operation, "PendingIntent cannot be null.");
    if (!hasWifiNetworkListenPermission(networkCapabilities)) {
        enforceAccessPermission();
    }
    ensureValidNetworkSpecifier(networkCapabilities);
    final NetworkCapabilities nc = new NetworkCapabilities(networkCapabilities);
    restrictRequestUidsForCaller(nc);
    NetworkRequest networkRequest = new NetworkRequest(nc, TYPE_NONE, nextNetworkRequestId(), NetworkRequest.Type.LISTEN);
    NetworkRequestInfo nri = new NetworkRequestInfo(networkRequest, operation);
    if (VDBG)
        log("pendingListenForNetwork for " + nri);
    mHandler.sendMessage(mHandler.obtainMessage(EVENT_REGISTER_NETWORK_LISTENER, nri));
}
#method_after
@Override
public void pendingListenForNetwork(NetworkCapabilities networkCapabilities, PendingIntent operation) {
    checkNotNull(operation, "PendingIntent cannot be null.");
    if (!hasWifiNetworkListenPermission(networkCapabilities)) {
        enforceAccessPermission();
    }
    ensureValidNetworkSpecifier(networkCapabilities);
    ensureSufficientPermissionsForRequest(networkCapabilities, Binder.getCallingPid(), Binder.getCallingUid());
    final NetworkCapabilities nc = new NetworkCapabilities(networkCapabilities);
    restrictRequestUidsForCaller(nc);
    NetworkRequest networkRequest = new NetworkRequest(nc, TYPE_NONE, nextNetworkRequestId(), NetworkRequest.Type.LISTEN);
    NetworkRequestInfo nri = new NetworkRequestInfo(networkRequest, operation);
    if (VDBG)
        log("pendingListenForNetwork for " + nri);
    mHandler.sendMessage(mHandler.obtainMessage(EVENT_REGISTER_NETWORK_LISTENER, nri));
}
#end_block

#method_before
public int registerNetworkAgent(Messenger messenger, NetworkInfo networkInfo, LinkProperties linkProperties, NetworkCapabilities networkCapabilities, int currentScore, NetworkMisc networkMisc) {
    enforceConnectivityInternalPermission();
    LinkProperties lp = new LinkProperties(linkProperties);
    lp.ensureDirectlyConnectedRoutes();
    // TODO: Instead of passing mDefaultRequest, provide an API to determine whether a Network
    // satisfies mDefaultRequest.
    final NetworkCapabilities nc = new NetworkCapabilities(networkCapabilities);
    final NetworkAgentInfo nai = new NetworkAgentInfo(messenger, new AsyncChannel(), new Network(reserveNetId()), new NetworkInfo(networkInfo), lp, nc, currentScore, mContext, mTrackerHandler, new NetworkMisc(networkMisc), mDefaultRequest, this);
    // Make sure the network capabilities reflect what the agent info says.
    nai.networkCapabilities = mixInCapabilities(nai, nc);
    synchronized (this) {
        nai.networkMonitor.systemReady = mSystemReady;
    }
    addValidationLogs(nai.networkMonitor.getValidationLogs(), nai.network, networkInfo.getExtraInfo());
    if (DBG)
        log("registerNetworkAgent " + nai);
    mHandler.sendMessage(mHandler.obtainMessage(EVENT_REGISTER_NETWORK_AGENT, nai));
    return nai.network.netId;
}
#method_after
public int registerNetworkAgent(Messenger messenger, NetworkInfo networkInfo, LinkProperties linkProperties, NetworkCapabilities networkCapabilities, int currentScore, NetworkMisc networkMisc) {
    enforceConnectivityInternalPermission();
    LinkProperties lp = new LinkProperties(linkProperties);
    lp.ensureDirectlyConnectedRoutes();
    // TODO: Instead of passing mDefaultRequest, provide an API to determine whether a Network
    // satisfies mDefaultRequest.
    final NetworkCapabilities nc = new NetworkCapabilities(networkCapabilities);
    final NetworkAgentInfo nai = new NetworkAgentInfo(messenger, new AsyncChannel(), new Network(reserveNetId()), new NetworkInfo(networkInfo), lp, nc, currentScore, mContext, mTrackerHandler, new NetworkMisc(networkMisc), mDefaultRequest, this);
    // Make sure the network capabilities reflect what the agent info says.
    nai.networkCapabilities = mixInCapabilities(nai, nc);
    synchronized (this) {
        nai.networkMonitor.systemReady = mSystemReady;
    }
    final String extraInfo = networkInfo.getExtraInfo();
    final String name = TextUtils.isEmpty(extraInfo) ? nai.networkCapabilities.getSSID() : extraInfo;
    addValidationLogs(nai.networkMonitor.getValidationLogs(), nai.network, name);
    if (DBG)
        log("registerNetworkAgent " + nai);
    mHandler.sendMessage(mHandler.obtainMessage(EVENT_REGISTER_NETWORK_AGENT, nai));
    return nai.network.netId;
}
#end_block

#method_before
private void updateLinkProperties(NetworkAgentInfo networkAgent, LinkProperties oldLp) {
    LinkProperties newLp = networkAgent.linkProperties;
    int netId = networkAgent.network.netId;
    // we do anything else, make sure its LinkProperties are accurate.
    if (networkAgent.clatd != null) {
        networkAgent.clatd.fixupLinkProperties(oldLp);
    }
    updateInterfaces(newLp, oldLp, netId, networkAgent.networkCapabilities);
    updateMtu(newLp, oldLp);
    // TODO - figure out what to do for clat
    // for (LinkProperties lp : newLp.getStackedLinks()) {
    // updateMtu(lp, null);
    // }
    updateTcpBufferSizes(networkAgent);
    updateRoutes(newLp, oldLp, netId);
    updateDnses(newLp, oldLp, netId);
    // Make sure LinkProperties represents the latest private DNS status.
    // This does not need to be done before updateDnses because the
    // LinkProperties are not the source of the private DNS configuration.
    // updateDnses will fetch the private DNS configuration from DnsManager.
    mDnsManager.updatePrivateDnsStatus(netId, newLp);
    // Start or stop clat accordingly to network state.
    networkAgent.updateClat(mNetd);
    if (isDefaultNetwork(networkAgent)) {
        handleApplyDefaultProxy(newLp.getHttpProxy());
    } else {
        updateProxy(newLp, oldLp);
    }
    // TODO - move this check to cover the whole function
    if (!Objects.equals(newLp, oldLp)) {
        notifyIfacesChangedForNetworkStats();
        notifyNetworkCallbacks(networkAgent, ConnectivityManager.CALLBACK_IP_CHANGED);
    }
    mKeepaliveTracker.handleCheckKeepalivesStillValid(networkAgent);
}
#method_after
private void updateLinkProperties(NetworkAgentInfo networkAgent, LinkProperties oldLp) {
    LinkProperties newLp = new LinkProperties(networkAgent.linkProperties);
    int netId = networkAgent.network.netId;
    // we do anything else, make sure its LinkProperties are accurate.
    if (networkAgent.clatd != null) {
        networkAgent.clatd.fixupLinkProperties(oldLp, newLp);
    }
    updateInterfaces(newLp, oldLp, netId, networkAgent.networkCapabilities);
    updateMtu(newLp, oldLp);
    // TODO - figure out what to do for clat
    // for (LinkProperties lp : newLp.getStackedLinks()) {
    // updateMtu(lp, null);
    // }
    updateTcpBufferSizes(networkAgent);
    updateRoutes(newLp, oldLp, netId);
    updateDnses(newLp, oldLp, netId);
    // Make sure LinkProperties represents the latest private DNS status.
    // This does not need to be done before updateDnses because the
    // LinkProperties are not the source of the private DNS configuration.
    // updateDnses will fetch the private DNS configuration from DnsManager.
    mDnsManager.updatePrivateDnsStatus(netId, newLp);
    // Start or stop clat accordingly to network state.
    networkAgent.updateClat(mNetd);
    if (isDefaultNetwork(networkAgent)) {
        handleApplyDefaultProxy(newLp.getHttpProxy());
    } else {
        updateProxy(newLp, oldLp);
    }
    // TODO - move this check to cover the whole function
    if (!Objects.equals(newLp, oldLp)) {
        synchronized (networkAgent) {
            networkAgent.linkProperties = newLp;
        }
        notifyIfacesChangedForNetworkStats();
        notifyNetworkCallbacks(networkAgent, ConnectivityManager.CALLBACK_IP_CHANGED);
    }
    mKeepaliveTracker.handleCheckKeepalivesStillValid(networkAgent);
}
#end_block

#method_before
private void updateCapabilities(int oldScore, NetworkAgentInfo nai, NetworkCapabilities nc) {
    NetworkCapabilities newNc = mixInCapabilities(nai, nc);
    if (Objects.equals(nai.networkCapabilities, newNc))
        return;
    final String oldPermission = getNetworkPermission(nai.networkCapabilities);
    final String newPermission = getNetworkPermission(newNc);
    if (!Objects.equals(oldPermission, newPermission) && nai.created && !nai.isVPN()) {
        try {
            mNetd.setNetworkPermission(nai.network.netId, newPermission);
        } catch (RemoteException e) {
            loge("Exception in setNetworkPermission: " + e);
        }
    }
    final NetworkCapabilities prevNc;
    synchronized (nai) {
        prevNc = nai.networkCapabilities;
        nai.networkCapabilities = newNc;
    }
    updateUids(nai, prevNc, newNc);
    if (nai.getCurrentScore() == oldScore && newNc.equalRequestableCapabilities(prevNc)) {
        // If the requestable capabilities haven't changed, and the score hasn't changed, then
        // the change we're processing can't affect any requests, it can only affect the listens
        // on this network. We might have been called by rematchNetworkAndRequests when a
        // network changed foreground state.
        processListenRequests(nai, true);
    } else {
        // If the requestable capabilities have changed or the score changed, we can't have been
        // called by rematchNetworkAndRequests, so it's safe to start a rematch.
        rematchAllNetworksAndRequests(nai, oldScore);
        notifyNetworkCallbacks(nai, ConnectivityManager.CALLBACK_CAP_CHANGED);
    }
    // Report changes that are interesting for network statistics tracking.
    if (prevNc != null) {
        final boolean meteredChanged = prevNc.hasCapability(NET_CAPABILITY_NOT_METERED) != newNc.hasCapability(NET_CAPABILITY_NOT_METERED);
        final boolean roamingChanged = prevNc.hasCapability(NET_CAPABILITY_NOT_ROAMING) != newNc.hasCapability(NET_CAPABILITY_NOT_ROAMING);
        if (meteredChanged || roamingChanged) {
            notifyIfacesChangedForNetworkStats();
        }
    }
    if (!newNc.hasTransport(TRANSPORT_VPN)) {
        // bubble those changes through.
        synchronized (mVpns) {
            for (int i = 0; i < mVpns.size(); i++) {
                final Vpn vpn = mVpns.valueAt(i);
                vpn.updateCapabilities();
            }
        }
    }
}
#method_after
private void updateCapabilities(int oldScore, NetworkAgentInfo nai, NetworkCapabilities nc) {
    NetworkCapabilities newNc = mixInCapabilities(nai, nc);
    if (Objects.equals(nai.networkCapabilities, newNc))
        return;
    final String oldPermission = getNetworkPermission(nai.networkCapabilities);
    final String newPermission = getNetworkPermission(newNc);
    if (!Objects.equals(oldPermission, newPermission) && nai.created && !nai.isVPN()) {
        try {
            mNetd.setNetworkPermission(nai.network.netId, newPermission);
        } catch (RemoteException e) {
            loge("Exception in setNetworkPermission: " + e);
        }
    }
    final NetworkCapabilities prevNc;
    synchronized (nai) {
        prevNc = nai.networkCapabilities;
        nai.networkCapabilities = newNc;
    }
    updateUids(nai, prevNc, newNc);
    if (nai.getCurrentScore() == oldScore && newNc.equalRequestableCapabilities(prevNc)) {
        // If the requestable capabilities haven't changed, and the score hasn't changed, then
        // the change we're processing can't affect any requests, it can only affect the listens
        // on this network. We might have been called by rematchNetworkAndRequests when a
        // network changed foreground state.
        processListenRequests(nai, true);
    } else {
        // If the requestable capabilities have changed or the score changed, we can't have been
        // called by rematchNetworkAndRequests, so it's safe to start a rematch.
        rematchAllNetworksAndRequests(nai, oldScore);
        notifyNetworkCallbacks(nai, ConnectivityManager.CALLBACK_CAP_CHANGED);
    }
    // Report changes that are interesting for network statistics tracking.
    if (prevNc != null) {
        final boolean meteredChanged = prevNc.hasCapability(NET_CAPABILITY_NOT_METERED) != newNc.hasCapability(NET_CAPABILITY_NOT_METERED);
        final boolean roamingChanged = prevNc.hasCapability(NET_CAPABILITY_NOT_ROAMING) != newNc.hasCapability(NET_CAPABILITY_NOT_ROAMING);
        if (meteredChanged || roamingChanged) {
            notifyIfacesChangedForNetworkStats();
        }
    }
    if (!newNc.hasTransport(TRANSPORT_VPN)) {
        // Tell VPNs about updated capabilities, since they may need to
        // bubble those changes through.
        updateAllVpnsCapabilities();
    }
}
#end_block

#method_before
private void callCallbackForRequest(NetworkRequestInfo nri, NetworkAgentInfo networkAgent, int notificationType, int arg1) {
    if (nri.messenger == null) {
        // Default request has no msgr
        return;
    }
    Bundle bundle = new Bundle();
    // TODO: check if defensive copies of data is needed.
    putParcelable(bundle, new NetworkRequest(nri.request));
    Message msg = Message.obtain();
    if (notificationType != ConnectivityManager.CALLBACK_UNAVAIL) {
        putParcelable(bundle, networkAgent.network);
    }
    switch(notificationType) {
        case ConnectivityManager.CALLBACK_AVAILABLE:
            {
                putParcelable(bundle, new NetworkCapabilities(networkAgent.networkCapabilities));
                putParcelable(bundle, new LinkProperties(networkAgent.linkProperties));
                break;
            }
        case ConnectivityManager.CALLBACK_LOSING:
            {
                msg.arg1 = arg1;
                break;
            }
        case ConnectivityManager.CALLBACK_CAP_CHANGED:
            {
                // networkAgent can't be null as it has been accessed a few lines above.
                final NetworkCapabilities nc = networkCapabilitiesWithoutUidsUnlessAllowed(networkAgent.networkCapabilities, nri.mPid, nri.mUid);
                putParcelable(bundle, nc);
                break;
            }
        case ConnectivityManager.CALLBACK_IP_CHANGED:
            {
                putParcelable(bundle, new LinkProperties(networkAgent.linkProperties));
                break;
            }
    }
    msg.what = notificationType;
    msg.setData(bundle);
    try {
        if (VDBG) {
            String notification = ConnectivityManager.getCallbackName(notificationType);
            log("sending notification " + notification + " for " + nri.request);
        }
        nri.messenger.send(msg);
    } catch (RemoteException e) {
        // may occur naturally in the race of binder death.
        loge("RemoteException caught trying to send a callback msg for " + nri.request);
    }
}
#method_after
private void callCallbackForRequest(NetworkRequestInfo nri, NetworkAgentInfo networkAgent, int notificationType, int arg1) {
    if (nri.messenger == null) {
        // Default request has no msgr
        return;
    }
    Bundle bundle = new Bundle();
    // TODO: check if defensive copies of data is needed.
    putParcelable(bundle, new NetworkRequest(nri.request));
    Message msg = Message.obtain();
    if (notificationType != ConnectivityManager.CALLBACK_UNAVAIL) {
        putParcelable(bundle, networkAgent.network);
    }
    switch(notificationType) {
        case ConnectivityManager.CALLBACK_AVAILABLE:
            {
                putParcelable(bundle, new NetworkCapabilities(networkAgent.networkCapabilities));
                putParcelable(bundle, new LinkProperties(networkAgent.linkProperties));
                break;
            }
        case ConnectivityManager.CALLBACK_LOSING:
            {
                msg.arg1 = arg1;
                break;
            }
        case ConnectivityManager.CALLBACK_CAP_CHANGED:
            {
                // networkAgent can't be null as it has been accessed a few lines above.
                final NetworkCapabilities nc = networkCapabilitiesRestrictedForCallerPermissions(networkAgent.networkCapabilities, nri.mPid, nri.mUid);
                putParcelable(bundle, nc);
                break;
            }
        case ConnectivityManager.CALLBACK_IP_CHANGED:
            {
                putParcelable(bundle, new LinkProperties(networkAgent.linkProperties));
                break;
            }
    }
    msg.what = notificationType;
    msg.setData(bundle);
    try {
        if (VDBG) {
            String notification = ConnectivityManager.getCallbackName(notificationType);
            log("sending notification " + notification + " for " + nri.request);
        }
        nri.messenger.send(msg);
    } catch (RemoteException e) {
        // may occur naturally in the race of binder death.
        loge("RemoteException caught trying to send a callback msg for " + nri.request);
    }
}
#end_block

#method_before
// Handles a network appearing or improving its score.
// 
// - Evaluates all current NetworkRequests that can be
// satisfied by newNetwork, and reassigns to newNetwork
// any such requests for which newNetwork is the best.
// 
// - Lingers any validated Networks that as a result are no longer
// needed. A network is needed if it is the best network for
// one or more NetworkRequests, or if it is a VPN.
// 
// - Tears down newNetwork if it just became validated
// but turns out to be unneeded.
// 
// - If reapUnvalidatedNetworks==REAP, tears down unvalidated
// networks that have no chance (i.e. even if validated)
// of becoming the highest scoring network.
// 
// NOTE: This function only adds NetworkRequests that "newNetwork" could satisfy,
// it does not remove NetworkRequests that other Networks could better satisfy.
// If you need to handle decreases in score, use {@link rematchAllNetworksAndRequests}.
// This function should be used when possible instead of {@code rematchAllNetworksAndRequests}
// as it performs better by a factor of the number of Networks.
// 
// @param newNetwork is the network to be matched against NetworkRequests.
// @param reapUnvalidatedNetworks indicates if an additional pass over all networks should be
// performed to tear down unvalidated networks that have no chance (i.e. even if
private void rematchNetworkAndRequests(NetworkAgentInfo newNetwork, ReapUnvalidatedNetworks reapUnvalidatedNetworks, long now) {
    if (!newNetwork.everConnected)
        return;
    boolean keep = newNetwork.isVPN();
    boolean isNewDefault = false;
    NetworkAgentInfo oldDefaultNetwork = null;
    final boolean wasBackgroundNetwork = newNetwork.isBackgroundNetwork();
    final int score = newNetwork.getCurrentScore();
    if (VDBG)
        log("rematching " + newNetwork.name());
    // Find and migrate to this Network any NetworkRequests for
    // which this network is now the best.
    ArrayList<NetworkAgentInfo> affectedNetworks = new ArrayList<>();
    ArrayList<NetworkRequestInfo> addedRequests = new ArrayList<>();
    NetworkCapabilities nc = newNetwork.networkCapabilities;
    if (VDBG)
        log(" network has: " + nc);
    for (NetworkRequestInfo nri : mNetworkRequests.values()) {
        // requests or not, and doesn't affect the network's score.
        if (nri.request.isListen())
            continue;
        final NetworkAgentInfo currentNetwork = getNetworkForRequest(nri.request.requestId);
        final boolean satisfies = newNetwork.satisfies(nri.request);
        if (newNetwork == currentNetwork && satisfies) {
            if (VDBG) {
                log("Network " + newNetwork.name() + " was already satisfying" + " request " + nri.request.requestId + ". No change.");
            }
            keep = true;
            continue;
        }
        // check if it satisfies the NetworkCapabilities
        if (VDBG)
            log("  checking if request is satisfied: " + nri.request);
        if (satisfies) {
            // this request
            if (VDBG) {
                log("currentScore = " + (currentNetwork != null ? currentNetwork.getCurrentScore() : 0) + ", newScore = " + score);
            }
            if (currentNetwork == null || currentNetwork.getCurrentScore() < score) {
                if (VDBG)
                    log("rematch for " + newNetwork.name());
                if (currentNetwork != null) {
                    if (VDBG)
                        log("   accepting network in place of " + currentNetwork.name());
                    currentNetwork.removeRequest(nri.request.requestId);
                    currentNetwork.lingerRequest(nri.request, now, mLingerDelayMs);
                    affectedNetworks.add(currentNetwork);
                } else {
                    if (VDBG)
                        log("   accepting network in place of null");
                }
                newNetwork.unlingerRequest(nri.request);
                setNetworkForRequest(nri.request.requestId, newNetwork);
                if (!newNetwork.addRequest(nri.request)) {
                    Slog.wtf(TAG, "BUG: " + newNetwork.name() + " already has " + nri.request);
                }
                addedRequests.add(nri);
                keep = true;
                // Tell NetworkFactories about the new score, so they can stop
                // trying to connect if they know they cannot match it.
                // TODO - this could get expensive if we have alot of requests for this
                // network.  Think about if there is a way to reduce this.  Push
                // netid->request mapping to each factory?
                sendUpdatedScoreToFactories(nri.request, score);
                if (isDefaultRequest(nri)) {
                    isNewDefault = true;
                    oldDefaultNetwork = currentNetwork;
                    if (currentNetwork != null) {
                        mLingerMonitor.noteLingerDefaultNetwork(currentNetwork, newNetwork);
                    }
                }
            }
        } else if (newNetwork.isSatisfyingRequest(nri.request.requestId)) {
            // longer satisfies "nri" when "currentNetwork" does not equal "newNetwork".
            if (DBG) {
                log("Network " + newNetwork.name() + " stopped satisfying" + " request " + nri.request.requestId);
            }
            newNetwork.removeRequest(nri.request.requestId);
            if (currentNetwork == newNetwork) {
                clearNetworkForRequest(nri.request.requestId);
                sendUpdatedScoreToFactories(nri.request, 0);
            } else {
                Slog.wtf(TAG, "BUG: Removing request " + nri.request.requestId + " from " + newNetwork.name() + " without updating mNetworkForRequestId or factories!");
            }
            // TODO: Technically, sending CALLBACK_LOST here is
            // incorrect if there is a replacement network currently
            // connected that can satisfy nri, which is a request
            // (not a listen). However, the only capability that can both
            // a) be requested and b) change is NET_CAPABILITY_TRUSTED,
            // so this code is only incorrect for a network that loses
            // the TRUSTED capability, which is a rare case.
            callCallbackForRequest(nri, newNetwork, ConnectivityManager.CALLBACK_LOST, 0);
        }
    }
    if (isNewDefault) {
        // Notify system services that this network is up.
        makeDefault(newNetwork);
        // Log 0 -> X and Y -> X default network transitions, where X is the new default.
        metricsLogger().defaultNetworkMetrics().logDefaultNetworkEvent(now, newNetwork, oldDefaultNetwork);
        // Have a new default network, release the transition wakelock in
        scheduleReleaseNetworkTransitionWakelock();
    }
    if (!newNetwork.networkCapabilities.equalRequestableCapabilities(nc)) {
        Slog.wtf(TAG, String.format("BUG: %s changed requestable capabilities during rematch: %s -> %s", newNetwork.name(), nc, newNetwork.networkCapabilities));
    }
    if (newNetwork.getCurrentScore() != score) {
        Slog.wtf(TAG, String.format("BUG: %s changed score during rematch: %d -> %d", newNetwork.name(), score, newNetwork.getCurrentScore()));
    }
    // Second pass: process all listens.
    if (wasBackgroundNetwork != newNetwork.isBackgroundNetwork()) {
        // If the network went from background to foreground or vice versa, we need to update
        // its foreground state. It is safe to do this after rematching the requests because
        // NET_CAPABILITY_FOREGROUND does not affect requests, as is not a requestable
        // capability and does not affect the network's score (see the Slog.wtf call above).
        updateCapabilities(score, newNetwork, newNetwork.networkCapabilities);
    } else {
        processListenRequests(newNetwork, false);
    }
    // before LegacyTypeTracker sends legacy broadcasts
    for (NetworkRequestInfo nri : addedRequests) notifyNetworkAvailable(newNetwork, nri);
    // available callback for newNetwork.
    for (NetworkAgentInfo nai : affectedNetworks) {
        updateLingerState(nai, now);
    }
    // Possibly unlinger newNetwork. Unlingering a network does not send any callbacks so it
    // does not need to be done in any particular order.
    updateLingerState(newNetwork, now);
    if (isNewDefault) {
        // the new one connected.
        if (oldDefaultNetwork != null) {
            mLegacyTypeTracker.remove(oldDefaultNetwork.networkInfo.getType(), oldDefaultNetwork, true);
        }
        mDefaultInetConditionPublished = newNetwork.lastValidated ? 100 : 0;
        mLegacyTypeTracker.add(newNetwork.networkInfo.getType(), newNetwork);
        notifyLockdownVpn(newNetwork);
    }
    if (keep) {
        // TODO: Avoid redoing this; this must only be done once when a network comes online.
        try {
            final IBatteryStats bs = BatteryStatsService.getService();
            final int type = newNetwork.networkInfo.getType();
            final String baseIface = newNetwork.linkProperties.getInterfaceName();
            bs.noteNetworkInterfaceType(baseIface, type);
            for (LinkProperties stacked : newNetwork.linkProperties.getStackedLinks()) {
                final String stackedIface = stacked.getInterfaceName();
                bs.noteNetworkInterfaceType(stackedIface, type);
            }
        } catch (RemoteException ignored) {
        }
        // This is on top of the multiple intent sequencing referenced in the todo above.
        for (int i = 0; i < newNetwork.numNetworkRequests(); i++) {
            NetworkRequest nr = newNetwork.requestAt(i);
            if (nr.legacyType != TYPE_NONE && nr.isRequest()) {
                // legacy type tracker filters out repeat adds
                mLegacyTypeTracker.add(nr.legacyType, newNetwork);
            }
        }
        // newNetwork to the tracker explicitly (it's a no-op if it has already been added).
        if (newNetwork.isVPN()) {
            mLegacyTypeTracker.add(TYPE_VPN, newNetwork);
        }
    }
    if (reapUnvalidatedNetworks == ReapUnvalidatedNetworks.REAP) {
        for (NetworkAgentInfo nai : mNetworkAgentInfos.values()) {
            if (unneeded(nai, UnneededFor.TEARDOWN)) {
                if (nai.getLingerExpiry() > 0) {
                    // This network has active linger timers and no requests, but is not
                    // lingering. Linger it.
                    // 
                    // One way (the only way?) this can happen if this network is unvalidated
                    // and became unneeded due to another network improving its score to the
                    // point where this network will no longer be able to satisfy any requests
                    // even if it validates.
                    updateLingerState(nai, now);
                } else {
                    if (DBG)
                        log("Reaping " + nai.name());
                    teardownUnneededNetwork(nai);
                }
            }
        }
    }
}
#method_after
// Handles a network appearing or improving its score.
// 
// - Evaluates all current NetworkRequests that can be
// satisfied by newNetwork, and reassigns to newNetwork
// any such requests for which newNetwork is the best.
// 
// - Lingers any validated Networks that as a result are no longer
// needed. A network is needed if it is the best network for
// one or more NetworkRequests, or if it is a VPN.
// 
// - Tears down newNetwork if it just became validated
// but turns out to be unneeded.
// 
// - If reapUnvalidatedNetworks==REAP, tears down unvalidated
// networks that have no chance (i.e. even if validated)
// of becoming the highest scoring network.
// 
// NOTE: This function only adds NetworkRequests that "newNetwork" could satisfy,
// it does not remove NetworkRequests that other Networks could better satisfy.
// If you need to handle decreases in score, use {@link rematchAllNetworksAndRequests}.
// This function should be used when possible instead of {@code rematchAllNetworksAndRequests}
// as it performs better by a factor of the number of Networks.
// 
// @param newNetwork is the network to be matched against NetworkRequests.
// @param reapUnvalidatedNetworks indicates if an additional pass over all networks should be
// performed to tear down unvalidated networks that have no chance (i.e. even if
private void rematchNetworkAndRequests(NetworkAgentInfo newNetwork, ReapUnvalidatedNetworks reapUnvalidatedNetworks, long now) {
    if (!newNetwork.everConnected)
        return;
    boolean keep = newNetwork.isVPN();
    boolean isNewDefault = false;
    NetworkAgentInfo oldDefaultNetwork = null;
    final boolean wasBackgroundNetwork = newNetwork.isBackgroundNetwork();
    final int score = newNetwork.getCurrentScore();
    if (VDBG)
        log("rematching " + newNetwork.name());
    // Find and migrate to this Network any NetworkRequests for
    // which this network is now the best.
    ArrayList<NetworkAgentInfo> affectedNetworks = new ArrayList<>();
    ArrayList<NetworkRequestInfo> addedRequests = new ArrayList<>();
    NetworkCapabilities nc = newNetwork.networkCapabilities;
    if (VDBG)
        log(" network has: " + nc);
    for (NetworkRequestInfo nri : mNetworkRequests.values()) {
        // requests or not, and doesn't affect the network's score.
        if (nri.request.isListen())
            continue;
        final NetworkAgentInfo currentNetwork = getNetworkForRequest(nri.request.requestId);
        final boolean satisfies = newNetwork.satisfies(nri.request);
        if (newNetwork == currentNetwork && satisfies) {
            if (VDBG) {
                log("Network " + newNetwork.name() + " was already satisfying" + " request " + nri.request.requestId + ". No change.");
            }
            keep = true;
            continue;
        }
        // check if it satisfies the NetworkCapabilities
        if (VDBG)
            log("  checking if request is satisfied: " + nri.request);
        if (satisfies) {
            // this request
            if (VDBG) {
                log("currentScore = " + (currentNetwork != null ? currentNetwork.getCurrentScore() : 0) + ", newScore = " + score);
            }
            if (currentNetwork == null || currentNetwork.getCurrentScore() < score) {
                if (VDBG)
                    log("rematch for " + newNetwork.name());
                if (currentNetwork != null) {
                    if (VDBG)
                        log("   accepting network in place of " + currentNetwork.name());
                    currentNetwork.removeRequest(nri.request.requestId);
                    currentNetwork.lingerRequest(nri.request, now, mLingerDelayMs);
                    affectedNetworks.add(currentNetwork);
                } else {
                    if (VDBG)
                        log("   accepting network in place of null");
                }
                newNetwork.unlingerRequest(nri.request);
                setNetworkForRequest(nri.request.requestId, newNetwork);
                if (!newNetwork.addRequest(nri.request)) {
                    Slog.wtf(TAG, "BUG: " + newNetwork.name() + " already has " + nri.request);
                }
                addedRequests.add(nri);
                keep = true;
                // Tell NetworkFactories about the new score, so they can stop
                // trying to connect if they know they cannot match it.
                // TODO - this could get expensive if we have a lot of requests for this
                // network.  Think about if there is a way to reduce this.  Push
                // netid->request mapping to each factory?
                sendUpdatedScoreToFactories(nri.request, score);
                if (isDefaultRequest(nri)) {
                    isNewDefault = true;
                    oldDefaultNetwork = currentNetwork;
                    if (currentNetwork != null) {
                        mLingerMonitor.noteLingerDefaultNetwork(currentNetwork, newNetwork);
                    }
                }
            }
        } else if (newNetwork.isSatisfyingRequest(nri.request.requestId)) {
            // longer satisfies "nri" when "currentNetwork" does not equal "newNetwork".
            if (DBG) {
                log("Network " + newNetwork.name() + " stopped satisfying" + " request " + nri.request.requestId);
            }
            newNetwork.removeRequest(nri.request.requestId);
            if (currentNetwork == newNetwork) {
                clearNetworkForRequest(nri.request.requestId);
                sendUpdatedScoreToFactories(nri.request, 0);
            } else {
                Slog.wtf(TAG, "BUG: Removing request " + nri.request.requestId + " from " + newNetwork.name() + " without updating mNetworkForRequestId or factories!");
            }
            // TODO: Technically, sending CALLBACK_LOST here is
            // incorrect if there is a replacement network currently
            // connected that can satisfy nri, which is a request
            // (not a listen). However, the only capability that can both
            // a) be requested and b) change is NET_CAPABILITY_TRUSTED,
            // so this code is only incorrect for a network that loses
            // the TRUSTED capability, which is a rare case.
            callCallbackForRequest(nri, newNetwork, ConnectivityManager.CALLBACK_LOST, 0);
        }
    }
    if (isNewDefault) {
        // Notify system services that this network is up.
        makeDefault(newNetwork);
        // Log 0 -> X and Y -> X default network transitions, where X is the new default.
        metricsLogger().defaultNetworkMetrics().logDefaultNetworkEvent(now, newNetwork, oldDefaultNetwork);
        // Have a new default network, release the transition wakelock in
        scheduleReleaseNetworkTransitionWakelock();
    }
    if (!newNetwork.networkCapabilities.equalRequestableCapabilities(nc)) {
        Slog.wtf(TAG, String.format("BUG: %s changed requestable capabilities during rematch: %s -> %s", newNetwork.name(), nc, newNetwork.networkCapabilities));
    }
    if (newNetwork.getCurrentScore() != score) {
        Slog.wtf(TAG, String.format("BUG: %s changed score during rematch: %d -> %d", newNetwork.name(), score, newNetwork.getCurrentScore()));
    }
    // Second pass: process all listens.
    if (wasBackgroundNetwork != newNetwork.isBackgroundNetwork()) {
        // If the network went from background to foreground or vice versa, we need to update
        // its foreground state. It is safe to do this after rematching the requests because
        // NET_CAPABILITY_FOREGROUND does not affect requests, as is not a requestable
        // capability and does not affect the network's score (see the Slog.wtf call above).
        updateCapabilities(score, newNetwork, newNetwork.networkCapabilities);
    } else {
        processListenRequests(newNetwork, false);
    }
    // before LegacyTypeTracker sends legacy broadcasts
    for (NetworkRequestInfo nri : addedRequests) notifyNetworkAvailable(newNetwork, nri);
    // available callback for newNetwork.
    for (NetworkAgentInfo nai : affectedNetworks) {
        updateLingerState(nai, now);
    }
    // Possibly unlinger newNetwork. Unlingering a network does not send any callbacks so it
    // does not need to be done in any particular order.
    updateLingerState(newNetwork, now);
    if (isNewDefault) {
        // the new one connected.
        if (oldDefaultNetwork != null) {
            mLegacyTypeTracker.remove(oldDefaultNetwork.networkInfo.getType(), oldDefaultNetwork, true);
        }
        mDefaultInetConditionPublished = newNetwork.lastValidated ? 100 : 0;
        mLegacyTypeTracker.add(newNetwork.networkInfo.getType(), newNetwork);
        notifyLockdownVpn(newNetwork);
    }
    if (keep) {
        // TODO: Avoid redoing this; this must only be done once when a network comes online.
        try {
            final IBatteryStats bs = BatteryStatsService.getService();
            final int type = newNetwork.networkInfo.getType();
            final String baseIface = newNetwork.linkProperties.getInterfaceName();
            bs.noteNetworkInterfaceType(baseIface, type);
            for (LinkProperties stacked : newNetwork.linkProperties.getStackedLinks()) {
                final String stackedIface = stacked.getInterfaceName();
                bs.noteNetworkInterfaceType(stackedIface, type);
            }
        } catch (RemoteException ignored) {
        }
        // This is on top of the multiple intent sequencing referenced in the todo above.
        for (int i = 0; i < newNetwork.numNetworkRequests(); i++) {
            NetworkRequest nr = newNetwork.requestAt(i);
            if (nr.legacyType != TYPE_NONE && nr.isRequest()) {
                // legacy type tracker filters out repeat adds
                mLegacyTypeTracker.add(nr.legacyType, newNetwork);
            }
        }
        // newNetwork to the tracker explicitly (it's a no-op if it has already been added).
        if (newNetwork.isVPN()) {
            mLegacyTypeTracker.add(TYPE_VPN, newNetwork);
        }
    }
    if (reapUnvalidatedNetworks == ReapUnvalidatedNetworks.REAP) {
        for (NetworkAgentInfo nai : mNetworkAgentInfos.values()) {
            if (unneeded(nai, UnneededFor.TEARDOWN)) {
                if (nai.getLingerExpiry() > 0) {
                    // This network has active linger timers and no requests, but is not
                    // lingering. Linger it.
                    // 
                    // One way (the only way?) this can happen if this network is unvalidated
                    // and became unneeded due to another network improving its score to the
                    // point where this network will no longer be able to satisfy any requests
                    // even if it validates.
                    updateLingerState(nai, now);
                } else {
                    if (DBG)
                        log("Reaping " + nai.name());
                    teardownUnneededNetwork(nai);
                }
            }
        }
    }
}
#end_block

#method_before
private void updateNetworkInfo(NetworkAgentInfo networkAgent, NetworkInfo newInfo) {
    final NetworkInfo.State state = newInfo.getState();
    NetworkInfo oldInfo = null;
    final int oldScore = networkAgent.getCurrentScore();
    synchronized (networkAgent) {
        oldInfo = networkAgent.networkInfo;
        networkAgent.networkInfo = newInfo;
    }
    notifyLockdownVpn(networkAgent);
    if (DBG) {
        log(networkAgent.name() + " EVENT_NETWORK_INFO_CHANGED, going from " + (oldInfo == null ? "null" : oldInfo.getState()) + " to " + state);
    }
    if (!networkAgent.created && (state == NetworkInfo.State.CONNECTED || (state == NetworkInfo.State.CONNECTING && networkAgent.isVPN()))) {
        // A network that has just connected has zero requests and is thus a foreground network.
        networkAgent.networkCapabilities.addCapability(NET_CAPABILITY_FOREGROUND);
        try {
            // This should never fail.  Specifying an already in use NetID will cause failure.
            if (networkAgent.isVPN()) {
                mNetd.createVirtualNetwork(networkAgent.network.netId, !networkAgent.linkProperties.getDnsServers().isEmpty(), (networkAgent.networkMisc == null || !networkAgent.networkMisc.allowBypass));
            } else {
                mNetd.createPhysicalNetwork(networkAgent.network.netId, getNetworkPermission(networkAgent.networkCapabilities));
            }
        } catch (Exception e) {
            loge("Error creating network " + networkAgent.network.netId + ": " + e.getMessage());
            return;
        }
        networkAgent.created = true;
    }
    if (!networkAgent.everConnected && state == NetworkInfo.State.CONNECTED) {
        networkAgent.everConnected = true;
        if (networkAgent.linkProperties == null) {
            Slog.wtf(TAG, networkAgent.name() + " connected with null LinkProperties");
        }
        handlePerNetworkPrivateDnsConfig(networkAgent, mDnsManager.getPrivateDnsConfig());
        updateLinkProperties(networkAgent, null);
        networkAgent.networkMonitor.sendMessage(NetworkMonitor.CMD_NETWORK_CONNECTED);
        scheduleUnvalidatedPrompt(networkAgent);
        if (networkAgent.isVPN()) {
            // Temporarily disable the default proxy (not global).
            synchronized (mProxyLock) {
                if (!mDefaultProxyDisabled) {
                    mDefaultProxyDisabled = true;
                    if (mGlobalProxy == null && mDefaultProxy != null) {
                        sendProxyBroadcast(null);
                    }
                }
            }
        // TODO: support proxy per network.
        }
        // Whether a particular NetworkRequest listen should cause signal strength thresholds to
        // be communicated to a particular NetworkAgent depends only on the network's immutable,
        // capabilities, so it only needs to be done once on initial connect, not every time the
        // network's capabilities change. Note that we do this before rematching the network,
        // so we could decide to tear it down immediately afterwards. That's fine though - on
        // disconnection NetworkAgents should stop any signal strength monitoring they have been
        // doing.
        updateSignalStrengthThresholds(networkAgent, "CONNECT", null);
        // Consider network even though it is not yet validated.
        final long now = SystemClock.elapsedRealtime();
        rematchNetworkAndRequests(networkAgent, ReapUnvalidatedNetworks.REAP, now);
        // This has to happen after matching the requests, because callbacks are just requests.
        notifyNetworkCallbacks(networkAgent, ConnectivityManager.CALLBACK_PRECHECK);
    } else if (state == NetworkInfo.State.DISCONNECTED) {
        networkAgent.asyncChannel.disconnect();
        if (networkAgent.isVPN()) {
            synchronized (mProxyLock) {
                if (mDefaultProxyDisabled) {
                    mDefaultProxyDisabled = false;
                    if (mGlobalProxy == null && mDefaultProxy != null) {
                        sendProxyBroadcast(mDefaultProxy);
                    }
                }
            }
            updateUids(networkAgent, networkAgent.networkCapabilities, null);
        }
    } else if ((oldInfo != null && oldInfo.getState() == NetworkInfo.State.SUSPENDED) || state == NetworkInfo.State.SUSPENDED) {
        // going into or coming out of SUSPEND: re-score and notify
        if (networkAgent.getCurrentScore() != oldScore) {
            rematchAllNetworksAndRequests(networkAgent, oldScore);
        }
        updateCapabilities(networkAgent.getCurrentScore(), networkAgent, networkAgent.networkCapabilities);
        // TODO (b/73132094) : remove this call once the few users of onSuspended and
        // onResumed have been removed.
        notifyNetworkCallbacks(networkAgent, (state == NetworkInfo.State.SUSPENDED ? ConnectivityManager.CALLBACK_SUSPENDED : ConnectivityManager.CALLBACK_RESUMED));
        mLegacyTypeTracker.update(networkAgent);
    }
}
#method_after
private void updateNetworkInfo(NetworkAgentInfo networkAgent, NetworkInfo newInfo) {
    final NetworkInfo.State state = newInfo.getState();
    NetworkInfo oldInfo = null;
    final int oldScore = networkAgent.getCurrentScore();
    synchronized (networkAgent) {
        oldInfo = networkAgent.networkInfo;
        networkAgent.networkInfo = newInfo;
    }
    notifyLockdownVpn(networkAgent);
    if (DBG) {
        log(networkAgent.name() + " EVENT_NETWORK_INFO_CHANGED, going from " + (oldInfo == null ? "null" : oldInfo.getState()) + " to " + state);
    }
    if (!networkAgent.created && (state == NetworkInfo.State.CONNECTED || (state == NetworkInfo.State.CONNECTING && networkAgent.isVPN()))) {
        // A network that has just connected has zero requests and is thus a foreground network.
        networkAgent.networkCapabilities.addCapability(NET_CAPABILITY_FOREGROUND);
        try {
            // This should never fail.  Specifying an already in use NetID will cause failure.
            if (networkAgent.isVPN()) {
                mNetd.createVirtualNetwork(networkAgent.network.netId, !networkAgent.linkProperties.getDnsServers().isEmpty(), (networkAgent.networkMisc == null || !networkAgent.networkMisc.allowBypass));
            } else {
                mNetd.createPhysicalNetwork(networkAgent.network.netId, getNetworkPermission(networkAgent.networkCapabilities));
            }
        } catch (Exception e) {
            loge("Error creating network " + networkAgent.network.netId + ": " + e.getMessage());
            return;
        }
        networkAgent.created = true;
    }
    if (!networkAgent.everConnected && state == NetworkInfo.State.CONNECTED) {
        networkAgent.everConnected = true;
        if (networkAgent.linkProperties == null) {
            Slog.wtf(TAG, networkAgent.name() + " connected with null LinkProperties");
        }
        handlePerNetworkPrivateDnsConfig(networkAgent, mDnsManager.getPrivateDnsConfig());
        updateLinkProperties(networkAgent, null);
        networkAgent.networkMonitor.sendMessage(NetworkMonitor.CMD_NETWORK_CONNECTED);
        scheduleUnvalidatedPrompt(networkAgent);
        if (networkAgent.isVPN()) {
            // Temporarily disable the default proxy (not global).
            synchronized (mProxyLock) {
                if (!mDefaultProxyDisabled) {
                    mDefaultProxyDisabled = true;
                    if (mGlobalProxy == null && mDefaultProxy != null) {
                        sendProxyBroadcast(null);
                    }
                }
            }
        // TODO: support proxy per network.
        }
        // Whether a particular NetworkRequest listen should cause signal strength thresholds to
        // be communicated to a particular NetworkAgent depends only on the network's immutable,
        // capabilities, so it only needs to be done once on initial connect, not every time the
        // network's capabilities change. Note that we do this before rematching the network,
        // so we could decide to tear it down immediately afterwards. That's fine though - on
        // disconnection NetworkAgents should stop any signal strength monitoring they have been
        // doing.
        updateSignalStrengthThresholds(networkAgent, "CONNECT", null);
        // Consider network even though it is not yet validated.
        final long now = SystemClock.elapsedRealtime();
        rematchNetworkAndRequests(networkAgent, ReapUnvalidatedNetworks.REAP, now);
        // This has to happen after matching the requests, because callbacks are just requests.
        notifyNetworkCallbacks(networkAgent, ConnectivityManager.CALLBACK_PRECHECK);
    } else if (state == NetworkInfo.State.DISCONNECTED) {
        networkAgent.asyncChannel.disconnect();
        if (networkAgent.isVPN()) {
            synchronized (mProxyLock) {
                if (mDefaultProxyDisabled) {
                    mDefaultProxyDisabled = false;
                    if (mGlobalProxy == null && mDefaultProxy != null) {
                        sendProxyBroadcast(mDefaultProxy);
                    }
                }
            }
            updateUids(networkAgent, networkAgent.networkCapabilities, null);
        }
        disconnectAndDestroyNetwork(networkAgent);
    } else if ((oldInfo != null && oldInfo.getState() == NetworkInfo.State.SUSPENDED) || state == NetworkInfo.State.SUSPENDED) {
        // going into or coming out of SUSPEND: re-score and notify
        if (networkAgent.getCurrentScore() != oldScore) {
            rematchAllNetworksAndRequests(networkAgent, oldScore);
        }
        updateCapabilities(networkAgent.getCurrentScore(), networkAgent, networkAgent.networkCapabilities);
        // TODO (b/73132094) : remove this call once the few users of onSuspended and
        // onResumed have been removed.
        notifyNetworkCallbacks(networkAgent, (state == NetworkInfo.State.SUSPENDED ? ConnectivityManager.CALLBACK_SUSPENDED : ConnectivityManager.CALLBACK_RESUMED));
        mLegacyTypeTracker.update(networkAgent);
    }
}
#end_block

#method_before
private synchronized StackTraceElement[] getOurStackTrace() {
    // backtrace if this is the first call to this method
    if (stackTrace == UNASSIGNED_STACK || (stackTrace == null && backtrace != null)) /* Out of protocol state */
    {
        // BEGIN Android-changed: Get stack trace in one call.
        // int depth = getStackTraceDepth();
        // stackTrace = new StackTraceElement[depth];
        // for (int i=0; i < depth; i++)
        // stackTrace[i] = getStackTraceElement(i);
        stackTrace = nativeGetStackTrace(backtrace);
        backtrace = null;
        if (stackTrace == null) {
            return UNASSIGNED_STACK;
        }
    // END Android-changed: Get stack trace in one call.
    } else if (stackTrace == null) {
        return UNASSIGNED_STACK;
    }
    return stackTrace;
}
#method_after
private synchronized StackTraceElement[] getOurStackTrace() {
    // backtrace if this is the first call to this method
    if (stackTrace == UNASSIGNED_STACK || (stackTrace == null && backtrace != null)) /* Out of protocol state */
    {
        // BEGIN Android-changed: Get stack trace elements with one native call.
        // int depth = getStackTraceDepth();
        // stackTrace = new StackTraceElement[depth];
        // for (int i=0; i < depth; i++)
        // stackTrace[i] = getStackTraceElement(i);
        stackTrace = nativeGetStackTrace(backtrace);
        backtrace = null;
        if (stackTrace == null) {
            return UNASSIGNED_STACK;
        }
    // END Android-changed: Get stack trace elements with one native call.
    } else if (stackTrace == null) {
        return UNASSIGNED_STACK;
    }
    return stackTrace;
}
#end_block

#method_before
private void addValidationLogs(ReadOnlyLocalLog log, Network network, String networkExtraInfo) {
    synchronized (mValidationLogs) {
        while (mValidationLogs.size() >= MAX_VALIDATION_LOGS) {
            mValidationLogs.removeLast();
        }
        mValidationLogs.addFirst(new ValidationLog(network, networkExtraInfo, log));
    }
}
#method_after
private void addValidationLogs(ReadOnlyLocalLog log, Network network, String name) {
    synchronized (mValidationLogs) {
        while (mValidationLogs.size() >= MAX_VALIDATION_LOGS) {
            mValidationLogs.removeLast();
        }
        mValidationLogs.addFirst(new ValidationLog(network, name, log));
    }
}
#end_block

#method_before
private Network getActiveNetworkForUidInternal(final int uid, boolean ignoreBlocked) {
    final int user = UserHandle.getUserId(uid);
    int vpnNetId = NETID_UNSET;
    synchronized (mVpns) {
        final Vpn vpn = mVpns.get(user);
        if (vpn != null && vpn.appliesToUid(uid))
            vpnNetId = vpn.getNetId();
    }
    NetworkAgentInfo nai;
    if (vpnNetId != NETID_UNSET) {
        nai = getNetworkAgentInfoForNetId(vpnNetId);
        if (nai != null)
            return nai.network;
    }
    nai = getDefaultNetwork();
    if (nai != null && isNetworkWithLinkPropertiesBlocked(nai.linkProperties, uid, ignoreBlocked)) {
        nai = null;
    }
    return nai != null ? nai.network : null;
}
#method_after
private Network getActiveNetworkForUidInternal(final int uid, boolean ignoreBlocked) {
    final int user = UserHandle.getUserId(uid);
    int vpnNetId = NETID_UNSET;
    synchronized (mVpns) {
        final Vpn vpn = mVpns.get(user);
        // be removed as the satisfying test below should be enough.
        if (vpn != null && vpn.appliesToUid(uid))
            vpnNetId = vpn.getNetId();
    }
    NetworkAgentInfo nai;
    if (vpnNetId != NETID_UNSET) {
        nai = getNetworkAgentInfoForNetId(vpnNetId);
        if (nai != null) {
            final NetworkCapabilities requiredCaps = createDefaultNetworkCapabilitiesForUid(uid);
            if (requiredCaps.satisfiedByNetworkCapabilities(nai.networkCapabilities)) {
                return nai.network;
            }
        }
    }
    nai = getDefaultNetwork();
    if (nai != null && isNetworkWithLinkPropertiesBlocked(nai.linkProperties, uid, ignoreBlocked)) {
        nai = null;
    }
    return nai != null ? nai.network : null;
}
#end_block

#method_before
private NetworkCapabilities getNetworkCapabilitiesInternal(NetworkAgentInfo nai) {
    if (nai != null) {
        synchronized (nai) {
            if (nai.networkCapabilities != null) {
                return networkCapabilitiesWithoutUidsUnlessAllowed(nai.networkCapabilities, Binder.getCallingPid(), Binder.getCallingUid());
            }
        }
    }
    return null;
}
#method_after
private NetworkCapabilities getNetworkCapabilitiesInternal(NetworkAgentInfo nai) {
    if (nai != null) {
        synchronized (nai) {
            if (nai.networkCapabilities != null) {
                return networkCapabilitiesRestrictedForCallerPermissions(nai.networkCapabilities, Binder.getCallingPid(), Binder.getCallingUid());
            }
        }
    }
    return null;
}
#end_block

#method_before
@Override
public boolean isActiveNetworkMetered() {
    enforceAccessPermission();
    final NetworkCapabilities caps = getNetworkCapabilities(getActiveNetwork());
    if (caps != null) {
        return !caps.hasCapability(NetworkCapabilities.NET_CAPABILITY_NOT_METERED);
    } else {
        // Always return the most conservative value
        return true;
    }
}
#method_after
@Override
public boolean isActiveNetworkMetered() {
    enforceAccessPermission();
    final int uid = Binder.getCallingUid();
    final NetworkCapabilities caps = getUnfilteredActiveNetworkState(uid).networkCapabilities;
    if (caps != null) {
        return !caps.hasCapability(NetworkCapabilities.NET_CAPABILITY_NOT_METERED);
    } else {
        // Always return the most conservative value
        return true;
    }
}
#end_block

#method_before
private void sendStickyBroadcast(Intent intent) {
    synchronized (this) {
        if (!mSystemReady) {
            mInitialBroadcast = new Intent(intent);
        }
        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
        if (VDBG) {
            log("sendStickyBroadcast: action=" + intent.getAction());
        }
        Bundle options = null;
        final long ident = Binder.clearCallingIdentity();
        if (ConnectivityManager.CONNECTIVITY_ACTION.equals(intent.getAction())) {
            final NetworkInfo ni = intent.getParcelableExtra(ConnectivityManager.EXTRA_NETWORK_INFO);
            if (ni.getType() == ConnectivityManager.TYPE_MOBILE_SUPL) {
                intent.setAction(ConnectivityManager.CONNECTIVITY_ACTION_SUPL);
                intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
            } else {
                BroadcastOptions opts = BroadcastOptions.makeBasic();
                opts.setMaxManifestReceiverApiLevel(Build.VERSION_CODES.M);
                options = opts.toBundle();
            }
            final IBatteryStats bs = BatteryStatsService.getService();
            try {
                bs.noteConnectivityChanged(intent.getIntExtra(ConnectivityManager.EXTRA_NETWORK_TYPE, ConnectivityManager.TYPE_NONE), ni.getState().toString());
            } catch (RemoteException e) {
            }
        }
        try {
            mContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL, options);
        } finally {
            Binder.restoreCallingIdentity(ident);
        }
    }
}
#method_after
private void sendStickyBroadcast(Intent intent) {
    synchronized (this) {
        if (!mSystemReady) {
            mInitialBroadcast = new Intent(intent);
        }
        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
        if (VDBG) {
            log("sendStickyBroadcast: action=" + intent.getAction());
        }
        Bundle options = null;
        final long ident = Binder.clearCallingIdentity();
        if (ConnectivityManager.CONNECTIVITY_ACTION.equals(intent.getAction())) {
            final NetworkInfo ni = intent.getParcelableExtra(ConnectivityManager.EXTRA_NETWORK_INFO);
            if (ni.getType() == ConnectivityManager.TYPE_MOBILE_SUPL) {
                intent.setAction(ConnectivityManager.CONNECTIVITY_ACTION_SUPL);
                intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
            } else {
                BroadcastOptions opts = BroadcastOptions.makeBasic();
                opts.setMaxManifestReceiverApiLevel(Build.VERSION_CODES.M);
                options = opts.toBundle();
            }
            final IBatteryStats bs = BatteryStatsService.getService();
            try {
                bs.noteConnectivityChanged(intent.getIntExtra(ConnectivityManager.EXTRA_NETWORK_TYPE, ConnectivityManager.TYPE_NONE), ni.getState().toString());
            } catch (RemoteException e) {
            }
            intent.addFlags(Intent.FLAG_RECEIVER_VISIBLE_TO_INSTANT_APPS);
        }
        try {
            mContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL, options);
        } finally {
            Binder.restoreCallingIdentity(ident);
        }
    }
}
#end_block

#method_before
@Override
protected void dump(FileDescriptor fd, PrintWriter writer, String[] args) {
    final IndentingPrintWriter pw = new IndentingPrintWriter(writer, "  ");
    if (!DumpUtils.checkDumpPermission(mContext, TAG, pw))
        return;
    if (ArrayUtils.contains(args, DIAG_ARG)) {
        dumpNetworkDiagnostics(pw);
        return;
    } else if (ArrayUtils.contains(args, TETHERING_ARG)) {
        mTethering.dump(fd, pw, args);
        return;
    }
    pw.print("NetworkFactories for:");
    for (NetworkFactoryInfo nfi : mNetworkFactoryInfos.values()) {
        pw.print(" " + nfi.name);
    }
    pw.println();
    pw.println();
    final NetworkAgentInfo defaultNai = getDefaultNetwork();
    pw.print("Active default network: ");
    if (defaultNai == null) {
        pw.println("none");
    } else {
        pw.println(defaultNai.network.netId);
    }
    pw.println();
    pw.println("Current Networks:");
    pw.increaseIndent();
    for (NetworkAgentInfo nai : mNetworkAgentInfos.values()) {
        pw.println(nai.toString());
        pw.increaseIndent();
        pw.println(String.format("Requests: REQUEST:%d LISTEN:%d BACKGROUND_REQUEST:%d total:%d", nai.numForegroundNetworkRequests(), nai.numNetworkRequests() - nai.numRequestNetworkRequests(), nai.numBackgroundNetworkRequests(), nai.numNetworkRequests()));
        pw.increaseIndent();
        for (int i = 0; i < nai.numNetworkRequests(); i++) {
            pw.println(nai.requestAt(i).toString());
        }
        pw.decreaseIndent();
        pw.println("Lingered:");
        pw.increaseIndent();
        nai.dumpLingerTimers(pw);
        pw.decreaseIndent();
        pw.decreaseIndent();
    }
    pw.decreaseIndent();
    pw.println();
    pw.println("Network Requests:");
    pw.increaseIndent();
    for (NetworkRequestInfo nri : mNetworkRequests.values()) {
        pw.println(nri.toString());
    }
    pw.println();
    pw.decreaseIndent();
    mLegacyTypeTracker.dump(pw);
    pw.println();
    mTethering.dump(fd, pw, args);
    pw.println();
    mKeepaliveTracker.dump(pw);
    pw.println();
    dumpAvoidBadWifiSettings(pw);
    if (ArrayUtils.contains(args, SHORT_ARG) == false) {
        pw.println();
        synchronized (mValidationLogs) {
            pw.println("mValidationLogs (most recent first):");
            for (ValidationLog p : mValidationLogs) {
                pw.println(p.mNetwork + " - " + p.mNetworkExtraInfo);
                pw.increaseIndent();
                p.mLog.dump(fd, pw, args);
                pw.decreaseIndent();
            }
        }
        pw.println();
        pw.println("mNetworkRequestInfoLogs (most recent first):");
        pw.increaseIndent();
        mNetworkRequestInfoLogs.reverseDump(fd, pw, args);
        pw.decreaseIndent();
        pw.println();
        pw.println("mNetworkInfoBlockingLogs (most recent first):");
        pw.increaseIndent();
        mNetworkInfoBlockingLogs.reverseDump(fd, pw, args);
        pw.decreaseIndent();
        pw.println();
        pw.println("NetTransition WakeLock activity (most recent first):");
        pw.increaseIndent();
        pw.println("total acquisitions: " + mTotalWakelockAcquisitions);
        pw.println("total releases: " + mTotalWakelockReleases);
        pw.println("cumulative duration: " + (mTotalWakelockDurationMs / 1000) + "s");
        pw.println("longest duration: " + (mMaxWakelockDurationMs / 1000) + "s");
        if (mTotalWakelockAcquisitions > mTotalWakelockReleases) {
            long duration = SystemClock.elapsedRealtime() - mLastWakeLockAcquireTimestamp;
            pw.println("currently holding WakeLock for: " + (duration / 1000) + "s");
        }
        mWakelockLogs.reverseDump(fd, pw, args);
        pw.decreaseIndent();
    }
}
#method_after
@Override
protected void dump(FileDescriptor fd, PrintWriter writer, String[] args) {
    final IndentingPrintWriter pw = new IndentingPrintWriter(writer, "  ");
    if (!DumpUtils.checkDumpPermission(mContext, TAG, pw))
        return;
    if (ArrayUtils.contains(args, DIAG_ARG)) {
        dumpNetworkDiagnostics(pw);
        return;
    } else if (ArrayUtils.contains(args, TETHERING_ARG)) {
        mTethering.dump(fd, pw, args);
        return;
    }
    pw.print("NetworkFactories for:");
    for (NetworkFactoryInfo nfi : mNetworkFactoryInfos.values()) {
        pw.print(" " + nfi.name);
    }
    pw.println();
    pw.println();
    final NetworkAgentInfo defaultNai = getDefaultNetwork();
    pw.print("Active default network: ");
    if (defaultNai == null) {
        pw.println("none");
    } else {
        pw.println(defaultNai.network.netId);
    }
    pw.println();
    pw.println("Current Networks:");
    pw.increaseIndent();
    for (NetworkAgentInfo nai : mNetworkAgentInfos.values()) {
        pw.println(nai.toString());
        pw.increaseIndent();
        pw.println(String.format("Requests: REQUEST:%d LISTEN:%d BACKGROUND_REQUEST:%d total:%d", nai.numForegroundNetworkRequests(), nai.numNetworkRequests() - nai.numRequestNetworkRequests(), nai.numBackgroundNetworkRequests(), nai.numNetworkRequests()));
        pw.increaseIndent();
        for (int i = 0; i < nai.numNetworkRequests(); i++) {
            pw.println(nai.requestAt(i).toString());
        }
        pw.decreaseIndent();
        pw.println("Lingered:");
        pw.increaseIndent();
        nai.dumpLingerTimers(pw);
        pw.decreaseIndent();
        pw.decreaseIndent();
    }
    pw.decreaseIndent();
    pw.println();
    pw.println("Network Requests:");
    pw.increaseIndent();
    for (NetworkRequestInfo nri : mNetworkRequests.values()) {
        pw.println(nri.toString());
    }
    pw.println();
    pw.decreaseIndent();
    mLegacyTypeTracker.dump(pw);
    pw.println();
    mTethering.dump(fd, pw, args);
    pw.println();
    mKeepaliveTracker.dump(pw);
    pw.println();
    dumpAvoidBadWifiSettings(pw);
    if (ArrayUtils.contains(args, SHORT_ARG) == false) {
        pw.println();
        synchronized (mValidationLogs) {
            pw.println("mValidationLogs (most recent first):");
            for (ValidationLog p : mValidationLogs) {
                pw.println(p.mNetwork + " - " + p.mName);
                pw.increaseIndent();
                p.mLog.dump(fd, pw, args);
                pw.decreaseIndent();
            }
        }
        pw.println();
        pw.println("mNetworkRequestInfoLogs (most recent first):");
        pw.increaseIndent();
        mNetworkRequestInfoLogs.reverseDump(fd, pw, args);
        pw.decreaseIndent();
        pw.println();
        pw.println("mNetworkInfoBlockingLogs (most recent first):");
        pw.increaseIndent();
        mNetworkInfoBlockingLogs.reverseDump(fd, pw, args);
        pw.decreaseIndent();
        pw.println();
        pw.println("NetTransition WakeLock activity (most recent first):");
        pw.increaseIndent();
        pw.println("total acquisitions: " + mTotalWakelockAcquisitions);
        pw.println("total releases: " + mTotalWakelockReleases);
        pw.println("cumulative duration: " + (mTotalWakelockDurationMs / 1000) + "s");
        pw.println("longest duration: " + (mMaxWakelockDurationMs / 1000) + "s");
        if (mTotalWakelockAcquisitions > mTotalWakelockReleases) {
            long duration = SystemClock.elapsedRealtime() - mLastWakeLockAcquireTimestamp;
            pw.println("currently holding WakeLock for: " + (duration / 1000) + "s");
        }
        mWakelockLogs.reverseDump(fd, pw, args);
        pw.decreaseIndent();
    }
}
#end_block

#method_before
private void maybeHandleNetworkAgentMessage(Message msg) {
    NetworkAgentInfo nai = mNetworkAgentInfos.get(msg.replyTo);
    if (nai == null) {
        if (VDBG) {
            log(String.format("%s from unknown NetworkAgent", eventName(msg.what)));
        }
        return;
    }
    switch(msg.what) {
        case NetworkAgent.EVENT_NETWORK_CAPABILITIES_CHANGED:
            {
                final NetworkCapabilities networkCapabilities = (NetworkCapabilities) msg.obj;
                if (networkCapabilities.hasCapability(NET_CAPABILITY_CAPTIVE_PORTAL) || networkCapabilities.hasCapability(NET_CAPABILITY_VALIDATED) || networkCapabilities.hasCapability(NET_CAPABILITY_FOREGROUND)) {
                    Slog.wtf(TAG, "BUG: " + nai + " has CS-managed capability.");
                }
                updateCapabilities(nai.getCurrentScore(), nai, networkCapabilities);
                break;
            }
        case NetworkAgent.EVENT_NETWORK_PROPERTIES_CHANGED:
            {
                handleUpdateLinkProperties(nai, (LinkProperties) msg.obj);
                break;
            }
        case NetworkAgent.EVENT_NETWORK_INFO_CHANGED:
            {
                NetworkInfo info = (NetworkInfo) msg.obj;
                updateNetworkInfo(nai, info);
                break;
            }
        case NetworkAgent.EVENT_NETWORK_SCORE_CHANGED:
            {
                Integer score = (Integer) msg.obj;
                if (score != null)
                    updateNetworkScore(nai, score);
                break;
            }
        case NetworkAgent.EVENT_SET_EXPLICITLY_SELECTED:
            {
                if (nai.everConnected && !nai.networkMisc.explicitlySelected) {
                    loge("ERROR: already-connected network explicitly selected.");
                }
                nai.networkMisc.explicitlySelected = true;
                nai.networkMisc.acceptUnvalidated = (boolean) msg.obj;
                break;
            }
        case NetworkAgent.EVENT_PACKET_KEEPALIVE:
            {
                mKeepaliveTracker.handleEventPacketKeepalive(nai, msg);
                break;
            }
    }
}
#method_after
private void maybeHandleNetworkAgentMessage(Message msg) {
    NetworkAgentInfo nai = mNetworkAgentInfos.get(msg.replyTo);
    if (nai == null) {
        if (VDBG) {
            log(String.format("%s from unknown NetworkAgent", eventName(msg.what)));
        }
        return;
    }
    switch(msg.what) {
        case NetworkAgent.EVENT_NETWORK_CAPABILITIES_CHANGED:
            {
                final NetworkCapabilities networkCapabilities = (NetworkCapabilities) msg.obj;
                if (networkCapabilities.hasCapability(NET_CAPABILITY_CAPTIVE_PORTAL) || networkCapabilities.hasCapability(NET_CAPABILITY_VALIDATED) || networkCapabilities.hasCapability(NET_CAPABILITY_FOREGROUND)) {
                    Slog.wtf(TAG, "BUG: " + nai + " has CS-managed capability.");
                }
                updateCapabilities(nai.getCurrentScore(), nai, networkCapabilities);
                break;
            }
        case NetworkAgent.EVENT_NETWORK_PROPERTIES_CHANGED:
            {
                handleUpdateLinkProperties(nai, (LinkProperties) msg.obj);
                break;
            }
        case NetworkAgent.EVENT_NETWORK_INFO_CHANGED:
            {
                NetworkInfo info = (NetworkInfo) msg.obj;
                updateNetworkInfo(nai, info);
                break;
            }
        case NetworkAgent.EVENT_NETWORK_SCORE_CHANGED:
            {
                Integer score = (Integer) msg.obj;
                if (score != null)
                    updateNetworkScore(nai, score.intValue());
                break;
            }
        case NetworkAgent.EVENT_SET_EXPLICITLY_SELECTED:
            {
                if (nai.everConnected && !nai.networkMisc.explicitlySelected) {
                    loge("ERROR: already-connected network explicitly selected.");
                }
                nai.networkMisc.explicitlySelected = true;
                nai.networkMisc.acceptUnvalidated = (boolean) msg.obj;
                break;
            }
        case NetworkAgent.EVENT_PACKET_KEEPALIVE:
            {
                mKeepaliveTracker.handleEventPacketKeepalive(nai, msg);
                break;
            }
    }
}
#end_block

#method_before
private void handleAsyncChannelDisconnected(Message msg) {
    NetworkAgentInfo nai = mNetworkAgentInfos.get(msg.replyTo);
    if (nai != null) {
        if (DBG) {
            log(nai.name() + " got DISCONNECTED, was satisfying " + nai.numNetworkRequests());
        }
        // disconnect the channel.
        if (nai.networkInfo.isConnected()) {
            nai.networkInfo.setDetailedState(NetworkInfo.DetailedState.DISCONNECTED, null, null);
        }
        final boolean wasDefault = isDefaultNetwork(nai);
        if (wasDefault) {
            mDefaultInetConditionPublished = 0;
            // Log default network disconnection before required book-keeping.
            // Let rematchAllNetworksAndRequests() below record a new default network event
            // if there is a fallback. Taken together, the two form a X -> 0, 0 -> Y sequence
            // whose timestamps tell how long it takes to recover a default network.
            long now = SystemClock.elapsedRealtime();
            metricsLogger().defaultNetworkMetrics().logDefaultNetworkEvent(now, null, nai);
        }
        notifyIfacesChangedForNetworkStats();
        // TODO - we shouldn't send CALLBACK_LOST to requests that can be satisfied
        // by other networks that are already connected. Perhaps that can be done by
        // sending all CALLBACK_LOST messages (for requests, not listens) at the end
        // of rematchAllNetworksAndRequests
        notifyNetworkCallbacks(nai, ConnectivityManager.CALLBACK_LOST);
        mKeepaliveTracker.handleStopAllKeepalives(nai, ConnectivityManager.PacketKeepalive.ERROR_INVALID_NETWORK);
        for (String iface : nai.linkProperties.getAllInterfaceNames()) {
            // Disable wakeup packet monitoring for each interface.
            wakeupModifyInterface(iface, nai.networkCapabilities, false);
        }
        nai.networkMonitor.sendMessage(NetworkMonitor.CMD_NETWORK_DISCONNECTED);
        mNetworkAgentInfos.remove(msg.replyTo);
        nai.maybeStopClat();
        synchronized (mNetworkForNetId) {
            // Remove the NetworkAgent, but don't mark the netId as
            // available until we've told netd to delete it below.
            mNetworkForNetId.remove(nai.network.netId);
        }
        // Remove all previously satisfied requests.
        for (int i = 0; i < nai.numNetworkRequests(); i++) {
            NetworkRequest request = nai.requestAt(i);
            NetworkAgentInfo currentNetwork = getNetworkForRequest(request.requestId);
            if (currentNetwork != null && currentNetwork.network.netId == nai.network.netId) {
                clearNetworkForRequest(request.requestId);
                sendUpdatedScoreToFactories(request, 0);
            }
        }
        nai.clearLingerState();
        if (nai.isSatisfyingRequest(mDefaultRequest.requestId)) {
            removeDataActivityTracking(nai);
            notifyLockdownVpn(nai);
            ensureNetworkTransitionWakelock(nai.name());
        }
        mLegacyTypeTracker.remove(nai, wasDefault);
        rematchAllNetworksAndRequests(null, 0);
        mLingerMonitor.noteDisconnect(nai);
        if (nai.created) {
            // long time.
            try {
                mNetd.removeNetwork(nai.network.netId);
            } catch (Exception e) {
                loge("Exception removing network: " + e);
            }
            mDnsManager.removeNetwork(nai.network);
        }
        synchronized (mNetworkForNetId) {
            mNetIdInUse.delete(nai.network.netId);
        }
    } else {
        NetworkFactoryInfo nfi = mNetworkFactoryInfos.remove(msg.replyTo);
        if (DBG && nfi != null)
            log("unregisterNetworkFactory for " + nfi.name);
    }
}
#method_after
// This is a no-op if it's called with a message designating a network that has
// already been destroyed, because its reference will not be found in the relevant
private void handleAsyncChannelDisconnected(Message msg) {
    NetworkAgentInfo nai = mNetworkAgentInfos.get(msg.replyTo);
    if (nai != null) {
        disconnectAndDestroyNetwork(nai);
    } else {
        NetworkFactoryInfo nfi = mNetworkFactoryInfos.remove(msg.replyTo);
        if (DBG && nfi != null)
            log("unregisterNetworkFactory for " + nfi.name);
    }
}
#end_block

#method_before
private void handleDeprecatedGlobalHttpProxy() {
    String proxy = Settings.Global.getString(mContext.getContentResolver(), Settings.Global.HTTP_PROXY);
    if (!TextUtils.isEmpty(proxy)) {
        String[] data = proxy.split(":");
        if (data.length == 0) {
            return;
        }
        int proxyPort = 8080;
        if (data.length > 1) {
            try {
                proxyPort = Integer.parseInt(data[1]);
            } catch (NumberFormatException e) {
                return;
            }
        }
        ProxyInfo p = new ProxyInfo(data[0], proxyPort, "");
        setGlobalProxy(p);
    }
}
#method_after
private void handleDeprecatedGlobalHttpProxy() {
    final String proxy = Settings.Global.getString(mContext.getContentResolver(), Settings.Global.HTTP_PROXY);
    if (!TextUtils.isEmpty(proxy)) {
        String[] data = proxy.split(":");
        if (data.length == 0) {
            return;
        }
        final String proxyHost = data[0];
        int proxyPort = 8080;
        if (data.length > 1) {
            try {
                proxyPort = Integer.parseInt(data[1]);
            } catch (NumberFormatException e) {
                return;
            }
        }
        final ProxyInfo p = new ProxyInfo(proxyHost, proxyPort, "");
        setGlobalProxy(p);
    }
}
#end_block

#method_before
@Override
public void onChange(boolean selfChange, Uri uri) {
    final Integer what = mUriEventMap.get(uri);
    if (what != null) {
        mHandler.obtainMessage(what).sendToTarget();
    } else {
        loge("No matching event to send for URI=" + uri);
    }
}
#method_after
@Override
public void onChange(boolean selfChange, Uri uri) {
    final Integer what = mUriEventMap.get(uri);
    if (what != null) {
        mHandler.obtainMessage(what.intValue()).sendToTarget();
    } else {
        loge("No matching event to send for URI=" + uri);
    }
}
#end_block

#method_before
@Override
public NetworkRequest requestNetwork(NetworkCapabilities networkCapabilities, Messenger messenger, int timeoutMs, IBinder binder, int legacyType) {
    final NetworkRequest.Type type = (networkCapabilities == null) ? NetworkRequest.Type.TRACK_DEFAULT : NetworkRequest.Type.REQUEST;
    // the system default network.
    if (type == NetworkRequest.Type.TRACK_DEFAULT) {
        networkCapabilities = new NetworkCapabilities(mDefaultRequest.networkCapabilities);
        networkCapabilities.removeCapability(NET_CAPABILITY_NOT_VPN);
        enforceAccessPermission();
    } else {
        networkCapabilities = new NetworkCapabilities(networkCapabilities);
        enforceNetworkRequestPermissions(networkCapabilities);
        // TODO: this is incorrect. We mark the request as metered or not depending on the state
        // of the app when the request is filed, but we never change the request if the app
        // changes network state. http://b/29964605
        enforceMeteredApnPolicy(networkCapabilities);
    }
    ensureRequestableCapabilities(networkCapabilities);
    // Set the UID range for this request to the single UID of the requester, or to an empty
    // set of UIDs if the caller has the appropriate permission and UIDs have not been set.
    // This will overwrite any allowed UIDs in the requested capabilities. Though there
    // are no visible methods to set the UIDs, an app could use reflection to try and get
    // networks for other apps so it's essential that the UIDs are overwritten.
    restrictRequestUidsForCaller(networkCapabilities);
    if (timeoutMs < 0) {
        throw new IllegalArgumentException("Bad timeout specified");
    }
    ensureValidNetworkSpecifier(networkCapabilities);
    NetworkRequest networkRequest = new NetworkRequest(networkCapabilities, legacyType, nextNetworkRequestId(), type);
    NetworkRequestInfo nri = new NetworkRequestInfo(messenger, networkRequest, binder);
    if (DBG)
        log("requestNetwork for " + nri);
    mHandler.sendMessage(mHandler.obtainMessage(EVENT_REGISTER_NETWORK_REQUEST, nri));
    if (timeoutMs > 0) {
        mHandler.sendMessageDelayed(mHandler.obtainMessage(EVENT_TIMEOUT_NETWORK_REQUEST, nri), timeoutMs);
    }
    return networkRequest;
}
#method_after
@Override
public NetworkRequest requestNetwork(NetworkCapabilities networkCapabilities, Messenger messenger, int timeoutMs, IBinder binder, int legacyType) {
    final NetworkRequest.Type type = (networkCapabilities == null) ? NetworkRequest.Type.TRACK_DEFAULT : NetworkRequest.Type.REQUEST;
    // the system default network.
    if (type == NetworkRequest.Type.TRACK_DEFAULT) {
        networkCapabilities = createDefaultNetworkCapabilitiesForUid(Binder.getCallingUid());
        enforceAccessPermission();
    } else {
        networkCapabilities = new NetworkCapabilities(networkCapabilities);
        enforceNetworkRequestPermissions(networkCapabilities);
        // TODO: this is incorrect. We mark the request as metered or not depending on the state
        // of the app when the request is filed, but we never change the request if the app
        // changes network state. http://b/29964605
        enforceMeteredApnPolicy(networkCapabilities);
    }
    ensureRequestableCapabilities(networkCapabilities);
    ensureSufficientPermissionsForRequest(networkCapabilities, Binder.getCallingPid(), Binder.getCallingUid());
    // Set the UID range for this request to the single UID of the requester, or to an empty
    // set of UIDs if the caller has the appropriate permission and UIDs have not been set.
    // This will overwrite any allowed UIDs in the requested capabilities. Though there
    // are no visible methods to set the UIDs, an app could use reflection to try and get
    // networks for other apps so it's essential that the UIDs are overwritten.
    restrictRequestUidsForCaller(networkCapabilities);
    if (timeoutMs < 0) {
        throw new IllegalArgumentException("Bad timeout specified");
    }
    ensureValidNetworkSpecifier(networkCapabilities);
    NetworkRequest networkRequest = new NetworkRequest(networkCapabilities, legacyType, nextNetworkRequestId(), type);
    NetworkRequestInfo nri = new NetworkRequestInfo(messenger, networkRequest, binder);
    if (DBG)
        log("requestNetwork for " + nri);
    mHandler.sendMessage(mHandler.obtainMessage(EVENT_REGISTER_NETWORK_REQUEST, nri));
    if (timeoutMs > 0) {
        mHandler.sendMessageDelayed(mHandler.obtainMessage(EVENT_TIMEOUT_NETWORK_REQUEST, nri), timeoutMs);
    }
    return networkRequest;
}
#end_block

#method_before
@Override
public NetworkRequest pendingRequestForNetwork(NetworkCapabilities networkCapabilities, PendingIntent operation) {
    checkNotNull(operation, "PendingIntent cannot be null.");
    networkCapabilities = new NetworkCapabilities(networkCapabilities);
    enforceNetworkRequestPermissions(networkCapabilities);
    enforceMeteredApnPolicy(networkCapabilities);
    ensureRequestableCapabilities(networkCapabilities);
    ensureValidNetworkSpecifier(networkCapabilities);
    restrictRequestUidsForCaller(networkCapabilities);
    NetworkRequest networkRequest = new NetworkRequest(networkCapabilities, TYPE_NONE, nextNetworkRequestId(), NetworkRequest.Type.REQUEST);
    NetworkRequestInfo nri = new NetworkRequestInfo(networkRequest, operation);
    if (DBG)
        log("pendingRequest for " + nri);
    mHandler.sendMessage(mHandler.obtainMessage(EVENT_REGISTER_NETWORK_REQUEST_WITH_INTENT, nri));
    return networkRequest;
}
#method_after
@Override
public NetworkRequest pendingRequestForNetwork(NetworkCapabilities networkCapabilities, PendingIntent operation) {
    checkNotNull(operation, "PendingIntent cannot be null.");
    networkCapabilities = new NetworkCapabilities(networkCapabilities);
    enforceNetworkRequestPermissions(networkCapabilities);
    enforceMeteredApnPolicy(networkCapabilities);
    ensureRequestableCapabilities(networkCapabilities);
    ensureSufficientPermissionsForRequest(networkCapabilities, Binder.getCallingPid(), Binder.getCallingUid());
    ensureValidNetworkSpecifier(networkCapabilities);
    restrictRequestUidsForCaller(networkCapabilities);
    NetworkRequest networkRequest = new NetworkRequest(networkCapabilities, TYPE_NONE, nextNetworkRequestId(), NetworkRequest.Type.REQUEST);
    NetworkRequestInfo nri = new NetworkRequestInfo(networkRequest, operation);
    if (DBG)
        log("pendingRequest for " + nri);
    mHandler.sendMessage(mHandler.obtainMessage(EVENT_REGISTER_NETWORK_REQUEST_WITH_INTENT, nri));
    return networkRequest;
}
#end_block

#method_before
@Override
public NetworkRequest listenForNetwork(NetworkCapabilities networkCapabilities, Messenger messenger, IBinder binder) {
    if (!hasWifiNetworkListenPermission(networkCapabilities)) {
        enforceAccessPermission();
    }
    NetworkCapabilities nc = new NetworkCapabilities(networkCapabilities);
    restrictRequestUidsForCaller(nc);
    // Apps without the CHANGE_NETWORK_STATE permission can't use background networks, so
    // make all their listens include NET_CAPABILITY_FOREGROUND. That way, they will get
    // onLost and onAvailable callbacks when networks move in and out of the background.
    // There is no need to do this for requests because an app without CHANGE_NETWORK_STATE
    // can't request networks.
    restrictBackgroundRequestForCaller(nc);
    ensureValidNetworkSpecifier(nc);
    NetworkRequest networkRequest = new NetworkRequest(nc, TYPE_NONE, nextNetworkRequestId(), NetworkRequest.Type.LISTEN);
    NetworkRequestInfo nri = new NetworkRequestInfo(messenger, networkRequest, binder);
    if (VDBG)
        log("listenForNetwork for " + nri);
    mHandler.sendMessage(mHandler.obtainMessage(EVENT_REGISTER_NETWORK_LISTENER, nri));
    return networkRequest;
}
#method_after
@Override
public NetworkRequest listenForNetwork(NetworkCapabilities networkCapabilities, Messenger messenger, IBinder binder) {
    if (!hasWifiNetworkListenPermission(networkCapabilities)) {
        enforceAccessPermission();
    }
    NetworkCapabilities nc = new NetworkCapabilities(networkCapabilities);
    ensureSufficientPermissionsForRequest(networkCapabilities, Binder.getCallingPid(), Binder.getCallingUid());
    restrictRequestUidsForCaller(nc);
    // Apps without the CHANGE_NETWORK_STATE permission can't use background networks, so
    // make all their listens include NET_CAPABILITY_FOREGROUND. That way, they will get
    // onLost and onAvailable callbacks when networks move in and out of the background.
    // There is no need to do this for requests because an app without CHANGE_NETWORK_STATE
    // can't request networks.
    restrictBackgroundRequestForCaller(nc);
    ensureValidNetworkSpecifier(nc);
    NetworkRequest networkRequest = new NetworkRequest(nc, TYPE_NONE, nextNetworkRequestId(), NetworkRequest.Type.LISTEN);
    NetworkRequestInfo nri = new NetworkRequestInfo(messenger, networkRequest, binder);
    if (VDBG)
        log("listenForNetwork for " + nri);
    mHandler.sendMessage(mHandler.obtainMessage(EVENT_REGISTER_NETWORK_LISTENER, nri));
    return networkRequest;
}
#end_block

#method_before
@Override
public void pendingListenForNetwork(NetworkCapabilities networkCapabilities, PendingIntent operation) {
    checkNotNull(operation, "PendingIntent cannot be null.");
    if (!hasWifiNetworkListenPermission(networkCapabilities)) {
        enforceAccessPermission();
    }
    ensureValidNetworkSpecifier(networkCapabilities);
    final NetworkCapabilities nc = new NetworkCapabilities(networkCapabilities);
    restrictRequestUidsForCaller(nc);
    NetworkRequest networkRequest = new NetworkRequest(nc, TYPE_NONE, nextNetworkRequestId(), NetworkRequest.Type.LISTEN);
    NetworkRequestInfo nri = new NetworkRequestInfo(networkRequest, operation);
    if (VDBG)
        log("pendingListenForNetwork for " + nri);
    mHandler.sendMessage(mHandler.obtainMessage(EVENT_REGISTER_NETWORK_LISTENER, nri));
}
#method_after
@Override
public void pendingListenForNetwork(NetworkCapabilities networkCapabilities, PendingIntent operation) {
    checkNotNull(operation, "PendingIntent cannot be null.");
    if (!hasWifiNetworkListenPermission(networkCapabilities)) {
        enforceAccessPermission();
    }
    ensureValidNetworkSpecifier(networkCapabilities);
    ensureSufficientPermissionsForRequest(networkCapabilities, Binder.getCallingPid(), Binder.getCallingUid());
    final NetworkCapabilities nc = new NetworkCapabilities(networkCapabilities);
    restrictRequestUidsForCaller(nc);
    NetworkRequest networkRequest = new NetworkRequest(nc, TYPE_NONE, nextNetworkRequestId(), NetworkRequest.Type.LISTEN);
    NetworkRequestInfo nri = new NetworkRequestInfo(networkRequest, operation);
    if (VDBG)
        log("pendingListenForNetwork for " + nri);
    mHandler.sendMessage(mHandler.obtainMessage(EVENT_REGISTER_NETWORK_LISTENER, nri));
}
#end_block

#method_before
public int registerNetworkAgent(Messenger messenger, NetworkInfo networkInfo, LinkProperties linkProperties, NetworkCapabilities networkCapabilities, int currentScore, NetworkMisc networkMisc) {
    enforceConnectivityInternalPermission();
    LinkProperties lp = new LinkProperties(linkProperties);
    lp.ensureDirectlyConnectedRoutes();
    // TODO: Instead of passing mDefaultRequest, provide an API to determine whether a Network
    // satisfies mDefaultRequest.
    final NetworkCapabilities nc = new NetworkCapabilities(networkCapabilities);
    final NetworkAgentInfo nai = new NetworkAgentInfo(messenger, new AsyncChannel(), new Network(reserveNetId()), new NetworkInfo(networkInfo), lp, nc, currentScore, mContext, mTrackerHandler, new NetworkMisc(networkMisc), mDefaultRequest, this);
    // Make sure the network capabilities reflect what the agent info says.
    nai.networkCapabilities = mixInCapabilities(nai, nc);
    synchronized (this) {
        nai.networkMonitor.systemReady = mSystemReady;
    }
    addValidationLogs(nai.networkMonitor.getValidationLogs(), nai.network, networkInfo.getExtraInfo());
    if (DBG)
        log("registerNetworkAgent " + nai);
    mHandler.sendMessage(mHandler.obtainMessage(EVENT_REGISTER_NETWORK_AGENT, nai));
    return nai.network.netId;
}
#method_after
public int registerNetworkAgent(Messenger messenger, NetworkInfo networkInfo, LinkProperties linkProperties, NetworkCapabilities networkCapabilities, int currentScore, NetworkMisc networkMisc) {
    enforceConnectivityInternalPermission();
    LinkProperties lp = new LinkProperties(linkProperties);
    lp.ensureDirectlyConnectedRoutes();
    // TODO: Instead of passing mDefaultRequest, provide an API to determine whether a Network
    // satisfies mDefaultRequest.
    final NetworkCapabilities nc = new NetworkCapabilities(networkCapabilities);
    final NetworkAgentInfo nai = new NetworkAgentInfo(messenger, new AsyncChannel(), new Network(reserveNetId()), new NetworkInfo(networkInfo), lp, nc, currentScore, mContext, mTrackerHandler, new NetworkMisc(networkMisc), mDefaultRequest, this);
    // Make sure the network capabilities reflect what the agent info says.
    nai.networkCapabilities = mixInCapabilities(nai, nc);
    synchronized (this) {
        nai.networkMonitor.systemReady = mSystemReady;
    }
    final String extraInfo = networkInfo.getExtraInfo();
    final String name = TextUtils.isEmpty(extraInfo) ? nai.networkCapabilities.getSSID() : extraInfo;
    addValidationLogs(nai.networkMonitor.getValidationLogs(), nai.network, name);
    if (DBG)
        log("registerNetworkAgent " + nai);
    mHandler.sendMessage(mHandler.obtainMessage(EVENT_REGISTER_NETWORK_AGENT, nai));
    return nai.network.netId;
}
#end_block

#method_before
private void updateLinkProperties(NetworkAgentInfo networkAgent, LinkProperties oldLp) {
    LinkProperties newLp = networkAgent.linkProperties;
    int netId = networkAgent.network.netId;
    // we do anything else, make sure its LinkProperties are accurate.
    if (networkAgent.clatd != null) {
        networkAgent.clatd.fixupLinkProperties(oldLp);
    }
    updateInterfaces(newLp, oldLp, netId, networkAgent.networkCapabilities);
    updateMtu(newLp, oldLp);
    // TODO - figure out what to do for clat
    // for (LinkProperties lp : newLp.getStackedLinks()) {
    // updateMtu(lp, null);
    // }
    updateTcpBufferSizes(networkAgent);
    updateRoutes(newLp, oldLp, netId);
    updateDnses(newLp, oldLp, netId);
    // Make sure LinkProperties represents the latest private DNS status.
    // This does not need to be done before updateDnses because the
    // LinkProperties are not the source of the private DNS configuration.
    // updateDnses will fetch the private DNS configuration from DnsManager.
    mDnsManager.updatePrivateDnsStatus(netId, newLp);
    // Start or stop clat accordingly to network state.
    networkAgent.updateClat(mNetd);
    if (isDefaultNetwork(networkAgent)) {
        handleApplyDefaultProxy(newLp.getHttpProxy());
    } else {
        updateProxy(newLp, oldLp);
    }
    // TODO - move this check to cover the whole function
    if (!Objects.equals(newLp, oldLp)) {
        notifyIfacesChangedForNetworkStats();
        notifyNetworkCallbacks(networkAgent, ConnectivityManager.CALLBACK_IP_CHANGED);
    }
    mKeepaliveTracker.handleCheckKeepalivesStillValid(networkAgent);
}
#method_after
private void updateLinkProperties(NetworkAgentInfo networkAgent, LinkProperties oldLp) {
    LinkProperties newLp = new LinkProperties(networkAgent.linkProperties);
    int netId = networkAgent.network.netId;
    // we do anything else, make sure its LinkProperties are accurate.
    if (networkAgent.clatd != null) {
        networkAgent.clatd.fixupLinkProperties(oldLp);
    }
    updateInterfaces(newLp, oldLp, netId, networkAgent.networkCapabilities);
    updateMtu(newLp, oldLp);
    // TODO - figure out what to do for clat
    // for (LinkProperties lp : newLp.getStackedLinks()) {
    // updateMtu(lp, null);
    // }
    updateTcpBufferSizes(networkAgent);
    updateRoutes(newLp, oldLp, netId);
    updateDnses(newLp, oldLp, netId);
    // Make sure LinkProperties represents the latest private DNS status.
    // This does not need to be done before updateDnses because the
    // LinkProperties are not the source of the private DNS configuration.
    // updateDnses will fetch the private DNS configuration from DnsManager.
    mDnsManager.updatePrivateDnsStatus(netId, newLp);
    // Start or stop clat accordingly to network state.
    networkAgent.updateClat(mNetd);
    if (isDefaultNetwork(networkAgent)) {
        handleApplyDefaultProxy(newLp.getHttpProxy());
    } else {
        updateProxy(newLp, oldLp);
    }
    // TODO - move this check to cover the whole function
    if (!Objects.equals(newLp, oldLp)) {
        synchronized (networkAgent) {
            networkAgent.linkProperties = newLp;
        }
        notifyIfacesChangedForNetworkStats();
        notifyNetworkCallbacks(networkAgent, ConnectivityManager.CALLBACK_IP_CHANGED);
    }
    mKeepaliveTracker.handleCheckKeepalivesStillValid(networkAgent);
}
#end_block

#method_before
private void updateCapabilities(int oldScore, NetworkAgentInfo nai, NetworkCapabilities nc) {
    NetworkCapabilities newNc = mixInCapabilities(nai, nc);
    if (Objects.equals(nai.networkCapabilities, newNc))
        return;
    final String oldPermission = getNetworkPermission(nai.networkCapabilities);
    final String newPermission = getNetworkPermission(newNc);
    if (!Objects.equals(oldPermission, newPermission) && nai.created && !nai.isVPN()) {
        try {
            mNetd.setNetworkPermission(nai.network.netId, newPermission);
        } catch (RemoteException e) {
            loge("Exception in setNetworkPermission: " + e);
        }
    }
    final NetworkCapabilities prevNc;
    synchronized (nai) {
        prevNc = nai.networkCapabilities;
        nai.networkCapabilities = newNc;
    }
    updateUids(nai, prevNc, newNc);
    if (nai.getCurrentScore() == oldScore && newNc.equalRequestableCapabilities(prevNc)) {
        // If the requestable capabilities haven't changed, and the score hasn't changed, then
        // the change we're processing can't affect any requests, it can only affect the listens
        // on this network. We might have been called by rematchNetworkAndRequests when a
        // network changed foreground state.
        processListenRequests(nai, true);
    } else {
        // If the requestable capabilities have changed or the score changed, we can't have been
        // called by rematchNetworkAndRequests, so it's safe to start a rematch.
        rematchAllNetworksAndRequests(nai, oldScore);
        notifyNetworkCallbacks(nai, ConnectivityManager.CALLBACK_CAP_CHANGED);
    }
    // Report changes that are interesting for network statistics tracking.
    if (prevNc != null) {
        final boolean meteredChanged = prevNc.hasCapability(NET_CAPABILITY_NOT_METERED) != newNc.hasCapability(NET_CAPABILITY_NOT_METERED);
        final boolean roamingChanged = prevNc.hasCapability(NET_CAPABILITY_NOT_ROAMING) != newNc.hasCapability(NET_CAPABILITY_NOT_ROAMING);
        if (meteredChanged || roamingChanged) {
            notifyIfacesChangedForNetworkStats();
        }
    }
    if (!newNc.hasTransport(TRANSPORT_VPN)) {
        // bubble those changes through.
        synchronized (mVpns) {
            for (int i = 0; i < mVpns.size(); i++) {
                final Vpn vpn = mVpns.valueAt(i);
                vpn.updateCapabilities();
            }
        }
    }
}
#method_after
private void updateCapabilities(int oldScore, NetworkAgentInfo nai, NetworkCapabilities nc) {
    NetworkCapabilities newNc = mixInCapabilities(nai, nc);
    if (Objects.equals(nai.networkCapabilities, newNc))
        return;
    final String oldPermission = getNetworkPermission(nai.networkCapabilities);
    final String newPermission = getNetworkPermission(newNc);
    if (!Objects.equals(oldPermission, newPermission) && nai.created && !nai.isVPN()) {
        try {
            mNetd.setNetworkPermission(nai.network.netId, newPermission);
        } catch (RemoteException e) {
            loge("Exception in setNetworkPermission: " + e);
        }
    }
    final NetworkCapabilities prevNc;
    synchronized (nai) {
        prevNc = nai.networkCapabilities;
        nai.networkCapabilities = newNc;
    }
    updateUids(nai, prevNc, newNc);
    if (nai.getCurrentScore() == oldScore && newNc.equalRequestableCapabilities(prevNc)) {
        // If the requestable capabilities haven't changed, and the score hasn't changed, then
        // the change we're processing can't affect any requests, it can only affect the listens
        // on this network. We might have been called by rematchNetworkAndRequests when a
        // network changed foreground state.
        processListenRequests(nai, true);
    } else {
        // If the requestable capabilities have changed or the score changed, we can't have been
        // called by rematchNetworkAndRequests, so it's safe to start a rematch.
        rematchAllNetworksAndRequests(nai, oldScore);
        notifyNetworkCallbacks(nai, ConnectivityManager.CALLBACK_CAP_CHANGED);
    }
    // Report changes that are interesting for network statistics tracking.
    if (prevNc != null) {
        final boolean meteredChanged = prevNc.hasCapability(NET_CAPABILITY_NOT_METERED) != newNc.hasCapability(NET_CAPABILITY_NOT_METERED);
        final boolean roamingChanged = prevNc.hasCapability(NET_CAPABILITY_NOT_ROAMING) != newNc.hasCapability(NET_CAPABILITY_NOT_ROAMING);
        if (meteredChanged || roamingChanged) {
            notifyIfacesChangedForNetworkStats();
        }
    }
    if (!newNc.hasTransport(TRANSPORT_VPN)) {
        // Tell VPNs about updated capabilities, since they may need to
        // bubble those changes through.
        updateAllVpnsCapabilities();
    }
}
#end_block

#method_before
private void callCallbackForRequest(NetworkRequestInfo nri, NetworkAgentInfo networkAgent, int notificationType, int arg1) {
    if (nri.messenger == null) {
        // Default request has no msgr
        return;
    }
    Bundle bundle = new Bundle();
    // TODO: check if defensive copies of data is needed.
    putParcelable(bundle, new NetworkRequest(nri.request));
    Message msg = Message.obtain();
    if (notificationType != ConnectivityManager.CALLBACK_UNAVAIL) {
        putParcelable(bundle, networkAgent.network);
    }
    switch(notificationType) {
        case ConnectivityManager.CALLBACK_AVAILABLE:
            {
                putParcelable(bundle, new NetworkCapabilities(networkAgent.networkCapabilities));
                putParcelable(bundle, new LinkProperties(networkAgent.linkProperties));
                break;
            }
        case ConnectivityManager.CALLBACK_LOSING:
            {
                msg.arg1 = arg1;
                break;
            }
        case ConnectivityManager.CALLBACK_CAP_CHANGED:
            {
                // networkAgent can't be null as it has been accessed a few lines above.
                final NetworkCapabilities nc = networkCapabilitiesWithoutUidsUnlessAllowed(networkAgent.networkCapabilities, nri.mPid, nri.mUid);
                putParcelable(bundle, nc);
                break;
            }
        case ConnectivityManager.CALLBACK_IP_CHANGED:
            {
                putParcelable(bundle, new LinkProperties(networkAgent.linkProperties));
                break;
            }
    }
    msg.what = notificationType;
    msg.setData(bundle);
    try {
        if (VDBG) {
            String notification = ConnectivityManager.getCallbackName(notificationType);
            log("sending notification " + notification + " for " + nri.request);
        }
        nri.messenger.send(msg);
    } catch (RemoteException e) {
        // may occur naturally in the race of binder death.
        loge("RemoteException caught trying to send a callback msg for " + nri.request);
    }
}
#method_after
private void callCallbackForRequest(NetworkRequestInfo nri, NetworkAgentInfo networkAgent, int notificationType, int arg1) {
    if (nri.messenger == null) {
        // Default request has no msgr
        return;
    }
    Bundle bundle = new Bundle();
    // TODO: check if defensive copies of data is needed.
    putParcelable(bundle, new NetworkRequest(nri.request));
    Message msg = Message.obtain();
    if (notificationType != ConnectivityManager.CALLBACK_UNAVAIL) {
        putParcelable(bundle, networkAgent.network);
    }
    switch(notificationType) {
        case ConnectivityManager.CALLBACK_AVAILABLE:
            {
                putParcelable(bundle, new NetworkCapabilities(networkAgent.networkCapabilities));
                putParcelable(bundle, new LinkProperties(networkAgent.linkProperties));
                break;
            }
        case ConnectivityManager.CALLBACK_LOSING:
            {
                msg.arg1 = arg1;
                break;
            }
        case ConnectivityManager.CALLBACK_CAP_CHANGED:
            {
                // networkAgent can't be null as it has been accessed a few lines above.
                final NetworkCapabilities nc = networkCapabilitiesRestrictedForCallerPermissions(networkAgent.networkCapabilities, nri.mPid, nri.mUid);
                putParcelable(bundle, nc);
                break;
            }
        case ConnectivityManager.CALLBACK_IP_CHANGED:
            {
                putParcelable(bundle, new LinkProperties(networkAgent.linkProperties));
                break;
            }
    }
    msg.what = notificationType;
    msg.setData(bundle);
    try {
        if (VDBG) {
            String notification = ConnectivityManager.getCallbackName(notificationType);
            log("sending notification " + notification + " for " + nri.request);
        }
        nri.messenger.send(msg);
    } catch (RemoteException e) {
        // may occur naturally in the race of binder death.
        loge("RemoteException caught trying to send a callback msg for " + nri.request);
    }
}
#end_block

#method_before
private void updateNetworkInfo(NetworkAgentInfo networkAgent, NetworkInfo newInfo) {
    final NetworkInfo.State state = newInfo.getState();
    NetworkInfo oldInfo = null;
    final int oldScore = networkAgent.getCurrentScore();
    synchronized (networkAgent) {
        oldInfo = networkAgent.networkInfo;
        networkAgent.networkInfo = newInfo;
    }
    notifyLockdownVpn(networkAgent);
    if (DBG) {
        log(networkAgent.name() + " EVENT_NETWORK_INFO_CHANGED, going from " + (oldInfo == null ? "null" : oldInfo.getState()) + " to " + state);
    }
    if (!networkAgent.created && (state == NetworkInfo.State.CONNECTED || (state == NetworkInfo.State.CONNECTING && networkAgent.isVPN()))) {
        // A network that has just connected has zero requests and is thus a foreground network.
        networkAgent.networkCapabilities.addCapability(NET_CAPABILITY_FOREGROUND);
        try {
            // This should never fail.  Specifying an already in use NetID will cause failure.
            if (networkAgent.isVPN()) {
                mNetd.createVirtualNetwork(networkAgent.network.netId, !networkAgent.linkProperties.getDnsServers().isEmpty(), (networkAgent.networkMisc == null || !networkAgent.networkMisc.allowBypass));
            } else {
                mNetd.createPhysicalNetwork(networkAgent.network.netId, getNetworkPermission(networkAgent.networkCapabilities));
            }
        } catch (Exception e) {
            loge("Error creating network " + networkAgent.network.netId + ": " + e.getMessage());
            return;
        }
        networkAgent.created = true;
    }
    if (!networkAgent.everConnected && state == NetworkInfo.State.CONNECTED) {
        networkAgent.everConnected = true;
        if (networkAgent.linkProperties == null) {
            Slog.wtf(TAG, networkAgent.name() + " connected with null LinkProperties");
        }
        handlePerNetworkPrivateDnsConfig(networkAgent, mDnsManager.getPrivateDnsConfig());
        updateLinkProperties(networkAgent, null);
        networkAgent.networkMonitor.sendMessage(NetworkMonitor.CMD_NETWORK_CONNECTED);
        scheduleUnvalidatedPrompt(networkAgent);
        if (networkAgent.isVPN()) {
            // Temporarily disable the default proxy (not global).
            synchronized (mProxyLock) {
                if (!mDefaultProxyDisabled) {
                    mDefaultProxyDisabled = true;
                    if (mGlobalProxy == null && mDefaultProxy != null) {
                        sendProxyBroadcast(null);
                    }
                }
            }
        // TODO: support proxy per network.
        }
        // Whether a particular NetworkRequest listen should cause signal strength thresholds to
        // be communicated to a particular NetworkAgent depends only on the network's immutable,
        // capabilities, so it only needs to be done once on initial connect, not every time the
        // network's capabilities change. Note that we do this before rematching the network,
        // so we could decide to tear it down immediately afterwards. That's fine though - on
        // disconnection NetworkAgents should stop any signal strength monitoring they have been
        // doing.
        updateSignalStrengthThresholds(networkAgent, "CONNECT", null);
        // Consider network even though it is not yet validated.
        final long now = SystemClock.elapsedRealtime();
        rematchNetworkAndRequests(networkAgent, ReapUnvalidatedNetworks.REAP, now);
        // This has to happen after matching the requests, because callbacks are just requests.
        notifyNetworkCallbacks(networkAgent, ConnectivityManager.CALLBACK_PRECHECK);
    } else if (state == NetworkInfo.State.DISCONNECTED) {
        networkAgent.asyncChannel.disconnect();
        if (networkAgent.isVPN()) {
            synchronized (mProxyLock) {
                if (mDefaultProxyDisabled) {
                    mDefaultProxyDisabled = false;
                    if (mGlobalProxy == null && mDefaultProxy != null) {
                        sendProxyBroadcast(mDefaultProxy);
                    }
                }
            }
            updateUids(networkAgent, networkAgent.networkCapabilities, null);
        }
    } else if ((oldInfo != null && oldInfo.getState() == NetworkInfo.State.SUSPENDED) || state == NetworkInfo.State.SUSPENDED) {
        // going into or coming out of SUSPEND: rescore and notify
        if (networkAgent.getCurrentScore() != oldScore) {
            rematchAllNetworksAndRequests(networkAgent, oldScore);
        }
        updateCapabilities(networkAgent.getCurrentScore(), networkAgent, networkAgent.networkCapabilities);
        // TODO (b/73132094) : remove this call once the few users of onSuspended and
        // onResumed have been removed.
        notifyNetworkCallbacks(networkAgent, (state == NetworkInfo.State.SUSPENDED ? ConnectivityManager.CALLBACK_SUSPENDED : ConnectivityManager.CALLBACK_RESUMED));
        mLegacyTypeTracker.update(networkAgent);
    }
}
#method_after
private void updateNetworkInfo(NetworkAgentInfo networkAgent, NetworkInfo newInfo) {
    final NetworkInfo.State state = newInfo.getState();
    NetworkInfo oldInfo = null;
    final int oldScore = networkAgent.getCurrentScore();
    synchronized (networkAgent) {
        oldInfo = networkAgent.networkInfo;
        networkAgent.networkInfo = newInfo;
    }
    notifyLockdownVpn(networkAgent);
    if (DBG) {
        log(networkAgent.name() + " EVENT_NETWORK_INFO_CHANGED, going from " + (oldInfo == null ? "null" : oldInfo.getState()) + " to " + state);
    }
    if (!networkAgent.created && (state == NetworkInfo.State.CONNECTED || (state == NetworkInfo.State.CONNECTING && networkAgent.isVPN()))) {
        // A network that has just connected has zero requests and is thus a foreground network.
        networkAgent.networkCapabilities.addCapability(NET_CAPABILITY_FOREGROUND);
        try {
            // This should never fail.  Specifying an already in use NetID will cause failure.
            if (networkAgent.isVPN()) {
                mNetd.createVirtualNetwork(networkAgent.network.netId, !networkAgent.linkProperties.getDnsServers().isEmpty(), (networkAgent.networkMisc == null || !networkAgent.networkMisc.allowBypass));
            } else {
                mNetd.createPhysicalNetwork(networkAgent.network.netId, getNetworkPermission(networkAgent.networkCapabilities));
            }
        } catch (Exception e) {
            loge("Error creating network " + networkAgent.network.netId + ": " + e.getMessage());
            return;
        }
        networkAgent.created = true;
    }
    if (!networkAgent.everConnected && state == NetworkInfo.State.CONNECTED) {
        networkAgent.everConnected = true;
        if (networkAgent.linkProperties == null) {
            Slog.wtf(TAG, networkAgent.name() + " connected with null LinkProperties");
        }
        handlePerNetworkPrivateDnsConfig(networkAgent, mDnsManager.getPrivateDnsConfig());
        updateLinkProperties(networkAgent, null);
        networkAgent.networkMonitor.sendMessage(NetworkMonitor.CMD_NETWORK_CONNECTED);
        scheduleUnvalidatedPrompt(networkAgent);
        if (networkAgent.isVPN()) {
            // Temporarily disable the default proxy (not global).
            synchronized (mProxyLock) {
                if (!mDefaultProxyDisabled) {
                    mDefaultProxyDisabled = true;
                    if (mGlobalProxy == null && mDefaultProxy != null) {
                        sendProxyBroadcast(null);
                    }
                }
            }
        // TODO: support proxy per network.
        }
        // Whether a particular NetworkRequest listen should cause signal strength thresholds to
        // be communicated to a particular NetworkAgent depends only on the network's immutable,
        // capabilities, so it only needs to be done once on initial connect, not every time the
        // network's capabilities change. Note that we do this before rematching the network,
        // so we could decide to tear it down immediately afterwards. That's fine though - on
        // disconnection NetworkAgents should stop any signal strength monitoring they have been
        // doing.
        updateSignalStrengthThresholds(networkAgent, "CONNECT", null);
        // Consider network even though it is not yet validated.
        final long now = SystemClock.elapsedRealtime();
        rematchNetworkAndRequests(networkAgent, ReapUnvalidatedNetworks.REAP, now);
        // This has to happen after matching the requests, because callbacks are just requests.
        notifyNetworkCallbacks(networkAgent, ConnectivityManager.CALLBACK_PRECHECK);
    } else if (state == NetworkInfo.State.DISCONNECTED) {
        networkAgent.asyncChannel.disconnect();
        if (networkAgent.isVPN()) {
            synchronized (mProxyLock) {
                if (mDefaultProxyDisabled) {
                    mDefaultProxyDisabled = false;
                    if (mGlobalProxy == null && mDefaultProxy != null) {
                        sendProxyBroadcast(mDefaultProxy);
                    }
                }
            }
            updateUids(networkAgent, networkAgent.networkCapabilities, null);
        }
        disconnectAndDestroyNetwork(networkAgent);
    } else if ((oldInfo != null && oldInfo.getState() == NetworkInfo.State.SUSPENDED) || state == NetworkInfo.State.SUSPENDED) {
        // going into or coming out of SUSPEND: rescore and notify
        if (networkAgent.getCurrentScore() != oldScore) {
            rematchAllNetworksAndRequests(networkAgent, oldScore);
        }
        updateCapabilities(networkAgent.getCurrentScore(), networkAgent, networkAgent.networkCapabilities);
        // TODO (b/73132094) : remove this call once the few users of onSuspended and
        // onResumed have been removed.
        notifyNetworkCallbacks(networkAgent, (state == NetworkInfo.State.SUSPENDED ? ConnectivityManager.CALLBACK_SUSPENDED : ConnectivityManager.CALLBACK_RESUMED));
        mLegacyTypeTracker.update(networkAgent);
    }
}
#end_block

#method_before
// The test is best-effort only because the test runs after the runtime starts.
// If the bug, http://b/80495283, still exists, the race condition between FileDescriptor
@Test
public void testGetJavaIOFileDescriptorAccess_notNull() {
    Assert.assertNotNull("SharedSecrets.getJavaIOFileDescriptorAccess can't be null", SharedSecrets.getJavaIOFileDescriptorAccess());
}
#method_after
@Test
public void testGetJavaIOFileDescriptorAccess_notNull() {
    Assert.assertNotNull("SharedSecrets.getJavaIOFileDescriptorAccess can't be null", SharedSecrets.getJavaIOFileDescriptorAccess());
}
#end_block

#method_before
/**
 * Returns the runtime class of this {@code Object}. The returned
 * {@code Class} object is the object that is locked by {@code
 * static synchronized} methods of the represented class.
 *
 * <p><b>The actual result type is {@code Class<? extends |X|>}
 * where {@code |X|} is the erasure of the static type of the
 * expression on which {@code getClass} is called.</b> For
 * example, no cast is required in this code fragment:</p>
 *
 * <p>
 * {@code Number n = 0;                             }<br>
 * {@code Class<? extends Number> c = n.getClass(); }
 * </p>
 *
 * @return The {@code Class} object that represents the runtime
 *         class of this object.
 * @jls 15.8.2 Class Literals
 */
// Android-changed: Replace native method declaration with implementation
public final Class<?> getClass() {
    return shadow$_klass_;
}
#method_after
/**
 * Returns the runtime class of this {@code Object}. The returned
 * {@code Class} object is the object that is locked by {@code
 * static synchronized} methods of the represented class.
 *
 * <p><b>The actual result type is {@code Class<? extends |X|>}
 * where {@code |X|} is the erasure of the static type of the
 * expression on which {@code getClass} is called.</b> For
 * example, no cast is required in this code fragment:</p>
 *
 * <p>
 * {@code Number n = 0;                             }<br>
 * {@code Class<? extends Number> c = n.getClass(); }
 * </p>
 *
 * @return The {@code Class} object that represents the runtime
 *         class of this object.
 * @jls 15.8.2 Class Literals
 */
// Android-changed: Use Android specific fields for Class and monitor.
public final Class<?> getClass() {
    return shadow$_klass_;
}
#end_block

#method_before
/**
 * Returns a hash code value for the object. This method is
 * supported for the benefit of hash tables such as those provided by
 * {@link java.util.HashMap}.
 * <p>
 * The general contract of {@code hashCode} is:
 * <ul>
 * <li>Whenever it is invoked on the same object more than once during
 *     an execution of a Java application, the {@code hashCode} method
 *     must consistently return the same integer, provided no information
 *     used in {@code equals} comparisons on the object is modified.
 *     This integer need not remain consistent from one execution of an
 *     application to another execution of the same application.
 * <li>If two objects are equal according to the {@code equals(Object)}
 *     method, then calling the {@code hashCode} method on each of
 *     the two objects must produce the same integer result.
 * <li>It is <em>not</em> required that if two objects are unequal
 *     according to the {@link java.lang.Object#equals(java.lang.Object)}
 *     method, then calling the {@code hashCode} method on each of the
 *     two objects must produce distinct integer results.  However, the
 *     programmer should be aware that producing distinct integer results
 *     for unequal objects may improve the performance of hash tables.
 * </ul>
 * <p>
 * As much as is reasonably practical, the hashCode method defined by
 * class {@code Object} does return distinct integers for distinct
 * objects. (This is typically implemented by converting the internal
 * address of the object into an integer, but this implementation
 * technique is not required by the
 * Java&trade; programming language.)
 *
 * @return  a hash code value for this object.
 * @see     java.lang.Object#equals(java.lang.Object)
 * @see     java.lang.System#identityHashCode
 */
// Android-changed: Replace native method declaration with implementation
public int hashCode() {
    return identityHashCode(this);
}
#method_after
/**
 * Returns a hash code value for the object. This method is
 * supported for the benefit of hash tables such as those provided by
 * {@link java.util.HashMap}.
 * <p>
 * The general contract of {@code hashCode} is:
 * <ul>
 * <li>Whenever it is invoked on the same object more than once during
 *     an execution of a Java application, the {@code hashCode} method
 *     must consistently return the same integer, provided no information
 *     used in {@code equals} comparisons on the object is modified.
 *     This integer need not remain consistent from one execution of an
 *     application to another execution of the same application.
 * <li>If two objects are equal according to the {@code equals(Object)}
 *     method, then calling the {@code hashCode} method on each of
 *     the two objects must produce the same integer result.
 * <li>It is <em>not</em> required that if two objects are unequal
 *     according to the {@link java.lang.Object#equals(java.lang.Object)}
 *     method, then calling the {@code hashCode} method on each of the
 *     two objects must produce distinct integer results.  However, the
 *     programmer should be aware that producing distinct integer results
 *     for unequal objects may improve the performance of hash tables.
 * </ul>
 * <p>
 * As much as is reasonably practical, the hashCode method defined by
 * class {@code Object} does return distinct integers for distinct
 * objects. (This is typically implemented by converting the internal
 * address of the object into an integer, but this implementation
 * technique is not required by the
 * Java&trade; programming language.)
 *
 * @return  a hash code value for this object.
 * @see     java.lang.Object#equals(java.lang.Object)
 * @see     java.lang.System#identityHashCode
 */
// BEGIN Android-changed: Added a local helper for identityHashCode.
public int hashCode() {
    return identityHashCode(this);
}
#end_block

#method_before
// BEGIN Android-changed: Added a local helper for identityHashCode.
// Package-private to be used by j.l.System. We do the implementation here
// to avoid Object.hashCode doing a clinit check on j.l.System, and also
// to avoid leaking shadow$_monitor_ outside of this class.
static int identityHashCode(Object obj) {
    int lockWord = obj.shadow$_monitor_;
    // Top 2 bits.
    final int lockWordStateMask = 0xC0000000;
    // Top 2 bits are value 2 (kStateHash).
    final int lockWordStateHash = 0x80000000;
    // Low 28 bits.
    final int lockWordHashMask = 0x0FFFFFFF;
    if ((lockWord & lockWordStateMask) == lockWordStateHash) {
        return lockWord & lockWordHashMask;
    }
    return identityHashCodeNative(obj);
}
#method_after
// Package-private to be used by j.l.System. We do the implementation here
// to avoid Object.hashCode doing a clinit check on j.l.System, and also
// to avoid leaking shadow$_monitor_ outside of this class.
static int identityHashCode(Object obj) {
    int lockWord = obj.shadow$_monitor_;
    // Top 2 bits.
    final int lockWordStateMask = 0xC0000000;
    // Top 2 bits are value 2 (kStateHash).
    final int lockWordStateHash = 0x80000000;
    // Low 28 bits.
    final int lockWordHashMask = 0x0FFFFFFF;
    if ((lockWord & lockWordStateMask) == lockWordStateHash) {
        return lockWord & lockWordHashMask;
    }
    return identityHashCodeNative(obj);
}
#end_block

#method_before
// BEGIN Android-changed: Added a local helper for identityHashCode.
public boolean equals(Object obj) {
    return (this == obj);
}
#method_after
// END Android-changed: Added a local helper for identityHashCode.
public boolean equals(Object obj) {
    return (this == obj);
}
#end_block

#method_before
/**
 * Creates and returns a copy of this object.  The precise meaning
 * of "copy" may depend on the class of the object. The general
 * intent is that, for any object {@code x}, the expression:
 * <blockquote>
 * <pre>
 * x.clone() != x</pre></blockquote>
 * will be true, and that the expression:
 * <blockquote>
 * <pre>
 * x.clone().getClass() == x.getClass()</pre></blockquote>
 * will be {@code true}, but these are not absolute requirements.
 * While it is typically the case that:
 * <blockquote>
 * <pre>
 * x.clone().equals(x)</pre></blockquote>
 * will be {@code true}, this is not an absolute requirement.
 * <p>
 * By convention, the returned object should be obtained by calling
 * {@code super.clone}.  If a class and all of its superclasses (except
 * {@code Object}) obey this convention, it will be the case that
 * {@code x.clone().getClass() == x.getClass()}.
 * <p>
 * By convention, the object returned by this method should be independent
 * of this object (which is being cloned).  To achieve this independence,
 * it may be necessary to modify one or more fields of the object returned
 * by {@code super.clone} before returning it.  Typically, this means
 * copying any mutable objects that comprise the internal "deep structure"
 * of the object being cloned and replacing the references to these
 * objects with references to the copies.  If a class contains only
 * primitive fields or references to immutable objects, then it is usually
 * the case that no fields in the object returned by {@code super.clone}
 * need to be modified.
 * <p>
 * The method {@code clone} for class {@code Object} performs a
 * specific cloning operation. First, if the class of this object does
 * not implement the interface {@code Cloneable}, then a
 * {@code CloneNotSupportedException} is thrown. Note that all arrays
 * are considered to implement the interface {@code Cloneable} and that
 * the return type of the {@code clone} method of an array type {@code T[]}
 * is {@code T[]} where T is any reference or primitive type.
 * Otherwise, this method creates a new instance of the class of this
 * object and initializes all its fields with exactly the contents of
 * the corresponding fields of this object, as if by assignment; the
 * contents of the fields are not themselves cloned. Thus, this method
 * performs a "shallow copy" of this object, not a "deep copy" operation.
 * <p>
 * The class {@code Object} does not itself implement the interface
 * {@code Cloneable}, so calling the {@code clone} method on an object
 * whose class is {@code Object} will result in throwing an
 * exception at run time.
 *
 * @return     a clone of this instance.
 * @throws  CloneNotSupportedException  if the object's class does not
 *               support the {@code Cloneable} interface. Subclasses
 *               that override the {@code clone} method can also
 *               throw this exception to indicate that an instance cannot
 *               be cloned.
 * @see java.lang.Cloneable
 */
// BEGIN Android-changed: Replaced native clone() method declaration with
// implementation that throws an exception if this object does not
// implement Cloneable and otherwise calls an internal native method to
protected Object clone() throws CloneNotSupportedException {
    if (!(this instanceof Cloneable)) {
        throw new CloneNotSupportedException("Class " + getClass().getName() + " doesn't implement Cloneable");
    }
    return internalClone();
}
#method_after
/**
 * Creates and returns a copy of this object.  The precise meaning
 * of "copy" may depend on the class of the object. The general
 * intent is that, for any object {@code x}, the expression:
 * <blockquote>
 * <pre>
 * x.clone() != x</pre></blockquote>
 * will be true, and that the expression:
 * <blockquote>
 * <pre>
 * x.clone().getClass() == x.getClass()</pre></blockquote>
 * will be {@code true}, but these are not absolute requirements.
 * While it is typically the case that:
 * <blockquote>
 * <pre>
 * x.clone().equals(x)</pre></blockquote>
 * will be {@code true}, this is not an absolute requirement.
 * <p>
 * By convention, the returned object should be obtained by calling
 * {@code super.clone}.  If a class and all of its superclasses (except
 * {@code Object}) obey this convention, it will be the case that
 * {@code x.clone().getClass() == x.getClass()}.
 * <p>
 * By convention, the object returned by this method should be independent
 * of this object (which is being cloned).  To achieve this independence,
 * it may be necessary to modify one or more fields of the object returned
 * by {@code super.clone} before returning it.  Typically, this means
 * copying any mutable objects that comprise the internal "deep structure"
 * of the object being cloned and replacing the references to these
 * objects with references to the copies.  If a class contains only
 * primitive fields or references to immutable objects, then it is usually
 * the case that no fields in the object returned by {@code super.clone}
 * need to be modified.
 * <p>
 * The method {@code clone} for class {@code Object} performs a
 * specific cloning operation. First, if the class of this object does
 * not implement the interface {@code Cloneable}, then a
 * {@code CloneNotSupportedException} is thrown. Note that all arrays
 * are considered to implement the interface {@code Cloneable} and that
 * the return type of the {@code clone} method of an array type {@code T[]}
 * is {@code T[]} where T is any reference or primitive type.
 * Otherwise, this method creates a new instance of the class of this
 * object and initializes all its fields with exactly the contents of
 * the corresponding fields of this object, as if by assignment; the
 * contents of the fields are not themselves cloned. Thus, this method
 * performs a "shallow copy" of this object, not a "deep copy" operation.
 * <p>
 * The class {@code Object} does not itself implement the interface
 * {@code Cloneable}, so calling the {@code clone} method on an object
 * whose class is {@code Object} will result in throwing an
 * exception at run time.
 *
 * @return     a clone of this instance.
 * @throws  CloneNotSupportedException  if the object's class does not
 *               support the {@code Cloneable} interface. Subclasses
 *               that override the {@code clone} method can also
 *               throw this exception to indicate that an instance cannot
 *               be cloned.
 * @see java.lang.Cloneable
 */
// BEGIN Android-changed: Use native local helper for clone()
// Checks whether cloning is allowed before calling native local helper.
protected Object clone() throws CloneNotSupportedException {
    if (!(this instanceof Cloneable)) {
        throw new CloneNotSupportedException("Class " + getClass().getName() + " doesn't implement Cloneable");
    }
    return internalClone();
}
#end_block

#method_before
// END Android-changed: Replaced native clone() method declaration
public String toString() {
    return getClass().getName() + "@" + Integer.toHexString(hashCode());
}
#method_after
// END Android-changed: Use native local helper for clone()
public String toString() {
    return getClass().getName() + "@" + Integer.toHexString(hashCode());
}
#end_block

#method_before
/**
 * Causes the current thread to wait until either another thread invokes the
 * {@link java.lang.Object#notify()} method or the
 * {@link java.lang.Object#notifyAll()} method for this object, or a
 * specified amount of time has elapsed.
 * <p>
 * The current thread must own this object's monitor.
 * <p>
 * This method causes the current thread (call it <var>T</var>) to
 * place itself in the wait set for this object and then to relinquish
 * any and all synchronization claims on this object. Thread <var>T</var>
 * becomes disabled for thread scheduling purposes and lies dormant
 * until one of four things happens:
 * <ul>
 * <li>Some other thread invokes the {@code notify} method for this
 * object and thread <var>T</var> happens to be arbitrarily chosen as
 * the thread to be awakened.
 * <li>Some other thread invokes the {@code notifyAll} method for this
 * object.
 * <li>Some other thread {@linkplain Thread#interrupt() interrupts}
 * thread <var>T</var>.
 * <li>The specified amount of real time has elapsed, more or less.  If
 * {@code timeout} is zero, however, then real time is not taken into
 * consideration and the thread simply waits until notified.
 * </ul>
 * The thread <var>T</var> is then removed from the wait set for this
 * object and re-enabled for thread scheduling. It then competes in the
 * usual manner with other threads for the right to synchronize on the
 * object; once it has gained control of the object, all its
 * synchronization claims on the object are restored to the status quo
 * ante - that is, to the situation as of the time that the {@code wait}
 * method was invoked. Thread <var>T</var> then returns from the
 * invocation of the {@code wait} method. Thus, on return from the
 * {@code wait} method, the synchronization state of the object and of
 * thread {@code T} is exactly as it was when the {@code wait} method
 * was invoked.
 * <p>
 * A thread can also wake up without being notified, interrupted, or
 * timing out, a so-called <i>spurious wakeup</i>.  While this will rarely
 * occur in practice, applications must guard against it by testing for
 * the condition that should have caused the thread to be awakened, and
 * continuing to wait if the condition is not satisfied.  In other words,
 * waits should always occur in loops, like this one:
 * <pre>
 *     synchronized (obj) {
 *         while (&lt;condition does not hold&gt;)
 *             obj.wait(timeout);
 *         ... // Perform action appropriate to condition
 *     }
 * </pre>
 * (For more information on this topic, see Section 3.2.3 in Doug Lea's
 * "Concurrent Programming in Java (Second Edition)" (Addison-Wesley,
 * 2000), or Item 50 in Joshua Bloch's "Effective Java Programming
 * Language Guide" (Addison-Wesley, 2001).
 *
 * <p>If the current thread is {@linkplain java.lang.Thread#interrupt()
 * interrupted} by any thread before or while it is waiting, then an
 * {@code InterruptedException} is thrown.  This exception is not
 * thrown until the lock status of this object has been restored as
 * described above.
 *
 * <p>
 * Note that the {@code wait} method, as it places the current thread
 * into the wait set for this object, unlocks only this object; any
 * other objects on which the current thread may be synchronized remain
 * locked while the thread waits.
 * <p>
 * This method should only be called by a thread that is the owner
 * of this object's monitor. See the {@code notify} method for a
 * description of the ways in which a thread can become the owner of
 * a monitor.
 *
 * @param      timeout   the maximum time to wait in milliseconds.
 * @throws  IllegalArgumentException      if the value of timeout is
 *               negative.
 * @throws  IllegalMonitorStateException  if the current thread is not
 *               the owner of the object's monitor.
 * @throws  InterruptedException if any thread interrupted the
 *             current thread before or while the current thread
 *             was waiting for a notification.  The <i>interrupted
 *             status</i> of the current thread is cleared when
 *             this exception is thrown.
 * @see        java.lang.Object#notify()
 * @see        java.lang.Object#notifyAll()
 */
// Android-changed: Replaced native wait(long) method declaration with
public final void wait(long timeout) throws InterruptedException {
    wait(timeout, 0);
}
#method_after
/**
 * Causes the current thread to wait until either another thread invokes the
 * {@link java.lang.Object#notify()} method or the
 * {@link java.lang.Object#notifyAll()} method for this object, or a
 * specified amount of time has elapsed.
 * <p>
 * The current thread must own this object's monitor.
 * <p>
 * This method causes the current thread (call it <var>T</var>) to
 * place itself in the wait set for this object and then to relinquish
 * any and all synchronization claims on this object. Thread <var>T</var>
 * becomes disabled for thread scheduling purposes and lies dormant
 * until one of four things happens:
 * <ul>
 * <li>Some other thread invokes the {@code notify} method for this
 * object and thread <var>T</var> happens to be arbitrarily chosen as
 * the thread to be awakened.
 * <li>Some other thread invokes the {@code notifyAll} method for this
 * object.
 * <li>Some other thread {@linkplain Thread#interrupt() interrupts}
 * thread <var>T</var>.
 * <li>The specified amount of real time has elapsed, more or less.  If
 * {@code timeout} is zero, however, then real time is not taken into
 * consideration and the thread simply waits until notified.
 * </ul>
 * The thread <var>T</var> is then removed from the wait set for this
 * object and re-enabled for thread scheduling. It then competes in the
 * usual manner with other threads for the right to synchronize on the
 * object; once it has gained control of the object, all its
 * synchronization claims on the object are restored to the status quo
 * ante - that is, to the situation as of the time that the {@code wait}
 * method was invoked. Thread <var>T</var> then returns from the
 * invocation of the {@code wait} method. Thus, on return from the
 * {@code wait} method, the synchronization state of the object and of
 * thread {@code T} is exactly as it was when the {@code wait} method
 * was invoked.
 * <p>
 * A thread can also wake up without being notified, interrupted, or
 * timing out, a so-called <i>spurious wakeup</i>.  While this will rarely
 * occur in practice, applications must guard against it by testing for
 * the condition that should have caused the thread to be awakened, and
 * continuing to wait if the condition is not satisfied.  In other words,
 * waits should always occur in loops, like this one:
 * <pre>
 *     synchronized (obj) {
 *         while (&lt;condition does not hold&gt;)
 *             obj.wait(timeout);
 *         ... // Perform action appropriate to condition
 *     }
 * </pre>
 * (For more information on this topic, see Section 3.2.3 in Doug Lea's
 * "Concurrent Programming in Java (Second Edition)" (Addison-Wesley,
 * 2000), or Item 50 in Joshua Bloch's "Effective Java Programming
 * Language Guide" (Addison-Wesley, 2001).
 *
 * <p>If the current thread is {@linkplain java.lang.Thread#interrupt()
 * interrupted} by any thread before or while it is waiting, then an
 * {@code InterruptedException} is thrown.  This exception is not
 * thrown until the lock status of this object has been restored as
 * described above.
 *
 * <p>
 * Note that the {@code wait} method, as it places the current thread
 * into the wait set for this object, unlocks only this object; any
 * other objects on which the current thread may be synchronized remain
 * locked while the thread waits.
 * <p>
 * This method should only be called by a thread that is the owner
 * of this object's monitor. See the {@code notify} method for a
 * description of the ways in which a thread can become the owner of
 * a monitor.
 *
 * @param      timeout   the maximum time to wait in milliseconds.
 * @throws  IllegalArgumentException      if the value of timeout is
 *               negative.
 * @throws  IllegalMonitorStateException  if the current thread is not
 *               the owner of the object's monitor.
 * @throws  InterruptedException if any thread interrupted the
 *             current thread before or while the current thread
 *             was waiting for a notification.  The <i>interrupted
 *             status</i> of the current thread is cleared when
 *             this exception is thrown.
 * @see        java.lang.Object#notify()
 * @see        java.lang.Object#notifyAll()
 */
// Android-changed: Implement wait(long) non-natively.
public final void wait(long timeout) throws InterruptedException {
    wait(timeout, 0);
}
#end_block

#method_before
@Override
public void init(ServletConfig servletConfig) throws ServletException {
    super.init(servletConfig);
    this.keyFileInputStream = this.getClass().getClassLoader().getResourceAsStream("keys/" + GCS_KEY_FILE);
    Optional<Storage> optionalStorage = GcsHelper.getStorage(this.keyFileInputStream);
    if (optionalStorage.isPresent()) {
        this.storage = optionalStorage.get();
    } else {
        logger.log(Level.SEVERE, "Error on getting storage instance!");
        throw new ServletException("Creating storage instance exception!");
    }
    syncCache.setErrorHandler(ErrorHandlers.getConsistentLogAndContinue(Level.INFO));
}
#method_after
@Override
public void init(ServletConfig servletConfig) throws ServletException {
    super.init(servletConfig);
    try {
        InputStream defaultInputStream = VtsSuiteTestJobServlet.class.getClassLoader().getResourceAsStream("config.properties");
        systemConfigProp.load(defaultInputStream);
        GCS_KEY_FILE = systemConfigProp.getProperty("gcs.keyFile");
        GCS_BUCKET_NAME = systemConfigProp.getProperty("gcs.bucketName");
        GCS_SUITE_TEST_FOLDER_NAME = systemConfigProp.getProperty("gcs.suiteTestFolderName");
        this.keyFileInputStream = this.getClass().getClassLoader().getResourceAsStream("keys/" + GCS_KEY_FILE);
        Optional<Storage> optionalStorage = GcsHelper.getStorage(this.keyFileInputStream);
        if (optionalStorage.isPresent()) {
            this.storage = optionalStorage.get();
        } else {
            logger.log(Level.SEVERE, "Error on getting storage instance!");
            throw new ServletException("Creating storage instance exception!");
        }
        syncCache.setErrorHandler(ErrorHandlers.getConsistentLogAndContinue(Level.INFO));
    } catch (FileNotFoundException e) {
        e.printStackTrace();
    } catch (IOException e) {
        e.printStackTrace();
    }
}
#end_block

#method_before
public void startRecordcontroller() {
    if (mStartRecordcontroller == true) {
        Log.v(TAG, "startRecordcontroller is working. stop it");
        mController.quit();
    }
    Log.v(TAG, "startRecordcontroller");
    mStartRecordcontroller = true;
    mController = new RecordProcedureController(this);
}
#method_after
public void startRecordcontroller() {
    if (mController != null) {
        Log.v(TAG, "startRecordcontroller is working. stop it");
        mController.quit();
    }
    Log.v(TAG, "startRecordcontroller");
    mController = new RecordProcedureController(this);
}
#end_block

#method_before
public void stopRecordcontroller() {
    if (mStartRecordcontroller == true) {
        Log.v(TAG, "startRecordcontroller is working. stop it");
        mController.quit();
    }
    Log.v(TAG, "stopRecordcontroller");
    mStartRecordcontroller = false;
}
#method_after
public void stopRecordcontroller() {
    if (mController != null) {
        Log.v(TAG, "startRecordcontroller is working. stop it");
        mController.quit();
    }
    Log.v(TAG, "stopRecordcontroller");
}
#end_block

#method_before
@Override
protected void onPause() {
    super.onPause();
    if (mController != null) {
        mController.quit();
    }
    mStartRecordcontroller = false;
    mCameraContext.end();
    endSoundPool();
}
#method_after
@Override
protected void onPause() {
    super.onPause();
    if (mController != null) {
        mController.quit();
    }
    mCameraContext.end();
    endSoundPool();
}
#end_block

#method_before
@Override
protected void onResume() {
    super.onResume();
    // delay the initialization as much as possible
    mStartRecordcontroller = false;
    init();
}
#method_after
@Override
protected void onResume() {
    super.onResume();
    // delay the initialization as much as possible
    init();
}
#end_block

#method_before
private void init() {
    mCameraContext = new CameraContext();
    mCameraContext.init(mOnRecordProcedureControllerListener);
    mCoverManager = new CoverageManager();
    mIndicatorView.setDataProvider(mCoverManager.getAxis(SensorManager.AXIS_X), mCoverManager.getAxis(SensorManager.AXIS_Y), mCoverManager.getAxis(SensorManager.AXIS_Z));
    initSoundPool();
    mRVSensorLogger = new RVSensorLogger(this);
    mVideoRecorder = new VideoRecorder(mCameraContext.getCamera(), mCameraContext.getProfile());
    if (LOG_RAW_SENSORS) {
        mRawSensorLogger = new RawSensorLogger(mRecordDir);
    }
}
#method_after
private void init() {
    mCameraContext = new CameraContext();
    mCameraContext.init(mRecordProcedureControllerCallback);
    mCoverManager = new CoverageManager();
    mIndicatorView.setDataProvider(mCoverManager.getAxis(SensorManager.AXIS_X), mCoverManager.getAxis(SensorManager.AXIS_Y), mCoverManager.getAxis(SensorManager.AXIS_Z));
    initSoundPool();
    mRVSensorLogger = new RVSensorLogger(this);
    mVideoRecorder = new VideoRecorder(mCameraContext.getCamera(), mCameraContext.getProfile());
    if (LOG_RAW_SENSORS) {
        mRawSensorLogger = new RawSensorLogger(mRecordDir);
    }
}
#end_block

#method_before
public void init(RVCVRecordActivity.OnRecordProcedureControllerListener listener) {
    mOnRecordProcedureControllerListener = listener;
    if (mCamera != null) {
        double alpha = mCamera.getParameters().getHorizontalViewAngle() * Math.PI / 180.0;
        int width = mProfile.videoFrameWidth;
        double fx = width / 2 / Math.tan(alpha / 2.0);
        if (LOCAL_LOGV)
            Log.v(TAG, "View angle=" + mCamera.getParameters().getHorizontalViewAngle() + "  Estimated fx = " + fx);
        mCameraPreview = (RVCVCameraPreview) findViewById(R.id.cam_preview);
        mCameraPreview.setOnRecordProcedureControllerListener(mOnRecordProcedureControllerListener);
        mCameraPreview.init(mCamera, (float) mProfile.videoFrameWidth / mProfile.videoFrameHeight, mCameraInfo.orientation);
    } else {
        message("Cannot open camera!");
        finish();
    }
}
#method_after
public void init(RVCVRecordActivity.RecordProcedureControllerCallback callback) {
    if (mCamera != null) {
        double alpha = mCamera.getParameters().getHorizontalViewAngle() * Math.PI / 180.0;
        int width = mProfile.videoFrameWidth;
        double fx = width / 2 / Math.tan(alpha / 2.0);
        if (LOCAL_LOGV)
            Log.v(TAG, "View angle=" + mCamera.getParameters().getHorizontalViewAngle() + "  Estimated fx = " + fx);
        mCameraPreview = (RVCVCameraPreview) findViewById(R.id.cam_preview);
        mCameraPreview.setRecordProcedureControllerCallback(callback);
        mCameraPreview.init(mCamera, (float) mProfile.videoFrameWidth / mProfile.videoFrameHeight, mCameraInfo.orientation);
    } else {
        message("Cannot open camera!");
        finish();
    }
}
#end_block

#method_before
public void init() {
    if (mCamera == null || mProfile == null) {
        return;
    }
    mRecorder = new MediaRecorder();
    mCamera.unlock();
    mRecorder.setCamera(mCamera);
    mRecorder.setVideoSource(MediaRecorder.VideoSource.CAMERA);
    mRecorder.setAudioSource(MediaRecorder.AudioSource.DEFAULT);
    mRecorder.setProfile(mProfile);
    try {
        mRecorder.setOutputFile(getVideoRecFilePath());
        mRecorder.prepare();
    } catch (IOException e) {
        Log.e(TAG, "Preparation for recording failed.");
        return;
    }
    try {
        mRecorder.start();
    } catch (RuntimeException e) {
        Log.e(TAG, "Starting recording failed.");
        mRecorder.reset();
        mRecorder.release();
        mCamera.lock();
        return;
    }
    mRunning = true;
}
#method_after
public void init() {
    if (mCamera == null || mProfile == null) {
        return;
    }
    mRecorder = new MediaRecorder();
    try {
        mCamera.unlock();
    } catch (RuntimeException e) {
        e.printStackTrace();
        try {
            mRecorder.reset();
            mRecorder.release();
        } catch (RuntimeException ex) {
            e.printStackTrace();
        }
        return;
    }
    try {
        mRecorder.setCamera(mCamera);
        mRecorder.setVideoSource(MediaRecorder.VideoSource.CAMERA);
        mRecorder.setAudioSource(MediaRecorder.AudioSource.DEFAULT);
        mRecorder.setProfile(mProfile);
    } catch (RuntimeException e) {
        e.printStackTrace();
        return;
    }
    try {
        mRecorder.setOutputFile(getVideoRecFilePath());
        mRecorder.prepare();
    } catch (IOException e) {
        Log.e(TAG, "Preparation for recording failed.");
        return;
    }
    try {
        mRecorder.start();
    } catch (RuntimeException e) {
        Log.e(TAG, "Starting recording failed.");
        try {
            mRecorder.reset();
            mRecorder.release();
            mCamera.lock();
        } catch (RuntimeException ex1) {
            e.printStackTrace();
        }
        return;
    }
    mRunning = true;
}
#end_block

#method_before
public void quit() {
    if (mThread != null)
        mThread.interrupt();
    try {
        if (LOCAL_LOGV)
            Log.v(TAG, "Wait for controller to end");
        // stop video recording
        mActivity.stopRecordVideo();
        // stop sensor logging
        mActivity.stopRecordSensor();
    } catch (Exception e) {
        e.printStackTrace();
    }
}
#method_after
public void quit() {
    mThread.interrupt();
    try {
        if (LOCAL_LOGV)
            Log.v(TAG, "Wait for controller to end");
        // stop video recording
        mActivity.stopRecordVideo();
        // stop sensor logging
        mActivity.stopRecordSensor();
    } catch (Exception e) {
        e.printStackTrace();
    }
}
#end_block

#method_before
public void surfaceCreated(SurfaceHolder holder) {
    if (mCamera == null) {
        // preview camera does not exist
        return;
    }
    try {
        mCamera.setPreviewDisplay(holder);
        mCamera.startPreview();
        int v_height = getHeight();
        int v_width = getWidth();
        ViewGroup.LayoutParams layout = getLayoutParams();
        if ((float) v_height / v_width > mAspect) {
            layout.height = (int) Math.round(v_width * mAspect);
            layout.width = v_width;
        } else {
            layout.width = (int) Math.round(v_height / mAspect);
            layout.height = v_height;
        }
        Log.d(TAG, String.format("Layout (%d, %d) -> (%d, %d)", v_width, v_height, layout.width, layout.height));
        setLayoutParams(layout);
    } catch (IOException e) {
        if (LOCAL_LOGD)
            Log.d(TAG, "Error when starting camera preview: " + e.getMessage());
    }
}
#method_after
public void surfaceCreated(SurfaceHolder holder) {
    if (mCamera == null) {
        // preview camera does not exist
        return;
    }
}
#end_block

#method_before
public void surfaceChanged(SurfaceHolder holder, int format, int w, int h) {
    if (mHolder.getSurface() == null || mCamera == null) {
        // preview surface or camera does not exist
        return;
    }
    int expectedHeight = (int) Math.round(w * mAspect);
    int expecteddWidth = (int) Math.round(h / mAspect);
    if ((expectedHeight == h || expectedHeight == (h - 1)) && (expecteddWidth == w || expecteddWidth == (w + 1))) {
        if (!mCheckStartTest && mOnRecordProcedureControllerListener != null) {
            mCheckStartTest = true;
            mOnRecordProcedureControllerListener.startRecordProcedurecontroller();
        }
        return;
    }
    if (mCheckStartTest) {
        if (mOnRecordProcedureControllerListener != null) {
            mOnRecordProcedureControllerListener.stopRecordProcedurecontroller();
        }
    }
    mCheckStartTest = false;
    // stop preview before making changes
    mCamera.stopPreview();
    mCamera.setDisplayOrientation(mRotation);
    // do the same as if it is created again
    surfaceCreated(holder);
}
#method_after
public void surfaceChanged(SurfaceHolder holder, int format, int w, int h) {
    if (mHolder.getSurface() == null || mCamera == null) {
        // preview surface or camera does not exist
        return;
    }
    if (adjustLayoutParamsIfNeeded()) {
        // Wait on next surfaceChanged() call before proceeding
        Log.d(TAG, "Waiting on surface change before starting preview");
        return;
    }
    if (mPreviewStarted) {
        Log.w(TAG, "Re-starting camera preview");
        if (mCheckStartTest && mRecordProcedureControllerCallback != null) {
            mRecordProcedureControllerCallback.stopRecordProcedureController();
        }
        mCamera.stopPreview();
        mPreviewStarted = false;
    }
    mCheckStartTest = false;
    mCamera.setDisplayOrientation(mRotation);
    try {
        mCamera.setPreviewDisplay(holder);
        mCamera.startPreview();
        mPreviewStarted = true;
        if (mRecordProcedureControllerCallback != null) {
            mCheckStartTest = true;
            mRecordProcedureControllerCallback.startRecordProcedureController();
        }
    } catch (IOException e) {
        if (LOCAL_LOGD)
            Log.d(TAG, "Error when starting camera preview: " + e.getMessage());
    }
}
#end_block

#method_before
@Test
public void testImmediateEncoding() throws IllegalInstructionException {
    final byte LI_OP = (byte) (13 << 3);
    final byte SIZE0 = (byte) (0 << 1);
    final byte SIZE8 = (byte) (1 << 1);
    final byte SIZE16 = (byte) (2 << 1);
    final byte SIZE32 = (byte) (3 << 1);
    final byte R1 = 1;
    ApfGenerator gen;
    // 0-byte immediate: li R0, 0
    gen = new ApfGenerator(3);
    gen.addLoadImmediate(Register.R0, 0);
    assertProgramEquals(new byte[] { LI_OP | SIZE0 }, gen.generate());
    // 1-byte immediate: li R0, 42
    gen = new ApfGenerator(3);
    gen.addLoadImmediate(Register.R0, 42);
    assertProgramEquals(new byte[] { LI_OP | SIZE8, 42 }, gen.generate());
    // 2-byte immediate: li R1, 0x1234
    gen = new ApfGenerator(3);
    gen.addLoadImmediate(Register.R1, 0x1234);
    assertProgramEquals(new byte[] { LI_OP | SIZE16 | R1, 0x12, 0x34 }, gen.generate());
    // 4-byte immediate: li R0, 0x12345678
    gen = new ApfGenerator(3);
    gen.addLoadImmediate(Register.R0, 0x12345678);
    assertProgramEquals(new byte[] { LI_OP | SIZE32, 0x12, 0x34, 0x56, 0x78 }, gen.generate());
}
#method_after
@Test
public void testImmediateEncoding() throws IllegalInstructionException {
    ApfGenerator gen;
    // 0-byte immediate: li R0, 0
    gen = new ApfGenerator(4);
    gen.addLoadImmediate(Register.R0, 0);
    assertProgramEquals(new byte[] { LI_OP | SIZE0 }, gen.generate());
    // 1-byte immediate: li R0, 42
    gen = new ApfGenerator(4);
    gen.addLoadImmediate(Register.R0, 42);
    assertProgramEquals(new byte[] { LI_OP | SIZE8, 42 }, gen.generate());
    // 2-byte immediate: li R1, 0x1234
    gen = new ApfGenerator(4);
    gen.addLoadImmediate(Register.R1, 0x1234);
    assertProgramEquals(new byte[] { LI_OP | SIZE16 | R1, 0x12, 0x34 }, gen.generate());
    // 4-byte immediate: li R0, 0x12345678
    gen = new ApfGenerator(3);
    gen.addLoadImmediate(Register.R0, 0x12345678);
    assertProgramEquals(new byte[] { LI_OP | SIZE32, 0x12, 0x34, 0x56, 0x78 }, gen.generate());
}
#end_block

#method_before
@Test
public void testNegativeImmediateEncoding() throws IllegalInstructionException {
    final byte LI_OP = (byte) (13 << 3);
    final byte SIZE0 = (byte) (0 << 1);
    final byte SIZE8 = (byte) (1 << 1);
    final byte SIZE16 = (byte) (2 << 1);
    final byte SIZE32 = (byte) (3 << 1);
    final byte R1 = 1;
    ApfGenerator gen;
    // 1-byte negative immediate: li R0, -42
    gen = new ApfGenerator(3);
    gen.addLoadImmediate(Register.R0, -42);
    assertProgramEquals(new byte[] { LI_OP | SIZE8, -42 }, gen.generate());
    // 2-byte negative immediate: li R1, -0x1234
    gen = new ApfGenerator(3);
    gen.addLoadImmediate(Register.R1, -0x1122);
    assertProgramEquals(new byte[] { LI_OP | SIZE16 | R1, (byte) 0xEE, (byte) 0xDE }, gen.generate());
    // 4-byte negative immediate: li R0, -0x11223344
    gen = new ApfGenerator(3);
    gen.addLoadImmediate(Register.R0, -0x11223344);
    assertProgramEquals(new byte[] { LI_OP | SIZE32, (byte) 0xEE, (byte) 0xDD, (byte) 0xCC, (byte) 0xBC }, gen.generate());
}
#method_after
@Test
public void testNegativeImmediateEncoding() throws IllegalInstructionException {
    ApfGenerator gen;
    // 1-byte negative immediate: li R0, -42
    gen = new ApfGenerator(3);
    gen.addLoadImmediate(Register.R0, -42);
    assertProgramEquals(new byte[] { LI_OP | SIZE8, -42 }, gen.generate());
    // 2-byte negative immediate: li R1, -0x1122
    gen = new ApfGenerator(3);
    gen.addLoadImmediate(Register.R1, -0x1122);
    assertProgramEquals(new byte[] { LI_OP | SIZE16 | R1, (byte) 0xEE, (byte) 0xDE }, gen.generate());
    // 4-byte negative immediate: li R0, -0x11223344
    gen = new ApfGenerator(3);
    gen.addLoadImmediate(Register.R0, -0x11223344);
    assertProgramEquals(new byte[] { LI_OP | SIZE32, (byte) 0xEE, (byte) 0xDD, (byte) 0xCC, (byte) 0xBC }, gen.generate());
}
#end_block

#method_before
@Test
public void testLoadStoreDataEncoding() throws IllegalInstructionException {
    final byte LDDW_OP = (byte) (22 << 3);
    final byte STDW_OP = (byte) (23 << 3);
    final byte SIZE0 = (byte) (0 << 1);
    final byte SIZE8 = (byte) (1 << 1);
    final byte SIZE16 = (byte) (2 << 1);
    final byte SIZE32 = (byte) (3 << 1);
    final byte R1 = 1;
    ApfGenerator gen;
    // Load data with no offset: lddw R0, [0 + r1]
    gen = new ApfGenerator(3);
    gen.addLoadData(Register.R0, 0);
    assertProgramEquals(new byte[] { LDDW_OP | SIZE0 }, gen.generate());
    // Store data with 8bit negative offset: lddw r0, [-42 + r1]
    gen = new ApfGenerator(3);
    gen.addStoreData(Register.R0, -42);
    assertProgramEquals(new byte[] { STDW_OP | SIZE8, -42 }, gen.generate());
    // Store data to R1 with 16bit negative offset: stdw r1, [-0x1234 + r0]
    gen = new ApfGenerator(3);
    gen.addStoreData(Register.R1, -0x1122);
    assertProgramEquals(new byte[] { STDW_OP | SIZE16 | R1, (byte) 0xEE, (byte) 0xDE }, gen.generate());
    // Load data to R1 with 32bit negative offset: lddw r1, [0x11223344 + r0]
    gen = new ApfGenerator(3);
    gen.addLoadData(Register.R1, 0xDEADBEEF);
    assertProgramEquals(new byte[] { LDDW_OP | SIZE32 | R1, (byte) 0xDE, (byte) 0xAD, (byte) 0xBE, (byte) 0xEF }, gen.generate());
}
#method_after
@Test
public void testLoadStoreDataEncoding() throws IllegalInstructionException {
    ApfGenerator gen;
    // Load data with no offset: lddw R0, [0 + r1]
    gen = new ApfGenerator(3);
    gen.addLoadData(Register.R0, 0);
    assertProgramEquals(new byte[] { LDDW_OP | SIZE0 }, gen.generate());
    // Store data with 8bit negative offset: lddw r0, [-42 + r1]
    gen = new ApfGenerator(3);
    gen.addStoreData(Register.R0, -42);
    assertProgramEquals(new byte[] { STDW_OP | SIZE8, -42 }, gen.generate());
    // Store data to R1 with 16bit negative offset: stdw r1, [-0x1122 + r0]
    gen = new ApfGenerator(3);
    gen.addStoreData(Register.R1, -0x1122);
    assertProgramEquals(new byte[] { STDW_OP | SIZE16 | R1, (byte) 0xEE, (byte) 0xDE }, gen.generate());
    // Load data to R1 with 32bit negative offset: lddw r1, [0xDEADBEEF + r0]
    gen = new ApfGenerator(3);
    gen.addLoadData(Register.R1, 0xDEADBEEF);
    assertProgramEquals(new byte[] { LDDW_OP | SIZE32 | R1, (byte) 0xDE, (byte) 0xAD, (byte) 0xBE, (byte) 0xEF }, gen.generate());
}
#end_block

#method_before
private PackageParser.Package scanPackageInternalLI(PackageParser.Package pkg, File scanFile, int policyFlags, int scanFlags, long currentTime, @Nullable UserHandle user) throws PackageManagerException {
    PackageSetting ps = null;
    PackageSetting updatedPkg;
    // reader
    synchronized (mPackages) {
        // Look to see if we already know about this package.
        String oldName = mSettings.getRenamedPackageLPr(pkg.packageName);
        if (pkg.mOriginalPackages != null && pkg.mOriginalPackages.contains(oldName)) {
            // This package has been renamed to its original name.  Let's
            // use that.
            ps = mSettings.getPackageLPr(oldName);
        }
        // If there was no original package, see one for the real package name.
        if (ps == null) {
            ps = mSettings.getPackageLPr(pkg.packageName);
        }
        // Check to see if this package could be hiding/updating a system
        // package.  Must look for it either under the original or real
        // package name depending on our state.
        updatedPkg = mSettings.getDisabledSystemPkgLPr(ps != null ? ps.name : pkg.packageName);
        if (DEBUG_INSTALL && updatedPkg != null)
            Slog.d(TAG, "updatedPkg = " + updatedPkg);
        // on the data partition and no longer defines this child package.
        if ((policyFlags & PackageParser.PARSE_IS_SYSTEM) != 0) {
            // If this is a parent package for an updated system app and this system
            // app got an OTA update which no longer defines some of the child packages
            // we have to prune them from the disabled system packages.
            PackageSetting disabledPs = mSettings.getDisabledSystemPkgLPr(pkg.packageName);
            if (disabledPs != null) {
                final int scannedChildCount = (pkg.childPackages != null) ? pkg.childPackages.size() : 0;
                final int disabledChildCount = disabledPs.childPackageNames != null ? disabledPs.childPackageNames.size() : 0;
                for (int i = 0; i < disabledChildCount; i++) {
                    String disabledChildPackageName = disabledPs.childPackageNames.get(i);
                    boolean disabledPackageAvailable = false;
                    for (int j = 0; j < scannedChildCount; j++) {
                        PackageParser.Package childPkg = pkg.childPackages.get(j);
                        if (childPkg.packageName.equals(disabledChildPackageName)) {
                            disabledPackageAvailable = true;
                            break;
                        }
                    }
                    if (!disabledPackageAvailable) {
                        mSettings.removeDisabledSystemPackageLPw(disabledChildPackageName);
                    }
                }
            }
        }
    }
    final boolean isUpdatedPkg = updatedPkg != null;
    final boolean isUpdatedSystemPkg = isUpdatedPkg && (policyFlags & PackageParser.PARSE_IS_SYSTEM) != 0;
    boolean isUpdatedPkgBetter = false;
    // First check if this is a system package that may involve an update
    if (isUpdatedSystemPkg) {
        // it needs to drop FLAG_PRIVILEGED.
        if (locationIsPrivileged(scanFile)) {
            updatedPkg.pkgPrivateFlags |= ApplicationInfo.PRIVATE_FLAG_PRIVILEGED;
        } else {
            updatedPkg.pkgPrivateFlags &= ~ApplicationInfo.PRIVATE_FLAG_PRIVILEGED;
        }
        if (ps != null && !ps.codePath.equals(scanFile)) {
            // what to do.
            if (DEBUG_INSTALL)
                Slog.d(TAG, "Path changing from " + ps.codePath);
            if (pkg.mVersionCode <= ps.versionCode) {
                // Ignore entry. Skip it.
                if (DEBUG_INSTALL)
                    Slog.i(TAG, "Package " + ps.name + " at " + scanFile + " ignored: updated version " + ps.versionCode + " better than this " + pkg.mVersionCode);
                if (!updatedPkg.codePath.equals(scanFile)) {
                    Slog.w(PackageManagerService.TAG, "Code path for hidden system pkg " + ps.name + " changing from " + updatedPkg.codePathString + " to " + scanFile);
                    updatedPkg.codePath = scanFile;
                    updatedPkg.codePathString = scanFile.toString();
                    updatedPkg.resourcePath = scanFile;
                    updatedPkg.resourcePathString = scanFile.toString();
                }
                updatedPkg.pkg = pkg;
                updatedPkg.versionCode = pkg.mVersionCode;
                // Update the disabled system child packages to point to the package too.
                final int childCount = updatedPkg.childPackageNames != null ? updatedPkg.childPackageNames.size() : 0;
                for (int i = 0; i < childCount; i++) {
                    String childPackageName = updatedPkg.childPackageNames.get(i);
                    PackageSetting updatedChildPkg = mSettings.getDisabledSystemPkgLPr(childPackageName);
                    if (updatedChildPkg != null) {
                        updatedChildPkg.pkg = pkg;
                        updatedChildPkg.versionCode = pkg.mVersionCode;
                    }
                }
            } else {
                // writer
                synchronized (mPackages) {
                    // Just remove the loaded entries from package lists.
                    mPackages.remove(ps.name);
                }
                logCriticalInfo(Log.WARN, "Package " + ps.name + " at " + scanFile + " reverting from " + ps.codePathString + ": new version " + pkg.mVersionCode + " better than installed " + ps.versionCode);
                InstallArgs args = createInstallArgsForExisting(packageFlagsToInstallFlags(ps), ps.codePathString, ps.resourcePathString, getAppDexInstructionSets(ps));
                synchronized (mInstallLock) {
                    args.cleanUpResourcesLI();
                }
                synchronized (mPackages) {
                    mSettings.enableSystemPackageLPw(ps.name);
                }
                isUpdatedPkgBetter = true;
            }
        }
    }
    String resourcePath = null;
    String baseResourcePath = null;
    if ((policyFlags & PackageParser.PARSE_FORWARD_LOCK) != 0 && !isUpdatedPkgBetter) {
        if (ps != null && ps.resourcePathString != null) {
            resourcePath = ps.resourcePathString;
            baseResourcePath = ps.resourcePathString;
        } else {
            // Should not happen at all. Just log an error.
            Slog.e(TAG, "Resource path not set for package " + pkg.packageName);
        }
    } else {
        resourcePath = pkg.codePath;
        baseResourcePath = pkg.baseCodePath;
    }
    // Set application objects path explicitly.
    pkg.setApplicationVolumeUuid(pkg.volumeUuid);
    pkg.setApplicationInfoCodePath(pkg.codePath);
    pkg.setApplicationInfoBaseCodePath(pkg.baseCodePath);
    pkg.setApplicationInfoSplitCodePaths(pkg.splitCodePaths);
    pkg.setApplicationInfoResourcePath(resourcePath);
    pkg.setApplicationInfoBaseResourcePath(baseResourcePath);
    pkg.setApplicationInfoSplitResourcePaths(pkg.splitCodePaths);
    // recent than the package we've already scanned
    if (isUpdatedSystemPkg && !isUpdatedPkgBetter) {
        // Set CPU Abis to application info.
        if ((scanFlags & SCAN_FIRST_BOOT_OR_UPGRADE) != 0) {
            final String cpuAbiOverride = deriveAbiOverride(pkg.cpuAbiOverride, updatedPkg);
            derivePackageAbi(pkg, scanFile, cpuAbiOverride, false, mAppLib32InstallDir);
        } else {
            pkg.applicationInfo.primaryCpuAbi = updatedPkg.primaryCpuAbiString;
            pkg.applicationInfo.secondaryCpuAbi = updatedPkg.secondaryCpuAbiString;
        }
        throw new PackageManagerException(Log.WARN, "Package " + ps.name + " at " + scanFile + " ignored: updated version " + ps.versionCode + " better than this " + pkg.mVersionCode);
    }
    if (isUpdatedPkg) {
        // An updated system app will not have the PARSE_IS_SYSTEM flag set
        // initially
        policyFlags |= PackageParser.PARSE_IS_SYSTEM;
        // flag set initially
        if ((updatedPkg.pkgPrivateFlags & ApplicationInfo.PRIVATE_FLAG_PRIVILEGED) != 0) {
            policyFlags |= PackageParser.PARSE_IS_PRIVILEGED;
        }
    }
    // Verify certificates against what was last scanned
    collectCertificatesLI(ps, pkg, scanFile, policyFlags);
    // Reset profile if the application version is changed
    checkVersionForProfileLI(ps, pkg);
    /*
         * A new system app appeared, but we already had a non-system one of the
         * same name installed earlier.
         */
    boolean shouldHideSystemApp = false;
    if (!isUpdatedPkg && ps != null && (policyFlags & PackageParser.PARSE_IS_SYSTEM_DIR) != 0 && !isSystemApp(ps)) {
        /*
             * Check to make sure the signatures match first. If they don't,
             * wipe the installed application and its data.
             */
        if (compareSignatures(ps.signatures.mSignatures, pkg.mSignatures) != PackageManager.SIGNATURE_MATCH) {
            logCriticalInfo(Log.WARN, "Package " + ps.name + " appeared on system, but" + " signatures don't match existing userdata copy; removing");
            try (PackageFreezer freezer = freezePackage(pkg.packageName, "scanPackageInternalLI")) {
                deletePackageLIF(pkg.packageName, null, true, null, 0, null, false, null);
            }
            ps = null;
        } else {
            /*
                 * If the newly-added system app is an older version than the
                 * already installed version, hide it. It will be scanned later
                 * and re-added like an update.
                 */
            if (pkg.mVersionCode <= ps.versionCode) {
                shouldHideSystemApp = true;
                logCriticalInfo(Log.INFO, "Package " + ps.name + " appeared at " + scanFile + " but new version " + pkg.mVersionCode + " better than installed " + ps.versionCode + "; hiding system");
            } else {
                /*
                     * The newly found system app is a newer version that the
                     * one previously installed. Simply remove the
                     * already-installed application and replace it with our own
                     * while keeping the application data.
                     */
                logCriticalInfo(Log.WARN, "Package " + ps.name + " at " + scanFile + " reverting from " + ps.codePathString + ": new version " + pkg.mVersionCode + " better than installed " + ps.versionCode);
                InstallArgs args = createInstallArgsForExisting(packageFlagsToInstallFlags(ps), ps.codePathString, ps.resourcePathString, getAppDexInstructionSets(ps));
                synchronized (mInstallLock) {
                    args.cleanUpResourcesLI();
                }
            }
        }
    }
    // TODO grab this value from PackageSettings
    if ((policyFlags & PackageParser.PARSE_IS_SYSTEM_DIR) == 0) {
        if (ps != null && !ps.codePath.equals(ps.resourcePath)) {
            policyFlags |= PackageParser.PARSE_FORWARD_LOCK;
        }
    }
    final int userId = ((user == null) ? 0 : user.getIdentifier());
    if (ps != null && ps.getInstantApp(userId)) {
        scanFlags |= SCAN_AS_INSTANT_APP;
    }
    if (ps != null && ps.getVirtulalPreload(userId)) {
        scanFlags |= SCAN_AS_VIRTUAL_PRELOAD;
    }
    // Note that we invoke the following method only if we are about to unpack an application
    PackageParser.Package scannedPkg = scanPackageLI(pkg, policyFlags, scanFlags | SCAN_UPDATE_SIGNATURE, currentTime, user);
    /*
         * If the system app should be overridden by a previously installed
         * data, hide the system app now and let the /data/app scan pick it up
         * again.
         */
    if (shouldHideSystemApp) {
        synchronized (mPackages) {
            mSettings.disableSystemPackageLPw(pkg.packageName, true);
        }
    }
    return scannedPkg;
}
#method_after
private PackageParser.Package scanPackageInternalLI(PackageParser.Package pkg, File scanFile, int policyFlags, int scanFlags, long currentTime, @Nullable UserHandle user) throws PackageManagerException {
    PackageSetting ps = null;
    PackageSetting updatedPkg;
    // reader
    synchronized (mPackages) {
        // Look to see if we already know about this package.
        String oldName = mSettings.getRenamedPackageLPr(pkg.packageName);
        if (pkg.mOriginalPackages != null && pkg.mOriginalPackages.contains(oldName)) {
            // This package has been renamed to its original name.  Let's
            // use that.
            ps = mSettings.getPackageLPr(oldName);
        }
        // If there was no original package, see one for the real package name.
        if (ps == null) {
            ps = mSettings.getPackageLPr(pkg.packageName);
        }
        // Check to see if this package could be hiding/updating a system
        // package.  Must look for it either under the original or real
        // package name depending on our state.
        updatedPkg = mSettings.getDisabledSystemPkgLPr(ps != null ? ps.name : pkg.packageName);
        if (DEBUG_INSTALL && updatedPkg != null)
            Slog.d(TAG, "updatedPkg = " + updatedPkg);
        // on the data partition and no longer defines this child package.
        if ((policyFlags & PackageParser.PARSE_IS_SYSTEM) != 0) {
            // If this is a parent package for an updated system app and this system
            // app got an OTA update which no longer defines some of the child packages
            // we have to prune them from the disabled system packages.
            PackageSetting disabledPs = mSettings.getDisabledSystemPkgLPr(pkg.packageName);
            if (disabledPs != null) {
                final int scannedChildCount = (pkg.childPackages != null) ? pkg.childPackages.size() : 0;
                final int disabledChildCount = disabledPs.childPackageNames != null ? disabledPs.childPackageNames.size() : 0;
                for (int i = 0; i < disabledChildCount; i++) {
                    String disabledChildPackageName = disabledPs.childPackageNames.get(i);
                    boolean disabledPackageAvailable = false;
                    for (int j = 0; j < scannedChildCount; j++) {
                        PackageParser.Package childPkg = pkg.childPackages.get(j);
                        if (childPkg.packageName.equals(disabledChildPackageName)) {
                            disabledPackageAvailable = true;
                            break;
                        }
                    }
                    if (!disabledPackageAvailable) {
                        mSettings.removeDisabledSystemPackageLPw(disabledChildPackageName);
                    }
                }
            }
        }
    }
    final boolean isUpdatedPkg = updatedPkg != null;
    final boolean isUpdatedSystemPkg = isUpdatedPkg && (policyFlags & PackageParser.PARSE_IS_SYSTEM) != 0;
    boolean isUpdatedPkgBetter = false;
    // First check if this is a system package that may involve an update
    if (isUpdatedSystemPkg) {
        // it needs to drop FLAG_PRIVILEGED.
        if (locationIsPrivileged(scanFile)) {
            updatedPkg.pkgPrivateFlags |= ApplicationInfo.PRIVATE_FLAG_PRIVILEGED;
        } else {
            updatedPkg.pkgPrivateFlags &= ~ApplicationInfo.PRIVATE_FLAG_PRIVILEGED;
        }
        if (ps != null && !ps.codePath.equals(scanFile)) {
            // what to do.
            if (DEBUG_INSTALL)
                Slog.d(TAG, "Path changing from " + ps.codePath);
            if (pkg.mVersionCode <= ps.versionCode) {
                // Ignore entry. Skip it.
                if (DEBUG_INSTALL)
                    Slog.i(TAG, "Package " + ps.name + " at " + scanFile + " ignored: updated version " + ps.versionCode + " better than this " + pkg.mVersionCode);
                if (!updatedPkg.codePath.equals(scanFile)) {
                    Slog.w(PackageManagerService.TAG, "Code path for hidden system pkg " + ps.name + " changing from " + updatedPkg.codePathString + " to " + scanFile);
                    updatedPkg.codePath = scanFile;
                    updatedPkg.codePathString = scanFile.toString();
                    updatedPkg.resourcePath = scanFile;
                    updatedPkg.resourcePathString = scanFile.toString();
                }
                updatedPkg.pkg = pkg;
                updatedPkg.versionCode = pkg.mVersionCode;
                // Update the disabled system child packages to point to the package too.
                final int childCount = updatedPkg.childPackageNames != null ? updatedPkg.childPackageNames.size() : 0;
                for (int i = 0; i < childCount; i++) {
                    String childPackageName = updatedPkg.childPackageNames.get(i);
                    PackageSetting updatedChildPkg = mSettings.getDisabledSystemPkgLPr(childPackageName);
                    if (updatedChildPkg != null) {
                        updatedChildPkg.pkg = pkg;
                        updatedChildPkg.versionCode = pkg.mVersionCode;
                    }
                }
            } else {
                // writer
                synchronized (mPackages) {
                    // Just remove the loaded entries from package lists.
                    mPackages.remove(ps.name);
                }
                logCriticalInfo(Log.WARN, "Package " + ps.name + " at " + scanFile + " reverting from " + ps.codePathString + ": new version " + pkg.mVersionCode + " better than installed " + ps.versionCode);
                InstallArgs args = createInstallArgsForExisting(packageFlagsToInstallFlags(ps), ps.codePathString, ps.resourcePathString, getAppDexInstructionSets(ps));
                synchronized (mInstallLock) {
                    args.cleanUpResourcesLI();
                }
                synchronized (mPackages) {
                    mSettings.enableSystemPackageLPw(ps.name);
                }
                isUpdatedPkgBetter = true;
            }
        }
    }
    String resourcePath = null;
    String baseResourcePath = null;
    if ((policyFlags & PackageParser.PARSE_FORWARD_LOCK) != 0 && !isUpdatedPkgBetter) {
        if (ps != null && ps.resourcePathString != null) {
            resourcePath = ps.resourcePathString;
            baseResourcePath = ps.resourcePathString;
        } else {
            // Should not happen at all. Just log an error.
            Slog.e(TAG, "Resource path not set for package " + pkg.packageName);
        }
    } else {
        resourcePath = pkg.codePath;
        baseResourcePath = pkg.baseCodePath;
    }
    // Set application objects path explicitly.
    pkg.setApplicationVolumeUuid(pkg.volumeUuid);
    pkg.setApplicationInfoCodePath(pkg.codePath);
    pkg.setApplicationInfoBaseCodePath(pkg.baseCodePath);
    pkg.setApplicationInfoSplitCodePaths(pkg.splitCodePaths);
    pkg.setApplicationInfoResourcePath(resourcePath);
    pkg.setApplicationInfoBaseResourcePath(baseResourcePath);
    pkg.setApplicationInfoSplitResourcePaths(pkg.splitCodePaths);
    // recent than the package we've already scanned
    if (isUpdatedSystemPkg && !isUpdatedPkgBetter) {
        // Set CPU Abis to application info.
        if ((scanFlags & SCAN_FIRST_BOOT_OR_UPGRADE) != 0) {
            final String cpuAbiOverride = deriveAbiOverride(pkg.cpuAbiOverride, updatedPkg);
            derivePackageAbi(pkg, scanFile, cpuAbiOverride, false, mAppLib32InstallDir);
        } else {
            pkg.applicationInfo.primaryCpuAbi = updatedPkg.primaryCpuAbiString;
            pkg.applicationInfo.secondaryCpuAbi = updatedPkg.secondaryCpuAbiString;
        }
        throw new PackageManagerException(Log.WARN, "Package " + ps.name + " at " + scanFile + " ignored: updated version " + ps.versionCode + " better than this " + pkg.mVersionCode);
    }
    if (isUpdatedPkg) {
        // An updated system app will not have the PARSE_IS_SYSTEM flag set
        // initially
        policyFlags |= PackageParser.PARSE_IS_SYSTEM;
        // flag set initially
        if ((updatedPkg.pkgPrivateFlags & ApplicationInfo.PRIVATE_FLAG_PRIVILEGED) != 0) {
            policyFlags |= PackageParser.PARSE_IS_PRIVILEGED;
        }
    }
    // Verify certificates against what was last scanned
    collectCertificatesLI(ps, pkg, scanFile, policyFlags);
    // Reset profile if the application version is changed
    maybeClearProfilesForUpgradesLI(ps, pkg);
    /*
         * A new system app appeared, but we already had a non-system one of the
         * same name installed earlier.
         */
    boolean shouldHideSystemApp = false;
    if (!isUpdatedPkg && ps != null && (policyFlags & PackageParser.PARSE_IS_SYSTEM_DIR) != 0 && !isSystemApp(ps)) {
        /*
             * Check to make sure the signatures match first. If they don't,
             * wipe the installed application and its data.
             */
        if (compareSignatures(ps.signatures.mSignatures, pkg.mSignatures) != PackageManager.SIGNATURE_MATCH) {
            logCriticalInfo(Log.WARN, "Package " + ps.name + " appeared on system, but" + " signatures don't match existing userdata copy; removing");
            try (PackageFreezer freezer = freezePackage(pkg.packageName, "scanPackageInternalLI")) {
                deletePackageLIF(pkg.packageName, null, true, null, 0, null, false, null);
            }
            ps = null;
        } else {
            /*
                 * If the newly-added system app is an older version than the
                 * already installed version, hide it. It will be scanned later
                 * and re-added like an update.
                 */
            if (pkg.mVersionCode <= ps.versionCode) {
                shouldHideSystemApp = true;
                logCriticalInfo(Log.INFO, "Package " + ps.name + " appeared at " + scanFile + " but new version " + pkg.mVersionCode + " better than installed " + ps.versionCode + "; hiding system");
            } else {
                /*
                     * The newly found system app is a newer version that the
                     * one previously installed. Simply remove the
                     * already-installed application and replace it with our own
                     * while keeping the application data.
                     */
                logCriticalInfo(Log.WARN, "Package " + ps.name + " at " + scanFile + " reverting from " + ps.codePathString + ": new version " + pkg.mVersionCode + " better than installed " + ps.versionCode);
                InstallArgs args = createInstallArgsForExisting(packageFlagsToInstallFlags(ps), ps.codePathString, ps.resourcePathString, getAppDexInstructionSets(ps));
                synchronized (mInstallLock) {
                    args.cleanUpResourcesLI();
                }
            }
        }
    }
    // TODO grab this value from PackageSettings
    if ((policyFlags & PackageParser.PARSE_IS_SYSTEM_DIR) == 0) {
        if (ps != null && !ps.codePath.equals(ps.resourcePath)) {
            policyFlags |= PackageParser.PARSE_FORWARD_LOCK;
        }
    }
    final int userId = ((user == null) ? 0 : user.getIdentifier());
    if (ps != null && ps.getInstantApp(userId)) {
        scanFlags |= SCAN_AS_INSTANT_APP;
    }
    if (ps != null && ps.getVirtulalPreload(userId)) {
        scanFlags |= SCAN_AS_VIRTUAL_PRELOAD;
    }
    // Note that we invoke the following method only if we are about to unpack an application
    PackageParser.Package scannedPkg = scanPackageLI(pkg, policyFlags, scanFlags | SCAN_UPDATE_SIGNATURE, currentTime, user);
    /*
         * If the system app should be overridden by a previously installed
         * data, hide the system app now and let the /data/app scan pick it up
         * again.
         */
    if (shouldHideSystemApp) {
        synchronized (mPackages) {
            mSettings.disableSystemPackageLPw(pkg.packageName, true);
        }
    }
    return scannedPkg;
}
#end_block

#method_before
private IpSecTransform createTransportModeTransform(String encAlgo, byte[] cryptKey, String authAlgo, byte[] authKey, Integer truncBits, SecurityParameterIndex spi, InetAddress addr) {
    Builder builder = new Builder(mContext);
    builder = builder.setEncryption(new IpSecAlgorithm(encAlgo, cryptKey));
    builder = builder.setAuthentication(new IpSecAlgorithm(authAlgo, authKey, truncBits.intValue()));
    try {
        return builder.buildTransportModeTransform(addr, spi);
    } catch (SpiUnavailableException | IOException | ResourceUnavailableException e) {
        Log.e("IpSec: Cannot create Transport mode transform" + e.toString());
    }
    return null;
}
#method_after
private IpSecTransform createTransportModeTransform(String encAlgo, byte[] cryptKey, String authAlgo, byte[] authKey, Integer truncBits, SecurityParameterIndex spi, InetAddress addr, UdpEncapsulationSocket udpEncapSocket) {
    Builder builder = new Builder(mContext);
    builder = builder.setEncryption(new IpSecAlgorithm(encAlgo, cryptKey));
    builder = builder.setAuthentication(new IpSecAlgorithm(authAlgo, authKey, truncBits.intValue()));
    if (udpEncapSocket != null) {
        builder = builder.setIpv4Encapsulation(udpEncapSocket, udpEncapSocket.getPort());
    }
    try {
        return builder.buildTransportModeTransform(addr, spi);
    } catch (SpiUnavailableException | IOException | ResourceUnavailableException e) {
        Log.e("IpSec: Cannot create Transport mode transform" + e.toString());
    }
    return null;
}
#end_block

#method_before
@Rpc(description = "Apply transport mode transform to DatagramSocket", returns = "True/False")
public Boolean ipSecApplyTransportModeTransformDatagramSocket(String socketId, Integer direction, String transformId) {
    DatagramSocket socket = SocketFacade.getDatagramSocketFromHashMap(socketId);
    IpSecTransform transform = sTransformHashMap.get(transformId);
    if (transform == null) {
        Log.e("IpSec: Transform does not exist for the requested id");
        return false;
    }
    try {
        mIpSecManager.applyTransportModeTransform(socket, direction.intValue(), transform);
    } catch (IOException e) {
        Log.e("IpSec: Cannot apply transform to socket " + e.toString());
        return false;
    }
    return true;
}
#method_after
@Rpc(description = "Apply transport mode transform to DatagramSocket", returns = "True/False")
public Boolean ipSecApplyTransportModeTransformDatagramSocket(String socketId, Integer direction, String transformId) {
    if (socketId == null) {
        Log.e("IpSec: Received null DatagramSocket key");
        return false;
    }
    DatagramSocket socket = SocketFacade.getDatagramSocket(socketId);
    IpSecTransform transform = sTransformHashMap.get(transformId);
    if (transform == null) {
        Log.e("IpSec: Transform does not exist for the requested id");
        return false;
    }
    try {
        mIpSecManager.applyTransportModeTransform(socket, direction.intValue(), transform);
    } catch (IOException e) {
        Log.e("IpSec: Cannot apply transform to socket " + e.toString());
        return false;
    }
    return true;
}
#end_block

#method_before
@Rpc(description = "Remove transport mode tranform from DatagramSocket", returns = "True/False")
public Boolean ipSecRemoveTransportModeTransformsDatagramSocket(String socketId) {
    DatagramSocket socket = SocketFacade.getDatagramSocketFromHashMap(socketId);
    try {
        mIpSecManager.removeTransportModeTransforms(socket);
        return true;
    } catch (IOException e) {
        Log.e("IpSec: Failed to remove transform " + e.toString());
    }
    return false;
}
#method_after
@Rpc(description = "Remove transport mode tranform from DatagramSocket", returns = "True/False")
public Boolean ipSecRemoveTransportModeTransformsDatagramSocket(String socketId) {
    if (socketId == null) {
        Log.e("IpSec: Received null DatagramSocket key");
        return false;
    }
    DatagramSocket socket = SocketFacade.getDatagramSocket(socketId);
    try {
        mIpSecManager.removeTransportModeTransforms(socket);
        return true;
    } catch (IOException e) {
        Log.e("IpSec: Failed to remove transform " + e.toString());
    }
    return false;
}
#end_block

#method_before
@Rpc(description = "Create a transform mode transform", returns = "Hash of transform object")
public String ipSecCreateTransportModeTransform(String encAlgo, String cryptKeyHex, String authAlgo, String authKeyHex, Integer truncBits, String spiId, String addr) {
    IpSecTransform transform = null;
    InetAddress inetAddr = NetworkUtils.numericToInetAddress(addr);
    SecurityParameterIndex spi = sSpiHashMap.get(spiId);
    if (spi == null) {
        Log.e("IpSec: SPI does not exist for the requested spiId");
        return null;
    }
    byte[] cryptKey = BaseEncoding.base16().decode(cryptKeyHex.toUpperCase());
    byte[] authKey = BaseEncoding.base16().decode(authKeyHex.toUpperCase());
    transform = createTransportModeTransform(encAlgo, cryptKey, authAlgo, authKey, truncBits, spi, inetAddr);
    if (transform == null)
        return null;
    String id = getTransformId(transform);
    sTransformHashMap.put(id, transform);
    return id;
}
#method_after
@Rpc(description = "Create a transform mode transform", returns = "Hash of transform object")
public String ipSecCreateTransportModeTransform(String encAlgo, String cryptKeyHex, String authAlgo, String authKeyHex, Integer truncBits, String spiId, String addr, String udpEncapSockId) {
    IpSecTransform transform = null;
    InetAddress inetAddr = NetworkUtils.numericToInetAddress(addr);
    UdpEncapsulationSocket udpEncapSocket = sUdpEncapHashMap.get(udpEncapSockId);
    SecurityParameterIndex spi = sSpiHashMap.get(spiId);
    if (spi == null) {
        Log.e("IpSec: SPI does not exist for the requested spiId");
        return null;
    }
    byte[] cryptKey = BaseEncoding.base16().decode(cryptKeyHex.toUpperCase());
    byte[] authKey = BaseEncoding.base16().decode(authKeyHex.toUpperCase());
    transform = createTransportModeTransform(encAlgo, cryptKey, authAlgo, authKey, truncBits, spi, inetAddr, udpEncapSocket);
    if (transform == null)
        return null;
    String id = getTransformId(transform);
    sTransformHashMap.put(id, transform);
    return id;
}
#end_block

#method_before
@Rpc(description = "Open TCP server socket and accept connection")
public ArrayList<String> openTcpServerSocket(String addr, Integer port) {
    ArrayList<String> idList = new ArrayList<String>();
    try {
        InetAddress localAddr = NetworkUtils.numericToInetAddress(addr);
        ServerSocket serverSocket = new ServerSocket(port.intValue(), 1, localAddr);
        String id = getServerSocketId(serverSocket);
        idList.add(id);
        sServerSocketHashMap.put(id, serverSocket);
        Socket socket = serverSocket.accept();
        id = getSocketId(socket);
        idList.add(id);
        sSocketHashMap.put(id, socket);
    } catch (IOException e) {
        Log.e("Socket: Failed to open TCP server socket " + e.toString());
    }
    return idList;
}
#method_after
@Rpc(description = "Open TCP server socket and accept connection")
public String openTcpServerSocket(String addr, Integer port) {
    try {
        InetAddress localAddr = NetworkUtils.numericToInetAddress(addr);
        ServerSocket serverSocket = new ServerSocket(port.intValue(), 10, localAddr);
        String id = getServerSocketId(serverSocket);
        sServerSocketHashMap.put(id, serverSocket);
        return id;
    } catch (IOException e) {
        Log.e("Socket: Failed to open TCP server socket " + e.toString());
    }
    return null;
}
#end_block

#method_before
@Rpc(description = "Receive data over socket", returns = "Received data in String")
public String recvDataOverDatagramSocket(String id) {
    byte[] buf = new byte[2048];
    try {
        DatagramSocket socket = sDatagramSocketHashMap.get(id);
        DatagramPacket dgramPacket = new DatagramPacket(buf, 2048);
        socket.receive(dgramPacket);
        return new String(dgramPacket.getData(), 0, dgramPacket.getLength());
    } catch (IOException e) {
        Log.e("Socket: Failed to recv data over datagram socket");
    }
    return null;
}
#method_after
@Rpc(description = "Receive data over socket", returns = "Received data in String")
public String recvDataOverDatagramSocket(String id) {
    byte[] buf = new byte[MAX_BUF_SZ];
    try {
        DatagramSocket socket = sDatagramSocketHashMap.get(id);
        DatagramPacket dgramPacket = new DatagramPacket(buf, MAX_BUF_SZ);
        socket.receive(dgramPacket);
        return new String(dgramPacket.getData(), 0, dgramPacket.getLength());
    } catch (IOException e) {
        Log.e("Socket: Failed to recv data over datagram socket");
    }
    return null;
}
#end_block

#method_before
/*
     * The following APIs are used to open, close, send and receive data over Os.socket
     * This uses android.Os class and can be used for UDP and TCP traffic
     */
@Rpc(description = "Open socket")
public String openSocket(Integer domain, Integer type, String addr, Integer port) {
    try {
        FileDescriptor fd = Os.socket(domain, type, 0);
        InetAddress localAddr = NetworkUtils.numericToInetAddress(addr);
        Os.bind(fd, localAddr, port.intValue());
        String id = getFileDescriptorId(fd);
        sFileDescriptorHashMap.put(id, fd);
        return id;
    } catch (SocketException | ErrnoException e) {
        Log.e("IpSec: Failed to open socket " + e.toString());
    }
    return null;
}
#method_after
/*
     * The following APIs are used to open, close, send and receive data over Os.socket
     * This uses android.system.Os class and can be used for UDP and TCP traffic
     */
@Rpc(description = "Open socket")
public String openSocket(Integer domain, Integer type, String addr, Integer port) {
    try {
        FileDescriptor fd = Os.socket(domain, type, 0);
        InetAddress localAddr = NetworkUtils.numericToInetAddress(addr);
        Os.bind(fd, localAddr, port.intValue());
        String id = getFileDescriptorId(fd);
        sFileDescriptorHashMap.put(id, fd);
        return id;
    } catch (SocketException | ErrnoException e) {
        Log.e("IpSec: Failed to open socket " + e.toString());
    }
    return null;
}
#end_block

#method_before
@Rpc(description = "Send data to server")
public Boolean sendDataOverSocket(String remoteAddr, Integer remotePort, String message, String id) {
    byte[] data = null;
    FileDescriptor fd = sFileDescriptorHashMap.get(id);
    InetAddress remote = NetworkUtils.numericToInetAddress(remoteAddr);
    try {
        data = new String(message).getBytes(StandardCharsets.UTF_8);
        int bytes = Os.sendto(fd, data, 0, data.length, 0, remote, remotePort.intValue());
        Log.d("IpSec: Sent " + String.valueOf(bytes) + " bytes");
        return true;
    } catch (ErrnoException | SocketException e) {
        Log.e("IpSec: Sending data over socket failed " + e.toString());
    }
    return false;
}
#method_after
@Rpc(description = "Send data to server")
public Boolean sendDataOverSocket(String remoteAddr, Integer remotePort, String message, String id) {
    FileDescriptor fd = sFileDescriptorHashMap.get(id);
    InetAddress remote = NetworkUtils.numericToInetAddress(remoteAddr);
    try {
        byte[] data = new String(message).getBytes(StandardCharsets.UTF_8);
        int bytes = Os.sendto(fd, data, 0, data.length, 0, remote, remotePort.intValue());
        Log.d("IpSec: Sent " + String.valueOf(bytes) + " bytes");
        return true;
    } catch (ErrnoException | SocketException e) {
        Log.e("IpSec: Sending data over socket failed " + e.toString());
    }
    return false;
}
#end_block

#method_before
@Rpc(description = "Recv data on server")
public String recvDataOverSocket(String id) {
    byte[] data = new byte[2048];
    String returnData = null;
    FileDescriptor fd = sFileDescriptorHashMap.get(id);
    try {
        Os.read(fd, data, 0, data.length);
        returnData = new String(data, StandardCharsets.UTF_8);
    } catch (ErrnoException | InterruptedIOException e) {
        Log.e("IpSec: Receiving data over socket failed " + e.toString());
    }
    return returnData;
}
#method_after
@Rpc(description = "Recv data on server")
public String recvDataOverSocket(String id) {
    byte[] data = new byte[MAX_BUF_SZ];
    FileDescriptor fd = sFileDescriptorHashMap.get(id);
    try {
        Os.read(fd, data, 0, data.length);
        return new String(data, StandardCharsets.UTF_8);
    } catch (ErrnoException | InterruptedIOException e) {
        Log.e("IpSec: Receiving data over socket failed " + e.toString());
    }
    return null;
}
#end_block

#method_before
private void onPayloadApplicationComplete(int errorCode) {
    final String state = UpdateEngineErrorCodes.isUpdateSucceeded(errorCode) ? "SUCCESS" : "FAILURE";
    runOnUiThread(() -> {
        Log.i("UpdateEngine", "Completed - errorCode=" + UpdateEngineErrorCodes.getCodeName(errorCode) + "/" + errorCode + " " + state);
        Toast.makeText(this, "Update completed", Toast.LENGTH_LONG).show();
        setUiCompletion(errorCode);
        if (errorCode == UpdateEngineErrorCodes.UPDATED_BUT_NOT_ACTIVE) {
            // Show "Switch Slot" button if update was successfully applied.
            uiShowSwitchSlotInfo();
        }
    });
}
#method_after
private void onPayloadApplicationComplete(int errorCode) {
    final String state = UpdateEngineErrorCodes.isUpdateSucceeded(errorCode) ? "SUCCESS" : "FAILURE";
    runOnUiThread(() -> {
        Log.i("UpdateEngine", "Completed - errorCode=" + UpdateEngineErrorCodes.getCodeName(errorCode) + "/" + errorCode + " " + state);
        Toast.makeText(this, "Update completed", Toast.LENGTH_LONG).show();
        setUiCompletion(errorCode);
        if (errorCode == UpdateEngineErrorCodes.UPDATED_BUT_NOT_ACTIVE) {
            // if update was successfully applied.
            if (mManualSwitchSlotRequired.get()) {
                // Show "Switch Slot" button.
                uiShowSwitchSlotInfo();
            }
        }
    });
}
#end_block

#method_before
private void uiReset() {
    mTextViewBuild.setText(Build.DISPLAY);
    mSpinnerConfigs.setEnabled(true);
    mButtonReload.setEnabled(true);
    mButtonApplyConfig.setEnabled(true);
    mButtonStop.setEnabled(false);
    mButtonReset.setEnabled(false);
    mProgressBar.setProgress(0);
    mProgressBar.setEnabled(false);
    mProgressBar.setVisibility(ProgressBar.INVISIBLE);
    mTextViewStatus.setText(R.string.unknown);
    mTextViewCompletion.setText(R.string.unknown);
    uiHideRestartInfo();
}
#method_after
private void uiReset() {
    mTextViewBuild.setText(Build.DISPLAY);
    mSpinnerConfigs.setEnabled(true);
    mButtonReload.setEnabled(true);
    mButtonApplyConfig.setEnabled(true);
    mButtonStop.setEnabled(false);
    mButtonReset.setEnabled(false);
    mProgressBar.setProgress(0);
    mProgressBar.setEnabled(false);
    mProgressBar.setVisibility(ProgressBar.INVISIBLE);
    mTextViewStatus.setText(R.string.unknown);
    mTextViewCompletion.setText(R.string.unknown);
    uiHideSwitchSlotInfo();
}
#end_block

#method_before
private void applyUpdate(final UpdateConfig config) {
    List<String> extraProperties = new ArrayList<>();
    // Disable switch slot on reboot, which is enabled by default.
    // User will enable it manually by clicking "Switch Slot" button on the screen.
    extraProperties.add(UpdateEngineProperties.PROPERTY_DISABLE_SWITCH_SLOT_ON_REBOOT);
    if (config.getInstallType() == UpdateConfig.AB_INSTALL_TYPE_NON_STREAMING) {
        PayloadSpec payload;
        try {
            payload = PayloadSpecs.forNonStreaming(config.getUpdatePackageFile());
        } catch (IOException e) {
            Log.e(TAG, "Error creating payload spec", e);
            Toast.makeText(this, "Error creating payload spec", Toast.LENGTH_LONG).show();
            return;
        }
        updateEngineApplyPayload(payload, extraProperties);
    } else {
        Log.d(TAG, "Starting PrepareStreamingService");
        PrepareStreamingService.startService(this, config, (code, payloadSpec) -> {
            if (code == PrepareStreamingService.RESULT_CODE_SUCCESS) {
                extraProperties.add("USER_AGENT=" + HTTP_USER_AGENT);
                config.getStreamingMetadata().getAuthorization().ifPresent(s -> extraProperties.add("AUTHORIZATION=" + s));
                updateEngineApplyPayload(payloadSpec, extraProperties);
            } else {
                Log.e(TAG, "PrepareStreamingService failed, result code is " + code);
                Toast.makeText(MainActivity.this, "PrepareStreamingService failed, result code is " + code, Toast.LENGTH_LONG).show();
            }
        });
    }
}
#method_after
private void applyUpdate(final UpdateConfig config) {
    List<String> extraProperties = new ArrayList<>();
    if (!config.getAbConfig().getForceSwitchSlot()) {
        // Disable switch slot on reboot, which is enabled by default.
        // User will enable it manually by clicking "Switch Slot" button on the screen.
        extraProperties.add(UpdateEngineProperties.PROPERTY_DISABLE_SWITCH_SLOT_ON_REBOOT);
        mManualSwitchSlotRequired.set(true);
    } else {
        mManualSwitchSlotRequired.set(false);
    }
    if (config.getInstallType() == UpdateConfig.AB_INSTALL_TYPE_NON_STREAMING) {
        PayloadSpec payload;
        try {
            payload = PayloadSpecs.forNonStreaming(config.getUpdatePackageFile());
        } catch (IOException e) {
            Log.e(TAG, "Error creating payload spec", e);
            Toast.makeText(this, "Error creating payload spec", Toast.LENGTH_LONG).show();
            return;
        }
        updateEngineApplyPayload(payload, extraProperties);
    } else {
        Log.d(TAG, "Starting PrepareStreamingService");
        PrepareStreamingService.startService(this, config, (code, payloadSpec) -> {
            if (code == PrepareStreamingService.RESULT_CODE_SUCCESS) {
                extraProperties.add("USER_AGENT=" + HTTP_USER_AGENT);
                config.getStreamingMetadata().getAuthorization().ifPresent(s -> extraProperties.add("AUTHORIZATION=" + s));
                updateEngineApplyPayload(payloadSpec, extraProperties);
            } else {
                Log.e(TAG, "PrepareStreamingService failed, result code is " + code);
                Toast.makeText(MainActivity.this, "PrepareStreamingService failed, result code is " + code, Toast.LENGTH_LONG).show();
            }
        });
    }
}
#end_block

#method_before
private void setSwitchSlotOnReboot() {
    Log.d(TAG, "setSwitchSlotOnReboot invoked");
    List<String> extraProperties = new ArrayList<>();
    // PROPERTY_DISABLE_POST_INSTALL should be passed on to skip checksum verification.
    extraProperties.add(UpdateEngineProperties.PROPERTY_DISABLE_POST_INSTALL);
    // It sets property SWITCH_SLOT_ON_REBOOT=1 by default.
    // HTTP headers are not required, UpdateEngine is not expected to stream payload.
    updateEngineApplyPayload(mLastPayloadSpec, extraProperties);
}
#method_after
private void setSwitchSlotOnReboot() {
    Log.d(TAG, "setSwitchSlotOnReboot invoked");
    List<String> extraProperties = new ArrayList<>();
    // PROPERTY_SKIP_POST_INSTALL should be passed on to skip post-installation hooks.
    extraProperties.add(UpdateEngineProperties.PROPERTY_SKIP_POST_INSTALL);
    // It sets property SWITCH_SLOT_ON_REBOOT=1 by default.
    // HTTP headers are not required, UpdateEngine is not expected to stream payload.
    updateEngineApplyPayload(mLastPayloadSpec, extraProperties);
    uiHideSwitchSlotInfo();
}
#end_block

#method_before
// Unlike mPrefFragment or mPrefScreen, mPhone may change during lifecycle of CdmaOptions.
// For example, a new sim card is inserted. When that happens, we update CdmaOptions with new
protected void update(Phone phone) {
    boolean addAPNExpand = false;
    mPhone = phone;
    PersistableBundle carrierConfig = PhoneGlobals.getInstance().getCarrierConfigForSubId(mPhone.getSubId());
    // Some CDMA carriers want the APN settings.
    if ((mPhone.getPhoneType() == PhoneConstants.PHONE_TYPE_CDMA) && carrierConfig.getBoolean(CarrierConfigManager.KEY_SHOW_APN_SETTING_CDMA_BOOL)) {
        addAPNExpand = true;
    }
    boolean addCdmaSubscription = deviceSupportsNvAndRuim();
    // Read platform settings for carrier settings
    boolean addCarrierSettings = carrierConfig.getBoolean(CarrierConfigManager.KEY_CARRIER_SETTINGS_ENABLE_BOOL);
    mPrefScreen.addPreference(mButtonCdmaSystemSelect);
    mButtonCdmaSystemSelect.setEnabled(true);
    if (addAPNExpand) {
        mButtonAPNExpand.setOnPreferenceClickListener(new Preference.OnPreferenceClickListener() {

            @Override
            public boolean onPreferenceClick(Preference preference) {
                // We need to build the Intent by hand as the Preference Framework
                // does not allow to add an Intent with some extras into a Preference
                // XML file
                final Intent intent = new Intent(Settings.ACTION_APN_SETTINGS);
                // This will setup the Home and Search affordance
                intent.putExtra(":settings:show_fragment_as_subsetting", true);
                intent.putExtra("sub_id", mPhone.getSubId());
                mPrefFragment.startActivity(intent);
                return true;
            }
        });
        mPrefScreen.addPreference(mCategoryAPNExpand);
    } else {
        mPrefScreen.removePreference(mCategoryAPNExpand);
    }
    if (addCdmaSubscription) {
        log("Both NV and Ruim supported, ENABLE subscription type selection");
        mPrefScreen.addPreference(mButtonCdmaSubscription);
        mButtonCdmaSubscription.setEnabled(true);
    } else {
        log("Both NV and Ruim NOT supported, REMOVE subscription type selection");
        mPrefScreen.removePreference(mButtonCdmaSubscription);
    }
    if (addCarrierSettings) {
        mPrefScreen.addPreference(mButtonCarrierSettings);
    } else {
        mPrefScreen.removePreference(mButtonCarrierSettings);
    }
}
#method_after
// Unlike mPrefFragment or mPrefScreen, mPhone may change during lifecycle of CdmaOptions.
// For example, a new sim card is inserted. When that happens, we update CdmaOptions with new
protected void update(Phone phone) {
    mPhone = phone;
    PersistableBundle carrierConfig = PhoneGlobals.getInstance().getCarrierConfigForSubId(mPhone.getSubId());
    // Some CDMA carriers want the APN settings.
    boolean addAPNExpand = shouldAddApnExpandPreference(carrierConfig);
    boolean addCdmaSubscription = deviceSupportsNvAndRuim();
    // Read platform settings for carrier settings
    boolean addCarrierSettings = carrierConfig.getBoolean(CarrierConfigManager.KEY_CARRIER_SETTINGS_ENABLE_BOOL);
    mPrefScreen.addPreference(mButtonCdmaSystemSelect);
    mButtonCdmaSystemSelect.setEnabled(true);
    if (addAPNExpand) {
        log("update: addAPNExpand");
        mButtonAPNExpand.setDisabledByAdmin(MobileNetworkSettings.isDpcApnEnforced(mButtonAPNExpand.getContext()) ? RestrictedLockUtils.getDeviceOwner(mButtonAPNExpand.getContext()) : null);
        mButtonAPNExpand.setOnPreferenceClickListener(new Preference.OnPreferenceClickListener() {

            @Override
            public boolean onPreferenceClick(Preference preference) {
                MetricsLogger.action(mButtonAPNExpand.getContext(), MetricsEvent.ACTION_MOBILE_NETWORK_APN_SETTINGS);
                // We need to build the Intent by hand as the Preference Framework
                // does not allow to add an Intent with some extras into a Preference
                // XML file
                final Intent intent = new Intent(Settings.ACTION_APN_SETTINGS);
                // This will setup the Home and Search affordance
                intent.putExtra(":settings:show_fragment_as_subsetting", true);
                intent.putExtra("sub_id", mPhone.getSubId());
                mPrefFragment.startActivity(intent);
                return true;
            }
        });
        mPrefScreen.addPreference(mCategoryAPNExpand);
    } else {
        mPrefScreen.removePreference(mCategoryAPNExpand);
    }
    if (addCdmaSubscription) {
        log("Both NV and Ruim supported, ENABLE subscription type selection");
        mPrefScreen.addPreference(mButtonCdmaSubscription);
        mButtonCdmaSubscription.setEnabled(true);
    } else {
        log("Both NV and Ruim NOT supported, REMOVE subscription type selection");
        mPrefScreen.removePreference(mButtonCdmaSubscription);
    }
    if (addCarrierSettings) {
        mPrefScreen.addPreference(mButtonCarrierSettings);
    } else {
        mPrefScreen.removePreference(mButtonCarrierSettings);
    }
}
#end_block

#method_before
private RequestDispatcher getTestSuiteDispatcher(HttpServletRequest request, HttpServletResponse response) {
    String PLAN_RELEASE_JSP = "WEB-INF/jsp/show_suite_release.jsp";
    String testPlan = request.getParameter("plan");
    String testCategoryType = request.getParameter("testCategoryType") == null ? "1" : request.getParameter("testCategoryType");
    int page = request.getParameter("page") == null ? 1 : Integer.valueOf(request.getParameter("page"));
    String nextPageToken = request.getParameter("nextPageToken") == null ? "" : request.getParameter("nextPageToken");
    int testCategoryTypeNum = Integer.parseInt(testCategoryType);
    List testTypeList = new ArrayList();
    testTypeList.add(testCategoryTypeNum);
    switch(testCategoryTypeNum) {
        case 1:
            testTypeList.add(3);
            testTypeList.add(5);
            break;
        case 2:
            testTypeList.add(3);
            break;
        case 4:
            testTypeList.add(5);
            break;
        default:
            break;
    }
    com.googlecode.objectify.cmd.Query<TestSuiteResultEntity> testSuiteResultEntityQuery = ofy().load().type(TestSuiteResultEntity.class).filter("suitePlan", testPlan).filter("testType in", testTypeList).orderKey(true);
    Pagination<TestSuiteResultEntity> testSuiteResultEntityPagination = new Pagination(testSuiteResultEntityQuery, page, Pagination.DEFAULT_PAGE_SIZE, nextPageToken, pageCountTokenSet);
    String nextPageTokenPagination = testSuiteResultEntityPagination.getNextPageCountToken();
    if (!nextPageTokenPagination.trim().isEmpty()) {
        this.pageCountTokenSet.add(nextPageTokenPagination);
    }
    logger.log(Level.INFO, "pageCountTokenSet => " + pageCountTokenSet);
    logger.log(Level.INFO, "list => " + testSuiteResultEntityPagination.getList());
    logger.log(Level.INFO, "next page count token => " + testSuiteResultEntityPagination.getNextPageCountToken());
    logger.log(Level.INFO, "page min range => " + testSuiteResultEntityPagination.getMinPageRange());
    logger.log(Level.INFO, "page max range => " + testSuiteResultEntityPagination.getMaxPageRange());
    logger.log(Level.INFO, "page size => " + testSuiteResultEntityPagination.getPageSize());
    logger.log(Level.INFO, "total count => " + testSuiteResultEntityPagination.getTotalCount());
    request.setAttribute("plan", testPlan);
    request.setAttribute("page", page);
    request.setAttribute("testType", "suite");
    request.setAttribute("testCategoryType", testCategoryType);
    request.setAttribute("testSuiteResultEntityPagination", testSuiteResultEntityPagination);
    RequestDispatcher dispatcher = request.getRequestDispatcher(PLAN_RELEASE_JSP);
    return dispatcher;
}
#method_after
private RequestDispatcher getTestSuiteDispatcher(HttpServletRequest request, HttpServletResponse response) {
    String PLAN_RELEASE_JSP = "WEB-INF/jsp/show_suite_release.jsp";
    String testPlan = request.getParameter("plan");
    String testCategoryType = request.getParameter("testCategoryType") == null ? "1" : request.getParameter("testCategoryType");
    int page = request.getParameter("page") == null ? 1 : Integer.valueOf(request.getParameter("page"));
    String nextPageToken = request.getParameter("nextPageToken") == null ? "" : request.getParameter("nextPageToken");
    com.googlecode.objectify.cmd.Query<TestSuiteResultEntity> testSuiteResultEntityQuery = ofy().load().type(TestSuiteResultEntity.class).filter("suitePlan", testPlan).filter(this.getTestTypeFieldName(testCategoryType), true).orderKey(true);
    Pagination<TestSuiteResultEntity> testSuiteResultEntityPagination = new Pagination(testSuiteResultEntityQuery, page, Pagination.DEFAULT_PAGE_SIZE, nextPageToken, pageCountTokenSet);
    String nextPageTokenPagination = testSuiteResultEntityPagination.getNextPageCountToken();
    if (!nextPageTokenPagination.trim().isEmpty()) {
        this.pageCountTokenSet.add(nextPageTokenPagination);
    }
    logger.log(Level.INFO, "pageCountTokenSet => " + pageCountTokenSet);
    logger.log(Level.INFO, "list => " + testSuiteResultEntityPagination.getList());
    logger.log(Level.INFO, "next page count token => " + testSuiteResultEntityPagination.getNextPageCountToken());
    logger.log(Level.INFO, "page min range => " + testSuiteResultEntityPagination.getMinPageRange());
    logger.log(Level.INFO, "page max range => " + testSuiteResultEntityPagination.getMaxPageRange());
    logger.log(Level.INFO, "page size => " + testSuiteResultEntityPagination.getPageSize());
    logger.log(Level.INFO, "total count => " + testSuiteResultEntityPagination.getTotalCount());
    request.setAttribute("plan", testPlan);
    request.setAttribute("page", page);
    request.setAttribute("testType", "suite");
    request.setAttribute("testCategoryType", testCategoryType);
    request.setAttribute("testSuiteResultEntityPagination", testSuiteResultEntityPagination);
    RequestDispatcher dispatcher = request.getRequestDispatcher(PLAN_RELEASE_JSP);
    return dispatcher;
}
#end_block

#method_before
private int build() {
    // initialize vertex byte buffer for shape coordinates
    mSphereVertices = ByteBuffer.allocateDirect(mNumSegments * (mNumSegments + 1) * COORDS_PER_VERTEX * VERTEX_STRIDE * 2).order(ByteOrder.nativeOrder()).asFloatBuffer();
    mIndices = ByteBuffer.allocateDirect(mNumSegments * (mNumSegments + 2) * 2 * 4).order(ByteOrder.nativeOrder()).asIntBuffer();
    /*
         * x = r * sin(phi) * cos(theta)
         * y = r * sin(phi) * sin(theta)
         * z = r * cos(phi)
         */
    double dTheta = 2 * Math.PI / mNumSegments;
    double dPhi = Math.PI / mNumSegments;
    int points = 0;
    boolean firstLoop = true;
    double epsilon = 1e-10;
    for (double phi = -(Math.PI); phi <= 0 + epsilon; phi += dPhi) {
        // for each stage calculating the slices
        for (double theta = 0.0; theta < (Math.PI * 2) - epsilon; theta += dTheta) {
            mSphereVertices.put((float) (mRadius * Math.sin(phi) * Math.cos(theta)));
            mSphereVertices.put((float) (mRadius * Math.sin(phi) * Math.sin(theta)));
            mSphereVertices.put((float) (mRadius * Math.cos(phi)));
            if (!firstLoop) {
                mIndices.put(points - mNumSegments);
                mIndices.put(points);
                mNumIndices += 2;
            }
            points++;
        }
        if (!firstLoop) {
            // Finish off layer
            mIndices.put(points - 2 * mNumSegments);
            mIndices.put(points - mNumSegments);
            mNumIndices += 2;
        }
        firstLoop = false;
    }
    StringBuilder sb = new StringBuilder();
    for (int i = 0; i < mNumIndices; i++) {
        sb.append(mIndices.get(i));
        sb.append(", ");
    }
    mIndices.position(0);
    mSphereVertices.position(0);
    return points;
}
#method_after
private int build() {
    // initialize vertex byte buffer for shape coordinates
    mSphereVertices = ByteBuffer.allocateDirect(mNumSegments * (mNumSegments + 1) * COORDS_PER_VERTEX * VERTEX_STRIDE * 2).order(ByteOrder.nativeOrder()).asFloatBuffer();
    mIndices = ByteBuffer.allocateDirect(mNumSegments * (mNumSegments + 2) * 2 * 4).order(ByteOrder.nativeOrder()).asIntBuffer();
    /*
         * x = r * sin(phi) * cos(theta)
         * y = r * sin(phi) * sin(theta)
         * z = r * cos(phi)
         */
    double dTheta = 2 * Math.PI / mNumSegments;
    double dPhi = Math.PI / mNumSegments;
    int points = 0;
    boolean firstLoop = true;
    double epsilon = 1e-10;
    for (double phi = -(Math.PI); phi <= 0 + epsilon; phi += dPhi) {
        // for each stage calculating the slices
        for (double theta = 0.0; theta < (Math.PI * 2) - epsilon; theta += dTheta) {
            mSphereVertices.put((float) (mRadius * Math.sin(phi) * Math.cos(theta)));
            mSphereVertices.put((float) (mRadius * Math.sin(phi) * Math.sin(theta)));
            mSphereVertices.put((float) (mRadius * Math.cos(phi)));
            if (!firstLoop) {
                mIndices.put(points - mNumSegments);
                mIndices.put(points);
                mNumIndices += 2;
            }
            points++;
        }
        if (!firstLoop) {
            // Finish off layer
            mIndices.put(points - 2 * mNumSegments);
            mIndices.put(points - mNumSegments);
            mNumIndices += 2;
        }
        firstLoop = false;
    }
    mIndices.position(0);
    mSphereVertices.position(0);
    return points;
}
#end_block

#method_before
private void commandLineReport(String reportName, String command) {
    System.err.println(reportName + ":");
    Runtime rt = Runtime.getRuntime();
    Writer logOutput = null;
    try {
        // Process must be fully qualified here because android.os.Process
        // is used elsewhere
        java.lang.Process p = Runtime.getRuntime().exec(command);
        if (mRequestBugreport) {
            logOutput = new BufferedWriter(new FileWriter(new File(Environment.getLegacyExternalStorageDirectory(), reportName), true));
        }
        // pipe everything from process stdout -> System.err
        InputStream inStream = p.getInputStream();
        InputStreamReader inReader = new InputStreamReader(inStream);
        BufferedReader inBuffer = new BufferedReader(inReader);
        String s;
        while ((s = inBuffer.readLine()) != null) {
            if (mRequestBugreport && logOutput != null) {
                try {
                    // When no space left on the device the write will
                    // occurs an I/O exception, so we needed to catch it
                    // and continue to read the data of the sync pipe to
                    // aviod the bugreport hang forever.
                    logOutput.write(s);
                    logOutput.write("\n");
                } catch (IOException e) {
                    while (inBuffer.readLine() != null) {
                    }
                    System.err.println(e.toString());
                    break;
                }
            } else {
                System.err.println(s);
            }
        }
        int status = p.waitFor();
        System.err.println("// " + reportName + " status was " + status);
        if (logOutput != null) {
            logOutput.close();
        }
    } catch (Exception e) {
        System.err.println("// Exception from " + reportName + ":");
        System.err.println(e.toString());
    }
}
#method_after
private void commandLineReport(String reportName, String command) {
    System.err.println(reportName + ":");
    Runtime rt = Runtime.getRuntime();
    Writer logOutput = null;
    try {
        // Process must be fully qualified here because android.os.Process
        // is used elsewhere
        java.lang.Process p = Runtime.getRuntime().exec(command);
        if (mRequestBugreport) {
            logOutput = new BufferedWriter(new FileWriter(new File(Environment.getLegacyExternalStorageDirectory(), reportName), true));
        }
        // pipe everything from process stdout -> System.err
        InputStream inStream = p.getInputStream();
        InputStreamReader inReader = new InputStreamReader(inStream);
        BufferedReader inBuffer = new BufferedReader(inReader);
        String s;
        while ((s = inBuffer.readLine()) != null) {
            if (mRequestBugreport) {
                try {
                    // When no space left on the device the write will
                    // occurs an I/O exception, so we needed to catch it
                    // and continue to read the data of the sync pipe to
                    // aviod the bugreport hang forever.
                    logOutput.write(s);
                    logOutput.write("\n");
                } catch (IOException e) {
                    while (inBuffer.readLine() != null) {
                    }
                    System.err.println(e.toString());
                    break;
                }
            } else {
                System.err.println(s);
            }
        }
        int status = p.waitFor();
        System.err.println("// " + reportName + " status was " + status);
        if (logOutput != null) {
            logOutput.close();
        }
    } catch (Exception e) {
        System.err.println("// Exception from " + reportName + ":");
        System.err.println(e.toString());
    }
}
#end_block

#method_before
@Override
public void handleMessage(Message msg) {
    switch(msg.what) {
        case MESSAGE_GET_NAME_AND_ADDRESS:
            if (DBG) {
                Slog.d(TAG, "MESSAGE_GET_NAME_AND_ADDRESS");
            }
            try {
                mBluetoothLock.writeLock().lock();
                if ((mBluetooth == null) && (!mBinding)) {
                    if (DBG) {
                        Slog.d(TAG, "Binding to service to get name and address");
                    }
                    mGetNameAddressOnly = true;
                    Message timeoutMsg = mHandler.obtainMessage(MESSAGE_TIMEOUT_BIND);
                    mHandler.sendMessageDelayed(timeoutMsg, TIMEOUT_BIND_MS);
                    Intent i = new Intent(IBluetooth.class.getName());
                    if (!doBind(i, mConnection, Context.BIND_AUTO_CREATE | Context.BIND_IMPORTANT, UserHandle.CURRENT)) {
                        mHandler.removeMessages(MESSAGE_TIMEOUT_BIND);
                    } else {
                        mBinding = true;
                    }
                } else if (mBluetooth != null) {
                    try {
                        storeNameAndAddress(mBluetooth.getName(), mBluetooth.getAddress());
                    } catch (RemoteException re) {
                        Slog.e(TAG, "Unable to grab names", re);
                    }
                    if (mGetNameAddressOnly && !mEnable) {
                        unbindAndFinish();
                    }
                    mGetNameAddressOnly = false;
                }
            } finally {
                mBluetoothLock.writeLock().unlock();
            }
            break;
        case MESSAGE_ENABLE:
            if (DBG) {
                Slog.d(TAG, "MESSAGE_ENABLE(" + msg.arg1 + "): mBluetooth = " + mBluetooth);
            }
            mHandler.removeMessages(MESSAGE_RESTART_BLUETOOTH_SERVICE);
            mEnable = true;
            // Use service interface to get the exact state
            try {
                mBluetoothLock.readLock().lock();
                if (mBluetooth != null) {
                    int state = mBluetooth.getState();
                    if (state == BluetoothAdapter.STATE_BLE_ON) {
                        Slog.w(TAG, "BT Enable in BLE_ON State, going to ON");
                        mBluetooth.onLeServiceUp();
                        persistBluetoothSetting(BLUETOOTH_ON_BLUETOOTH);
                        break;
                    }
                }
            } catch (RemoteException e) {
                Slog.e(TAG, "", e);
            } finally {
                mBluetoothLock.readLock().unlock();
            }
            mQuietEnable = (msg.arg1 == 1);
            if (mBluetooth == null) {
                handleEnable(mQuietEnable);
            } else {
                // 
                // We need to wait until transitioned to STATE_OFF and
                // the previous Bluetooth process has exited. The
                // waiting period has three components:
                // (a) Wait until the local state is STATE_OFF. This
                // is accomplished by "waitForOnOff(false, true)".
                // (b) Wait until the STATE_OFF state is updated to
                // all components.
                // (c) Wait until the Bluetooth process exits, and
                // ActivityManager detects it.
                // The waiting for (b) and (c) is accomplished by
                // delaying the MESSAGE_RESTART_BLUETOOTH_SERVICE
                // message. On slower devices, that delay needs to be
                // on the order of (2 * SERVICE_RESTART_TIME_MS).
                // 
                waitForOnOff(false, true);
                Message restartMsg = mHandler.obtainMessage(MESSAGE_RESTART_BLUETOOTH_SERVICE);
                mHandler.sendMessageDelayed(restartMsg, 2 * SERVICE_RESTART_TIME_MS);
            }
            break;
        case MESSAGE_DISABLE:
            if (DBG) {
                Slog.d(TAG, "MESSAGE_DISABLE: mBluetooth = " + mBluetooth);
            }
            mHandler.removeMessages(MESSAGE_RESTART_BLUETOOTH_SERVICE);
            if (mEnable && mBluetooth != null) {
                waitForOnOff(true, false);
                mEnable = false;
                handleDisable();
                waitForOnOff(false, false);
            } else {
                mEnable = false;
                handleDisable();
            }
            break;
        case MESSAGE_RESTORE_USER_SETTING:
            if ((msg.arg1 == RESTORE_SETTING_TO_OFF) && mEnable) {
                if (DBG) {
                    Slog.d(TAG, "Restore Bluetooth state to disabled");
                }
                persistBluetoothSetting(BLUETOOTH_OFF);
                mEnableExternal = false;
                sendDisableMsg(BluetoothProtoEnums.ENABLE_DISABLE_REASON_RESTORE_USER_SETTING, mContext.getPackageName());
            } else if ((msg.arg1 == RESTORE_SETTING_TO_ON) && !mEnable) {
                if (DBG) {
                    Slog.d(TAG, "Restore Bluetooth state to enabled");
                }
                mQuietEnableExternal = false;
                mEnableExternal = true;
                // waive WRITE_SECURE_SETTINGS permission check
                sendEnableMsg(false, BluetoothProtoEnums.ENABLE_DISABLE_REASON_RESTORE_USER_SETTING, mContext.getPackageName());
            }
            break;
        case MESSAGE_REGISTER_ADAPTER:
            {
                IBluetoothManagerCallback callback = (IBluetoothManagerCallback) msg.obj;
                mCallbacks.register(callback);
                break;
            }
        case MESSAGE_UNREGISTER_ADAPTER:
            {
                IBluetoothManagerCallback callback = (IBluetoothManagerCallback) msg.obj;
                mCallbacks.unregister(callback);
                break;
            }
        case MESSAGE_REGISTER_STATE_CHANGE_CALLBACK:
            {
                IBluetoothStateChangeCallback callback = (IBluetoothStateChangeCallback) msg.obj;
                mStateChangeCallbacks.register(callback);
                break;
            }
        case MESSAGE_UNREGISTER_STATE_CHANGE_CALLBACK:
            {
                IBluetoothStateChangeCallback callback = (IBluetoothStateChangeCallback) msg.obj;
                mStateChangeCallbacks.unregister(callback);
                break;
            }
        case MESSAGE_ADD_PROXY_DELAYED:
            {
                ProfileServiceConnections psc = mProfileServices.get(msg.arg1);
                if (psc == null) {
                    break;
                }
                IBluetoothProfileServiceConnection proxy = (IBluetoothProfileServiceConnection) msg.obj;
                psc.addProxy(proxy);
                break;
            }
        case MESSAGE_BIND_PROFILE_SERVICE:
            {
                ProfileServiceConnections psc = (ProfileServiceConnections) msg.obj;
                removeMessages(MESSAGE_BIND_PROFILE_SERVICE, msg.obj);
                if (psc == null) {
                    break;
                }
                psc.bindService();
                break;
            }
        case MESSAGE_BLUETOOTH_SERVICE_CONNECTED:
            {
                if (DBG) {
                    Slog.d(TAG, "MESSAGE_BLUETOOTH_SERVICE_CONNECTED: " + msg.arg1);
                }
                IBinder service = (IBinder) msg.obj;
                try {
                    mBluetoothLock.writeLock().lock();
                    if (msg.arg1 == SERVICE_IBLUETOOTHGATT) {
                        mBluetoothGatt = IBluetoothGatt.Stub.asInterface(Binder.allowBlocking(service));
                        onBluetoothGattServiceUp();
                        break;
                    }
                    // else must be SERVICE_IBLUETOOTH
                    // Remove timeout
                    mHandler.removeMessages(MESSAGE_TIMEOUT_BIND);
                    mBinding = false;
                    mBluetoothBinder = service;
                    mBluetooth = IBluetooth.Stub.asInterface(Binder.allowBlocking(service));
                    if (!isNameAndAddressSet()) {
                        Message getMsg = mHandler.obtainMessage(MESSAGE_GET_NAME_AND_ADDRESS);
                        mHandler.sendMessage(getMsg);
                        if (mGetNameAddressOnly) {
                            return;
                        }
                    }
                    // Register callback object
                    try {
                        mBluetooth.registerCallback(mBluetoothCallback);
                    } catch (RemoteException re) {
                        Slog.e(TAG, "Unable to register BluetoothCallback", re);
                    }
                    // Inform BluetoothAdapter instances that service is up
                    sendBluetoothServiceUpCallback();
                    // Do enable request
                    try {
                        if (!mQuietEnable) {
                            if (!mBluetooth.enable()) {
                                Slog.e(TAG, "IBluetooth.enable() returned false");
                            }
                        } else {
                            if (!mBluetooth.enableNoAutoConnect()) {
                                Slog.e(TAG, "IBluetooth.enableNoAutoConnect() returned false");
                            }
                        }
                    } catch (RemoteException e) {
                        Slog.e(TAG, "Unable to call enable()", e);
                    }
                } finally {
                    mBluetoothLock.writeLock().unlock();
                }
                if (!mEnable) {
                    waitForOnOff(true, false);
                    handleDisable();
                    waitForOnOff(false, false);
                }
                break;
            }
        case MESSAGE_BLUETOOTH_STATE_CHANGE:
            {
                int prevState = msg.arg1;
                int newState = msg.arg2;
                if (DBG) {
                    Slog.d(TAG, "MESSAGE_BLUETOOTH_STATE_CHANGE: " + BluetoothAdapter.nameForState(prevState) + " > " + BluetoothAdapter.nameForState(newState));
                }
                mState = newState;
                bluetoothStateChangeHandler(prevState, newState);
                // unbind and rebind bluetooth service and enable bluetooth
                if ((prevState == BluetoothAdapter.STATE_BLE_TURNING_ON) && (newState == BluetoothAdapter.STATE_OFF) && (mBluetooth != null) && mEnable) {
                    recoverBluetoothServiceFromError(false);
                }
                if ((prevState == BluetoothAdapter.STATE_TURNING_ON) && (newState == BluetoothAdapter.STATE_BLE_ON) && (mBluetooth != null) && mEnable) {
                    recoverBluetoothServiceFromError(true);
                }
                // here.  This is a bit of a hack (b/29363429).
                if ((prevState == BluetoothAdapter.STATE_BLE_TURNING_OFF) && (newState == BluetoothAdapter.STATE_OFF)) {
                    if (mEnable) {
                        Slog.d(TAG, "Entering STATE_OFF but mEnabled is true; restarting.");
                        waitForOnOff(false, true);
                        Message restartMsg = mHandler.obtainMessage(MESSAGE_RESTART_BLUETOOTH_SERVICE);
                        mHandler.sendMessageDelayed(restartMsg, 2 * SERVICE_RESTART_TIME_MS);
                    }
                }
                if (newState == BluetoothAdapter.STATE_ON || newState == BluetoothAdapter.STATE_BLE_ON) {
                    // bluetooth is working, reset the counter
                    if (mErrorRecoveryRetryCounter != 0) {
                        Slog.w(TAG, "bluetooth is recovered from error");
                        mErrorRecoveryRetryCounter = 0;
                    }
                }
                break;
            }
        case MESSAGE_BLUETOOTH_SERVICE_DISCONNECTED:
            {
                Slog.e(TAG, "MESSAGE_BLUETOOTH_SERVICE_DISCONNECTED(" + msg.arg1 + ")");
                try {
                    mBluetoothLock.writeLock().lock();
                    if (msg.arg1 == SERVICE_IBLUETOOTH) {
                        // if service is unbinded already, do nothing and return
                        if (mBluetooth == null) {
                            break;
                        }
                        mBluetooth = null;
                    } else if (msg.arg1 == SERVICE_IBLUETOOTHGATT) {
                        mBluetoothGatt = null;
                        break;
                    } else {
                        Slog.e(TAG, "Unknown argument for service disconnect!");
                        break;
                    }
                } finally {
                    mBluetoothLock.writeLock().unlock();
                }
                // log the unexpected crash
                addCrashLog();
                addActiveLog(BluetoothProtoEnums.ENABLE_DISABLE_REASON_CRASH, mContext.getPackageName(), false);
                if (mEnable) {
                    mEnable = false;
                    // Send a Bluetooth Restart message
                    Message restartMsg = mHandler.obtainMessage(MESSAGE_RESTART_BLUETOOTH_SERVICE);
                    mHandler.sendMessageDelayed(restartMsg, SERVICE_RESTART_TIME_MS);
                }
                sendBluetoothServiceDownCallback();
                // the BT icon correctly
                if ((mState == BluetoothAdapter.STATE_TURNING_ON) || (mState == BluetoothAdapter.STATE_ON)) {
                    bluetoothStateChangeHandler(BluetoothAdapter.STATE_ON, BluetoothAdapter.STATE_TURNING_OFF);
                    mState = BluetoothAdapter.STATE_TURNING_OFF;
                }
                if (mState == BluetoothAdapter.STATE_TURNING_OFF) {
                    bluetoothStateChangeHandler(BluetoothAdapter.STATE_TURNING_OFF, BluetoothAdapter.STATE_OFF);
                }
                mHandler.removeMessages(MESSAGE_BLUETOOTH_STATE_CHANGE);
                mState = BluetoothAdapter.STATE_OFF;
                break;
            }
        case MESSAGE_RESTART_BLUETOOTH_SERVICE:
            {
                Slog.d(TAG, "MESSAGE_RESTART_BLUETOOTH_SERVICE");
                /* Enable without persisting the setting as
                     it doesnt change when IBluetooth
                     service restarts */
                mEnable = true;
                addActiveLog(BluetoothProtoEnums.ENABLE_DISABLE_REASON_RESTARTED, mContext.getPackageName(), true);
                handleEnable(mQuietEnable);
                break;
            }
        case MESSAGE_TIMEOUT_BIND:
            {
                Slog.e(TAG, "MESSAGE_TIMEOUT_BIND");
                mBluetoothLock.writeLock().lock();
                mBinding = false;
                mBluetoothLock.writeLock().unlock();
                break;
            }
        case MESSAGE_TIMEOUT_UNBIND:
            {
                Slog.e(TAG, "MESSAGE_TIMEOUT_UNBIND");
                mBluetoothLock.writeLock().lock();
                mUnbinding = false;
                mBluetoothLock.writeLock().unlock();
                break;
            }
        case MESSAGE_USER_SWITCHED:
            {
                if (DBG) {
                    Slog.d(TAG, "MESSAGE_USER_SWITCHED");
                }
                mHandler.removeMessages(MESSAGE_USER_SWITCHED);
                /* disable and enable BT when detect a user switch */
                if (mBluetooth != null && isEnabled()) {
                    try {
                        mBluetoothLock.readLock().lock();
                        if (mBluetooth != null) {
                            mBluetooth.unregisterCallback(mBluetoothCallback);
                        }
                    } catch (RemoteException re) {
                        Slog.e(TAG, "Unable to unregister", re);
                    } finally {
                        mBluetoothLock.readLock().unlock();
                    }
                    if (mState == BluetoothAdapter.STATE_TURNING_OFF) {
                        // MESSAGE_USER_SWITCHED happened right after MESSAGE_ENABLE
                        bluetoothStateChangeHandler(mState, BluetoothAdapter.STATE_OFF);
                        mState = BluetoothAdapter.STATE_OFF;
                    }
                    if (mState == BluetoothAdapter.STATE_OFF) {
                        bluetoothStateChangeHandler(mState, BluetoothAdapter.STATE_TURNING_ON);
                        mState = BluetoothAdapter.STATE_TURNING_ON;
                    }
                    waitForOnOff(true, false);
                    if (mState == BluetoothAdapter.STATE_TURNING_ON) {
                        bluetoothStateChangeHandler(mState, BluetoothAdapter.STATE_ON);
                    }
                    unbindAllBluetoothProfileServices();
                    // disable
                    addActiveLog(BluetoothProtoEnums.ENABLE_DISABLE_REASON_USER_SWITCH, mContext.getPackageName(), false);
                    handleDisable();
                    // Pbap service need receive STATE_TURNING_OFF intent to close
                    bluetoothStateChangeHandler(BluetoothAdapter.STATE_ON, BluetoothAdapter.STATE_TURNING_OFF);
                    boolean didDisableTimeout = !waitForOnOff(false, true);
                    bluetoothStateChangeHandler(BluetoothAdapter.STATE_TURNING_OFF, BluetoothAdapter.STATE_OFF);
                    sendBluetoothServiceDownCallback();
                    try {
                        mBluetoothLock.writeLock().lock();
                        if (mBluetooth != null) {
                            mBluetooth = null;
                            // Unbind
                            mContext.unbindService(mConnection);
                        }
                        mBluetoothGatt = null;
                    } finally {
                        mBluetoothLock.writeLock().unlock();
                    }
                    // 
                    if (didDisableTimeout) {
                        SystemClock.sleep(3000);
                    } else {
                        SystemClock.sleep(100);
                    }
                    mHandler.removeMessages(MESSAGE_BLUETOOTH_STATE_CHANGE);
                    mState = BluetoothAdapter.STATE_OFF;
                    // enable
                    addActiveLog(BluetoothProtoEnums.ENABLE_DISABLE_REASON_USER_SWITCH, mContext.getPackageName(), true);
                    // mEnable flag could have been reset on disableBLE. Reenable it.
                    mEnable = true;
                    handleEnable(mQuietEnable);
                } else if (mBinding || mBluetooth != null) {
                    Message userMsg = mHandler.obtainMessage(MESSAGE_USER_SWITCHED);
                    userMsg.arg2 = 1 + msg.arg2;
                    // if user is switched when service is binding retry after a delay
                    mHandler.sendMessageDelayed(userMsg, USER_SWITCHED_TIME_MS);
                    if (DBG) {
                        Slog.d(TAG, "Retry MESSAGE_USER_SWITCHED " + userMsg.arg2);
                    }
                }
                break;
            }
        case MESSAGE_USER_UNLOCKED:
            {
                if (DBG) {
                    Slog.d(TAG, "MESSAGE_USER_UNLOCKED");
                }
                mHandler.removeMessages(MESSAGE_USER_SWITCHED);
                if (mEnable && !mBinding && (mBluetooth == null)) {
                    // aware, so try binding again.
                    if (DBG) {
                        Slog.d(TAG, "Enabled but not bound; retrying after unlock");
                    }
                    handleEnable(mQuietEnable);
                }
            }
    }
}
#method_after
@Override
public void handleMessage(Message msg) {
    switch(msg.what) {
        case MESSAGE_GET_NAME_AND_ADDRESS:
            if (DBG) {
                Slog.d(TAG, "MESSAGE_GET_NAME_AND_ADDRESS");
            }
            try {
                mBluetoothLock.writeLock().lock();
                if ((mBluetooth == null) && (!mBinding)) {
                    if (DBG) {
                        Slog.d(TAG, "Binding to service to get name and address");
                    }
                    mGetNameAddressOnly = true;
                    Message timeoutMsg = mHandler.obtainMessage(MESSAGE_TIMEOUT_BIND);
                    mHandler.sendMessageDelayed(timeoutMsg, TIMEOUT_BIND_MS);
                    Intent i = new Intent(IBluetooth.class.getName());
                    if (!doBind(i, mConnection, Context.BIND_AUTO_CREATE | Context.BIND_IMPORTANT, UserHandle.CURRENT)) {
                        mHandler.removeMessages(MESSAGE_TIMEOUT_BIND);
                    } else {
                        mBinding = true;
                    }
                } else if (mBluetooth != null) {
                    try {
                        storeNameAndAddress(mBluetooth.getName(), mBluetooth.getAddress());
                    } catch (RemoteException re) {
                        Slog.e(TAG, "Unable to grab names", re);
                    }
                    if (mGetNameAddressOnly && !mEnable) {
                        unbindAndFinish();
                    }
                    mGetNameAddressOnly = false;
                }
            } finally {
                mBluetoothLock.writeLock().unlock();
            }
            break;
        case MESSAGE_ENABLE:
            if (DBG) {
                Slog.d(TAG, "MESSAGE_ENABLE(" + msg.arg1 + "): mBluetooth = " + mBluetooth);
            }
            mHandler.removeMessages(MESSAGE_RESTART_BLUETOOTH_SERVICE);
            mEnable = true;
            // Use service interface to get the exact state
            try {
                mBluetoothLock.readLock().lock();
                if (mBluetooth != null) {
                    int state = mBluetooth.getState();
                    if (state == BluetoothAdapter.STATE_BLE_ON) {
                        Slog.w(TAG, "BT Enable in BLE_ON State, going to ON");
                        mBluetooth.onLeServiceUp();
                        persistBluetoothSetting(BLUETOOTH_ON_BLUETOOTH);
                        break;
                    }
                }
            } catch (RemoteException e) {
                Slog.e(TAG, "", e);
            } finally {
                mBluetoothLock.readLock().unlock();
            }
            mQuietEnable = (msg.arg1 == 1);
            if (mBluetooth == null) {
                handleEnable(mQuietEnable);
            } else {
                // 
                // We need to wait until transitioned to STATE_OFF and
                // the previous Bluetooth process has exited. The
                // waiting period has three components:
                // (a) Wait until the local state is STATE_OFF. This
                // is accomplished by "waitForOnOff(false, true)".
                // (b) Wait until the STATE_OFF state is updated to
                // all components.
                // (c) Wait until the Bluetooth process exits, and
                // ActivityManager detects it.
                // The waiting for (b) and (c) is accomplished by
                // delaying the MESSAGE_RESTART_BLUETOOTH_SERVICE
                // message. On slower devices, that delay needs to be
                // on the order of (2 * SERVICE_RESTART_TIME_MS).
                // 
                waitForOnOff(false, true);
                Message restartMsg = mHandler.obtainMessage(MESSAGE_RESTART_BLUETOOTH_SERVICE);
                mHandler.sendMessageDelayed(restartMsg, 2 * SERVICE_RESTART_TIME_MS);
            }
            break;
        case MESSAGE_DISABLE:
            if (DBG) {
                Slog.d(TAG, "MESSAGE_DISABLE: mBluetooth = " + mBluetooth);
            }
            mHandler.removeMessages(MESSAGE_RESTART_BLUETOOTH_SERVICE);
            if (mEnable && mBluetooth != null) {
                waitForOnOff(true, false);
                mEnable = false;
                handleDisable();
                waitForOnOff(false, false);
            } else {
                mEnable = false;
                handleDisable();
            }
            break;
        case MESSAGE_RESTORE_USER_SETTING:
            if ((msg.arg1 == RESTORE_SETTING_TO_OFF) && mEnable) {
                if (DBG) {
                    Slog.d(TAG, "Restore Bluetooth state to disabled");
                }
                persistBluetoothSetting(BLUETOOTH_OFF);
                mEnableExternal = false;
                sendDisableMsg(BluetoothProtoEnums.ENABLE_DISABLE_REASON_RESTORE_USER_SETTING, mContext.getPackageName());
            } else if ((msg.arg1 == RESTORE_SETTING_TO_ON) && !mEnable) {
                if (DBG) {
                    Slog.d(TAG, "Restore Bluetooth state to enabled");
                }
                mQuietEnableExternal = false;
                mEnableExternal = true;
                // waive WRITE_SECURE_SETTINGS permission check
                sendEnableMsg(false, BluetoothProtoEnums.ENABLE_DISABLE_REASON_RESTORE_USER_SETTING, mContext.getPackageName());
            }
            break;
        case MESSAGE_REGISTER_ADAPTER:
            {
                IBluetoothManagerCallback callback = (IBluetoothManagerCallback) msg.obj;
                mCallbacks.register(callback);
                break;
            }
        case MESSAGE_UNREGISTER_ADAPTER:
            {
                IBluetoothManagerCallback callback = (IBluetoothManagerCallback) msg.obj;
                mCallbacks.unregister(callback);
                break;
            }
        case MESSAGE_REGISTER_STATE_CHANGE_CALLBACK:
            {
                IBluetoothStateChangeCallback callback = (IBluetoothStateChangeCallback) msg.obj;
                mStateChangeCallbacks.register(callback);
                break;
            }
        case MESSAGE_UNREGISTER_STATE_CHANGE_CALLBACK:
            {
                IBluetoothStateChangeCallback callback = (IBluetoothStateChangeCallback) msg.obj;
                mStateChangeCallbacks.unregister(callback);
                break;
            }
        case MESSAGE_ADD_PROXY_DELAYED:
            {
                ProfileServiceConnections psc = mProfileServices.get(msg.arg1);
                if (psc == null) {
                    break;
                }
                IBluetoothProfileServiceConnection proxy = (IBluetoothProfileServiceConnection) msg.obj;
                psc.addProxy(proxy);
                break;
            }
        case MESSAGE_BIND_PROFILE_SERVICE:
            {
                ProfileServiceConnections psc = (ProfileServiceConnections) msg.obj;
                removeMessages(MESSAGE_BIND_PROFILE_SERVICE, msg.obj);
                if (psc == null) {
                    break;
                }
                psc.bindService();
                break;
            }
        case MESSAGE_BLUETOOTH_SERVICE_CONNECTED:
            {
                if (DBG) {
                    Slog.d(TAG, "MESSAGE_BLUETOOTH_SERVICE_CONNECTED: " + msg.arg1);
                }
                IBinder service = (IBinder) msg.obj;
                try {
                    mBluetoothLock.writeLock().lock();
                    if (msg.arg1 == SERVICE_IBLUETOOTHGATT) {
                        mBluetoothGatt = IBluetoothGatt.Stub.asInterface(Binder.allowBlocking(service));
                        continueFromBleOnState();
                        break;
                    }
                    // else must be SERVICE_IBLUETOOTH
                    // Remove timeout
                    mHandler.removeMessages(MESSAGE_TIMEOUT_BIND);
                    mBinding = false;
                    mBluetoothBinder = service;
                    mBluetooth = IBluetooth.Stub.asInterface(Binder.allowBlocking(service));
                    if (!isNameAndAddressSet()) {
                        Message getMsg = mHandler.obtainMessage(MESSAGE_GET_NAME_AND_ADDRESS);
                        mHandler.sendMessage(getMsg);
                        if (mGetNameAddressOnly) {
                            return;
                        }
                    }
                    // Register callback object
                    try {
                        mBluetooth.registerCallback(mBluetoothCallback);
                    } catch (RemoteException re) {
                        Slog.e(TAG, "Unable to register BluetoothCallback", re);
                    }
                    // Inform BluetoothAdapter instances that service is up
                    sendBluetoothServiceUpCallback();
                    // Do enable request
                    try {
                        if (!mQuietEnable) {
                            if (!mBluetooth.enable()) {
                                Slog.e(TAG, "IBluetooth.enable() returned false");
                            }
                        } else {
                            if (!mBluetooth.enableNoAutoConnect()) {
                                Slog.e(TAG, "IBluetooth.enableNoAutoConnect() returned false");
                            }
                        }
                    } catch (RemoteException e) {
                        Slog.e(TAG, "Unable to call enable()", e);
                    }
                } finally {
                    mBluetoothLock.writeLock().unlock();
                }
                if (!mEnable) {
                    waitForOnOff(true, false);
                    handleDisable();
                    waitForOnOff(false, false);
                }
                break;
            }
        case MESSAGE_BLUETOOTH_STATE_CHANGE:
            {
                int prevState = msg.arg1;
                int newState = msg.arg2;
                if (DBG) {
                    Slog.d(TAG, "MESSAGE_BLUETOOTH_STATE_CHANGE: " + BluetoothAdapter.nameForState(prevState) + " > " + BluetoothAdapter.nameForState(newState));
                }
                mState = newState;
                bluetoothStateChangeHandler(prevState, newState);
                // unbind and rebind bluetooth service and enable bluetooth
                if ((prevState == BluetoothAdapter.STATE_BLE_TURNING_ON) && (newState == BluetoothAdapter.STATE_OFF) && (mBluetooth != null) && mEnable) {
                    recoverBluetoothServiceFromError(false);
                }
                if ((prevState == BluetoothAdapter.STATE_TURNING_ON) && (newState == BluetoothAdapter.STATE_BLE_ON) && (mBluetooth != null) && mEnable) {
                    recoverBluetoothServiceFromError(true);
                }
                // here.  This is a bit of a hack (b/29363429).
                if ((prevState == BluetoothAdapter.STATE_BLE_TURNING_OFF) && (newState == BluetoothAdapter.STATE_OFF)) {
                    if (mEnable) {
                        Slog.d(TAG, "Entering STATE_OFF but mEnabled is true; restarting.");
                        waitForOnOff(false, true);
                        Message restartMsg = mHandler.obtainMessage(MESSAGE_RESTART_BLUETOOTH_SERVICE);
                        mHandler.sendMessageDelayed(restartMsg, 2 * SERVICE_RESTART_TIME_MS);
                    }
                }
                if (newState == BluetoothAdapter.STATE_ON || newState == BluetoothAdapter.STATE_BLE_ON) {
                    // bluetooth is working, reset the counter
                    if (mErrorRecoveryRetryCounter != 0) {
                        Slog.w(TAG, "bluetooth is recovered from error");
                        mErrorRecoveryRetryCounter = 0;
                    }
                }
                break;
            }
        case MESSAGE_BLUETOOTH_SERVICE_DISCONNECTED:
            {
                Slog.e(TAG, "MESSAGE_BLUETOOTH_SERVICE_DISCONNECTED(" + msg.arg1 + ")");
                try {
                    mBluetoothLock.writeLock().lock();
                    if (msg.arg1 == SERVICE_IBLUETOOTH) {
                        // if service is unbinded already, do nothing and return
                        if (mBluetooth == null) {
                            break;
                        }
                        mBluetooth = null;
                    } else if (msg.arg1 == SERVICE_IBLUETOOTHGATT) {
                        mBluetoothGatt = null;
                        break;
                    } else {
                        Slog.e(TAG, "Unknown argument for service disconnect!");
                        break;
                    }
                } finally {
                    mBluetoothLock.writeLock().unlock();
                }
                // log the unexpected crash
                addCrashLog();
                addActiveLog(BluetoothProtoEnums.ENABLE_DISABLE_REASON_CRASH, mContext.getPackageName(), false);
                if (mEnable) {
                    mEnable = false;
                    // Send a Bluetooth Restart message
                    Message restartMsg = mHandler.obtainMessage(MESSAGE_RESTART_BLUETOOTH_SERVICE);
                    mHandler.sendMessageDelayed(restartMsg, SERVICE_RESTART_TIME_MS);
                }
                sendBluetoothServiceDownCallback();
                // the BT icon correctly
                if ((mState == BluetoothAdapter.STATE_TURNING_ON) || (mState == BluetoothAdapter.STATE_ON)) {
                    bluetoothStateChangeHandler(BluetoothAdapter.STATE_ON, BluetoothAdapter.STATE_TURNING_OFF);
                    mState = BluetoothAdapter.STATE_TURNING_OFF;
                }
                if (mState == BluetoothAdapter.STATE_TURNING_OFF) {
                    bluetoothStateChangeHandler(BluetoothAdapter.STATE_TURNING_OFF, BluetoothAdapter.STATE_OFF);
                }
                mHandler.removeMessages(MESSAGE_BLUETOOTH_STATE_CHANGE);
                mState = BluetoothAdapter.STATE_OFF;
                break;
            }
        case MESSAGE_RESTART_BLUETOOTH_SERVICE:
            {
                Slog.d(TAG, "MESSAGE_RESTART_BLUETOOTH_SERVICE");
                /* Enable without persisting the setting as
                     it doesnt change when IBluetooth
                     service restarts */
                mEnable = true;
                addActiveLog(BluetoothProtoEnums.ENABLE_DISABLE_REASON_RESTARTED, mContext.getPackageName(), true);
                handleEnable(mQuietEnable);
                break;
            }
        case MESSAGE_TIMEOUT_BIND:
            {
                Slog.e(TAG, "MESSAGE_TIMEOUT_BIND");
                mBluetoothLock.writeLock().lock();
                mBinding = false;
                mBluetoothLock.writeLock().unlock();
                break;
            }
        case MESSAGE_TIMEOUT_UNBIND:
            {
                Slog.e(TAG, "MESSAGE_TIMEOUT_UNBIND");
                mBluetoothLock.writeLock().lock();
                mUnbinding = false;
                mBluetoothLock.writeLock().unlock();
                break;
            }
        case MESSAGE_USER_SWITCHED:
            {
                if (DBG) {
                    Slog.d(TAG, "MESSAGE_USER_SWITCHED");
                }
                mHandler.removeMessages(MESSAGE_USER_SWITCHED);
                /* disable and enable BT when detect a user switch */
                if (mBluetooth != null && isEnabled()) {
                    try {
                        mBluetoothLock.readLock().lock();
                        if (mBluetooth != null) {
                            mBluetooth.unregisterCallback(mBluetoothCallback);
                        }
                    } catch (RemoteException re) {
                        Slog.e(TAG, "Unable to unregister", re);
                    } finally {
                        mBluetoothLock.readLock().unlock();
                    }
                    if (mState == BluetoothAdapter.STATE_TURNING_OFF) {
                        // MESSAGE_USER_SWITCHED happened right after MESSAGE_ENABLE
                        bluetoothStateChangeHandler(mState, BluetoothAdapter.STATE_OFF);
                        mState = BluetoothAdapter.STATE_OFF;
                    }
                    if (mState == BluetoothAdapter.STATE_OFF) {
                        bluetoothStateChangeHandler(mState, BluetoothAdapter.STATE_TURNING_ON);
                        mState = BluetoothAdapter.STATE_TURNING_ON;
                    }
                    waitForOnOff(true, false);
                    if (mState == BluetoothAdapter.STATE_TURNING_ON) {
                        bluetoothStateChangeHandler(mState, BluetoothAdapter.STATE_ON);
                    }
                    unbindAllBluetoothProfileServices();
                    // disable
                    addActiveLog(BluetoothProtoEnums.ENABLE_DISABLE_REASON_USER_SWITCH, mContext.getPackageName(), false);
                    handleDisable();
                    // Pbap service need receive STATE_TURNING_OFF intent to close
                    bluetoothStateChangeHandler(BluetoothAdapter.STATE_ON, BluetoothAdapter.STATE_TURNING_OFF);
                    boolean didDisableTimeout = !waitForOnOff(false, true);
                    bluetoothStateChangeHandler(BluetoothAdapter.STATE_TURNING_OFF, BluetoothAdapter.STATE_OFF);
                    sendBluetoothServiceDownCallback();
                    try {
                        mBluetoothLock.writeLock().lock();
                        if (mBluetooth != null) {
                            mBluetooth = null;
                            // Unbind
                            mContext.unbindService(mConnection);
                        }
                        mBluetoothGatt = null;
                    } finally {
                        mBluetoothLock.writeLock().unlock();
                    }
                    // 
                    if (didDisableTimeout) {
                        SystemClock.sleep(3000);
                    } else {
                        SystemClock.sleep(100);
                    }
                    mHandler.removeMessages(MESSAGE_BLUETOOTH_STATE_CHANGE);
                    mState = BluetoothAdapter.STATE_OFF;
                    // enable
                    addActiveLog(BluetoothProtoEnums.ENABLE_DISABLE_REASON_USER_SWITCH, mContext.getPackageName(), true);
                    // mEnable flag could have been reset on disableBLE. Reenable it.
                    mEnable = true;
                    handleEnable(mQuietEnable);
                } else if (mBinding || mBluetooth != null) {
                    Message userMsg = mHandler.obtainMessage(MESSAGE_USER_SWITCHED);
                    userMsg.arg2 = 1 + msg.arg2;
                    // if user is switched when service is binding retry after a delay
                    mHandler.sendMessageDelayed(userMsg, USER_SWITCHED_TIME_MS);
                    if (DBG) {
                        Slog.d(TAG, "Retry MESSAGE_USER_SWITCHED " + userMsg.arg2);
                    }
                }
                break;
            }
        case MESSAGE_USER_UNLOCKED:
            {
                if (DBG) {
                    Slog.d(TAG, "MESSAGE_USER_UNLOCKED");
                }
                mHandler.removeMessages(MESSAGE_USER_SWITCHED);
                if (mEnable && !mBinding && (mBluetooth == null)) {
                    // aware, so try binding again.
                    if (DBG) {
                        Slog.d(TAG, "Enabled but not bound; retrying after unlock");
                    }
                    handleEnable(mQuietEnable);
                }
            }
    }
}
#end_block

#method_before
private void bluetoothStateChangeHandler(int prevState, int newState) {
    boolean isStandardBroadcast = true;
    if (prevState == newState) {
        // No change. Nothing to do.
        return;
    }
    // Notify all proxy objects first of adapter state change
    if (newState == BluetoothAdapter.STATE_BLE_ON || newState == BluetoothAdapter.STATE_OFF) {
        boolean intermediate_off = (prevState == BluetoothAdapter.STATE_TURNING_OFF && newState == BluetoothAdapter.STATE_BLE_ON);
        if (newState == BluetoothAdapter.STATE_OFF) {
            // If Bluetooth is off, send service down event to proxy objects, and unbind
            if (DBG) {
                Slog.d(TAG, "Bluetooth is complete send Service Down");
            }
            sendBluetoothServiceDownCallback();
            unbindAndFinish();
            sendBleStateChanged(prevState, newState);
            // Don't broadcast as it has already been broadcast before
            isStandardBroadcast = false;
        } else if (!intermediate_off) {
            // connect to GattService
            if (DBG) {
                Slog.d(TAG, "Bluetooth is in LE only mode");
            }
            if (mBluetoothGatt != null || !mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_BLUETOOTH_LE)) {
                if (DBG) {
                    Slog.d(TAG, "Calling BluetoothGattServiceUp");
                }
                onBluetoothGattServiceUp();
            } else {
                if (DBG) {
                    Slog.d(TAG, "Binding Bluetooth GATT service");
                }
                Intent i = new Intent(IBluetoothGatt.class.getName());
                doBind(i, mConnection, Context.BIND_AUTO_CREATE | Context.BIND_IMPORTANT, UserHandle.CURRENT);
            }
            sendBleStateChanged(prevState, newState);
            // Don't broadcase this as std intent
            isStandardBroadcast = false;
        } else if (intermediate_off) {
            if (DBG) {
                Slog.d(TAG, "Intermediate off, back to LE only mode");
            }
            // For LE only mode, broadcast as is
            sendBleStateChanged(prevState, newState);
            // BT is OFF for general users
            sendBluetoothStateCallback(false);
            // Broadcast as STATE_OFF
            newState = BluetoothAdapter.STATE_OFF;
            sendBrEdrDownCallback();
        }
    } else if (newState == BluetoothAdapter.STATE_ON) {
        boolean isUp = (newState == BluetoothAdapter.STATE_ON);
        sendBluetoothStateCallback(isUp);
        sendBleStateChanged(prevState, newState);
    } else if (newState == BluetoothAdapter.STATE_BLE_TURNING_ON || newState == BluetoothAdapter.STATE_BLE_TURNING_OFF) {
        sendBleStateChanged(prevState, newState);
        isStandardBroadcast = false;
    } else if (newState == BluetoothAdapter.STATE_TURNING_ON || newState == BluetoothAdapter.STATE_TURNING_OFF) {
        sendBleStateChanged(prevState, newState);
    }
    if (isStandardBroadcast) {
        if (prevState == BluetoothAdapter.STATE_BLE_ON) {
            // Show prevState of BLE_ON as OFF to standard users
            prevState = BluetoothAdapter.STATE_OFF;
        }
        Intent intent = new Intent(BluetoothAdapter.ACTION_STATE_CHANGED);
        intent.putExtra(BluetoothAdapter.EXTRA_PREVIOUS_STATE, prevState);
        intent.putExtra(BluetoothAdapter.EXTRA_STATE, newState);
        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
        mContext.sendBroadcastAsUser(intent, UserHandle.ALL, BLUETOOTH_PERM);
    }
}
#method_after
private void bluetoothStateChangeHandler(int prevState, int newState) {
    boolean isStandardBroadcast = true;
    if (prevState == newState) {
        // No change. Nothing to do.
        return;
    }
    // Notify all proxy objects first of adapter state change
    if (newState == BluetoothAdapter.STATE_BLE_ON || newState == BluetoothAdapter.STATE_OFF) {
        boolean intermediate_off = (prevState == BluetoothAdapter.STATE_TURNING_OFF && newState == BluetoothAdapter.STATE_BLE_ON);
        if (newState == BluetoothAdapter.STATE_OFF) {
            // If Bluetooth is off, send service down event to proxy objects, and unbind
            if (DBG) {
                Slog.d(TAG, "Bluetooth is complete send Service Down");
            }
            sendBluetoothServiceDownCallback();
            unbindAndFinish();
            sendBleStateChanged(prevState, newState);
            // Don't broadcast as it has already been broadcast before
            isStandardBroadcast = false;
        } else if (!intermediate_off) {
            // connect to GattService
            if (DBG) {
                Slog.d(TAG, "Bluetooth is in LE only mode");
            }
            if (mBluetoothGatt != null || !mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_BLUETOOTH_LE)) {
                continueFromBleOnState();
            } else {
                if (DBG) {
                    Slog.d(TAG, "Binding Bluetooth GATT service");
                }
                Intent i = new Intent(IBluetoothGatt.class.getName());
                doBind(i, mConnection, Context.BIND_AUTO_CREATE | Context.BIND_IMPORTANT, UserHandle.CURRENT);
            }
            sendBleStateChanged(prevState, newState);
            // Don't broadcase this as std intent
            isStandardBroadcast = false;
        } else if (intermediate_off) {
            if (DBG) {
                Slog.d(TAG, "Intermediate off, back to LE only mode");
            }
            // For LE only mode, broadcast as is
            sendBleStateChanged(prevState, newState);
            // BT is OFF for general users
            sendBluetoothStateCallback(false);
            // Broadcast as STATE_OFF
            newState = BluetoothAdapter.STATE_OFF;
            sendBrEdrDownCallback();
        }
    } else if (newState == BluetoothAdapter.STATE_ON) {
        boolean isUp = (newState == BluetoothAdapter.STATE_ON);
        sendBluetoothStateCallback(isUp);
        sendBleStateChanged(prevState, newState);
    } else if (newState == BluetoothAdapter.STATE_BLE_TURNING_ON || newState == BluetoothAdapter.STATE_BLE_TURNING_OFF) {
        sendBleStateChanged(prevState, newState);
        isStandardBroadcast = false;
    } else if (newState == BluetoothAdapter.STATE_TURNING_ON || newState == BluetoothAdapter.STATE_TURNING_OFF) {
        sendBleStateChanged(prevState, newState);
    }
    if (isStandardBroadcast) {
        if (prevState == BluetoothAdapter.STATE_BLE_ON) {
            // Show prevState of BLE_ON as OFF to standard users
            prevState = BluetoothAdapter.STATE_OFF;
        }
        Intent intent = new Intent(BluetoothAdapter.ACTION_STATE_CHANGED);
        intent.putExtra(BluetoothAdapter.EXTRA_PREVIOUS_STATE, prevState);
        intent.putExtra(BluetoothAdapter.EXTRA_STATE, newState);
        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
        mContext.sendBroadcastAsUser(intent, UserHandle.ALL, BLUETOOTH_PERM);
    }
}
#end_block

#method_before
@Test
public void testDstMeansSummer() {
    // Ireland was the original example that made the IANA upstream data add a zone to the
    // tzdata rules where DST is in the Winter. "Irish Standard Time" is summer, so in the new
    // scheme DST is considered to be in the winter and the associated DST adjustment was
    // negative from the standard time. In the old scheme "Irish Standard Time" was modeled as
    // the DST name. Unfortunately, various users of formatting APIs assume standard and DST
    // times are consistent and (effectively) that "DST" means "summer". We likely cannot adopt
    // the concept of a winter DST without risking app compat issues.
    // For example, getDisplayName(boolean daylight) has always returned the winter time for
    // false, and the summer time for true. If we change this then it should be changed on a
    // major release boundary, with improved APIs (e.g. a version of getDisplayName() that takes
    // a time), existing API behavior made dependent on target API version, and after fixing any
    // platform code that makes incorrect assumptions about DST meaning "1 hour forward".
    final String timeZoneId = "Europe/Dublin";
    final Locale locale = Locale.UK;
    final long winterTimeMillis = 1445734800000L + /* 25 Oct 2015 01:00:00 GMT */
    TimeUnit.DAYS.toMillis(1);
    final String winterTimeName = "Greenwich Mean Time";
    final int winterOffsetRawMillis = 0;
    final int winterOffsetDstMillis = 0;
    final long summerTimeMillis = 1427590800000L + /* 29 Mar 2015 01:00:00 GMT */
    TimeUnit.DAYS.toMillis(1);
    final String summerTimeName = "Irish Standard Time";
    final int summerOffsetRawMillis = 0;
    final int summerOffsetDstMillis = (int) TimeUnit.HOURS.toMillis(1);
    // There is no common interface between java.util.TimeZone and android.icu.util.TimeZone
    // so the tests are for each are effectively duplicated.
    // java.util.TimeZone
    {
        java.util.TimeZone timeZone = java.util.TimeZone.getTimeZone(timeZoneId);
        assertTrue(timeZone.useDaylightTime());
        assertFalse(timeZone.inDaylightTime(new Date(winterTimeMillis)));
        assertTrue(timeZone.inDaylightTime(new Date(summerTimeMillis)));
        assertEquals(winterOffsetRawMillis + winterOffsetDstMillis, timeZone.getOffset(winterTimeMillis));
        assertEquals(summerOffsetRawMillis + summerOffsetDstMillis, timeZone.getOffset(summerTimeMillis));
        assertEquals(winterTimeName, timeZone.getDisplayName(false, /* daylight */
        java.util.TimeZone.LONG, locale));
        assertEquals(summerTimeName, timeZone.getDisplayName(true, /* daylight */
        java.util.TimeZone.LONG, locale));
    }
    // android.icu.util.TimeZone
    {
        android.icu.util.TimeZone timeZone = android.icu.util.TimeZone.getTimeZone(timeZoneId);
        assertTrue(timeZone.useDaylightTime());
        assertFalse(timeZone.inDaylightTime(new Date(winterTimeMillis)));
        assertTrue(timeZone.inDaylightTime(new Date(summerTimeMillis)));
        assertEquals(winterOffsetRawMillis + winterOffsetDstMillis, timeZone.getOffset(winterTimeMillis));
        assertEquals(summerOffsetRawMillis + summerOffsetDstMillis, timeZone.getOffset(summerTimeMillis));
        // These methods show the trouble we'd have if callers were to take the output from
        // inDaylightTime() and pass it to getDisplayName().
        assertEquals(winterTimeName, timeZone.getDisplayName(false, /* daylight */
        android.icu.util.TimeZone.LONG, locale));
        assertEquals(summerTimeName, timeZone.getDisplayName(true, /* daylight */
        android.icu.util.TimeZone.LONG, locale));
        // APIs not identical to java.util.TimeZone tested below.
        int[] offsets = new int[2];
        timeZone.getOffset(winterTimeMillis, false, /* local */
        offsets);
        assertEquals(winterOffsetRawMillis, offsets[0]);
        assertEquals(winterOffsetDstMillis, offsets[1]);
        timeZone.getOffset(summerTimeMillis, false, /* local */
        offsets);
        assertEquals(summerOffsetRawMillis, offsets[0]);
        assertEquals(summerOffsetDstMillis, offsets[1]);
    }
    // icu TimeZoneNames
    TimeZoneNames timeZoneNames = TimeZoneNames.getInstance(locale);
    // getDisplayName: date = winterTimeMillis
    assertEquals(winterTimeName, timeZoneNames.getDisplayName(timeZoneId, TimeZoneNames.NameType.LONG_STANDARD, winterTimeMillis));
    assertEquals(summerTimeName, timeZoneNames.getDisplayName(timeZoneId, TimeZoneNames.NameType.LONG_DAYLIGHT, winterTimeMillis));
    // getDisplayName: date = summerTimeMillis
    assertEquals(winterTimeName, timeZoneNames.getDisplayName(timeZoneId, TimeZoneNames.NameType.LONG_STANDARD, summerTimeMillis));
    assertEquals(summerTimeName, timeZoneNames.getDisplayName(timeZoneId, TimeZoneNames.NameType.LONG_DAYLIGHT, summerTimeMillis));
}
#method_after
@Test
public void testDstMeansSummer() {
    // Ireland was the original example that caused the default IANA upstream tzdata to contain
    // a zone where DST is in the Winter (since tzdata 2018e, though it was tried in 2018a
    // first). This change was made to historical and future transitions.
    // 
    // The upstream reasoning went like this: "Irish *Standard* Time" is summer, so the other
    // time must be the DST. So, DST is considered to be in the winter and the associated DST
    // adjustment is negative from the standard time. In the old scheme "Irish Standard Time" /
    // summer was just modeled as the DST in common with all other global time zones.
    // 
    // Unfortunately, various users of formatting APIs assume standard and DST times are
    // consistent and (effectively) that "DST" means "summer". We likely cannot adopt the
    // concept of a winter DST without risking app compat issues.
    // 
    // For example, getDisplayName(boolean daylight) has always returned the winter time for
    // false, and the summer time for true. If we change this then it should be changed on a
    // major release boundary, with improved APIs (e.g. a version of getDisplayName() that takes
    // a millis), existing API behavior made dependent on target API version, and after fixing
    // any platform code that makes incorrect assumptions about DST meaning "1 hour forward".
    final String timeZoneId = "Europe/Dublin";
    final Locale locale = Locale.UK;
    // 26 Oct 2015 01:00:00 GMT - one day after the start of "Greenwich Mean Time" in
    // Europe/Dublin in 2015. An arbitrary historical example of winter in Ireland.
    final long winterTimeMillis = 1445821200000L;
    final String winterTimeName = "Greenwich Mean Time";
    final int winterOffsetRawMillis = 0;
    final int winterOffsetDstMillis = 0;
    // 30 Mar 2015 01:00:00 GMT - one day after the start of "Irish Standard Time" in
    // Europe/Dublin in 2015. An arbitrary historical example of summer in Ireland.
    final long summerTimeMillis = 1427677200000L;
    final String summerTimeName = "Irish Standard Time";
    final int summerOffsetRawMillis = 0;
    final int summerOffsetDstMillis = (int) TimeUnit.HOURS.toMillis(1);
    // There is no common interface between java.util.TimeZone and android.icu.util.TimeZone
    // so the tests are for each are effectively duplicated.
    // java.util.TimeZone
    {
        java.util.TimeZone timeZone = java.util.TimeZone.getTimeZone(timeZoneId);
        assertTrue(timeZone.useDaylightTime());
        assertFalse(timeZone.inDaylightTime(new Date(winterTimeMillis)));
        assertTrue(timeZone.inDaylightTime(new Date(summerTimeMillis)));
        assertEquals(winterOffsetRawMillis + winterOffsetDstMillis, timeZone.getOffset(winterTimeMillis));
        assertEquals(summerOffsetRawMillis + summerOffsetDstMillis, timeZone.getOffset(summerTimeMillis));
        assertEquals(winterTimeName, timeZone.getDisplayName(false, /* daylight */
        java.util.TimeZone.LONG, locale));
        assertEquals(summerTimeName, timeZone.getDisplayName(true, /* daylight */
        java.util.TimeZone.LONG, locale));
    }
    // android.icu.util.TimeZone
    {
        android.icu.util.TimeZone timeZone = android.icu.util.TimeZone.getTimeZone(timeZoneId);
        assertTrue(timeZone.useDaylightTime());
        assertFalse(timeZone.inDaylightTime(new Date(winterTimeMillis)));
        assertTrue(timeZone.inDaylightTime(new Date(summerTimeMillis)));
        assertEquals(winterOffsetRawMillis + winterOffsetDstMillis, timeZone.getOffset(winterTimeMillis));
        assertEquals(summerOffsetRawMillis + summerOffsetDstMillis, timeZone.getOffset(summerTimeMillis));
        // These methods show the trouble we'd have if callers were to take the output from
        // inDaylightTime() and pass it to getDisplayName().
        assertEquals(winterTimeName, timeZone.getDisplayName(false, /* daylight */
        android.icu.util.TimeZone.LONG, locale));
        assertEquals(summerTimeName, timeZone.getDisplayName(true, /* daylight */
        android.icu.util.TimeZone.LONG, locale));
        // APIs not identical to java.util.TimeZone tested below.
        int[] offsets = new int[2];
        timeZone.getOffset(winterTimeMillis, false, /* local */
        offsets);
        assertEquals(winterOffsetRawMillis, offsets[0]);
        assertEquals(winterOffsetDstMillis, offsets[1]);
        timeZone.getOffset(summerTimeMillis, false, /* local */
        offsets);
        assertEquals(summerOffsetRawMillis, offsets[0]);
        assertEquals(summerOffsetDstMillis, offsets[1]);
    }
    // icu TimeZoneNames
    TimeZoneNames timeZoneNames = TimeZoneNames.getInstance(locale);
    // getDisplayName: date = winterTimeMillis
    assertEquals(winterTimeName, timeZoneNames.getDisplayName(timeZoneId, TimeZoneNames.NameType.LONG_STANDARD, winterTimeMillis));
    assertEquals(summerTimeName, timeZoneNames.getDisplayName(timeZoneId, TimeZoneNames.NameType.LONG_DAYLIGHT, winterTimeMillis));
    // getDisplayName: date = summerTimeMillis
    assertEquals(winterTimeName, timeZoneNames.getDisplayName(timeZoneId, TimeZoneNames.NameType.LONG_STANDARD, summerTimeMillis));
    assertEquals(summerTimeName, timeZoneNames.getDisplayName(timeZoneId, TimeZoneNames.NameType.LONG_DAYLIGHT, summerTimeMillis));
}
#end_block

#method_before
void add(String path, String value) {
    add(path, new String[] { value });
}
#method_after
public void add(String path, String... values) {
    List<String[]> list = rbPathToValues.get(path);
    if (list == null) {
        rbPathToValues.put(path, list = new ArrayList<String[]>(1));
    }
    list.add(normalizeValues(path, values));
}
#end_block

#method_before
@Deprecated
public ULocale getBestMatch(ULocale... ulocales) {
    return getBestMatch(LocalePriorityList.add(ulocales).build());
}
#method_after
public ULocale getBestMatch(ULocale ulocale) {
    return getBestMatchInternal(ulocale, null);
}
#end_block

#method_before
@SuppressWarnings("unchecked")
public MapComparator<K> add(K... data) {
    for (int i = 0; i < data.length; ++i) {
        add(data[i]);
    }
    return this;
}
#method_after
public MapComparator<K> add(K newObject) {
    Integer already = ordering.get(newObject);
    if (already == null) {
        if (locked)
            throw new UnsupportedOperationException("Attempt to modify locked object");
        ordering.put(newObject, new Integer(rankToName.size()));
        rankToName.add(newObject);
    }
    return this;
}
#end_block

#method_before
public ULocale getBestMatch(ULocale... locales) {
    return getBestMatch(new LinkedHashSet<>(Arrays.asList(locales)), null);
}
#method_after
public ULocale getBestMatch(ULocale ulocale) {
    return getBestMatch(ulocale, null);
}
#end_block

#method_before
public ULocale getBestMatch(ULocale desiredLocale, Output<ULocale> outputBestDesired) {
    int bestDistance = Integer.MAX_VALUE;
    ULocale bestDesiredLocale = null;
    Collection<ULocale> bestSupportedLocales = null;
    // quick check for exact match, with hack for und
    final LSR desiredLSR = desiredLocale.equals(UND_LOCALE) ? UND : LSR.fromMaximalized(desiredLocale);
    if (exactSupportedLocales.contains(desiredLocale)) {
        if (outputBestDesired != null) {
            outputBestDesired.value = desiredLocale;
        }
        return desiredLocale;
    }
    // quick check for maximized locale
    if (distanceOption == DistanceOption.NORMAL) {
        Collection<ULocale> found = supportedLanguages.get(desiredLSR);
        if (found != null) {
            // if we find one in the set, return first (lowest). We already know the exact one isn't there.
            if (outputBestDesired != null) {
                outputBestDesired.value = desiredLocale;
            }
            return found.iterator().next();
        }
    }
    for (final Entry<LSR, Collection<ULocale>> supportedLsrAndLocale : supportedLanguages.entrySet()) {
        int distance = localeDistance.distanceRaw(desiredLSR, supportedLsrAndLocale.getKey(), thresholdDistance, distanceOption);
        if (distance < bestDistance) {
            bestDistance = distance;
            bestDesiredLocale = desiredLocale;
            bestSupportedLocales = supportedLsrAndLocale.getValue();
            if (distance == 0) {
                break;
            }
        }
    }
    if (bestDistance >= thresholdDistance) {
        if (outputBestDesired != null) {
            outputBestDesired.value = null;
        }
        return defaultLanguage;
    }
    if (outputBestDesired != null) {
        outputBestDesired.value = bestDesiredLocale;
    }
    // pick exact match if there is one
    if (bestSupportedLocales.contains(bestDesiredLocale)) {
        return bestDesiredLocale;
    }
    // otherwise return first supported, combining variants and extensions from bestDesired
    return bestSupportedLocales.iterator().next();
}
#method_after
public ULocale getBestMatch(ULocale... locales) {
    return getBestMatch(new LinkedHashSet<>(Arrays.asList(locales)), null);
}
#end_block

#method_before
public UnicodeRelation<T> addAll(UnicodeSet keys, T value) {
    for (String key : keys) {
        add(key, value);
    }
    return this;
}
#method_after
public UnicodeRelation<T> addAll(UnicodeSet keys, T... values) {
    return addAll(keys, Arrays.asList(values));
}
#end_block

#method_before
public UnicodeRelation<T> removeAll(UnicodeSet keys, T value) {
    for (String key : keys) {
        remove(key, value);
    }
    return this;
}
#method_after
public UnicodeRelation<T> removeAll(UnicodeSet keys, T... values) {
    return removeAll(keys, Arrays.asList(values));
}
#end_block

#method_before
@SuppressWarnings("unchecked")
public MBuilder<K, V, M> put(V... values) {
    int v = 0;
    for (K key : keys) {
        put(key, values[v++]);
        if (v >= values.length) {
            v = 0;
        }
    }
    keys = null;
    return this;
}
#method_after
public MBuilder<K, V, M> put(V value) {
    for (K key : keys) {
        put(key, value);
    }
    keys = null;
    return this;
}
#end_block

#method_before
public MBuilder<K, V, M> put(Collection<? extends V> values) {
    Iterator<? extends V> vi = null;
    for (K key : keys) {
        if (vi == null || !vi.hasNext()) {
            vi = values.iterator();
        }
        put(key, vi.next());
    }
    return this;
}
#method_after
@SuppressWarnings("unchecked")
public MBuilder<K, V, M> put(V... values) {
    int v = 0;
    for (K key : keys) {
        put(key, values[v++]);
        if (v >= values.length) {
            v = 0;
        }
    }
    keys = null;
    return this;
}
#end_block

#method_before
private void addDexPath(String dexPath, File optimizedDirectory, boolean isTrusted) {
    final List<IOException> suppressedExceptionList = new ArrayList<IOException>();
    final Element[] newElements = makeDexElements(splitDexPath(dexPath), optimizedDirectory, suppressedExceptionList, definingContext, isTrusted);
    if (newElements != null && newElements.length > 0) {
        final Element[] oldElements = dexElements;
        dexElements = new Element[oldElements.length + newElements.length];
        System.arraycopy(oldElements, 0, dexElements, 0, oldElements.length);
        System.arraycopy(newElements, 0, dexElements, oldElements.length, newElements.length);
    }
    if (suppressedExceptionList.size() > 0) {
        final IOException[] newSuppressedExceptions = suppressedExceptionList.toArray(new IOException[suppressedExceptionList.size()]);
        if (dexElementsSuppressedExceptions != null) {
            final IOException[] oldSuppressedExceptions = dexElementsSuppressedExceptions;
            final int suppressedExceptionsLength = oldSuppressedExceptions.length + newSuppressedExceptions.length;
            dexElementsSuppressedExceptions = new IOException[suppressedExceptionsLength];
            System.arraycopy(oldSuppressedExceptions, 0, dexElementsSuppressedExceptions, 0, oldSuppressedExceptions.length);
            System.arraycopy(newSuppressedExceptions, 0, dexElementsSuppressedExceptions, oldSuppressedExceptions.length, newSuppressedExceptions.length);
        } else {
            dexElementsSuppressedExceptions = newSuppressedExceptions;
        }
    }
}
#method_after
public void addDexPath(String dexPath, File optimizedDirectory, boolean isTrusted) {
    final List<IOException> suppressedExceptionList = new ArrayList<IOException>();
    final Element[] newElements = makeDexElements(splitDexPath(dexPath), optimizedDirectory, suppressedExceptionList, definingContext, isTrusted);
    if (newElements != null && newElements.length > 0) {
        final Element[] oldElements = dexElements;
        dexElements = new Element[oldElements.length + newElements.length];
        System.arraycopy(oldElements, 0, dexElements, 0, oldElements.length);
        System.arraycopy(newElements, 0, dexElements, oldElements.length, newElements.length);
    }
    if (suppressedExceptionList.size() > 0) {
        final IOException[] newSuppressedExceptions = suppressedExceptionList.toArray(new IOException[suppressedExceptionList.size()]);
        if (dexElementsSuppressedExceptions != null) {
            final IOException[] oldSuppressedExceptions = dexElementsSuppressedExceptions;
            final int suppressedExceptionsLength = oldSuppressedExceptions.length + newSuppressedExceptions.length;
            dexElementsSuppressedExceptions = new IOException[suppressedExceptionsLength];
            System.arraycopy(oldSuppressedExceptions, 0, dexElementsSuppressedExceptions, 0, oldSuppressedExceptions.length);
            System.arraycopy(newSuppressedExceptions, 0, dexElementsSuppressedExceptions, oldSuppressedExceptions.length, newSuppressedExceptions.length);
        } else {
            dexElementsSuppressedExceptions = newSuppressedExceptions;
        }
    }
}
#end_block

#method_before
public void addDexPath(String dexPath) {
    addDexPath(dexPath, null, /*optimizedDirectory*/
    false);
}
#method_after
public void addDexPath(String dexPath) {
    addDexPath(dexPath, false);
}
#end_block

#method_before
private String getLabInfraIssueDescription() throws IOException {
    InputStream inputStream = servletContext.getResourceAsStream("/WEB-INF/buganizer/LabInfraIssue.tpl");
    String templateDescription = IOUtils.toString(inputStream, "UTF-8");
    Map<String, String> valuesMap = new HashMap<>();
    valuesMap.put("suiteBuildNumber", suiteBuildNumber);
    valuesMap.put("buildId", buildId);
    valuesMap.put("modulesDone", Integer.toString(modulesDone));
    valuesMap.put("modulesTotal", Integer.toString(modulesTotal));
    valuesMap.put("hostName", hostName);
    valuesMap.put("resultPath", resultPath);
    valuesMap.put("buildVendorFingerprint", buildVendorFingerprint);
    valuesMap.put("buildSystemFingerprint", buildSystemFingerprint);
    StrSubstitutor sub = new StrSubstitutor(valuesMap);
    String resolvedDescription = sub.replace(templateDescription);
    return resolvedDescription;
}
#method_after
private String getLabInfraIssueDescription() throws IOException {
    String bugTrackingSystem = systemConfigProp.getProperty("bug.tracking.system");
    String templateName = bugTrackingSystemProp.getProperty(bugTrackingSystem + ".labInfraIssue.template.name");
    InputStream inputStream = this.getClass().getClassLoader().getResourceAsStream("bug_tracking_system/" + bugTrackingSystem + "/" + templateName);
    String templateDescription = IOUtils.toString(inputStream, "UTF-8");
    Map<String, String> valuesMap = new HashMap<>();
    valuesMap.put("suiteBuildNumber", suiteBuildNumber);
    valuesMap.put("buildId", buildId);
    valuesMap.put("modulesDone", Integer.toString(modulesDone));
    valuesMap.put("modulesTotal", Integer.toString(modulesTotal));
    valuesMap.put("hostName", hostName);
    valuesMap.put("resultPath", resultPath);
    valuesMap.put("buildVendorFingerprint", buildVendorFingerprint);
    valuesMap.put("buildSystemFingerprint", buildSystemFingerprint);
    StrSubstitutor sub = new StrSubstitutor(valuesMap);
    String resolvedDescription = sub.replace(templateDescription);
    return resolvedDescription;
}
#end_block

#method_before
private String getCrashSecurityDescription() throws IOException {
    InputStream inputStream = servletContext.getResourceAsStream("/WEB-INF/buganizer/CrashSecurityVulnerabilityReports.tpl");
    String templateDescription = IOUtils.toString(inputStream, "UTF-8");
    Map<String, String> valuesMap = new HashMap<>();
    valuesMap.put("suiteBuildNumber", suiteBuildNumber);
    valuesMap.put("buildId", buildId);
    valuesMap.put("hostName", hostName);
    valuesMap.put("resultPath", resultPath);
    valuesMap.put("buildVendorFingerprint", buildVendorFingerprint);
    valuesMap.put("buildSystemFingerprint", buildSystemFingerprint);
    StrSubstitutor sub = new StrSubstitutor(valuesMap);
    String resolvedDescription = sub.replace(templateDescription);
    return resolvedDescription;
}
#method_after
private String getCrashSecurityDescription() throws IOException {
    String bugTrackingSystem = systemConfigProp.getProperty("bug.tracking.system");
    String templateName = bugTrackingSystemProp.getProperty(bugTrackingSystem + ".crashSecurity.template.name");
    InputStream inputStream = this.getClass().getClassLoader().getResourceAsStream("bug_tracking_system/" + bugTrackingSystem + "/" + templateName);
    String templateDescription = IOUtils.toString(inputStream, "UTF-8");
    Map<String, String> valuesMap = new HashMap<>();
    valuesMap.put("suiteBuildNumber", suiteBuildNumber);
    valuesMap.put("buildId", buildId);
    valuesMap.put("hostName", hostName);
    valuesMap.put("resultPath", resultPath);
    valuesMap.put("buildVendorFingerprint", buildVendorFingerprint);
    valuesMap.put("buildSystemFingerprint", buildSystemFingerprint);
    StrSubstitutor sub = new StrSubstitutor(valuesMap);
    String resolvedDescription = sub.replace(templateDescription);
    return resolvedDescription;
}
#end_block

#method_before
public String getBuganizerLink() throws IOException, ParseException, URISyntaxException {
    List<NameValuePair> qparams = new ArrayList<NameValuePair>();
    if (!this.bootSuccess || (this.passedTestCaseCount == 0 && this.failedTestCaseCount == 0)) {
        qparams.add(new BasicNameValuePair("component", "326430"));
        qparams.add(new BasicNameValuePair("template", "1073865"));
        qparams.add(new BasicNameValuePair("description", this.getLabInfraIssueDescription()));
    } else {
        qparams.add(new BasicNameValuePair("component", "163868"));
        qparams.add(new BasicNameValuePair("template", "661006"));
        qparams.add(new BasicNameValuePair("description", this.getCrashSecurityDescription()));
    }
    // https://buganizer.corp.google.com/issues/new?component=326430&template=1073865&description
    URI uri = URIUtils.createURI("https", "buganizer.corp.google.com", -1, "/issues/new", URLEncodedUtils.format(qparams, "UTF-8"), null);
    return uri.toString();
}
#method_after
public String getBuganizerLink() throws IOException, ParseException, URISyntaxException {
    String bugTrackingSystem = systemConfigProp.getProperty("bug.tracking.system");
    List<NameValuePair> qparams = new ArrayList<NameValuePair>();
    if (!this.bootSuccess || (this.passedTestCaseCount == 0 && this.failedTestCaseCount == 0)) {
        qparams.add(new BasicNameValuePair("component", this.bugTrackingSystemProp.getProperty(bugTrackingSystem + ".labInfraIssue.component.id")));
        qparams.add(new BasicNameValuePair("template", this.bugTrackingSystemProp.getProperty(bugTrackingSystem + ".labInfraIssue.template.id")));
        qparams.add(new BasicNameValuePair("description", this.getLabInfraIssueDescription()));
    } else {
        qparams.add(new BasicNameValuePair("component", this.bugTrackingSystemProp.getProperty(bugTrackingSystem + ".crashSecurity.component.id")));
        qparams.add(new BasicNameValuePair("template", this.bugTrackingSystemProp.getProperty(bugTrackingSystem + ".crashSecurity.template.id")));
        qparams.add(new BasicNameValuePair("description", this.getCrashSecurityDescription()));
    }
    URI uri = URIUtils.createURI(this.bugTrackingSystemProp.getProperty(bugTrackingSystem + ".uri.scheme"), this.bugTrackingSystemProp.getProperty(bugTrackingSystem + ".uri.host"), -1, this.bugTrackingSystemProp.getProperty(bugTrackingSystem + ".uri.path"), URLEncodedUtils.format(qparams, "UTF-8"), null);
    return uri.toString();
}
#end_block

#method_before
public void testHlsSampleAes_bbb_unmuxed_1500k() throws Exception {
    if (!MediaUtils.checkDecoder(MediaFormat.MIMETYPE_VIDEO_AVC)) {
        // skip
        return;
    }
    MediaCodecList mcl = new MediaCodecList(MediaCodecList.REGULAR_CODECS);
    for (MediaCodecInfo info : mcl.getCodecInfos()) {
        if (info.isEncoder() || info.getName().toLowerCase().startsWith("omx.google.")) {
            continue;
        }
        try {
            CodecCapabilities caps = info.getCapabilitiesForType(MediaFormat.MIMETYPE_VIDEO_AVC);
            VideoCapabilities vcaps = caps.getVideoCapabilities();
            if (vcaps.areSizeAndRateSupported(1920, 1080, 30)) {
                // Play stream for 60 seconds
                playLiveVideoTest("http://storage.googleapis.com/wvmedia/cenc/hls/sample_aes/" + "bbb_1080p_30fps_11min/unmuxed_1500k/prog_index.m3u8", 60 * 1000);
            }
        } catch (IllegalArgumentException e) {
        }
    }
}
#method_after
public void testHlsSampleAes_bbb_unmuxed_1500k() throws Exception {
    if (!MediaUtils.checkDecoder(MediaFormat.MIMETYPE_VIDEO_AVC)) {
        // skip
        return;
    }
    MediaCodecList mcl = new MediaCodecList(MediaCodecList.REGULAR_CODECS);
    for (MediaCodecInfo info : mcl.getCodecInfos()) {
        if (info.isEncoder() || info.getName().toLowerCase().startsWith("omx.google.")) {
            continue;
        }
        try {
            CodecCapabilities caps = info.getCapabilitiesForType(MediaFormat.MIMETYPE_VIDEO_AVC);
            VideoCapabilities vcaps = caps.getVideoCapabilities();
            // Play 1080p stream for 60 seconds if platform supports.
            if (vcaps.areSizeAndRateSupported(1920, 1080, 30)) {
                playLiveVideoTest("http://storage.googleapis.com/wvmedia/cenc/hls/sample_aes/" + "bbb_1080p_30fps_11min/unmuxed_1500k/prog_index.m3u8", 60 * 1000);
            }
        } catch (IllegalArgumentException e) {
        }
    }
}
#end_block

