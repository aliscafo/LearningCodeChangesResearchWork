186
#method_before
private void notifyTopOfAudioFocusStack(FocusStackEntry fse) {
    // notify the top of the stack in particular zone that it gained focus
    int tempZone;
    int tempmZone;
    if (fse.mZone != -1) {
        if (abandonAudioFocusZone != -1)
            tempZone = abandonAudioFocusZone;
        else
            tempZone = fse.mZone;
    } else
        tempZone = MultizoneAudioRouter.ZONE_CABIN;
    while (tempZone != 0) {
        FocusStackEntry fseZ = new FocusStackEntry();
        Iterator<FocusStackEntry> fseIterator = mFocusStack.iterator();
        while (fseIterator.hasNext()) {
            // Note Stack iterator iterates from bottom of stack
            FocusStackEntry fseZone = (FocusStackEntry) fseIterator.next();
            if (fseZone.mZone != -1)
                tempmZone = fseZone.mZone;
            else
                tempmZone = MultizoneAudioRouter.ZONE_CABIN;
            if ((tempmZone & tempZone) != 0) {
                Log.i(TAG, "Entry in same zone found and " + fseZone.mClientId + " needs to be notified. Zone: " + tempZone);
                fseZ = fseZone;
            }
        }
        if (!mFocusStack.empty() && (fseZ.mFocusDispatcher != null)) {
            int zoneValue = -1;
            if (canReassignAudioFocus()) {
                try {
                    int zoneFlag;
                    if (fseZ.mZone == -1) {
                        zoneFlag = -1;
                        zoneValue = -1;
                    } else {
                        zoneFlag = 1;
                        if (fse.mZone != -1) {
                            if (abandonAudioFocusZone != -1)
                                zoneValue = abandonAudioFocusZone & fseZ.mZone;
                            else
                                zoneValue = fse.mZone & fseZ.mZone;
                        } else
                            zoneValue = MultizoneAudioRouter.ZONE_CABIN;
                    }
                    fseZ.mFocusDispatcher.dispatchAudioFocusChange(AudioManager.AUDIOFOCUS_GAIN, fseZ.mClientId, zoneValue, zoneFlag);
                } catch (RemoteException e) {
                    Log.e(TAG, "Failure to signal gain of audio control focus due to " + e);
                    e.printStackTrace();
                }
            }
            tempZone &= ~zoneValue;
        } else {
            tempZone = 0;
        }
    }
}
#method_after
private void notifyTopOfAudioFocusStack(FocusStackEntry fse) {
    // notify the top of the stack in particular zone that it gained focus
    int tempZone;
    int tempmZone;
    if (fse.mZone != -1) {
        if (abandonAudioFocusZone != -1)
            tempZone = abandonAudioFocusZone;
        else
            tempZone = fse.mZone;
    } else
        tempZone = MultizoneAudioRouter.ZONE_CABIN;
    while (tempZone != 0) {
        FocusStackEntry fseZ = new FocusStackEntry();
        Iterator<FocusStackEntry> fseIterator = mFocusStack.iterator();
        while (fseIterator.hasNext()) {
            // Note Stack iterator iterates from bottom of stack
            FocusStackEntry fseZone = (FocusStackEntry) fseIterator.next();
            if (fseZone.mZone != -1)
                tempmZone = fseZone.mZone;
            else
                tempmZone = MultizoneAudioRouter.ZONE_CABIN;
            if ((tempmZone & tempZone) != 0) {
                fseZ = fseZone;
            }
        }
        if (!mFocusStack.empty() && (fseZ.mFocusDispatcher != null)) {
            Log.d(TAG, "Entry in same zone found and " + fseZ.mClientId + " needs to be notified. Zone: " + tempZone);
            int zoneValue = 0;
            if (canReassignAudioFocus()) {
                try {
                    int zoneFlag;
                    if (fseZ.mZone == -1) {
                        zoneFlag = -1;
                        zoneValue = MultizoneAudioRouter.ZONE_CABIN;
                    } else {
                        zoneFlag = 1;
                        if (fse.mZone != -1) {
                            if (abandonAudioFocusZone != -1)
                                zoneValue = abandonAudioFocusZone & fseZ.mZone;
                            else
                                zoneValue = fse.mZone & fseZ.mZone;
                        } else
                            zoneValue = MultizoneAudioRouter.ZONE_CABIN;
                    }
                    fseZ.mFocusDispatcher.dispatchAudioFocusChange(AudioManager.AUDIOFOCUS_GAIN, fseZ.mClientId, zoneValue, zoneFlag);
                } catch (RemoteException e) {
                    Log.e(TAG, "Failure to signal gain of audio control focus due to " + e);
                    e.printStackTrace();
                }
            }
            tempZone &= ~zoneValue;
        } else {
            tempZone = 0;
        }
    }
}
#end_block

#method_before
private void removeFocusStackEntry(String clientToRemove, boolean signal) {
    // is the current top of the focus stack abandoning focus? (because of request, not death)
    if (!mFocusStack.empty() && mFocusStack.peek().mClientId.equals(clientToRemove)) {
        // Log.i(TAG, "   removeFocusStackEntry() removing top of stack");
        FocusStackEntry fse = mFocusStack.pop();
        fse.unlinkToDeath();
        if (signal) {
            // notify the new top of the stack it gained focus
            notifyTopOfAudioFocusStack(fse);
            // there's a new top of the stack, let the remote control know
            synchronized (mRCStack) {
                checkUpdateRemoteControlDisplay_syncAfRcs(RC_INFO_ALL);
            }
        }
    } else {
        // focus is abandoned by a client that's not at the top of the stack,
        // no need to update focus.
        // (using an iterator on the stack so we can safely remove an entry after having
        // evaluated it, traversal order doesn't matter here)
        Iterator<FocusStackEntry> stackIterator = mFocusStack.iterator();
        while (stackIterator.hasNext()) {
            FocusStackEntry fse = (FocusStackEntry) stackIterator.next();
            if (fse.mClientId.equals(clientToRemove)) {
                Log.i(TAG, " AudioFocus  abandonAudioFocus(): removing entry for " + fse.mClientId);
                stackIterator.remove();
                fse.unlinkToDeath();
                if (signal)
                    notifyTopOfAudioFocusStack(fse);
            }
        }
    }
}
#method_after
private void removeFocusStackEntry(String clientToRemove, boolean signal) {
    // is the current top of the focus stack abandoning focus? (because of request, not death)
    if (!mFocusStack.empty() && mFocusStack.peek().mClientId.equals(clientToRemove)) {
        // Log.i(TAG, "   removeFocusStackEntry() removing top of stack");
        FocusStackEntry fse = mFocusStack.peek();
        boolean removeEntry = true;
        // otherwise, leave it and just update the zone.
        if (fse.mZone != -1 && abandonAudioFocusZone != -1) {
            if ((fse.mZone & ~abandonAudioFocusZone) != 0) {
                removeEntry = false;
                fse.mZone &= ~abandonAudioFocusZone;
            }
        }
        if (removeEntry == true) {
            Log.d(TAG, " AudioFocus  removeFocusStackEntry(): removing top of stack " + fse.mClientId);
            mFocusStack.pop();
            fse.unlinkToDeath();
        }
        if (signal) {
            // notify the new top of the stack it gained focus
            notifyTopOfAudioFocusStack(fse);
            // there's a new top of the stack, let the remote control know
            synchronized (mRCStack) {
                checkUpdateRemoteControlDisplay_syncAfRcs(RC_INFO_ALL);
            }
        }
    } else {
        // focus is abandoned by a client that's not at the top of the stack,
        // no need to update focus.
        // (using an iterator on the stack so we can safely remove an entry after having
        // evaluated it, traversal order doesn't matter here)
        Iterator<FocusStackEntry> stackIterator = mFocusStack.iterator();
        while (stackIterator.hasNext()) {
            boolean removeEntry = true;
            FocusStackEntry fse = (FocusStackEntry) stackIterator.next();
            if (fse.mClientId.equals(clientToRemove)) {
                // otherwise, leave it and just update the zone.
                if (fse.mZone != -1 && abandonAudioFocusZone != -1) {
                    if ((fse.mZone & ~abandonAudioFocusZone) != 0) {
                        removeEntry = false;
                        fse.mZone &= ~abandonAudioFocusZone;
                    }
                }
                if (removeEntry == true) {
                    Log.d(TAG, " AudioFocus  removeFocusStackEntry(): removing entry for " + fse.mClientId);
                    stackIterator.remove();
                    fse.unlinkToDeath();
                }
                if (signal)
                    notifyTopOfAudioFocusStack(fse);
            }
        }
    }
}
#end_block

#method_before
private void removeFocusStackEntryForClient(IBinder cb) {
    // is the owner of the audio focus part of the client to remove?
    boolean isTopOfStackForClientToRemove = !mFocusStack.isEmpty() && mFocusStack.peek().mSourceRef.equals(cb);
    // (using an iterator on the stack so we can safely remove an entry after having
    // evaluated it, traversal order doesn't matter here)
    Iterator<FocusStackEntry> stackIterator = mFocusStack.iterator();
    while (stackIterator.hasNext()) {
        FocusStackEntry fse = (FocusStackEntry) stackIterator.next();
        if (fse.mSourceRef.equals(cb)) {
            Log.i(TAG, " AudioFocus  abandonAudioFocus(): removing entry for " + fse.mClientId);
            stackIterator.remove();
        // the client just died, no need to unlink to its death
        }
    }
    if (isTopOfStackForClientToRemove) {
        // we removed an entry at the top of the stack:
        // notify the new top of the stack it gained focus.
        notifyTopOfAudioFocusStack();
        // there's a new top of the stack, let the remote control know
        synchronized (mRCStack) {
            checkUpdateRemoteControlDisplay_syncAfRcs(RC_INFO_ALL);
        }
    }
}
#method_after
private void removeFocusStackEntryForClient(IBinder cb) {
    // is the owner of the audio focus part of the client to remove?
    boolean isTopOfStackForClientToRemove = !mFocusStack.isEmpty() && mFocusStack.peek().mSourceRef.equals(cb);
    // (using an iterator on the stack so we can safely remove an entry after having
    // evaluated it, traversal order doesn't matter here)
    Iterator<FocusStackEntry> stackIterator = mFocusStack.iterator();
    while (stackIterator.hasNext()) {
        FocusStackEntry fse = (FocusStackEntry) stackIterator.next();
        if (fse.mSourceRef.equals(cb)) {
            Log.i(TAG, " AudioFocus  removeFocusStackEntryForClient(): removing entry for " + fse.mClientId);
            stackIterator.remove();
            // the client just died, no need to unlink to its death
            // notify the new top of the stack for each zone it gained focus.
            notifyTopOfAudioFocusStack(fse);
        }
    }
    if (isTopOfStackForClientToRemove) {
        // there's a new top of the stack, let the remote control know
        synchronized (mRCStack) {
            checkUpdateRemoteControlDisplay_syncAfRcs(RC_INFO_ALL);
        }
    }
}
#end_block

#method_before
public int requestAudioFocus(int mainStreamType, int focusChangeHint, IBinder cb, IAudioFocusDispatcher fd, String clientId, String callingPackageName, int zone) {
    Log.i(TAG, " AudioFocus  requestAudioFocus() from " + clientId);
    // we need a valid binder callback for clients
    if (!cb.pingBinder()) {
        Log.e(TAG, " AudioFocus DOA client for requestAudioFocus(), aborting.");
        return AudioManager.AUDIOFOCUS_REQUEST_FAILED;
    }
    synchronized (mAudioFocusLock) {
        if (!canReassignAudioFocus()) {
            return AudioManager.AUDIOFOCUS_REQUEST_FAILED;
        }
        // handle the potential premature death of the new holder of the focus
        // (premature death == death before abandoning focus)
        // Register for client death notification
        AudioFocusDeathHandler afdh = new AudioFocusDeathHandler(cb);
        try {
            cb.linkToDeath(afdh, 0);
        } catch (RemoteException e) {
            // client has already died!
            Log.w(TAG, "AudioFocus  requestAudioFocus() could not link to " + cb + " binder death");
            return AudioManager.AUDIOFOCUS_REQUEST_FAILED;
        }
        if (!mFocusStack.empty() && mFocusStack.peek().mClientId.equals(clientId)) {
            // hasn't changed, don't do anything
            if (mFocusStack.peek().mFocusChangeType == focusChangeHint) {
                // unlink death handler so it can be gc'ed.
                // linkToDeath() creates a JNI global reference preventing collection.
                cb.unlinkToDeath(afdh, 0);
                return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
            }
            // the reason for the audio focus request has changed: remove the current top of
            // stack and respond as if we had a new focus owner
            FocusStackEntry fse = mFocusStack.pop();
            fse.unlinkToDeath();
        }
        int tempZone;
        int tempmZone;
        if (zone != -1)
            tempZone = zone;
        else
            tempZone = MultizoneAudioRouter.ZONE_CABIN;
        while (tempZone != 0) {
            FocusStackEntry fseZ = new FocusStackEntry();
            Iterator<FocusStackEntry> fseIterator = mFocusStack.iterator();
            while (fseIterator.hasNext()) {
                // Note stack iterator iterates from bottom of stack
                FocusStackEntry fseZone = (FocusStackEntry) fseIterator.next();
                if (fseZone.mZone != -1)
                    tempmZone = fseZone.mZone;
                else
                    tempmZone = MultizoneAudioRouter.ZONE_CABIN;
                if ((tempmZone & tempZone) != 0) {
                    Log.i(TAG, "Entry in same zone found and " + fseZone.mClientId + " needs to be notified. Zone: " + tempZone);
                    fseZ = fseZone;
                }
            }
            // notify current top of stack in particular zone that it is losing focus
            if (!mFocusStack.empty() && (fseZ.mFocusDispatcher != null)) {
                int zoneValue = -1;
                try {
                    // 1 or -1:audioFocusListener needs zone info or not
                    int zoneFlag;
                    if (fseZ.mZone == -1) {
                        zoneFlag = -1;
                        zoneValue = -1;
                    } else {
                        zoneFlag = 1;
                        if (zone != -1)
                            zoneValue = zone & fseZ.mZone;
                        else
                            zoneValue = MultizoneAudioRouter.ZONE_CABIN;
                    }
                    fseZ.mFocusDispatcher.dispatchAudioFocusChange(// loss and gain codes are inverse of each other
                    -1 * focusChangeHint, fseZ.mClientId, zoneValue, zoneFlag);
                } catch (RemoteException e) {
                    Log.e(TAG, "Failure to signal loss of focus due to " + e);
                    e.printStackTrace();
                }
                tempZone &= ~zoneValue;
            } else {
                tempZone = 0;
            }
        }
        // focus requester might already be somewhere below in the stack, remove it
        removeFocusStackEntry(clientId, false);
        // push focus requester at the top of the audio focus stack
        mFocusStack.push(new FocusStackEntry(mainStreamType, focusChangeHint, fd, cb, clientId, afdh, callingPackageName, Binder.getCallingUid(), zone));
        // there's a new top of the stack, let the remote control know
        synchronized (mRCStack) {
            checkUpdateRemoteControlDisplay_syncAfRcs(RC_INFO_ALL);
        }
    }
    return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
}
#method_after
public int requestAudioFocus(int mainStreamType, int focusChangeHint, IBinder cb, IAudioFocusDispatcher fd, String clientId, String callingPackageName, int zone) {
    Log.i(TAG, " AudioFocus  requestAudioFocus() from " + clientId);
    // we need a valid binder callback for clients
    if (!cb.pingBinder()) {
        Log.e(TAG, " AudioFocus DOA client for requestAudioFocus(), aborting.");
        return AudioManager.AUDIOFOCUS_REQUEST_FAILED;
    }
    synchronized (mAudioFocusLock) {
        if (!canReassignAudioFocus()) {
            return AudioManager.AUDIOFOCUS_REQUEST_FAILED;
        }
        // handle the potential premature death of the new holder of the focus
        // (premature death == death before abandoning focus)
        // Register for client death notification
        AudioFocusDeathHandler afdh = new AudioFocusDeathHandler(cb);
        try {
            cb.linkToDeath(afdh, 0);
        } catch (RemoteException e) {
            // client has already died!
            Log.w(TAG, "AudioFocus  requestAudioFocus() could not link to " + cb + " binder death");
            return AudioManager.AUDIOFOCUS_REQUEST_FAILED;
        }
        if (!mFocusStack.empty() && mFocusStack.peek().mClientId.equals(clientId)) {
            // hasn't changed, don't do anything
            if (mFocusStack.peek().mFocusChangeType == focusChangeHint && mFocusStack.peek().mZone == zone) {
                // unlink death handler so it can be gc'ed.
                // linkToDeath() creates a JNI global reference preventing collection.
                cb.unlinkToDeath(afdh, 0);
                return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
            }
            // stack and respond as if we had a new focus owner
            if (mFocusStack.peek().mFocusChangeType != focusChangeHint) {
                FocusStackEntry fse = mFocusStack.pop();
                fse.unlinkToDeath();
            }
        }
        int tempZone;
        int tempmZone;
        if (zone != -1)
            tempZone = zone;
        else
            tempZone = MultizoneAudioRouter.ZONE_CABIN;
        while (tempZone != 0) {
            FocusStackEntry fseZ = new FocusStackEntry();
            Iterator<FocusStackEntry> fseIterator = mFocusStack.iterator();
            while (fseIterator.hasNext()) {
                // Note stack iterator iterates from bottom of stack
                FocusStackEntry fseZone = (FocusStackEntry) fseIterator.next();
                if (fseZone.mZone != -1)
                    tempmZone = fseZone.mZone;
                else
                    tempmZone = MultizoneAudioRouter.ZONE_CABIN;
                if ((tempmZone & tempZone) != 0) {
                    fseZ = fseZone;
                }
            }
            // notify current top of stack in particular zone that it is losing focus
            if (!mFocusStack.empty() && (fseZ.mFocusDispatcher != null)) {
                int zoneValue = 0;
                try {
                    // 1 or -1:audioFocusListener needs zone info or not
                    int zoneFlag;
                    if (fseZ.mZone == -1) {
                        zoneFlag = -1;
                        zoneValue = MultizoneAudioRouter.ZONE_CABIN;
                    } else {
                        zoneFlag = 1;
                        if (zone != -1)
                            zoneValue = zone & fseZ.mZone;
                        else
                            zoneValue = MultizoneAudioRouter.ZONE_CABIN;
                    }
                    // acquiring the focus has changed
                    if (!fseZ.mClientId.equals(clientId)) {
                        Log.d(TAG, "Entry in same zone found and " + fseZ.mClientId + " needs to be notified. Zone: " + tempZone);
                        fseZ.mFocusDispatcher.dispatchAudioFocusChange(// loss and gain codes are inverse of each other
                        -1 * focusChangeHint, fseZ.mClientId, zoneValue, zoneFlag);
                    } else if (fseZ.mFocusChangeType != focusChangeHint) {
                        // the reason for the audio focus request has changed: remove the entry from the
                        // stack and respond as if we had a new focus owner
                        mFocusStack.remove(fseZ);
                        fseZ.unlinkToDeath();
                        zoneValue = 0;
                    }
                } catch (RemoteException e) {
                    Log.e(TAG, "Failure to signal loss of focus due to " + e);
                    e.printStackTrace();
                }
                tempZone &= ~zoneValue;
            } else {
                tempZone = 0;
            }
        }
        // focus requester might already be somewhere below in the stack, remove it
        removeFocusStackEntry(clientId, false);
        Log.d(TAG, " AudioFocus  requestAudioFocus(): adding top of stack " + clientId);
        // push focus requester at the top of the audio focus stack
        mFocusStack.push(new FocusStackEntry(mainStreamType, focusChangeHint, fd, cb, clientId, afdh, callingPackageName, Binder.getCallingUid(), zone));
        // there's a new top of the stack, let the remote control know
        synchronized (mRCStack) {
            checkUpdateRemoteControlDisplay_syncAfRcs(RC_INFO_ALL);
        }
    }
    return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
}
#end_block

#method_before
public int abandonAudioFocus(IAudioFocusDispatcher fl, String clientId, int zone) {
    Log.i(TAG, " AudioFocus  abandonAudioFocus() from " + clientId);
    try {
        abandonAudioFocusZone = zone;
        // this will take care of notifying the new focus owner if needed
        synchronized (mAudioFocusLock) {
            removeFocusStackEntry(clientId, true);
        }
    } catch (java.util.ConcurrentModificationException cme) {
        // Catching this exception here is temporary. It is here just to prevent
        // a crash seen when the "Silent" notification is played. This is believed to be fixed
        // but this try catch block is left just to be safe.
        Log.e(TAG, "FATAL EXCEPTION AudioFocus  abandonAudioFocus() caused " + cme);
        cme.printStackTrace();
    }
    return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
}
#method_after
public int abandonAudioFocus(IAudioFocusDispatcher fl, String clientId, int zone) {
    Log.i(TAG, " AudioFocus  abandonAudioFocus() from " + clientId);
    try {
        abandonAudioFocusZone = zone;
        // this will take care of notifying the new focus owner if needed
        synchronized (mAudioFocusLock) {
            removeFocusStackEntry(clientId, true);
        }
        abandonAudioFocusZone = -1;
    } catch (java.util.ConcurrentModificationException cme) {
        // Catching this exception here is temporary. It is here just to prevent
        // a crash seen when the "Silent" notification is played. This is believed to be fixed
        // but this try catch block is left just to be safe.
        Log.e(TAG, "FATAL EXCEPTION AudioFocus  abandonAudioFocus() caused " + cme);
        cme.printStackTrace();
    }
    return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
}
#end_block

#method_before
private void onStorageStateChangedAsync(String path, String oldState, String newState) {
    if (DEBUG)
        Slog.i(TAG, String.format("Media {%s} state changed from {%s} -> {%s}", path, oldState, newState));
    if (newState.equals(Environment.MEDIA_SHARED)) {
        /*
             * Storage is now shared. Modify the UMS notification
             * for stopping UMS.
             */
        Intent intent = new Intent();
        intent.setClass(mContext, com.android.systemui.usb.UsbStorageActivity.class);
        PendingIntent pi = PendingIntent.getActivity(mContext, 0, intent, 0);
        setUsbStorageNotification(com.android.internal.R.string.usb_storage_stop_notification_title, com.android.internal.R.string.usb_storage_stop_notification_message, com.android.internal.R.drawable.stat_sys_warning, false, true, pi);
    } else if (newState.equals(Environment.MEDIA_CHECKING)) {
        /*
             * Storage is now checking. Update media notification and disable
             * UMS notification.
             */
        setMediaStorageNotification(com.android.internal.R.string.ext_media_checking_notification_title, com.android.internal.R.string.ext_media_checking_notification_message, com.android.internal.R.drawable.stat_notify_sdcard_prepare, true, false, null);
        updateUsbMassStorageNotification(false);
    } else if (newState.equals(Environment.MEDIA_MOUNTED)) {
        /*
             * Storage is now mounted. Dismiss any media notifications,
             * and enable UMS notification if connected.
             */
        setMediaStorageNotification(0, 0, 0, false, false, null);
        updateUsbMassStorageNotification(mUmsAvailable);
    } else if (newState.equals(Environment.MEDIA_UNMOUNTED)) {
        /*
             * Storage is now unmounted. We may have been unmounted
             * because the user is enabling/disabling UMS, in which case we don't
             * want to display the 'safe to unmount' notification.
             */
        if (!mStorageManager.isUsbMassStorageEnabled()) {
            if (oldState.equals(Environment.MEDIA_SHARED)) {
                /*
                     * The unmount was due to UMS being enabled. Dismiss any
                     * media notifications, and enable UMS notification if connected
                     */
                setMediaStorageNotification(0, 0, 0, false, false, null);
                updateUsbMassStorageNotification(mUmsAvailable);
            } else {
                /*
                     * Show safe to unmount media notification, and enable UMS
                     * notification if connected.
                     */
                if (Environment.isExternalStorageRemovable()) {
                    setMediaStorageNotification(com.android.internal.R.string.ext_media_safe_unmount_notification_title, com.android.internal.R.string.ext_media_safe_unmount_notification_message, com.android.internal.R.drawable.stat_notify_sdcard, true, true, null);
                } else {
                    // This device does not have removable storage, so
                    // don't tell the user they can remove it.
                    setMediaStorageNotification(0, 0, 0, false, false, null);
                }
                updateUsbMassStorageNotification(mUmsAvailable);
            }
        } else {
            /*
                 * The unmount was due to UMS being enabled. Dismiss any
                 * media notifications, and disable the UMS notification
                 */
            setMediaStorageNotification(0, 0, 0, false, false, null);
            updateUsbMassStorageNotification(false);
        }
    } else if (newState.equals(Environment.MEDIA_NOFS)) {
        /*
             * Storage has no filesystem. Show blank media notification,
             * and enable UMS notification if connected.
             */
        Intent intent = new Intent();
        intent.setClass(mContext, com.android.internal.app.ExternalMediaFormatActivity.class);
        intent.putExtra(StorageVolume.EXTRA_STORAGE_VOLUME, path);
        PendingIntent pi = PendingIntent.getActivity(mContext, 0, intent, 0);
        setMediaStorageNotification(com.android.internal.R.string.ext_media_nofs_notification_title, com.android.internal.R.string.ext_media_nofs_notification_message, com.android.internal.R.drawable.stat_notify_sdcard_usb, true, false, pi);
        updateUsbMassStorageNotification(mUmsAvailable);
    } else if (newState.equals(Environment.MEDIA_UNMOUNTABLE)) {
        /*
             * Storage is corrupt. Show corrupt media notification,
             * and enable UMS notification if connected.
             */
        Intent intent = new Intent();
        intent.setClass(mContext, com.android.internal.app.ExternalMediaFormatActivity.class);
        intent.putExtra(StorageVolume.EXTRA_STORAGE_VOLUME, path);
        PendingIntent pi = PendingIntent.getActivity(mContext, 0, intent, 0);
        setMediaStorageNotification(com.android.internal.R.string.ext_media_unmountable_notification_title, com.android.internal.R.string.ext_media_unmountable_notification_message, com.android.internal.R.drawable.stat_notify_sdcard_usb, true, false, pi);
        updateUsbMassStorageNotification(mUmsAvailable);
    } else if (newState.equals(Environment.MEDIA_REMOVED)) {
        /*
             * Storage has been removed. Show nomedia media notification,
             * and disable UMS notification regardless of connection state.
             */
        setMediaStorageNotification(com.android.internal.R.string.ext_media_nomedia_notification_title, com.android.internal.R.string.ext_media_nomedia_notification_message, com.android.internal.R.drawable.stat_notify_sdcard_usb, true, false, null);
        updateUsbMassStorageNotification(false);
    } else if (newState.equals(Environment.MEDIA_BAD_REMOVAL)) {
        /*
             * Storage has been removed unsafely. Show bad removal media notification,
             * and disable UMS notification regardless of connection state.
             */
        setMediaStorageNotification(com.android.internal.R.string.ext_media_badremoval_notification_title, com.android.internal.R.string.ext_media_badremoval_notification_message, com.android.internal.R.drawable.stat_sys_warning, true, true, null);
        updateUsbMassStorageNotification(false);
    } else {
        Slog.w(TAG, String.format("Ignoring unknown state {%s}", newState));
    }
}
#method_after
private void onStorageStateChangedAsync(String path, String oldState, String newState) {
    if (DEBUG)
        Slog.i(TAG, String.format("Media {%s} state changed from {%s} -> {%s}", path, oldState, newState));
    if (newState.equals(Environment.MEDIA_SHARED)) {
        /*
             * Storage is now shared. Modify the UMS notification
             * for stopping UMS.
             */
        Intent intent = new Intent();
        intent.setClass(mContext, com.android.systemui.usb.UsbStorageActivity.class);
        PendingIntent pi = PendingIntent.getActivity(mContext, 0, intent, 0);
        setUsbStorageNotification(com.android.internal.R.string.usb_storage_stop_notification_title, com.android.internal.R.string.usb_storage_stop_notification_message, com.android.internal.R.drawable.stat_sys_warning, false, true, pi);
    } else if (newState.equals(Environment.MEDIA_CHECKING)) {
        /*
             * Storage is now checking. Update media notification and disable
             * UMS notification.
             */
        setMediaStorageNotification(com.android.internal.R.string.ext_media_checking_notification_title, com.android.internal.R.string.ext_media_checking_notification_message, com.android.internal.R.drawable.stat_notify_sdcard_prepare, true, false, null);
        updateUsbMassStorageNotification(false);
    } else if (newState.equals(Environment.MEDIA_MOUNTED)) {
        /*
             * Storage is now mounted. Dismiss any media notifications,
             * and enable UMS notification if connected.
             */
        setMediaStorageNotification(0, 0, 0, false, false, null);
        updateUsbMassStorageNotification(mUmsAvailable);
    } else if (newState.equals(Environment.MEDIA_UNMOUNTED)) {
        /*
             * Storage is now unmounted. We may have been unmounted
             * because the user is enabling/disabling UMS, in which case we don't
             * want to display the 'safe to unmount' notification.
             */
        if (!mStorageManager.isUsbMassStorageEnabled()) {
            if (oldState.equals(Environment.MEDIA_SHARED)) {
                /*
                     * The unmount was due to UMS being enabled. Dismiss any
                     * media notifications, and enable UMS notification if connected
                     */
                setMediaStorageNotification(0, 0, 0, false, false, null);
                updateUsbMassStorageNotification(mUmsAvailable);
            } else {
                /*
                     * Show safe to unmount media notification, and enable UMS
                     * notification if connected.
                     */
                if (Environment.isExternalStorageRemovable()) {
                    setMediaStorageNotification(com.android.internal.R.string.ext_media_safe_unmount_notification_title, com.android.internal.R.string.ext_media_safe_unmount_notification_message, com.android.internal.R.drawable.stat_notify_sdcard, true, true, null);
                } else {
                    // This device does not have removable storage, so
                    // don't tell the user they can remove it.
                    setMediaStorageNotification(0, 0, 0, false, false, null);
                }
                updateUsbMassStorageNotification(mUmsAvailable);
            }
        } else {
            /*
                 * The unmount was due to UMS being enabled. Dismiss any
                 * media notifications, and disable the UMS notification
                 */
            setMediaStorageNotification(0, 0, 0, false, false, null);
            updateUsbMassStorageNotification(false);
        }
    } else if (newState.equals(Environment.MEDIA_NOFS)) {
        /*
             * Storage has no filesystem. Show blank media notification,
             * and enable UMS notification if connected.
             */
        Intent intent = new Intent();
        intent.setClass(mContext, com.android.internal.app.ExternalMediaFormatActivity.class);
        if ("true".equals(System.getProperty("omap.enhancement"))) {
            intent.putExtra(StorageVolume.EXTRA_STORAGE_VOLUME, path);
        }
        PendingIntent pi = PendingIntent.getActivity(mContext, 0, intent, 0);
        setMediaStorageNotification(com.android.internal.R.string.ext_media_nofs_notification_title, com.android.internal.R.string.ext_media_nofs_notification_message, com.android.internal.R.drawable.stat_notify_sdcard_usb, true, false, pi);
        updateUsbMassStorageNotification(mUmsAvailable);
    } else if (newState.equals(Environment.MEDIA_UNMOUNTABLE)) {
        /*
             * Storage is corrupt. Show corrupt media notification,
             * and enable UMS notification if connected.
             */
        Intent intent = new Intent();
        intent.setClass(mContext, com.android.internal.app.ExternalMediaFormatActivity.class);
        if ("true".equals(System.getProperty("omap.enhancement"))) {
            intent.putExtra(StorageVolume.EXTRA_STORAGE_VOLUME, path);
        }
        PendingIntent pi = PendingIntent.getActivity(mContext, 0, intent, 0);
        setMediaStorageNotification(com.android.internal.R.string.ext_media_unmountable_notification_title, com.android.internal.R.string.ext_media_unmountable_notification_message, com.android.internal.R.drawable.stat_notify_sdcard_usb, true, false, pi);
        updateUsbMassStorageNotification(mUmsAvailable);
    } else if (newState.equals(Environment.MEDIA_REMOVED)) {
        /*
             * Storage has been removed. Show nomedia media notification,
             * and disable UMS notification regardless of connection state.
             */
        setMediaStorageNotification(com.android.internal.R.string.ext_media_nomedia_notification_title, com.android.internal.R.string.ext_media_nomedia_notification_message, com.android.internal.R.drawable.stat_notify_sdcard_usb, true, false, null);
        updateUsbMassStorageNotification(false);
    } else if (newState.equals(Environment.MEDIA_BAD_REMOVAL)) {
        /*
             * Storage has been removed unsafely. Show bad removal media notification,
             * and disable UMS notification regardless of connection state.
             */
        setMediaStorageNotification(com.android.internal.R.string.ext_media_badremoval_notification_title, com.android.internal.R.string.ext_media_badremoval_notification_message, com.android.internal.R.drawable.stat_sys_warning, true, true, null);
        updateUsbMassStorageNotification(false);
    } else {
        Slog.w(TAG, String.format("Ignoring unknown state {%s}", newState));
    }
}
#end_block

#method_before
@Override
public int onStartCommand(Intent intent, int flags, int startId) {
    if (FORMAT_AND_FACTORY_RESET.equals(intent.getAction())) {
        mFactoryReset = true;
    }
    if (intent.getBooleanExtra(EXTRA_ALWAYS_RESET, false)) {
        mAlwaysReset = true;
    }
    mStoragePath = intent.getStringExtra(StorageVolume.EXTRA_STORAGE_VOLUME);
    if (mProgressDialog == null) {
        mProgressDialog = new ProgressDialog(this);
        mProgressDialog.setIndeterminate(true);
        mProgressDialog.setCancelable(true);
        mProgressDialog.getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_ALERT);
        if (!mAlwaysReset) {
            mProgressDialog.setOnCancelListener(this);
        }
        updateProgressState();
        mProgressDialog.show();
    }
    return Service.START_REDELIVER_INTENT;
}
#method_after
@Override
public int onStartCommand(Intent intent, int flags, int startId) {
    if (FORMAT_AND_FACTORY_RESET.equals(intent.getAction())) {
        mFactoryReset = true;
    }
    if (intent.getBooleanExtra(EXTRA_ALWAYS_RESET, false)) {
        mAlwaysReset = true;
    }
    mStorageVolume = intent.getParcelableExtra(StorageVolume.EXTRA_STORAGE_VOLUME);
    if ("true".equals(System.getProperty("omap.enhancement"))) {
        IMountService mountService = getMountService();
        mStoragePath = intent.getStringExtra(StorageVolume.EXTRA_STORAGE_VOLUME);
        try {
            for (StorageVolume vol : mountService.getVolumeList()) {
                if (vol.getPath().equals(mStoragePath)) {
                    mStorageVolume = vol;
                    break;
                }
            }
        } catch (RemoteException e) {
            Log.e(TAG, "Failed getting VolumeList", e);
        }
    }
    if (mProgressDialog == null) {
        mProgressDialog = new ProgressDialog(this);
        mProgressDialog.setIndeterminate(true);
        mProgressDialog.setCancelable(true);
        mProgressDialog.getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_ALERT);
        if (!mAlwaysReset) {
            mProgressDialog.setOnCancelListener(this);
        }
        updateProgressState();
        mProgressDialog.show();
    }
    return Service.START_REDELIVER_INTENT;
}
#end_block

#method_before
@Override
public void onCancel(DialogInterface dialog) {
    IMountService mountService = getMountService();
    String extStoragePath = mStoragePath == "" ? Environment.getLegacyExternalStorageDirectory().toString() : mStoragePath;
    try {
        mountService.mountVolume(extStoragePath);
    } catch (RemoteException e) {
        Log.w(TAG, "Failed talking with mount service", e);
    }
    stopSelf();
}
#method_after
@Override
public void onCancel(DialogInterface dialog) {
    IMountService mountService = getMountService();
    String extStoragePath = mStorageVolume == null ? Environment.getLegacyExternalStorageDirectory().toString() : mStorageVolume.getPath();
    try {
        mountService.mountVolume(extStoragePath);
    } catch (RemoteException e) {
        Log.w(TAG, "Failed talking with mount service", e);
    }
    stopSelf();
}
#end_block

#method_before
void updateProgressState() {
    String status = mStoragePath == "" ? Environment.getExternalStorageState() : mStorageManager.getVolumeState(mStoragePath);
    if (Environment.MEDIA_MOUNTED.equals(status) || Environment.MEDIA_MOUNTED_READ_ONLY.equals(status)) {
        updateProgressDialog(R.string.progress_unmounting);
        IMountService mountService = getMountService();
        final String extStoragePath = mStoragePath == "" ? Environment.getLegacyExternalStorageDirectory().toString() : mStoragePath;
        try {
            // Remove encryption mapping if this is an unmount for a factory reset.
            mountService.unmountVolume(extStoragePath, true, mFactoryReset);
        } catch (RemoteException e) {
            Log.w(TAG, "Failed talking with mount service", e);
        }
    } else if (Environment.MEDIA_NOFS.equals(status) || Environment.MEDIA_UNMOUNTED.equals(status) || Environment.MEDIA_UNMOUNTABLE.equals(status)) {
        updateProgressDialog(R.string.progress_erasing);
        final IMountService mountService = getMountService();
        final String extStoragePath = mStoragePath == "" ? Environment.getLegacyExternalStorageDirectory().toString() : mStoragePath;
        if (mountService != null) {
            new Thread() {

                @Override
                public void run() {
                    boolean success = false;
                    try {
                        mountService.formatVolume(extStoragePath);
                        success = true;
                    } catch (Exception e) {
                        Toast.makeText(ExternalStorageFormatter.this, R.string.format_error, Toast.LENGTH_LONG).show();
                    }
                    if (success) {
                        if (mFactoryReset) {
                            sendBroadcast(new Intent("android.intent.action.MASTER_CLEAR"));
                            // Intent handling is asynchronous -- assume it will happen soon.
                            stopSelf();
                            return;
                        }
                    }
                    // reset, then it is time to remount the storage.
                    if (!success && mAlwaysReset) {
                        sendBroadcast(new Intent("android.intent.action.MASTER_CLEAR"));
                    } else {
                        try {
                            mountService.mountVolume(extStoragePath);
                        } catch (RemoteException e) {
                            Log.w(TAG, "Failed talking with mount service", e);
                        }
                    }
                    stopSelf();
                    return;
                }
            }.start();
        } else {
            Log.w(TAG, "Unable to locate IMountService");
        }
    } else if (Environment.MEDIA_BAD_REMOVAL.equals(status)) {
        fail(R.string.media_bad_removal);
    } else if (Environment.MEDIA_CHECKING.equals(status)) {
        fail(R.string.media_checking);
    } else if (Environment.MEDIA_REMOVED.equals(status)) {
        fail(R.string.media_removed);
    } else if (Environment.MEDIA_SHARED.equals(status)) {
        fail(R.string.media_shared);
    } else {
        fail(R.string.media_unknown_state);
        Log.w(TAG, "Unknown storage state: " + status);
        stopSelf();
    }
}
#method_after
void updateProgressState() {
    String status = mStorageVolume == null ? Environment.getExternalStorageState() : mStorageManager.getVolumeState(mStorageVolume.getPath());
    if (Environment.MEDIA_MOUNTED.equals(status) || Environment.MEDIA_MOUNTED_READ_ONLY.equals(status)) {
        updateProgressDialog(R.string.progress_unmounting);
        IMountService mountService = getMountService();
        final String extStoragePath = mStorageVolume == null ? Environment.getLegacyExternalStorageDirectory().toString() : mStorageVolume.getPath();
        try {
            // Remove encryption mapping if this is an unmount for a factory reset.
            mountService.unmountVolume(extStoragePath, true, mFactoryReset);
        } catch (RemoteException e) {
            Log.w(TAG, "Failed talking with mount service", e);
        }
    } else if (Environment.MEDIA_NOFS.equals(status) || Environment.MEDIA_UNMOUNTED.equals(status) || Environment.MEDIA_UNMOUNTABLE.equals(status)) {
        updateProgressDialog(R.string.progress_erasing);
        final IMountService mountService = getMountService();
        final String extStoragePath = mStorageVolume == null ? Environment.getLegacyExternalStorageDirectory().toString() : mStorageVolume.getPath();
        if (mountService != null) {
            new Thread() {

                @Override
                public void run() {
                    boolean success = false;
                    try {
                        mountService.formatVolume(extStoragePath);
                        success = true;
                    } catch (Exception e) {
                        Toast.makeText(ExternalStorageFormatter.this, R.string.format_error, Toast.LENGTH_LONG).show();
                    }
                    if (success) {
                        if (mFactoryReset) {
                            sendBroadcast(new Intent("android.intent.action.MASTER_CLEAR"));
                            // Intent handling is asynchronous -- assume it will happen soon.
                            stopSelf();
                            return;
                        }
                    }
                    // reset, then it is time to remount the storage.
                    if (!success && mAlwaysReset) {
                        sendBroadcast(new Intent("android.intent.action.MASTER_CLEAR"));
                    } else {
                        try {
                            mountService.mountVolume(extStoragePath);
                        } catch (RemoteException e) {
                            Log.w(TAG, "Failed talking with mount service", e);
                        }
                    }
                    stopSelf();
                    return;
                }
            }.start();
        } else {
            Log.w(TAG, "Unable to locate IMountService");
        }
    } else if (Environment.MEDIA_BAD_REMOVAL.equals(status)) {
        fail(R.string.media_bad_removal);
    } else if (Environment.MEDIA_CHECKING.equals(status)) {
        fail(R.string.media_checking);
    } else if (Environment.MEDIA_REMOVED.equals(status)) {
        fail(R.string.media_removed);
    } else if (Environment.MEDIA_SHARED.equals(status)) {
        fail(R.string.media_shared);
    } else {
        fail(R.string.media_unknown_state);
        Log.w(TAG, "Unknown storage state: " + status);
        stopSelf();
    }
}
#end_block

#method_before
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    Log.d("ExternalMediaFormatActivity", "onCreate!");
    path = getIntent().getStringExtra(StorageVolume.EXTRA_STORAGE_VOLUME);
    // Set up the "dialog"
    final AlertController.AlertParams p = mAlertParams;
    p.mIconId = com.android.internal.R.drawable.stat_sys_warning;
    p.mTitle = getString(com.android.internal.R.string.extmedia_format_title);
    p.mMessage = getString(com.android.internal.R.string.extmedia_format_message);
    p.mPositiveButtonText = getString(com.android.internal.R.string.extmedia_format_button_format);
    p.mPositiveButtonListener = this;
    p.mNegativeButtonText = getString(com.android.internal.R.string.cancel);
    p.mNegativeButtonListener = this;
    setupAlert();
}
#method_after
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    Log.d("ExternalMediaFormatActivity", "onCreate!");
    if ("true".equals(System.getProperty("omap.enhancement"))) {
        mPath = getIntent().getStringExtra(StorageVolume.EXTRA_STORAGE_VOLUME);
    }
    // Set up the "dialog"
    final AlertController.AlertParams p = mAlertParams;
    p.mIconId = com.android.internal.R.drawable.stat_sys_warning;
    p.mTitle = getString(com.android.internal.R.string.extmedia_format_title);
    p.mMessage = getString(com.android.internal.R.string.extmedia_format_message);
    p.mPositiveButtonText = getString(com.android.internal.R.string.extmedia_format_button_format);
    p.mPositiveButtonListener = this;
    p.mNegativeButtonText = getString(com.android.internal.R.string.cancel);
    p.mNegativeButtonListener = this;
    setupAlert();
}
#end_block

#method_before
public void onClick(DialogInterface dialog, int which) {
    if (which == POSITIVE_BUTTON) {
        Intent intent = new Intent(ExternalStorageFormatter.FORMAT_ONLY);
        intent.setComponent(ExternalStorageFormatter.COMPONENT_NAME);
        intent.putExtra(StorageVolume.EXTRA_STORAGE_VOLUME, path);
        startService(intent);
    }
    // No matter what, finish the activity
    finish();
}
#method_after
public void onClick(DialogInterface dialog, int which) {
    if (which == POSITIVE_BUTTON) {
        Intent intent = new Intent(ExternalStorageFormatter.FORMAT_ONLY);
        intent.setComponent(ExternalStorageFormatter.COMPONENT_NAME);
        if ("true".equals(System.getProperty("omap.enhancement"))) {
            intent.putExtra(StorageVolume.EXTRA_STORAGE_VOLUME, mPath);
        }
        startService(intent);
    }
    // No matter what, finish the activity
    finish();
}
#end_block

#method_before
@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    String wfdRole = SystemProperties.get("persist.wfd.role", "source");
    mIsSink = wfdRole.equalsIgnoreCase("sink");
    if (!mIsSink) {
        AlertDialog.Builder alertDialogBuilder = new AlertDialog.Builder(SinkActivity.this);
        alertDialogBuilder.setTitle("Wrong WFD role");
        alertDialogBuilder.setMessage("This device is not a WFD sink. " + "Can't start player now.").setCancelable(false).setPositiveButton("Close", new DialogInterface.OnClickListener() {

            public void onClick(DialogInterface dialog, int id) {
                // Finish player activity
                SinkActivity.this.finish();
            }
        });
        // Create and show warning
        alertDialogBuilder.create().show();
    }
    Intent intent = getIntent();
    mIpAddress = intent.getStringExtra(WfdSinkTools.EXTRA_ADDRESS);
    mRtspPort = intent.getIntExtra(WfdSinkTools.EXTRA_PORT, WfdSinkTools.DEFAULT_RTSP_PORT);
    if (mIpAddress == null) {
        mIpAddress = "";
    }
    mSinkSurfaceView = new WfdSinkSurfaceView(getApplicationContext());
    mSinkSurfaceView.getHolder().addCallback(new SurfaceCreatedCallback(this));
    mRtspSink = new RtspSink();
    mRtspStateListener = new WfdRtspStateListener();
    setContentView(R.layout.activity_sink);
    placeView(R.id.content_view);
}
#method_after
@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    int port;
    String ipAddress;
    Intent intent = getIntent();
    ipAddress = intent.getStringExtra(WfdSinkTools.EXTRA_ADDRESS);
    port = intent.getIntExtra(WfdSinkTools.EXTRA_PORT, WfdSinkTools.DEFAULT_RTSP_PORT);
    if (ipAddress == null) {
        ipAddress = "";
    }
    try {
        mWfdSink = new WfdSink(ipAddress, port);
    } catch (WfdSinkRoleException ex) {
        AlertDialog.Builder alertDialogBuilder = new AlertDialog.Builder(SinkActivity.this);
        alertDialogBuilder.setTitle("Wrong WFD role");
        alertDialogBuilder.setMessage("This device is not a WFD sink. " + "Can't start player now.").setCancelable(false).setPositiveButton("Close", new DialogInterface.OnClickListener() {

            public void onClick(DialogInterface dialog, int id) {
                // Finish player activity
                SinkActivity.this.finish();
            }
        });
        // Create and show warning
        alertDialogBuilder.create().show();
    }
    mSinkSurfaceView = new WfdSinkSurfaceView(getApplicationContext());
    mSinkSurfaceView.getHolder().addCallback(new SurfaceCreatedCallback(this));
    mWfdStateListener = new TestWfdStateListener(this);
    setContentView(R.layout.activity_sink);
    placeView(R.id.content_view);
}
#end_block

#method_before
public void connect() {
    if (D)
        Log.v(LOG_TAG, "connect() called");
    if (mSinkSurfaceView == null || mSinkSurfaceView.getSurface() == null) {
        Log.e(LOG_TAG, "Surface is not available.");
        return;
    }
    if ((mIpAddress.length() == 0) || (mRtspPort == 0)) {
        Log.e(LOG_TAG, "Address or port not set.");
        return;
    }
    mRtspSink.connect(mSinkSurfaceView.getSurface(), mIpAddress + ":" + mRtspPort);
    if ((mRtspSink != null) && (mRtspStateListener != null)) {
        mRtspSink.setStateListener(mRtspStateListener);
    }
}
#method_after
public void connect() {
    if (D)
        Log.v(LOG_TAG, "connect() called");
    if (mSinkSurfaceView == null || mSinkSurfaceView.getSurface() == null) {
        Log.e(LOG_TAG, "Surface is not available.");
        return;
    }
    mWfdSink.connect(mSinkSurfaceView.getSurface());
    if ((mWfdSink != null) && (mWfdStateListener != null)) {
        mWfdSink.setStateListener(mWfdStateListener);
    }
}
#end_block

#method_before
public void disconnect() {
    if (D)
        Log.v(LOG_TAG, "disconnect() called");
    mRtspSink.disconnect();
}
#method_after
public void disconnect() {
    if (D)
        Log.v(LOG_TAG, "disconnect() called");
    mWfdSink.disconnect();
}
#end_block

#method_before
public void play() {
    if (D)
        Log.v(LOG_TAG, "play() called");
    mRtspSink.play();
}
#method_after
public void play() {
    if (D)
        Log.v(LOG_TAG, "play() called");
    mWfdSink.play();
}
#end_block

#method_before
public void pause() {
    if (D)
        Log.v(LOG_TAG, "pause() called");
    mRtspSink.pause();
}
#method_after
public void pause() {
    if (D)
        Log.v(LOG_TAG, "pause() called");
    mWfdSink.pause();
}
#end_block

#method_before
public void tearDown() {
    if (D)
        Log.v(LOG_TAG, "tearDown() called");
    mRtspSink.teardown();
}
#method_after
public void tearDown() {
    if (D)
        Log.v(LOG_TAG, "tearDown() called");
    mWfdSink.teardown();
}
#end_block

#method_before
private void setWfdInfo() {
    WifiP2pWfdInfo wfdInfo = new WifiP2pWfdInfo();
    wfdInfo.setDeviceType(WifiP2pWfdInfo.PRIMARY_SINK);
    wfdInfo.setWfdEnabled(true);
    mWifiP2pManger = (WifiP2pManager) this.getSystemService(Context.WIFI_P2P_SERVICE);
    mChannel = mWifiP2pManger.initialize(this, Looper.myLooper(), null);
    mWifiP2pManger.setWFDInfo(mChannel, wfdInfo, new WfdActionListener());
}
#method_after
private void setWfdInfo() {
    WifiP2pWfdInfo wfdInfo = new WifiP2pWfdInfo();
    wfdInfo.setDeviceType(WifiP2pWfdInfo.PRIMARY_SINK);
    wfdInfo.setWfdEnabled(true);
    if (mWifiP2pManger == null) {
        mWifiP2pManger = (WifiP2pManager) this.getSystemService(Context.WIFI_P2P_SERVICE);
    }
    if (mChannel == null) {
        mChannel = mWifiP2pManger.initialize(this, Looper.myLooper(), null);
    }
    mWifiP2pManger.setWFDInfo(mChannel, wfdInfo, new WfdActionListener(this));
}
#end_block

#method_before
@Override
public void onFailure(int reason) {
    Log.e(LOG_TAG, "Error setting Wfd info. Reason: " + reason);
    mWfdEnabled = false;
}
#method_after
@Override
public void onFailure(int reason) {
    Log.e(LOG_TAG, "Error setting Wfd info. Reason: " + reason + " Trying to set WFD info once more.");
    mWfdEnabled = false;
    mParentService.setWfdInfo();
}
#end_block

#method_before
@Override
public void onReceive(Context context, Intent intent) {
    if (D)
        Log.v(LOG_TAG, "Received intent with action: " + intent.getAction());
    if (intent.getAction() == WifiP2pManager.WIFI_P2P_CONNECTION_CHANGED_ACTION) {
        NetworkInfo networkInfo = (NetworkInfo) intent.getParcelableExtra(WifiP2pManager.EXTRA_NETWORK_INFO);
        WifiP2pInfo wifiP2Info = (WifiP2pInfo) intent.getParcelableExtra(WifiP2pManager.EXTRA_WIFI_P2P_INFO);
        if (wifiP2Info.groupOwnerAddress != null) {
            if (D)
                Log.v(LOG_TAG, "GO ip address: " + wifiP2Info.groupOwnerAddress.getHostAddress());
        }
        if (networkInfo.isConnected() && (wifiP2Info.groupOwnerAddress != null)) {
            mWifiP2Info = wifiP2Info;
            mWifiP2pManger.requestGroupInfo(mChannel, mWfdGroupInfoListener);
        }
    }
    if (intent.getAction() == WfdSinkTools.DHCP_ACTION) {
        String action = intent.getStringExtra(WfdSinkTools.EXTRA_ACTION);
        String tempMac = intent.getStringExtra(WfdSinkTools.EXTRA_MAC_ADDRESS);
        String tempIp = intent.getStringExtra(WfdSinkTools.EXTRA_IP_ADDRESS);
        if ((tempMac != null) && (tempMac.equalsIgnoreCase(mParent.mSourceMac))) {
            synchronized (mParent.mSourceAddress) {
                mParent.mSourceAddress = tempIp;
            }
            mParent.invokeSink();
        }
    }
}
#method_after
@Override
public void onReceive(Context context, Intent intent) {
    if (D)
        Log.v(LOG_TAG, "Received intent with action: " + intent.getAction());
    if (intent.getAction() == WifiP2pManager.WIFI_P2P_CONNECTION_CHANGED_ACTION) {
        NetworkInfo networkInfo = (NetworkInfo) intent.getParcelableExtra(WifiP2pManager.EXTRA_NETWORK_INFO);
        WifiP2pInfo wifiP2Info = (WifiP2pInfo) intent.getParcelableExtra(WifiP2pManager.EXTRA_WIFI_P2P_INFO);
        if (wifiP2Info.groupOwnerAddress != null) {
            if (D)
                Log.v(LOG_TAG, "GO ip address: " + wifiP2Info.groupOwnerAddress.getHostAddress());
        }
        if (networkInfo.isConnected() && (wifiP2Info.groupOwnerAddress != null)) {
            mWifiP2Info = wifiP2Info;
            mWifiP2pManger.requestGroupInfo(mChannel, mWfdGroupInfoListener);
        }
    }
    if (intent.getAction() == WfdSinkTools.DHCP_ACTION) {
        String tempMac = intent.getStringExtra(WfdSinkTools.EXTRA_MAC_ADDRESS);
        String tempIp = intent.getStringExtra(WfdSinkTools.EXTRA_IP_ADDRESS);
        if ((tempMac != null) && (tempMac.equalsIgnoreCase(mParent.mSourceMac))) {
            synchronized (mParent.mSourceAddress) {
                mParent.mSourceAddress = tempIp;
            }
            mParent.invokeSink();
        }
    }
}
#end_block

#method_before
private void discoverPeers() {
    if (SystemProperties.OMAP_ENHANCEMENT && mConnectedDevice == null) {
        return;
    }
    if (!mDiscoverPeersInProgress) {
        mDiscoverPeersInProgress = true;
        mDiscoverPeersRetriesLeft = DISCOVER_PEERS_MAX_RETRIES;
        handleScanStarted();
        tryDiscoverPeers();
    }
}
#method_after
private void discoverPeers() {
    if (SystemProperties.OMAP_ENHANCEMENT && mConnectedDevice != null) {
        Slog.w(TAG, "Discover peers skipped due to active connection.");
        return;
    }
    if (!mDiscoverPeersInProgress) {
        mDiscoverPeersInProgress = true;
        mDiscoverPeersRetriesLeft = DISCOVER_PEERS_MAX_RETRIES;
        handleScanStarted();
        tryDiscoverPeers();
    }
}
#end_block

#method_before
private void updateConnection() {
    // have disconnected from the old one.
    if (mRemoteDisplay != null && mConnectedDevice != mDesiredDevice) {
        Slog.i(TAG, "Stopped listening for RTSP connection on " + mRemoteDisplayInterface + " from Wifi display: " + mConnectedDevice.deviceName);
        mRemoteDisplay.dispose();
        mRemoteDisplay = null;
        mRemoteDisplayInterface = null;
        mRemoteDisplayConnected = false;
        mHandler.removeCallbacks(mRtspTimeout);
        setRemoteSubmixOn(false);
        unadvertiseDisplay();
    // continue to next step
    }
    // Step 2. Before we try to connect to a new device, disconnect from the old one.
    if (mDisconnectingDevice != null) {
        // wait for asynchronous callback
        return;
    }
    if (mConnectedDevice != null && mConnectedDevice != mDesiredDevice) {
        Slog.i(TAG, "Disconnecting from Wifi display: " + mConnectedDevice.deviceName);
        mDisconnectingDevice = mConnectedDevice;
        mConnectedDevice = null;
        unadvertiseDisplay();
        final WifiP2pDevice oldDevice = mDisconnectingDevice;
        mWifiP2pManager.removeGroup(mWifiP2pChannel, new ActionListener() {

            @Override
            public void onSuccess() {
                Slog.i(TAG, "Disconnected from Wifi display: " + oldDevice.deviceName);
                next();
            }

            @Override
            public void onFailure(int reason) {
                Slog.i(TAG, "Failed to disconnect from Wifi display: " + oldDevice.deviceName + ", reason=" + reason);
                next();
            }

            private void next() {
                if (mDisconnectingDevice == oldDevice) {
                    mDisconnectingDevice = null;
                    updateConnection();
                }
            }
        });
        // wait for asynchronous callback
        return;
    }
    // to the old one.
    if (mCancelingDevice != null) {
        // wait for asynchronous callback
        return;
    }
    if (mConnectingDevice != null && mConnectingDevice != mDesiredDevice) {
        Slog.i(TAG, "Canceling connection to Wifi display: " + mConnectingDevice.deviceName);
        mCancelingDevice = mConnectingDevice;
        mConnectingDevice = null;
        unadvertiseDisplay();
        mHandler.removeCallbacks(mConnectionTimeout);
        final WifiP2pDevice oldDevice = mCancelingDevice;
        mWifiP2pManager.cancelConnect(mWifiP2pChannel, new ActionListener() {

            @Override
            public void onSuccess() {
                Slog.i(TAG, "Canceled connection to Wifi display: " + oldDevice.deviceName);
                next();
            }

            @Override
            public void onFailure(int reason) {
                Slog.i(TAG, "Failed to cancel connection to Wifi display: " + oldDevice.deviceName + ", reason=" + reason);
                next();
            }

            private void next() {
                if (mCancelingDevice == oldDevice) {
                    mCancelingDevice = null;
                    updateConnection();
                }
            }
        });
        // wait for asynchronous callback
        return;
    }
    // Step 4. If we wanted to disconnect, then mission accomplished.
    if (mDesiredDevice == null) {
        unadvertiseDisplay();
        // done
        return;
    }
    // Step 5. Try to connect.
    if (mConnectedDevice == null && mConnectingDevice == null) {
        Slog.i(TAG, "Connecting to Wifi display: " + mDesiredDevice.deviceName);
        mConnectingDevice = mDesiredDevice;
        WifiP2pConfig config = new WifiP2pConfig();
        WpsInfo wps = new WpsInfo();
        if (mConnectingDevice.wpsPbcSupported()) {
            wps.setup = WpsInfo.PBC;
        } else if (mConnectingDevice.wpsDisplaySupported()) {
            // We do keypad if peer does display
            wps.setup = WpsInfo.KEYPAD;
        } else {
            wps.setup = WpsInfo.DISPLAY;
        }
        config.wps = wps;
        config.deviceAddress = mConnectingDevice.deviceAddress;
        // Helps with STA & P2P concurrency
        config.groupOwnerIntent = WifiP2pConfig.MIN_GROUP_OWNER_INTENT;
        WifiDisplay display = createWifiDisplay(mConnectingDevice);
        advertiseDisplay(display, null, 0, 0, 0);
        final WifiP2pDevice newDevice = mDesiredDevice;
        mWifiP2pManager.connect(mWifiP2pChannel, config, new ActionListener() {

            @Override
            public void onSuccess() {
                // The connection may not yet be established.  We still need to wait
                // for WIFI_P2P_CONNECTION_CHANGED_ACTION.  However, we might never
                // get that broadcast, so we register a timeout.
                Slog.i(TAG, "Initiated connection to Wifi display: " + newDevice.deviceName);
                mHandler.postDelayed(mConnectionTimeout, CONNECTION_TIMEOUT_SECONDS * 1000);
            }

            @Override
            public void onFailure(int reason) {
                if (mConnectingDevice == newDevice) {
                    Slog.i(TAG, "Failed to initiate connection to Wifi display: " + newDevice.deviceName + ", reason=" + reason);
                    mConnectingDevice = null;
                    handleConnectionFailure(false);
                }
            }
        });
        // wait for asynchronous callback
        return;
    }
    // Step 6. Listen for incoming connections.
    if (mConnectedDevice != null && mRemoteDisplay == null) {
        Inet4Address addr = getInterfaceAddress(mConnectedDeviceGroupInfo);
        if (addr == null) {
            Slog.i(TAG, "Failed to get local interface address for communicating " + "with Wifi display: " + mConnectedDevice.deviceName);
            handleConnectionFailure(false);
            // done
            return;
        }
        setRemoteSubmixOn(true);
        final WifiP2pDevice oldDevice = mConnectedDevice;
        final int port = getPortNumber(mConnectedDevice);
        final String iface = addr.getHostAddress() + ":" + port;
        mRemoteDisplayInterface = iface;
        Slog.i(TAG, "Listening for RTSP connection on " + iface + " from Wifi display: " + mConnectedDevice.deviceName);
        mRemoteDisplay = RemoteDisplay.listen(iface, new RemoteDisplay.Listener() {

            @Override
            public void onDisplayConnected(Surface surface, int width, int height, int flags) {
                if (mConnectedDevice == oldDevice && !mRemoteDisplayConnected) {
                    Slog.i(TAG, "Opened RTSP connection with Wifi display: " + mConnectedDevice.deviceName);
                    mRemoteDisplayConnected = true;
                    mHandler.removeCallbacks(mRtspTimeout);
                    final WifiDisplay display = createWifiDisplay(mConnectedDevice);
                    advertiseDisplay(display, surface, width, height, flags);
                }
            }

            @Override
            public void onDisplayDisconnected() {
                if (mConnectedDevice == oldDevice) {
                    Slog.i(TAG, "Closed RTSP connection with Wifi display: " + mConnectedDevice.deviceName);
                    mHandler.removeCallbacks(mRtspTimeout);
                    if (SystemProperties.OMAP_ENHANCEMENT) {
                        mRemoteDisplayConnected = false;
                    } else {
                        disconnect();
                    }
                }
            }

            @Override
            public void onDisplayError(int error) {
                if (mConnectedDevice == oldDevice) {
                    Slog.i(TAG, "Lost RTSP connection with Wifi display due to error " + error + ": " + mConnectedDevice.deviceName);
                    mHandler.removeCallbacks(mRtspTimeout);
                    handleConnectionFailure(false);
                }
            }
        }, mHandler);
        mHandler.postDelayed(mRtspTimeout, RTSP_TIMEOUT_SECONDS * 1000);
    }
}
#method_after
private void updateConnection() {
    // have disconnected from the old one.
    if (mRemoteDisplay != null && mConnectedDevice != mDesiredDevice) {
        Slog.i(TAG, "Stopped listening for RTSP connection on " + mRemoteDisplayInterface + " from Wifi display: " + mConnectedDevice.deviceName);
        mRemoteDisplay.dispose();
        mRemoteDisplay = null;
        mRemoteDisplayInterface = null;
        mRemoteDisplayConnected = false;
        mHandler.removeCallbacks(mRtspTimeout);
        setRemoteSubmixOn(false);
        unadvertiseDisplay();
    // continue to next step
    }
    // Step 2. Before we try to connect to a new device, disconnect from the old one.
    if (mDisconnectingDevice != null) {
        // wait for asynchronous callback
        return;
    }
    if (mConnectedDevice != null && mConnectedDevice != mDesiredDevice) {
        Slog.i(TAG, "Disconnecting from Wifi display: " + mConnectedDevice.deviceName);
        mDisconnectingDevice = mConnectedDevice;
        mConnectedDevice = null;
        unadvertiseDisplay();
        final WifiP2pDevice oldDevice = mDisconnectingDevice;
        mWifiP2pManager.removeGroup(mWifiP2pChannel, new ActionListener() {

            @Override
            public void onSuccess() {
                Slog.i(TAG, "Disconnected from Wifi display: " + oldDevice.deviceName);
                next();
            }

            @Override
            public void onFailure(int reason) {
                Slog.i(TAG, "Failed to disconnect from Wifi display: " + oldDevice.deviceName + ", reason=" + reason);
                next();
            }

            private void next() {
                if (mDisconnectingDevice == oldDevice) {
                    mDisconnectingDevice = null;
                    updateConnection();
                }
            }
        });
        // wait for asynchronous callback
        return;
    }
    // to the old one.
    if (mCancelingDevice != null) {
        // wait for asynchronous callback
        return;
    }
    if (mConnectingDevice != null && mConnectingDevice != mDesiredDevice) {
        Slog.i(TAG, "Canceling connection to Wifi display: " + mConnectingDevice.deviceName);
        mCancelingDevice = mConnectingDevice;
        mConnectingDevice = null;
        unadvertiseDisplay();
        mHandler.removeCallbacks(mConnectionTimeout);
        final WifiP2pDevice oldDevice = mCancelingDevice;
        mWifiP2pManager.cancelConnect(mWifiP2pChannel, new ActionListener() {

            @Override
            public void onSuccess() {
                Slog.i(TAG, "Canceled connection to Wifi display: " + oldDevice.deviceName);
                next();
            }

            @Override
            public void onFailure(int reason) {
                Slog.i(TAG, "Failed to cancel connection to Wifi display: " + oldDevice.deviceName + ", reason=" + reason);
                next();
            }

            private void next() {
                if (mCancelingDevice == oldDevice) {
                    mCancelingDevice = null;
                    updateConnection();
                }
            }
        });
        // wait for asynchronous callback
        return;
    }
    // Step 4. If we wanted to disconnect, then mission accomplished.
    if (mDesiredDevice == null) {
        unadvertiseDisplay();
        // done
        return;
    }
    // Step 5. Try to connect.
    if (mConnectedDevice == null && mConnectingDevice == null) {
        Slog.i(TAG, "Connecting to Wifi display: " + mDesiredDevice.deviceName);
        mConnectingDevice = mDesiredDevice;
        WifiP2pConfig config = new WifiP2pConfig();
        WpsInfo wps = new WpsInfo();
        if (mConnectingDevice.wpsPbcSupported()) {
            wps.setup = WpsInfo.PBC;
        } else if (mConnectingDevice.wpsDisplaySupported()) {
            // We do keypad if peer does display
            wps.setup = WpsInfo.KEYPAD;
        } else {
            wps.setup = WpsInfo.DISPLAY;
        }
        config.wps = wps;
        config.deviceAddress = mConnectingDevice.deviceAddress;
        // Helps with STA & P2P concurrency
        config.groupOwnerIntent = WifiP2pConfig.MIN_GROUP_OWNER_INTENT;
        WifiDisplay display = createWifiDisplay(mConnectingDevice);
        advertiseDisplay(display, null, 0, 0, 0);
        final WifiP2pDevice newDevice = mDesiredDevice;
        mWifiP2pManager.connect(mWifiP2pChannel, config, new ActionListener() {

            @Override
            public void onSuccess() {
                // The connection may not yet be established.  We still need to wait
                // for WIFI_P2P_CONNECTION_CHANGED_ACTION.  However, we might never
                // get that broadcast, so we register a timeout.
                Slog.i(TAG, "Initiated connection to Wifi display: " + newDevice.deviceName);
                mHandler.postDelayed(mConnectionTimeout, CONNECTION_TIMEOUT_SECONDS * 1000);
            }

            @Override
            public void onFailure(int reason) {
                if (mConnectingDevice == newDevice) {
                    Slog.i(TAG, "Failed to initiate connection to Wifi display: " + newDevice.deviceName + ", reason=" + reason);
                    mConnectingDevice = null;
                    handleConnectionFailure(false);
                }
            }
        });
        // wait for asynchronous callback
        return;
    }
    // Step 6. Listen for incoming connections.
    if (mConnectedDevice != null && mRemoteDisplay == null) {
        Inet4Address addr = getInterfaceAddress(mConnectedDeviceGroupInfo);
        if (addr == null) {
            Slog.i(TAG, "Failed to get local interface address for communicating " + "with Wifi display: " + mConnectedDevice.deviceName);
            handleConnectionFailure(false);
            // done
            return;
        }
        setRemoteSubmixOn(true);
        final WifiP2pDevice oldDevice = mConnectedDevice;
        final int port = getPortNumber(mConnectedDevice);
        final String iface = addr.getHostAddress() + ":" + port;
        mRemoteDisplayInterface = iface;
        Slog.i(TAG, "Listening for RTSP connection on " + iface + " from Wifi display: " + mConnectedDevice.deviceName);
        mRemoteDisplay = RemoteDisplay.listen(iface, new RemoteDisplay.Listener() {

            @Override
            public void onDisplayConnected(Surface surface, int width, int height, int flags) {
                if (mConnectedDevice == oldDevice && !mRemoteDisplayConnected) {
                    if (!SystemProperties.OMAP_ENHANCEMENT) {
                        Slog.i(TAG, "Opened RTSP connection with Wifi display: " + mConnectedDevice.deviceName);
                    }
                    mRemoteDisplayConnected = true;
                    mHandler.removeCallbacks(mRtspTimeout);
                    final WifiDisplay display = createWifiDisplay(mConnectedDevice);
                    advertiseDisplay(display, surface, width, height, flags);
                }
            }

            @Override
            public void onDisplayDisconnected() {
                if (mConnectedDevice == oldDevice) {
                    if (!SystemProperties.OMAP_ENHANCEMENT) {
                        Slog.i(TAG, "Closed RTSP connection with Wifi display: " + mConnectedDevice.deviceName);
                    }
                    if (SystemProperties.OMAP_ENHANCEMENT) {
                        mRemoteDisplayConnected = false;
                    } else {
                        mHandler.removeCallbacks(mRtspTimeout);
                        disconnect();
                    }
                }
            }

            @Override
            public void onDisplayError(int error) {
                if (mConnectedDevice == oldDevice) {
                    Slog.i(TAG, "Lost RTSP connection with Wifi display due to error " + error + ": " + mConnectedDevice.deviceName);
                    mHandler.removeCallbacks(mRtspTimeout);
                    handleConnectionFailure(false);
                }
            }
        }, mHandler);
        mHandler.postDelayed(mRtspTimeout, RTSP_TIMEOUT_SECONDS * 1000);
    }
}
#end_block

#method_before
// Every time webView setBaseLayer, this will be called.
// When we found the Video layer, then we set the Surface Texture to it.
public static void setBaseLayer(int layer) {
    // Don't do this for full screen mode.
    if (mHTML5VideoView != null && !mHTML5VideoView.isFullScreenMode() && !mHTML5VideoView.surfaceTextureDeleted()) {
        mBaseLayer = layer;
        int currentVideoLayerId = mHTML5VideoView.getVideoLayerId();
        SurfaceTexture surfTexture = HTML5VideoInline.getSurfaceTexture(currentVideoLayerId);
        int textureName = mHTML5VideoView.getTextureName();
        if (layer != 0 && surfTexture != null && currentVideoLayerId != -1) {
            int playerState = mHTML5VideoView.getCurrentState();
            if (mHTML5VideoView.getPlayerBuffering())
                playerState = HTML5VideoView.STATE_PREPARING;
            boolean foundInTree = nativeSendSurfaceTexture(surfTexture, layer, currentVideoLayerId, textureName, playerState);
            if (playerState >= HTML5VideoView.STATE_PREPARED && !foundInTree) {
                mHTML5VideoView.pauseAndDispatch(mCurrentProxy);
                mHTML5VideoView.deleteSurfaceTexture();
            }
        }
    }
}
#method_after
// Every time webView setBaseLayer, this will be called.
// When we found the Video layer, then we set the Surface Texture to it.
public static void setBaseLayer(int layer) {
    // Don't do this for full screen mode.
    if (mHTML5VideoView != null && !mHTML5VideoView.isFullScreenMode() && !mHTML5VideoView.surfaceTextureDeleted()) {
        mBaseLayer = layer;
        int currentVideoLayerId = mHTML5VideoView.getVideoLayerId();
        SurfaceTexture surfTexture = HTML5VideoInline.getSurfaceTexture(currentVideoLayerId);
        int textureName = mHTML5VideoView.getTextureName();
        if (layer != 0 && surfTexture != null && currentVideoLayerId != -1) {
            int playerState = mHTML5VideoView.getCurrentState();
            if (mHTML5VideoView.getPlayerBuffering())
                playerState = HTML5VideoView.STATE_PREPARING;
            boolean foundInTree = nativeSendSurfaceTexture(surfTexture, layer, currentVideoLayerId, textureName, playerState);
            if (playerState >= HTML5VideoView.STATE_PREPARED && !foundInTree) {
                mHTML5VideoView.pauseAndDispatch(mCurrentProxy);
                if ("true".equals(System.getProperty("omap.enhancement"))) {
                    mHTML5VideoView.reset();
                } else {
                    mHTML5VideoView.deleteSurfaceTexture();
                }
            }
        }
    }
}
#end_block

#method_before
// A bunch event listeners for our VideoView
public void onPrepared(MediaPlayer mp) {
    VideoPlayer.onPrepared();
    Message msg = Message.obtain(mWebCoreHandler, PREPARED);
    Map<String, Object> map = new HashMap<String, Object>();
    map.put("dur", new Integer(mp.getDuration()));
    map.put("width", new Integer(mp.getVideoWidth()));
    map.put("height", new Integer(mp.getVideoHeight()));
    msg.obj = map;
    mWebCoreHandler.sendMessage(msg);
}
#method_after
// A bunch event listeners for our VideoView
public void onPrepared(MediaPlayer mp) {
    VideoPlayer.onPrepared();
    if ("true".equals(System.getProperty("omap.enhancement"))) {
        if (!VideoPlayer.isResetted(this)) {
            Message msg = Message.obtain(mWebCoreHandler, PREPARED);
            Map<String, Object> map = new HashMap<String, Object>();
            map.put("dur", new Integer(mp.getDuration()));
            map.put("width", new Integer(mp.getVideoWidth()));
            map.put("height", new Integer(mp.getVideoHeight()));
            msg.obj = map;
            mWebCoreHandler.sendMessage(msg);
        }
    } else {
        Message msg = Message.obtain(mWebCoreHandler, PREPARED);
        Map<String, Object> map = new HashMap<String, Object>();
        map.put("dur", new Integer(mp.getDuration()));
        map.put("width", new Integer(mp.getVideoWidth()));
        map.put("height", new Integer(mp.getVideoHeight()));
        msg.obj = map;
        mWebCoreHandler.sendMessage(msg);
    }
}
#end_block

#method_before
public void stop() {
    if (mPlayer != null) {
        mPlayer.stop();
        deleteSurfaceTexture();
        mPlayer.reset();
        mPlayer = null;
        mCurrentState = STATE_RESETTED;
    }
}
#method_after
public void stop() {
    if (mPlayer != null) {
        mPlayer.stop();
        mPlayer.reset();
        mPlayer = null;
        deleteSurfaceTexture();
        mCurrentState = STATE_RESETTED;
    }
}
#end_block

#method_before
public void reset() {
    if (mCurrentState != STATE_RESETTED) {
        if ("true".equals(System.getProperty("omap.enhancement"))) {
            mPlayer.stop();
            deleteSurfaceTexture();
        }
        mPlayer.reset();
        if ("true".equals(System.getProperty("omap.enhancement"))) {
            mPlayer = null;
        }
    }
    mCurrentState = STATE_RESETTED;
}
#method_after
public void reset() {
    if (mCurrentState != STATE_RESETTED) {
        if ("true".equals(System.getProperty("omap.enhancement"))) {
            mPlayer.stop();
            mPlayer.reset();
            mPlayer = null;
            deleteSurfaceTexture();
        } else {
            mPlayer.reset();
        }
    }
    mCurrentState = STATE_RESETTED;
}
#end_block

#method_before
@Override
public void run() {
    EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_SYSTEM_RUN, SystemClock.uptimeMillis());
    Looper.prepare();
    android.os.Process.setThreadPriority(android.os.Process.THREAD_PRIORITY_FOREGROUND);
    BinderInternal.disableBackgroundScheduling(true);
    android.os.Process.setCanSelfBackground(false);
    // Check whether we failed to shut down last time we tried.
    {
        final String shutdownAction = SystemProperties.get(ShutdownThread.SHUTDOWN_ACTION_PROPERTY, "");
        if (shutdownAction != null && shutdownAction.length() > 0) {
            boolean reboot = (shutdownAction.charAt(0) == '1');
            final String reason;
            if (shutdownAction.length() > 1) {
                reason = shutdownAction.substring(1, shutdownAction.length());
            } else {
                reason = null;
            }
            ShutdownThread.rebootOrShutdown(reboot, reason);
        }
    }
    String factoryTestStr = SystemProperties.get("ro.factorytest");
    int factoryTest = "".equals(factoryTestStr) ? SystemServer.FACTORY_TEST_OFF : Integer.parseInt(factoryTestStr);
    final boolean headless = "1".equals(SystemProperties.get("ro.config.headless", "0"));
    LightsService lights = null;
    PowerManagerService power = null;
    BatteryService battery = null;
    VibratorService vibrator = null;
    AlarmManagerService alarm = null;
    NetworkManagementService networkManagement = null;
    NetworkStatsService networkStats = null;
    NetworkPolicyManagerService networkPolicy = null;
    ConnectivityService connectivity = null;
    WifiP2pService wifiP2p = null;
    WifiService wifi = null;
    NsdService serviceDiscovery = null;
    IPackageManager pm = null;
    Context context = null;
    WindowManagerService wm = null;
    BluetoothService bluetooth = null;
    BluetoothA2dpService bluetoothA2dp = null;
    DockObserver dock = null;
    UsbService usb = null;
    SerialService serial = null;
    UiModeManagerService uiMode = null;
    RecognitionManagerService recognition = null;
    ThrottleService throttle = null;
    NetworkTimeUpdateService networkTimeUpdater = null;
    CommonTimeManagementService commonTimeMgmtService = null;
    InputManagerService inputManager = null;
    TIEthernetService ethernet = null;
    // Critical services...
    try {
        Slog.i(TAG, "Entropy Mixer");
        ServiceManager.addService("entropy", new EntropyMixer());
        Slog.i(TAG, "Power Manager");
        power = new PowerManagerService();
        ServiceManager.addService(Context.POWER_SERVICE, power);
        Slog.i(TAG, "Activity Manager");
        context = ActivityManagerService.main(factoryTest);
        Slog.i(TAG, "Telephony Registry");
        ServiceManager.addService("telephony.registry", new TelephonyRegistry(context));
        Slog.i(TAG, "Scheduling Policy");
        ServiceManager.addService(Context.SCHEDULING_POLICY_SERVICE, new SchedulingPolicyService());
        AttributeCache.init(context);
        Slog.i(TAG, "Package Manager");
        // Only run "core" apps if we're encrypting the device.
        String cryptState = SystemProperties.get("vold.decrypt");
        boolean onlyCore = false;
        if (ENCRYPTING_STATE.equals(cryptState)) {
            Slog.w(TAG, "Detected encryption in progress - only parsing core apps");
            onlyCore = true;
        } else if (ENCRYPTED_STATE.equals(cryptState)) {
            Slog.w(TAG, "Device encrypted - only parsing core apps");
            onlyCore = true;
        }
        pm = PackageManagerService.main(context, factoryTest != SystemServer.FACTORY_TEST_OFF, onlyCore);
        boolean firstBoot = false;
        try {
            firstBoot = pm.isFirstBoot();
        } catch (RemoteException e) {
        }
        ActivityManagerService.setSystemProcess();
        mContentResolver = context.getContentResolver();
        // The AccountManager must come before the ContentService
        try {
            Slog.i(TAG, "Account Manager");
            ServiceManager.addService(Context.ACCOUNT_SERVICE, new AccountManagerService(context));
        } catch (Throwable e) {
            Slog.e(TAG, "Failure starting Account Manager", e);
        }
        Slog.i(TAG, "Content Manager");
        ContentService.main(context, factoryTest == SystemServer.FACTORY_TEST_LOW_LEVEL);
        Slog.i(TAG, "System Content Providers");
        ActivityManagerService.installSystemProviders();
        Slog.i(TAG, "Lights Service");
        lights = new LightsService(context);
        Slog.i(TAG, "Battery Service");
        battery = new BatteryService(context, lights);
        ServiceManager.addService("battery", battery);
        Slog.i(TAG, "Vibrator Service");
        vibrator = new VibratorService(context);
        ServiceManager.addService("vibrator", vibrator);
        // only initialize the power service after we have started the
        // lights service, content providers and the battery service.
        power.init(context, lights, ActivityManagerService.self(), battery);
        Slog.i(TAG, "Alarm Manager");
        alarm = new AlarmManagerService(context);
        ServiceManager.addService(Context.ALARM_SERVICE, alarm);
        Slog.i(TAG, "Init Watchdog");
        Watchdog.getInstance().init(context, battery, power, alarm, ActivityManagerService.self());
        Slog.i(TAG, "Window Manager");
        wm = WindowManagerService.main(context, power, factoryTest != SystemServer.FACTORY_TEST_LOW_LEVEL, !firstBoot, onlyCore);
        ServiceManager.addService(Context.WINDOW_SERVICE, wm);
        inputManager = wm.getInputManagerService();
        ServiceManager.addService(Context.INPUT_SERVICE, inputManager);
        ActivityManagerService.self().setWindowManager(wm);
        // support Bluetooth - see bug 988521
        if (SystemProperties.get("ro.kernel.qemu").equals("1")) {
            Slog.i(TAG, "No Bluetooh Service (emulator)");
        } else if (factoryTest == SystemServer.FACTORY_TEST_LOW_LEVEL) {
            Slog.i(TAG, "No Bluetooth Service (factory test)");
        } else {
            Slog.i(TAG, "Bluetooth Service");
            bluetooth = new BluetoothService(context);
            ServiceManager.addService(BluetoothAdapter.BLUETOOTH_SERVICE, bluetooth);
            bluetooth.initAfterRegistration();
            if (!"0".equals(SystemProperties.get("system_init.startaudioservice"))) {
                bluetoothA2dp = new BluetoothA2dpService(context, bluetooth);
                ServiceManager.addService(BluetoothA2dpService.BLUETOOTH_A2DP_SERVICE, bluetoothA2dp);
                bluetooth.initAfterA2dpRegistration();
            }
            int bluetoothOn = Settings.Secure.getInt(mContentResolver, Settings.Secure.BLUETOOTH_ON, 0);
            if (bluetoothOn != 0) {
                bluetooth.enable();
            }
        }
    } catch (RuntimeException e) {
        Slog.e("System", "******************************************");
        Slog.e("System", "************ Failure starting core service", e);
    }
    DevicePolicyManagerService devicePolicy = null;
    StatusBarManagerService statusBar = null;
    InputMethodManagerService imm = null;
    AppWidgetService appWidget = null;
    NotificationManagerService notification = null;
    WallpaperManagerService wallpaper = null;
    LocationManagerService location = null;
    CountryDetectorService countryDetector = null;
    TextServicesManagerService tsms = null;
    LockSettingsService lockSettings = null;
    DreamManagerService dreamy = null;
    // Bring up services needed for UI.
    if (factoryTest != SystemServer.FACTORY_TEST_LOW_LEVEL) {
        try {
            Slog.i(TAG, "Input Method Service");
            imm = new InputMethodManagerService(context, wm);
            ServiceManager.addService(Context.INPUT_METHOD_SERVICE, imm);
        } catch (Throwable e) {
            reportWtf("starting Input Manager Service", e);
        }
        try {
            Slog.i(TAG, "Accessibility Manager");
            ServiceManager.addService(Context.ACCESSIBILITY_SERVICE, new AccessibilityManagerService(context));
        } catch (Throwable e) {
            reportWtf("starting Accessibility Manager", e);
        }
    }
    try {
        wm.displayReady();
    } catch (Throwable e) {
        reportWtf("making display ready", e);
    }
    try {
        pm.performBootDexOpt();
    } catch (Throwable e) {
        reportWtf("performing boot dexopt", e);
    }
    try {
        ActivityManagerNative.getDefault().showBootMessage(context.getResources().getText(com.android.internal.R.string.android_upgrading_starting_apps), false);
    } catch (RemoteException e) {
    }
    if (factoryTest != SystemServer.FACTORY_TEST_LOW_LEVEL) {
        MountService mountService = null;
        if (!"0".equals(SystemProperties.get("system_init.startmountservice"))) {
            try {
                /*
                     * NotificationManagerService is dependant on MountService,
                     * (for media / usb notifications) so we must start MountService first.
                     */
                Slog.i(TAG, "Mount Service");
                mountService = new MountService(context);
                ServiceManager.addService("mount", mountService);
            } catch (Throwable e) {
                reportWtf("starting Mount Service", e);
            }
        }
        try {
            Slog.i(TAG, "LockSettingsService");
            lockSettings = new LockSettingsService(context);
            ServiceManager.addService("lock_settings", lockSettings);
        } catch (Throwable e) {
            reportWtf("starting LockSettingsService service", e);
        }
        try {
            Slog.i(TAG, "Device Policy");
            devicePolicy = new DevicePolicyManagerService(context);
            ServiceManager.addService(Context.DEVICE_POLICY_SERVICE, devicePolicy);
        } catch (Throwable e) {
            reportWtf("starting DevicePolicyService", e);
        }
        try {
            Slog.i(TAG, "Status Bar");
            statusBar = new StatusBarManagerService(context, wm);
            ServiceManager.addService(Context.STATUS_BAR_SERVICE, statusBar);
        } catch (Throwable e) {
            reportWtf("starting StatusBarManagerService", e);
        }
        try {
            Slog.i(TAG, "Clipboard Service");
            ServiceManager.addService(Context.CLIPBOARD_SERVICE, new ClipboardService(context));
        } catch (Throwable e) {
            reportWtf("starting Clipboard Service", e);
        }
        try {
            Slog.i(TAG, "NetworkManagement Service");
            networkManagement = NetworkManagementService.create(context);
            ServiceManager.addService(Context.NETWORKMANAGEMENT_SERVICE, networkManagement);
        } catch (Throwable e) {
            reportWtf("starting NetworkManagement Service", e);
        }
        try {
            Slog.i(TAG, "Text Service Manager Service");
            tsms = new TextServicesManagerService(context);
            ServiceManager.addService(Context.TEXT_SERVICES_MANAGER_SERVICE, tsms);
        } catch (Throwable e) {
            reportWtf("starting Text Service Manager Service", e);
        }
        try {
            Slog.i(TAG, "NetworkStats Service");
            networkStats = new NetworkStatsService(context, networkManagement, alarm);
            ServiceManager.addService(Context.NETWORK_STATS_SERVICE, networkStats);
        } catch (Throwable e) {
            reportWtf("starting NetworkStats Service", e);
        }
        try {
            Slog.i(TAG, "NetworkPolicy Service");
            networkPolicy = new NetworkPolicyManagerService(context, ActivityManagerService.self(), power, networkStats, networkManagement);
            ServiceManager.addService(Context.NETWORK_POLICY_SERVICE, networkPolicy);
        } catch (Throwable e) {
            reportWtf("starting NetworkPolicy Service", e);
        }
        try {
            Slog.i(TAG, "Wi-Fi P2pService");
            wifiP2p = new WifiP2pService(context);
            ServiceManager.addService(Context.WIFI_P2P_SERVICE, wifiP2p);
        } catch (Throwable e) {
            reportWtf("starting Wi-Fi P2pService", e);
        }
        try {
            Slog.i(TAG, "Wi-Fi Service");
            wifi = new WifiService(context);
            ServiceManager.addService(Context.WIFI_SERVICE, wifi);
        } catch (Throwable e) {
            reportWtf("starting Wi-Fi Service", e);
        }
        try {
            Slog.i(TAG, "TIEthernet Service");
            ethernet = new TIEthernetService(context);
            ServiceManager.addService(Context.ETHERNET_SERVICE, ethernet);
        } catch (Throwable e) {
            reportWtf("starting TIEthernet Service", e);
        }
        try {
            Slog.i(TAG, "Connectivity Service");
            connectivity = new ConnectivityService(context, networkManagement, networkStats, networkPolicy);
            ServiceManager.addService(Context.CONNECTIVITY_SERVICE, connectivity);
            networkStats.bindConnectivityManager(connectivity);
            networkPolicy.bindConnectivityManager(connectivity);
            wifi.checkAndStartWifi();
            wifiP2p.connectivityServiceReady();
        } catch (Throwable e) {
            reportWtf("starting Connectivity Service", e);
        }
        try {
            Slog.i(TAG, "Network Service Discovery Service");
            serviceDiscovery = NsdService.create(context);
            ServiceManager.addService(Context.NSD_SERVICE, serviceDiscovery);
        } catch (Throwable e) {
            reportWtf("starting Service Discovery Service", e);
        }
        try {
            Slog.i(TAG, "Throttle Service");
            throttle = new ThrottleService(context);
            ServiceManager.addService(Context.THROTTLE_SERVICE, throttle);
        } catch (Throwable e) {
            reportWtf("starting ThrottleService", e);
        }
        try {
            Slog.i(TAG, "UpdateLock Service");
            ServiceManager.addService(Context.UPDATE_LOCK_SERVICE, new UpdateLockService(context));
        } catch (Throwable e) {
            reportWtf("starting UpdateLockService", e);
        }
        /*
             * MountService has a few dependencies: Notification Manager and
             * AppWidget Provider. Make sure MountService is completely started
             * first before continuing.
             */
        if (mountService != null) {
            mountService.waitForAsecScan();
        }
        try {
            Slog.i(TAG, "Notification Manager");
            notification = new NotificationManagerService(context, statusBar, lights);
            ServiceManager.addService(Context.NOTIFICATION_SERVICE, notification);
            networkPolicy.bindNotificationManager(notification);
        } catch (Throwable e) {
            reportWtf("starting Notification Manager", e);
        }
        try {
            Slog.i(TAG, "Device Storage Monitor");
            ServiceManager.addService(DeviceStorageMonitorService.SERVICE, new DeviceStorageMonitorService(context));
        } catch (Throwable e) {
            reportWtf("starting DeviceStorageMonitor service", e);
        }
        if (SystemProperties.OMAP_ENHANCEMENT) {
            try {
                Slog.i(TAG, "starting SUPL Service (SystemServer)");
                ServiceManager.addService("SUPL_SERVICE", SUPLService.getInstance(context));
            } catch (Throwable e) {
                Slog.e(TAG, "Failure installing SUPL Service", e);
            }
        }
        try {
            Slog.i(TAG, "Location Manager");
            location = new LocationManagerService(context);
            ServiceManager.addService(Context.LOCATION_SERVICE, location);
        } catch (Throwable e) {
            reportWtf("starting Location Manager", e);
        }
        try {
            Slog.i(TAG, "Country Detector");
            countryDetector = new CountryDetectorService(context);
            ServiceManager.addService(Context.COUNTRY_DETECTOR, countryDetector);
        } catch (Throwable e) {
            reportWtf("starting Country Detector", e);
        }
        try {
            Slog.i(TAG, "Search Service");
            ServiceManager.addService(Context.SEARCH_SERVICE, new SearchManagerService(context));
        } catch (Throwable e) {
            reportWtf("starting Search Service", e);
        }
        try {
            Slog.i(TAG, "DropBox Service");
            ServiceManager.addService(Context.DROPBOX_SERVICE, new DropBoxManagerService(context, new File("/data/system/dropbox")));
        } catch (Throwable e) {
            reportWtf("starting DropBoxManagerService", e);
        }
        if (context.getResources().getBoolean(com.android.internal.R.bool.config_enableWallpaperService)) {
            try {
                Slog.i(TAG, "Wallpaper Service");
                if (!headless) {
                    wallpaper = new WallpaperManagerService(context);
                    ServiceManager.addService(Context.WALLPAPER_SERVICE, wallpaper);
                }
            } catch (Throwable e) {
                reportWtf("starting Wallpaper Service", e);
            }
        }
        if (!"0".equals(SystemProperties.get("system_init.startaudioservice"))) {
            try {
                Slog.i(TAG, "Audio Service");
                ServiceManager.addService(Context.AUDIO_SERVICE, new AudioService(context));
            } catch (Throwable e) {
                reportWtf("starting Audio Service", e);
            }
        }
        try {
            Slog.i(TAG, "Dock Observer");
            // Listen for dock station changes
            dock = new DockObserver(context, power);
        } catch (Throwable e) {
            reportWtf("starting DockObserver", e);
        }
        try {
            Slog.i(TAG, "Wired Accessory Observer");
            // Listen for wired headset changes
            new WiredAccessoryObserver(context);
        } catch (Throwable e) {
            reportWtf("starting WiredAccessoryObserver", e);
        }
        try {
            Slog.i(TAG, "USB Service");
            // Manage USB host and device support
            usb = new UsbService(context);
            ServiceManager.addService(Context.USB_SERVICE, usb);
        } catch (Throwable e) {
            reportWtf("starting UsbService", e);
        }
        try {
            Slog.i(TAG, "Serial Service");
            // Serial port support
            serial = new SerialService(context);
            ServiceManager.addService(Context.SERIAL_SERVICE, serial);
        } catch (Throwable e) {
            Slog.e(TAG, "Failure starting SerialService", e);
        }
        try {
            Slog.i(TAG, "UI Mode Manager Service");
            // Listen for UI mode changes
            uiMode = new UiModeManagerService(context);
        } catch (Throwable e) {
            reportWtf("starting UiModeManagerService", e);
        }
        try {
            Slog.i(TAG, "Backup Service");
            ServiceManager.addService(Context.BACKUP_SERVICE, new BackupManagerService(context));
        } catch (Throwable e) {
            Slog.e(TAG, "Failure starting Backup Service", e);
        }
        try {
            Slog.i(TAG, "AppWidget Service");
            appWidget = new AppWidgetService(context);
            ServiceManager.addService(Context.APPWIDGET_SERVICE, appWidget);
        } catch (Throwable e) {
            reportWtf("starting AppWidget Service", e);
        }
        try {
            Slog.i(TAG, "Recognition Service");
            recognition = new RecognitionManagerService(context);
        } catch (Throwable e) {
            reportWtf("starting Recognition Service", e);
        }
        try {
            Slog.i(TAG, "DiskStats Service");
            ServiceManager.addService("diskstats", new DiskStatsService(context));
        } catch (Throwable e) {
            reportWtf("starting DiskStats Service", e);
        }
        try {
            // need to add this service even if SamplingProfilerIntegration.isEnabled()
            // is false, because it is this service that detects system property change and
            // turns on SamplingProfilerIntegration. Plus, when sampling profiler doesn't work,
            // there is little overhead for running this service.
            Slog.i(TAG, "SamplingProfiler Service");
            ServiceManager.addService("samplingprofiler", new SamplingProfilerService(context));
        } catch (Throwable e) {
            reportWtf("starting SamplingProfiler Service", e);
        }
        try {
            Slog.i(TAG, "NetworkTimeUpdateService");
            networkTimeUpdater = new NetworkTimeUpdateService(context);
        } catch (Throwable e) {
            reportWtf("starting NetworkTimeUpdate service", e);
        }
        try {
            Slog.i(TAG, "CommonTimeManagementService");
            commonTimeMgmtService = new CommonTimeManagementService(context);
            ServiceManager.addService("commontime_management", commonTimeMgmtService);
        } catch (Throwable e) {
            reportWtf("starting CommonTimeManagementService service", e);
        }
        try {
            Slog.i(TAG, "CertBlacklister");
            CertBlacklister blacklister = new CertBlacklister(context);
        } catch (Throwable e) {
            reportWtf("starting CertBlacklister", e);
        }
        if (context.getResources().getBoolean(com.android.internal.R.bool.config_enableDreams)) {
            try {
                Slog.i(TAG, "Dreams Service");
                // Dreams (interactive idle-time views, a/k/a screen savers)
                dreamy = new DreamManagerService(context);
                ServiceManager.addService("dreams", dreamy);
            } catch (Throwable e) {
                reportWtf("starting DreamManagerService", e);
            }
        }
    }
    // Before things start rolling, be sure we have decided whether
    // we are in safe mode.
    final boolean safeMode = wm.detectSafeMode();
    if (safeMode) {
        ActivityManagerService.self().enterSafeMode();
        // Post the safe mode state in the Zygote class
        Zygote.systemInSafeMode = true;
        // Disable the JIT for the system_server process
        VMRuntime.getRuntime().disableJitCompilation();
    } else {
        // Enable the JIT for the system_server process
        VMRuntime.getRuntime().startJitCompilation();
    }
    try {
        vibrator.systemReady();
    } catch (Throwable e) {
        reportWtf("making Vibrator Service ready", e);
    }
    if (devicePolicy != null) {
        try {
            devicePolicy.systemReady();
        } catch (Throwable e) {
            reportWtf("making Device Policy Service ready", e);
        }
    }
    if (notification != null) {
        try {
            notification.systemReady();
        } catch (Throwable e) {
            reportWtf("making Notification Service ready", e);
        }
    }
    try {
        wm.systemReady();
    } catch (Throwable e) {
        reportWtf("making Window Manager Service ready", e);
    }
    if (safeMode) {
        ActivityManagerService.self().showSafeModeOverlay();
    }
    // Update the configuration for this context by hand, because we're going
    // to start using it before the config change done in wm.systemReady() will
    // propagate to it.
    Configuration config = wm.computeNewConfiguration();
    DisplayMetrics metrics = new DisplayMetrics();
    WindowManager w = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
    w.getDefaultDisplay().getMetrics(metrics);
    context.getResources().updateConfiguration(config, metrics);
    power.systemReady();
    try {
        pm.systemReady();
    } catch (Throwable e) {
        reportWtf("making Package Manager Service ready", e);
    }
    try {
        lockSettings.systemReady();
    } catch (Throwable e) {
        reportWtf("making Lock Settings Service ready", e);
    }
    // These are needed to propagate to the runnable below.
    final Context contextF = context;
    final BatteryService batteryF = battery;
    final NetworkManagementService networkManagementF = networkManagement;
    final NetworkStatsService networkStatsF = networkStats;
    final NetworkPolicyManagerService networkPolicyF = networkPolicy;
    final ConnectivityService connectivityF = connectivity;
    final DockObserver dockF = dock;
    final UsbService usbF = usb;
    final ThrottleService throttleF = throttle;
    final UiModeManagerService uiModeF = uiMode;
    final AppWidgetService appWidgetF = appWidget;
    final WallpaperManagerService wallpaperF = wallpaper;
    final InputMethodManagerService immF = imm;
    final RecognitionManagerService recognitionF = recognition;
    final LocationManagerService locationF = location;
    final CountryDetectorService countryDetectorF = countryDetector;
    final NetworkTimeUpdateService networkTimeUpdaterF = networkTimeUpdater;
    final CommonTimeManagementService commonTimeMgmtServiceF = commonTimeMgmtService;
    final TextServicesManagerService textServiceManagerServiceF = tsms;
    final StatusBarManagerService statusBarF = statusBar;
    final DreamManagerService dreamyF = dreamy;
    final InputManagerService inputManagerF = inputManager;
    final BluetoothService bluetoothF = bluetooth;
    // We now tell the activity manager it is okay to run third party
    // code.  It will call back into us once it has gotten to the state
    // where third party code can really run (but before it has actually
    // started launching the initial applications), for us to complete our
    // initialization.
    ActivityManagerService.self().systemReady(new Runnable() {

        public void run() {
            Slog.i(TAG, "Making services ready");
            if (!headless)
                startSystemUi(contextF);
            try {
                if (batteryF != null)
                    batteryF.systemReady();
            } catch (Throwable e) {
                reportWtf("making Battery Service ready", e);
            }
            try {
                if (networkManagementF != null)
                    networkManagementF.systemReady();
            } catch (Throwable e) {
                reportWtf("making Network Managment Service ready", e);
            }
            try {
                if (networkStatsF != null)
                    networkStatsF.systemReady();
            } catch (Throwable e) {
                reportWtf("making Network Stats Service ready", e);
            }
            try {
                if (networkPolicyF != null)
                    networkPolicyF.systemReady();
            } catch (Throwable e) {
                reportWtf("making Network Policy Service ready", e);
            }
            try {
                if (connectivityF != null)
                    connectivityF.systemReady();
            } catch (Throwable e) {
                reportWtf("making Connectivity Service ready", e);
            }
            try {
                if (dockF != null)
                    dockF.systemReady();
            } catch (Throwable e) {
                reportWtf("making Dock Service ready", e);
            }
            try {
                if (usbF != null)
                    usbF.systemReady();
            } catch (Throwable e) {
                reportWtf("making USB Service ready", e);
            }
            try {
                if (uiModeF != null)
                    uiModeF.systemReady();
            } catch (Throwable e) {
                reportWtf("making UI Mode Service ready", e);
            }
            try {
                if (recognitionF != null)
                    recognitionF.systemReady();
            } catch (Throwable e) {
                reportWtf("making Recognition Service ready", e);
            }
            Watchdog.getInstance().start();
            try {
                if (appWidgetF != null)
                    appWidgetF.systemReady(safeMode);
            } catch (Throwable e) {
                reportWtf("making App Widget Service ready", e);
            }
            try {
                if (wallpaperF != null)
                    wallpaperF.systemReady();
            } catch (Throwable e) {
                reportWtf("making Wallpaper Service ready", e);
            }
            try {
                if (immF != null)
                    immF.systemReady(statusBarF);
            } catch (Throwable e) {
                reportWtf("making Input Method Service ready", e);
            }
            try {
                if (locationF != null)
                    locationF.systemReady();
            } catch (Throwable e) {
                reportWtf("making Location Service ready", e);
            }
            try {
                if (countryDetectorF != null)
                    countryDetectorF.systemReady();
            } catch (Throwable e) {
                reportWtf("making Country Detector Service ready", e);
            }
            try {
                if (throttleF != null)
                    throttleF.systemReady();
            } catch (Throwable e) {
                reportWtf("making Throttle Service ready", e);
            }
            try {
                if (networkTimeUpdaterF != null)
                    networkTimeUpdaterF.systemReady();
            } catch (Throwable e) {
                reportWtf("making Network Time Service ready", e);
            }
            try {
                if (commonTimeMgmtServiceF != null)
                    commonTimeMgmtServiceF.systemReady();
            } catch (Throwable e) {
                reportWtf("making Common time management service ready", e);
            }
            try {
                if (textServiceManagerServiceF != null)
                    textServiceManagerServiceF.systemReady();
            } catch (Throwable e) {
                reportWtf("making Text Services Manager Service ready", e);
            }
            try {
                if (dreamyF != null)
                    dreamyF.systemReady();
            } catch (Throwable e) {
                reportWtf("making DreamManagerService ready", e);
            }
            try {
                if (inputManagerF != null)
                    inputManagerF.systemReady(bluetoothF);
            } catch (Throwable e) {
                reportWtf("making InputManagerService ready", e);
            }
        }
    });
    // For debug builds, log event loop stalls to dropbox for analysis.
    if (StrictMode.conditionallyEnableDebugLogging()) {
        Slog.i(TAG, "Enabled StrictMode for system server main thread.");
    }
    Looper.loop();
    Slog.d(TAG, "System ServerThread is exiting!");
}
#method_after
@Override
public void run() {
    EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_SYSTEM_RUN, SystemClock.uptimeMillis());
    Looper.prepare();
    android.os.Process.setThreadPriority(android.os.Process.THREAD_PRIORITY_FOREGROUND);
    BinderInternal.disableBackgroundScheduling(true);
    android.os.Process.setCanSelfBackground(false);
    // Check whether we failed to shut down last time we tried.
    {
        final String shutdownAction = SystemProperties.get(ShutdownThread.SHUTDOWN_ACTION_PROPERTY, "");
        if (shutdownAction != null && shutdownAction.length() > 0) {
            boolean reboot = (shutdownAction.charAt(0) == '1');
            final String reason;
            if (shutdownAction.length() > 1) {
                reason = shutdownAction.substring(1, shutdownAction.length());
            } else {
                reason = null;
            }
            ShutdownThread.rebootOrShutdown(reboot, reason);
        }
    }
    String factoryTestStr = SystemProperties.get("ro.factorytest");
    int factoryTest = "".equals(factoryTestStr) ? SystemServer.FACTORY_TEST_OFF : Integer.parseInt(factoryTestStr);
    final boolean headless = "1".equals(SystemProperties.get("ro.config.headless", "0"));
    LightsService lights = null;
    PowerManagerService power = null;
    BatteryService battery = null;
    VibratorService vibrator = null;
    AlarmManagerService alarm = null;
    NetworkManagementService networkManagement = null;
    NetworkStatsService networkStats = null;
    NetworkPolicyManagerService networkPolicy = null;
    ConnectivityService connectivity = null;
    WifiP2pService wifiP2p = null;
    WifiService wifi = null;
    NsdService serviceDiscovery = null;
    IPackageManager pm = null;
    Context context = null;
    WindowManagerService wm = null;
    BluetoothService bluetooth = null;
    BluetoothA2dpService bluetoothA2dp = null;
    // BLUETI_ENHANCEMENT
    BluetoothGattClientService bluetoothGattClient = null;
    // BLUETI_ENHANCEMENT
    BluetoothGattServerService bluetoothGattServer = null;
    DockObserver dock = null;
    UsbService usb = null;
    SerialService serial = null;
    UiModeManagerService uiMode = null;
    RecognitionManagerService recognition = null;
    ThrottleService throttle = null;
    NetworkTimeUpdateService networkTimeUpdater = null;
    CommonTimeManagementService commonTimeMgmtService = null;
    InputManagerService inputManager = null;
    TIEthernetService ethernet = null;
    // Critical services...
    try {
        Slog.i(TAG, "Entropy Mixer");
        ServiceManager.addService("entropy", new EntropyMixer());
        Slog.i(TAG, "Power Manager");
        power = new PowerManagerService();
        ServiceManager.addService(Context.POWER_SERVICE, power);
        Slog.i(TAG, "Activity Manager");
        context = ActivityManagerService.main(factoryTest);
        Slog.i(TAG, "Telephony Registry");
        ServiceManager.addService("telephony.registry", new TelephonyRegistry(context));
        Slog.i(TAG, "Scheduling Policy");
        ServiceManager.addService(Context.SCHEDULING_POLICY_SERVICE, new SchedulingPolicyService());
        AttributeCache.init(context);
        Slog.i(TAG, "Package Manager");
        // Only run "core" apps if we're encrypting the device.
        String cryptState = SystemProperties.get("vold.decrypt");
        boolean onlyCore = false;
        if (ENCRYPTING_STATE.equals(cryptState)) {
            Slog.w(TAG, "Detected encryption in progress - only parsing core apps");
            onlyCore = true;
        } else if (ENCRYPTED_STATE.equals(cryptState)) {
            Slog.w(TAG, "Device encrypted - only parsing core apps");
            onlyCore = true;
        }
        pm = PackageManagerService.main(context, factoryTest != SystemServer.FACTORY_TEST_OFF, onlyCore);
        boolean firstBoot = false;
        try {
            firstBoot = pm.isFirstBoot();
        } catch (RemoteException e) {
        }
        ActivityManagerService.setSystemProcess();
        mContentResolver = context.getContentResolver();
        // The AccountManager must come before the ContentService
        try {
            Slog.i(TAG, "Account Manager");
            ServiceManager.addService(Context.ACCOUNT_SERVICE, new AccountManagerService(context));
        } catch (Throwable e) {
            Slog.e(TAG, "Failure starting Account Manager", e);
        }
        Slog.i(TAG, "Content Manager");
        ContentService.main(context, factoryTest == SystemServer.FACTORY_TEST_LOW_LEVEL);
        Slog.i(TAG, "System Content Providers");
        ActivityManagerService.installSystemProviders();
        Slog.i(TAG, "Lights Service");
        lights = new LightsService(context);
        Slog.i(TAG, "Battery Service");
        battery = new BatteryService(context, lights);
        ServiceManager.addService("battery", battery);
        Slog.i(TAG, "Vibrator Service");
        vibrator = new VibratorService(context);
        ServiceManager.addService("vibrator", vibrator);
        // only initialize the power service after we have started the
        // lights service, content providers and the battery service.
        power.init(context, lights, ActivityManagerService.self(), battery);
        Slog.i(TAG, "Alarm Manager");
        alarm = new AlarmManagerService(context);
        ServiceManager.addService(Context.ALARM_SERVICE, alarm);
        Slog.i(TAG, "Init Watchdog");
        Watchdog.getInstance().init(context, battery, power, alarm, ActivityManagerService.self());
        Slog.i(TAG, "Window Manager");
        wm = WindowManagerService.main(context, power, factoryTest != SystemServer.FACTORY_TEST_LOW_LEVEL, !firstBoot, onlyCore);
        ServiceManager.addService(Context.WINDOW_SERVICE, wm);
        inputManager = wm.getInputManagerService();
        ServiceManager.addService(Context.INPUT_SERVICE, inputManager);
        ActivityManagerService.self().setWindowManager(wm);
        // support Bluetooth - see bug 988521
        if (SystemProperties.get("ro.kernel.qemu").equals("1")) {
            Slog.i(TAG, "No Bluetooh Service (emulator)");
        } else if (factoryTest == SystemServer.FACTORY_TEST_LOW_LEVEL) {
            Slog.i(TAG, "No Bluetooth Service (factory test)");
        } else {
            Slog.i(TAG, "Bluetooth Service");
            bluetooth = new BluetoothService(context);
            ServiceManager.addService(BluetoothAdapter.BLUETOOTH_SERVICE, bluetooth);
            bluetooth.initAfterRegistration();
            if (!"0".equals(SystemProperties.get("system_init.startaudioservice"))) {
                bluetoothA2dp = new BluetoothA2dpService(context, bluetooth);
                ServiceManager.addService(BluetoothA2dpService.BLUETOOTH_A2DP_SERVICE, bluetoothA2dp);
                bluetooth.initAfterA2dpRegistration();
            }
            // bluetoothGattClient = new BluetoothGattClientService(context, bluetooth);
            if (SystemProperties.BLUETI_ENHANCEMENT) {
                bluetoothGattClient = new BluetoothGattClientService(context, bluetooth);
                ServiceManager.addService(BluetoothGattClientService.BLUETOOTH_GATTCLIENT_SERVICE, bluetoothGattClient);
            }
            if (SystemProperties.BLUETI_ENHANCEMENT) {
                // BLUETI_ENHANCEMENT
                bluetoothGattServer = new BluetoothGattServerService(context, bluetooth);
                ServiceManager.addService(BluetoothGattServerService.BLUETOOTH_GATTSERVER_SERVICE, bluetoothGattServer);
            }
            int bluetoothOn = Settings.Secure.getInt(mContentResolver, Settings.Secure.BLUETOOTH_ON, 0);
            if (bluetoothOn != 0) {
                bluetooth.enable();
            }
        }
    } catch (RuntimeException e) {
        Slog.e("System", "******************************************");
        Slog.e("System", "************ Failure starting core service", e);
    }
    DevicePolicyManagerService devicePolicy = null;
    StatusBarManagerService statusBar = null;
    InputMethodManagerService imm = null;
    AppWidgetService appWidget = null;
    NotificationManagerService notification = null;
    WallpaperManagerService wallpaper = null;
    LocationManagerService location = null;
    CountryDetectorService countryDetector = null;
    TextServicesManagerService tsms = null;
    LockSettingsService lockSettings = null;
    DreamManagerService dreamy = null;
    // Bring up services needed for UI.
    if (factoryTest != SystemServer.FACTORY_TEST_LOW_LEVEL) {
        try {
            Slog.i(TAG, "Input Method Service");
            imm = new InputMethodManagerService(context, wm);
            ServiceManager.addService(Context.INPUT_METHOD_SERVICE, imm);
        } catch (Throwable e) {
            reportWtf("starting Input Manager Service", e);
        }
        try {
            Slog.i(TAG, "Accessibility Manager");
            ServiceManager.addService(Context.ACCESSIBILITY_SERVICE, new AccessibilityManagerService(context));
        } catch (Throwable e) {
            reportWtf("starting Accessibility Manager", e);
        }
    }
    try {
        wm.displayReady();
    } catch (Throwable e) {
        reportWtf("making display ready", e);
    }
    try {
        pm.performBootDexOpt();
    } catch (Throwable e) {
        reportWtf("performing boot dexopt", e);
    }
    try {
        ActivityManagerNative.getDefault().showBootMessage(context.getResources().getText(com.android.internal.R.string.android_upgrading_starting_apps), false);
    } catch (RemoteException e) {
    }
    if (factoryTest != SystemServer.FACTORY_TEST_LOW_LEVEL) {
        MountService mountService = null;
        if (!"0".equals(SystemProperties.get("system_init.startmountservice"))) {
            try {
                /*
                     * NotificationManagerService is dependant on MountService,
                     * (for media / usb notifications) so we must start MountService first.
                     */
                Slog.i(TAG, "Mount Service");
                mountService = new MountService(context);
                ServiceManager.addService("mount", mountService);
            } catch (Throwable e) {
                reportWtf("starting Mount Service", e);
            }
        }
        try {
            Slog.i(TAG, "LockSettingsService");
            lockSettings = new LockSettingsService(context);
            ServiceManager.addService("lock_settings", lockSettings);
        } catch (Throwable e) {
            reportWtf("starting LockSettingsService service", e);
        }
        try {
            Slog.i(TAG, "Device Policy");
            devicePolicy = new DevicePolicyManagerService(context);
            ServiceManager.addService(Context.DEVICE_POLICY_SERVICE, devicePolicy);
        } catch (Throwable e) {
            reportWtf("starting DevicePolicyService", e);
        }
        try {
            Slog.i(TAG, "Status Bar");
            statusBar = new StatusBarManagerService(context, wm);
            ServiceManager.addService(Context.STATUS_BAR_SERVICE, statusBar);
        } catch (Throwable e) {
            reportWtf("starting StatusBarManagerService", e);
        }
        try {
            Slog.i(TAG, "Clipboard Service");
            ServiceManager.addService(Context.CLIPBOARD_SERVICE, new ClipboardService(context));
        } catch (Throwable e) {
            reportWtf("starting Clipboard Service", e);
        }
        try {
            Slog.i(TAG, "NetworkManagement Service");
            networkManagement = NetworkManagementService.create(context);
            ServiceManager.addService(Context.NETWORKMANAGEMENT_SERVICE, networkManagement);
        } catch (Throwable e) {
            reportWtf("starting NetworkManagement Service", e);
        }
        try {
            Slog.i(TAG, "Text Service Manager Service");
            tsms = new TextServicesManagerService(context);
            ServiceManager.addService(Context.TEXT_SERVICES_MANAGER_SERVICE, tsms);
        } catch (Throwable e) {
            reportWtf("starting Text Service Manager Service", e);
        }
        try {
            Slog.i(TAG, "NetworkStats Service");
            networkStats = new NetworkStatsService(context, networkManagement, alarm);
            ServiceManager.addService(Context.NETWORK_STATS_SERVICE, networkStats);
        } catch (Throwable e) {
            reportWtf("starting NetworkStats Service", e);
        }
        try {
            Slog.i(TAG, "NetworkPolicy Service");
            networkPolicy = new NetworkPolicyManagerService(context, ActivityManagerService.self(), power, networkStats, networkManagement);
            ServiceManager.addService(Context.NETWORK_POLICY_SERVICE, networkPolicy);
        } catch (Throwable e) {
            reportWtf("starting NetworkPolicy Service", e);
        }
        try {
            Slog.i(TAG, "Wi-Fi P2pService");
            wifiP2p = new WifiP2pService(context);
            ServiceManager.addService(Context.WIFI_P2P_SERVICE, wifiP2p);
        } catch (Throwable e) {
            reportWtf("starting Wi-Fi P2pService", e);
        }
        try {
            Slog.i(TAG, "Wi-Fi Service");
            wifi = new WifiService(context);
            ServiceManager.addService(Context.WIFI_SERVICE, wifi);
        } catch (Throwable e) {
            reportWtf("starting Wi-Fi Service", e);
        }
        if (SystemProperties.OMAP_ENHANCEMENT) {
            try {
                Slog.i(TAG, "TIEthernet Service");
                ethernet = new TIEthernetService(context);
                ServiceManager.addService(Context.ETHERNET_SERVICE, ethernet);
            } catch (Throwable e) {
                reportWtf("starting TIEthernet Service", e);
            }
        }
        try {
            Slog.i(TAG, "Connectivity Service");
            connectivity = new ConnectivityService(context, networkManagement, networkStats, networkPolicy);
            ServiceManager.addService(Context.CONNECTIVITY_SERVICE, connectivity);
            networkStats.bindConnectivityManager(connectivity);
            networkPolicy.bindConnectivityManager(connectivity);
            wifi.checkAndStartWifi();
            wifiP2p.connectivityServiceReady();
        } catch (Throwable e) {
            reportWtf("starting Connectivity Service", e);
        }
        try {
            Slog.i(TAG, "Network Service Discovery Service");
            serviceDiscovery = NsdService.create(context);
            ServiceManager.addService(Context.NSD_SERVICE, serviceDiscovery);
        } catch (Throwable e) {
            reportWtf("starting Service Discovery Service", e);
        }
        try {
            Slog.i(TAG, "Throttle Service");
            throttle = new ThrottleService(context);
            ServiceManager.addService(Context.THROTTLE_SERVICE, throttle);
        } catch (Throwable e) {
            reportWtf("starting ThrottleService", e);
        }
        try {
            Slog.i(TAG, "UpdateLock Service");
            ServiceManager.addService(Context.UPDATE_LOCK_SERVICE, new UpdateLockService(context));
        } catch (Throwable e) {
            reportWtf("starting UpdateLockService", e);
        }
        /*
             * MountService has a few dependencies: Notification Manager and
             * AppWidget Provider. Make sure MountService is completely started
             * first before continuing.
             */
        if (mountService != null) {
            mountService.waitForAsecScan();
        }
        try {
            Slog.i(TAG, "Notification Manager");
            notification = new NotificationManagerService(context, statusBar, lights);
            ServiceManager.addService(Context.NOTIFICATION_SERVICE, notification);
            networkPolicy.bindNotificationManager(notification);
        } catch (Throwable e) {
            reportWtf("starting Notification Manager", e);
        }
        try {
            Slog.i(TAG, "Device Storage Monitor");
            ServiceManager.addService(DeviceStorageMonitorService.SERVICE, new DeviceStorageMonitorService(context));
        } catch (Throwable e) {
            reportWtf("starting DeviceStorageMonitor service", e);
        }
        if (SystemProperties.OMAP_ENHANCEMENT) {
            try {
                Slog.i(TAG, "starting SUPL Service (SystemServer)");
                ServiceManager.addService("SUPL_SERVICE", SUPLService.getInstance(context));
            } catch (Throwable e) {
                Slog.e(TAG, "Failure installing SUPL Service", e);
            }
        }
        try {
            Slog.i(TAG, "Location Manager");
            location = new LocationManagerService(context);
            ServiceManager.addService(Context.LOCATION_SERVICE, location);
        } catch (Throwable e) {
            reportWtf("starting Location Manager", e);
        }
        try {
            Slog.i(TAG, "Country Detector");
            countryDetector = new CountryDetectorService(context);
            ServiceManager.addService(Context.COUNTRY_DETECTOR, countryDetector);
        } catch (Throwable e) {
            reportWtf("starting Country Detector", e);
        }
        try {
            Slog.i(TAG, "Search Service");
            ServiceManager.addService(Context.SEARCH_SERVICE, new SearchManagerService(context));
        } catch (Throwable e) {
            reportWtf("starting Search Service", e);
        }
        try {
            Slog.i(TAG, "DropBox Service");
            ServiceManager.addService(Context.DROPBOX_SERVICE, new DropBoxManagerService(context, new File("/data/system/dropbox")));
        } catch (Throwable e) {
            reportWtf("starting DropBoxManagerService", e);
        }
        if (context.getResources().getBoolean(com.android.internal.R.bool.config_enableWallpaperService)) {
            try {
                Slog.i(TAG, "Wallpaper Service");
                if (!headless) {
                    wallpaper = new WallpaperManagerService(context);
                    ServiceManager.addService(Context.WALLPAPER_SERVICE, wallpaper);
                }
            } catch (Throwable e) {
                reportWtf("starting Wallpaper Service", e);
            }
        }
        if (!"0".equals(SystemProperties.get("system_init.startaudioservice"))) {
            try {
                Slog.i(TAG, "Audio Service");
                ServiceManager.addService(Context.AUDIO_SERVICE, new AudioService(context));
            } catch (Throwable e) {
                reportWtf("starting Audio Service", e);
            }
        }
        try {
            Slog.i(TAG, "Dock Observer");
            // Listen for dock station changes
            dock = new DockObserver(context, power);
        } catch (Throwable e) {
            reportWtf("starting DockObserver", e);
        }
        try {
            Slog.i(TAG, "Wired Accessory Observer");
            // Listen for wired headset changes
            new WiredAccessoryObserver(context);
        } catch (Throwable e) {
            reportWtf("starting WiredAccessoryObserver", e);
        }
        try {
            Slog.i(TAG, "USB Service");
            // Manage USB host and device support
            usb = new UsbService(context);
            ServiceManager.addService(Context.USB_SERVICE, usb);
        } catch (Throwable e) {
            reportWtf("starting UsbService", e);
        }
        try {
            Slog.i(TAG, "Serial Service");
            // Serial port support
            serial = new SerialService(context);
            ServiceManager.addService(Context.SERIAL_SERVICE, serial);
        } catch (Throwable e) {
            Slog.e(TAG, "Failure starting SerialService", e);
        }
        try {
            Slog.i(TAG, "UI Mode Manager Service");
            // Listen for UI mode changes
            uiMode = new UiModeManagerService(context);
        } catch (Throwable e) {
            reportWtf("starting UiModeManagerService", e);
        }
        try {
            Slog.i(TAG, "Backup Service");
            ServiceManager.addService(Context.BACKUP_SERVICE, new BackupManagerService(context));
        } catch (Throwable e) {
            Slog.e(TAG, "Failure starting Backup Service", e);
        }
        try {
            Slog.i(TAG, "AppWidget Service");
            appWidget = new AppWidgetService(context);
            ServiceManager.addService(Context.APPWIDGET_SERVICE, appWidget);
        } catch (Throwable e) {
            reportWtf("starting AppWidget Service", e);
        }
        try {
            Slog.i(TAG, "Recognition Service");
            recognition = new RecognitionManagerService(context);
        } catch (Throwable e) {
            reportWtf("starting Recognition Service", e);
        }
        try {
            Slog.i(TAG, "DiskStats Service");
            ServiceManager.addService("diskstats", new DiskStatsService(context));
        } catch (Throwable e) {
            reportWtf("starting DiskStats Service", e);
        }
        try {
            // need to add this service even if SamplingProfilerIntegration.isEnabled()
            // is false, because it is this service that detects system property change and
            // turns on SamplingProfilerIntegration. Plus, when sampling profiler doesn't work,
            // there is little overhead for running this service.
            Slog.i(TAG, "SamplingProfiler Service");
            ServiceManager.addService("samplingprofiler", new SamplingProfilerService(context));
        } catch (Throwable e) {
            reportWtf("starting SamplingProfiler Service", e);
        }
        try {
            Slog.i(TAG, "NetworkTimeUpdateService");
            networkTimeUpdater = new NetworkTimeUpdateService(context);
        } catch (Throwable e) {
            reportWtf("starting NetworkTimeUpdate service", e);
        }
        try {
            Slog.i(TAG, "CommonTimeManagementService");
            commonTimeMgmtService = new CommonTimeManagementService(context);
            ServiceManager.addService("commontime_management", commonTimeMgmtService);
        } catch (Throwable e) {
            reportWtf("starting CommonTimeManagementService service", e);
        }
        try {
            Slog.i(TAG, "CertBlacklister");
            CertBlacklister blacklister = new CertBlacklister(context);
        } catch (Throwable e) {
            reportWtf("starting CertBlacklister", e);
        }
        if (context.getResources().getBoolean(com.android.internal.R.bool.config_enableDreams)) {
            try {
                Slog.i(TAG, "Dreams Service");
                // Dreams (interactive idle-time views, a/k/a screen savers)
                dreamy = new DreamManagerService(context);
                ServiceManager.addService("dreams", dreamy);
            } catch (Throwable e) {
                reportWtf("starting DreamManagerService", e);
            }
        }
    }
    // Before things start rolling, be sure we have decided whether
    // we are in safe mode.
    final boolean safeMode = wm.detectSafeMode();
    if (safeMode) {
        ActivityManagerService.self().enterSafeMode();
        // Post the safe mode state in the Zygote class
        Zygote.systemInSafeMode = true;
        // Disable the JIT for the system_server process
        VMRuntime.getRuntime().disableJitCompilation();
    } else {
        // Enable the JIT for the system_server process
        VMRuntime.getRuntime().startJitCompilation();
    }
    try {
        vibrator.systemReady();
    } catch (Throwable e) {
        reportWtf("making Vibrator Service ready", e);
    }
    if (devicePolicy != null) {
        try {
            devicePolicy.systemReady();
        } catch (Throwable e) {
            reportWtf("making Device Policy Service ready", e);
        }
    }
    if (notification != null) {
        try {
            notification.systemReady();
        } catch (Throwable e) {
            reportWtf("making Notification Service ready", e);
        }
    }
    try {
        wm.systemReady();
    } catch (Throwable e) {
        reportWtf("making Window Manager Service ready", e);
    }
    if (safeMode) {
        ActivityManagerService.self().showSafeModeOverlay();
    }
    // Update the configuration for this context by hand, because we're going
    // to start using it before the config change done in wm.systemReady() will
    // propagate to it.
    Configuration config = wm.computeNewConfiguration();
    DisplayMetrics metrics = new DisplayMetrics();
    WindowManager w = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
    w.getDefaultDisplay().getMetrics(metrics);
    context.getResources().updateConfiguration(config, metrics);
    power.systemReady();
    try {
        pm.systemReady();
    } catch (Throwable e) {
        reportWtf("making Package Manager Service ready", e);
    }
    try {
        lockSettings.systemReady();
    } catch (Throwable e) {
        reportWtf("making Lock Settings Service ready", e);
    }
    // These are needed to propagate to the runnable below.
    final Context contextF = context;
    final BatteryService batteryF = battery;
    final NetworkManagementService networkManagementF = networkManagement;
    final NetworkStatsService networkStatsF = networkStats;
    final NetworkPolicyManagerService networkPolicyF = networkPolicy;
    final ConnectivityService connectivityF = connectivity;
    final DockObserver dockF = dock;
    final UsbService usbF = usb;
    final ThrottleService throttleF = throttle;
    final UiModeManagerService uiModeF = uiMode;
    final AppWidgetService appWidgetF = appWidget;
    final WallpaperManagerService wallpaperF = wallpaper;
    final InputMethodManagerService immF = imm;
    final RecognitionManagerService recognitionF = recognition;
    final LocationManagerService locationF = location;
    final CountryDetectorService countryDetectorF = countryDetector;
    final NetworkTimeUpdateService networkTimeUpdaterF = networkTimeUpdater;
    final CommonTimeManagementService commonTimeMgmtServiceF = commonTimeMgmtService;
    final TextServicesManagerService textServiceManagerServiceF = tsms;
    final StatusBarManagerService statusBarF = statusBar;
    final DreamManagerService dreamyF = dreamy;
    final InputManagerService inputManagerF = inputManager;
    final BluetoothService bluetoothF = bluetooth;
    // We now tell the activity manager it is okay to run third party
    // code.  It will call back into us once it has gotten to the state
    // where third party code can really run (but before it has actually
    // started launching the initial applications), for us to complete our
    // initialization.
    ActivityManagerService.self().systemReady(new Runnable() {

        public void run() {
            Slog.i(TAG, "Making services ready");
            if (!headless)
                startSystemUi(contextF);
            try {
                if (batteryF != null)
                    batteryF.systemReady();
            } catch (Throwable e) {
                reportWtf("making Battery Service ready", e);
            }
            try {
                if (networkManagementF != null)
                    networkManagementF.systemReady();
            } catch (Throwable e) {
                reportWtf("making Network Managment Service ready", e);
            }
            try {
                if (networkStatsF != null)
                    networkStatsF.systemReady();
            } catch (Throwable e) {
                reportWtf("making Network Stats Service ready", e);
            }
            try {
                if (networkPolicyF != null)
                    networkPolicyF.systemReady();
            } catch (Throwable e) {
                reportWtf("making Network Policy Service ready", e);
            }
            try {
                if (connectivityF != null)
                    connectivityF.systemReady();
            } catch (Throwable e) {
                reportWtf("making Connectivity Service ready", e);
            }
            try {
                if (dockF != null)
                    dockF.systemReady();
            } catch (Throwable e) {
                reportWtf("making Dock Service ready", e);
            }
            try {
                if (usbF != null)
                    usbF.systemReady();
            } catch (Throwable e) {
                reportWtf("making USB Service ready", e);
            }
            try {
                if (uiModeF != null)
                    uiModeF.systemReady();
            } catch (Throwable e) {
                reportWtf("making UI Mode Service ready", e);
            }
            try {
                if (recognitionF != null)
                    recognitionF.systemReady();
            } catch (Throwable e) {
                reportWtf("making Recognition Service ready", e);
            }
            Watchdog.getInstance().start();
            try {
                if (appWidgetF != null)
                    appWidgetF.systemReady(safeMode);
            } catch (Throwable e) {
                reportWtf("making App Widget Service ready", e);
            }
            try {
                if (wallpaperF != null)
                    wallpaperF.systemReady();
            } catch (Throwable e) {
                reportWtf("making Wallpaper Service ready", e);
            }
            try {
                if (immF != null)
                    immF.systemReady(statusBarF);
            } catch (Throwable e) {
                reportWtf("making Input Method Service ready", e);
            }
            try {
                if (locationF != null)
                    locationF.systemReady();
            } catch (Throwable e) {
                reportWtf("making Location Service ready", e);
            }
            try {
                if (countryDetectorF != null)
                    countryDetectorF.systemReady();
            } catch (Throwable e) {
                reportWtf("making Country Detector Service ready", e);
            }
            try {
                if (throttleF != null)
                    throttleF.systemReady();
            } catch (Throwable e) {
                reportWtf("making Throttle Service ready", e);
            }
            try {
                if (networkTimeUpdaterF != null)
                    networkTimeUpdaterF.systemReady();
            } catch (Throwable e) {
                reportWtf("making Network Time Service ready", e);
            }
            try {
                if (commonTimeMgmtServiceF != null)
                    commonTimeMgmtServiceF.systemReady();
            } catch (Throwable e) {
                reportWtf("making Common time management service ready", e);
            }
            try {
                if (textServiceManagerServiceF != null)
                    textServiceManagerServiceF.systemReady();
            } catch (Throwable e) {
                reportWtf("making Text Services Manager Service ready", e);
            }
            try {
                if (dreamyF != null)
                    dreamyF.systemReady();
            } catch (Throwable e) {
                reportWtf("making DreamManagerService ready", e);
            }
            try {
                if (inputManagerF != null)
                    inputManagerF.systemReady(bluetoothF);
            } catch (Throwable e) {
                reportWtf("making InputManagerService ready", e);
            }
        }
    });
    // For debug builds, log event loop stalls to dropbox for analysis.
    if (StrictMode.conditionallyEnableDebugLogging()) {
        Slog.i(TAG, "Enabled StrictMode for system server main thread.");
    }
    Looper.loop();
    Slog.d(TAG, "System ServerThread is exiting!");
}
#end_block

#method_before
@Override
public String toString() {
    StringBuilder sbuf = new StringBuilder();
    sbuf.append("Interface name: ").append(this.ifaceName).append('\n');
    sbuf.append("Interface address : ").append(null == this.ifaceAddress ? "NONE" : this.ifaceAddress.toString()).append('\n');
    sbuf.append("Prefix length: ").append(this.prefixLength).append("\n");
    sbuf.append("IP assignment: ").append(ipAssignment.toString()).append("\n");
    sbuf.append("Gateway: ").append(null == this.gateway ? "NONE" : gateway.toString()).append("\n");
    sbuf.append("DNS addresses: ").append(DNSaddresses.size() == 0 ? "NONE" : "").append("\n");
    for (InetAddress addr : DNSaddresses) {
        sbuf.append("   ").append(addr).append("\n");
    }
    return sbuf.toString();
}
#method_after
@Override
public String toString() {
    StringBuilder sbuilder = new StringBuilder();
    sbuilder.append("Interface name: ").append(this.ifaceName).append('\n');
    sbuilder.append("Interface address : ").append(null == this.ifaceAddress ? "NONE" : this.ifaceAddress.toString()).append('\n');
    sbuilder.append("Prefix length: ").append(this.prefixLength).append("\n");
    sbuilder.append("IP assignment: ").append(ipAssignment.toString()).append("\n");
    sbuilder.append("Gateway: ").append(null == this.gateway ? "NONE" : gateway.toString()).append("\n");
    sbuilder.append("DNS addresses: ").append(DNSaddresses.size() == 0 ? "NONE" : "").append("\n");
    for (InetAddress addr : DNSaddresses) {
        sbuilder.append("   ").append(addr).append("\n");
    }
    return sbuilder.toString();
}
#end_block

#method_before
public void setEthernetState(boolean state) {
    if (mIsEthernetEnabled == state) {
        return;
    }
    mIsEthernetEnabled = state;
    List<String> ifaces = mEthMonitor.getEthIfacesList();
    String lastPluggedIface = null;
    for (String ifacename : ifaces) {
        lastPluggedIface = ifacename;
    }
    if (state) {
        Log.d(TAG, "Start Monitoring ethernet state changed");
        mEthMonitor.startMonitoring();
    } else {
        Log.d(TAG, "Stop Monitoring ethernet state changed");
        mEthMonitor.stopMonitoring();
    }
    if (state && null != lastPluggedIface) {
        // Setting UP last plugged ethernet interface
        if (EthernetConfigStore.isInterfaceConfigured(lastPluggedIface)) {
            try {
                // we don't get link status indications unless the iface is up - bring it up
                Log.d(TAG, "Setting up " + lastPluggedIface + " ethernet interface");
                mNMService.setInterfaceUp(lastPluggedIface);
                InterfaceConfiguration config = mNMService.getInterfaceConfig(lastPluggedIface);
                if (config != null && mHwAddr == null) {
                    mHwAddr = config.getHardwareAddress();
                }
            } catch (RemoteException e) {
                Log.e(TAG, "Cant set interface UP - " + lastPluggedIface, e);
            }
        } else {
            Log.d(TAG, "Interface " + lastPluggedIface + " did not configured");
        }
    } else if (!state && null != lastPluggedIface) {
        // Setting DOWN last plugged ethernet interface
        if (EthernetConfigStore.isInterfaceConfigured(lastPluggedIface)) {
            try {
                Log.d(TAG, "Setting down " + lastPluggedIface + " ethernet interface");
                mNMService.setInterfaceDown(lastPluggedIface);
                InterfaceConfiguration config = mNMService.getInterfaceConfig(lastPluggedIface);
                if (config != null && config.isActive()) {
                    Log.e(TAG, "Cant set interface to DOWN - " + lastPluggedIface);
                }
            } catch (RemoteException e) {
                Log.e(TAG, "Cant set interface to DOWN - " + lastPluggedIface, e);
            }
        } else {
            Log.d(TAG, "Interface " + lastPluggedIface + " did not configured");
        }
    }
    sendGlobalStateChangeBroadcast();
}
#method_after
public void setEthernetState(boolean state) {
    if (mIsEthernetEnabled == state) {
        return;
    }
    mIsEthernetEnabled = state;
    List<String> ifaces = mEthMonitor.getEthIfacesList();
    String lastPluggedIface = null;
    for (String ifacename : ifaces) {
        lastPluggedIface = ifacename;
    }
    if (state) {
        mEthMonitor.startMonitoring();
    } else {
        mEthMonitor.stopMonitoring();
    }
    sendGlobalStateChangeBroadcast();
    if (state && null != lastPluggedIface) {
        // Setting UP last plugged ethernet interface
        if (EthernetConfigStore.isInterfaceConfigured(lastPluggedIface)) {
            try {
                // we don't get link status indications unless the iface is up - bring it up
                Log.d(TAG, "Setting up " + lastPluggedIface + " ethernet interface");
                mNMService.setInterfaceUp(lastPluggedIface);
                InterfaceConfiguration config = mNMService.getInterfaceConfig(lastPluggedIface);
                if (config != null && mHwAddr == null) {
                    mHwAddr = config.getHardwareAddress();
                }
            } catch (RemoteException e) {
                Log.e(TAG, "Cant set interface UP - " + lastPluggedIface, e);
            }
        } else {
            Log.d(TAG, "Interface " + lastPluggedIface + " did not configured");
        }
    } else if (!state && null != lastPluggedIface) {
        // Setting DOWN last plugged ethernet interface
        if (EthernetConfigStore.isInterfaceConfigured(lastPluggedIface)) {
            try {
                Log.d(TAG, "Setting down " + lastPluggedIface + " ethernet interface");
                mNMService.setInterfaceDown(lastPluggedIface);
                InterfaceConfiguration config = mNMService.getInterfaceConfig(lastPluggedIface);
                if (config != null && config.isActive()) {
                    Log.e(TAG, "Cant set interface to DOWN - " + lastPluggedIface);
                }
            } catch (RemoteException e) {
                Log.e(TAG, "Cant set interface to DOWN - " + lastPluggedIface, e);
            }
        } else {
            Log.d(TAG, "Interface " + lastPluggedIface + " did not configured");
        }
    }
}
#end_block

#method_before
@Override
protected void onAttachedToWindow() {
    super.onAttachedToWindow();
    mWifiGroup = (ViewGroup) findViewById(R.id.wifi_combo);
    mWifi = (ImageView) findViewById(R.id.wifi_signal);
    mWifiActivity = (ImageView) findViewById(R.id.wifi_inout);
    mMobileGroup = (ViewGroup) findViewById(R.id.mobile_combo);
    mMobile = (ImageView) findViewById(R.id.mobile_signal);
    mMobileActivity = (ImageView) findViewById(R.id.mobile_inout);
    mMobileType = (ImageView) findViewById(R.id.mobile_type);
    mSpacer = findViewById(R.id.spacer);
    mAirplane = (ImageView) findViewById(R.id.airplane);
    mSpacer1 = findViewById(R.id.spacer1);
    mEthernet = (ImageView) findViewById(R.id.ethernet_status_icon);
    apply();
}
#method_after
@Override
protected void onAttachedToWindow() {
    super.onAttachedToWindow();
    mWifiGroup = (ViewGroup) findViewById(R.id.wifi_combo);
    mWifi = (ImageView) findViewById(R.id.wifi_signal);
    mWifiActivity = (ImageView) findViewById(R.id.wifi_inout);
    mMobileGroup = (ViewGroup) findViewById(R.id.mobile_combo);
    mMobile = (ImageView) findViewById(R.id.mobile_signal);
    mMobileActivity = (ImageView) findViewById(R.id.mobile_inout);
    mMobileType = (ImageView) findViewById(R.id.mobile_type);
    mSpacer = findViewById(R.id.spacer);
    mAirplane = (ImageView) findViewById(R.id.airplane);
    if (SystemProperties.OMAP_ENHANCEMENT) {
        mSpacer1 = findViewById(R.id.spacer1);
        mEthernet = (ImageView) findViewById(R.id.ethernet_status_icon);
    }
    apply();
}
#end_block

#method_before
@Override
protected void onDetachedFromWindow() {
    mWifiGroup = null;
    mWifi = null;
    mWifiActivity = null;
    mMobileGroup = null;
    mMobile = null;
    mMobileActivity = null;
    mMobileType = null;
    mSpacer = null;
    mAirplane = null;
    mSpacer1 = null;
    mEthernet = null;
    super.onDetachedFromWindow();
}
#method_after
@Override
protected void onDetachedFromWindow() {
    mWifiGroup = null;
    mWifi = null;
    mWifiActivity = null;
    mMobileGroup = null;
    mMobile = null;
    mMobileActivity = null;
    mMobileType = null;
    mSpacer = null;
    mAirplane = null;
    if (SystemProperties.OMAP_ENHANCEMENT) {
        mSpacer1 = null;
        mEthernet = null;
    }
    super.onDetachedFromWindow();
}
#end_block

#method_before
@Override
public void setIsEthernetConnected(boolean is, int ethIconId) {
    mIsEthernetConnected = is;
    mEthStatusIconId = ethIconId;
    apply();
}
#method_after
@Override
public void setIsEthernetConnected(boolean is, int ethIconId) {
    if (SystemProperties.OMAP_ENHANCEMENT) {
        mIsEthernetConnected = is;
        mEthStatusIconId = ethIconId;
        apply();
    } else {
        // Empty implementation for nonOMAP. Just removing warnings
        is = is;
        ethIconId = ethIconId;
    }
}
#end_block

#method_before
private void apply() {
    if (mWifiGroup == null)
        return;
    if (mWifiVisible) {
        mWifiGroup.setVisibility(View.VISIBLE);
        mWifi.setImageResource(mWifiStrengthId);
        mWifiActivity.setImageResource(mWifiActivityId);
        mWifiGroup.setContentDescription(mWifiDescription);
    } else {
        mWifiGroup.setVisibility(View.GONE);
    }
    if (DEBUG)
        Slog.d(TAG, String.format("wifi: %s sig=%d act=%d", (mWifiVisible ? "VISIBLE" : "GONE"), mWifiStrengthId, mWifiActivityId));
    if (mMobileVisible && !mIsAirplaneMode) {
        mMobileGroup.setVisibility(View.VISIBLE);
        mMobile.setImageResource(mMobileStrengthId);
        mMobileActivity.setImageResource(mMobileActivityId);
        mMobileType.setImageResource(mMobileTypeId);
        mMobileGroup.setContentDescription(mMobileTypeDescription + " " + mMobileDescription);
    } else {
        mMobileGroup.setVisibility(View.GONE);
    }
    if (mIsAirplaneMode) {
        mAirplane.setVisibility(View.VISIBLE);
        mAirplane.setImageResource(mAirplaneIconId);
    } else {
        mAirplane.setVisibility(View.GONE);
    }
    if (mIsEthernetConnected) {
        mEthernet.setVisibility(View.VISIBLE);
        mEthernet.setImageResource(mEthStatusIconId);
    } else {
        mEthernet.setVisibility(View.GONE);
    }
    if (mMobileVisible && mWifiVisible && mIsAirplaneMode) {
        mSpacer.setVisibility(View.INVISIBLE);
    } else {
        mSpacer.setVisibility(View.GONE);
    }
    if (mIsEthernetConnected) {
        mSpacer1.setVisibility(View.INVISIBLE);
    } else {
        mSpacer1.setVisibility(View.GONE);
    }
    if (DEBUG)
        Slog.d(TAG, String.format("mobile: %s sig=%d act=%d typ=%d", (mMobileVisible ? "VISIBLE" : "GONE"), mMobileStrengthId, mMobileActivityId, mMobileTypeId));
    mMobileType.setVisibility(!mWifiVisible ? View.VISIBLE : View.GONE);
}
#method_after
private void apply() {
    if (mWifiGroup == null)
        return;
    if (mWifiVisible) {
        mWifiGroup.setVisibility(View.VISIBLE);
        mWifi.setImageResource(mWifiStrengthId);
        mWifiActivity.setImageResource(mWifiActivityId);
        mWifiGroup.setContentDescription(mWifiDescription);
    } else {
        mWifiGroup.setVisibility(View.GONE);
    }
    if (DEBUG)
        Slog.d(TAG, String.format("wifi: %s sig=%d act=%d", (mWifiVisible ? "VISIBLE" : "GONE"), mWifiStrengthId, mWifiActivityId));
    if (mMobileVisible && !mIsAirplaneMode) {
        mMobileGroup.setVisibility(View.VISIBLE);
        mMobile.setImageResource(mMobileStrengthId);
        mMobileActivity.setImageResource(mMobileActivityId);
        mMobileType.setImageResource(mMobileTypeId);
        mMobileGroup.setContentDescription(mMobileTypeDescription + " " + mMobileDescription);
    } else {
        mMobileGroup.setVisibility(View.GONE);
    }
    if (mIsAirplaneMode) {
        mAirplane.setVisibility(View.VISIBLE);
        mAirplane.setImageResource(mAirplaneIconId);
    } else {
        mAirplane.setVisibility(View.GONE);
    }
    /*
         * TI change. Show/hide ethernet icon on status bar
         */
    if (SystemProperties.OMAP_ENHANCEMENT) {
        if (mIsEthernetConnected) {
            mEthernet.setVisibility(View.VISIBLE);
            mEthernet.setImageResource(mEthStatusIconId);
            mSpacer1.setVisibility(View.INVISIBLE);
        } else {
            mEthernet.setVisibility(View.GONE);
            mSpacer1.setVisibility(View.GONE);
        }
    }
    if (mMobileVisible && mWifiVisible && mIsAirplaneMode) {
        mSpacer.setVisibility(View.INVISIBLE);
    } else {
        mSpacer.setVisibility(View.GONE);
    }
    if (DEBUG)
        Slog.d(TAG, String.format("mobile: %s sig=%d act=%d typ=%d", (mMobileVisible ? "VISIBLE" : "GONE"), mMobileStrengthId, mMobileActivityId, mMobileTypeId));
    mMobileType.setVisibility(!mWifiVisible ? View.VISIBLE : View.GONE);
}
#end_block

#method_before
public void refreshSignalCluster(SignalCluster cluster) {
    cluster.setWifiIndicators(// only show wifi in the cluster if connected or if wifi-only
    mWifiEnabled && (mWifiConnected || !mHasMobileDataFeature), mWifiIconId, mWifiActivityIconId, mContentDescriptionWifi);
    if (mIsWimaxEnabled && mWimaxConnected) {
        // wimax is special
        cluster.setMobileDataIndicators(true, mAlwaysShowCdmaRssi ? mPhoneSignalIconId : mWimaxIconId, mMobileActivityIconId, mDataTypeIconId, mContentDescriptionWimax, mContentDescriptionDataType);
    } else {
        // normal mobile data
        cluster.setMobileDataIndicators(mHasMobileDataFeature, mShowPhoneRSSIForData ? mPhoneSignalIconId : mDataSignalIconId, mMobileActivityIconId, mDataTypeIconId, mContentDescriptionPhoneSignal, mContentDescriptionDataType);
    }
    cluster.setIsAirplaneMode(mAirplaneMode, mAirplaneIconId);
    cluster.setIsEthernetConnected(mEthernetConnected, mEthernetIconId);
}
#method_after
public void refreshSignalCluster(SignalCluster cluster) {
    cluster.setWifiIndicators(// only show wifi in the cluster if connected or if wifi-only
    mWifiEnabled && (mWifiConnected || !mHasMobileDataFeature), mWifiIconId, mWifiActivityIconId, mContentDescriptionWifi);
    if (mIsWimaxEnabled && mWimaxConnected) {
        // wimax is special
        cluster.setMobileDataIndicators(true, mAlwaysShowCdmaRssi ? mPhoneSignalIconId : mWimaxIconId, mMobileActivityIconId, mDataTypeIconId, mContentDescriptionWimax, mContentDescriptionDataType);
    } else {
        // normal mobile data
        cluster.setMobileDataIndicators(mHasMobileDataFeature, mShowPhoneRSSIForData ? mPhoneSignalIconId : mDataSignalIconId, mMobileActivityIconId, mDataTypeIconId, mContentDescriptionPhoneSignal, mContentDescriptionDataType);
    }
    cluster.setIsAirplaneMode(mAirplaneMode, mAirplaneIconId);
    if (SystemProperties.OMAP_ENHANCEMENT) {
        cluster.setIsEthernetConnected(mEthernetConnected, mEthernetIconId);
    }
}
#end_block

#method_before
@Override
public void onReceive(Context context, Intent intent) {
    final String action = intent.getAction();
    if (action.equals(WifiManager.RSSI_CHANGED_ACTION) || action.equals(WifiManager.WIFI_STATE_CHANGED_ACTION) || action.equals(WifiManager.NETWORK_STATE_CHANGED_ACTION)) {
        updateWifiState(intent);
        refreshViews();
    } else if (action.equals(TelephonyIntents.ACTION_SIM_STATE_CHANGED)) {
        updateSimState(intent);
        updateDataIcon();
        refreshViews();
    } else if (action.equals(Telephony.Intents.SPN_STRINGS_UPDATED_ACTION)) {
        updateNetworkName(intent.getBooleanExtra(Telephony.Intents.EXTRA_SHOW_SPN, false), intent.getStringExtra(Telephony.Intents.EXTRA_SPN), intent.getBooleanExtra(Telephony.Intents.EXTRA_SHOW_PLMN, false), intent.getStringExtra(Telephony.Intents.EXTRA_PLMN));
        refreshViews();
    } else if (action.equals(ConnectivityManager.CONNECTIVITY_ACTION) || action.equals(ConnectivityManager.INET_CONDITION_ACTION)) {
        updateEthernetState(intent);
        updateConnectivity(intent);
        refreshViews();
    } else if (action.equals(Intent.ACTION_CONFIGURATION_CHANGED)) {
        refreshViews();
    } else if (action.equals(Intent.ACTION_AIRPLANE_MODE_CHANGED)) {
        updateAirplaneMode();
        refreshViews();
    } else if (action.equals(WimaxManagerConstants.NET_4G_STATE_CHANGED_ACTION) || action.equals(WimaxManagerConstants.SIGNAL_LEVEL_CHANGED_ACTION) || action.equals(WimaxManagerConstants.WIMAX_NETWORK_STATE_CHANGED_ACTION)) {
        updateWimaxState(intent);
        refreshViews();
    }
}
#method_after
@Override
public void onReceive(Context context, Intent intent) {
    final String action = intent.getAction();
    if (action.equals(WifiManager.RSSI_CHANGED_ACTION) || action.equals(WifiManager.WIFI_STATE_CHANGED_ACTION) || action.equals(WifiManager.NETWORK_STATE_CHANGED_ACTION)) {
        updateWifiState(intent);
        refreshViews();
    } else if (action.equals(TelephonyIntents.ACTION_SIM_STATE_CHANGED)) {
        updateSimState(intent);
        updateDataIcon();
        refreshViews();
    } else if (action.equals(Telephony.Intents.SPN_STRINGS_UPDATED_ACTION)) {
        updateNetworkName(intent.getBooleanExtra(Telephony.Intents.EXTRA_SHOW_SPN, false), intent.getStringExtra(Telephony.Intents.EXTRA_SPN), intent.getBooleanExtra(Telephony.Intents.EXTRA_SHOW_PLMN, false), intent.getStringExtra(Telephony.Intents.EXTRA_PLMN));
        refreshViews();
    } else if (action.equals(ConnectivityManager.CONNECTIVITY_ACTION) || action.equals(ConnectivityManager.INET_CONDITION_ACTION)) {
        if (SystemProperties.OMAP_ENHANCEMENT) {
            updateEthernetState(intent);
        }
        updateConnectivity(intent);
        refreshViews();
    } else if (action.equals(Intent.ACTION_CONFIGURATION_CHANGED)) {
        refreshViews();
    } else if (action.equals(Intent.ACTION_AIRPLANE_MODE_CHANGED)) {
        updateAirplaneMode();
        refreshViews();
    } else if (action.equals(WimaxManagerConstants.NET_4G_STATE_CHANGED_ACTION) || action.equals(WimaxManagerConstants.SIGNAL_LEVEL_CHANGED_ACTION) || action.equals(WimaxManagerConstants.WIMAX_NETWORK_STATE_CHANGED_ACTION)) {
        updateWimaxState(intent);
        refreshViews();
    }
}
#end_block

#method_before
private final void updateTelephonySignalStrength() {
    if (!hasService()) {
        if (CHATTY)
            Slog.d(TAG, "updateTelephonySignalStrength: hasService()=" + hasService());
        mPhoneSignalIconId = R.drawable.stat_sys_signal_null;
        mDataSignalIconId = R.drawable.stat_sys_signal_null;
    } else {
        if (mSignalStrength == null) {
            if (CHATTY)
                Slog.d(TAG, "updateTelephonySignalStrength: mSignalStrength == null");
            mPhoneSignalIconId = R.drawable.stat_sys_signal_null;
            mDataSignalIconId = R.drawable.stat_sys_signal_null;
            mContentDescriptionPhoneSignal = mContext.getString(AccessibilityContentDescriptions.PHONE_SIGNAL_STRENGTH[0]);
        } else {
            int iconLevel;
            int[] iconList;
            if (isCdma() && mAlwaysShowCdmaRssi) {
                mLastSignalLevel = iconLevel = mSignalStrength.getCdmaLevel();
                if (DEBUG)
                    Slog.d(TAG, "mAlwaysShowCdmaRssi=" + mAlwaysShowCdmaRssi + " set to cdmaLevel=" + mSignalStrength.getCdmaLevel() + " instead of level=" + mSignalStrength.getLevel());
            } else {
                mLastSignalLevel = iconLevel = mSignalStrength.getLevel();
            }
            if (isCdma()) {
                if (isCdmaEri()) {
                    iconList = TelephonyIcons.TELEPHONY_SIGNAL_STRENGTH_ROAMING[mInetCondition];
                } else {
                    iconList = TelephonyIcons.TELEPHONY_SIGNAL_STRENGTH[mInetCondition];
                }
            } else {
                // Though mPhone is a Manager, this call is not an IPC
                if (mPhone.isNetworkRoaming()) {
                    iconList = TelephonyIcons.TELEPHONY_SIGNAL_STRENGTH_ROAMING[mInetCondition];
                } else {
                    iconList = TelephonyIcons.TELEPHONY_SIGNAL_STRENGTH[mInetCondition];
                }
            }
            mPhoneSignalIconId = iconList[iconLevel];
            mContentDescriptionPhoneSignal = mContext.getString(AccessibilityContentDescriptions.PHONE_SIGNAL_STRENGTH[iconLevel]);
            mDataSignalIconId = TelephonyIcons.DATA_SIGNAL_STRENGTH[mInetCondition][iconLevel];
        }
    }
}
#method_after
private final void updateTelephonySignalStrength() {
    if (!hasService()) {
        if (CHATTY)
            Slog.d(TAG, "updateTelephonySignalStrength: !hasService()");
        mPhoneSignalIconId = R.drawable.stat_sys_signal_null;
        mDataSignalIconId = R.drawable.stat_sys_signal_null;
    } else {
        if (mSignalStrength == null) {
            if (CHATTY)
                Slog.d(TAG, "updateTelephonySignalStrength: mSignalStrength == null");
            mPhoneSignalIconId = R.drawable.stat_sys_signal_null;
            mDataSignalIconId = R.drawable.stat_sys_signal_null;
            mContentDescriptionPhoneSignal = mContext.getString(AccessibilityContentDescriptions.PHONE_SIGNAL_STRENGTH[0]);
        } else {
            int iconLevel;
            int[] iconList;
            if (isCdma() && mAlwaysShowCdmaRssi) {
                mLastSignalLevel = iconLevel = mSignalStrength.getCdmaLevel();
                if (DEBUG)
                    Slog.d(TAG, "mAlwaysShowCdmaRssi=" + mAlwaysShowCdmaRssi + " set to cdmaLevel=" + mSignalStrength.getCdmaLevel() + " instead of level=" + mSignalStrength.getLevel());
            } else {
                mLastSignalLevel = iconLevel = mSignalStrength.getLevel();
            }
            if (isCdma()) {
                if (isCdmaEri()) {
                    iconList = TelephonyIcons.TELEPHONY_SIGNAL_STRENGTH_ROAMING[mInetCondition];
                } else {
                    iconList = TelephonyIcons.TELEPHONY_SIGNAL_STRENGTH[mInetCondition];
                }
            } else {
                // Though mPhone is a Manager, this call is not an IPC
                if (mPhone.isNetworkRoaming()) {
                    iconList = TelephonyIcons.TELEPHONY_SIGNAL_STRENGTH_ROAMING[mInetCondition];
                } else {
                    iconList = TelephonyIcons.TELEPHONY_SIGNAL_STRENGTH[mInetCondition];
                }
            }
            mPhoneSignalIconId = iconList[iconLevel];
            mContentDescriptionPhoneSignal = mContext.getString(AccessibilityContentDescriptions.PHONE_SIGNAL_STRENGTH[iconLevel]);
            mDataSignalIconId = TelephonyIcons.DATA_SIGNAL_STRENGTH[mInetCondition][iconLevel];
        }
    }
}
#end_block

#method_before
private final void updateDataNetType() {
    if (mIsWimaxEnabled && mWimaxConnected) {
        // wimax is a special 4g network not handled by telephony
        mDataIconList = TelephonyIcons.DATA_4G[mInetCondition];
        mDataTypeIconId = R.drawable.stat_sys_data_connected_4g;
        mContentDescriptionDataType = mContext.getString(R.string.accessibility_data_connection_4g);
    } else {
        switch(mDataNetType) {
            case TelephonyManager.NETWORK_TYPE_UNKNOWN:
                if (!mShowAtLeastThreeGees) {
                    mDataIconList = TelephonyIcons.DATA_G[mInetCondition];
                    mDataTypeIconId = 0;
                    mContentDescriptionDataType = mContext.getString(R.string.accessibility_data_connection_gprs);
                    break;
                } else {
                // fall through
                }
            case TelephonyManager.NETWORK_TYPE_EDGE:
                if (!mShowAtLeastThreeGees) {
                    mDataIconList = TelephonyIcons.DATA_E[mInetCondition];
                    mDataTypeIconId = R.drawable.stat_sys_data_connected_e;
                    mContentDescriptionDataType = mContext.getString(R.string.accessibility_data_connection_edge);
                    break;
                } else {
                // fall through
                }
            case TelephonyManager.NETWORK_TYPE_UMTS:
                mDataIconList = TelephonyIcons.DATA_3G[mInetCondition];
                mDataTypeIconId = R.drawable.stat_sys_data_connected_3g;
                mContentDescriptionDataType = mContext.getString(R.string.accessibility_data_connection_3g);
                break;
            case TelephonyManager.NETWORK_TYPE_HSDPA:
            case TelephonyManager.NETWORK_TYPE_HSUPA:
            case TelephonyManager.NETWORK_TYPE_HSPA:
            case TelephonyManager.NETWORK_TYPE_HSPAP:
                if (mHspaDataDistinguishable) {
                    mDataIconList = TelephonyIcons.DATA_H[mInetCondition];
                    mDataTypeIconId = R.drawable.stat_sys_data_connected_h;
                    mContentDescriptionDataType = mContext.getString(R.string.accessibility_data_connection_3_5g);
                } else {
                    mDataIconList = TelephonyIcons.DATA_3G[mInetCondition];
                    mDataTypeIconId = R.drawable.stat_sys_data_connected_3g;
                    mContentDescriptionDataType = mContext.getString(R.string.accessibility_data_connection_3g);
                }
                break;
            case TelephonyManager.NETWORK_TYPE_CDMA:
                // display 1xRTT for IS95A/B
                mDataIconList = TelephonyIcons.DATA_1X[mInetCondition];
                mDataTypeIconId = R.drawable.stat_sys_data_connected_1x;
                mContentDescriptionDataType = mContext.getString(R.string.accessibility_data_connection_cdma);
                break;
            case TelephonyManager.NETWORK_TYPE_1xRTT:
                mDataIconList = TelephonyIcons.DATA_1X[mInetCondition];
                mDataTypeIconId = R.drawable.stat_sys_data_connected_1x;
                mContentDescriptionDataType = mContext.getString(R.string.accessibility_data_connection_cdma);
                break;
            // fall through
            case TelephonyManager.NETWORK_TYPE_EVDO_0:
            case TelephonyManager.NETWORK_TYPE_EVDO_A:
            case TelephonyManager.NETWORK_TYPE_EVDO_B:
            case TelephonyManager.NETWORK_TYPE_EHRPD:
                mDataIconList = TelephonyIcons.DATA_3G[mInetCondition];
                mDataTypeIconId = R.drawable.stat_sys_data_connected_3g;
                mContentDescriptionDataType = mContext.getString(R.string.accessibility_data_connection_3g);
                break;
            case TelephonyManager.NETWORK_TYPE_LTE:
                mDataIconList = TelephonyIcons.DATA_4G[mInetCondition];
                mDataTypeIconId = R.drawable.stat_sys_data_connected_4g;
                mContentDescriptionDataType = mContext.getString(R.string.accessibility_data_connection_4g);
                break;
            default:
                if (!mShowAtLeastThreeGees) {
                    mDataIconList = TelephonyIcons.DATA_G[mInetCondition];
                    mDataTypeIconId = R.drawable.stat_sys_data_connected_g;
                    mContentDescriptionDataType = mContext.getString(R.string.accessibility_data_connection_gprs);
                } else {
                    mDataIconList = TelephonyIcons.DATA_3G[mInetCondition];
                    mDataTypeIconId = R.drawable.stat_sys_data_connected_3g;
                    mContentDescriptionDataType = mContext.getString(R.string.accessibility_data_connection_3g);
                }
                break;
        }
    }
    if (isCdma()) {
        if (isCdmaEri()) {
            mDataTypeIconId = R.drawable.stat_sys_data_connected_roam;
        }
    } else if (mPhone.isNetworkRoaming()) {
        mDataTypeIconId = R.drawable.stat_sys_data_connected_roam;
    }
}
#method_after
private final void updateDataNetType() {
    if (mIsWimaxEnabled && mWimaxConnected) {
        // wimax is a special 4g network not handled by telephony
        mDataIconList = TelephonyIcons.DATA_4G[mInetCondition];
        mDataTypeIconId = R.drawable.stat_sys_data_connected_4g;
        mContentDescriptionDataType = mContext.getString(R.string.accessibility_data_connection_4g);
    } else {
        switch(mDataNetType) {
            case TelephonyManager.NETWORK_TYPE_UNKNOWN:
                if (!mShowAtLeastThreeGees) {
                    mDataIconList = TelephonyIcons.DATA_G[mInetCondition];
                    mDataTypeIconId = 0;
                    mContentDescriptionDataType = mContext.getString(R.string.accessibility_data_connection_gprs);
                    break;
                } else {
                // fall through
                }
            case TelephonyManager.NETWORK_TYPE_EDGE:
                if (!mShowAtLeastThreeGees) {
                    mDataIconList = TelephonyIcons.DATA_E[mInetCondition];
                    mDataTypeIconId = R.drawable.stat_sys_data_connected_e;
                    mContentDescriptionDataType = mContext.getString(R.string.accessibility_data_connection_edge);
                    break;
                } else {
                // fall through
                }
            case TelephonyManager.NETWORK_TYPE_UMTS:
                mDataIconList = TelephonyIcons.DATA_3G[mInetCondition];
                mDataTypeIconId = R.drawable.stat_sys_data_connected_3g;
                mContentDescriptionDataType = mContext.getString(R.string.accessibility_data_connection_3g);
                break;
            case TelephonyManager.NETWORK_TYPE_HSDPA:
            case TelephonyManager.NETWORK_TYPE_HSUPA:
            case TelephonyManager.NETWORK_TYPE_HSPA:
            case TelephonyManager.NETWORK_TYPE_HSPAP:
                if (mHspaDataDistinguishable) {
                    mDataIconList = TelephonyIcons.DATA_H[mInetCondition];
                    mDataTypeIconId = R.drawable.stat_sys_data_connected_h;
                    mContentDescriptionDataType = mContext.getString(R.string.accessibility_data_connection_3_5g);
                } else {
                    mDataIconList = TelephonyIcons.DATA_3G[mInetCondition];
                    mDataTypeIconId = R.drawable.stat_sys_data_connected_3g;
                    mContentDescriptionDataType = mContext.getString(R.string.accessibility_data_connection_3g);
                }
                break;
            case TelephonyManager.NETWORK_TYPE_CDMA:
                if (!mShowAtLeastThreeGees) {
                    // display 1xRTT for IS95A/B
                    mDataIconList = TelephonyIcons.DATA_1X[mInetCondition];
                    mDataTypeIconId = R.drawable.stat_sys_data_connected_1x;
                    mContentDescriptionDataType = mContext.getString(R.string.accessibility_data_connection_cdma);
                    break;
                } else {
                // fall through
                }
            case TelephonyManager.NETWORK_TYPE_1xRTT:
                if (!mShowAtLeastThreeGees) {
                    mDataIconList = TelephonyIcons.DATA_1X[mInetCondition];
                    mDataTypeIconId = R.drawable.stat_sys_data_connected_1x;
                    mContentDescriptionDataType = mContext.getString(R.string.accessibility_data_connection_cdma);
                    break;
                } else {
                // fall through
                }
            // fall through
            case TelephonyManager.NETWORK_TYPE_EVDO_0:
            case TelephonyManager.NETWORK_TYPE_EVDO_A:
            case TelephonyManager.NETWORK_TYPE_EVDO_B:
            case TelephonyManager.NETWORK_TYPE_EHRPD:
                mDataIconList = TelephonyIcons.DATA_3G[mInetCondition];
                mDataTypeIconId = R.drawable.stat_sys_data_connected_3g;
                mContentDescriptionDataType = mContext.getString(R.string.accessibility_data_connection_3g);
                break;
            case TelephonyManager.NETWORK_TYPE_LTE:
                mDataIconList = TelephonyIcons.DATA_4G[mInetCondition];
                mDataTypeIconId = R.drawable.stat_sys_data_connected_4g;
                mContentDescriptionDataType = mContext.getString(R.string.accessibility_data_connection_4g);
                break;
            default:
                if (!mShowAtLeastThreeGees) {
                    mDataIconList = TelephonyIcons.DATA_G[mInetCondition];
                    mDataTypeIconId = R.drawable.stat_sys_data_connected_g;
                    mContentDescriptionDataType = mContext.getString(R.string.accessibility_data_connection_gprs);
                } else {
                    mDataIconList = TelephonyIcons.DATA_3G[mInetCondition];
                    mDataTypeIconId = R.drawable.stat_sys_data_connected_3g;
                    mContentDescriptionDataType = mContext.getString(R.string.accessibility_data_connection_3g);
                }
                break;
        }
    }
    if (isCdma()) {
        if (isCdmaEri()) {
            mDataTypeIconId = R.drawable.stat_sys_data_connected_roam;
        }
    } else if (mPhone.isNetworkRoaming()) {
        mDataTypeIconId = R.drawable.stat_sys_data_connected_roam;
    }
}
#end_block

#method_before
private void updateEthernetState(Intent intent) {
    final String action = intent.getAction();
    if (action.equals(ConnectivityManager.CONNECTIVITY_ACTION)) {
        final NetworkInfo networkInfo = (NetworkInfo) intent.getParcelableExtra(ConnectivityManager.EXTRA_NETWORK_INFO);
        mEthernetConnected = networkInfo != null && networkInfo.isConnected();
    }
    updateEthernetIcons();
}
#method_after
private void updateEthernetState(Intent intent) {
    final String action = intent.getAction();
    if (action.equals(ConnectivityManager.CONNECTIVITY_ACTION)) {
        final NetworkInfo networkInfo = (NetworkInfo) intent.getParcelableExtra(ConnectivityManager.EXTRA_NETWORK_INFO);
        if (networkInfo != null && networkInfo.isConnected() && networkInfo.getType() == ConnectivityManager.TYPE_ETHERNET) {
            mEthernetConnected = true;
        } else {
            mEthernetConnected = false;
        }
    }
    updateEthernetIcons();
}
#end_block

#method_before
// ===== Full or limited Internet connectivity ==================================
private void updateConnectivity(Intent intent) {
    if (CHATTY) {
        Slog.d(TAG, "updateConnectivity: intent=" + intent);
    }
    final ConnectivityManager connManager = (ConnectivityManager) mContext.getSystemService(Context.CONNECTIVITY_SERVICE);
    final NetworkInfo info = connManager.getActiveNetworkInfo();
    // Are we connected at all, by any interface?
    mConnected = info != null && info.isConnected();
    if (mConnected) {
        mConnectedNetworkType = info.getType();
        mConnectedNetworkTypeName = info.getTypeName();
    } else {
        mConnectedNetworkType = ConnectivityManager.TYPE_NONE;
        mConnectedNetworkTypeName = null;
    }
    int connectionStatus = intent.getIntExtra(ConnectivityManager.EXTRA_INET_CONDITION, 0);
    if (CHATTY) {
        Slog.d(TAG, "updateConnectivity: networkInfo=" + info);
        Slog.d(TAG, "updateConnectivity: connectionStatus=" + connectionStatus);
    }
    mInetCondition = (connectionStatus > INET_CONDITION_THRESHOLD ? 1 : 0);
    if (info != null && info.getType() == ConnectivityManager.TYPE_BLUETOOTH) {
        mBluetoothTethered = info.isConnected();
    } else {
        mBluetoothTethered = false;
    }
    // We want to update all the icons, all at once, for any condition change
    updateDataNetType();
    updateWimaxIcons();
    updateDataIcon();
    updateTelephonySignalStrength();
    updateWifiIcons();
    updateEthernetIcons();
}
#method_after
// ===== Full or limited Internet connectivity ==================================
private void updateConnectivity(Intent intent) {
    if (CHATTY) {
        Slog.d(TAG, "updateConnectivity: intent=" + intent);
    }
    final ConnectivityManager connManager = (ConnectivityManager) mContext.getSystemService(Context.CONNECTIVITY_SERVICE);
    final NetworkInfo info = connManager.getActiveNetworkInfo();
    // Are we connected at all, by any interface?
    mConnected = info != null && info.isConnected();
    if (mConnected) {
        mConnectedNetworkType = info.getType();
        mConnectedNetworkTypeName = info.getTypeName();
    } else {
        mConnectedNetworkType = ConnectivityManager.TYPE_NONE;
        mConnectedNetworkTypeName = null;
    }
    int connectionStatus = intent.getIntExtra(ConnectivityManager.EXTRA_INET_CONDITION, 0);
    if (CHATTY) {
        Slog.d(TAG, "updateConnectivity: networkInfo=" + info);
        Slog.d(TAG, "updateConnectivity: connectionStatus=" + connectionStatus);
    }
    mInetCondition = (connectionStatus > INET_CONDITION_THRESHOLD ? 1 : 0);
    if (info != null && info.getType() == ConnectivityManager.TYPE_BLUETOOTH) {
        mBluetoothTethered = info.isConnected();
    } else {
        mBluetoothTethered = false;
    }
    // We want to update all the icons, all at once, for any condition change
    updateDataNetType();
    updateWimaxIcons();
    updateDataIcon();
    updateTelephonySignalStrength();
    updateWifiIcons();
    if (SystemProperties.OMAP_ENHANCEMENT) {
        updateEthernetIcons();
    }
}
#end_block

#method_before
// ===== Update the views =======================================================
void refreshViews() {
    Context context = mContext;
    int combinedSignalIconId = 0;
    int combinedActivityIconId = 0;
    String combinedLabel = "";
    String wifiLabel = "";
    String mobileLabel = "";
    String ethLabel = "";
    int N;
    final boolean emergencyOnly = (mServiceState != null && mServiceState.isEmergencyOnly());
    if (!mHasMobileDataFeature) {
        mDataSignalIconId = mPhoneSignalIconId = 0;
        mobileLabel = "";
    } else {
        if (mDataConnected) {
            mobileLabel = mNetworkName;
        } else if (mConnected || emergencyOnly) {
            if (hasService() || emergencyOnly) {
                // The isEmergencyOnly test covers the case of a phone with no SIM
                mobileLabel = mNetworkName;
            } else {
                // Tablets, basically
                mobileLabel = "";
            }
        } else {
            mobileLabel = context.getString(R.string.status_bar_settings_signal_meter_disconnected);
        }
        // Now for things that should only be shown when actually using mobile data.
        if (mDataConnected) {
            combinedSignalIconId = mDataSignalIconId;
            switch(mDataActivity) {
                case TelephonyManager.DATA_ACTIVITY_IN:
                    mMobileActivityIconId = R.drawable.stat_sys_signal_in;
                    break;
                case TelephonyManager.DATA_ACTIVITY_OUT:
                    mMobileActivityIconId = R.drawable.stat_sys_signal_out;
                    break;
                case TelephonyManager.DATA_ACTIVITY_INOUT:
                    mMobileActivityIconId = R.drawable.stat_sys_signal_inout;
                    break;
                default:
                    mMobileActivityIconId = 0;
                    break;
            }
            combinedLabel = mobileLabel;
            combinedActivityIconId = mMobileActivityIconId;
            // set by updateDataIcon()
            combinedSignalIconId = mDataSignalIconId;
            mContentDescriptionCombinedSignal = mContentDescriptionDataType;
        }
    }
    if (mWifiConnected) {
        if (mWifiSsid == null) {
            wifiLabel = context.getString(R.string.status_bar_settings_signal_meter_wifi_nossid);
            // no wifis, no bits
            mWifiActivityIconId = 0;
        } else {
            wifiLabel = mWifiSsid;
            if (DEBUG) {
                wifiLabel += "xxxxXXXXxxxxXXXX";
            }
            switch(mWifiActivity) {
                case WifiManager.DATA_ACTIVITY_IN:
                    mWifiActivityIconId = R.drawable.stat_sys_wifi_in;
                    break;
                case WifiManager.DATA_ACTIVITY_OUT:
                    mWifiActivityIconId = R.drawable.stat_sys_wifi_out;
                    break;
                case WifiManager.DATA_ACTIVITY_INOUT:
                    mWifiActivityIconId = R.drawable.stat_sys_wifi_inout;
                    break;
                case WifiManager.DATA_ACTIVITY_NONE:
                    mWifiActivityIconId = 0;
                    break;
            }
        }
        combinedActivityIconId = mWifiActivityIconId;
        combinedLabel = wifiLabel;
        // set by updateWifiIcons()
        combinedSignalIconId = mWifiIconId;
        mContentDescriptionCombinedSignal = mContentDescriptionWifi;
    } else {
        if (mHasMobileDataFeature) {
            wifiLabel = "";
        } else {
            wifiLabel = context.getString(R.string.status_bar_settings_signal_meter_disconnected);
        }
    }
    if (mBluetoothTethered) {
        combinedLabel = mContext.getString(R.string.bluetooth_tethered);
        combinedSignalIconId = mBluetoothTetherIconId;
        mContentDescriptionCombinedSignal = mContext.getString(R.string.accessibility_bluetooth_tether);
    }
    if (mAirplaneMode && (mServiceState == null || (!hasService() && !mServiceState.isEmergencyOnly()))) {
        // Only display the flight-mode icon if not in "emergency calls only" mode.
        // look again; your radios are now airplanes
        mContentDescriptionPhoneSignal = mContext.getString(R.string.accessibility_airplane_mode);
        mAirplaneIconId = R.drawable.stat_sys_signal_flightmode;
        mPhoneSignalIconId = mDataSignalIconId = mDataTypeIconId = 0;
        // combined values from connected wifi take precedence over airplane mode
        if (mWifiConnected) {
            // Suppress "No internet connection." from mobile if wifi connected.
            mobileLabel = "";
        } else {
            if (mHasMobileDataFeature) {
                // let the mobile icon show "No internet connection."
                wifiLabel = "";
            } else {
                wifiLabel = context.getString(R.string.status_bar_settings_signal_meter_disconnected);
                combinedLabel = wifiLabel;
            }
            mContentDescriptionCombinedSignal = mContentDescriptionPhoneSignal;
            combinedSignalIconId = mDataSignalIconId;
        }
    } else if (!mDataConnected && !mWifiConnected && !mBluetoothTethered && !mWimaxConnected && !mEthernetConnected) {
        // pretty much totally disconnected
        combinedLabel = context.getString(R.string.status_bar_settings_signal_meter_disconnected);
        // On devices without mobile radios, we want to show the wifi icon
        combinedSignalIconId = mHasMobileDataFeature ? mDataSignalIconId : mWifiIconId;
        mContentDescriptionCombinedSignal = mHasMobileDataFeature ? mContentDescriptionDataType : mContentDescriptionWifi;
        mDataTypeIconId = 0;
        if (isCdma()) {
            if (isCdmaEri()) {
                mDataTypeIconId = R.drawable.stat_sys_data_connected_roam;
            }
        } else if (mPhone.isNetworkRoaming()) {
            mDataTypeIconId = R.drawable.stat_sys_data_connected_roam;
        }
    }
    if (DEBUG) {
        Slog.d(TAG, "refreshViews connected={" + (mWifiConnected ? " wifi" : "") + (mDataConnected ? " data" : "") + (mEthernetConnected ? " ethernet" : "") + " } level=" + ((mSignalStrength == null) ? "??" : Integer.toString(mSignalStrength.getLevel())) + " combinedSignalIconId=0x" + Integer.toHexString(combinedSignalIconId) + "/" + getResourceName(combinedSignalIconId) + " combinedActivityIconId=0x" + Integer.toHexString(combinedActivityIconId) + " mobileLabel=" + mobileLabel + " wifiLabel=" + wifiLabel + " combinedLabel=" + combinedLabel + " mAirplaneMode=" + mAirplaneMode + " mDataActivity=" + mDataActivity + " mPhoneSignalIconId=0x" + Integer.toHexString(mPhoneSignalIconId) + " mDataDirectionIconId=0x" + Integer.toHexString(mDataDirectionIconId) + " mDataSignalIconId=0x" + Integer.toHexString(mDataSignalIconId) + " mDataTypeIconId=0x" + Integer.toHexString(mDataTypeIconId) + " mWifiIconId=0x" + Integer.toHexString(mWifiIconId) + " mEthernetIconId=0x" + Integer.toHexString(mEthernetIconId) + " mBluetoothTetherIconId=0x" + Integer.toHexString(mBluetoothTetherIconId));
    }
    if (mLastPhoneSignalIconId != mPhoneSignalIconId || mLastDataDirectionOverlayIconId != combinedActivityIconId || mLastWifiIconId != mWifiIconId || mLastWimaxIconId != mWimaxIconId || mLastDataTypeIconId != mDataTypeIconId || mLastEthernetIconId != mEthernetIconId || mLastAirplaneMode != mAirplaneMode) {
        // NB: the mLast*s will be updated later
        for (SignalCluster cluster : mSignalClusters) {
            refreshSignalCluster(cluster);
        }
    }
    if (mLastAirplaneMode != mAirplaneMode) {
        mLastAirplaneMode = mAirplaneMode;
    }
    // the phone icon on phones
    if (mLastPhoneSignalIconId != mPhoneSignalIconId) {
        mLastPhoneSignalIconId = mPhoneSignalIconId;
        N = mPhoneSignalIconViews.size();
        for (int i = 0; i < N; i++) {
            final ImageView v = mPhoneSignalIconViews.get(i);
            if (mPhoneSignalIconId == 0) {
                v.setVisibility(View.GONE);
            } else {
                v.setVisibility(View.VISIBLE);
                v.setImageResource(mPhoneSignalIconId);
                v.setContentDescription(mContentDescriptionPhoneSignal);
            }
        }
    }
    // the data icon on phones
    if (mLastDataDirectionIconId != mDataDirectionIconId) {
        mLastDataDirectionIconId = mDataDirectionIconId;
        N = mDataDirectionIconViews.size();
        for (int i = 0; i < N; i++) {
            final ImageView v = mDataDirectionIconViews.get(i);
            v.setImageResource(mDataDirectionIconId);
            v.setContentDescription(mContentDescriptionDataType);
        }
    }
    // the wifi icon on phones
    if (mLastWifiIconId != mWifiIconId) {
        mLastWifiIconId = mWifiIconId;
        N = mWifiIconViews.size();
        for (int i = 0; i < N; i++) {
            final ImageView v = mWifiIconViews.get(i);
            if (mWifiIconId == 0) {
                v.setVisibility(View.GONE);
            } else {
                v.setVisibility(View.VISIBLE);
                v.setImageResource(mWifiIconId);
                v.setContentDescription(mContentDescriptionWifi);
            }
        }
    }
    // the Ethernet icon on phones
    if (mLastEthernetIconId != mEthernetIconId) {
        mLastEthernetIconId = mEthernetIconId;
        N = mEthernetIconViews.size();
        for (int i = 0; i < N; i++) {
            final ImageView v = mWifiIconViews.get(i);
            if (mEthernetIconId == 0) {
                v.setVisibility(View.GONE);
            } else {
                v.setVisibility(View.VISIBLE);
                v.setImageResource(mEthernetIconId);
                v.setContentDescription(mContentDescriptionEthernet);
            }
        }
    }
    // the wimax icon on phones
    if (mLastWimaxIconId != mWimaxIconId) {
        mLastWimaxIconId = mWimaxIconId;
        N = mWimaxIconViews.size();
        for (int i = 0; i < N; i++) {
            final ImageView v = mWimaxIconViews.get(i);
            if (mWimaxIconId == 0) {
                v.setVisibility(View.GONE);
            } else {
                v.setVisibility(View.VISIBLE);
                v.setImageResource(mWimaxIconId);
                v.setContentDescription(mContentDescriptionWimax);
            }
        }
    }
    // the combined data signal icon
    if (mLastCombinedSignalIconId != combinedSignalIconId) {
        mLastCombinedSignalIconId = combinedSignalIconId;
        N = mCombinedSignalIconViews.size();
        for (int i = 0; i < N; i++) {
            final ImageView v = mCombinedSignalIconViews.get(i);
            v.setImageResource(combinedSignalIconId);
            v.setContentDescription(mContentDescriptionCombinedSignal);
        }
    }
    // the data network type overlay
    if (mLastDataTypeIconId != mDataTypeIconId) {
        mLastDataTypeIconId = mDataTypeIconId;
        N = mDataTypeIconViews.size();
        for (int i = 0; i < N; i++) {
            final ImageView v = mDataTypeIconViews.get(i);
            if (mDataTypeIconId == 0) {
                v.setVisibility(View.GONE);
            } else {
                v.setVisibility(View.VISIBLE);
                v.setImageResource(mDataTypeIconId);
                v.setContentDescription(mContentDescriptionDataType);
            }
        }
    }
    // the data direction overlay
    if (mLastDataDirectionOverlayIconId != combinedActivityIconId) {
        if (DEBUG) {
            Slog.d(TAG, "changing data overlay icon id to " + combinedActivityIconId);
        }
        mLastDataDirectionOverlayIconId = combinedActivityIconId;
        N = mDataDirectionOverlayIconViews.size();
        for (int i = 0; i < N; i++) {
            final ImageView v = mDataDirectionOverlayIconViews.get(i);
            if (combinedActivityIconId == 0) {
                v.setVisibility(View.GONE);
            } else {
                v.setVisibility(View.VISIBLE);
                v.setImageResource(combinedActivityIconId);
                v.setContentDescription(mContentDescriptionDataType);
            }
        }
    }
    // the combinedLabel in the notification panel
    if (!mLastCombinedLabel.equals(combinedLabel)) {
        mLastCombinedLabel = combinedLabel;
        N = mCombinedLabelViews.size();
        for (int i = 0; i < N; i++) {
            TextView v = mCombinedLabelViews.get(i);
            v.setText(combinedLabel);
        }
    }
    // wifi label
    N = mWifiLabelViews.size();
    for (int i = 0; i < N; i++) {
        TextView v = mWifiLabelViews.get(i);
        v.setText(wifiLabel);
        if ("".equals(wifiLabel)) {
            v.setVisibility(View.GONE);
        } else {
            v.setVisibility(View.VISIBLE);
        }
    }
    // mobile label
    N = mMobileLabelViews.size();
    for (int i = 0; i < N; i++) {
        TextView v = mMobileLabelViews.get(i);
        v.setText(mobileLabel);
        if ("".equals(mobileLabel)) {
            v.setVisibility(View.GONE);
        } else {
            v.setVisibility(View.VISIBLE);
        }
    }
}
#method_after
// ===== Update the views =======================================================
void refreshViews() {
    Context context = mContext;
    int combinedSignalIconId = 0;
    int combinedActivityIconId = 0;
    String combinedLabel = "";
    String wifiLabel = "";
    String mobileLabel = "";
    String ethLabel = "";
    int N;
    final boolean emergencyOnly = (mServiceState != null && mServiceState.isEmergencyOnly());
    if (!mHasMobileDataFeature) {
        mDataSignalIconId = mPhoneSignalIconId = 0;
        mobileLabel = "";
    } else {
        if (mDataConnected) {
            mobileLabel = mNetworkName;
        } else if (mConnected || emergencyOnly) {
            if (hasService() || emergencyOnly) {
                // The isEmergencyOnly test covers the case of a phone with no SIM
                mobileLabel = mNetworkName;
            } else {
                // Tablets, basically
                mobileLabel = "";
            }
        } else {
            mobileLabel = context.getString(R.string.status_bar_settings_signal_meter_disconnected);
        }
        // Now for things that should only be shown when actually using mobile data.
        if (mDataConnected) {
            combinedSignalIconId = mDataSignalIconId;
            switch(mDataActivity) {
                case TelephonyManager.DATA_ACTIVITY_IN:
                    mMobileActivityIconId = R.drawable.stat_sys_signal_in;
                    break;
                case TelephonyManager.DATA_ACTIVITY_OUT:
                    mMobileActivityIconId = R.drawable.stat_sys_signal_out;
                    break;
                case TelephonyManager.DATA_ACTIVITY_INOUT:
                    mMobileActivityIconId = R.drawable.stat_sys_signal_inout;
                    break;
                default:
                    mMobileActivityIconId = 0;
                    break;
            }
            combinedLabel = mobileLabel;
            combinedActivityIconId = mMobileActivityIconId;
            // set by updateDataIcon()
            combinedSignalIconId = mDataSignalIconId;
            mContentDescriptionCombinedSignal = mContentDescriptionDataType;
        }
    }
    if (mWifiConnected) {
        if (mWifiSsid == null) {
            wifiLabel = context.getString(R.string.status_bar_settings_signal_meter_wifi_nossid);
            // no wifis, no bits
            mWifiActivityIconId = 0;
        } else {
            wifiLabel = mWifiSsid;
            if (DEBUG) {
                wifiLabel += "xxxxXXXXxxxxXXXX";
            }
            switch(mWifiActivity) {
                case WifiManager.DATA_ACTIVITY_IN:
                    mWifiActivityIconId = R.drawable.stat_sys_wifi_in;
                    break;
                case WifiManager.DATA_ACTIVITY_OUT:
                    mWifiActivityIconId = R.drawable.stat_sys_wifi_out;
                    break;
                case WifiManager.DATA_ACTIVITY_INOUT:
                    mWifiActivityIconId = R.drawable.stat_sys_wifi_inout;
                    break;
                case WifiManager.DATA_ACTIVITY_NONE:
                    mWifiActivityIconId = 0;
                    break;
            }
        }
        combinedActivityIconId = mWifiActivityIconId;
        combinedLabel = wifiLabel;
        // set by updateWifiIcons()
        combinedSignalIconId = mWifiIconId;
        mContentDescriptionCombinedSignal = mContentDescriptionWifi;
    } else {
        if (mHasMobileDataFeature) {
            wifiLabel = "";
        } else {
            wifiLabel = context.getString(R.string.status_bar_settings_signal_meter_disconnected);
        }
    }
    if (mBluetoothTethered) {
        combinedLabel = mContext.getString(R.string.bluetooth_tethered);
        combinedSignalIconId = mBluetoothTetherIconId;
        mContentDescriptionCombinedSignal = mContext.getString(R.string.accessibility_bluetooth_tether);
    }
    final boolean ethernetConnected = (mConnectedNetworkType == ConnectivityManager.TYPE_ETHERNET);
    if (ethernetConnected) {
        if (!SystemProperties.OMAP_ENHANCEMENT) {
            // TODO: icons and strings for Ethernet connectivity
            combinedLabel = mConnectedNetworkTypeName;
        }
    }
    if (mAirplaneMode && (mServiceState == null || (!hasService() && !mServiceState.isEmergencyOnly()))) {
        // Only display the flight-mode icon if not in "emergency calls only" mode.
        // look again; your radios are now airplanes
        mContentDescriptionPhoneSignal = mContext.getString(R.string.accessibility_airplane_mode);
        mAirplaneIconId = R.drawable.stat_sys_signal_flightmode;
        mPhoneSignalIconId = mDataSignalIconId = mDataTypeIconId = 0;
        // combined values from connected wifi take precedence over airplane mode
        if (mWifiConnected) {
            // Suppress "No internet connection." from mobile if wifi connected.
            mobileLabel = "";
        } else {
            if (mHasMobileDataFeature) {
                // let the mobile icon show "No internet connection."
                wifiLabel = "";
            } else {
                wifiLabel = context.getString(R.string.status_bar_settings_signal_meter_disconnected);
                combinedLabel = wifiLabel;
            }
            mContentDescriptionCombinedSignal = mContentDescriptionPhoneSignal;
            combinedSignalIconId = mDataSignalIconId;
        }
    } else if (!mDataConnected && !mWifiConnected && !mBluetoothTethered && !mWimaxConnected) {
        // pretty much totally disconnected
        if ((SystemProperties.OMAP_ENHANCEMENT && !mEthernetConnected) || (!SystemProperties.OMAP_ENHANCEMENT && !ethernetConnected)) {
            combinedLabel = context.getString(R.string.status_bar_settings_signal_meter_disconnected);
            // On devices without mobile radios, we want to show the wifi icon
            combinedSignalIconId = mHasMobileDataFeature ? mDataSignalIconId : mWifiIconId;
            mContentDescriptionCombinedSignal = mHasMobileDataFeature ? mContentDescriptionDataType : mContentDescriptionWifi;
            mDataTypeIconId = 0;
            if (isCdma()) {
                if (isCdmaEri()) {
                    mDataTypeIconId = R.drawable.stat_sys_data_connected_roam;
                }
            } else if (mPhone.isNetworkRoaming()) {
                mDataTypeIconId = R.drawable.stat_sys_data_connected_roam;
            }
        }
    }
    if (DEBUG) {
        Slog.d(TAG, "refreshViews connected={" + (mWifiConnected ? " wifi" : "") + (mDataConnected ? " data" : "") + (SystemProperties.OMAP_ENHANCEMENT ? (mEthernetConnected ? " ethernet" : "") : "") + " } level=" + ((mSignalStrength == null) ? "??" : Integer.toString(mSignalStrength.getLevel())) + " combinedSignalIconId=0x" + Integer.toHexString(combinedSignalIconId) + "/" + getResourceName(combinedSignalIconId) + " combinedActivityIconId=0x" + Integer.toHexString(combinedActivityIconId) + " mobileLabel=" + mobileLabel + " wifiLabel=" + wifiLabel + " combinedLabel=" + combinedLabel + " mAirplaneMode=" + mAirplaneMode + " mDataActivity=" + mDataActivity + " mPhoneSignalIconId=0x" + Integer.toHexString(mPhoneSignalIconId) + " mDataDirectionIconId=0x" + Integer.toHexString(mDataDirectionIconId) + " mDataSignalIconId=0x" + Integer.toHexString(mDataSignalIconId) + " mDataTypeIconId=0x" + Integer.toHexString(mDataTypeIconId) + " mWifiIconId=0x" + Integer.toHexString(mWifiIconId) + " mEthernetIconId=0x" + Integer.toHexString(mEthernetIconId) + (SystemProperties.OMAP_ENHANCEMENT ? " mEthernetIconId=0x" + Integer.toHexString(mEthernetIconId) : "") + " mBluetoothTetherIconId=0x" + Integer.toHexString(mBluetoothTetherIconId));
    }
    if (mLastPhoneSignalIconId != mPhoneSignalIconId || mLastDataDirectionOverlayIconId != combinedActivityIconId || mLastWifiIconId != mWifiIconId || mLastWimaxIconId != mWimaxIconId || mLastDataTypeIconId != mDataTypeIconId || (SystemProperties.OMAP_ENHANCEMENT && mLastEthernetIconId != mEthernetIconId) || mLastAirplaneMode != mAirplaneMode) {
        // NB: the mLast*s will be updated later
        for (SignalCluster cluster : mSignalClusters) {
            refreshSignalCluster(cluster);
        }
    }
    if (mLastAirplaneMode != mAirplaneMode) {
        mLastAirplaneMode = mAirplaneMode;
    }
    // the phone icon on phones
    if (mLastPhoneSignalIconId != mPhoneSignalIconId) {
        mLastPhoneSignalIconId = mPhoneSignalIconId;
        N = mPhoneSignalIconViews.size();
        for (int i = 0; i < N; i++) {
            final ImageView v = mPhoneSignalIconViews.get(i);
            if (mPhoneSignalIconId == 0) {
                v.setVisibility(View.GONE);
            } else {
                v.setVisibility(View.VISIBLE);
                v.setImageResource(mPhoneSignalIconId);
                v.setContentDescription(mContentDescriptionPhoneSignal);
            }
        }
    }
    // the data icon on phones
    if (mLastDataDirectionIconId != mDataDirectionIconId) {
        mLastDataDirectionIconId = mDataDirectionIconId;
        N = mDataDirectionIconViews.size();
        for (int i = 0; i < N; i++) {
            final ImageView v = mDataDirectionIconViews.get(i);
            v.setImageResource(mDataDirectionIconId);
            v.setContentDescription(mContentDescriptionDataType);
        }
    }
    // the wifi icon on phones
    if (mLastWifiIconId != mWifiIconId) {
        mLastWifiIconId = mWifiIconId;
        N = mWifiIconViews.size();
        for (int i = 0; i < N; i++) {
            final ImageView v = mWifiIconViews.get(i);
            if (mWifiIconId == 0) {
                v.setVisibility(View.GONE);
            } else {
                v.setVisibility(View.VISIBLE);
                v.setImageResource(mWifiIconId);
                v.setContentDescription(mContentDescriptionWifi);
            }
        }
    }
    // the Ethernet icon on phones
    if (SystemProperties.OMAP_ENHANCEMENT) {
        if (mLastEthernetIconId != mEthernetIconId) {
            mLastEthernetIconId = mEthernetIconId;
            N = mEthernetIconViews.size();
            for (int i = 0; i < N; i++) {
                final ImageView v = mWifiIconViews.get(i);
                if (mEthernetIconId == 0) {
                    v.setVisibility(View.GONE);
                } else {
                    v.setVisibility(View.VISIBLE);
                    v.setImageResource(mEthernetIconId);
                    v.setContentDescription(mContentDescriptionEthernet);
                }
            }
        }
    }
    // the wimax icon on phones
    if (mLastWimaxIconId != mWimaxIconId) {
        mLastWimaxIconId = mWimaxIconId;
        N = mWimaxIconViews.size();
        for (int i = 0; i < N; i++) {
            final ImageView v = mWimaxIconViews.get(i);
            if (mWimaxIconId == 0) {
                v.setVisibility(View.GONE);
            } else {
                v.setVisibility(View.VISIBLE);
                v.setImageResource(mWimaxIconId);
                v.setContentDescription(mContentDescriptionWimax);
            }
        }
    }
    // the combined data signal icon
    if (mLastCombinedSignalIconId != combinedSignalIconId) {
        mLastCombinedSignalIconId = combinedSignalIconId;
        N = mCombinedSignalIconViews.size();
        for (int i = 0; i < N; i++) {
            final ImageView v = mCombinedSignalIconViews.get(i);
            v.setImageResource(combinedSignalIconId);
            v.setContentDescription(mContentDescriptionCombinedSignal);
        }
    }
    // the data network type overlay
    if (mLastDataTypeIconId != mDataTypeIconId) {
        mLastDataTypeIconId = mDataTypeIconId;
        N = mDataTypeIconViews.size();
        for (int i = 0; i < N; i++) {
            final ImageView v = mDataTypeIconViews.get(i);
            if (mDataTypeIconId == 0) {
                v.setVisibility(View.GONE);
            } else {
                v.setVisibility(View.VISIBLE);
                v.setImageResource(mDataTypeIconId);
                v.setContentDescription(mContentDescriptionDataType);
            }
        }
    }
    // the data direction overlay
    if (mLastDataDirectionOverlayIconId != combinedActivityIconId) {
        if (DEBUG) {
            Slog.d(TAG, "changing data overlay icon id to " + combinedActivityIconId);
        }
        mLastDataDirectionOverlayIconId = combinedActivityIconId;
        N = mDataDirectionOverlayIconViews.size();
        for (int i = 0; i < N; i++) {
            final ImageView v = mDataDirectionOverlayIconViews.get(i);
            if (combinedActivityIconId == 0) {
                v.setVisibility(View.GONE);
            } else {
                v.setVisibility(View.VISIBLE);
                v.setImageResource(combinedActivityIconId);
                v.setContentDescription(mContentDescriptionDataType);
            }
        }
    }
    // the combinedLabel in the notification panel
    if (!mLastCombinedLabel.equals(combinedLabel)) {
        mLastCombinedLabel = combinedLabel;
        N = mCombinedLabelViews.size();
        for (int i = 0; i < N; i++) {
            TextView v = mCombinedLabelViews.get(i);
            v.setText(combinedLabel);
        }
    }
    // wifi label
    N = mWifiLabelViews.size();
    for (int i = 0; i < N; i++) {
        TextView v = mWifiLabelViews.get(i);
        v.setText(wifiLabel);
        if ("".equals(wifiLabel)) {
            v.setVisibility(View.GONE);
        } else {
            v.setVisibility(View.VISIBLE);
        }
    }
    // mobile label
    N = mMobileLabelViews.size();
    for (int i = 0; i < N; i++) {
        TextView v = mMobileLabelViews.get(i);
        v.setText(mobileLabel);
        if ("".equals(mobileLabel)) {
            v.setVisibility(View.GONE);
        } else {
            v.setVisibility(View.VISIBLE);
        }
    }
}
#end_block

#method_before
protected void addPanelWindows() {
    final Context context = mContext;
    final Resources res = mContext.getResources();
    // Notification Panel
    mNotificationPanel = (NotificationPanel) View.inflate(context, R.layout.system_bar_notification_panel, null);
    mNotificationPanel.setBar(this);
    mNotificationPanel.show(false, false);
    mNotificationPanel.setOnTouchListener(new TouchOutsideListener(MSG_CLOSE_NOTIFICATION_PANEL, mNotificationPanel));
    // the battery icon
    mBatteryController.addIconView((ImageView) mNotificationPanel.findViewById(R.id.battery));
    mBatteryController.addLabelView((TextView) mNotificationPanel.findViewById(R.id.battery_text));
    // Bt
    mBluetoothController.addIconView((ImageView) mNotificationPanel.findViewById(R.id.bluetooth));
    // network icons: either a combo icon that switches between mobile and data, or distinct
    // mobile and data icons
    final ImageView mobileRSSI = (ImageView) mNotificationPanel.findViewById(R.id.mobile_signal);
    if (mobileRSSI != null) {
        mNetworkController.addPhoneSignalIconView(mobileRSSI);
    }
    final ImageView wifiRSSI = (ImageView) mNotificationPanel.findViewById(R.id.wifi_signal);
    if (wifiRSSI != null) {
        mNetworkController.addWifiIconView(wifiRSSI);
    }
    mNetworkController.addWifiLabelView((TextView) mNotificationPanel.findViewById(R.id.wifi_text));
    mNetworkController.addDataTypeIconView((ImageView) mNotificationPanel.findViewById(R.id.mobile_type));
    mNetworkController.addMobileLabelView((TextView) mNotificationPanel.findViewById(R.id.mobile_text));
    mNetworkController.addCombinedLabelView((TextView) mBarContents.findViewById(R.id.network_text));
    final ImageView ethernetIcon = (ImageView) mNotificationPanel.findViewById(R.id.ethernet_icon);
    if (ethernetIcon != null) {
        mNetworkController.addEthernetIconView(ethernetIcon);
    }
    mStatusBarView.setIgnoreChildren(0, mNotificationTrigger, mNotificationPanel);
    WindowManager.LayoutParams lp = mNotificationPanelParams = new WindowManager.LayoutParams(res.getDimensionPixelSize(R.dimen.notification_panel_width), getNotificationPanelHeight(), WindowManager.LayoutParams.TYPE_NAVIGATION_BAR_PANEL, WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS | WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM | WindowManager.LayoutParams.FLAG_SPLIT_TOUCH | WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED, PixelFormat.TRANSLUCENT);
    lp.gravity = Gravity.BOTTOM | Gravity.RIGHT;
    lp.setTitle("NotificationPanel");
    lp.softInputMode = WindowManager.LayoutParams.SOFT_INPUT_STATE_UNCHANGED | WindowManager.LayoutParams.SOFT_INPUT_ADJUST_NOTHING;
    // == no animation
    lp.windowAnimations = com.android.internal.R.style.Animation;
    // lp.windowAnimations = com.android.internal.R.style.Animation_ZoomButtons; // simple fade
    WindowManagerImpl.getDefault().addView(mNotificationPanel, lp);
    // Recents Panel
    mRecentTasksLoader = new RecentTasksLoader(context);
    updateRecentsPanel();
    // Search Panel
    mStatusBarView.setBar(this);
    mHomeButton.setOnTouchListener(mHomeSearchActionListener);
    updateSearchPanel();
    // Input methods Panel
    mInputMethodsPanel = (InputMethodsPanel) View.inflate(context, R.layout.system_bar_input_methods_panel, null);
    mInputMethodsPanel.setHardKeyboardEnabledChangeListener(this);
    mInputMethodsPanel.setOnTouchListener(new TouchOutsideListener(MSG_CLOSE_INPUT_METHODS_PANEL, mInputMethodsPanel));
    mInputMethodsPanel.setImeSwitchButton(mInputMethodSwitchButton);
    mStatusBarView.setIgnoreChildren(2, mInputMethodSwitchButton, mInputMethodsPanel);
    lp = new WindowManager.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT, WindowManager.LayoutParams.TYPE_STATUS_BAR_PANEL, WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN | WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM | WindowManager.LayoutParams.FLAG_SPLIT_TOUCH | WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED, PixelFormat.TRANSLUCENT);
    lp.gravity = Gravity.BOTTOM | Gravity.RIGHT;
    lp.setTitle("InputMethodsPanel");
    lp.windowAnimations = R.style.Animation_RecentPanel;
    WindowManagerImpl.getDefault().addView(mInputMethodsPanel, lp);
    // Compatibility mode selector panel
    mCompatModePanel = (CompatModePanel) View.inflate(context, R.layout.system_bar_compat_mode_panel, null);
    mCompatModePanel.setOnTouchListener(new TouchOutsideListener(MSG_CLOSE_COMPAT_MODE_PANEL, mCompatModePanel));
    mCompatModePanel.setTrigger(mCompatModeButton);
    mCompatModePanel.setVisibility(View.GONE);
    mStatusBarView.setIgnoreChildren(3, mCompatModeButton, mCompatModePanel);
    lp = new WindowManager.LayoutParams(250, ViewGroup.LayoutParams.WRAP_CONTENT, WindowManager.LayoutParams.TYPE_STATUS_BAR_PANEL, WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN | WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM | WindowManager.LayoutParams.FLAG_SPLIT_TOUCH | WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED, PixelFormat.TRANSLUCENT);
    lp.gravity = Gravity.BOTTOM | Gravity.RIGHT;
    lp.setTitle("CompatModePanel");
    lp.windowAnimations = android.R.style.Animation_Dialog;
    WindowManagerImpl.getDefault().addView(mCompatModePanel, lp);
    mRecentButton.setOnTouchListener(mRecentsPanel);
    mPile = (NotificationRowLayout) mNotificationPanel.findViewById(R.id.content);
    mPile.removeAllViews();
    mPile.setLongPressListener(getNotificationLongClicker());
    ScrollView scroller = (ScrollView) mPile.getParent();
    scroller.setFillViewport(true);
}
#method_after
protected void addPanelWindows() {
    final Context context = mContext;
    final Resources res = mContext.getResources();
    // Notification Panel
    mNotificationPanel = (NotificationPanel) View.inflate(context, R.layout.system_bar_notification_panel, null);
    mNotificationPanel.setBar(this);
    mNotificationPanel.show(false, false);
    mNotificationPanel.setOnTouchListener(new TouchOutsideListener(MSG_CLOSE_NOTIFICATION_PANEL, mNotificationPanel));
    // the battery icon
    mBatteryController.addIconView((ImageView) mNotificationPanel.findViewById(R.id.battery));
    mBatteryController.addLabelView((TextView) mNotificationPanel.findViewById(R.id.battery_text));
    // Bt
    mBluetoothController.addIconView((ImageView) mNotificationPanel.findViewById(R.id.bluetooth));
    // network icons: either a combo icon that switches between mobile and data, or distinct
    // mobile and data icons
    final ImageView mobileRSSI = (ImageView) mNotificationPanel.findViewById(R.id.mobile_signal);
    if (mobileRSSI != null) {
        mNetworkController.addPhoneSignalIconView(mobileRSSI);
    }
    final ImageView wifiRSSI = (ImageView) mNotificationPanel.findViewById(R.id.wifi_signal);
    if (wifiRSSI != null) {
        mNetworkController.addWifiIconView(wifiRSSI);
    }
    mNetworkController.addWifiLabelView((TextView) mNotificationPanel.findViewById(R.id.wifi_text));
    mNetworkController.addDataTypeIconView((ImageView) mNotificationPanel.findViewById(R.id.mobile_type));
    mNetworkController.addMobileLabelView((TextView) mNotificationPanel.findViewById(R.id.mobile_text));
    mNetworkController.addCombinedLabelView((TextView) mBarContents.findViewById(R.id.network_text));
    final ImageView ethernetIcon = (ImageView) mNotificationPanel.findViewById(R.id.ethernet_icon);
    if (SystemProperties.OMAP_ENHANCEMENT) {
        if (ethernetIcon != null) {
            mNetworkController.addEthernetIconView(ethernetIcon);
        }
    }
    mStatusBarView.setIgnoreChildren(0, mNotificationTrigger, mNotificationPanel);
    WindowManager.LayoutParams lp = mNotificationPanelParams = new WindowManager.LayoutParams(res.getDimensionPixelSize(R.dimen.notification_panel_width), getNotificationPanelHeight(), WindowManager.LayoutParams.TYPE_NAVIGATION_BAR_PANEL, WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS | WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM | WindowManager.LayoutParams.FLAG_SPLIT_TOUCH | WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED, PixelFormat.TRANSLUCENT);
    lp.gravity = Gravity.BOTTOM | Gravity.RIGHT;
    lp.setTitle("NotificationPanel");
    lp.softInputMode = WindowManager.LayoutParams.SOFT_INPUT_STATE_UNCHANGED | WindowManager.LayoutParams.SOFT_INPUT_ADJUST_NOTHING;
    // == no animation
    lp.windowAnimations = com.android.internal.R.style.Animation;
    // lp.windowAnimations = com.android.internal.R.style.Animation_ZoomButtons; // simple fade
    WindowManagerImpl.getDefault().addView(mNotificationPanel, lp);
    // Recents Panel
    mRecentTasksLoader = new RecentTasksLoader(context);
    updateRecentsPanel();
    // Search Panel
    mStatusBarView.setBar(this);
    mHomeButton.setOnTouchListener(mHomeSearchActionListener);
    updateSearchPanel();
    // Input methods Panel
    mInputMethodsPanel = (InputMethodsPanel) View.inflate(context, R.layout.system_bar_input_methods_panel, null);
    mInputMethodsPanel.setHardKeyboardEnabledChangeListener(this);
    mInputMethodsPanel.setOnTouchListener(new TouchOutsideListener(MSG_CLOSE_INPUT_METHODS_PANEL, mInputMethodsPanel));
    mInputMethodsPanel.setImeSwitchButton(mInputMethodSwitchButton);
    mStatusBarView.setIgnoreChildren(2, mInputMethodSwitchButton, mInputMethodsPanel);
    lp = new WindowManager.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT, WindowManager.LayoutParams.TYPE_STATUS_BAR_PANEL, WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN | WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM | WindowManager.LayoutParams.FLAG_SPLIT_TOUCH | WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED, PixelFormat.TRANSLUCENT);
    lp.gravity = Gravity.BOTTOM | Gravity.RIGHT;
    lp.setTitle("InputMethodsPanel");
    lp.windowAnimations = R.style.Animation_RecentPanel;
    WindowManagerImpl.getDefault().addView(mInputMethodsPanel, lp);
    // Compatibility mode selector panel
    mCompatModePanel = (CompatModePanel) View.inflate(context, R.layout.system_bar_compat_mode_panel, null);
    mCompatModePanel.setOnTouchListener(new TouchOutsideListener(MSG_CLOSE_COMPAT_MODE_PANEL, mCompatModePanel));
    mCompatModePanel.setTrigger(mCompatModeButton);
    mCompatModePanel.setVisibility(View.GONE);
    mStatusBarView.setIgnoreChildren(3, mCompatModeButton, mCompatModePanel);
    lp = new WindowManager.LayoutParams(250, ViewGroup.LayoutParams.WRAP_CONTENT, WindowManager.LayoutParams.TYPE_STATUS_BAR_PANEL, WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN | WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM | WindowManager.LayoutParams.FLAG_SPLIT_TOUCH | WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED, PixelFormat.TRANSLUCENT);
    lp.gravity = Gravity.BOTTOM | Gravity.RIGHT;
    lp.setTitle("CompatModePanel");
    lp.windowAnimations = android.R.style.Animation_Dialog;
    WindowManagerImpl.getDefault().addView(mCompatModePanel, lp);
    mRecentButton.setOnTouchListener(mRecentsPanel);
    mPile = (NotificationRowLayout) mNotificationPanel.findViewById(R.id.content);
    mPile.removeAllViews();
    mPile.setLongPressListener(getNotificationLongClicker());
    ScrollView scroller = (ScrollView) mPile.getParent();
    scroller.setFillViewport(true);
}
#end_block

#method_before
private void parseProperties() {
    try {
        if (mProperties != null) {
            /*
                    for (int i = 0;i< mProperties.length;i++) {
                        log("characteristic prop("+i+"):"+mProperties[i]);
                    }
                    */
            for (int j = 0; j < mProperties.length; j++) {
                /*	log("characteristic props:"+mProperties[j]); */
                if (mProperties[j].equals("Name")) {
                    j++;
                } else if (mProperties[j].equals("Description")) {
                    j++;
                } else if (mProperties[j].equals("Broadcast")) {
                    mBroadcasting = mProperties[++j].equals("true");
                } else if (mProperties[j].equals("Indicate")) {
                    mIndicating = mProperties[++j].equals("true");
                } else if (mProperties[j].equals("Notify")) {
                    mNotifying = mProperties[++j].equals("true");
                } else if (mProperties[j].equals("Readable")) {
                    mReadable = mProperties[++j].equals("true");
                } else if (mProperties[j].equals("WriteMethods")) {
                    int method_count = Integer.valueOf(mProperties[++j]);
                    for (int i = 0; i < method_count; i++) {
                        ++j;
                        if (mProperties[j].equals("Write"))
                            mWritableWithRsp = true;
                        else if (mProperties[j].equals("WriteWithoutResponse"))
                            mWritableWitoutRsp = true;
                        else if (mProperties[j].equals("AuthenticatedSignedWrite"))
                            mWritableSigned = true;
                        else if (mProperties[j].equals("ReliableWrite"))
                            mWritableReliable = true;
                    }
                } else if (mProperties[j].equals("UUID")) {
                    mUuid = UUID.fromString(mProperties[++j]);
                } else if (mProperties[j].equals("Value")) {
                    j++;
                } else {
                    Log.e(TAG, "parseProperties Invalid property:\"" + mProperties[j] + "\" (" + mPath + ")");
                    break;
                }
            }
        } else {
            Log.e(TAG, "mProperties = NULL !");
        }
    } catch (Exception e) {
        Log.e(TAG, "parseProperties exception:" + e);
    }
}
#method_after
private void parseProperties() {
    try {
        if (mProperties != null) {
            /*
                    for (int i = 0;i< mProperties.length;i++) {
                        log("characteristic prop("+i+"):"+mProperties[i]);
                    }
                    */
            for (int j = 0; j < mProperties.length; j++) {
                /*        log("characteristic props:"+mProperties[j]); */
                if (mProperties[j].equals("Name")) {
                    j++;
                } else if (mProperties[j].equals("Description")) {
                    j++;
                } else if (mProperties[j].equals("Broadcast")) {
                    mBroadcasting = mProperties[++j].equals("true");
                } else if (mProperties[j].equals("Indicate")) {
                    mIndicating = mProperties[++j].equals("true");
                } else if (mProperties[j].equals("Notify")) {
                    mNotifying = mProperties[++j].equals("true");
                } else if (mProperties[j].equals("Readable")) {
                    mReadable = mProperties[++j].equals("true");
                } else if (mProperties[j].equals("WriteMethods")) {
                    int method_count = Integer.valueOf(mProperties[++j]);
                    for (int i = 0; i < method_count; i++) {
                        ++j;
                        if (mProperties[j].equals("Write"))
                            mWritableWithRsp = true;
                        else if (mProperties[j].equals("WriteWithoutResponse"))
                            mWritableWitoutRsp = true;
                        else if (mProperties[j].equals("AuthenticatedSignedWrite"))
                            mWritableSigned = true;
                        else if (mProperties[j].equals("ReliableWrite"))
                            mWritableReliable = true;
                    }
                } else if (mProperties[j].equals("UUID")) {
                    mUuid = UUID.fromString(mProperties[++j]);
                } else if (mProperties[j].equals("Value")) {
                    j++;
                } else {
                    Log.e(TAG, "parseProperties Invalid property:\"" + mProperties[j] + "\" (" + mPath + ")");
                    break;
                }
            }
        } else {
            Log.e(TAG, "mProperties = NULL !");
        }
    } catch (Exception e) {
        Log.e(TAG, "parseProperties exception:" + e);
    }
}
#end_block

#method_before
public static Uri getContentUri(String volumeName) {
    return Uri.parse(CONTENT_AUTHORITY_SLASH + volumeName + "/video/media");
}
#method_after
public static Uri getContentUri(String volumeName) {
    return Uri.parse(CONTENT_AUTHORITY_SLASH + volumeName + "/images/media");
}
#end_block

#method_before
public static Bitmap getThumbnail(ContentResolver cr, long origId, int kind, BitmapFactory.Options options) {
    return InternalThumbnails.getThumbnail(cr, origId, InternalThumbnails.DEFAULT_GROUP_ID, kind, options, EXTERNAL_CONTENT_URI, true);
}
#method_after
public static Bitmap getThumbnail(ContentResolver cr, long origId, int kind, BitmapFactory.Options options) {
    return InternalThumbnails.getThumbnail(cr, origId, InternalThumbnails.DEFAULT_GROUP_ID, kind, options, EXTERNAL_CONTENT_URI, false);
}
#end_block

#method_before
public static Bitmap getThumbnail(ContentResolver cr, long origId, long groupId, int kind, BitmapFactory.Options options) {
    return InternalThumbnails.getThumbnail(cr, origId, groupId, kind, options, EXTERNAL_CONTENT_URI, true);
}
#method_after
public static Bitmap getThumbnail(ContentResolver cr, long origId, long groupId, int kind, BitmapFactory.Options options) {
    return InternalThumbnails.getThumbnail(cr, origId, groupId, kind, options, EXTERNAL_CONTENT_URI, false);
}
#end_block

#method_before
public static Uri getContentUri(String volumeName) {
    return Uri.parse(CONTENT_AUTHORITY_SLASH + volumeName + "/video/thumbnails");
}
#method_after
public static Uri getContentUri(String volumeName) {
    return Uri.parse(CONTENT_AUTHORITY_SLASH + volumeName + "/images/thumbnails");
}
#end_block

#method_before
public static Uri getContentUri(String volumeName) {
    return Uri.parse(CONTENT_AUTHORITY_SLASH + volumeName + "/video/media");
}
#method_after
public static Uri getContentUri(String volumeName) {
    return Uri.parse(CONTENT_AUTHORITY_SLASH + volumeName + "/audio/media");
}
#end_block

#method_before
public static final Uri getContentUri(String volumeName, long playlistId) {
    return Uri.parse(CONTENT_AUTHORITY_SLASH + volumeName + "/audio/playlists/" + playlistId + "/members");
}
#method_after
public static final Uri getContentUri(String volumeName, long genreId) {
    return Uri.parse(CONTENT_AUTHORITY_SLASH + volumeName + "/audio/genres/" + genreId + "/members");
}
#end_block

#method_before
public static void cancelThumbnailRequest(ContentResolver cr, long origId, long groupId) {
    InternalThumbnails.cancelThumbnailRequest(cr, origId, EXTERNAL_CONTENT_URI, groupId);
}
#method_after
public static void cancelThumbnailRequest(ContentResolver cr, long origId) {
    InternalThumbnails.cancelThumbnailRequest(cr, origId, EXTERNAL_CONTENT_URI, InternalThumbnails.DEFAULT_GROUP_ID);
}
#end_block

#method_before
public static Bitmap getThumbnail(ContentResolver cr, long origId, long groupId, int kind, BitmapFactory.Options options) {
    return InternalThumbnails.getThumbnail(cr, origId, groupId, kind, options, EXTERNAL_CONTENT_URI, true);
}
#method_after
public static Bitmap getThumbnail(ContentResolver cr, long origId, int kind, BitmapFactory.Options options) {
    return InternalThumbnails.getThumbnail(cr, origId, InternalThumbnails.DEFAULT_GROUP_ID, kind, options, EXTERNAL_CONTENT_URI, true);
}
#end_block

#method_before
private void startDataStallAlarm(boolean suspectedStall) {
    int nextAction = getRecoveryAction();
    int delayInMs;
    // with an aggresive timeout.
    if (mIsScreenOn || suspectedStall || RecoveryAction.isAggressiveRecovery(nextAction)) {
        delayInMs = Settings.Secure.getInt(mResolver, Settings.Secure.DATA_STALL_ALARM_AGGRESSIVE_DELAY_IN_MS, DATA_STALL_ALARM_AGGRESSIVE_DELAY_IN_MS_DEFAULT);
    } else {
        delayInMs = Settings.Secure.getInt(mResolver, Settings.Secure.DATA_STALL_ALARM_NON_AGGRESSIVE_DELAY_IN_MS, DATA_STALL_ALARM_NON_AGGRESSIVE_DELAY_IN_MS_DEFAULT);
    }
    mDataStallAlarmTag += 1;
    if (VDBG) {
        log("startDataStallAlarm: tag=" + mDataStallAlarmTag + " delay=" + (delayInMs / 1000) + "s");
    }
    AlarmManager am = (AlarmManager) mPhone.getContext().getSystemService(Context.ALARM_SERVICE);
    Intent intent = new Intent(INTENT_DATA_STALL_ALARM);
    intent.putExtra(DATA_STALL_ALARM_TAG_EXTRA, mDataStallAlarmTag);
    mDataStallAlarmIntent = PendingIntent.getBroadcast(mPhone.getContext(), 0, intent, PendingIntent.FLAG_UPDATE_CURRENT);
    am.set(AlarmManager.ELAPSED_REALTIME_WAKEUP, SystemClock.elapsedRealtime() + delayInMs, mDataStallAlarmIntent);
    if ("true".equals(System.getProperty("omap.enhancement"))) {
        mDataStallAlarmCount += 1;
    }
}
#method_after
private void startDataStallAlarm(boolean suspectedStall) {
    int nextAction = getRecoveryAction();
    int delayInMs;
    // with an aggresive timeout.
    if (mIsScreenOn || suspectedStall || RecoveryAction.isAggressiveRecovery(nextAction)) {
        delayInMs = Settings.Secure.getInt(mResolver, Settings.Secure.DATA_STALL_ALARM_AGGRESSIVE_DELAY_IN_MS, DATA_STALL_ALARM_AGGRESSIVE_DELAY_IN_MS_DEFAULT);
    } else {
        delayInMs = Settings.Secure.getInt(mResolver, Settings.Secure.DATA_STALL_ALARM_NON_AGGRESSIVE_DELAY_IN_MS, DATA_STALL_ALARM_NON_AGGRESSIVE_DELAY_IN_MS_DEFAULT);
    }
    mDataStallAlarmTag += 1;
    if (VDBG) {
        log("startDataStallAlarm: tag=" + mDataStallAlarmTag + " delay=" + (delayInMs / 1000) + "s");
    }
    AlarmManager am = (AlarmManager) mPhone.getContext().getSystemService(Context.ALARM_SERVICE);
    Intent intent = new Intent(INTENT_DATA_STALL_ALARM);
    intent.putExtra(DATA_STALL_ALARM_TAG_EXTRA, mDataStallAlarmTag);
    mDataStallAlarmIntent = PendingIntent.getBroadcast(mPhone.getContext(), 0, intent, PendingIntent.FLAG_UPDATE_CURRENT);
    am.set(AlarmManager.ELAPSED_REALTIME_WAKEUP, SystemClock.elapsedRealtime() + delayInMs, mDataStallAlarmIntent);
}
#end_block

#method_before
private void stopDataStallAlarm() {
    AlarmManager am = (AlarmManager) mPhone.getContext().getSystemService(Context.ALARM_SERVICE);
    if (VDBG) {
        log("stopDataStallAlarm: current tag=" + mDataStallAlarmTag + " mDataStallAlarmIntent=" + mDataStallAlarmIntent);
    }
    mDataStallAlarmTag += 1;
    if (mDataStallAlarmIntent != null) {
        am.cancel(mDataStallAlarmIntent);
        mDataStallAlarmIntent = null;
        if ("true".equals(System.getProperty("omap.enhancement"))) {
            mDataStallAlarmCount -= 1;
        }
    }
}
#method_after
private void stopDataStallAlarm() {
    AlarmManager am = (AlarmManager) mPhone.getContext().getSystemService(Context.ALARM_SERVICE);
    if (VDBG) {
        log("stopDataStallAlarm: current tag=" + mDataStallAlarmTag + " mDataStallAlarmIntent=" + mDataStallAlarmIntent);
    }
    mDataStallAlarmTag += 1;
    if (mDataStallAlarmIntent != null) {
        am.cancel(mDataStallAlarmIntent);
        mDataStallAlarmIntent = null;
    }
}
#end_block

#method_before
@Override
protected void restartDataStallAlarm() {
    // To be called on screen status change.
    // Do not cancel the alarm if it is set with aggressive timeout.
    int nextAction = getRecoveryAction();
    if (RecoveryAction.isAggressiveRecovery(nextAction)) {
        if (DBG)
            log("data stall recovery action is pending. not resetting the alarm.");
        return;
    }
    if ("true".equals(System.getProperty("omap.enhancement"))) {
        if (mUserDataEnabled && mDataStallAlarmCount > 0) {
            stopDataStallAlarm();
            startDataStallAlarm(DATA_STALL_NOT_SUSPECTED);
        } else {
            if (DBG)
                log("Data connection is not enabled or no alarms");
        }
    } else {
        stopDataStallAlarm();
        startDataStallAlarm(DATA_STALL_NOT_SUSPECTED);
    }
}
#method_after
@Override
protected void restartDataStallAlarm() {
    // To be called on screen status change.
    // Do not cancel the alarm if it is set with aggressive timeout.
    int nextAction = getRecoveryAction();
    if (RecoveryAction.isAggressiveRecovery(nextAction)) {
        if (DBG)
            log("data stall recovery action is pending. not resetting the alarm.");
        return;
    }
    if ("true".equals(System.getProperty("omap.enhancement"))) {
        if (mDataStallAlarmIntent != null) {
            stopDataStallAlarm();
            startDataStallAlarm(DATA_STALL_NOT_SUSPECTED);
        } else {
            if (DBG)
                log("Data connection is not enabled or no alarms");
        }
    } else {
        stopDataStallAlarm();
        startDataStallAlarm(DATA_STALL_NOT_SUSPECTED);
    }
}
#end_block

#method_before
@Override
public void pause() {
    if (isPlaying()) {
        mPlayer.pause();
    } else if (mCurrentState == STATE_NOTPREPARED) {
        mPauseDuringPreparing = true;
    }
    super.pause();
}
#method_after
@Override
public void pause() {
    if ("true".equals(System.getProperty("omap.enhancement"))) {
        if (isPlaying()) {
            mPlayer.pause();
        } else if (mCurrentState == STATE_NOTPREPARED) {
            mPauseDuringPreparing = true;
        }
        // Delete the Timer to stop it since there is no stop call.
        if (mTimer != null) {
            mTimer.purge();
            mTimer.cancel();
            mTimer = null;
        }
    }
}
#end_block

#method_before
public void pause() {
    // Delete the Timer to stop it since there is no stop call.
    if (mTimer != null) {
        mTimer.purge();
        mTimer.cancel();
        mTimer = null;
    }
}
#method_after
public void pause() {
    if (!("true".equals(System.getProperty("omap.enhancement")))) {
        if (isPlaying()) {
            mPlayer.pause();
        } else if (mCurrentState == STATE_NOTPREPARED) {
            mPauseDuringPreparing = true;
        }
        // Delete the Timer to stop it since there is no stop call.
        if (mTimer != null) {
            mTimer.purge();
            mTimer.cancel();
            mTimer = null;
        }
    }
}
#end_block

#method_before
@Override
public void pause() {
    if (isPlaying()) {
        mPlayer.pause();
        if ("true".equals(System.getProperty("omap.enhancement"))) {
            mPlayer.stop();
            deleteSurfaceTexture();
        }
    } else if (mCurrentState == STATE_NOTPREPARED) {
        mPauseDuringPreparing = true;
    }
    super.pause();
}
#method_after
@Override
public void pause() {
    if ("true".equals(System.getProperty("omap.enhancement"))) {
        if (isPlaying()) {
            mPlayer.pause();
            mPlayer.stop();
            deleteSurfaceTexture();
        } else if (mCurrentState == STATE_NOTPREPARED) {
            mPauseDuringPreparing = true;
        }
        // Delete the Timer to stop it since there is no stop call.
        if (mTimer != null) {
            mTimer.purge();
            mTimer.cancel();
            mTimer = null;
        }
    }
}
#end_block

#method_before
@Override
public void run() {
    EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_SYSTEM_RUN, SystemClock.uptimeMillis());
    Looper.prepare();
    android.os.Process.setThreadPriority(android.os.Process.THREAD_PRIORITY_FOREGROUND);
    BinderInternal.disableBackgroundScheduling(true);
    android.os.Process.setCanSelfBackground(false);
    // Check whether we failed to shut down last time we tried.
    {
        final String shutdownAction = SystemProperties.get(ShutdownThread.SHUTDOWN_ACTION_PROPERTY, "");
        if (shutdownAction != null && shutdownAction.length() > 0) {
            boolean reboot = (shutdownAction.charAt(0) == '1');
            final String reason;
            if (shutdownAction.length() > 1) {
                reason = shutdownAction.substring(1, shutdownAction.length());
            } else {
                reason = null;
            }
            ShutdownThread.rebootOrShutdown(reboot, reason);
        }
    }
    String factoryTestStr = SystemProperties.get("ro.factorytest");
    int factoryTest = "".equals(factoryTestStr) ? SystemServer.FACTORY_TEST_OFF : Integer.parseInt(factoryTestStr);
    final boolean headless = "1".equals(SystemProperties.get("ro.config.headless", "0"));
    LightsService lights = null;
    PowerManagerService power = null;
    BatteryService battery = null;
    VibratorService vibrator = null;
    AlarmManagerService alarm = null;
    NetworkManagementService networkManagement = null;
    NetworkStatsService networkStats = null;
    NetworkPolicyManagerService networkPolicy = null;
    ConnectivityService connectivity = null;
    WifiP2pService wifiP2p = null;
    WifiService wifi = null;
    NsdService serviceDiscovery = null;
    IPackageManager pm = null;
    Context context = null;
    WindowManagerService wm = null;
    BluetoothService bluetooth = null;
    BluetoothA2dpService bluetoothA2dp = null;
    DockObserver dock = null;
    UsbService usb = null;
    SerialService serial = null;
    UiModeManagerService uiMode = null;
    RecognitionManagerService recognition = null;
    ThrottleService throttle = null;
    NetworkTimeUpdateService networkTimeUpdater = null;
    CommonTimeManagementService commonTimeMgmtService = null;
    InputManagerService inputManager = null;
    // Critical services...
    try {
        Slog.i(TAG, "Entropy Mixer");
        ServiceManager.addService("entropy", new EntropyMixer());
        Slog.i(TAG, "Power Manager");
        power = new PowerManagerService();
        ServiceManager.addService(Context.POWER_SERVICE, power);
        Slog.i(TAG, "Activity Manager");
        context = ActivityManagerService.main(factoryTest);
        Slog.i(TAG, "Telephony Registry");
        ServiceManager.addService("telephony.registry", new TelephonyRegistry(context));
        Slog.i(TAG, "Scheduling Policy");
        ServiceManager.addService(Context.SCHEDULING_POLICY_SERVICE, new SchedulingPolicyService());
        AttributeCache.init(context);
        Slog.i(TAG, "Package Manager");
        // Only run "core" apps if we're encrypting the device.
        String cryptState = SystemProperties.get("vold.decrypt");
        boolean onlyCore = false;
        if (ENCRYPTING_STATE.equals(cryptState)) {
            Slog.w(TAG, "Detected encryption in progress - only parsing core apps");
            onlyCore = true;
        } else if (ENCRYPTED_STATE.equals(cryptState)) {
            Slog.w(TAG, "Device encrypted - only parsing core apps");
            onlyCore = true;
        }
        pm = PackageManagerService.main(context, factoryTest != SystemServer.FACTORY_TEST_OFF, onlyCore);
        boolean firstBoot = false;
        try {
            firstBoot = pm.isFirstBoot();
        } catch (RemoteException e) {
        }
        ActivityManagerService.setSystemProcess();
        mContentResolver = context.getContentResolver();
        // The AccountManager must come before the ContentService
        try {
            Slog.i(TAG, "Account Manager");
            ServiceManager.addService(Context.ACCOUNT_SERVICE, new AccountManagerService(context));
        } catch (Throwable e) {
            Slog.e(TAG, "Failure starting Account Manager", e);
        }
        Slog.i(TAG, "Content Manager");
        ContentService.main(context, factoryTest == SystemServer.FACTORY_TEST_LOW_LEVEL);
        Slog.i(TAG, "System Content Providers");
        ActivityManagerService.installSystemProviders();
        Slog.i(TAG, "Lights Service");
        lights = new LightsService(context);
        Slog.i(TAG, "Battery Service");
        battery = new BatteryService(context, lights);
        ServiceManager.addService("battery", battery);
        Slog.i(TAG, "Vibrator Service");
        vibrator = new VibratorService(context);
        ServiceManager.addService("vibrator", vibrator);
        // only initialize the power service after we have started the
        // lights service, content providers and the battery service.
        power.init(context, lights, ActivityManagerService.self(), battery);
        Slog.i(TAG, "Alarm Manager");
        alarm = new AlarmManagerService(context);
        ServiceManager.addService(Context.ALARM_SERVICE, alarm);
        Slog.i(TAG, "Init Watchdog");
        Watchdog.getInstance().init(context, battery, power, alarm, ActivityManagerService.self());
        Slog.i(TAG, "Window Manager");
        wm = WindowManagerService.main(context, power, factoryTest != SystemServer.FACTORY_TEST_LOW_LEVEL, !firstBoot, onlyCore);
        ServiceManager.addService(Context.WINDOW_SERVICE, wm);
        inputManager = wm.getInputManagerService();
        ServiceManager.addService(Context.INPUT_SERVICE, inputManager);
        ActivityManagerService.self().setWindowManager(wm);
        // support Bluetooth - see bug 988521
        if (SystemProperties.get("ro.kernel.qemu").equals("1")) {
            Slog.i(TAG, "No Bluetooh Service (emulator)");
        } else if (factoryTest == SystemServer.FACTORY_TEST_LOW_LEVEL) {
            Slog.i(TAG, "No Bluetooth Service (factory test)");
        } else {
            Slog.i(TAG, "Bluetooth Service");
            bluetooth = new BluetoothService(context);
            ServiceManager.addService(BluetoothAdapter.BLUETOOTH_SERVICE, bluetooth);
            bluetooth.initAfterRegistration();
            if (!"0".equals(SystemProperties.get("system_init.startaudioservice"))) {
                bluetoothA2dp = new BluetoothA2dpService(context, bluetooth);
                ServiceManager.addService(BluetoothA2dpService.BLUETOOTH_A2DP_SERVICE, bluetoothA2dp);
                bluetooth.initAfterA2dpRegistration();
            }
            int bluetoothOn = Settings.Secure.getInt(mContentResolver, Settings.Secure.BLUETOOTH_ON, 0);
            if (bluetoothOn != 0) {
                bluetooth.enable();
            }
        }
    } catch (RuntimeException e) {
        Slog.e("System", "******************************************");
        Slog.e("System", "************ Failure starting core service", e);
    }
    DevicePolicyManagerService devicePolicy = null;
    StatusBarManagerService statusBar = null;
    InputMethodManagerService imm = null;
    AppWidgetService appWidget = null;
    NotificationManagerService notification = null;
    WallpaperManagerService wallpaper = null;
    LocationManagerService location = null;
    CountryDetectorService countryDetector = null;
    TextServicesManagerService tsms = null;
    LockSettingsService lockSettings = null;
    DreamManagerService dreamy = null;
    // Bring up services needed for UI.
    if (factoryTest != SystemServer.FACTORY_TEST_LOW_LEVEL) {
        try {
            Slog.i(TAG, "Input Method Service");
            imm = new InputMethodManagerService(context, wm);
            ServiceManager.addService(Context.INPUT_METHOD_SERVICE, imm);
        } catch (Throwable e) {
            reportWtf("starting Input Manager Service", e);
        }
        try {
            Slog.i(TAG, "Accessibility Manager");
            ServiceManager.addService(Context.ACCESSIBILITY_SERVICE, new AccessibilityManagerService(context));
        } catch (Throwable e) {
            reportWtf("starting Accessibility Manager", e);
        }
    }
    try {
        wm.displayReady();
    } catch (Throwable e) {
        reportWtf("making display ready", e);
    }
    try {
        pm.performBootDexOpt();
    } catch (Throwable e) {
        reportWtf("performing boot dexopt", e);
    }
    try {
        ActivityManagerNative.getDefault().showBootMessage(context.getResources().getText(com.android.internal.R.string.android_upgrading_starting_apps), false);
    } catch (RemoteException e) {
    }
    if (factoryTest != SystemServer.FACTORY_TEST_LOW_LEVEL) {
        MountService mountService = null;
        if (!"0".equals(SystemProperties.get("system_init.startmountservice"))) {
            try {
                /*
                     * NotificationManagerService is dependant on MountService,
                     * (for media / usb notifications) so we must start MountService first.
                     */
                Slog.i(TAG, "Mount Service");
                mountService = new MountService(context);
                ServiceManager.addService("mount", mountService);
            } catch (Throwable e) {
                reportWtf("starting Mount Service", e);
            }
        }
        try {
            Slog.i(TAG, "LockSettingsService");
            lockSettings = new LockSettingsService(context);
            ServiceManager.addService("lock_settings", lockSettings);
        } catch (Throwable e) {
            reportWtf("starting LockSettingsService service", e);
        }
        try {
            Slog.i(TAG, "Device Policy");
            devicePolicy = new DevicePolicyManagerService(context);
            ServiceManager.addService(Context.DEVICE_POLICY_SERVICE, devicePolicy);
        } catch (Throwable e) {
            reportWtf("starting DevicePolicyService", e);
        }
        try {
            Slog.i(TAG, "Status Bar");
            statusBar = new StatusBarManagerService(context, wm);
            ServiceManager.addService(Context.STATUS_BAR_SERVICE, statusBar);
        } catch (Throwable e) {
            reportWtf("starting StatusBarManagerService", e);
        }
        try {
            Slog.i(TAG, "Clipboard Service");
            ServiceManager.addService(Context.CLIPBOARD_SERVICE, new ClipboardService(context));
        } catch (Throwable e) {
            reportWtf("starting Clipboard Service", e);
        }
        try {
            Slog.i(TAG, "NetworkManagement Service");
            networkManagement = NetworkManagementService.create(context);
            ServiceManager.addService(Context.NETWORKMANAGEMENT_SERVICE, networkManagement);
        } catch (Throwable e) {
            reportWtf("starting NetworkManagement Service", e);
        }
        try {
            Slog.i(TAG, "Text Service Manager Service");
            tsms = new TextServicesManagerService(context);
            ServiceManager.addService(Context.TEXT_SERVICES_MANAGER_SERVICE, tsms);
        } catch (Throwable e) {
            reportWtf("starting Text Service Manager Service", e);
        }
        try {
            Slog.i(TAG, "NetworkStats Service");
            networkStats = new NetworkStatsService(context, networkManagement, alarm);
            ServiceManager.addService(Context.NETWORK_STATS_SERVICE, networkStats);
        } catch (Throwable e) {
            reportWtf("starting NetworkStats Service", e);
        }
        try {
            Slog.i(TAG, "NetworkPolicy Service");
            networkPolicy = new NetworkPolicyManagerService(context, ActivityManagerService.self(), power, networkStats, networkManagement);
            ServiceManager.addService(Context.NETWORK_POLICY_SERVICE, networkPolicy);
        } catch (Throwable e) {
            reportWtf("starting NetworkPolicy Service", e);
        }
        try {
            Slog.i(TAG, "Wi-Fi P2pService");
            wifiP2p = new WifiP2pService(context);
            ServiceManager.addService(Context.WIFI_P2P_SERVICE, wifiP2p);
        } catch (Throwable e) {
            reportWtf("starting Wi-Fi P2pService", e);
        }
        try {
            Slog.i(TAG, "Wi-Fi Service");
            wifi = new WifiService(context);
            ServiceManager.addService(Context.WIFI_SERVICE, wifi);
        } catch (Throwable e) {
            reportWtf("starting Wi-Fi Service", e);
        }
        try {
            Slog.i(TAG, "Connectivity Service");
            connectivity = new ConnectivityService(context, networkManagement, networkStats, networkPolicy);
            ServiceManager.addService(Context.CONNECTIVITY_SERVICE, connectivity);
            networkStats.bindConnectivityManager(connectivity);
            networkPolicy.bindConnectivityManager(connectivity);
            wifi.checkAndStartWifi();
            wifiP2p.connectivityServiceReady();
        } catch (Throwable e) {
            reportWtf("starting Connectivity Service", e);
        }
        try {
            Slog.i(TAG, "Network Service Discovery Service");
            serviceDiscovery = NsdService.create(context);
            ServiceManager.addService(Context.NSD_SERVICE, serviceDiscovery);
        } catch (Throwable e) {
            reportWtf("starting Service Discovery Service", e);
        }
        try {
            Slog.i(TAG, "Throttle Service");
            throttle = new ThrottleService(context);
            ServiceManager.addService(Context.THROTTLE_SERVICE, throttle);
        } catch (Throwable e) {
            reportWtf("starting ThrottleService", e);
        }
        try {
            Slog.i(TAG, "UpdateLock Service");
            ServiceManager.addService(Context.UPDATE_LOCK_SERVICE, new UpdateLockService(context));
        } catch (Throwable e) {
            reportWtf("starting UpdateLockService", e);
        }
        /*
             * MountService has a few dependencies: Notification Manager and
             * AppWidget Provider. Make sure MountService is completely started
             * first before continuing.
             */
        if (mountService != null) {
            mountService.waitForAsecScan();
        }
        try {
            Slog.i(TAG, "Notification Manager");
            notification = new NotificationManagerService(context, statusBar, lights);
            ServiceManager.addService(Context.NOTIFICATION_SERVICE, notification);
            networkPolicy.bindNotificationManager(notification);
        } catch (Throwable e) {
            reportWtf("starting Notification Manager", e);
        }
        try {
            Slog.i(TAG, "Device Storage Monitor");
            ServiceManager.addService(DeviceStorageMonitorService.SERVICE, new DeviceStorageMonitorService(context));
        } catch (Throwable e) {
            reportWtf("starting DeviceStorageMonitor service", e);
        }
        try {
            Slog.i(TAG, "starting SUPL Service (SystemServer)");
            ServiceManager.addService("SUPL_SERVICE", SUPLService.getInstance(context));
        } catch (Throwable e) {
            Slog.e(TAG, "Failure installing SUPL Service", e);
        }
        try {
            Slog.i(TAG, "Location Manager");
            location = new LocationManagerService(context);
            ServiceManager.addService(Context.LOCATION_SERVICE, location);
        } catch (Throwable e) {
            reportWtf("starting Location Manager", e);
        }
        try {
            Slog.i(TAG, "Country Detector");
            countryDetector = new CountryDetectorService(context);
            ServiceManager.addService(Context.COUNTRY_DETECTOR, countryDetector);
        } catch (Throwable e) {
            reportWtf("starting Country Detector", e);
        }
        try {
            Slog.i(TAG, "Search Service");
            ServiceManager.addService(Context.SEARCH_SERVICE, new SearchManagerService(context));
        } catch (Throwable e) {
            reportWtf("starting Search Service", e);
        }
        try {
            Slog.i(TAG, "DropBox Service");
            ServiceManager.addService(Context.DROPBOX_SERVICE, new DropBoxManagerService(context, new File("/data/system/dropbox")));
        } catch (Throwable e) {
            reportWtf("starting DropBoxManagerService", e);
        }
        if (context.getResources().getBoolean(com.android.internal.R.bool.config_enableWallpaperService)) {
            try {
                Slog.i(TAG, "Wallpaper Service");
                if (!headless) {
                    wallpaper = new WallpaperManagerService(context);
                    ServiceManager.addService(Context.WALLPAPER_SERVICE, wallpaper);
                }
            } catch (Throwable e) {
                reportWtf("starting Wallpaper Service", e);
            }
        }
        if (!"0".equals(SystemProperties.get("system_init.startaudioservice"))) {
            try {
                Slog.i(TAG, "Audio Service");
                ServiceManager.addService(Context.AUDIO_SERVICE, new AudioService(context));
            } catch (Throwable e) {
                reportWtf("starting Audio Service", e);
            }
        }
        try {
            Slog.i(TAG, "Dock Observer");
            // Listen for dock station changes
            dock = new DockObserver(context, power);
        } catch (Throwable e) {
            reportWtf("starting DockObserver", e);
        }
        try {
            Slog.i(TAG, "Wired Accessory Observer");
            // Listen for wired headset changes
            new WiredAccessoryObserver(context);
        } catch (Throwable e) {
            reportWtf("starting WiredAccessoryObserver", e);
        }
        try {
            Slog.i(TAG, "USB Service");
            // Manage USB host and device support
            usb = new UsbService(context);
            ServiceManager.addService(Context.USB_SERVICE, usb);
        } catch (Throwable e) {
            reportWtf("starting UsbService", e);
        }
        try {
            Slog.i(TAG, "Serial Service");
            // Serial port support
            serial = new SerialService(context);
            ServiceManager.addService(Context.SERIAL_SERVICE, serial);
        } catch (Throwable e) {
            Slog.e(TAG, "Failure starting SerialService", e);
        }
        try {
            Slog.i(TAG, "UI Mode Manager Service");
            // Listen for UI mode changes
            uiMode = new UiModeManagerService(context);
        } catch (Throwable e) {
            reportWtf("starting UiModeManagerService", e);
        }
        try {
            Slog.i(TAG, "Backup Service");
            ServiceManager.addService(Context.BACKUP_SERVICE, new BackupManagerService(context));
        } catch (Throwable e) {
            Slog.e(TAG, "Failure starting Backup Service", e);
        }
        try {
            Slog.i(TAG, "AppWidget Service");
            appWidget = new AppWidgetService(context);
            ServiceManager.addService(Context.APPWIDGET_SERVICE, appWidget);
        } catch (Throwable e) {
            reportWtf("starting AppWidget Service", e);
        }
        try {
            Slog.i(TAG, "Recognition Service");
            recognition = new RecognitionManagerService(context);
        } catch (Throwable e) {
            reportWtf("starting Recognition Service", e);
        }
        try {
            Slog.i(TAG, "DiskStats Service");
            ServiceManager.addService("diskstats", new DiskStatsService(context));
        } catch (Throwable e) {
            reportWtf("starting DiskStats Service", e);
        }
        try {
            // need to add this service even if SamplingProfilerIntegration.isEnabled()
            // is false, because it is this service that detects system property change and
            // turns on SamplingProfilerIntegration. Plus, when sampling profiler doesn't work,
            // there is little overhead for running this service.
            Slog.i(TAG, "SamplingProfiler Service");
            ServiceManager.addService("samplingprofiler", new SamplingProfilerService(context));
        } catch (Throwable e) {
            reportWtf("starting SamplingProfiler Service", e);
        }
        try {
            Slog.i(TAG, "NetworkTimeUpdateService");
            networkTimeUpdater = new NetworkTimeUpdateService(context);
        } catch (Throwable e) {
            reportWtf("starting NetworkTimeUpdate service", e);
        }
        try {
            Slog.i(TAG, "CommonTimeManagementService");
            commonTimeMgmtService = new CommonTimeManagementService(context);
            ServiceManager.addService("commontime_management", commonTimeMgmtService);
        } catch (Throwable e) {
            reportWtf("starting CommonTimeManagementService service", e);
        }
        try {
            Slog.i(TAG, "CertBlacklister");
            CertBlacklister blacklister = new CertBlacklister(context);
        } catch (Throwable e) {
            reportWtf("starting CertBlacklister", e);
        }
        if (context.getResources().getBoolean(com.android.internal.R.bool.config_enableDreams)) {
            try {
                Slog.i(TAG, "Dreams Service");
                // Dreams (interactive idle-time views, a/k/a screen savers)
                dreamy = new DreamManagerService(context);
                ServiceManager.addService("dreams", dreamy);
            } catch (Throwable e) {
                reportWtf("starting DreamManagerService", e);
            }
        }
    }
    // Before things start rolling, be sure we have decided whether
    // we are in safe mode.
    final boolean safeMode = wm.detectSafeMode();
    if (safeMode) {
        ActivityManagerService.self().enterSafeMode();
        // Post the safe mode state in the Zygote class
        Zygote.systemInSafeMode = true;
        // Disable the JIT for the system_server process
        VMRuntime.getRuntime().disableJitCompilation();
    } else {
        // Enable the JIT for the system_server process
        VMRuntime.getRuntime().startJitCompilation();
    }
    try {
        vibrator.systemReady();
    } catch (Throwable e) {
        reportWtf("making Vibrator Service ready", e);
    }
    if (devicePolicy != null) {
        try {
            devicePolicy.systemReady();
        } catch (Throwable e) {
            reportWtf("making Device Policy Service ready", e);
        }
    }
    if (notification != null) {
        try {
            notification.systemReady();
        } catch (Throwable e) {
            reportWtf("making Notification Service ready", e);
        }
    }
    try {
        wm.systemReady();
    } catch (Throwable e) {
        reportWtf("making Window Manager Service ready", e);
    }
    if (safeMode) {
        ActivityManagerService.self().showSafeModeOverlay();
    }
    // Update the configuration for this context by hand, because we're going
    // to start using it before the config change done in wm.systemReady() will
    // propagate to it.
    Configuration config = wm.computeNewConfiguration();
    DisplayMetrics metrics = new DisplayMetrics();
    WindowManager w = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
    w.getDefaultDisplay().getMetrics(metrics);
    context.getResources().updateConfiguration(config, metrics);
    power.systemReady();
    try {
        pm.systemReady();
    } catch (Throwable e) {
        reportWtf("making Package Manager Service ready", e);
    }
    try {
        lockSettings.systemReady();
    } catch (Throwable e) {
        reportWtf("making Lock Settings Service ready", e);
    }
    // These are needed to propagate to the runnable below.
    final Context contextF = context;
    final BatteryService batteryF = battery;
    final NetworkManagementService networkManagementF = networkManagement;
    final NetworkStatsService networkStatsF = networkStats;
    final NetworkPolicyManagerService networkPolicyF = networkPolicy;
    final ConnectivityService connectivityF = connectivity;
    final DockObserver dockF = dock;
    final UsbService usbF = usb;
    final ThrottleService throttleF = throttle;
    final UiModeManagerService uiModeF = uiMode;
    final AppWidgetService appWidgetF = appWidget;
    final WallpaperManagerService wallpaperF = wallpaper;
    final InputMethodManagerService immF = imm;
    final RecognitionManagerService recognitionF = recognition;
    final LocationManagerService locationF = location;
    final CountryDetectorService countryDetectorF = countryDetector;
    final NetworkTimeUpdateService networkTimeUpdaterF = networkTimeUpdater;
    final CommonTimeManagementService commonTimeMgmtServiceF = commonTimeMgmtService;
    final TextServicesManagerService textServiceManagerServiceF = tsms;
    final StatusBarManagerService statusBarF = statusBar;
    final DreamManagerService dreamyF = dreamy;
    final InputManagerService inputManagerF = inputManager;
    final BluetoothService bluetoothF = bluetooth;
    // We now tell the activity manager it is okay to run third party
    // code.  It will call back into us once it has gotten to the state
    // where third party code can really run (but before it has actually
    // started launching the initial applications), for us to complete our
    // initialization.
    ActivityManagerService.self().systemReady(new Runnable() {

        public void run() {
            Slog.i(TAG, "Making services ready");
            if (!headless)
                startSystemUi(contextF);
            try {
                if (batteryF != null)
                    batteryF.systemReady();
            } catch (Throwable e) {
                reportWtf("making Battery Service ready", e);
            }
            try {
                if (networkManagementF != null)
                    networkManagementF.systemReady();
            } catch (Throwable e) {
                reportWtf("making Network Managment Service ready", e);
            }
            try {
                if (networkStatsF != null)
                    networkStatsF.systemReady();
            } catch (Throwable e) {
                reportWtf("making Network Stats Service ready", e);
            }
            try {
                if (networkPolicyF != null)
                    networkPolicyF.systemReady();
            } catch (Throwable e) {
                reportWtf("making Network Policy Service ready", e);
            }
            try {
                if (connectivityF != null)
                    connectivityF.systemReady();
            } catch (Throwable e) {
                reportWtf("making Connectivity Service ready", e);
            }
            try {
                if (dockF != null)
                    dockF.systemReady();
            } catch (Throwable e) {
                reportWtf("making Dock Service ready", e);
            }
            try {
                if (usbF != null)
                    usbF.systemReady();
            } catch (Throwable e) {
                reportWtf("making USB Service ready", e);
            }
            try {
                if (uiModeF != null)
                    uiModeF.systemReady();
            } catch (Throwable e) {
                reportWtf("making UI Mode Service ready", e);
            }
            try {
                if (recognitionF != null)
                    recognitionF.systemReady();
            } catch (Throwable e) {
                reportWtf("making Recognition Service ready", e);
            }
            Watchdog.getInstance().start();
            try {
                if (appWidgetF != null)
                    appWidgetF.systemReady(safeMode);
            } catch (Throwable e) {
                reportWtf("making App Widget Service ready", e);
            }
            try {
                if (wallpaperF != null)
                    wallpaperF.systemReady();
            } catch (Throwable e) {
                reportWtf("making Wallpaper Service ready", e);
            }
            try {
                if (immF != null)
                    immF.systemReady(statusBarF);
            } catch (Throwable e) {
                reportWtf("making Input Method Service ready", e);
            }
            try {
                if (locationF != null)
                    locationF.systemReady();
            } catch (Throwable e) {
                reportWtf("making Location Service ready", e);
            }
            try {
                if (countryDetectorF != null)
                    countryDetectorF.systemReady();
            } catch (Throwable e) {
                reportWtf("making Country Detector Service ready", e);
            }
            try {
                if (throttleF != null)
                    throttleF.systemReady();
            } catch (Throwable e) {
                reportWtf("making Throttle Service ready", e);
            }
            try {
                if (networkTimeUpdaterF != null)
                    networkTimeUpdaterF.systemReady();
            } catch (Throwable e) {
                reportWtf("making Network Time Service ready", e);
            }
            try {
                if (commonTimeMgmtServiceF != null)
                    commonTimeMgmtServiceF.systemReady();
            } catch (Throwable e) {
                reportWtf("making Common time management service ready", e);
            }
            try {
                if (textServiceManagerServiceF != null)
                    textServiceManagerServiceF.systemReady();
            } catch (Throwable e) {
                reportWtf("making Text Services Manager Service ready", e);
            }
            try {
                if (dreamyF != null)
                    dreamyF.systemReady();
            } catch (Throwable e) {
                reportWtf("making DreamManagerService ready", e);
            }
            try {
                if (inputManagerF != null)
                    inputManagerF.systemReady(bluetoothF);
            } catch (Throwable e) {
                reportWtf("making InputManagerService ready", e);
            }
        }
    });
    // For debug builds, log event loop stalls to dropbox for analysis.
    if (StrictMode.conditionallyEnableDebugLogging()) {
        Slog.i(TAG, "Enabled StrictMode for system server main thread.");
    }
    Looper.loop();
    Slog.d(TAG, "System ServerThread is exiting!");
}
#method_after
@Override
public void run() {
    EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_SYSTEM_RUN, SystemClock.uptimeMillis());
    Looper.prepare();
    android.os.Process.setThreadPriority(android.os.Process.THREAD_PRIORITY_FOREGROUND);
    BinderInternal.disableBackgroundScheduling(true);
    android.os.Process.setCanSelfBackground(false);
    // Check whether we failed to shut down last time we tried.
    {
        final String shutdownAction = SystemProperties.get(ShutdownThread.SHUTDOWN_ACTION_PROPERTY, "");
        if (shutdownAction != null && shutdownAction.length() > 0) {
            boolean reboot = (shutdownAction.charAt(0) == '1');
            final String reason;
            if (shutdownAction.length() > 1) {
                reason = shutdownAction.substring(1, shutdownAction.length());
            } else {
                reason = null;
            }
            ShutdownThread.rebootOrShutdown(reboot, reason);
        }
    }
    String factoryTestStr = SystemProperties.get("ro.factorytest");
    int factoryTest = "".equals(factoryTestStr) ? SystemServer.FACTORY_TEST_OFF : Integer.parseInt(factoryTestStr);
    final boolean headless = "1".equals(SystemProperties.get("ro.config.headless", "0"));
    LightsService lights = null;
    PowerManagerService power = null;
    BatteryService battery = null;
    VibratorService vibrator = null;
    AlarmManagerService alarm = null;
    NetworkManagementService networkManagement = null;
    NetworkStatsService networkStats = null;
    NetworkPolicyManagerService networkPolicy = null;
    ConnectivityService connectivity = null;
    WifiP2pService wifiP2p = null;
    WifiService wifi = null;
    NsdService serviceDiscovery = null;
    IPackageManager pm = null;
    Context context = null;
    WindowManagerService wm = null;
    BluetoothService bluetooth = null;
    BluetoothA2dpService bluetoothA2dp = null;
    DockObserver dock = null;
    UsbService usb = null;
    SerialService serial = null;
    UiModeManagerService uiMode = null;
    RecognitionManagerService recognition = null;
    ThrottleService throttle = null;
    NetworkTimeUpdateService networkTimeUpdater = null;
    CommonTimeManagementService commonTimeMgmtService = null;
    InputManagerService inputManager = null;
    // Critical services...
    try {
        Slog.i(TAG, "Entropy Mixer");
        ServiceManager.addService("entropy", new EntropyMixer());
        Slog.i(TAG, "Power Manager");
        power = new PowerManagerService();
        ServiceManager.addService(Context.POWER_SERVICE, power);
        Slog.i(TAG, "Activity Manager");
        context = ActivityManagerService.main(factoryTest);
        Slog.i(TAG, "Telephony Registry");
        ServiceManager.addService("telephony.registry", new TelephonyRegistry(context));
        Slog.i(TAG, "Scheduling Policy");
        ServiceManager.addService(Context.SCHEDULING_POLICY_SERVICE, new SchedulingPolicyService());
        AttributeCache.init(context);
        Slog.i(TAG, "Package Manager");
        // Only run "core" apps if we're encrypting the device.
        String cryptState = SystemProperties.get("vold.decrypt");
        boolean onlyCore = false;
        if (ENCRYPTING_STATE.equals(cryptState)) {
            Slog.w(TAG, "Detected encryption in progress - only parsing core apps");
            onlyCore = true;
        } else if (ENCRYPTED_STATE.equals(cryptState)) {
            Slog.w(TAG, "Device encrypted - only parsing core apps");
            onlyCore = true;
        }
        pm = PackageManagerService.main(context, factoryTest != SystemServer.FACTORY_TEST_OFF, onlyCore);
        boolean firstBoot = false;
        try {
            firstBoot = pm.isFirstBoot();
        } catch (RemoteException e) {
        }
        ActivityManagerService.setSystemProcess();
        mContentResolver = context.getContentResolver();
        // The AccountManager must come before the ContentService
        try {
            Slog.i(TAG, "Account Manager");
            ServiceManager.addService(Context.ACCOUNT_SERVICE, new AccountManagerService(context));
        } catch (Throwable e) {
            Slog.e(TAG, "Failure starting Account Manager", e);
        }
        Slog.i(TAG, "Content Manager");
        ContentService.main(context, factoryTest == SystemServer.FACTORY_TEST_LOW_LEVEL);
        Slog.i(TAG, "System Content Providers");
        ActivityManagerService.installSystemProviders();
        Slog.i(TAG, "Lights Service");
        lights = new LightsService(context);
        Slog.i(TAG, "Battery Service");
        battery = new BatteryService(context, lights);
        ServiceManager.addService("battery", battery);
        Slog.i(TAG, "Vibrator Service");
        vibrator = new VibratorService(context);
        ServiceManager.addService("vibrator", vibrator);
        // only initialize the power service after we have started the
        // lights service, content providers and the battery service.
        power.init(context, lights, ActivityManagerService.self(), battery);
        Slog.i(TAG, "Alarm Manager");
        alarm = new AlarmManagerService(context);
        ServiceManager.addService(Context.ALARM_SERVICE, alarm);
        Slog.i(TAG, "Init Watchdog");
        Watchdog.getInstance().init(context, battery, power, alarm, ActivityManagerService.self());
        Slog.i(TAG, "Window Manager");
        wm = WindowManagerService.main(context, power, factoryTest != SystemServer.FACTORY_TEST_LOW_LEVEL, !firstBoot, onlyCore);
        ServiceManager.addService(Context.WINDOW_SERVICE, wm);
        inputManager = wm.getInputManagerService();
        ServiceManager.addService(Context.INPUT_SERVICE, inputManager);
        ActivityManagerService.self().setWindowManager(wm);
        // support Bluetooth - see bug 988521
        if (SystemProperties.get("ro.kernel.qemu").equals("1")) {
            Slog.i(TAG, "No Bluetooh Service (emulator)");
        } else if (factoryTest == SystemServer.FACTORY_TEST_LOW_LEVEL) {
            Slog.i(TAG, "No Bluetooth Service (factory test)");
        } else {
            Slog.i(TAG, "Bluetooth Service");
            bluetooth = new BluetoothService(context);
            ServiceManager.addService(BluetoothAdapter.BLUETOOTH_SERVICE, bluetooth);
            bluetooth.initAfterRegistration();
            if (!"0".equals(SystemProperties.get("system_init.startaudioservice"))) {
                bluetoothA2dp = new BluetoothA2dpService(context, bluetooth);
                ServiceManager.addService(BluetoothA2dpService.BLUETOOTH_A2DP_SERVICE, bluetoothA2dp);
                bluetooth.initAfterA2dpRegistration();
            }
            int bluetoothOn = Settings.Secure.getInt(mContentResolver, Settings.Secure.BLUETOOTH_ON, 0);
            if (bluetoothOn != 0) {
                bluetooth.enable();
            }
        }
    } catch (RuntimeException e) {
        Slog.e("System", "******************************************");
        Slog.e("System", "************ Failure starting core service", e);
    }
    DevicePolicyManagerService devicePolicy = null;
    StatusBarManagerService statusBar = null;
    InputMethodManagerService imm = null;
    AppWidgetService appWidget = null;
    NotificationManagerService notification = null;
    WallpaperManagerService wallpaper = null;
    LocationManagerService location = null;
    CountryDetectorService countryDetector = null;
    TextServicesManagerService tsms = null;
    LockSettingsService lockSettings = null;
    DreamManagerService dreamy = null;
    // Bring up services needed for UI.
    if (factoryTest != SystemServer.FACTORY_TEST_LOW_LEVEL) {
        try {
            Slog.i(TAG, "Input Method Service");
            imm = new InputMethodManagerService(context, wm);
            ServiceManager.addService(Context.INPUT_METHOD_SERVICE, imm);
        } catch (Throwable e) {
            reportWtf("starting Input Manager Service", e);
        }
        try {
            Slog.i(TAG, "Accessibility Manager");
            ServiceManager.addService(Context.ACCESSIBILITY_SERVICE, new AccessibilityManagerService(context));
        } catch (Throwable e) {
            reportWtf("starting Accessibility Manager", e);
        }
    }
    try {
        wm.displayReady();
    } catch (Throwable e) {
        reportWtf("making display ready", e);
    }
    try {
        pm.performBootDexOpt();
    } catch (Throwable e) {
        reportWtf("performing boot dexopt", e);
    }
    try {
        ActivityManagerNative.getDefault().showBootMessage(context.getResources().getText(com.android.internal.R.string.android_upgrading_starting_apps), false);
    } catch (RemoteException e) {
    }
    if (factoryTest != SystemServer.FACTORY_TEST_LOW_LEVEL) {
        MountService mountService = null;
        if (!"0".equals(SystemProperties.get("system_init.startmountservice"))) {
            try {
                /*
                     * NotificationManagerService is dependant on MountService,
                     * (for media / usb notifications) so we must start MountService first.
                     */
                Slog.i(TAG, "Mount Service");
                mountService = new MountService(context);
                ServiceManager.addService("mount", mountService);
            } catch (Throwable e) {
                reportWtf("starting Mount Service", e);
            }
        }
        try {
            Slog.i(TAG, "LockSettingsService");
            lockSettings = new LockSettingsService(context);
            ServiceManager.addService("lock_settings", lockSettings);
        } catch (Throwable e) {
            reportWtf("starting LockSettingsService service", e);
        }
        try {
            Slog.i(TAG, "Device Policy");
            devicePolicy = new DevicePolicyManagerService(context);
            ServiceManager.addService(Context.DEVICE_POLICY_SERVICE, devicePolicy);
        } catch (Throwable e) {
            reportWtf("starting DevicePolicyService", e);
        }
        try {
            Slog.i(TAG, "Status Bar");
            statusBar = new StatusBarManagerService(context, wm);
            ServiceManager.addService(Context.STATUS_BAR_SERVICE, statusBar);
        } catch (Throwable e) {
            reportWtf("starting StatusBarManagerService", e);
        }
        try {
            Slog.i(TAG, "Clipboard Service");
            ServiceManager.addService(Context.CLIPBOARD_SERVICE, new ClipboardService(context));
        } catch (Throwable e) {
            reportWtf("starting Clipboard Service", e);
        }
        try {
            Slog.i(TAG, "NetworkManagement Service");
            networkManagement = NetworkManagementService.create(context);
            ServiceManager.addService(Context.NETWORKMANAGEMENT_SERVICE, networkManagement);
        } catch (Throwable e) {
            reportWtf("starting NetworkManagement Service", e);
        }
        try {
            Slog.i(TAG, "Text Service Manager Service");
            tsms = new TextServicesManagerService(context);
            ServiceManager.addService(Context.TEXT_SERVICES_MANAGER_SERVICE, tsms);
        } catch (Throwable e) {
            reportWtf("starting Text Service Manager Service", e);
        }
        try {
            Slog.i(TAG, "NetworkStats Service");
            networkStats = new NetworkStatsService(context, networkManagement, alarm);
            ServiceManager.addService(Context.NETWORK_STATS_SERVICE, networkStats);
        } catch (Throwable e) {
            reportWtf("starting NetworkStats Service", e);
        }
        try {
            Slog.i(TAG, "NetworkPolicy Service");
            networkPolicy = new NetworkPolicyManagerService(context, ActivityManagerService.self(), power, networkStats, networkManagement);
            ServiceManager.addService(Context.NETWORK_POLICY_SERVICE, networkPolicy);
        } catch (Throwable e) {
            reportWtf("starting NetworkPolicy Service", e);
        }
        try {
            Slog.i(TAG, "Wi-Fi P2pService");
            wifiP2p = new WifiP2pService(context);
            ServiceManager.addService(Context.WIFI_P2P_SERVICE, wifiP2p);
        } catch (Throwable e) {
            reportWtf("starting Wi-Fi P2pService", e);
        }
        try {
            Slog.i(TAG, "Wi-Fi Service");
            wifi = new WifiService(context);
            ServiceManager.addService(Context.WIFI_SERVICE, wifi);
        } catch (Throwable e) {
            reportWtf("starting Wi-Fi Service", e);
        }
        try {
            Slog.i(TAG, "Connectivity Service");
            connectivity = new ConnectivityService(context, networkManagement, networkStats, networkPolicy);
            ServiceManager.addService(Context.CONNECTIVITY_SERVICE, connectivity);
            networkStats.bindConnectivityManager(connectivity);
            networkPolicy.bindConnectivityManager(connectivity);
            wifi.checkAndStartWifi();
            wifiP2p.connectivityServiceReady();
        } catch (Throwable e) {
            reportWtf("starting Connectivity Service", e);
        }
        try {
            Slog.i(TAG, "Network Service Discovery Service");
            serviceDiscovery = NsdService.create(context);
            ServiceManager.addService(Context.NSD_SERVICE, serviceDiscovery);
        } catch (Throwable e) {
            reportWtf("starting Service Discovery Service", e);
        }
        try {
            Slog.i(TAG, "Throttle Service");
            throttle = new ThrottleService(context);
            ServiceManager.addService(Context.THROTTLE_SERVICE, throttle);
        } catch (Throwable e) {
            reportWtf("starting ThrottleService", e);
        }
        try {
            Slog.i(TAG, "UpdateLock Service");
            ServiceManager.addService(Context.UPDATE_LOCK_SERVICE, new UpdateLockService(context));
        } catch (Throwable e) {
            reportWtf("starting UpdateLockService", e);
        }
        /*
             * MountService has a few dependencies: Notification Manager and
             * AppWidget Provider. Make sure MountService is completely started
             * first before continuing.
             */
        if (mountService != null) {
            mountService.waitForAsecScan();
        }
        try {
            Slog.i(TAG, "Notification Manager");
            notification = new NotificationManagerService(context, statusBar, lights);
            ServiceManager.addService(Context.NOTIFICATION_SERVICE, notification);
            networkPolicy.bindNotificationManager(notification);
        } catch (Throwable e) {
            reportWtf("starting Notification Manager", e);
        }
        try {
            Slog.i(TAG, "Device Storage Monitor");
            ServiceManager.addService(DeviceStorageMonitorService.SERVICE, new DeviceStorageMonitorService(context));
        } catch (Throwable e) {
            reportWtf("starting DeviceStorageMonitor service", e);
        }
        if (SystemProperties.OMAP_ENHANCEMENT) {
            try {
                Slog.i(TAG, "starting SUPL Service (SystemServer)");
                ServiceManager.addService("SUPL_SERVICE", SUPLService.getInstance(context));
            } catch (Throwable e) {
                Slog.e(TAG, "Failure installing SUPL Service", e);
            }
        }
        try {
            Slog.i(TAG, "Location Manager");
            location = new LocationManagerService(context);
            ServiceManager.addService(Context.LOCATION_SERVICE, location);
        } catch (Throwable e) {
            reportWtf("starting Location Manager", e);
        }
        try {
            Slog.i(TAG, "Country Detector");
            countryDetector = new CountryDetectorService(context);
            ServiceManager.addService(Context.COUNTRY_DETECTOR, countryDetector);
        } catch (Throwable e) {
            reportWtf("starting Country Detector", e);
        }
        try {
            Slog.i(TAG, "Search Service");
            ServiceManager.addService(Context.SEARCH_SERVICE, new SearchManagerService(context));
        } catch (Throwable e) {
            reportWtf("starting Search Service", e);
        }
        try {
            Slog.i(TAG, "DropBox Service");
            ServiceManager.addService(Context.DROPBOX_SERVICE, new DropBoxManagerService(context, new File("/data/system/dropbox")));
        } catch (Throwable e) {
            reportWtf("starting DropBoxManagerService", e);
        }
        if (context.getResources().getBoolean(com.android.internal.R.bool.config_enableWallpaperService)) {
            try {
                Slog.i(TAG, "Wallpaper Service");
                if (!headless) {
                    wallpaper = new WallpaperManagerService(context);
                    ServiceManager.addService(Context.WALLPAPER_SERVICE, wallpaper);
                }
            } catch (Throwable e) {
                reportWtf("starting Wallpaper Service", e);
            }
        }
        if (!"0".equals(SystemProperties.get("system_init.startaudioservice"))) {
            try {
                Slog.i(TAG, "Audio Service");
                ServiceManager.addService(Context.AUDIO_SERVICE, new AudioService(context));
            } catch (Throwable e) {
                reportWtf("starting Audio Service", e);
            }
        }
        try {
            Slog.i(TAG, "Dock Observer");
            // Listen for dock station changes
            dock = new DockObserver(context, power);
        } catch (Throwable e) {
            reportWtf("starting DockObserver", e);
        }
        try {
            Slog.i(TAG, "Wired Accessory Observer");
            // Listen for wired headset changes
            new WiredAccessoryObserver(context);
        } catch (Throwable e) {
            reportWtf("starting WiredAccessoryObserver", e);
        }
        try {
            Slog.i(TAG, "USB Service");
            // Manage USB host and device support
            usb = new UsbService(context);
            ServiceManager.addService(Context.USB_SERVICE, usb);
        } catch (Throwable e) {
            reportWtf("starting UsbService", e);
        }
        try {
            Slog.i(TAG, "Serial Service");
            // Serial port support
            serial = new SerialService(context);
            ServiceManager.addService(Context.SERIAL_SERVICE, serial);
        } catch (Throwable e) {
            Slog.e(TAG, "Failure starting SerialService", e);
        }
        try {
            Slog.i(TAG, "UI Mode Manager Service");
            // Listen for UI mode changes
            uiMode = new UiModeManagerService(context);
        } catch (Throwable e) {
            reportWtf("starting UiModeManagerService", e);
        }
        try {
            Slog.i(TAG, "Backup Service");
            ServiceManager.addService(Context.BACKUP_SERVICE, new BackupManagerService(context));
        } catch (Throwable e) {
            Slog.e(TAG, "Failure starting Backup Service", e);
        }
        try {
            Slog.i(TAG, "AppWidget Service");
            appWidget = new AppWidgetService(context);
            ServiceManager.addService(Context.APPWIDGET_SERVICE, appWidget);
        } catch (Throwable e) {
            reportWtf("starting AppWidget Service", e);
        }
        try {
            Slog.i(TAG, "Recognition Service");
            recognition = new RecognitionManagerService(context);
        } catch (Throwable e) {
            reportWtf("starting Recognition Service", e);
        }
        try {
            Slog.i(TAG, "DiskStats Service");
            ServiceManager.addService("diskstats", new DiskStatsService(context));
        } catch (Throwable e) {
            reportWtf("starting DiskStats Service", e);
        }
        try {
            // need to add this service even if SamplingProfilerIntegration.isEnabled()
            // is false, because it is this service that detects system property change and
            // turns on SamplingProfilerIntegration. Plus, when sampling profiler doesn't work,
            // there is little overhead for running this service.
            Slog.i(TAG, "SamplingProfiler Service");
            ServiceManager.addService("samplingprofiler", new SamplingProfilerService(context));
        } catch (Throwable e) {
            reportWtf("starting SamplingProfiler Service", e);
        }
        try {
            Slog.i(TAG, "NetworkTimeUpdateService");
            networkTimeUpdater = new NetworkTimeUpdateService(context);
        } catch (Throwable e) {
            reportWtf("starting NetworkTimeUpdate service", e);
        }
        try {
            Slog.i(TAG, "CommonTimeManagementService");
            commonTimeMgmtService = new CommonTimeManagementService(context);
            ServiceManager.addService("commontime_management", commonTimeMgmtService);
        } catch (Throwable e) {
            reportWtf("starting CommonTimeManagementService service", e);
        }
        try {
            Slog.i(TAG, "CertBlacklister");
            CertBlacklister blacklister = new CertBlacklister(context);
        } catch (Throwable e) {
            reportWtf("starting CertBlacklister", e);
        }
        if (context.getResources().getBoolean(com.android.internal.R.bool.config_enableDreams)) {
            try {
                Slog.i(TAG, "Dreams Service");
                // Dreams (interactive idle-time views, a/k/a screen savers)
                dreamy = new DreamManagerService(context);
                ServiceManager.addService("dreams", dreamy);
            } catch (Throwable e) {
                reportWtf("starting DreamManagerService", e);
            }
        }
    }
    // Before things start rolling, be sure we have decided whether
    // we are in safe mode.
    final boolean safeMode = wm.detectSafeMode();
    if (safeMode) {
        ActivityManagerService.self().enterSafeMode();
        // Post the safe mode state in the Zygote class
        Zygote.systemInSafeMode = true;
        // Disable the JIT for the system_server process
        VMRuntime.getRuntime().disableJitCompilation();
    } else {
        // Enable the JIT for the system_server process
        VMRuntime.getRuntime().startJitCompilation();
    }
    try {
        vibrator.systemReady();
    } catch (Throwable e) {
        reportWtf("making Vibrator Service ready", e);
    }
    if (devicePolicy != null) {
        try {
            devicePolicy.systemReady();
        } catch (Throwable e) {
            reportWtf("making Device Policy Service ready", e);
        }
    }
    if (notification != null) {
        try {
            notification.systemReady();
        } catch (Throwable e) {
            reportWtf("making Notification Service ready", e);
        }
    }
    try {
        wm.systemReady();
    } catch (Throwable e) {
        reportWtf("making Window Manager Service ready", e);
    }
    if (safeMode) {
        ActivityManagerService.self().showSafeModeOverlay();
    }
    // Update the configuration for this context by hand, because we're going
    // to start using it before the config change done in wm.systemReady() will
    // propagate to it.
    Configuration config = wm.computeNewConfiguration();
    DisplayMetrics metrics = new DisplayMetrics();
    WindowManager w = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
    w.getDefaultDisplay().getMetrics(metrics);
    context.getResources().updateConfiguration(config, metrics);
    power.systemReady();
    try {
        pm.systemReady();
    } catch (Throwable e) {
        reportWtf("making Package Manager Service ready", e);
    }
    try {
        lockSettings.systemReady();
    } catch (Throwable e) {
        reportWtf("making Lock Settings Service ready", e);
    }
    // These are needed to propagate to the runnable below.
    final Context contextF = context;
    final BatteryService batteryF = battery;
    final NetworkManagementService networkManagementF = networkManagement;
    final NetworkStatsService networkStatsF = networkStats;
    final NetworkPolicyManagerService networkPolicyF = networkPolicy;
    final ConnectivityService connectivityF = connectivity;
    final DockObserver dockF = dock;
    final UsbService usbF = usb;
    final ThrottleService throttleF = throttle;
    final UiModeManagerService uiModeF = uiMode;
    final AppWidgetService appWidgetF = appWidget;
    final WallpaperManagerService wallpaperF = wallpaper;
    final InputMethodManagerService immF = imm;
    final RecognitionManagerService recognitionF = recognition;
    final LocationManagerService locationF = location;
    final CountryDetectorService countryDetectorF = countryDetector;
    final NetworkTimeUpdateService networkTimeUpdaterF = networkTimeUpdater;
    final CommonTimeManagementService commonTimeMgmtServiceF = commonTimeMgmtService;
    final TextServicesManagerService textServiceManagerServiceF = tsms;
    final StatusBarManagerService statusBarF = statusBar;
    final DreamManagerService dreamyF = dreamy;
    final InputManagerService inputManagerF = inputManager;
    final BluetoothService bluetoothF = bluetooth;
    // We now tell the activity manager it is okay to run third party
    // code.  It will call back into us once it has gotten to the state
    // where third party code can really run (but before it has actually
    // started launching the initial applications), for us to complete our
    // initialization.
    ActivityManagerService.self().systemReady(new Runnable() {

        public void run() {
            Slog.i(TAG, "Making services ready");
            if (!headless)
                startSystemUi(contextF);
            try {
                if (batteryF != null)
                    batteryF.systemReady();
            } catch (Throwable e) {
                reportWtf("making Battery Service ready", e);
            }
            try {
                if (networkManagementF != null)
                    networkManagementF.systemReady();
            } catch (Throwable e) {
                reportWtf("making Network Managment Service ready", e);
            }
            try {
                if (networkStatsF != null)
                    networkStatsF.systemReady();
            } catch (Throwable e) {
                reportWtf("making Network Stats Service ready", e);
            }
            try {
                if (networkPolicyF != null)
                    networkPolicyF.systemReady();
            } catch (Throwable e) {
                reportWtf("making Network Policy Service ready", e);
            }
            try {
                if (connectivityF != null)
                    connectivityF.systemReady();
            } catch (Throwable e) {
                reportWtf("making Connectivity Service ready", e);
            }
            try {
                if (dockF != null)
                    dockF.systemReady();
            } catch (Throwable e) {
                reportWtf("making Dock Service ready", e);
            }
            try {
                if (usbF != null)
                    usbF.systemReady();
            } catch (Throwable e) {
                reportWtf("making USB Service ready", e);
            }
            try {
                if (uiModeF != null)
                    uiModeF.systemReady();
            } catch (Throwable e) {
                reportWtf("making UI Mode Service ready", e);
            }
            try {
                if (recognitionF != null)
                    recognitionF.systemReady();
            } catch (Throwable e) {
                reportWtf("making Recognition Service ready", e);
            }
            Watchdog.getInstance().start();
            try {
                if (appWidgetF != null)
                    appWidgetF.systemReady(safeMode);
            } catch (Throwable e) {
                reportWtf("making App Widget Service ready", e);
            }
            try {
                if (wallpaperF != null)
                    wallpaperF.systemReady();
            } catch (Throwable e) {
                reportWtf("making Wallpaper Service ready", e);
            }
            try {
                if (immF != null)
                    immF.systemReady(statusBarF);
            } catch (Throwable e) {
                reportWtf("making Input Method Service ready", e);
            }
            try {
                if (locationF != null)
                    locationF.systemReady();
            } catch (Throwable e) {
                reportWtf("making Location Service ready", e);
            }
            try {
                if (countryDetectorF != null)
                    countryDetectorF.systemReady();
            } catch (Throwable e) {
                reportWtf("making Country Detector Service ready", e);
            }
            try {
                if (throttleF != null)
                    throttleF.systemReady();
            } catch (Throwable e) {
                reportWtf("making Throttle Service ready", e);
            }
            try {
                if (networkTimeUpdaterF != null)
                    networkTimeUpdaterF.systemReady();
            } catch (Throwable e) {
                reportWtf("making Network Time Service ready", e);
            }
            try {
                if (commonTimeMgmtServiceF != null)
                    commonTimeMgmtServiceF.systemReady();
            } catch (Throwable e) {
                reportWtf("making Common time management service ready", e);
            }
            try {
                if (textServiceManagerServiceF != null)
                    textServiceManagerServiceF.systemReady();
            } catch (Throwable e) {
                reportWtf("making Text Services Manager Service ready", e);
            }
            try {
                if (dreamyF != null)
                    dreamyF.systemReady();
            } catch (Throwable e) {
                reportWtf("making DreamManagerService ready", e);
            }
            try {
                if (inputManagerF != null)
                    inputManagerF.systemReady(bluetoothF);
            } catch (Throwable e) {
                reportWtf("making InputManagerService ready", e);
            }
        }
    });
    // For debug builds, log event loop stalls to dropbox for analysis.
    if (StrictMode.conditionallyEnableDebugLogging()) {
        Slog.i(TAG, "Enabled StrictMode for system server main thread.");
    }
    Looper.loop();
    Slog.d(TAG, "System ServerThread is exiting!");
}
#end_block

#method_before
public int getRawExternalWidth() {
    if (SystemProperties.OMAP_ENHANCEMENT) {
        String prop = SystemProperties.get("persist.hwc.primary.tv");
        if (prop != null && prop.equals("true")) {
            return getRawWidth();
        } else {
            return getMirroringRegion().width();
        }
    } else {
        return 1280;
    }
}
#method_after
public int getRawExternalWidth() {
    if (SystemProperties.OMAP_ENHANCEMENT) {
        int primaryTv = SystemProperties.getInt("persist.hwc.primary.tv", 0);
        if (primaryTv == 1) {
            return getRawWidth();
        } else {
            return getMirroringRegion().width();
        }
    } else {
        return 1280;
    }
}
#end_block

#method_before
public int getRawExternalHeight() {
    if (SystemProperties.OMAP_ENHANCEMENT) {
        String prop = SystemProperties.get("persist.hwc.primary.tv");
        if (prop != null && prop.equals("true")) {
            return getRawHeight();
        } else {
            return getMirroringRegion().height();
        }
    } else {
        return 720;
    }
}
#method_after
public int getRawExternalHeight() {
    if (SystemProperties.OMAP_ENHANCEMENT) {
        int primaryTv = SystemProperties.getInt("persist.hwc.primary.tv", 0);
        if (primaryTv == 1) {
            return getRawHeight();
        } else {
            return getMirroringRegion().height();
        }
    } else {
        return 720;
    }
}
#end_block

#method_before
private synchronized final void updateHDMIaudiochannels(int state, int prevState, String name) {
    if (state == 0) {
        // if HDMI is disconnected set audio channels to 0
        SystemProperties.set("omap.audio.hdmi.channels", "0");
    } else {
        // if HDMI is connected, then set the property to the correct count
        char[] channels = new char[2];
        Slog.e(TAG, "update audio channels of HDMI");
        try {
            FileReader file = new FileReader(HDMI_CHANNEL_PATH);
            if (file.read(channels, 0, 1) > 0) {
                SystemProperties.set("omap.audio.hdmi.channels", new String(channels, 0, 1));
            }
        } catch (FileNotFoundException e) {
            Slog.w(TAG, "Not able to read audio channels of HDMI");
        } catch (Exception e) {
            Slog.e(TAG, "", e);
        }
    }
}
#method_after
private synchronized final void updateHDMIaudiochannels(int state, int prevState, String name) {
    if (state == 0) {
        // if HDMI is disconnected set audio channels to 0
        SystemProperties.set("dolby.audio.hdmi.channels", "0");
    } else {
        // if HDMI is connected, then set the property to the correct count
        char[] channels = new char[2];
        Slog.e(TAG, "update audio channels of HDMI");
        try {
            FileReader file = new FileReader(HDMI_CHANNEL_PATH);
            if (file.read(channels, 0, 1) > 0) {
                SystemProperties.set("dolby.audio.hdmi.channels", new String(channels, 0, 1));
            }
        } catch (FileNotFoundException e) {
            Slog.w(TAG, "Not able to read audio channels of HDMI");
        } catch (Exception e) {
            Slog.e(TAG, "", e);
        }
    }
}
#end_block

#method_before
public static void pauseAndDispatch() {
    if (mHTML5VideoView != null) {
        mHTML5VideoView.pauseAndDispatch(mCurrentProxy);
        // When switching out, clean the video content on the old page
        // by telling the layer not readyToUseSurfTex.
        setBaseLayer(mBaseLayer);
        mHTML5VideoView.release();
    }
}
#method_after
public static void pauseAndDispatch() {
    if (mHTML5VideoView != null) {
        mHTML5VideoView.pauseAndDispatch(mCurrentProxy);
        // When switching out, clean the video content on the old page
        // by telling the layer not readyToUseSurfTex.
        setBaseLayer(mBaseLayer);
        if ("true".equals(System.getProperty("omap.enhancement"))) {
            mHTML5VideoView.release();
        }
    }
}
#end_block

#method_before
// This is on the UI thread.
// When native tell Java to play, we need to check whether or not it is
public static void play(String url, int time, HTML5VideoViewProxy proxy, WebChromeClient client, int videoLayerId) {
    int currentVideoLayerId = -1;
    boolean backFromFullScreenMode = false;
    boolean surfaceDeleted = true;
    int currentState = mHTML5VideoView.STATE_RELEASED;
    if (mHTML5VideoView != null) {
        currentVideoLayerId = mHTML5VideoView.getVideoLayerId();
        backFromFullScreenMode = mHTML5VideoView.fullScreenExited();
        surfaceDeleted = mHTML5VideoView.surfaceTextureDeleted();
        currentState = mHTML5VideoView.getCurrentState();
    }
    if (backFromFullScreenMode || currentVideoLayerId != videoLayerId || surfaceDeleted == true || currentState == mHTML5VideoView.STATE_RELEASED) {
        // inside the HTML5VideoView.
        if (mHTML5VideoView != null && currentState != mHTML5VideoView.STATE_RELEASED) {
            if (!backFromFullScreenMode) {
                mHTML5VideoView.pauseAndDispatch(mCurrentProxy);
            }
            // release the media player to avoid finalize error
            mHTML5VideoView.release();
        }
        mCurrentProxy = proxy;
        mHTML5VideoView = new HTML5VideoInline(videoLayerId, time, false);
        mHTML5VideoView.setVideoURI(url, mCurrentProxy);
        mHTML5VideoView.prepareDataAndDisplayMode(proxy);
    } else if (mCurrentProxy == proxy) {
        // Here, we handle the case when we keep playing with one video
        if (!mHTML5VideoView.isPlaying()) {
            mHTML5VideoView.seekTo(time);
            mHTML5VideoView.start();
        }
    } else if (mCurrentProxy != null) {
        // Some other video is already playing. Notify the caller that
        // its playback ended.
        proxy.dispatchOnEnded();
    }
}
#method_after
// This is on the UI thread.
// When native tell Java to play, we need to check whether or not it is
public static void play(String url, int time, HTML5VideoViewProxy proxy, WebChromeClient client, int videoLayerId) {
    int currentVideoLayerId = -1;
    boolean backFromFullScreenMode = false;
    boolean surfaceDeleted = true;
    int currentState = mHTML5VideoView.STATE_RELEASED;
    if (mHTML5VideoView != null) {
        currentVideoLayerId = mHTML5VideoView.getVideoLayerId();
        backFromFullScreenMode = mHTML5VideoView.fullScreenExited();
        if ("true".equals(System.getProperty("omap.enhancement"))) {
            surfaceDeleted = mHTML5VideoView.surfaceTextureDeleted();
            currentState = mHTML5VideoView.getCurrentState();
        }
    }
    if ("true".equals(System.getProperty("omap.enhancement"))) {
        if (backFromFullScreenMode || currentVideoLayerId != videoLayerId || surfaceDeleted == true || currentState == mHTML5VideoView.STATE_RELEASED) {
            // inside the HTML5VideoView.
            if (mHTML5VideoView != null && currentState != mHTML5VideoView.STATE_RELEASED) {
                if (!backFromFullScreenMode) {
                    mHTML5VideoView.pauseAndDispatch(mCurrentProxy);
                }
                // release the media player to avoid finalize error
                mHTML5VideoView.release();
            }
            mCurrentProxy = proxy;
            mHTML5VideoView = new HTML5VideoInline(videoLayerId, time, false);
            mHTML5VideoView.setVideoURI(url, mCurrentProxy);
            mHTML5VideoView.prepareDataAndDisplayMode(proxy);
        } else if (mCurrentProxy == proxy) {
            // Here, we handle the case when we keep playing with one video
            if (!mHTML5VideoView.isPlaying()) {
                mHTML5VideoView.seekTo(time);
                mHTML5VideoView.start();
            }
        } else if (mCurrentProxy != null) {
            // Some other video is already playing. Notify the caller that
            // its playback ended.
            proxy.dispatchOnEnded();
        }
    } else {
        if (backFromFullScreenMode || currentVideoLayerId != videoLayerId || mHTML5VideoView.surfaceTextureDeleted()) {
            // inside the HTML5VideoView.
            if (mHTML5VideoView != null) {
                if (!backFromFullScreenMode) {
                    mHTML5VideoView.pauseAndDispatch(mCurrentProxy);
                }
                // release the media player to avoid finalize error
                mHTML5VideoView.release();
            }
            mCurrentProxy = proxy;
            mHTML5VideoView = new HTML5VideoInline(videoLayerId, time, false);
            mHTML5VideoView.setVideoURI(url, mCurrentProxy);
            mHTML5VideoView.prepareDataAndDisplayMode(proxy);
        } else if (mCurrentProxy == proxy) {
            // Here, we handle the case when we keep playing with one video
            if (!mHTML5VideoView.isPlaying()) {
                mHTML5VideoView.seekTo(time);
                mHTML5VideoView.start();
            }
        } else if (mCurrentProxy != null) {
            // Some other video is already playing. Notify the caller that
            // its playback ended.
            proxy.dispatchOnEnded();
        }
    }
}
#end_block

#method_before
// This is on the UI thread.
// When native tell Java to play, we need to check whether or not it is
public static void play(String url, int time, HTML5VideoViewProxy proxy, WebChromeClient client, int videoLayerId) {
    int currentVideoLayerId = -1;
    boolean backFromFullScreenMode = false;
    boolean surfaceDeleted = true;
    int currentState = mHTML5VideoView.STATE_RELEASED;
    if (mHTML5VideoView != null) {
        currentVideoLayerId = mHTML5VideoView.getVideoLayerId();
        backFromFullScreenMode = mHTML5VideoView.fullScreenExited();
        surfaceDeleted = mHTML5VideoView.surfaceTextureDeleted();
        currentState = mHTML5VideoView.getCurrentState();
    }
    if (backFromFullScreenMode || currentVideoLayerId != videoLayerId || surfaceDeleted == true || (currentState == mHTML5VideoView.STATE_RELEASED && "true".equals(System.getProperty("omap.enhancement")))) {
        // inside the HTML5VideoView.
        if ((mHTML5VideoView != null && !"true".equals(System.getProperty("omap.enhancement"))) || (mHTML5VideoView != null && currentState != mHTML5VideoView.STATE_RELEASED && "true".equals(System.getProperty("omap.enhancement")))) {
            if (!backFromFullScreenMode) {
                mHTML5VideoView.pauseAndDispatch(mCurrentProxy);
            }
            // release the media player to avoid finalize error
            mHTML5VideoView.release();
        }
        mCurrentProxy = proxy;
        mHTML5VideoView = new HTML5VideoInline(videoLayerId, time, false);
        mHTML5VideoView.setVideoURI(url, mCurrentProxy);
        mHTML5VideoView.prepareDataAndDisplayMode(proxy);
    } else if (mCurrentProxy == proxy) {
        // Here, we handle the case when we keep playing with one video
        if (!mHTML5VideoView.isPlaying()) {
            mHTML5VideoView.seekTo(time);
            mHTML5VideoView.start();
        }
    } else if (mCurrentProxy != null) {
        // Some other video is already playing. Notify the caller that
        // its playback ended.
        proxy.dispatchOnEnded();
    }
}
#method_after
// This is on the UI thread.
// When native tell Java to play, we need to check whether or not it is
public static void play(String url, int time, HTML5VideoViewProxy proxy, WebChromeClient client, int videoLayerId) {
    int currentVideoLayerId = -1;
    boolean backFromFullScreenMode = false;
    boolean surfaceDeleted = true;
    int currentState = mHTML5VideoView.STATE_RELEASED;
    if (mHTML5VideoView != null) {
        currentVideoLayerId = mHTML5VideoView.getVideoLayerId();
        backFromFullScreenMode = mHTML5VideoView.fullScreenExited();
        if ("true".equals(System.getProperty("omap.enhancement"))) {
            surfaceDeleted = mHTML5VideoView.surfaceTextureDeleted();
            currentState = mHTML5VideoView.getCurrentState();
        }
    }
    if ("true".equals(System.getProperty("omap.enhancement"))) {
        if (backFromFullScreenMode || currentVideoLayerId != videoLayerId || surfaceDeleted == true || currentState == mHTML5VideoView.STATE_RELEASED) {
            // inside the HTML5VideoView.
            if (mHTML5VideoView != null && currentState != mHTML5VideoView.STATE_RELEASED) {
                if (!backFromFullScreenMode) {
                    mHTML5VideoView.pauseAndDispatch(mCurrentProxy);
                }
                // release the media player to avoid finalize error
                mHTML5VideoView.release();
            }
            mCurrentProxy = proxy;
            mHTML5VideoView = new HTML5VideoInline(videoLayerId, time, false);
            mHTML5VideoView.setVideoURI(url, mCurrentProxy);
            mHTML5VideoView.prepareDataAndDisplayMode(proxy);
        } else if (mCurrentProxy == proxy) {
            // Here, we handle the case when we keep playing with one video
            if (!mHTML5VideoView.isPlaying()) {
                mHTML5VideoView.seekTo(time);
                mHTML5VideoView.start();
            }
        } else if (mCurrentProxy != null) {
            // Some other video is already playing. Notify the caller that
            // its playback ended.
            proxy.dispatchOnEnded();
        }
    } else {
        if (backFromFullScreenMode || currentVideoLayerId != videoLayerId || mHTML5VideoView.surfaceTextureDeleted()) {
            // inside the HTML5VideoView.
            if (mHTML5VideoView != null) {
                if (!backFromFullScreenMode) {
                    mHTML5VideoView.pauseAndDispatch(mCurrentProxy);
                }
                // release the media player to avoid finalize error
                mHTML5VideoView.release();
            }
            mCurrentProxy = proxy;
            mHTML5VideoView = new HTML5VideoInline(videoLayerId, time, false);
            mHTML5VideoView.setVideoURI(url, mCurrentProxy);
            mHTML5VideoView.prepareDataAndDisplayMode(proxy);
        } else if (mCurrentProxy == proxy) {
            // Here, we handle the case when we keep playing with one video
            if (!mHTML5VideoView.isPlaying()) {
                mHTML5VideoView.seekTo(time);
                mHTML5VideoView.start();
            }
        } else if (mCurrentProxy != null) {
            // Some other video is already playing. Notify the caller that
            // its playback ended.
            proxy.dispatchOnEnded();
        }
    }
}
#end_block

#method_before
private void addDevice(String address, String[] properties) {
    BluetoothDeviceProperties deviceProperties = mBluetoothService.getDeviceProperties();
    deviceProperties.addProperties(address, properties);
    String rssi = deviceProperties.getProperty(address, "RSSI");
    String classValue = deviceProperties.getProperty(address, "Class");
    String name = deviceProperties.getProperty(address, "Name");
    short rssiValue;
    // If we accept the pairing, we will automatically show it at the top of the list.
    if (rssi != null) {
        rssiValue = (short) Integer.valueOf(rssi).intValue();
    } else {
        rssiValue = Short.MIN_VALUE;
    }
    if (classValue != null) {
        Intent intent = new Intent(BluetoothDevice.ACTION_FOUND);
        intent.putExtra(BluetoothDevice.EXTRA_DEVICE, mAdapter.getRemoteDevice(address));
        intent.putExtra(BluetoothDevice.EXTRA_CLASS, new BluetoothClass(Integer.valueOf(classValue)));
        intent.putExtra(BluetoothDevice.EXTRA_RSSI, rssiValue);
        intent.putExtra(BluetoothDevice.EXTRA_NAME, name);
        mContext.sendBroadcast(intent, BLUETOOTH_PERM);
    } else {
        log("ClassValue: " + classValue + " for remote device: " + address + " is null");
    }
}
#method_after
private void addDevice(String address, String[] properties) {
    BluetoothDeviceProperties deviceProperties = mBluetoothService.getDeviceProperties();
    // BLUETI_ENHANCEMENT
    Boolean leDevice = false;
    deviceProperties.addProperties(address, properties);
    String rssi = deviceProperties.getProperty(address, "RSSI");
    String classValue = deviceProperties.getProperty(address, "Class");
    String name = deviceProperties.getProperty(address, "Name");
    // BLUETI_ENHANCEMENT
    String broadcaster = deviceProperties.getProperty(address, "Broadcaster");
    short rssiValue;
    if (SystemProperties.BLUETI_ENHANCEMENT) {
        if (broadcaster != null) {
            classValue = "0";
            leDevice = true;
        }
        if (DBG) {
            Log.d(TAG, "Address:" + address + " RSSI:" + rssi + " name:" + name);
            Log.d(TAG, " LE:" + leDevice + " Class:" + classValue);
        }
    }
    // If we accept the pairing, we will automatically show it at the top of the list.
    if (rssi != null) {
        rssiValue = (short) Integer.valueOf(rssi).intValue();
    } else {
        rssiValue = Short.MIN_VALUE;
    }
    if (classValue != null) {
        Intent intent = new Intent(BluetoothDevice.ACTION_FOUND);
        if (SystemProperties.BLUETI_ENHANCEMENT) {
            BluetoothDevice dev = mAdapter.getRemoteDevice(address);
            if (leDevice == false) {
                dev.SetDeviceBrEdr();
            } else {
                dev.SetDeviceLe();
            }
            intent.putExtra(BluetoothDevice.EXTRA_DEVICE, dev);
        } else {
            intent.putExtra(BluetoothDevice.EXTRA_DEVICE, mAdapter.getRemoteDevice(address));
        }
        intent.putExtra(BluetoothDevice.EXTRA_CLASS, new BluetoothClass(Integer.valueOf(classValue)));
        intent.putExtra(BluetoothDevice.EXTRA_RSSI, rssiValue);
        intent.putExtra(BluetoothDevice.EXTRA_NAME, name);
        if (SystemProperties.BLUETI_ENHANCEMENT) {
            intent.putExtra(BluetoothDevice.EXTRA_DEVICE_TYPE, (leDevice ? BluetoothDevice.DEVICE_TYPE_LE : BluetoothDevice.DEVICE_TYPE_BR_EDR));
        }
        mContext.sendBroadcast(intent, BLUETOOTH_PERM);
    } else {
        log("ClassValue: " + classValue + " for remote device: " + address + " is null");
    }
}
#end_block

#method_before
/**
 * Called by native code on a PropertyChanged signal from
 * org.bluez.Adapter. This method is also called from
 * {@link BluetoothAdapterStateMachine} to set the "Pairable"
 * property when Bluetooth is enabled.
 *
 * @param propValues a string array containing the key and one or more
 *  values.
 */
void onPropertyChanged(String[] propValues) {
    BluetoothAdapterProperties adapterProperties = mBluetoothService.getAdapterProperties();
    if (adapterProperties.isEmpty()) {
        // We have got a property change before
        // we filled up our cache.
        adapterProperties.getAllProperties();
    }
    log("Property Changed: " + propValues[0] + " : " + propValues[1]);
    String name = propValues[0];
    if (name.equals("Name")) {
        adapterProperties.setProperty(name, propValues[1]);
        Intent intent = new Intent(BluetoothAdapter.ACTION_LOCAL_NAME_CHANGED);
        intent.putExtra(BluetoothAdapter.EXTRA_LOCAL_NAME, propValues[1]);
        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
        mContext.sendBroadcast(intent, BLUETOOTH_PERM);
    } else if (name.equals("Pairable") || name.equals("Discoverable")) {
        adapterProperties.setProperty(name, propValues[1]);
        if (name.equals("Discoverable")) {
            mBluetoothState.sendMessage(BluetoothAdapterStateMachine.SCAN_MODE_CHANGED);
        }
        String pairable = name.equals("Pairable") ? propValues[1] : adapterProperties.getProperty("Pairable");
        String discoverable = name.equals("Discoverable") ? propValues[1] : adapterProperties.getProperty("Discoverable");
        // This shouldn't happen, unless Adapter Properties are null.
        if (pairable == null || discoverable == null)
            return;
        int mode = BluetoothService.bluezStringToScanMode(pairable.equals("true"), discoverable.equals("true"));
        if (mode >= 0) {
            Intent intent = new Intent(BluetoothAdapter.ACTION_SCAN_MODE_CHANGED);
            intent.putExtra(BluetoothAdapter.EXTRA_SCAN_MODE, mode);
            intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
            mContext.sendBroadcast(intent, BLUETOOTH_PERM);
        }
    } else if (name.equals("Discovering")) {
        Intent intent;
        adapterProperties.setProperty(name, propValues[1]);
        if (propValues[1].equals("true")) {
            intent = new Intent(BluetoothAdapter.ACTION_DISCOVERY_STARTED);
        } else {
            // Stop the discovery.
            mBluetoothService.cancelDiscovery();
            intent = new Intent(BluetoothAdapter.ACTION_DISCOVERY_FINISHED);
        }
        mContext.sendBroadcast(intent, BLUETOOTH_PERM);
    } else if (name.equals("Devices") || name.equals("UUIDs")) {
        String value = null;
        int len = Integer.valueOf(propValues[1]);
        if (len > 0) {
            StringBuilder str = new StringBuilder();
            for (int i = 2; i < propValues.length; i++) {
                str.append(propValues[i]);
                str.append(",");
            }
            value = str.toString();
        }
        adapterProperties.setProperty(name, value);
        if (name.equals("UUIDs")) {
            mBluetoothService.updateBluetoothState(value);
        }
    } else if (name.equals("Powered")) {
        mBluetoothState.sendMessage(BluetoothAdapterStateMachine.POWER_STATE_CHANGED, propValues[1].equals("true") ? new Boolean(true) : new Boolean(false));
    } else if (name.equals("DiscoverableTimeout")) {
        adapterProperties.setProperty(name, propValues[1]);
    }
}
#method_after
/**
 * Called by native code on a PropertyChanged signal from
 * org.bluez.Adapter. This method is also called from
 * {@link BluetoothAdapterStateMachine} to set the "Pairable"
 * property when Bluetooth is enabled.
 *
 * @param propValues a string array containing the key and one or more
 *  values.
 */
void onPropertyChanged(String[] propValues) {
    BluetoothAdapterProperties adapterProperties = mBluetoothService.getAdapterProperties();
    if (adapterProperties.isEmpty()) {
        // We have got a property change before
        // we filled up our cache.
        adapterProperties.getAllProperties();
    }
    log("Property Changed: " + propValues[0] + " : " + propValues[1]);
    String name = propValues[0];
    if (name.equals("Name")) {
        adapterProperties.setProperty(name, propValues[1]);
        Intent intent = new Intent(BluetoothAdapter.ACTION_LOCAL_NAME_CHANGED);
        intent.putExtra(BluetoothAdapter.EXTRA_LOCAL_NAME, propValues[1]);
        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
        mContext.sendBroadcast(intent, BLUETOOTH_PERM);
    } else if (name.equals("Pairable") || name.equals("Discoverable")) {
        adapterProperties.setProperty(name, propValues[1]);
        if (name.equals("Discoverable")) {
            mBluetoothState.sendMessage(BluetoothAdapterStateMachine.SCAN_MODE_CHANGED);
        }
        String pairable = name.equals("Pairable") ? propValues[1] : adapterProperties.getProperty("Pairable");
        String discoverable = name.equals("Discoverable") ? propValues[1] : adapterProperties.getProperty("Discoverable");
        // This shouldn't happen, unless Adapter Properties are null.
        if (pairable == null || discoverable == null)
            return;
        int mode = BluetoothService.bluezStringToScanMode(pairable.equals("true"), discoverable.equals("true"));
        if (mode >= 0) {
            Intent intent = new Intent(BluetoothAdapter.ACTION_SCAN_MODE_CHANGED);
            intent.putExtra(BluetoothAdapter.EXTRA_SCAN_MODE, mode);
            intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
            mContext.sendBroadcast(intent, BLUETOOTH_PERM);
        }
    } else if (name.equals("Discovering")) {
        Intent intent;
        adapterProperties.setProperty(name, propValues[1]);
        if (propValues[1].equals("true")) {
            intent = new Intent(BluetoothAdapter.ACTION_DISCOVERY_STARTED);
        } else {
            // Stop the discovery.
            if (SystemProperties.BLUETI_ENHANCEMENT) {
                // Fix to prevent sending the CancelDiscovery() in case we are not scanning anymore
                if (mBluetoothService.isDiscovering() == true) {
                    mBluetoothService.cancelDiscovery();
                }
            } else {
                mBluetoothService.cancelDiscovery();
            }
            intent = new Intent(BluetoothAdapter.ACTION_DISCOVERY_FINISHED);
        }
        mContext.sendBroadcast(intent, BLUETOOTH_PERM);
    } else if (name.equals("Devices") || name.equals("UUIDs")) {
        String value = null;
        int len = Integer.valueOf(propValues[1]);
        if (len > 0) {
            StringBuilder str = new StringBuilder();
            for (int i = 2; i < propValues.length; i++) {
                str.append(propValues[i]);
                str.append(",");
            }
            value = str.toString();
        }
        adapterProperties.setProperty(name, value);
        if (name.equals("UUIDs")) {
            mBluetoothService.updateBluetoothState(value);
        }
    } else if (name.equals("Powered")) {
        mBluetoothState.sendMessage(BluetoothAdapterStateMachine.POWER_STATE_CHANGED, propValues[1].equals("true") ? new Boolean(true) : new Boolean(false));
    } else if (name.equals("DiscoverableTimeout")) {
        adapterProperties.setProperty(name, propValues[1]);
    }
}
#end_block

#method_before
private void onRequestPinCode(String objectPath, int nativeData) {
    String address = checkPairingRequestAndGetAddress(objectPath, nativeData);
    if (address == null)
        return;
    String pendingOutgoingAddress = mBluetoothService.getPendingOutgoingBonding();
    BluetoothClass btClass = new BluetoothClass(mBluetoothService.getRemoteClass(address));
    int btDeviceClass = btClass.getDeviceClass();
    if (address.equals(pendingOutgoingAddress)) {
        // Check if its a dock
        if (mBluetoothService.isBluetoothDock(address)) {
            String pin = mBluetoothService.getDockPin();
            mBluetoothService.setPin(address, BluetoothDevice.convertPinToBytes(pin));
            return;
        }
        // try 0000 once if the device looks dumb
        switch(btDeviceClass) {
            case BluetoothClass.Device.AUDIO_VIDEO_WEARABLE_HEADSET:
            case BluetoothClass.Device.AUDIO_VIDEO_HANDSFREE:
            case BluetoothClass.Device.AUDIO_VIDEO_HEADPHONES:
            case BluetoothClass.Device.AUDIO_VIDEO_PORTABLE_AUDIO:
            case BluetoothClass.Device.AUDIO_VIDEO_HIFI_AUDIO:
                if (mBluetoothService.attemptAutoPair(address))
                    return;
        }
    }
    if (btDeviceClass == BluetoothClass.Device.PERIPHERAL_KEYBOARD || btDeviceClass == BluetoothClass.Device.PERIPHERAL_KEYBOARD_POINTING) {
        // and pair.
        if (mBluetoothService.isFixedPinZerosAutoPairKeyboard(address)) {
            mBluetoothService.setPin(address, BluetoothDevice.convertPinToBytes("0000"));
            return;
        }
        // Generate a variable PIN. This is not truly random but good enough.
        int pin = (int) Math.floor(Math.random() * 10000);
        sendDisplayPinIntent(address, pin);
        return;
    }
    // Acquire wakelock during PIN code request to bring up LCD display
    if (!SystemProperties.BLUETI_ENHANCEMENT) {
        mWakeLock.acquire();
    }
    Intent intent = new Intent(BluetoothDevice.ACTION_PAIRING_REQUEST);
    intent.putExtra(BluetoothDevice.EXTRA_DEVICE, mAdapter.getRemoteDevice(address));
    intent.putExtra(BluetoothDevice.EXTRA_PAIRING_VARIANT, BluetoothDevice.PAIRING_VARIANT_PIN);
    mContext.sendBroadcast(intent, BLUETOOTH_ADMIN_PERM);
    // Release wakelock to allow the LCD to go off after the PIN popup notification.
    if (SystemProperties.BLUETI_ENHANCEMENT) {
        // TI-BLUEZ Fix - bring up LCD display for PIN_CODE_REQUEST_WAKELOCK_TIME
        mWakeLock.acquire(PIN_CODE_REQUEST_WAKELOCK_TIME);
    } else {
        mWakeLock.release();
    }
    return;
}
#method_after
private void onRequestPinCode(String objectPath, int nativeData) {
    String address = checkPairingRequestAndGetAddress(objectPath, nativeData);
    if (address == null)
        return;
    String pendingOutgoingAddress = mBluetoothService.getPendingOutgoingBonding();
    BluetoothClass btClass = new BluetoothClass(mBluetoothService.getRemoteClass(address));
    int btDeviceClass = btClass.getDeviceClass();
    if (address.equals(pendingOutgoingAddress)) {
        // Check if its a dock
        if (mBluetoothService.isBluetoothDock(address)) {
            String pin = mBluetoothService.getDockPin();
            mBluetoothService.setPin(address, BluetoothDevice.convertPinToBytes(pin));
            return;
        }
        // try 0000 once if the device looks dumb
        switch(btDeviceClass) {
            case BluetoothClass.Device.AUDIO_VIDEO_WEARABLE_HEADSET:
            case BluetoothClass.Device.AUDIO_VIDEO_HANDSFREE:
            case BluetoothClass.Device.AUDIO_VIDEO_HEADPHONES:
            case BluetoothClass.Device.AUDIO_VIDEO_PORTABLE_AUDIO:
            case BluetoothClass.Device.AUDIO_VIDEO_HIFI_AUDIO:
                if (mBluetoothService.attemptAutoPair(address))
                    return;
        }
    }
    if (btDeviceClass == BluetoothClass.Device.PERIPHERAL_KEYBOARD || btDeviceClass == BluetoothClass.Device.PERIPHERAL_KEYBOARD_POINTING) {
        // and pair.
        if (mBluetoothService.isFixedPinZerosAutoPairKeyboard(address)) {
            mBluetoothService.setPin(address, BluetoothDevice.convertPinToBytes("0000"));
            return;
        }
        // Generate a variable PIN. This is not truly random but good enough.
        int pin = (int) Math.floor(Math.random() * 10000);
        sendDisplayPinIntent(address, pin);
        return;
    }
    // Acquire wakelock during PIN code request to bring up LCD display
    if (!SystemProperties.BLUETI_ENHANCEMENT) {
        mWakeLock.acquire();
    }
    Intent intent = new Intent(BluetoothDevice.ACTION_PAIRING_REQUEST);
    intent.putExtra(BluetoothDevice.EXTRA_DEVICE, mAdapter.getRemoteDevice(address));
    intent.putExtra(BluetoothDevice.EXTRA_PAIRING_VARIANT, BluetoothDevice.PAIRING_VARIANT_PIN);
    mContext.sendBroadcast(intent, BLUETOOTH_ADMIN_PERM);
    // Release wakelock to allow the LCD to go off after the PIN popup notification.
    if (SystemProperties.BLUETI_ENHANCEMENT) {
        mWakeLock.acquire(PIN_CODE_REQUEST_WAKELOCK_TIME);
    } else {
        mWakeLock.release();
    }
    return;
}
#end_block

#method_before
private void onAgentAuthorize(String objectPath, String deviceUuid, int nativeData) {
    if (!mBluetoothService.isEnabled())
        return;
    String address = mBluetoothService.getAddressFromObjectPath(objectPath);
    if (address == null) {
        Log.e(TAG, "Unable to get device address in onAuthAgentAuthorize");
        return;
    }
    boolean authorized = false;
    ParcelUuid uuid = ParcelUuid.fromString(deviceUuid);
    BluetoothDevice device = mAdapter.getRemoteDevice(address);
    mAuthorizationAgentRequestData.put(address, new Integer(nativeData));
    // remote service
    if (mA2dp != null && (BluetoothUuid.isAudioSource(uuid) || BluetoothUuid.isAvrcpTarget(uuid) || BluetoothUuid.isAdvAudioDist(uuid)) && !isOtherSinkInNonDisconnectedState(address)) {
        authorized = mA2dp.getPriority(device) > BluetoothProfile.PRIORITY_OFF;
        if (authorized && !BluetoothUuid.isAvrcpTarget(uuid)) {
            Log.i(TAG, "First check pass for incoming A2DP / AVRCP connection from " + address);
            // Some headsets try to connect AVCTP before AVDTP - against the recommendation
            // If AVCTP connection fails, we get stuck in IncomingA2DP state in the state
            // machine.  We don't handle AVCTP signals currently. We only send
            // intents for AVDTP state changes. We need to handle both of them in
            // some cases. For now, just don't move to incoming state in this case.
            mBluetoothService.notifyIncomingA2dpConnection(address, false);
        } else {
            Log.i(TAG, "" + authorized + "Incoming A2DP / AVRCP connection from " + address);
            mA2dp.allowIncomingConnect(device, authorized);
            mBluetoothService.notifyIncomingA2dpConnection(address, true);
        }
    } else if (BluetoothUuid.isInputDevice(uuid)) {
        // We can have more than 1 input device connected.
        authorized = mBluetoothService.getInputDevicePriority(device) > BluetoothInputDevice.PRIORITY_OFF;
        if (authorized) {
            Log.i(TAG, "First check pass for incoming HID connection from " + address);
            // notify profile state change
            mBluetoothService.notifyIncomingHidConnection(address);
        } else {
            Log.i(TAG, "Rejecting incoming HID connection from " + address);
            mBluetoothService.allowIncomingProfileConnect(device, authorized);
        }
    } else if (BluetoothUuid.isBnep(uuid)) {
        // PAN doesn't go to the state machine, accept or reject from here
        authorized = mBluetoothService.allowIncomingTethering();
        mBluetoothService.allowIncomingProfileConnect(device, authorized);
    } else {
        Log.i(TAG, "Rejecting incoming " + deviceUuid + " connection from " + address);
        mBluetoothService.allowIncomingProfileConnect(device, authorized);
    }
    log("onAgentAuthorize(" + objectPath + ", " + deviceUuid + ") = " + authorized);
}
#method_after
private void onAgentAuthorize(String objectPath, String deviceUuid, int nativeData) {
    if (!mBluetoothService.isEnabled())
        return;
    String address = mBluetoothService.getAddressFromObjectPath(objectPath);
    if (address == null) {
        Log.e(TAG, "Unable to get device address in onAuthAgentAuthorize");
        return;
    }
    boolean authorized = false;
    ParcelUuid uuid = ParcelUuid.fromString(deviceUuid);
    BluetoothDevice device = mAdapter.getRemoteDevice(address);
    mAuthorizationAgentRequestData.put(address, new Integer(nativeData));
    // remote service
    if (mA2dp != null && (BluetoothUuid.isAudioSource(uuid) || BluetoothUuid.isAvrcpTarget(uuid) || BluetoothUuid.isAdvAudioDist(uuid)) && !isOtherSinkInNonDisconnectedState(address)) {
        authorized = mA2dp.getPriority(device) > BluetoothProfile.PRIORITY_OFF;
        if (authorized && !BluetoothUuid.isAvrcpTarget(uuid)) {
            if (SystemProperties.BLUETI_ENHANCEMENT) {
                Log.i(TAG, "First check pass for incoming A2DP connection from " + address);
            } else {
                Log.i(TAG, "First check pass for incoming A2DP / AVRCP connection from " + address);
            }
            // Some headsets try to connect AVCTP before AVDTP - against the recommendation
            // If AVCTP connection fails, we get stuck in IncomingA2DP state in the state
            // machine.  We don't handle AVCTP signals currently. We only send
            // intents for AVDTP state changes. We need to handle both of them in
            // some cases. For now, just don't move to incoming state in this case.
            mBluetoothService.notifyIncomingA2dpConnection(address, false);
        } else {
            if (SystemProperties.BLUETI_ENHANCEMENT) {
                /* In this case we know we are in AVRCP connect */
                Log.i(TAG, "" + authorized + "Incoming AVRCP connection from " + address);
            } else {
                Log.i(TAG, "" + authorized + "Incoming A2DP / AVRCP connection from " + address);
            }
            mA2dp.allowIncomingConnect(device, authorized);
            mBluetoothService.notifyIncomingA2dpConnection(address, true);
            if (SystemProperties.BLUETI_ENHANCEMENT) {
                /* as AVRCP does not have a profile state we handle this here */
                mBluetoothService.notifyIncomingAVRCPConnection(address);
            }
        }
    } else if (BluetoothUuid.isInputDevice(uuid)) {
        // We can have more than 1 input device connected.
        authorized = mBluetoothService.getInputDevicePriority(device) > BluetoothInputDevice.PRIORITY_OFF;
        if (authorized) {
            Log.i(TAG, "First check pass for incoming HID connection from " + address);
            // notify profile state change
            mBluetoothService.notifyIncomingHidConnection(address);
        } else {
            Log.i(TAG, "Rejecting incoming HID connection from " + address);
            mBluetoothService.allowIncomingProfileConnect(device, authorized);
        }
    } else if (BluetoothUuid.isBnep(uuid)) {
        // PAN doesn't go to the state machine, accept or reject from here
        authorized = mBluetoothService.allowIncomingTethering();
        mBluetoothService.allowIncomingProfileConnect(device, authorized);
    } else {
        Log.i(TAG, "Rejecting incoming " + deviceUuid + " connection from " + address);
        mBluetoothService.allowIncomingProfileConnect(device, authorized);
    }
    log("onAgentAuthorize(" + objectPath + ", " + deviceUuid + ") = " + authorized);
}
#end_block

#method_before
private String[] parseMetadata(Bundle metadata) {
    if (SystemProperties.BLUETI_ENHANCEMENT) {
        if (metadata == null)
            return new String[1];
        Set<String> keys = metadata.keySet();
        String[] properties = new String[keys.size() * 2];
        int j = 0;
        for (String key : keys) {
            if (!mMetadataMap.containsKey(key))
                continue;
            properties[j++] = mMetadataMap.get(key);
            // This could be done by a separate class which handle
            // Integer and String metadata. However this would imply
            // the native code to constantly call the VM methods to
            // extract the field, which is actually more expensive than
            // converting it to String
            properties[j++] = metadata.get(key).toString();
        }
        return properties;
    } else {
        Log.e(TAG, "SystemProperties.BLUETI_ENHANCEMENT == false, parseMetadata not implemented");
        return null;
    }
}
#method_after
private String[] parseMetadata(Bundle metadata) {
    if (SystemProperties.BLUETI_ENHANCEMENT) {
        if (metadata == null) {
            return new String[1];
        }
        Set<String> keys = metadata.keySet();
        String[] properties = new String[keys.size() * 2];
        int j = 0;
        for (String key : keys) {
            if (!mMetadataMap.containsKey(key)) {
                continue;
            }
            properties[j++] = mMetadataMap.get(key);
            // This could be done by a separate class which handle
            // Integer and String metadata. However this would imply
            // the native code to constantly call the VM methods to
            // extract the field, which is actually more expensive than
            // converting it to String
            properties[j++] = metadata.get(key).toString();
        }
        return properties;
    } else {
        Log.e(TAG, "SystemProperties.BLUETI_ENHANCEMENT == false," + " parseMetadata not implemented");
        return null;
    }
}
#end_block

#method_before
private String[] parseMediaPlayerSettings(Bundle settings) {
    if (SystemProperties.BLUETI_ENHANCEMENT) {
        if (settings == null)
            return new String[1];
        Set<String> keys = settings.keySet();
        String[] properties = new String[keys.size() * 2];
        int j = 0;
        for (String key : keys) {
            if (!mSettingsMap.containsKey(key)) {
                Log.e(TAG, "Ignoring unknown setting " + key);
                continue;
            }
            int value = settings.getInt(key);
            if (!mSettingValuesMap.containsKey(value)) {
                Log.e(TAG, "Ignoring setting " + key + " because of unkown value " + value);
                continue;
            }
            properties[j++] = mSettingsMap.get(key);
            properties[j++] = mSettingValuesMap.get(value);
        }
        return properties;
    } else {
        Log.e(TAG, "SystemProperties.BLUETI_ENHANCEMENT == false, parseMediaPlayerSettings not implemented");
        return null;
    }
}
#method_after
private String[] parseMediaPlayerSettings(Bundle settings) {
    if (SystemProperties.BLUETI_ENHANCEMENT) {
        if (settings == null) {
            return new String[1];
        }
        Set<String> keys = settings.keySet();
        String[] properties = new String[keys.size() * 2];
        int j = 0;
        for (String key : keys) {
            if (!mSettingsMap.containsKey(key)) {
                Log.e(TAG, "Ignoring unknown setting " + key);
                continue;
            }
            int value = settings.getInt(key);
            if (!mSettingValuesMap.containsKey(value)) {
                Log.e(TAG, "Ignoring setting " + key + " because of unkown value " + value);
                continue;
            }
            properties[j++] = mSettingsMap.get(key);
            properties[j++] = mSettingValuesMap.get(value);
        }
        return properties;
    } else {
        Log.e(TAG, "SystemProperties.BLUETI_ENHANCEMENT == false," + " parseMediaPlayerSettings not implemented");
        return null;
    }
}
#end_block

#method_before
private void avrcpRegisterMediaPlayer(Bundle metadata, Bundle settings) {
    if (SystemProperties.BLUETI_ENHANCEMENT) {
        String[] parsedMetadata = parseMetadata(metadata);
        String[] parsedSettings = parseMediaPlayerSettings(settings);
        Log.i(TAG, "Register player - metadata: " + parsedMetadata.length + " settings: " + parsedSettings.length);
        avrcpRegisterMediaPlayerNative(mBluetoothService, parsedMetadata, parsedSettings);
    } else {
        Log.e(TAG, "SystemProperties.BLUETI_ENHANCEMENT == false, avrcpRegisterMediaPlayer not implemented");
    }
}
#method_after
private void avrcpRegisterMediaPlayer(Bundle metadata, Bundle settings) {
    if (SystemProperties.BLUETI_ENHANCEMENT) {
        String[] parsedMetadata = parseMetadata(metadata);
        String[] parsedSettings = parseMediaPlayerSettings(settings);
        Log.i(TAG, "Register player - metadata: " + parsedMetadata.length + " settings: " + parsedSettings.length);
        avrcpRegisterMediaPlayerNative(mBluetoothService, parsedMetadata, parsedSettings);
    } else {
        Log.e(TAG, "SystemProperties.BLUETI_ENHANCEMENT == false," + " avrcpRegisterMediaPlayer not implemented");
    }
}
#end_block

#method_before
private static HashMap<Integer, String> createStatusMap() {
    if (SystemProperties.BLUETI_ENHANCEMENT) {
        HashMap<Integer, String> map = new HashMap<Integer, String>();
        map.put(AudioManager.MEDIA_PLAYBACK_STATUS_PLAYING, "playing");
        map.put(AudioManager.MEDIA_PLAYBACK_STATUS_STOPPED, "stopped");
        map.put(AudioManager.MEDIA_PLAYBACK_STATUS_PAUSED, "paused");
        map.put(AudioManager.MEDIA_PLAYBACK_STATUS_FORWARD_SEEK, "forward-seek");
        map.put(AudioManager.MEDIA_PLAYBACK_STATUS_REVERSE_SEEK, "reverse-seek");
        return map;
    } else {
        Log.e(TAG, "SystemProperties.BLUETI_ENHANCEMENT == false, createStatusMap not implemented");
        return null;
    }
}
#method_after
private static HashMap<Integer, String> createStatusMap() {
    if (SystemProperties.BLUETI_ENHANCEMENT) {
        HashMap<Integer, String> map = new HashMap<Integer, String>();
        map.put(AudioManager.MEDIA_PLAYBACK_STATUS_PLAYING, "playing");
        map.put(AudioManager.MEDIA_PLAYBACK_STATUS_STOPPED, "stopped");
        map.put(AudioManager.MEDIA_PLAYBACK_STATUS_PAUSED, "paused");
        map.put(AudioManager.MEDIA_PLAYBACK_STATUS_FORWARD_SEEK, "forward-seek");
        map.put(AudioManager.MEDIA_PLAYBACK_STATUS_REVERSE_SEEK, "reverse-seek");
        return map;
    } else {
        Log.e(TAG, "SystemProperties.BLUETI_ENHANCEMENT == false," + " createStatusMap not implemented");
        return null;
    }
}
#end_block

#method_before
private static HashMap<String, String> createSettingsMap() {
    if (SystemProperties.BLUETI_ENHANCEMENT) {
        HashMap<String, String> map = new HashMap<String, String>();
        map.put(AudioManager.MEDIA_PLAYER_SETTING_EQUALIZER, "Equalizer");
        map.put(AudioManager.MEDIA_PLAYER_SETTING_REPEAT, "Repeat");
        map.put(AudioManager.MEDIA_PLAYER_SETTING_SHUFFLE, "Shuffle");
        map.put(AudioManager.MEDIA_PLAYER_SETTING_SCAN, "Scan");
        return map;
    } else {
        Log.e(TAG, "SystemProperties.BLUETI_ENHANCEMENT == false, createSettingsMap not implemented");
        return null;
    }
}
#method_after
private static HashMap<String, String> createSettingsMap() {
    if (SystemProperties.BLUETI_ENHANCEMENT) {
        HashMap<String, String> map = new HashMap<String, String>();
        map.put(AudioManager.MEDIA_PLAYER_SETTING_EQUALIZER, "Equalizer");
        map.put(AudioManager.MEDIA_PLAYER_SETTING_REPEAT, "Repeat");
        map.put(AudioManager.MEDIA_PLAYER_SETTING_SHUFFLE, "Shuffle");
        map.put(AudioManager.MEDIA_PLAYER_SETTING_SCAN, "Scan");
        return map;
    } else {
        Log.e(TAG, "SystemProperties.BLUETI_ENHANCEMENT == false," + " createSettingsMap not implemented");
        return null;
    }
}
#end_block

#method_before
private static HashMap<Integer, String> createSettingValuesMap() {
    if (SystemProperties.BLUETI_ENHANCEMENT) {
        HashMap<Integer, String> map = new HashMap<Integer, String>();
        // We rely on the fact that equalizer, repeat, shuffle and scan modes
        // share some states, so we avoid populating the map with several
        // values.
        map.put(AudioManager.MEDIA_PLAYER_EQUALIZER_MODE_OFF, "off");
        map.put(AudioManager.MEDIA_PLAYER_EQUALIZER_MODE_ON, "on");
        map.put(AudioManager.MEDIA_PLAYER_REPEAT_MODE_SINGLETRACK, "singletrack");
        map.put(AudioManager.MEDIA_PLAYER_REPEAT_MODE_ALLTRACKS, "alltracks");
        map.put(AudioManager.MEDIA_PLAYER_REPEAT_MODE_GROUP, "group");
        return map;
    } else {
        Log.e(TAG, "SystemProperties.BLUETI_ENHANCEMENT == false, createSettingValuesMap not implemented");
        return null;
    }
}
#method_after
private static HashMap<Integer, String> createSettingValuesMap() {
    if (SystemProperties.BLUETI_ENHANCEMENT) {
        HashMap<Integer, String> map = new HashMap<Integer, String>();
        // We rely on the fact that equalizer, repeat, shuffle and scan modes
        // share some states, so we avoid populating the map with several
        // values.
        map.put(AudioManager.MEDIA_PLAYER_EQUALIZER_MODE_OFF, "off");
        map.put(AudioManager.MEDIA_PLAYER_EQUALIZER_MODE_ON, "on");
        map.put(AudioManager.MEDIA_PLAYER_REPEAT_MODE_SINGLETRACK, "singletrack");
        map.put(AudioManager.MEDIA_PLAYER_REPEAT_MODE_ALLTRACKS, "alltracks");
        map.put(AudioManager.MEDIA_PLAYER_REPEAT_MODE_GROUP, "group");
        return map;
    } else {
        Log.e(TAG, "SystemProperties.BLUETI_ENHANCEMENT == false," + " createSettingValuesMap not implemented");
        return null;
    }
}
#end_block

#method_before
private static HashMap<String, String> createMetadataMap() {
    if (SystemProperties.BLUETI_ENHANCEMENT) {
        HashMap<String, String> map = new HashMap<String, String>();
        map.put(AudioManager.EXTRA_MEDIA_TITLE, "Title");
        map.put(AudioManager.EXTRA_MEDIA_ARTIST, "Artist");
        map.put(AudioManager.EXTRA_MEDIA_ALBUM, "Album");
        map.put(AudioManager.EXTRA_MEDIA_GENRE, "Genre");
        map.put(AudioManager.EXTRA_MEDIA_NUMBER_OF_TRACKS, "NumberOfTracks");
        map.put(AudioManager.EXTRA_MEDIA_TRACK_NUMBER, "Number");
        map.put(AudioManager.EXTRA_MEDIA_TRACK_DURATION, "Duration");
        return map;
    } else {
        Log.e(TAG, "SystemProperties.BLUETI_ENHANCEMENT == false, createMetadataMap not implemented");
        return null;
    }
}
#method_after
private static HashMap<String, String> createMetadataMap() {
    if (SystemProperties.BLUETI_ENHANCEMENT) {
        HashMap<String, String> map = new HashMap<String, String>();
        map.put(AudioManager.EXTRA_MEDIA_TITLE, "Title");
        map.put(AudioManager.EXTRA_MEDIA_ARTIST, "Artist");
        map.put(AudioManager.EXTRA_MEDIA_ALBUM, "Album");
        map.put(AudioManager.EXTRA_MEDIA_GENRE, "Genre");
        map.put(AudioManager.EXTRA_MEDIA_NUMBER_OF_TRACKS, "NumberOfTracks");
        map.put(AudioManager.EXTRA_MEDIA_TRACK_NUMBER, "Number");
        map.put(AudioManager.EXTRA_MEDIA_TRACK_DURATION, "Duration");
        return map;
    } else {
        Log.e(TAG, "SystemProperties.BLUETI_ENHANCEMENT == false," + " createMetadataMap not implemented");
        return null;
    }
}
#end_block

#method_before
private synchronized void onMediaPlayerPropertyChanged(String[] propValues) {
    if (SystemProperties.BLUETI_ENHANCEMENT) {
        if (!mBluetoothService.isEnabled()) {
            return;
        }
        Log.d(TAG, "Received MediaPlayer setting: " + propValues[0] + "=" + propValues[1]);
        String name = propValues[0];
        String key = null;
        int val = -1;
        for (Map.Entry<String, String> entry : mSettingsMap.entrySet()) {
            if (entry.getValue().equalsIgnoreCase(propValues[0])) {
                key = entry.getKey();
                break;
            }
        }
        if (key == null) {
            Log.e(TAG, "Unknown setting key: " + propValues[0]);
            return;
        }
        for (Map.Entry<Integer, String> entry : mSettingValuesMap.entrySet()) {
            if (entry.getValue().equalsIgnoreCase(propValues[1])) {
                val = entry.getKey();
                break;
            }
        }
        if (val == -1) {
            Log.e(TAG, "Unknown setting value " + propValues[1] + " for key " + propValues[0]);
            return;
        }
        Log.d(TAG, "Setting MediaPlayer value: " + key + " = " + val);
        Intent intent = mContext.registerReceiver(null, new IntentFilter(AudioManager.ACTION_MEDIA_PLAYER_SETTINGS_CHANGED));
        if (intent != null) {
            intent.removeExtra(key);
        } else {
            intent = new Intent(AudioManager.ACTION_MEDIA_PLAYER_SETTINGS_CHANGED);
        }
        intent.putExtra(key, val);
        intent.addFlags(Intent.FLAG_FROM_BACKGROUND);
        mContext.sendStickyBroadcast(intent);
    } else {
        Log.e(TAG, "SystemProperties.BLUETI_ENHANCEMENT == false, createMetadataMap not implemented");
    }
}
#method_after
private synchronized void onMediaPlayerPropertyChanged(String[] propValues) {
    if (SystemProperties.BLUETI_ENHANCEMENT) {
        if (!mBluetoothService.isEnabled()) {
            return;
        }
        Log.d(TAG, "Received MediaPlayer setting: " + propValues[0] + "=" + propValues[1]);
        String name = propValues[0];
        String key = null;
        int val = -1;
        for (Map.Entry<String, String> entry : mSettingsMap.entrySet()) {
            if (entry.getValue().equalsIgnoreCase(propValues[0])) {
                key = entry.getKey();
                break;
            }
        }
        if (key == null) {
            Log.e(TAG, "Unknown setting key: " + propValues[0]);
            return;
        }
        for (Map.Entry<Integer, String> entry : mSettingValuesMap.entrySet()) {
            if (entry.getValue().equalsIgnoreCase(propValues[1])) {
                val = entry.getKey();
                break;
            }
        }
        if (val == -1) {
            Log.e(TAG, "Unknown setting value " + propValues[1] + " for key " + propValues[0]);
            return;
        }
        Log.d(TAG, "Setting MediaPlayer value: " + key + " = " + val);
        Intent intent = mContext.registerReceiver(null, new IntentFilter(AudioManager.ACTION_MEDIA_PLAYER_SETTINGS_CHANGED));
        if (intent != null) {
            intent.removeExtra(key);
        } else {
            intent = new Intent(AudioManager.ACTION_MEDIA_PLAYER_SETTINGS_CHANGED);
        }
        intent.putExtra(key, val);
        intent.addFlags(Intent.FLAG_FROM_BACKGROUND);
        mContext.sendStickyBroadcast(intent);
    } else {
        Log.e(TAG, "SystemProperties.BLUETI_ENHANCEMENT == false," + " createMetadataMap not implemented");
    }
}
#end_block

#method_before
public static Uri getContentUri(String volumeName) {
    return Uri.parse(CONTENT_AUTHORITY_SLASH + volumeName + "/video/media");
}
#method_after
public static Uri getContentUri(String volumeName) {
    return Uri.parse(CONTENT_AUTHORITY_SLASH + volumeName + "/images/media");
}
#end_block

#method_before
public static Bitmap getThumbnail(ContentResolver cr, long origId, int kind, BitmapFactory.Options options) {
    return InternalThumbnails.getThumbnail(cr, origId, InternalThumbnails.DEFAULT_GROUP_ID, kind, options, EXTERNAL_CONTENT_URI, true);
}
#method_after
public static Bitmap getThumbnail(ContentResolver cr, long origId, int kind, BitmapFactory.Options options) {
    return InternalThumbnails.getThumbnail(cr, origId, InternalThumbnails.DEFAULT_GROUP_ID, kind, options, EXTERNAL_CONTENT_URI, false);
}
#end_block

#method_before
public static Bitmap getThumbnail(ContentResolver cr, long origId, long groupId, int kind, BitmapFactory.Options options) {
    return InternalThumbnails.getThumbnail(cr, origId, groupId, kind, options, EXTERNAL_CONTENT_URI, true);
}
#method_after
public static Bitmap getThumbnail(ContentResolver cr, long origId, long groupId, int kind, BitmapFactory.Options options) {
    return InternalThumbnails.getThumbnail(cr, origId, groupId, kind, options, EXTERNAL_CONTENT_URI, false);
}
#end_block

#method_before
public static Uri getContentUri(String volumeName) {
    return Uri.parse(CONTENT_AUTHORITY_SLASH + volumeName + "/video/thumbnails");
}
#method_after
public static Uri getContentUri(String volumeName) {
    return Uri.parse(CONTENT_AUTHORITY_SLASH + volumeName + "/images/thumbnails");
}
#end_block

#method_before
public static Uri getContentUri(String volumeName) {
    return Uri.parse(CONTENT_AUTHORITY_SLASH + volumeName + "/video/media");
}
#method_after
public static Uri getContentUri(String volumeName) {
    return Uri.parse(CONTENT_AUTHORITY_SLASH + volumeName + "/audio/media");
}
#end_block

#method_before
public static final Uri getContentUri(String volumeName, long playlistId) {
    return Uri.parse(CONTENT_AUTHORITY_SLASH + volumeName + "/audio/playlists/" + playlistId + "/members");
}
#method_after
public static final Uri getContentUri(String volumeName, long genreId) {
    return Uri.parse(CONTENT_AUTHORITY_SLASH + volumeName + "/audio/genres/" + genreId + "/members");
}
#end_block

#method_before
public static void cancelThumbnailRequest(ContentResolver cr, long origId, long groupId) {
    InternalThumbnails.cancelThumbnailRequest(cr, origId, EXTERNAL_CONTENT_URI, groupId);
}
#method_after
public static void cancelThumbnailRequest(ContentResolver cr, long origId) {
    InternalThumbnails.cancelThumbnailRequest(cr, origId, EXTERNAL_CONTENT_URI, InternalThumbnails.DEFAULT_GROUP_ID);
}
#end_block

#method_before
public static Bitmap getThumbnail(ContentResolver cr, long origId, long groupId, int kind, BitmapFactory.Options options) {
    return InternalThumbnails.getThumbnail(cr, origId, groupId, kind, options, EXTERNAL_CONTENT_URI, true);
}
#method_after
public static Bitmap getThumbnail(ContentResolver cr, long origId, int kind, BitmapFactory.Options options) {
    return InternalThumbnails.getThumbnail(cr, origId, InternalThumbnails.DEFAULT_GROUP_ID, kind, options, EXTERNAL_CONTENT_URI, true);
}
#end_block

#method_before
public void registerMediaPlayerEventReceiver(ComponentName eventReceiver) {
    if (SystemProperties.BLUETI_ENHANCEMENT) {
        // TODO enforce the rule about the receiver being declared in the manifest
        IAudioService service = getService();
        try {
            service.registerMediaPlayerEventReceiver(eventReceiver);
        } catch (RemoteException e) {
            Log.e(TAG, "Dead object in registerMediaButtonEventReceiver" + e);
        }
    } else {
        Log.e(TAG, "SystemProperties.BLUETI_ENHANCEMENT==false, registerMediaPlayerEventReceiver not implemented");
    }
}
#method_after
public void registerMediaPlayerEventReceiver(ComponentName eventReceiver) {
    if (SystemProperties.BLUETI_ENHANCEMENT) {
        // TODO enforce the rule about the receiver being declared in the manifest
        IAudioService service = getService();
        try {
            service.registerMediaPlayerEventReceiver(eventReceiver);
        } catch (RemoteException e) {
            Log.e(TAG, "Dead object in registerMediaButtonEventReceiver" + e);
        }
    } else {
        Log.e(TAG, "SystemProperties.BLUETI_ENHANCEMENT==false," + "registerMediaPlayerEventReceiver not implemented");
    }
}
#end_block

#method_before
public void unregisterMediaPlayerEventReceiver(ComponentName eventReceiver) {
    if (SystemProperties.BLUETI_ENHANCEMENT) {
        IAudioService service = getService();
        try {
            service.unregisterMediaPlayerEventReceiver(eventReceiver);
        } catch (RemoteException e) {
            Log.e(TAG, "Dead object in unregisterMediaButtonEventReceiver" + e);
        }
    } else {
        Log.e(TAG, "SystemProperties.BLUETI_ENHANCEMENT==false, unregisterMediaPlayerEventReceiver not implemented");
    }
}
#method_after
public void unregisterMediaPlayerEventReceiver(ComponentName eventReceiver) {
    if (SystemProperties.BLUETI_ENHANCEMENT) {
        IAudioService service = getService();
        try {
            service.unregisterMediaPlayerEventReceiver(eventReceiver);
        } catch (RemoteException e) {
            Log.e(TAG, "Dead object in unregisterMediaButtonEventReceiver" + e);
        }
    } else {
        Log.e(TAG, "SystemProperties.BLUETI_ENHANCEMENT==false," + " unregisterMediaPlayerEventReceiver not implemented");
    }
}
#end_block

#method_before
public void setCurrentMediaPlaybackStatus(int status, long elapsed) {
    if (SystemProperties.BLUETI_ENHANCEMENT) {
        IAudioService service = getService();
        try {
            service.setCurrentMediaPlaybackStatus(status, elapsed);
        } catch (RemoteException e) {
            Log.e(TAG, "Dead object in setCurrentMediaPlaybackStatus" + e);
        }
    }
}
#method_after
public void setCurrentMediaPlaybackStatus(int status, long elapsed) {
    if (SystemProperties.BLUETI_ENHANCEMENT) {
        IAudioService service = getService();
        try {
            service.setCurrentMediaPlaybackStatus(status, elapsed);
        } catch (RemoteException e) {
            Log.e(TAG, "Dead object in setCurrentMediaPlaybackStatus" + e);
        }
    } else {
        Log.e(TAG, "SystemProperties.BLUETI_ENHANCEMENT==false," + " setCurrentMediaPlaybackStatus not implemented");
    }
}
#end_block

#method_before
public void setCurrentMedia(Bundle metadata) {
    if (SystemProperties.BLUETI_ENHANCEMENT) {
        IAudioService service = getService();
        try {
            service.setCurrentMedia(metadata);
        } catch (RemoteException e) {
            Log.e(TAG, "Dead object in setCurrentMediaPlaybackStatus" + e);
        }
    }
}
#method_after
public void setCurrentMedia(Bundle metadata) {
    if (SystemProperties.BLUETI_ENHANCEMENT) {
        IAudioService service = getService();
        try {
            service.setCurrentMedia(metadata);
        } catch (RemoteException e) {
            Log.e(TAG, "Dead object in setCurrentMediaPlaybackStatus" + e);
        }
    } else {
        Log.e(TAG, "SystemProperties.BLUETI_ENHANCEMENT==false," + " setCurrentMedia not implemented");
    }
}
#end_block

#method_before
public void setCurrentMediaPlayerSettings(Bundle settings) {
    if (SystemProperties.BLUETI_ENHANCEMENT) {
        IAudioService service = getService();
        try {
            service.setCurrentMediaPlayerSettings(settings);
        } catch (RemoteException e) {
            Log.e(TAG, "Dead object in setCurrentMediaPlayerSettings" + e);
        }
    }
}
#method_after
public void setCurrentMediaPlayerSettings(Bundle settings) {
    if (SystemProperties.BLUETI_ENHANCEMENT) {
        IAudioService service = getService();
        try {
            service.setCurrentMediaPlayerSettings(settings);
        } catch (RemoteException e) {
            Log.e(TAG, "Dead object in setCurrentMediaPlayerSettings" + e);
        }
    } else {
        Log.e(TAG, "SystemProperties.BLUETI_ENHANCEMENT==false," + " setCurrentMediaPlayerSettings not implemented");
    }
}
#end_block

#method_before
private void addDevice(String address, String[] properties) {
    BluetoothDeviceProperties deviceProperties = mBluetoothService.getDeviceProperties();
    // BLUETI_ENHANCEMENT
    Boolean leDevice = false;
    deviceProperties.addProperties(address, properties);
    String rssi = deviceProperties.getProperty(address, "RSSI");
    String classValue = deviceProperties.getProperty(address, "Class");
    String name = deviceProperties.getProperty(address, "Name");
    // BLUETI_ENHANCEMENT
    String broadcaster = deviceProperties.getProperty(address, "Broadcaster");
    short rssiValue;
    if (SystemProperties.BLUETI_ENHANCEMENT) {
        if (broadcaster != null) {
            classValue = "0";
            leDevice = true;
        }
        if (DBG)
            Log.d(TAG, "Address:" + address + " RSSI:" + rssi + " name:" + name + " LE:" + leDevice + " Class:" + classValue);
    }
    // If we accept the pairing, we will automatically show it at the top of the list.
    if (rssi != null) {
        rssiValue = (short) Integer.valueOf(rssi).intValue();
    } else {
        rssiValue = Short.MIN_VALUE;
    }
    if (classValue != null) {
        Intent intent = new Intent(BluetoothDevice.ACTION_FOUND);
        if (SystemProperties.BLUETI_ENHANCEMENT) {
            BluetoothDevice dev = mAdapter.getRemoteDevice(address);
            if (leDevice == false) {
                dev.SetDeviceBrEdr();
            } else {
                dev.SetDeviceLe();
            }
            intent.putExtra(BluetoothDevice.EXTRA_DEVICE, dev);
        } else {
            intent.putExtra(BluetoothDevice.EXTRA_DEVICE, mAdapter.getRemoteDevice(address));
        }
        intent.putExtra(BluetoothDevice.EXTRA_CLASS, new BluetoothClass(Integer.valueOf(classValue)));
        intent.putExtra(BluetoothDevice.EXTRA_RSSI, rssiValue);
        intent.putExtra(BluetoothDevice.EXTRA_NAME, name);
        if (SystemProperties.BLUETI_ENHANCEMENT) {
            intent.putExtra(BluetoothDevice.EXTRA_DEVICE_TYPE, (leDevice ? BluetoothDevice.DEVICE_TYPE_LE : BluetoothDevice.DEVICE_TYPE_BR_EDR));
        }
        mContext.sendBroadcast(intent, BLUETOOTH_PERM);
    } else {
        log("ClassValue: " + classValue + " for remote device: " + address + " is null");
    }
}
#method_after
private void addDevice(String address, String[] properties) {
    BluetoothDeviceProperties deviceProperties = mBluetoothService.getDeviceProperties();
    // BLUETI_ENHANCEMENT
    Boolean leDevice = false;
    deviceProperties.addProperties(address, properties);
    String rssi = deviceProperties.getProperty(address, "RSSI");
    String classValue = deviceProperties.getProperty(address, "Class");
    String name = deviceProperties.getProperty(address, "Name");
    // BLUETI_ENHANCEMENT
    String broadcaster = deviceProperties.getProperty(address, "Broadcaster");
    short rssiValue;
    if (SystemProperties.BLUETI_ENHANCEMENT) {
        if (broadcaster != null) {
            classValue = "0";
            leDevice = true;
        }
        if (DBG) {
            Log.d(TAG, "Address:" + address + " RSSI:" + rssi + " name:" + name);
            Log.d(TAG, " LE:" + leDevice + " Class:" + classValue);
        }
    }
    // If we accept the pairing, we will automatically show it at the top of the list.
    if (rssi != null) {
        rssiValue = (short) Integer.valueOf(rssi).intValue();
    } else {
        rssiValue = Short.MIN_VALUE;
    }
    if (classValue != null) {
        Intent intent = new Intent(BluetoothDevice.ACTION_FOUND);
        if (SystemProperties.BLUETI_ENHANCEMENT) {
            BluetoothDevice dev = mAdapter.getRemoteDevice(address);
            if (leDevice == false) {
                dev.SetDeviceBrEdr();
            } else {
                dev.SetDeviceLe();
            }
            intent.putExtra(BluetoothDevice.EXTRA_DEVICE, dev);
        } else {
            intent.putExtra(BluetoothDevice.EXTRA_DEVICE, mAdapter.getRemoteDevice(address));
        }
        intent.putExtra(BluetoothDevice.EXTRA_CLASS, new BluetoothClass(Integer.valueOf(classValue)));
        intent.putExtra(BluetoothDevice.EXTRA_RSSI, rssiValue);
        intent.putExtra(BluetoothDevice.EXTRA_NAME, name);
        if (SystemProperties.BLUETI_ENHANCEMENT) {
            intent.putExtra(BluetoothDevice.EXTRA_DEVICE_TYPE, (leDevice ? BluetoothDevice.DEVICE_TYPE_LE : BluetoothDevice.DEVICE_TYPE_BR_EDR));
        }
        mContext.sendBroadcast(intent, BLUETOOTH_PERM);
    } else {
        log("ClassValue: " + classValue + " for remote device: " + address + " is null");
    }
}
#end_block

#method_before
private void onRequestPinCode(String objectPath, int nativeData) {
    String address = checkPairingRequestAndGetAddress(objectPath, nativeData);
    if (address == null)
        return;
    String pendingOutgoingAddress = mBluetoothService.getPendingOutgoingBonding();
    BluetoothClass btClass = new BluetoothClass(mBluetoothService.getRemoteClass(address));
    int btDeviceClass = btClass.getDeviceClass();
    if (address.equals(pendingOutgoingAddress)) {
        // Check if its a dock
        if (mBluetoothService.isBluetoothDock(address)) {
            String pin = mBluetoothService.getDockPin();
            mBluetoothService.setPin(address, BluetoothDevice.convertPinToBytes(pin));
            return;
        }
        // try 0000 once if the device looks dumb
        switch(btDeviceClass) {
            case BluetoothClass.Device.AUDIO_VIDEO_WEARABLE_HEADSET:
            case BluetoothClass.Device.AUDIO_VIDEO_HANDSFREE:
            case BluetoothClass.Device.AUDIO_VIDEO_HEADPHONES:
            case BluetoothClass.Device.AUDIO_VIDEO_PORTABLE_AUDIO:
            case BluetoothClass.Device.AUDIO_VIDEO_HIFI_AUDIO:
                if (mBluetoothService.attemptAutoPair(address))
                    return;
        }
    }
    if (btDeviceClass == BluetoothClass.Device.PERIPHERAL_KEYBOARD || btDeviceClass == BluetoothClass.Device.PERIPHERAL_KEYBOARD_POINTING) {
        // and pair.
        if (mBluetoothService.isFixedPinZerosAutoPairKeyboard(address)) {
            mBluetoothService.setPin(address, BluetoothDevice.convertPinToBytes("0000"));
            return;
        }
        // Generate a variable PIN. This is not truly random but good enough.
        int pin = (int) Math.floor(Math.random() * 10000);
        sendDisplayPinIntent(address, pin);
        return;
    }
    // Acquire wakelock during PIN code request to bring up LCD display
    if (!SystemProperties.BLUETI_ENHANCEMENT) {
        mWakeLock.acquire();
    }
    Intent intent = new Intent(BluetoothDevice.ACTION_PAIRING_REQUEST);
    intent.putExtra(BluetoothDevice.EXTRA_DEVICE, mAdapter.getRemoteDevice(address));
    intent.putExtra(BluetoothDevice.EXTRA_PAIRING_VARIANT, BluetoothDevice.PAIRING_VARIANT_PIN);
    mContext.sendBroadcast(intent, BLUETOOTH_ADMIN_PERM);
    // Release wakelock to allow the LCD to go off after the PIN popup notification.
    if (SystemProperties.BLUETI_ENHANCEMENT) {
        // TI-BLUEZ Fix - bring up LCD display for PIN_CODE_REQUEST_WAKELOCK_TIME
        mWakeLock.acquire(PIN_CODE_REQUEST_WAKELOCK_TIME);
    } else {
        mWakeLock.release();
    }
    return;
}
#method_after
private void onRequestPinCode(String objectPath, int nativeData) {
    String address = checkPairingRequestAndGetAddress(objectPath, nativeData);
    if (address == null)
        return;
    String pendingOutgoingAddress = mBluetoothService.getPendingOutgoingBonding();
    BluetoothClass btClass = new BluetoothClass(mBluetoothService.getRemoteClass(address));
    int btDeviceClass = btClass.getDeviceClass();
    if (address.equals(pendingOutgoingAddress)) {
        // Check if its a dock
        if (mBluetoothService.isBluetoothDock(address)) {
            String pin = mBluetoothService.getDockPin();
            mBluetoothService.setPin(address, BluetoothDevice.convertPinToBytes(pin));
            return;
        }
        // try 0000 once if the device looks dumb
        switch(btDeviceClass) {
            case BluetoothClass.Device.AUDIO_VIDEO_WEARABLE_HEADSET:
            case BluetoothClass.Device.AUDIO_VIDEO_HANDSFREE:
            case BluetoothClass.Device.AUDIO_VIDEO_HEADPHONES:
            case BluetoothClass.Device.AUDIO_VIDEO_PORTABLE_AUDIO:
            case BluetoothClass.Device.AUDIO_VIDEO_HIFI_AUDIO:
                if (mBluetoothService.attemptAutoPair(address))
                    return;
        }
    }
    if (btDeviceClass == BluetoothClass.Device.PERIPHERAL_KEYBOARD || btDeviceClass == BluetoothClass.Device.PERIPHERAL_KEYBOARD_POINTING) {
        // and pair.
        if (mBluetoothService.isFixedPinZerosAutoPairKeyboard(address)) {
            mBluetoothService.setPin(address, BluetoothDevice.convertPinToBytes("0000"));
            return;
        }
        // Generate a variable PIN. This is not truly random but good enough.
        int pin = (int) Math.floor(Math.random() * 10000);
        sendDisplayPinIntent(address, pin);
        return;
    }
    // Acquire wakelock during PIN code request to bring up LCD display
    if (!SystemProperties.BLUETI_ENHANCEMENT) {
        mWakeLock.acquire();
    }
    Intent intent = new Intent(BluetoothDevice.ACTION_PAIRING_REQUEST);
    intent.putExtra(BluetoothDevice.EXTRA_DEVICE, mAdapter.getRemoteDevice(address));
    intent.putExtra(BluetoothDevice.EXTRA_PAIRING_VARIANT, BluetoothDevice.PAIRING_VARIANT_PIN);
    mContext.sendBroadcast(intent, BLUETOOTH_ADMIN_PERM);
    // Release wakelock to allow the LCD to go off after the PIN popup notification.
    if (SystemProperties.BLUETI_ENHANCEMENT) {
        mWakeLock.acquire(PIN_CODE_REQUEST_WAKELOCK_TIME);
    } else {
        mWakeLock.release();
    }
    return;
}
#end_block

#method_before
private void onAgentAuthorize(String objectPath, String deviceUuid, int nativeData) {
    if (!mBluetoothService.isEnabled())
        return;
    String address = mBluetoothService.getAddressFromObjectPath(objectPath);
    if (address == null) {
        Log.e(TAG, "Unable to get device address in onAuthAgentAuthorize");
        return;
    }
    boolean authorized = false;
    ParcelUuid uuid = ParcelUuid.fromString(deviceUuid);
    BluetoothDevice device = mAdapter.getRemoteDevice(address);
    mAuthorizationAgentRequestData.put(address, new Integer(nativeData));
    // remote service
    if (mA2dp != null && (BluetoothUuid.isAudioSource(uuid) || BluetoothUuid.isAvrcpTarget(uuid) || BluetoothUuid.isAdvAudioDist(uuid)) && !isOtherSinkInNonDisconnectedState(address)) {
        authorized = mA2dp.getPriority(device) > BluetoothProfile.PRIORITY_OFF;
        if (authorized && !BluetoothUuid.isAvrcpTarget(uuid)) {
            if (SystemProperties.BLUETI_ENHANCEMENT)
                Log.i(TAG, "First check pass for incoming A2DP connection from " + address);
            else
                Log.i(TAG, "First check pass for incoming A2DP / AVRCP connection from " + address);
            // Some headsets try to connect AVCTP before AVDTP - against the recommendation
            // If AVCTP connection fails, we get stuck in IncomingA2DP state in the state
            // machine.  We don't handle AVCTP signals currently. We only send
            // intents for AVDTP state changes. We need to handle both of them in
            // some cases. For now, just don't move to incoming state in this case.
            mBluetoothService.notifyIncomingA2dpConnection(address, false);
        } else {
            if (SystemProperties.BLUETI_ENHANCEMENT) {
                /* In this case we know we are in AVRCP connect */
                Log.i(TAG, "" + authorized + "Incoming AVRCP connection from " + address);
            } else {
                Log.i(TAG, "" + authorized + "Incoming A2DP / AVRCP connection from " + address);
            }
            mA2dp.allowIncomingConnect(device, authorized);
            mBluetoothService.notifyIncomingA2dpConnection(address, true);
            if (SystemProperties.BLUETI_ENHANCEMENT)
                /* as AVRCP does not have a profile state we handle this here */
                mBluetoothService.notifyIncomingAVRCPConnection(address);
        }
    } else if (BluetoothUuid.isInputDevice(uuid)) {
        // We can have more than 1 input device connected.
        authorized = mBluetoothService.getInputDevicePriority(device) > BluetoothInputDevice.PRIORITY_OFF;
        if (authorized) {
            Log.i(TAG, "First check pass for incoming HID connection from " + address);
            // notify profile state change
            mBluetoothService.notifyIncomingHidConnection(address);
        } else {
            Log.i(TAG, "Rejecting incoming HID connection from " + address);
            mBluetoothService.allowIncomingProfileConnect(device, authorized);
        }
    } else if (BluetoothUuid.isBnep(uuid)) {
        // PAN doesn't go to the state machine, accept or reject from here
        authorized = mBluetoothService.allowIncomingTethering();
        mBluetoothService.allowIncomingProfileConnect(device, authorized);
    } else {
        Log.i(TAG, "Rejecting incoming " + deviceUuid + " connection from " + address);
        mBluetoothService.allowIncomingProfileConnect(device, authorized);
    }
    log("onAgentAuthorize(" + objectPath + ", " + deviceUuid + ") = " + authorized);
}
#method_after
private void onAgentAuthorize(String objectPath, String deviceUuid, int nativeData) {
    if (!mBluetoothService.isEnabled())
        return;
    String address = mBluetoothService.getAddressFromObjectPath(objectPath);
    if (address == null) {
        Log.e(TAG, "Unable to get device address in onAuthAgentAuthorize");
        return;
    }
    boolean authorized = false;
    ParcelUuid uuid = ParcelUuid.fromString(deviceUuid);
    BluetoothDevice device = mAdapter.getRemoteDevice(address);
    mAuthorizationAgentRequestData.put(address, new Integer(nativeData));
    // remote service
    if (mA2dp != null && (BluetoothUuid.isAudioSource(uuid) || BluetoothUuid.isAvrcpTarget(uuid) || BluetoothUuid.isAdvAudioDist(uuid)) && !isOtherSinkInNonDisconnectedState(address)) {
        authorized = mA2dp.getPriority(device) > BluetoothProfile.PRIORITY_OFF;
        if (authorized && !BluetoothUuid.isAvrcpTarget(uuid)) {
            if (SystemProperties.BLUETI_ENHANCEMENT) {
                Log.i(TAG, "First check pass for incoming A2DP connection from " + address);
            } else {
                Log.i(TAG, "First check pass for incoming A2DP / AVRCP connection from " + address);
            }
            // Some headsets try to connect AVCTP before AVDTP - against the recommendation
            // If AVCTP connection fails, we get stuck in IncomingA2DP state in the state
            // machine.  We don't handle AVCTP signals currently. We only send
            // intents for AVDTP state changes. We need to handle both of them in
            // some cases. For now, just don't move to incoming state in this case.
            mBluetoothService.notifyIncomingA2dpConnection(address, false);
        } else {
            if (SystemProperties.BLUETI_ENHANCEMENT) {
                /* In this case we know we are in AVRCP connect */
                Log.i(TAG, "" + authorized + "Incoming AVRCP connection from " + address);
            } else {
                Log.i(TAG, "" + authorized + "Incoming A2DP / AVRCP connection from " + address);
            }
            mA2dp.allowIncomingConnect(device, authorized);
            mBluetoothService.notifyIncomingA2dpConnection(address, true);
            if (SystemProperties.BLUETI_ENHANCEMENT) {
                /* as AVRCP does not have a profile state we handle this here */
                mBluetoothService.notifyIncomingAVRCPConnection(address);
            }
        }
    } else if (BluetoothUuid.isInputDevice(uuid)) {
        // We can have more than 1 input device connected.
        authorized = mBluetoothService.getInputDevicePriority(device) > BluetoothInputDevice.PRIORITY_OFF;
        if (authorized) {
            Log.i(TAG, "First check pass for incoming HID connection from " + address);
            // notify profile state change
            mBluetoothService.notifyIncomingHidConnection(address);
        } else {
            Log.i(TAG, "Rejecting incoming HID connection from " + address);
            mBluetoothService.allowIncomingProfileConnect(device, authorized);
        }
    } else if (BluetoothUuid.isBnep(uuid)) {
        // PAN doesn't go to the state machine, accept or reject from here
        authorized = mBluetoothService.allowIncomingTethering();
        mBluetoothService.allowIncomingProfileConnect(device, authorized);
    } else {
        Log.i(TAG, "Rejecting incoming " + deviceUuid + " connection from " + address);
        mBluetoothService.allowIncomingProfileConnect(device, authorized);
    }
    log("onAgentAuthorize(" + objectPath + ", " + deviceUuid + ") = " + authorized);
}
#end_block

#method_before
/*
     * IBluetoothGattClientCallback overrides
     */
@Override
public void valueChanged(String path, byte[] value) {
    log("Value changed on " + path);
    GattCharacteristic chr = mCharacteristics.get(path);
    if (chr != null)
        chr.notifyValueChanged(value);
}
#method_after
/*
     * IBluetoothGattClientCallback overrides
     */
@Override
public void valueChanged(String path, byte[] value) {
    log("Value changed on " + path);
    GattCharacteristic chr = mCharacteristics.get(path);
    if (chr != null) {
        chr.notifyValueChanged(value);
    }
}
#end_block

#method_before
@Override
public void propertyChanged(String path, String property, String value) {
    log("property changed on " + path);
    GattCharacteristic chr = mCharacteristics.get(path);
    if (chr != null) {
        if (property.equals("Indicate"))
            chr.setIndicating(value.equals("true"));
        else if (property.equals("Broadcast"))
            chr.setBroadcasting(value.equals("true"));
        else if (property.equals("Notify"))
            chr.setNotifying(value.equals("true"));
    }
}
#method_after
@Override
public void propertyChanged(String path, String property, String value) {
    log("property changed on " + path);
    GattCharacteristic chr = mCharacteristics.get(path);
    if (chr != null) {
        if (property.equals("Indicate")) {
            chr.setIndicating(value.equals("true"));
        } else if (property.equals("Broadcast")) {
            chr.setBroadcasting(value.equals("true"));
        } else if (property.equals("Notify")) {
            chr.setNotifying(value.equals("true"));
        }
    }
}
#end_block

#method_before
@Override
public void clientConnected(String addr) {
    log("clientConnected " + addr);
    if (mClientCB != null)
        mClientCB.onClientConnected(addr);
}
#method_after
@Override
public void clientConnected(String addr) {
    log("clientConnected " + addr);
    if (mClientCB != null) {
        mClientCB.onClientConnected(addr);
    }
}
#end_block

#method_before
@Override
public void clientDisconnected(String addr) {
    log("clientDisconnected " + addr);
    if (mClientCB != null)
        mClientCB.onClientDisconnected(addr);
}
#method_after
@Override
public void clientDisconnected(String addr) {
    log("clientDisconnected " + addr);
    if (mClientCB != null) {
        mClientCB.onClientDisconnected(addr);
    }
}
#end_block

#method_before
@Override
public void valueWriteReqComplete(String path, byte result) {
    log("valueWriteReqComplete path:" + path + " result:" + result);
    GattCharacteristic chr = mCharacteristics.get(path);
    if (chr != null)
        chr.notifyWriteComplete(result);
}
#method_after
@Override
public void valueWriteReqComplete(String path, byte result) {
    log("valueWriteReqComplete path:" + path + " result:" + result);
    GattCharacteristic chr = mCharacteristics.get(path);
    if (chr != null) {
        chr.notifyWriteComplete(result);
    }
}
#end_block

#method_before
@Override
public void valueReadComplete(String path, byte result, byte[] data) {
    log("valueReadComplete path:" + path + " result:" + result + " data[0]:" + data[0]);
    GattCharacteristic chr = mCharacteristics.get(path);
    if (chr != null)
        chr.notifyReadComplete(result, data);
}
#method_after
@Override
public void valueReadComplete(String path, byte result, byte[] data) {
    log("valueReadComplete path:" + path + " result:" + result + " data[0]:" + data[0]);
    GattCharacteristic chr = mCharacteristics.get(path);
    if (chr != null) {
        chr.notifyReadComplete(result, data);
    }
}
#end_block

#method_before
public void dump() {
    try {
        log("------------>8------------ GattService dump start ------------>8------------");
        log(mUuid.toString());
        log(mPath);
        log(mGattClient.getDevice().toString());
        if (mCharacteristics != null && mCharacteristics.size() > 0) {
            for (int i = 0; i < mCharacteristics.size(); i++) mCharacteristics.get(i).dump();
        } else
            log("No charactersitics!");
        log("------------8<------------ GattService dump end   ------------8<------------");
    } catch (Exception e) {
        Log.e(TAG, "dump exception " + e);
    }
}
#method_after
public void dump() {
    try {
        log("------------>8------------ GattService dump start ------------>8------------");
        log(mUuid.toString());
        log(mPath);
        log(mGattClient.getDevice().toString());
        if (mCharacteristics != null && mCharacteristics.size() > 0) {
            for (int i = 0; i < mCharacteristics.size(); i++) mCharacteristics.get(i).dump();
        } else {
            log("No charactersitics!");
        }
        log("------------8<------------ GattService dump end   ------------8<------------");
    } catch (Exception e) {
        Log.e(TAG, "dump exception " + e);
    }
}
#end_block

#method_before
private void checkValid() throws GattClientException {
    if (!mValid)
        throw new GattClientException("Invalid handle cache");
}
#method_after
private void checkValid() throws GattClientException {
    if (!mValid) {
        throw new GattClientException("Invalid handle cache");
    }
}
#end_block

#method_before
public ArrayList<GattCharacteristic> getCharacteristics() throws GattClientException {
    checkValid();
    if (mCharacteristics == null)
        discoverAllChars();
    return mCharacteristics;
}
#method_after
public ArrayList<GattCharacteristic> getCharacteristics() throws GattClientException {
    checkValid();
    if (mCharacteristics == null) {
        discoverAllChars();
    }
    return mCharacteristics;
}
#end_block

#method_before
public ArrayList<GattCharacteristic> getCharacteristics(UUID uuid) throws GattClientException {
    checkValid();
    if (mCharacteristics == null)
        discoverAllChars();
    if (mCharacteristics != null) {
        ArrayList<GattCharacteristic> gattCharList = new ArrayList<GattCharacteristic>();
        for (int i = 0; i < mCharacteristics.size(); i++) {
            GattCharacteristic characteristic = mCharacteristics.get(i);
            if (characteristic.getUUID().compareTo(uuid) == 0)
                gattCharList.add(characteristic);
        }
        return gattCharList;
    }
    return null;
}
#method_after
public ArrayList<GattCharacteristic> getCharacteristics(UUID uuid) throws GattClientException {
    checkValid();
    if (mCharacteristics == null) {
        discoverAllChars();
    }
    if (mCharacteristics != null) {
        ArrayList<GattCharacteristic> gattCharList = new ArrayList<GattCharacteristic>();
        for (int i = 0; i < mCharacteristics.size(); i++) {
            GattCharacteristic characteristic = mCharacteristics.get(i);
            if (characteristic.getUUID().compareTo(uuid) == 0) {
                gattCharList.add(characteristic);
            }
        }
        return gattCharList;
    }
    return null;
}
#end_block

#method_before
public GattCharacteristic getCharacteristic(UUID uuid) throws GattClientException {
    checkValid();
    if (mCharacteristics == null)
        discoverAllChars();
    if (mCharacteristics != null) {
        for (int i = 0; i < mCharacteristics.size(); i++) {
            GattCharacteristic characteristic = mCharacteristics.get(i);
            if (characteristic.getUUID().compareTo(uuid) == 0)
                return characteristic;
        }
    }
    return null;
}
#method_after
public GattCharacteristic getCharacteristic(UUID uuid) throws GattClientException {
    checkValid();
    if (mCharacteristics == null) {
        discoverAllChars();
    }
    if (mCharacteristics != null) {
        for (int i = 0; i < mCharacteristics.size(); i++) {
            GattCharacteristic characteristic = mCharacteristics.get(i);
            if (characteristic.getUUID().compareTo(uuid) == 0) {
                return characteristic;
            }
        }
    }
    return null;
}
#end_block

#method_before
public void dump() {
    try {
        log("------------>8------------ GattCharacteristic dump start ------------>8------------");
        log(mUuid.toString());
        log(mPath);
        log(mGattClient.getDevice().toString());
        String props = "";
        if (mNotifying)
            props += " Notifying";
        if (mIndicating)
            props += " Indicating";
        if (mBroadcasting)
            props += " Broadcasting";
        if (mWritableWithRsp)
            props += " write_req";
        if (mWritableWitoutRsp)
            props += " write_cmd";
        if (mWritableSigned)
            props += " write_auth";
        if (mWritableReliable)
            props += " write_rel";
        if (mReadable)
            props += " readable";
        if (props.equals(""))
            log("no properties");
        else
            log(props);
        log("------------8<------------ GattCharacteristic dump end   ------------8<------------");
    } catch (Exception e) {
        Log.e(TAG, "dump exception " + e);
    }
}
#method_after
public void dump() {
    try {
        log("------------>8------------ GattCharacteristic dump start ------------>8------------");
        log(mUuid.toString());
        log(mPath);
        log(mGattClient.getDevice().toString());
        String props = "";
        if (mNotifying)
            props += " Notifying";
        if (mIndicating)
            props += " Indicating";
        if (mBroadcasting)
            props += " Broadcasting";
        if (mWritableWithRsp)
            props += " write_req";
        if (mWritableWitoutRsp)
            props += " write_cmd";
        if (mWritableSigned)
            props += " write_auth";
        if (mWritableReliable)
            props += " write_rel";
        if (mReadable)
            props += " readable";
        if (props.equals(""))
            log("no properties");
        else {
            log(props);
        }
        log("------------8<------------ GattCharacteristic dump end   ------------8<------------");
    } catch (Exception e) {
        Log.e(TAG, "dump exception " + e);
    }
}
#end_block

#method_before
private void setNotifying(boolean notify) {
    log("setNotifying " + notify);
    mNotifying = notify;
    if (mNotifying != notify) {
        if (mCb != null)
            mCb.onPropertyChanged(this, "Notify", notify ? "true" : "false");
    }
}
#method_after
private void setNotifying(boolean notify) {
    log("setNotifying " + notify);
    mNotifying = notify;
    if (mNotifying != notify) {
        if (mCb != null) {
            mCb.onPropertyChanged(this, "Notify", notify ? "true" : "false");
        }
    }
}
#end_block

#method_before
private void setIndicating(boolean indicate) {
    log("setIndicating " + indicate);
    if (mIndicating != indicate) {
        mIndicating = indicate;
        if (mCb != null)
            mCb.onPropertyChanged(this, "Indicate", indicate ? "true" : "false");
    }
}
#method_after
private void setIndicating(boolean indicate) {
    log("setIndicating " + indicate);
    if (mIndicating != indicate) {
        mIndicating = indicate;
        if (mCb != null) {
            mCb.onPropertyChanged(this, "Indicate", indicate ? "true" : "false");
        }
    }
}
#end_block

#method_before
private void setBroadcasting(boolean broadcast) {
    log("setBroadcasting " + broadcast);
    if (mBroadcasting != broadcast) {
        mBroadcasting = broadcast;
        if (mCb != null)
            mCb.onPropertyChanged(this, "Broadcast", broadcast ? "true" : "false");
    }
}
#method_after
private void setBroadcasting(boolean broadcast) {
    log("setBroadcasting " + broadcast);
    if (mBroadcasting != broadcast) {
        mBroadcasting = broadcast;
        if (mCb != null) {
            mCb.onPropertyChanged(this, "Broadcast", broadcast ? "true" : "false");
        }
    }
}
#end_block

#method_before
private void notifyValueChanged(byte[] value) {
    log("value has changed !");
    if (mCb != null)
        mCb.onValueChanged(this, value);
}
#method_after
private void notifyValueChanged(byte[] value) {
    log("value has changed !");
    if (mCb != null) {
        mCb.onValueChanged(this, value);
    }
}
#end_block

#method_before
private void notifyWriteComplete(byte status) {
    if (mCb != null)
        mCb.onWriteComplete(this, status);
}
#method_after
private void notifyWriteComplete(byte status) {
    if (mCb != null) {
        mCb.onWriteComplete(this, status);
    }
}
#end_block

#method_before
private void notifyReadComplete(byte status, byte[] value) {
    if (mCb != null)
        mCb.onReadComplete(this, status, value);
}
#method_after
private void notifyReadComplete(byte status, byte[] value) {
    if (mCb != null) {
        mCb.onReadComplete(this, status, value);
    }
}
#end_block

#method_before
private void parseProperties() {
    try {
        if (mProperties != null) {
            /*
                       for (int i = 0;i< mProperties.length;i++) {
                       log("characteristic prop("+i+"):"+mProperties[i]);
                       }
                     */
            for (int j = 0; j < mProperties.length; j++) {
                /*log("characteristic props:"+mProperties[j]); */
                if (mProperties[j].equals("Name")) {
                    j++;
                } else if (mProperties[j].equals("Description")) {
                    j++;
                } else if (mProperties[j].equals("Broadcast")) {
                    mBroadcasting = mProperties[++j].equals("true");
                } else if (mProperties[j].equals("Indicate")) {
                    mIndicating = mProperties[++j].equals("true");
                } else if (mProperties[j].equals("Notify")) {
                    mNotifying = mProperties[++j].equals("true");
                } else if (mProperties[j].equals("Readable")) {
                    mReadable = mProperties[++j].equals("true");
                } else if (mProperties[j].equals("WriteMethods")) {
                    int method_count = Integer.valueOf(mProperties[++j]);
                    for (int i = 0; i < method_count; i++) {
                        ++j;
                        if (mProperties[j].equals("Write"))
                            mWritableWithRsp = true;
                        else if (mProperties[j].equals("WriteWithoutResponse"))
                            mWritableWitoutRsp = true;
                        else if (mProperties[j].equals("AuthenticatedSignedWrite"))
                            mWritableSigned = true;
                        else if (mProperties[j].equals("ReliableWrite"))
                            mWritableReliable = true;
                    }
                } else if (mProperties[j].equals("UUID")) {
                    mUuid = UUID.fromString(mProperties[++j]);
                } else if (mProperties[j].equals("Value")) {
                    j++;
                } else {
                    Log.e(TAG, "parseProperties Invalid property:\"" + mProperties[j] + "\" (" + mPath + ")");
                    break;
                }
            }
        } else {
            Log.e(TAG, "mProperties = NULL !");
        }
    } catch (Exception e) {
        Log.e(TAG, "parseProperties exception:" + e);
    }
}
#method_after
private void parseProperties() {
    try {
        if (mProperties != null) {
            /*
                       for (int i = 0;i< mProperties.length;i++) {
                       log("characteristic prop("+i+"):"+mProperties[i]);
                       }
                     */
            for (int j = 0; j < mProperties.length; j++) {
                /*log("characteristic props:"+mProperties[j]); */
                if (mProperties[j].equals("Name")) {
                    j++;
                } else if (mProperties[j].equals("Description")) {
                    j++;
                } else if (mProperties[j].equals("Broadcast")) {
                    mBroadcasting = mProperties[++j].equals("true");
                } else if (mProperties[j].equals("Indicate")) {
                    mIndicating = mProperties[++j].equals("true");
                } else if (mProperties[j].equals("Notify")) {
                    mNotifying = mProperties[++j].equals("true");
                } else if (mProperties[j].equals("Readable")) {
                    mReadable = mProperties[++j].equals("true");
                } else if (mProperties[j].equals("WriteMethods")) {
                    int method_count = Integer.valueOf(mProperties[++j]);
                    for (int i = 0; i < method_count; i++) {
                        ++j;
                        if (mProperties[j].equals("Write")) {
                            mWritableWithRsp = true;
                        } else if (mProperties[j].equals("WriteWithoutResponse")) {
                            mWritableWitoutRsp = true;
                        } else if (mProperties[j].equals("AuthenticatedSignedWrite")) {
                            mWritableSigned = true;
                        } else if (mProperties[j].equals("ReliableWrite")) {
                            mWritableReliable = true;
                        }
                    }
                } else if (mProperties[j].equals("UUID")) {
                    mUuid = UUID.fromString(mProperties[++j]);
                } else if (mProperties[j].equals("Value")) {
                    j++;
                } else {
                    Log.e(TAG, "parseProperties Invalid property:\"" + mProperties[j] + "\" (" + mPath + ")");
                    break;
                }
            }
        } else {
            Log.e(TAG, "mProperties = NULL !");
        }
    } catch (Exception e) {
        Log.e(TAG, "parseProperties exception:" + e);
    }
}
#end_block

#method_before
public synchronized void disconnect() throws GattClientException {
    if (mDevice == null)
        throw new GattClientException("BluetoothGattClientService not available");
    try {
        mService.Disconnect(mDevice, mId);
    } catch (Exception e) {
        Log.e(TAG, "disconnect exception " + e);
        throw new GattClientException(e);
    }
}
#method_after
public synchronized void disconnect() throws GattClientException {
    if (mDevice == null) {
        throw new GattClientException("BluetoothGattClientService not available");
    }
    try {
        mService.Disconnect(mDevice, mId);
    } catch (Exception e) {
        Log.e(TAG, "disconnect exception " + e);
        throw new GattClientException(e);
    }
}
#end_block

#method_before
public GattService discoverPrimaryService(UUID uuid) throws GattClientException {
    if (mService == null) {
        throw new GattClientException("BluetoothGattClientService not available");
    }
    if (mDevice == null) {
        throw new GattClientException("Invalid device");
    }
    checkDeviceConnected();
    if (mPrimaries == null)
        doPrimaryServicesDiscovery();
    if (mPrimaries.size() > 0) {
        for (int i = 0; i < mPrimaries.size(); i++) {
            GattService svc = mPrimaries.get(i);
            if (svc != null && svc.getUUID().equals(uuid))
                return svc;
        }
    }
    return null;
}
#method_after
public GattService discoverPrimaryService(UUID uuid) throws GattClientException {
    if (mService == null) {
        throw new GattClientException("BluetoothGattClientService not available");
    }
    if (mDevice == null) {
        throw new GattClientException("Invalid device");
    }
    checkDeviceConnected();
    if (mPrimaries == null) {
        doPrimaryServicesDiscovery();
    }
    if (mPrimaries.size() > 0) {
        for (int i = 0; i < mPrimaries.size(); i++) {
            GattService svc = mPrimaries.get(i);
            if (svc != null && svc.getUUID().equals(uuid)) {
                return svc;
            }
        }
    }
    return null;
}
#end_block

#method_before
public ArrayList<GattService> discoverAllPrimaryServices() throws GattClientException {
    if (mService == null) {
        throw new GattClientException("BluetoothGattClientService not available");
    }
    if (mDevice == null) {
        throw new GattClientException("Invalid device");
    }
    checkDeviceConnected();
    if (mPrimaries == null)
        doPrimaryServicesDiscovery();
    return mPrimaries;
}
#method_after
public ArrayList<GattService> discoverAllPrimaryServices() throws GattClientException {
    if (mService == null) {
        throw new GattClientException("BluetoothGattClientService not available");
    }
    if (mDevice == null) {
        throw new GattClientException("Invalid device");
    }
    checkDeviceConnected();
    if (mPrimaries == null) {
        doPrimaryServicesDiscovery();
    }
    return mPrimaries;
}
#end_block

#method_before
/**
 * Discover all characteristics, between the handle provided
 *
 * @param servicePath
 *            The service which holds the characteristics.
 * @return ArrayList<GattCaharacteristic> List of characteristics available
 *         on the remote GATT Server
 * @throws GattclientException
 *             on error, for example Bluetooth not connected.
 */
private ArrayList<GattCharacteristic> discoverAllCharacteristics(String svc) throws GattClientException {
    if (mService == null) {
        throw new GattClientException("BluetoothGattClientService not available");
    }
    if (mDevice == null) {
        throw new GattClientException("Invalid device");
    }
    checkDeviceConnected();
    ArrayList<GattCharacteristic> chars = new ArrayList<GattCharacteristic>();
    String[] services = null;
    String[] charslist = null;
    GattCharacteristic characteristic = null;
    try {
        log("Trying to get characteristics");
        charslist = mService.getCharacteristicList(mDevice, svc);
    } catch (Exception e) {
        Log.e(TAG, "getCharacteristicList exception:" + e);
    }
    if (charslist != null) {
        for (int i = 0; i < charslist.length; i++) {
            log("char:" + charslist[i]);
            try {
                characteristic = getChar(charslist[i]);
                if (characteristic == null) {
                    log("char is new. Allocating new object");
                    characteristic = new GattCharacteristic(this, null, charslist[i]);
                    addChar(charslist[i], characteristic);
                } else {
                    log("char is already cached. Using cached");
                }
            } catch (Exception e) {
                Log.e(TAG, "GattCharacteristic exception " + e);
            }
            if (characteristic != null)
                chars.add(characteristic);
        }
    }
    return chars;
}
#method_after
/**
 * Discover all characteristics, between the handle provided
 *
 * @param servicePath
 *            The service which holds the characteristics.
 * @return ArrayList<GattCaharacteristic> List of characteristics available
 *         on the remote GATT Server
 * @throws GattclientException
 *             on error, for example Bluetooth not connected.
 */
private ArrayList<GattCharacteristic> discoverAllCharacteristics(String svc) throws GattClientException {
    if (mService == null) {
        throw new GattClientException("BluetoothGattClientService not available");
    }
    if (mDevice == null) {
        throw new GattClientException("Invalid device");
    }
    checkDeviceConnected();
    ArrayList<GattCharacteristic> chars = new ArrayList<GattCharacteristic>();
    String[] services = null;
    String[] charslist = null;
    GattCharacteristic characteristic = null;
    try {
        log("Trying to get characteristics");
        charslist = mService.getCharacteristicList(mDevice, svc);
    } catch (Exception e) {
        Log.e(TAG, "getCharacteristicList exception:" + e);
    }
    if (charslist != null) {
        for (int i = 0; i < charslist.length; i++) {
            log("char:" + charslist[i]);
            try {
                characteristic = getChar(charslist[i]);
                if (characteristic == null) {
                    log("char is new. Allocating new object");
                    characteristic = new GattCharacteristic(this, null, charslist[i]);
                    addChar(charslist[i], characteristic);
                } else {
                    log("char is already cached. Using cached");
                }
            } catch (Exception e) {
                Log.e(TAG, "GattCharacteristic exception " + e);
            }
            if (characteristic != null) {
                chars.add(characteristic);
            }
        }
    }
    return chars;
}
#end_block

#method_before
private synchronized void checkDeviceConnected() throws GattClientException {
    if (mService == null)
        throw new GattClientException("Could not connect to Gatt Client Service");
    try {
        if (mService.isConnected(mDevice) == false)
            throw new GattClientException("device " + mDevice.toString() + " is not connected");
    } catch (Exception e) {
        throw new GattClientException("checkDeviceConnected() exception:" + e);
    }
}
#method_after
private synchronized void checkDeviceConnected() throws GattClientException {
    if (mService == null) {
        throw new GattClientException("Could not connect to Gatt Client Service");
    }
    try {
        if (mService.isConnected(mDevice) == false) {
            throw new GattClientException("device " + mDevice.toString() + " is not connected");
        }
    } catch (Exception e) {
        throw new GattClientException("checkDeviceConnected() exception:" + e);
    }
}
#end_block

#method_before
public synchronized boolean sendReply(int type) throws IOException {
    ByteArrayOutputStream out = new ByteArrayOutputStream();
    int bytesReceived;
    long id = mListener.getConnectionId();
    if (id == -1) {
        replyHeader.mConnectionID = null;
    } else {
        replyHeader.mConnectionID = ObexHelper.convertToByteArray(id);
    }
    byte[] headerArray = ObexHelper.createHeader(replyHeader, true);
    int bodyLength = -1;
    int orginalBodyLength = -1;
    if (mPrivateOutput != null) {
        bodyLength = mPrivateOutput.size();
        orginalBodyLength = bodyLength;
    }
    if ((ObexHelper.BASE_PACKET_LENGTH + headerArray.length) > mMaxPacketLength) {
        int end = 0;
        int start = 0;
        while (end != headerArray.length) {
            end = ObexHelper.findHeaderEnd(headerArray, start, mMaxPacketLength - ObexHelper.BASE_PACKET_LENGTH);
            if (end == -1) {
                mClosed = true;
                if (mPrivateInput != null) {
                    mPrivateInput.close();
                }
                if (mPrivateOutput != null) {
                    mPrivateOutput.close();
                }
                mParent.sendResponse(ResponseCodes.OBEX_HTTP_INTERNAL_ERROR, null);
                throw new IOException("OBEX Packet exceeds max packet size");
            }
            byte[] sendHeader = new byte[end - start];
            System.arraycopy(headerArray, start, sendHeader, 0, sendHeader.length);
            mParent.sendResponse(type, sendHeader);
            start = end;
        }
        if (bodyLength > 0) {
            return true;
        } else {
            return false;
        }
    } else {
        out.write(headerArray);
    }
    // last packet; so set finalBitSet to true.
    if (mGetOperation && type == ResponseCodes.OBEX_HTTP_OK) {
        finalBitSet = true;
    }
    if ((finalBitSet) || (headerArray.length < (mMaxPacketLength - 20))) {
        if (bodyLength > 0) {
            /*
                 * Determine if I can send the whole body or just part of
                 * the body.  Remember that there is the 3 bytes for the
                 * response message and 3 bytes for the header ID and length
                 */
            if (bodyLength > (mMaxPacketLength - headerArray.length - 6)) {
                bodyLength = mMaxPacketLength - headerArray.length - 6;
            }
            if (SystemProperties.BLUETI_ENHANCEMENT) {
                /*
                         * Since this is a put request if the final bit is set or
                         * the output stream is closed we need to send the 0x49
                         * (End of Body) otherwise, we need to send 0x48 (Body)
                         */
                if ((finalBitSet) || (mPrivateOutput.isClosed())) {
                    out.write(0x49);
                } else {
                    out.write(0x48);
                }
                bodyLength += 3;
                out.write((byte) (bodyLength >> 8));
                out.write((byte) bodyLength);
                mPrivateOutput.writeToOutputStream((bodyLength - 3), out);
            } else {
                byte[] body = mPrivateOutput.readBytes(bodyLength);
                /*
                         * Since this is a put request if the final bit is set or
                         * the output stream is closed we need to send the 0x49
                         * (End of Body) otherwise, we need to send 0x48 (Body)
                         */
                if ((finalBitSet) || (mPrivateOutput.isClosed())) {
                    out.write(0x49);
                } else {
                    out.write(0x48);
                }
                bodyLength += 3;
                out.write((byte) (bodyLength >> 8));
                out.write((byte) bodyLength);
                out.write(body);
            }
        }
    }
    if ((finalBitSet) && (type == ResponseCodes.OBEX_HTTP_OK) && (orginalBodyLength <= 0)) {
        out.write(0x49);
        orginalBodyLength = 3;
        out.write((byte) (orginalBodyLength >> 8));
        out.write((byte) orginalBodyLength);
    }
    mResponseSize = 3;
    mParent.sendResponse(type, out.toByteArray());
    if (type == ResponseCodes.OBEX_HTTP_CONTINUE) {
        int headerID = mInput.read();
        int length = mInput.read();
        length = (length << 8) + mInput.read();
        if ((headerID != ObexHelper.OBEX_OPCODE_PUT) && (headerID != ObexHelper.OBEX_OPCODE_PUT_FINAL) && (headerID != ObexHelper.OBEX_OPCODE_GET) && (headerID != ObexHelper.OBEX_OPCODE_GET_FINAL)) {
            if (length > 3) {
                if (SystemProperties.BLUETI_ENHANCEMENT) {
                    /*
                        * Discard the rest of the headers in this OBEX message, the length we've calculated
                        * includes the 3 bytes we have already read (1 for headerID + 2 for the length)
                        */
                    mInput.skip(length - 3);
                } else {
                    byte[] temp = new byte[length - 3];
                    // First three bytes already read, compensating for this
                    bytesReceived = mInput.read(temp);
                    while (bytesReceived != temp.length) {
                        bytesReceived += mInput.read(temp, bytesReceived, temp.length - bytesReceived);
                    }
                }
            }
            /*
                 * Determine if an ABORT was sent as the reply
                 */
            if (headerID == ObexHelper.OBEX_OPCODE_ABORT) {
                mParent.sendResponse(ResponseCodes.OBEX_HTTP_OK, null);
                mClosed = true;
                isAborted = true;
                mExceptionString = "Abort Received";
                throw new IOException("Abort Received");
            } else {
                mParent.sendResponse(ResponseCodes.OBEX_HTTP_BAD_REQUEST, null);
                mClosed = true;
                mExceptionString = "Bad Request Received";
                throw new IOException("Bad Request Received");
            }
        } else {
            if ((headerID == ObexHelper.OBEX_OPCODE_PUT_FINAL)) {
                finalBitSet = true;
            } else if (headerID == ObexHelper.OBEX_OPCODE_GET_FINAL) {
                mRequestFinished = true;
            }
            /*
                 * Determine if the packet length is larger then this device can receive
                 */
            if (length > ObexHelper.MAX_PACKET_SIZE_INT) {
                mParent.sendResponse(ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE, null);
                throw new IOException("Packet received was too large");
            }
            /*
                 * Determine if any headers were sent in the initial request
                 */
            if (length > 3) {
                byte[] data = new byte[length - 3];
                bytesReceived = mInput.read(data);
                while (bytesReceived != data.length) {
                    bytesReceived += mInput.read(data, bytesReceived, data.length - bytesReceived);
                }
                byte[] body = ObexHelper.updateHeaderSet(requestHeader, data);
                if (body != null) {
                    mHasBody = true;
                }
                if (mListener.getConnectionId() != -1 && requestHeader.mConnectionID != null) {
                    mListener.setConnectionId(ObexHelper.convertToLong(requestHeader.mConnectionID));
                } else {
                    mListener.setConnectionId(1);
                }
                if (requestHeader.mAuthResp != null) {
                    if (!mParent.handleAuthResp(requestHeader.mAuthResp)) {
                        mExceptionString = "Authentication Failed";
                        mParent.sendResponse(ResponseCodes.OBEX_HTTP_UNAUTHORIZED, null);
                        mClosed = true;
                        requestHeader.mAuthResp = null;
                        return false;
                    }
                    requestHeader.mAuthResp = null;
                }
                if (requestHeader.mAuthChall != null) {
                    mParent.handleAuthChall(requestHeader);
                    // send the auhtResp to the client
                    replyHeader.mAuthResp = new byte[requestHeader.mAuthResp.length];
                    System.arraycopy(requestHeader.mAuthResp, 0, replyHeader.mAuthResp, 0, replyHeader.mAuthResp.length);
                    requestHeader.mAuthResp = null;
                    requestHeader.mAuthChall = null;
                }
                if (body != null) {
                    mPrivateInput.writeBytes(body, 1);
                }
            }
        }
        return true;
    } else {
        return false;
    }
}
#method_after
public synchronized boolean sendReply(int type) throws IOException {
    ByteArrayOutputStream out = new ByteArrayOutputStream();
    int bytesReceived;
    long id = mListener.getConnectionId();
    if (id == -1) {
        replyHeader.mConnectionID = null;
    } else {
        replyHeader.mConnectionID = ObexHelper.convertToByteArray(id);
    }
    byte[] headerArray = ObexHelper.createHeader(replyHeader, true);
    int bodyLength = -1;
    int orginalBodyLength = -1;
    if (mPrivateOutput != null) {
        bodyLength = mPrivateOutput.size();
        orginalBodyLength = bodyLength;
    }
    if ((ObexHelper.BASE_PACKET_LENGTH + headerArray.length) > mMaxPacketLength) {
        int end = 0;
        int start = 0;
        while (end != headerArray.length) {
            end = ObexHelper.findHeaderEnd(headerArray, start, mMaxPacketLength - ObexHelper.BASE_PACKET_LENGTH);
            if (end == -1) {
                mClosed = true;
                if (mPrivateInput != null) {
                    mPrivateInput.close();
                }
                if (mPrivateOutput != null) {
                    mPrivateOutput.close();
                }
                mParent.sendResponse(ResponseCodes.OBEX_HTTP_INTERNAL_ERROR, null);
                throw new IOException("OBEX Packet exceeds max packet size");
            }
            byte[] sendHeader = new byte[end - start];
            System.arraycopy(headerArray, start, sendHeader, 0, sendHeader.length);
            mParent.sendResponse(type, sendHeader);
            start = end;
        }
        if (bodyLength > 0) {
            return true;
        } else {
            return false;
        }
    } else {
        out.write(headerArray);
    }
    // last packet; so set finalBitSet to true.
    if (mGetOperation && type == ResponseCodes.OBEX_HTTP_OK) {
        finalBitSet = true;
    }
    if ((finalBitSet) || (headerArray.length < (mMaxPacketLength - 20))) {
        if (bodyLength > 0) {
            /*
                 * Determine if I can send the whole body or just part of
                 * the body.  Remember that there is the 3 bytes for the
                 * response message and 3 bytes for the header ID and length
                 */
            if (bodyLength > (mMaxPacketLength - headerArray.length - 6)) {
                bodyLength = mMaxPacketLength - headerArray.length - 6;
            }
            if (SystemProperties.BLUETI_ENHANCEMENT) {
                if ((finalBitSet) || (mPrivateOutput.isClosed())) {
                    out.write(0x49);
                } else {
                    out.write(0x48);
                }
                bodyLength += 3;
                out.write((byte) (bodyLength >> 8));
                out.write((byte) bodyLength);
                mPrivateOutput.writeToOutputStream((bodyLength - 3), out);
            } else {
                byte[] body = mPrivateOutput.readBytes(bodyLength);
                /*
                     * Since this is a put request if the final bit is set or
                     * the output stream is closed we need to send the 0x49
                     * (End of Body) otherwise, we need to send 0x48 (Body)
                     */
                if ((finalBitSet) || (mPrivateOutput.isClosed())) {
                    out.write(0x49);
                } else {
                    out.write(0x48);
                }
                bodyLength += 3;
                out.write((byte) (bodyLength >> 8));
                out.write((byte) bodyLength);
                out.write(body);
            }
        }
    }
    if ((finalBitSet) && (type == ResponseCodes.OBEX_HTTP_OK) && (orginalBodyLength <= 0)) {
        out.write(0x49);
        orginalBodyLength = 3;
        out.write((byte) (orginalBodyLength >> 8));
        out.write((byte) orginalBodyLength);
    }
    mResponseSize = 3;
    mParent.sendResponse(type, out.toByteArray());
    if (type == ResponseCodes.OBEX_HTTP_CONTINUE) {
        int headerID = mInput.read();
        int length = mInput.read();
        length = (length << 8) + mInput.read();
        if ((headerID != ObexHelper.OBEX_OPCODE_PUT) && (headerID != ObexHelper.OBEX_OPCODE_PUT_FINAL) && (headerID != ObexHelper.OBEX_OPCODE_GET) && (headerID != ObexHelper.OBEX_OPCODE_GET_FINAL)) {
            if (length > 3) {
                if (SystemProperties.BLUETI_ENHANCEMENT) {
                    /*
                        * Discard the rest of the headers in this OBEX message, the length we've calculated
                        * includes the 3 bytes we have already read (1 for headerID + 2 for the length)
                        */
                    mInput.skip(length - 3);
                } else {
                    byte[] temp = new byte[length - 3];
                    // First three bytes already read, compensating for this
                    bytesReceived = mInput.read(temp);
                    while (bytesReceived != temp.length) {
                        bytesReceived += mInput.read(temp, bytesReceived, temp.length - bytesReceived);
                    }
                }
            }
            /*
                 * Determine if an ABORT was sent as the reply
                 */
            if (headerID == ObexHelper.OBEX_OPCODE_ABORT) {
                mParent.sendResponse(ResponseCodes.OBEX_HTTP_OK, null);
                mClosed = true;
                isAborted = true;
                mExceptionString = "Abort Received";
                throw new IOException("Abort Received");
            } else {
                mParent.sendResponse(ResponseCodes.OBEX_HTTP_BAD_REQUEST, null);
                mClosed = true;
                mExceptionString = "Bad Request Received";
                throw new IOException("Bad Request Received");
            }
        } else {
            if ((headerID == ObexHelper.OBEX_OPCODE_PUT_FINAL)) {
                finalBitSet = true;
            } else if (headerID == ObexHelper.OBEX_OPCODE_GET_FINAL) {
                mRequestFinished = true;
            }
            /*
                 * Determine if the packet length is larger then this device can receive
                 */
            if (length > ObexHelper.MAX_PACKET_SIZE_INT) {
                mParent.sendResponse(ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE, null);
                throw new IOException("Packet received was too large");
            }
            /*
                 * Determine if any headers were sent in the initial request
                 */
            if (length > 3) {
                byte[] data = new byte[length - 3];
                bytesReceived = mInput.read(data);
                while (bytesReceived != data.length) {
                    bytesReceived += mInput.read(data, bytesReceived, data.length - bytesReceived);
                }
                byte[] body = ObexHelper.updateHeaderSet(requestHeader, data);
                if (body != null) {
                    mHasBody = true;
                }
                if (mListener.getConnectionId() != -1 && requestHeader.mConnectionID != null) {
                    mListener.setConnectionId(ObexHelper.convertToLong(requestHeader.mConnectionID));
                } else {
                    mListener.setConnectionId(1);
                }
                if (requestHeader.mAuthResp != null) {
                    if (!mParent.handleAuthResp(requestHeader.mAuthResp)) {
                        mExceptionString = "Authentication Failed";
                        mParent.sendResponse(ResponseCodes.OBEX_HTTP_UNAUTHORIZED, null);
                        mClosed = true;
                        requestHeader.mAuthResp = null;
                        return false;
                    }
                    requestHeader.mAuthResp = null;
                }
                if (requestHeader.mAuthChall != null) {
                    mParent.handleAuthChall(requestHeader);
                    // send the auhtResp to the client
                    replyHeader.mAuthResp = new byte[requestHeader.mAuthResp.length];
                    System.arraycopy(requestHeader.mAuthResp, 0, replyHeader.mAuthResp, 0, replyHeader.mAuthResp.length);
                    requestHeader.mAuthResp = null;
                    requestHeader.mAuthChall = null;
                }
                if (body != null) {
                    mPrivateInput.writeBytes(body, 1);
                }
            }
        }
        return true;
    } else {
        return false;
    }
}
#end_block

#method_before
private boolean sendRequest(int opCode) throws IOException {
    boolean returnValue = false;
    ByteArrayOutputStream out = new ByteArrayOutputStream();
    int bodyLength = -1;
    byte[] headerArray = ObexHelper.createHeader(mRequestHeader, true);
    if (mPrivateOutput != null) {
        bodyLength = mPrivateOutput.size();
    }
    /*
         * Determine if there is space to add a body request.  At present
         * this method checks to see if there is room for at least a 17
         * byte body header.  This number needs to be at least 6 so that
         * there is room for the header ID and length and the reply ID and
         * length, but it is a waste of resources if we can't send much of
         * the body.
         */
    if ((ObexHelper.BASE_PACKET_LENGTH + headerArray.length) > mMaxPacketSize) {
        int end = 0;
        int start = 0;
        while (end != headerArray.length) {
            // split the headerArray
            end = ObexHelper.findHeaderEnd(headerArray, start, mMaxPacketSize - ObexHelper.BASE_PACKET_LENGTH);
            // can not split
            if (end == -1) {
                mOperationDone = true;
                abort();
                mExceptionMessage = "Header larger then can be sent in a packet";
                mInputOpen = false;
                if (mPrivateInput != null) {
                    mPrivateInput.close();
                }
                if (mPrivateOutput != null) {
                    mPrivateOutput.close();
                }
                throw new IOException("OBEX Packet exceeds max packet size");
            }
            byte[] sendHeader = new byte[end - start];
            System.arraycopy(headerArray, start, sendHeader, 0, sendHeader.length);
            if (!mParent.sendRequest(opCode, sendHeader, mReplyHeader, mPrivateInput)) {
                return false;
            }
            if (mReplyHeader.responseCode != ResponseCodes.OBEX_HTTP_CONTINUE) {
                return false;
            }
            start = end;
        }
        if (bodyLength > 0) {
            return true;
        } else {
            return false;
        }
    } else {
        out.write(headerArray);
    }
    if (bodyLength > 0) {
        /*
             * Determine if we can send the whole body or just part of
             * the body.  Remember that there is the 3 bytes for the
             * response message and 3 bytes for the header ID and length
             */
        if (bodyLength > (mMaxPacketSize - headerArray.length - 6)) {
            returnValue = true;
            bodyLength = mMaxPacketSize - headerArray.length - 6;
        }
        if (SystemProperties.BLUETI_ENHANCEMENT) {
            int orgBodyLength = bodyLength;
            /*
             * Since this is a put request if the final bit is set or
             * the output stream is closed we need to send the 0x49
             * (End of Body) otherwise, we need to send 0x48 (Body)
             */
            if ((mPrivateOutput.isClosed()) && (!returnValue) && (!mEndOfBodySent) && ((opCode & 0x80) != 0)) {
                out.write(0x49);
                mEndOfBodySent = true;
            } else {
                out.write(0x48);
            }
            bodyLength += 3;
            out.write((byte) (bodyLength >> 8));
            out.write((byte) bodyLength);
            mPrivateOutput.writeToOutputStream(orgBodyLength, out);
        } else {
            byte[] body = mPrivateOutput.readBytes(bodyLength);
            /*
              * Since this is a put request if the final bit is set or
              * the output stream is closed we need to send the 0x49
              * (End of Body) otherwise, we need to send 0x48 (Body)
              */
            if ((mPrivateOutput.isClosed()) && (!returnValue) && (!mEndOfBodySent) && ((opCode & 0x80) != 0)) {
                out.write(0x49);
                mEndOfBodySent = true;
            } else {
                out.write(0x48);
            }
            bodyLength += 3;
            out.write((byte) (bodyLength >> 8));
            out.write((byte) bodyLength);
            if (body != null) {
                out.write(body);
            }
        }
    }
    if (mPrivateOutputOpen && bodyLength <= 0 && !mEndOfBodySent) {
        // only 0x82 or 0x83 can send 0x49
        if ((opCode & 0x80) == 0) {
            out.write(0x48);
        } else {
            out.write(0x49);
            mEndOfBodySent = true;
        }
        bodyLength = 3;
        out.write((byte) (bodyLength >> 8));
        out.write((byte) bodyLength);
    }
    if (out.size() == 0) {
        if (!mParent.sendRequest(opCode, null, mReplyHeader, mPrivateInput)) {
            return false;
        }
        return returnValue;
    }
    if ((out.size() > 0) && (!mParent.sendRequest(opCode, out.toByteArray(), mReplyHeader, mPrivateInput))) {
        return false;
    }
    // send 0x49 with empty body
    if ((mPrivateOutput != null) && (mPrivateOutput.size() > 0))
        returnValue = true;
    return returnValue;
}
#method_after
private boolean sendRequest(int opCode) throws IOException {
    boolean returnValue = false;
    ByteArrayOutputStream out = new ByteArrayOutputStream();
    int bodyLength = -1;
    byte[] headerArray = ObexHelper.createHeader(mRequestHeader, true);
    if (mPrivateOutput != null) {
        bodyLength = mPrivateOutput.size();
    }
    /*
         * Determine if there is space to add a body request.  At present
         * this method checks to see if there is room for at least a 17
         * byte body header.  This number needs to be at least 6 so that
         * there is room for the header ID and length and the reply ID and
         * length, but it is a waste of resources if we can't send much of
         * the body.
         */
    if ((ObexHelper.BASE_PACKET_LENGTH + headerArray.length) > mMaxPacketSize) {
        int end = 0;
        int start = 0;
        while (end != headerArray.length) {
            // split the headerArray
            end = ObexHelper.findHeaderEnd(headerArray, start, mMaxPacketSize - ObexHelper.BASE_PACKET_LENGTH);
            // can not split
            if (end == -1) {
                mOperationDone = true;
                abort();
                mExceptionMessage = "Header larger then can be sent in a packet";
                mInputOpen = false;
                if (mPrivateInput != null) {
                    mPrivateInput.close();
                }
                if (mPrivateOutput != null) {
                    mPrivateOutput.close();
                }
                throw new IOException("OBEX Packet exceeds max packet size");
            }
            byte[] sendHeader = new byte[end - start];
            System.arraycopy(headerArray, start, sendHeader, 0, sendHeader.length);
            if (!mParent.sendRequest(opCode, sendHeader, mReplyHeader, mPrivateInput)) {
                return false;
            }
            if (mReplyHeader.responseCode != ResponseCodes.OBEX_HTTP_CONTINUE) {
                return false;
            }
            start = end;
        }
        if (bodyLength > 0) {
            return true;
        } else {
            return false;
        }
    } else {
        out.write(headerArray);
    }
    if (bodyLength > 0) {
        /*
             * Determine if we can send the whole body or just part of
             * the body.  Remember that there is the 3 bytes for the
             * response message and 3 bytes for the header ID and length
             */
        if (bodyLength > (mMaxPacketSize - headerArray.length - 6)) {
            returnValue = true;
            bodyLength = mMaxPacketSize - headerArray.length - 6;
        }
        if (SystemProperties.BLUETI_ENHANCEMENT) {
            int orgBodyLength = bodyLength;
            if ((mPrivateOutput.isClosed()) && (!returnValue) && (!mEndOfBodySent) && ((opCode & 0x80) != 0)) {
                out.write(0x49);
                mEndOfBodySent = true;
            } else {
                out.write(0x48);
            }
            bodyLength += 3;
            out.write((byte) (bodyLength >> 8));
            out.write((byte) bodyLength);
            mPrivateOutput.writeToOutputStream(orgBodyLength, out);
        } else {
            /* non BLUETI_ENHANCEMENT */
            byte[] body = mPrivateOutput.readBytes(bodyLength);
            /*
                 * Since this is a put request if the final bit is set or
                 * the output stream is closed we need to send the 0x49
                 * (End of Body) otherwise, we need to send 0x48 (Body)
                 */
            if ((mPrivateOutput.isClosed()) && (!returnValue) && (!mEndOfBodySent) && ((opCode & 0x80) != 0)) {
                out.write(0x49);
                mEndOfBodySent = true;
            } else {
                out.write(0x48);
            }
            bodyLength += 3;
            out.write((byte) (bodyLength >> 8));
            out.write((byte) bodyLength);
            if (body != null) {
                out.write(body);
            }
        }
    }
    if (mPrivateOutputOpen && bodyLength <= 0 && !mEndOfBodySent) {
        // only 0x82 or 0x83 can send 0x49
        if ((opCode & 0x80) == 0) {
            out.write(0x48);
        } else {
            out.write(0x49);
            mEndOfBodySent = true;
        }
        bodyLength = 3;
        out.write((byte) (bodyLength >> 8));
        out.write((byte) bodyLength);
    }
    if (out.size() == 0) {
        if (!mParent.sendRequest(opCode, null, mReplyHeader, mPrivateInput)) {
            return false;
        }
        return returnValue;
    }
    if ((out.size() > 0) && (!mParent.sendRequest(opCode, out.toByteArray(), mReplyHeader, mPrivateInput))) {
        return false;
    }
    // send 0x49 with empty body
    if ((mPrivateOutput != null) && (mPrivateOutput.size() > 0))
        returnValue = true;
    return returnValue;
}
#end_block

#method_before
public void noteBluetoothOff() {
    enforceCallingPermission();
    synchronized (mStats) {
        mBluetoothPendingStats = false;
        mStats.noteBluetoothOffLocked();
    }
    if (SystemProperties.BLUETI_ENHANCEMENT)
        mStats.setBtHeadset(null);
}
#method_after
public void noteBluetoothOff() {
    enforceCallingPermission();
    synchronized (mStats) {
        mBluetoothPendingStats = false;
        mStats.noteBluetoothOffLocked();
    }
    if (SystemProperties.BLUETI_ENHANCEMENT) {
        mStats.setBtHeadset(null);
    }
}
#end_block

#method_before
private void onRequestPinCode(String objectPath, int nativeData) {
    String address = checkPairingRequestAndGetAddress(objectPath, nativeData);
    if (address == null)
        return;
    String pendingOutgoingAddress = mBluetoothService.getPendingOutgoingBonding();
    BluetoothClass btClass = new BluetoothClass(mBluetoothService.getRemoteClass(address));
    int btDeviceClass = btClass.getDeviceClass();
    if (address.equals(pendingOutgoingAddress)) {
        // Check if its a dock
        if (mBluetoothService.isBluetoothDock(address)) {
            String pin = mBluetoothService.getDockPin();
            mBluetoothService.setPin(address, BluetoothDevice.convertPinToBytes(pin));
            return;
        }
        // try 0000 once if the device looks dumb
        switch(btDeviceClass) {
            case BluetoothClass.Device.AUDIO_VIDEO_WEARABLE_HEADSET:
            case BluetoothClass.Device.AUDIO_VIDEO_HANDSFREE:
            case BluetoothClass.Device.AUDIO_VIDEO_HEADPHONES:
            case BluetoothClass.Device.AUDIO_VIDEO_PORTABLE_AUDIO:
            case BluetoothClass.Device.AUDIO_VIDEO_HIFI_AUDIO:
                if (mBluetoothService.attemptAutoPair(address))
                    return;
        }
    }
    if (btDeviceClass == BluetoothClass.Device.PERIPHERAL_KEYBOARD || btDeviceClass == BluetoothClass.Device.PERIPHERAL_KEYBOARD_POINTING) {
        // and pair.
        if (mBluetoothService.isFixedPinZerosAutoPairKeyboard(address)) {
            mBluetoothService.setPin(address, BluetoothDevice.convertPinToBytes("0000"));
            return;
        }
        // Generate a variable PIN. This is not truly random but good enough.
        int pin = (int) Math.floor(Math.random() * 10000);
        sendDisplayPinIntent(address, pin);
        return;
    }
    // Acquire wakelock during PIN code request to bring up LCD display
    if (!SystemProperties.BLUETI_ENHANCEMENT) {
        mWakeLock.acquire();
    }
    Intent intent = new Intent(BluetoothDevice.ACTION_PAIRING_REQUEST);
    intent.putExtra(BluetoothDevice.EXTRA_DEVICE, mAdapter.getRemoteDevice(address));
    intent.putExtra(BluetoothDevice.EXTRA_PAIRING_VARIANT, BluetoothDevice.PAIRING_VARIANT_PIN);
    mContext.sendBroadcast(intent, BLUETOOTH_ADMIN_PERM);
    // Release wakelock to allow the LCD to go off after the PIN popup notification.
    if (SystemProperties.BLUETI_ENHANCEMENT) {
        // TI-BLUEZ Fix - bring up LCD display for PIN_CODE_REQUEST_WAKELOCK_TIME
        mWakeLock.acquire(PIN_CODE_REQUEST_WAKELOCK_TIME);
    } else {
        mWakeLock.release();
    }
    return;
}
#method_after
private void onRequestPinCode(String objectPath, int nativeData) {
    String address = checkPairingRequestAndGetAddress(objectPath, nativeData);
    if (address == null)
        return;
    String pendingOutgoingAddress = mBluetoothService.getPendingOutgoingBonding();
    BluetoothClass btClass = new BluetoothClass(mBluetoothService.getRemoteClass(address));
    int btDeviceClass = btClass.getDeviceClass();
    if (address.equals(pendingOutgoingAddress)) {
        // Check if its a dock
        if (mBluetoothService.isBluetoothDock(address)) {
            String pin = mBluetoothService.getDockPin();
            mBluetoothService.setPin(address, BluetoothDevice.convertPinToBytes(pin));
            return;
        }
        // try 0000 once if the device looks dumb
        switch(btDeviceClass) {
            case BluetoothClass.Device.AUDIO_VIDEO_WEARABLE_HEADSET:
            case BluetoothClass.Device.AUDIO_VIDEO_HANDSFREE:
            case BluetoothClass.Device.AUDIO_VIDEO_HEADPHONES:
            case BluetoothClass.Device.AUDIO_VIDEO_PORTABLE_AUDIO:
            case BluetoothClass.Device.AUDIO_VIDEO_HIFI_AUDIO:
                if (mBluetoothService.attemptAutoPair(address))
                    return;
        }
    }
    if (btDeviceClass == BluetoothClass.Device.PERIPHERAL_KEYBOARD || btDeviceClass == BluetoothClass.Device.PERIPHERAL_KEYBOARD_POINTING) {
        // and pair.
        if (mBluetoothService.isFixedPinZerosAutoPairKeyboard(address)) {
            mBluetoothService.setPin(address, BluetoothDevice.convertPinToBytes("0000"));
            return;
        }
        // Generate a variable PIN. This is not truly random but good enough.
        int pin = (int) Math.floor(Math.random() * 10000);
        sendDisplayPinIntent(address, pin);
        return;
    }
    // Acquire wakelock during PIN code request to bring up LCD display
    if (!SystemProperties.BLUETI_ENHANCEMENT) {
        mWakeLock.acquire();
    }
    Intent intent = new Intent(BluetoothDevice.ACTION_PAIRING_REQUEST);
    intent.putExtra(BluetoothDevice.EXTRA_DEVICE, mAdapter.getRemoteDevice(address));
    intent.putExtra(BluetoothDevice.EXTRA_PAIRING_VARIANT, BluetoothDevice.PAIRING_VARIANT_PIN);
    mContext.sendBroadcast(intent, BLUETOOTH_ADMIN_PERM);
    // Release wakelock to allow the LCD to go off after the PIN popup notification.
    if (SystemProperties.BLUETI_ENHANCEMENT) {
        mWakeLock.acquire(PIN_CODE_REQUEST_WAKELOCK_TIME);
    } else {
        mWakeLock.release();
    }
    return;
}
#end_block

#method_before
private void onAgentAuthorize(String objectPath, String deviceUuid, int nativeData) {
    if (!mBluetoothService.isEnabled())
        return;
    String address = mBluetoothService.getAddressFromObjectPath(objectPath);
    if (address == null) {
        Log.e(TAG, "Unable to get device address in onAuthAgentAuthorize");
        return;
    }
    boolean authorized = false;
    ParcelUuid uuid = ParcelUuid.fromString(deviceUuid);
    BluetoothDevice device = mAdapter.getRemoteDevice(address);
    mAuthorizationAgentRequestData.put(address, new Integer(nativeData));
    // remote service
    if (mA2dp != null && (BluetoothUuid.isAudioSource(uuid) || BluetoothUuid.isAvrcpTarget(uuid) || BluetoothUuid.isAdvAudioDist(uuid)) && !isOtherSinkInNonDisconnectedState(address)) {
        authorized = mA2dp.getPriority(device) > BluetoothProfile.PRIORITY_OFF;
        if (authorized && !BluetoothUuid.isAvrcpTarget(uuid)) {
            if (SystemProperties.BLUETI_ENHANCEMENT)
                Log.i(TAG, "First check pass for incoming A2DP connection from " + address);
            else
                Log.i(TAG, "First check pass for incoming A2DP / AVRCP connection from " + address);
            // Some headsets try to connect AVCTP before AVDTP - against the recommendation
            // If AVCTP connection fails, we get stuck in IncomingA2DP state in the state
            // machine.  We don't handle AVCTP signals currently. We only send
            // intents for AVDTP state changes. We need to handle both of them in
            // some cases. For now, just don't move to incoming state in this case.
            mBluetoothService.notifyIncomingA2dpConnection(address, false);
        } else {
            if (SystemProperties.BLUETI_ENHANCEMENT) {
                /* In this case we know we are in AVRCP connect */
                Log.i(TAG, "" + authorized + "Incoming AVRCP connection from " + address);
            } else {
                Log.i(TAG, "" + authorized + "Incoming A2DP / AVRCP connection from " + address);
            }
            mA2dp.allowIncomingConnect(device, authorized);
            mBluetoothService.notifyIncomingA2dpConnection(address, true);
            if (SystemProperties.BLUETI_ENHANCEMENT)
                /* as AVRCP does not have a profile state we handle this here */
                mBluetoothService.notifyIncomingAVRCPConnection(address);
        }
    } else if (BluetoothUuid.isInputDevice(uuid)) {
        // We can have more than 1 input device connected.
        authorized = mBluetoothService.getInputDevicePriority(device) > BluetoothInputDevice.PRIORITY_OFF;
        if (authorized) {
            Log.i(TAG, "First check pass for incoming HID connection from " + address);
            // notify profile state change
            mBluetoothService.notifyIncomingHidConnection(address);
        } else {
            Log.i(TAG, "Rejecting incoming HID connection from " + address);
            mBluetoothService.allowIncomingProfileConnect(device, authorized);
        }
    } else if (BluetoothUuid.isBnep(uuid)) {
        // PAN doesn't go to the state machine, accept or reject from here
        authorized = mBluetoothService.allowIncomingTethering();
        mBluetoothService.allowIncomingProfileConnect(device, authorized);
    } else {
        Log.i(TAG, "Rejecting incoming " + deviceUuid + " connection from " + address);
        mBluetoothService.allowIncomingProfileConnect(device, authorized);
    }
    log("onAgentAuthorize(" + objectPath + ", " + deviceUuid + ") = " + authorized);
}
#method_after
private void onAgentAuthorize(String objectPath, String deviceUuid, int nativeData) {
    if (!mBluetoothService.isEnabled())
        return;
    String address = mBluetoothService.getAddressFromObjectPath(objectPath);
    if (address == null) {
        Log.e(TAG, "Unable to get device address in onAuthAgentAuthorize");
        return;
    }
    boolean authorized = false;
    ParcelUuid uuid = ParcelUuid.fromString(deviceUuid);
    BluetoothDevice device = mAdapter.getRemoteDevice(address);
    mAuthorizationAgentRequestData.put(address, new Integer(nativeData));
    // remote service
    if (mA2dp != null && (BluetoothUuid.isAudioSource(uuid) || BluetoothUuid.isAvrcpTarget(uuid) || BluetoothUuid.isAdvAudioDist(uuid)) && !isOtherSinkInNonDisconnectedState(address)) {
        authorized = mA2dp.getPriority(device) > BluetoothProfile.PRIORITY_OFF;
        if (authorized && !BluetoothUuid.isAvrcpTarget(uuid)) {
            if (SystemProperties.BLUETI_ENHANCEMENT) {
                Log.i(TAG, "First check pass for incoming A2DP connection from " + address);
            } else {
                Log.i(TAG, "First check pass for incoming A2DP / AVRCP connection from " + address);
            }
            // Some headsets try to connect AVCTP before AVDTP - against the recommendation
            // If AVCTP connection fails, we get stuck in IncomingA2DP state in the state
            // machine.  We don't handle AVCTP signals currently. We only send
            // intents for AVDTP state changes. We need to handle both of them in
            // some cases. For now, just don't move to incoming state in this case.
            mBluetoothService.notifyIncomingA2dpConnection(address, false);
        } else {
            if (SystemProperties.BLUETI_ENHANCEMENT) {
                /* In this case we know we are in AVRCP connect */
                Log.i(TAG, "" + authorized + "Incoming AVRCP connection from " + address);
            } else {
                Log.i(TAG, "" + authorized + "Incoming A2DP / AVRCP connection from " + address);
            }
            mA2dp.allowIncomingConnect(device, authorized);
            mBluetoothService.notifyIncomingA2dpConnection(address, true);
            if (SystemProperties.BLUETI_ENHANCEMENT) {
                /* as AVRCP does not have a profile state we handle this here */
                mBluetoothService.notifyIncomingAVRCPConnection(address);
            }
        }
    } else if (BluetoothUuid.isInputDevice(uuid)) {
        // We can have more than 1 input device connected.
        authorized = mBluetoothService.getInputDevicePriority(device) > BluetoothInputDevice.PRIORITY_OFF;
        if (authorized) {
            Log.i(TAG, "First check pass for incoming HID connection from " + address);
            // notify profile state change
            mBluetoothService.notifyIncomingHidConnection(address);
        } else {
            Log.i(TAG, "Rejecting incoming HID connection from " + address);
            mBluetoothService.allowIncomingProfileConnect(device, authorized);
        }
    } else if (BluetoothUuid.isBnep(uuid)) {
        // PAN doesn't go to the state machine, accept or reject from here
        authorized = mBluetoothService.allowIncomingTethering();
        mBluetoothService.allowIncomingProfileConnect(device, authorized);
    } else {
        Log.i(TAG, "Rejecting incoming " + deviceUuid + " connection from " + address);
        mBluetoothService.allowIncomingProfileConnect(device, authorized);
    }
    log("onAgentAuthorize(" + objectPath + ", " + deviceUuid + ") = " + authorized);
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    log("WarmUp process message: " + message.what);
    boolean retValue = HANDLED;
    switch(message.what) {
        case SERVICE_RECORD_LOADED:
            removeMessages(PREPARE_BLUETOOTH_TIMEOUT);
            transitionTo(mHotOff);
            break;
        case PREPARE_BLUETOOTH_TIMEOUT:
            Log.e(TAG, "Bluetooth adapter SDP failed to load");
            shutoffBluetooth();
            transitionTo(mPowerOff);
            broadcastState(BluetoothAdapter.STATE_OFF);
            break;
        // handle this at HotOff state
        case USER_TURN_ON:
        // Once in HotOff state, continue turn bluetooth
        case TURN_ON_CONTINUE:
        // on to the BluetoothOn state
        case AIRPLANE_MODE_ON:
        case AIRPLANE_MODE_OFF:
        case PER_PROCESS_TURN_ON:
        case PER_PROCESS_TURN_OFF:
            deferMessage(message);
            break;
        case SCAN_MODE_CHANGED:
            if (SystemProperties.BLUETI_ENHANCEMENT)
                deferMessage(message);
            else
                return NOT_HANDLED;
            break;
        case USER_TURN_OFF:
            Log.w(TAG, "WarmUp received: " + message.what);
            break;
        default:
            return NOT_HANDLED;
    }
    return retValue;
}
#method_after
@Override
public boolean processMessage(Message message) {
    log("WarmUp process message: " + message.what);
    boolean retValue = HANDLED;
    switch(message.what) {
        case SERVICE_RECORD_LOADED:
            removeMessages(PREPARE_BLUETOOTH_TIMEOUT);
            transitionTo(mHotOff);
            break;
        case PREPARE_BLUETOOTH_TIMEOUT:
            Log.e(TAG, "Bluetooth adapter SDP failed to load");
            shutoffBluetooth();
            transitionTo(mPowerOff);
            broadcastState(BluetoothAdapter.STATE_OFF);
            break;
        // handle this at HotOff state
        case USER_TURN_ON:
        // Once in HotOff state, continue turn bluetooth
        case TURN_ON_CONTINUE:
        // on to the BluetoothOn state
        case AIRPLANE_MODE_ON:
        case AIRPLANE_MODE_OFF:
        case PER_PROCESS_TURN_ON:
        case PER_PROCESS_TURN_OFF:
            deferMessage(message);
            break;
        case SCAN_MODE_CHANGED:
            if (SystemProperties.BLUETI_ENHANCEMENT) {
                deferMessage(message);
            } else {
                return NOT_HANDLED;
            }
            break;
        case USER_TURN_OFF:
            Log.w(TAG, "WarmUp received: " + message.what);
            break;
        default:
            return NOT_HANDLED;
    }
    return retValue;
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    log("HotOff process message: " + message.what);
    boolean retValue = HANDLED;
    switch(message.what) {
        case USER_TURN_ON:
            broadcastState(BluetoothAdapter.STATE_TURNING_ON);
            if ((Boolean) message.obj) {
                persistSwitchSetting(true);
            }
        // $FALL-THROUGH$
        case TURN_ON_CONTINUE:
            mBluetoothService.switchConnectable(true);
            if (SystemProperties.BLUETI_ENHANCEMENT) {
                sendMessageDelayed(SCAN_MODE_CHANGE_TIMEOUT, SCAN_MODE_CHANGE_TIMEOUT_TIME);
            }
            transitionTo(mSwitching);
            break;
        case AIRPLANE_MODE_ON:
        case TURN_COLD:
            shutoffBluetooth();
            transitionTo(mPowerOff);
            broadcastState(BluetoothAdapter.STATE_OFF);
            break;
        case AIRPLANE_MODE_OFF:
            if (getBluetoothPersistedSetting()) {
                broadcastState(BluetoothAdapter.STATE_TURNING_ON);
                transitionTo(mSwitching);
                mBluetoothService.switchConnectable(true);
                if (SystemProperties.BLUETI_ENHANCEMENT)
                    sendMessageDelayed(SCAN_MODE_CHANGE_TIMEOUT, SCAN_MODE_CHANGE_TIMEOUT_TIME);
            }
            break;
        case PER_PROCESS_TURN_ON:
            transitionTo(mPerProcessState);
            // Resend the PER_PROCESS_TURN_ON message so that the callback
            // can be sent through.
            deferMessage(message);
            mBluetoothService.switchConnectable(true);
            if (SystemProperties.BLUETI_ENHANCEMENT) {
                sendMessageDelayed(SCAN_MODE_CHANGE_TIMEOUT, SCAN_MODE_CHANGE_TIMEOUT_TIME);
            }
            break;
        case PER_PROCESS_TURN_OFF:
            perProcessCallback(false, (IBluetoothStateChangeCallback) message.obj);
            break;
        case // ignore
        USER_TURN_OFF:
            break;
        case SCAN_MODE_CHANGED:
            if (SystemProperties.BLUETI_ENHANCEMENT) {
                deferMessage(message);
            } else {
                return NOT_HANDLED;
            }
            break;
        case POWER_STATE_CHANGED:
            if ((Boolean) message.obj) {
                recoverStateMachine(TURN_HOT, null);
            }
            break;
        default:
            return NOT_HANDLED;
    }
    return retValue;
}
#method_after
@Override
public boolean processMessage(Message message) {
    log("HotOff process message: " + message.what);
    boolean retValue = HANDLED;
    switch(message.what) {
        case USER_TURN_ON:
            broadcastState(BluetoothAdapter.STATE_TURNING_ON);
            if ((Boolean) message.obj) {
                persistSwitchSetting(true);
            }
        // $FALL-THROUGH$
        case TURN_ON_CONTINUE:
            mBluetoothService.switchConnectable(true);
            if (SystemProperties.BLUETI_ENHANCEMENT) {
                sendMessageDelayed(SCAN_MODE_CHANGE_TIMEOUT, SCAN_MODE_CHANGE_TIMEOUT_TIME);
            }
            transitionTo(mSwitching);
            break;
        case AIRPLANE_MODE_ON:
        case TURN_COLD:
            shutoffBluetooth();
            transitionTo(mPowerOff);
            broadcastState(BluetoothAdapter.STATE_OFF);
            break;
        case AIRPLANE_MODE_OFF:
            if (getBluetoothPersistedSetting()) {
                broadcastState(BluetoothAdapter.STATE_TURNING_ON);
                transitionTo(mSwitching);
                mBluetoothService.switchConnectable(true);
                if (SystemProperties.BLUETI_ENHANCEMENT) {
                    sendMessageDelayed(SCAN_MODE_CHANGE_TIMEOUT, SCAN_MODE_CHANGE_TIMEOUT_TIME);
                }
            }
            break;
        case PER_PROCESS_TURN_ON:
            transitionTo(mPerProcessState);
            // Resend the PER_PROCESS_TURN_ON message so that the callback
            // can be sent through.
            deferMessage(message);
            mBluetoothService.switchConnectable(true);
            if (SystemProperties.BLUETI_ENHANCEMENT) {
                sendMessageDelayed(SCAN_MODE_CHANGE_TIMEOUT, SCAN_MODE_CHANGE_TIMEOUT_TIME);
            }
            break;
        case PER_PROCESS_TURN_OFF:
            perProcessCallback(false, (IBluetoothStateChangeCallback) message.obj);
            break;
        case // ignore
        USER_TURN_OFF:
            break;
        case SCAN_MODE_CHANGED:
            if (SystemProperties.BLUETI_ENHANCEMENT) {
                deferMessage(message);
            } else {
                return NOT_HANDLED;
            }
            break;
        case POWER_STATE_CHANGED:
            if ((Boolean) message.obj) {
                recoverStateMachine(TURN_HOT, null);
            }
            break;
        default:
            return NOT_HANDLED;
    }
    return retValue;
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    log("Switching process message: " + message.what);
    boolean retValue = HANDLED;
    switch(message.what) {
        case SCAN_MODE_CHANGE_TIMEOUT:
            if (SystemProperties.BLUETI_ENHANCEMENT) {
                Log.e(TAG, "Devices failed to change scan mode, reseting...");
                transitionTo(mHotOff);
                finishSwitchingOff();
                // reset the hardware
                deferMessage(obtainMessage(TURN_COLD));
                if ((mPublicState == BluetoothAdapter.STATE_TURNING_OFF) && (mContext.getResources().getBoolean(com.android.internal.R.bool.config_bluetooth_adapter_quick_switch))) {
                    // try to recover in case of STATE_TURNING_OFF, otherwise, remain in
                    // PowerOff state in order to prevent loop of turning on
                    deferMessage(obtainMessage(TURN_HOT));
                }
            } else {
                return NOT_HANDLED;
            }
            break;
        case SCAN_MODE_CHANGED:
            if (SystemProperties.BLUETI_ENHANCEMENT) {
                removeMessages(SCAN_MODE_CHANGE_TIMEOUT);
                if (mPublicState == BluetoothAdapter.STATE_TURNING_OFF) {
                    if (mBluetoothService.getAdapterConnectionState() == BluetoothAdapter.STATE_DISCONNECTED) {
                        transitionTo(mHotOff);
                        if (mContext.getResources().getBoolean(com.android.internal.R.bool.config_bluetooth_adapter_quick_switch)) {
                            finishSwitchingOff();
                        } else {
                            deferMessage(obtainMessage(TURN_COLD));
                        }
                    }
                } else if (mPublicState == BluetoothAdapter.STATE_TURNING_ON) {
                    // set pairable if it's not
                    mBluetoothService.setPairable();
                    mBluetoothService.initBluetoothAfterTurningOn();
                    transitionTo(mBluetoothOn);
                    broadcastState(BluetoothAdapter.STATE_ON);
                    // run bluetooth now that it's turned on
                    // Note runBluetooth should be called only in adapter STATE_ON
                    mBluetoothService.runBluetooth();
                }
            } else {
                // This event matches mBluetoothService.switchConnectable action
                if (mPublicState == BluetoothAdapter.STATE_TURNING_ON) {
                    // set pairable if it's not
                    mBluetoothService.setPairable();
                    mBluetoothService.initBluetoothAfterTurningOn();
                    transitionTo(mBluetoothOn);
                    broadcastState(BluetoothAdapter.STATE_ON);
                    // run bluetooth now that it's turned on
                    // Note runBluetooth should be called only in adapter STATE_ON
                    mBluetoothService.runBluetooth();
                }
            }
            break;
        case POWER_STATE_CHANGED:
            removeMessages(POWER_DOWN_TIMEOUT);
            if (!((Boolean) message.obj)) {
                if (mPublicState == BluetoothAdapter.STATE_TURNING_OFF) {
                    transitionTo(mHotOff);
                    finishSwitchingOff();
                    if (!mContext.getResources().getBoolean(com.android.internal.R.bool.config_bluetooth_adapter_quick_switch)) {
                        deferMessage(obtainMessage(TURN_COLD));
                    }
                }
            } else {
                if (mPublicState != BluetoothAdapter.STATE_TURNING_ON) {
                    if (mContext.getResources().getBoolean(com.android.internal.R.bool.config_bluetooth_adapter_quick_switch)) {
                        recoverStateMachine(TURN_HOT, null);
                    } else {
                        recoverStateMachine(TURN_COLD, null);
                    }
                }
            }
            break;
        case ALL_DEVICES_DISCONNECTED:
            removeMessages(DEVICES_DISCONNECT_TIMEOUT);
            mBluetoothService.switchConnectable(false);
            if (SystemProperties.BLUETI_ENHANCEMENT)
                sendMessageDelayed(SCAN_MODE_CHANGE_TIMEOUT, SCAN_MODE_CHANGE_TIMEOUT_TIME);
            else
                sendMessageDelayed(POWER_DOWN_TIMEOUT, POWER_DOWN_TIMEOUT_TIME);
            break;
        case DEVICES_DISCONNECT_TIMEOUT:
            if (SystemProperties.BLUETI_ENHANCEMENT) {
                transitionTo(mHotOff);
                finishSwitchingOff();
            } else {
                sendMessage(ALL_DEVICES_DISCONNECTED);
            }
            // reset the hardware for error recovery
            Log.e(TAG, "Devices failed to disconnect, reseting...");
            deferMessage(obtainMessage(TURN_COLD));
            if (mContext.getResources().getBoolean(com.android.internal.R.bool.config_bluetooth_adapter_quick_switch)) {
                deferMessage(obtainMessage(TURN_HOT));
            }
            break;
        case POWER_DOWN_TIMEOUT:
            transitionTo(mHotOff);
            finishSwitchingOff();
            // reset the hardware for error recovery
            Log.e(TAG, "Devices failed to power down, reseting...");
            deferMessage(obtainMessage(TURN_COLD));
            if (mContext.getResources().getBoolean(com.android.internal.R.bool.config_bluetooth_adapter_quick_switch)) {
                deferMessage(obtainMessage(TURN_HOT));
            }
            break;
        case USER_TURN_ON:
        case AIRPLANE_MODE_OFF:
        case AIRPLANE_MODE_ON:
        case PER_PROCESS_TURN_ON:
        case PER_PROCESS_TURN_OFF:
        case USER_TURN_OFF:
            deferMessage(message);
            break;
        default:
            return NOT_HANDLED;
    }
    return retValue;
}
#method_after
@Override
public boolean processMessage(Message message) {
    log("Switching process message: " + message.what);
    boolean retValue = HANDLED;
    switch(message.what) {
        case SCAN_MODE_CHANGE_TIMEOUT:
            if (SystemProperties.BLUETI_ENHANCEMENT) {
                Log.e(TAG, "Devices failed to change scan mode, reseting...");
                transitionTo(mHotOff);
                finishSwitchingOff();
                // reset the hardware
                deferMessage(obtainMessage(TURN_COLD));
                if ((mPublicState == BluetoothAdapter.STATE_TURNING_OFF) && (mContext.getResources().getBoolean(com.android.internal.R.bool.config_bluetooth_adapter_quick_switch))) {
                    // try to recover in case of STATE_TURNING_OFF, otherwise, remain in
                    // PowerOff state in order to prevent loop of turning on
                    deferMessage(obtainMessage(TURN_HOT));
                }
            } else {
                return NOT_HANDLED;
            }
            break;
        case SCAN_MODE_CHANGED:
            if (SystemProperties.BLUETI_ENHANCEMENT) {
                removeMessages(SCAN_MODE_CHANGE_TIMEOUT);
                if (mPublicState == BluetoothAdapter.STATE_TURNING_OFF) {
                    if (mBluetoothService.getAdapterConnectionState() == BluetoothAdapter.STATE_DISCONNECTED) {
                        transitionTo(mHotOff);
                        if (mContext.getResources().getBoolean(com.android.internal.R.bool.config_bluetooth_adapter_quick_switch)) {
                            finishSwitchingOff();
                        } else {
                            deferMessage(obtainMessage(TURN_COLD));
                        }
                    }
                } else if (mPublicState == BluetoothAdapter.STATE_TURNING_ON) {
                    // set pairable if it's not
                    mBluetoothService.setPairable();
                    mBluetoothService.initBluetoothAfterTurningOn();
                    transitionTo(mBluetoothOn);
                    broadcastState(BluetoothAdapter.STATE_ON);
                    // run bluetooth now that it's turned on
                    // Note runBluetooth should be called only in adapter STATE_ON
                    mBluetoothService.runBluetooth();
                }
            } else {
                // This event matches mBluetoothService.switchConnectable action
                if (mPublicState == BluetoothAdapter.STATE_TURNING_ON) {
                    // set pairable if it's not
                    mBluetoothService.setPairable();
                    mBluetoothService.initBluetoothAfterTurningOn();
                    transitionTo(mBluetoothOn);
                    broadcastState(BluetoothAdapter.STATE_ON);
                    // run bluetooth now that it's turned on
                    // Note runBluetooth should be called only in adapter STATE_ON
                    mBluetoothService.runBluetooth();
                }
            }
            break;
        case POWER_STATE_CHANGED:
            removeMessages(POWER_DOWN_TIMEOUT);
            if (!((Boolean) message.obj)) {
                if (mPublicState == BluetoothAdapter.STATE_TURNING_OFF) {
                    transitionTo(mHotOff);
                    finishSwitchingOff();
                    if (!mContext.getResources().getBoolean(com.android.internal.R.bool.config_bluetooth_adapter_quick_switch)) {
                        deferMessage(obtainMessage(TURN_COLD));
                    }
                }
            } else {
                if (mPublicState != BluetoothAdapter.STATE_TURNING_ON) {
                    if (mContext.getResources().getBoolean(com.android.internal.R.bool.config_bluetooth_adapter_quick_switch)) {
                        recoverStateMachine(TURN_HOT, null);
                    } else {
                        recoverStateMachine(TURN_COLD, null);
                    }
                }
            }
            break;
        case ALL_DEVICES_DISCONNECTED:
            removeMessages(DEVICES_DISCONNECT_TIMEOUT);
            mBluetoothService.switchConnectable(false);
            if (SystemProperties.BLUETI_ENHANCEMENT) {
                sendMessageDelayed(SCAN_MODE_CHANGE_TIMEOUT, SCAN_MODE_CHANGE_TIMEOUT_TIME);
            } else {
                sendMessageDelayed(POWER_DOWN_TIMEOUT, POWER_DOWN_TIMEOUT_TIME);
            }
            break;
        case DEVICES_DISCONNECT_TIMEOUT:
            if (SystemProperties.BLUETI_ENHANCEMENT) {
                transitionTo(mHotOff);
                finishSwitchingOff();
            } else {
                sendMessage(ALL_DEVICES_DISCONNECTED);
            }
            // reset the hardware for error recovery
            Log.e(TAG, "Devices failed to disconnect, reseting...");
            deferMessage(obtainMessage(TURN_COLD));
            if (mContext.getResources().getBoolean(com.android.internal.R.bool.config_bluetooth_adapter_quick_switch)) {
                deferMessage(obtainMessage(TURN_HOT));
            }
            break;
        case POWER_DOWN_TIMEOUT:
            transitionTo(mHotOff);
            finishSwitchingOff();
            // reset the hardware for error recovery
            Log.e(TAG, "Devices failed to power down, reseting...");
            deferMessage(obtainMessage(TURN_COLD));
            if (mContext.getResources().getBoolean(com.android.internal.R.bool.config_bluetooth_adapter_quick_switch)) {
                deferMessage(obtainMessage(TURN_HOT));
            }
            break;
        case USER_TURN_ON:
        case AIRPLANE_MODE_OFF:
        case AIRPLANE_MODE_ON:
        case PER_PROCESS_TURN_ON:
        case PER_PROCESS_TURN_OFF:
        case USER_TURN_OFF:
            deferMessage(message);
            break;
        default:
            return NOT_HANDLED;
    }
    return retValue;
}
#end_block

#method_before
private void onRequestPinCode(String objectPath, int nativeData) {
    String address = checkPairingRequestAndGetAddress(objectPath, nativeData);
    if (address == null)
        return;
    String pendingOutgoingAddress = mBluetoothService.getPendingOutgoingBonding();
    BluetoothClass btClass = new BluetoothClass(mBluetoothService.getRemoteClass(address));
    int btDeviceClass = btClass.getDeviceClass();
    if (address.equals(pendingOutgoingAddress)) {
        // Check if its a dock
        if (mBluetoothService.isBluetoothDock(address)) {
            String pin = mBluetoothService.getDockPin();
            mBluetoothService.setPin(address, BluetoothDevice.convertPinToBytes(pin));
            return;
        }
        // try 0000 once if the device looks dumb
        switch(btDeviceClass) {
            case BluetoothClass.Device.AUDIO_VIDEO_WEARABLE_HEADSET:
            case BluetoothClass.Device.AUDIO_VIDEO_HANDSFREE:
            case BluetoothClass.Device.AUDIO_VIDEO_HEADPHONES:
            case BluetoothClass.Device.AUDIO_VIDEO_PORTABLE_AUDIO:
            case BluetoothClass.Device.AUDIO_VIDEO_HIFI_AUDIO:
                if (mBluetoothService.attemptAutoPair(address))
                    return;
        }
    }
    if (btDeviceClass == BluetoothClass.Device.PERIPHERAL_KEYBOARD || btDeviceClass == BluetoothClass.Device.PERIPHERAL_KEYBOARD_POINTING) {
        // and pair.
        if (mBluetoothService.isFixedPinZerosAutoPairKeyboard(address)) {
            mBluetoothService.setPin(address, BluetoothDevice.convertPinToBytes("0000"));
            return;
        }
        // Generate a variable PIN. This is not truly random but good enough.
        int pin = (int) Math.floor(Math.random() * 10000);
        sendDisplayPinIntent(address, pin);
        return;
    }
    // Acquire wakelock during PIN code request to bring up LCD display
    if (!SystemProperties.BLUETI_ENHANCEMENT) {
        mWakeLock.acquire();
    }
    Intent intent = new Intent(BluetoothDevice.ACTION_PAIRING_REQUEST);
    intent.putExtra(BluetoothDevice.EXTRA_DEVICE, mAdapter.getRemoteDevice(address));
    intent.putExtra(BluetoothDevice.EXTRA_PAIRING_VARIANT, BluetoothDevice.PAIRING_VARIANT_PIN);
    mContext.sendBroadcast(intent, BLUETOOTH_ADMIN_PERM);
    // Release wakelock to allow the LCD to go off after the PIN popup notification.
    if (SystemProperties.BLUETI_ENHANCEMENT) {
        // TI-BLUEZ Fix - bring up LCD display for PIN_CODE_REQUEST_WAKELOCK_TIME
        mWakeLock.acquire(PIN_CODE_REQUEST_WAKELOCK_TIME);
    } else {
        mWakeLock.release();
    }
    return;
}
#method_after
private void onRequestPinCode(String objectPath, int nativeData) {
    String address = checkPairingRequestAndGetAddress(objectPath, nativeData);
    if (address == null)
        return;
    String pendingOutgoingAddress = mBluetoothService.getPendingOutgoingBonding();
    BluetoothClass btClass = new BluetoothClass(mBluetoothService.getRemoteClass(address));
    int btDeviceClass = btClass.getDeviceClass();
    if (address.equals(pendingOutgoingAddress)) {
        // Check if its a dock
        if (mBluetoothService.isBluetoothDock(address)) {
            String pin = mBluetoothService.getDockPin();
            mBluetoothService.setPin(address, BluetoothDevice.convertPinToBytes(pin));
            return;
        }
        // try 0000 once if the device looks dumb
        switch(btDeviceClass) {
            case BluetoothClass.Device.AUDIO_VIDEO_WEARABLE_HEADSET:
            case BluetoothClass.Device.AUDIO_VIDEO_HANDSFREE:
            case BluetoothClass.Device.AUDIO_VIDEO_HEADPHONES:
            case BluetoothClass.Device.AUDIO_VIDEO_PORTABLE_AUDIO:
            case BluetoothClass.Device.AUDIO_VIDEO_HIFI_AUDIO:
                if (mBluetoothService.attemptAutoPair(address))
                    return;
        }
    }
    if (btDeviceClass == BluetoothClass.Device.PERIPHERAL_KEYBOARD || btDeviceClass == BluetoothClass.Device.PERIPHERAL_KEYBOARD_POINTING) {
        // and pair.
        if (mBluetoothService.isFixedPinZerosAutoPairKeyboard(address)) {
            mBluetoothService.setPin(address, BluetoothDevice.convertPinToBytes("0000"));
            return;
        }
        // Generate a variable PIN. This is not truly random but good enough.
        int pin = (int) Math.floor(Math.random() * 10000);
        sendDisplayPinIntent(address, pin);
        return;
    }
    // Acquire wakelock during PIN code request to bring up LCD display
    mWakeLock.acquire();
    Intent intent = new Intent(BluetoothDevice.ACTION_PAIRING_REQUEST);
    intent.putExtra(BluetoothDevice.EXTRA_DEVICE, mAdapter.getRemoteDevice(address));
    intent.putExtra(BluetoothDevice.EXTRA_PAIRING_VARIANT, BluetoothDevice.PAIRING_VARIANT_PIN);
    mContext.sendBroadcast(intent, BLUETOOTH_ADMIN_PERM);
    // Release wakelock to allow the LCD to go off after the PIN popup notification.
    mWakeLock.release();
    return;
}
#end_block

#method_before
private void onAgentAuthorize(String objectPath, String deviceUuid, int nativeData) {
    if (!mBluetoothService.isEnabled())
        return;
    String address = mBluetoothService.getAddressFromObjectPath(objectPath);
    if (address == null) {
        Log.e(TAG, "Unable to get device address in onAuthAgentAuthorize");
        return;
    }
    boolean authorized = false;
    ParcelUuid uuid = ParcelUuid.fromString(deviceUuid);
    BluetoothDevice device = mAdapter.getRemoteDevice(address);
    mAuthorizationAgentRequestData.put(address, new Integer(nativeData));
    // remote service
    if (mA2dp != null && (BluetoothUuid.isAudioSource(uuid) || BluetoothUuid.isAvrcpTarget(uuid) || BluetoothUuid.isAdvAudioDist(uuid)) && !isOtherSinkInNonDisconnectedState(address)) {
        authorized = mA2dp.getPriority(device) > BluetoothProfile.PRIORITY_OFF;
        if (authorized && !BluetoothUuid.isAvrcpTarget(uuid)) {
            if (SystemProperties.BLUETI_ENHANCEMENT)
                Log.i(TAG, "First check pass for incoming A2DP connection from " + address);
            else
                Log.i(TAG, "First check pass for incoming A2DP / AVRCP connection from " + address);
            // Some headsets try to connect AVCTP before AVDTP - against the recommendation
            // If AVCTP connection fails, we get stuck in IncomingA2DP state in the state
            // machine.  We don't handle AVCTP signals currently. We only send
            // intents for AVDTP state changes. We need to handle both of them in
            // some cases. For now, just don't move to incoming state in this case.
            mBluetoothService.notifyIncomingA2dpConnection(address, false);
        } else {
            if (SystemProperties.BLUETI_ENHANCEMENT) {
                /* In this case we know we are in AVRCP connect */
                Log.i(TAG, "" + authorized + "Incoming AVRCP connection from " + address);
            } else {
                Log.i(TAG, "" + authorized + "Incoming A2DP / AVRCP connection from " + address);
            }
            mA2dp.allowIncomingConnect(device, authorized);
            mBluetoothService.notifyIncomingA2dpConnection(address, true);
            if (SystemProperties.BLUETI_ENHANCEMENT)
                /* as AVRCP does not have a profile state we handle this here */
                mBluetoothService.notifyIncomingAVRCPConnection(address);
        }
    } else if (BluetoothUuid.isInputDevice(uuid)) {
        // We can have more than 1 input device connected.
        authorized = mBluetoothService.getInputDevicePriority(device) > BluetoothInputDevice.PRIORITY_OFF;
        if (authorized) {
            Log.i(TAG, "First check pass for incoming HID connection from " + address);
            // notify profile state change
            mBluetoothService.notifyIncomingHidConnection(address);
        } else {
            Log.i(TAG, "Rejecting incoming HID connection from " + address);
            mBluetoothService.allowIncomingProfileConnect(device, authorized);
        }
    } else if (BluetoothUuid.isBnep(uuid)) {
        // PAN doesn't go to the state machine, accept or reject from here
        authorized = mBluetoothService.allowIncomingTethering();
        mBluetoothService.allowIncomingProfileConnect(device, authorized);
    } else {
        Log.i(TAG, "Rejecting incoming " + deviceUuid + " connection from " + address);
        mBluetoothService.allowIncomingProfileConnect(device, authorized);
    }
    log("onAgentAuthorize(" + objectPath + ", " + deviceUuid + ") = " + authorized);
}
#method_after
private void onAgentAuthorize(String objectPath, String deviceUuid, int nativeData) {
    if (!mBluetoothService.isEnabled())
        return;
    String address = mBluetoothService.getAddressFromObjectPath(objectPath);
    if (address == null) {
        Log.e(TAG, "Unable to get device address in onAuthAgentAuthorize");
        return;
    }
    boolean authorized = false;
    ParcelUuid uuid = ParcelUuid.fromString(deviceUuid);
    BluetoothDevice device = mAdapter.getRemoteDevice(address);
    mAuthorizationAgentRequestData.put(address, new Integer(nativeData));
    // remote service
    if (mA2dp != null && (BluetoothUuid.isAudioSource(uuid) || BluetoothUuid.isAvrcpTarget(uuid) || BluetoothUuid.isAdvAudioDist(uuid)) && !isOtherSinkInNonDisconnectedState(address)) {
        authorized = mA2dp.getPriority(device) > BluetoothProfile.PRIORITY_OFF;
        if (authorized && !BluetoothUuid.isAvrcpTarget(uuid)) {
            if (SystemProperties.BLUETI_ENHANCEMENT) {
                Log.i(TAG, "First check pass for incoming A2DP connection from " + address);
            } else {
                Log.i(TAG, "First check pass for incoming A2DP / AVRCP connection from " + address);
            }
            // Some headsets try to connect AVCTP before AVDTP - against the recommendation
            // If AVCTP connection fails, we get stuck in IncomingA2DP state in the state
            // machine.  We don't handle AVCTP signals currently. We only send
            // intents for AVDTP state changes. We need to handle both of them in
            // some cases. For now, just don't move to incoming state in this case.
            mBluetoothService.notifyIncomingA2dpConnection(address, false);
        } else {
            if (SystemProperties.BLUETI_ENHANCEMENT) {
                /* In this case we know we are in AVRCP connect */
                Log.i(TAG, "" + authorized + "Incoming AVRCP connection from " + address);
            } else {
                Log.i(TAG, "" + authorized + "Incoming A2DP / AVRCP connection from " + address);
            }
            mA2dp.allowIncomingConnect(device, authorized);
            mBluetoothService.notifyIncomingA2dpConnection(address, true);
            if (SystemProperties.BLUETI_ENHANCEMENT) {
                /* as AVRCP does not have a profile state we handle this here */
                mBluetoothService.notifyIncomingAVRCPConnection(address);
            }
        }
    } else if (BluetoothUuid.isInputDevice(uuid)) {
        // We can have more than 1 input device connected.
        authorized = mBluetoothService.getInputDevicePriority(device) > BluetoothInputDevice.PRIORITY_OFF;
        if (authorized) {
            Log.i(TAG, "First check pass for incoming HID connection from " + address);
            // notify profile state change
            mBluetoothService.notifyIncomingHidConnection(address);
        } else {
            Log.i(TAG, "Rejecting incoming HID connection from " + address);
            mBluetoothService.allowIncomingProfileConnect(device, authorized);
        }
    } else if (BluetoothUuid.isBnep(uuid)) {
        // PAN doesn't go to the state machine, accept or reject from here
        authorized = mBluetoothService.allowIncomingTethering();
        mBluetoothService.allowIncomingProfileConnect(device, authorized);
    } else {
        Log.i(TAG, "Rejecting incoming " + deviceUuid + " connection from " + address);
        mBluetoothService.allowIncomingProfileConnect(device, authorized);
    }
    log("onAgentAuthorize(" + objectPath + ", " + deviceUuid + ") = " + authorized);
}
#end_block

#method_before
public FileCacheEntry beginFile(String path, String mimeType, long lastModified, long fileSize, boolean isDirectory, boolean noMedia) {
    mMimeType = mimeType;
    mFileType = 0;
    mFileSize = fileSize;
    if (!isDirectory) {
        if (!noMedia && isNoMediaFile(path)) {
            noMedia = true;
        }
        mNoMedia = noMedia;
        // try mimeType first, if it is specified
        if (mimeType != null) {
            mFileType = MediaFile.getFileTypeForMimeType(mimeType);
        }
        // if mimeType was not specified, compute file type based on file extension.
        if (mFileType == 0) {
            MediaFile.MediaFileType mediaFileType = MediaFile.getFileType(path);
            if (mediaFileType != null) {
                mFileType = mediaFileType.fileType;
                if (mMimeType == null) {
                    mMimeType = mediaFileType.mimeType;
                }
            }
        }
        if (isDrmEnabled() && MediaFile.isDrmFileType(mFileType)) {
            mFileType = getFileTypeFromDrm(path);
        }
    }
    String key = path;
    if (mCaseInsensitivePaths) {
        key = path.toLowerCase();
    }
    FileCacheEntry entry = mFileCache.get(key);
    // add some slack to avoid a rounding error
    long delta = (entry != null) ? (lastModified - entry.mLastModified) : 0;
    boolean wasModified = delta > 1 || delta < -1;
    if (entry == null || wasModified) {
        if (wasModified) {
            entry.mLastModified = lastModified;
        } else {
            entry = new FileCacheEntry(0, path, lastModified, (isDirectory ? MtpConstants.FORMAT_ASSOCIATION : 0));
            mFileCache.put(key, entry);
        }
        entry.mLastModifiedChanged = true;
    }
    entry.mSeenInFileSystem = true;
    if (mProcessPlaylists && MediaFile.isPlayListFileType(mFileType)) {
        mPlayLists.add(entry);
        // we don't process playlists in the main scan, so return null
        return null;
    }
    // clear all the metadata
    mArtist = null;
    mAlbumArtist = null;
    mAlbum = null;
    mTitle = null;
    mComposer = null;
    mGenre = null;
    mTrack = 0;
    mYear = 0;
    mDuration = 0;
    mPath = path;
    mLastModified = lastModified;
    mWriter = null;
    mCompilation = 0;
    mIsDrm = false;
    mWidth = 0;
    mHeight = 0;
    if (SystemProperties.BLUETI_ENHANCEMENT)
        mNumberOfTracks = 0;
    return entry;
}
#method_after
public FileCacheEntry beginFile(String path, String mimeType, long lastModified, long fileSize, boolean isDirectory, boolean noMedia) {
    mMimeType = mimeType;
    mFileType = 0;
    mFileSize = fileSize;
    if (!isDirectory) {
        if (!noMedia && isNoMediaFile(path)) {
            noMedia = true;
        }
        mNoMedia = noMedia;
        // try mimeType first, if it is specified
        if (mimeType != null) {
            mFileType = MediaFile.getFileTypeForMimeType(mimeType);
        }
        // if mimeType was not specified, compute file type based on file extension.
        if (mFileType == 0) {
            MediaFile.MediaFileType mediaFileType = MediaFile.getFileType(path);
            if (mediaFileType != null) {
                mFileType = mediaFileType.fileType;
                if (mMimeType == null) {
                    mMimeType = mediaFileType.mimeType;
                }
            }
        }
        if (isDrmEnabled() && MediaFile.isDrmFileType(mFileType)) {
            mFileType = getFileTypeFromDrm(path);
        }
    }
    String key = path;
    if (mCaseInsensitivePaths) {
        key = path.toLowerCase();
    }
    FileCacheEntry entry = mFileCache.get(key);
    // add some slack to avoid a rounding error
    long delta = (entry != null) ? (lastModified - entry.mLastModified) : 0;
    boolean wasModified = delta > 1 || delta < -1;
    if (entry == null || wasModified) {
        if (wasModified) {
            entry.mLastModified = lastModified;
        } else {
            entry = new FileCacheEntry(0, path, lastModified, (isDirectory ? MtpConstants.FORMAT_ASSOCIATION : 0));
            mFileCache.put(key, entry);
        }
        entry.mLastModifiedChanged = true;
    }
    entry.mSeenInFileSystem = true;
    if (mProcessPlaylists && MediaFile.isPlayListFileType(mFileType)) {
        mPlayLists.add(entry);
        // we don't process playlists in the main scan, so return null
        return null;
    }
    // clear all the metadata
    mArtist = null;
    mAlbumArtist = null;
    mAlbum = null;
    mTitle = null;
    mComposer = null;
    mGenre = null;
    mTrack = 0;
    mYear = 0;
    mDuration = 0;
    mPath = path;
    mLastModified = lastModified;
    mWriter = null;
    mCompilation = 0;
    mIsDrm = false;
    mWidth = 0;
    mHeight = 0;
    if (SystemProperties.BLUETI_ENHANCEMENT) {
        mNumberOfTracks = 0;
    }
    return entry;
}
#end_block

#method_before
private ContentValues toValues() {
    ContentValues map = new ContentValues();
    map.put(MediaStore.MediaColumns.DATA, mPath);
    map.put(MediaStore.MediaColumns.TITLE, mTitle);
    map.put(MediaStore.MediaColumns.DATE_MODIFIED, mLastModified);
    map.put(MediaStore.MediaColumns.SIZE, mFileSize);
    map.put(MediaStore.MediaColumns.MIME_TYPE, mMimeType);
    map.put(MediaStore.MediaColumns.IS_DRM, mIsDrm);
    if (mWidth > 0 && mHeight > 0) {
        map.put(MediaStore.MediaColumns.WIDTH, mWidth);
        map.put(MediaStore.MediaColumns.HEIGHT, mHeight);
    }
    if (!mNoMedia) {
        if (MediaFile.isVideoFileType(mFileType)) {
            map.put(Video.Media.ARTIST, (mArtist != null && mArtist.length() > 0 ? mArtist : MediaStore.UNKNOWN_STRING));
            map.put(Video.Media.ALBUM, (mAlbum != null && mAlbum.length() > 0 ? mAlbum : MediaStore.UNKNOWN_STRING));
            map.put(Video.Media.DURATION, mDuration);
        // FIXME - add RESOLUTION
        } else if (MediaFile.isImageFileType(mFileType)) {
        // FIXME - add DESCRIPTION
        } else if (MediaFile.isAudioFileType(mFileType)) {
            map.put(Audio.Media.ARTIST, (mArtist != null && mArtist.length() > 0) ? mArtist : MediaStore.UNKNOWN_STRING);
            map.put(Audio.Media.ALBUM_ARTIST, (mAlbumArtist != null && mAlbumArtist.length() > 0) ? mAlbumArtist : null);
            map.put(Audio.Media.ALBUM, (mAlbum != null && mAlbum.length() > 0) ? mAlbum : MediaStore.UNKNOWN_STRING);
            map.put(Audio.Media.COMPOSER, mComposer);
            map.put(Audio.Media.GENRE, mGenre);
            if (mYear != 0) {
                map.put(Audio.Media.YEAR, mYear);
            }
            map.put(Audio.Media.TRACK, mTrack);
            if (SystemProperties.BLUETI_ENHANCEMENT)
                map.put(Audio.Media.NUMBER_OF_TRACKS, mNumberOfTracks);
            map.put(Audio.Media.DURATION, mDuration);
            map.put(Audio.Media.COMPILATION, mCompilation);
        }
    }
    return map;
}
#method_after
private ContentValues toValues() {
    ContentValues map = new ContentValues();
    map.put(MediaStore.MediaColumns.DATA, mPath);
    map.put(MediaStore.MediaColumns.TITLE, mTitle);
    map.put(MediaStore.MediaColumns.DATE_MODIFIED, mLastModified);
    map.put(MediaStore.MediaColumns.SIZE, mFileSize);
    map.put(MediaStore.MediaColumns.MIME_TYPE, mMimeType);
    map.put(MediaStore.MediaColumns.IS_DRM, mIsDrm);
    if (mWidth > 0 && mHeight > 0) {
        map.put(MediaStore.MediaColumns.WIDTH, mWidth);
        map.put(MediaStore.MediaColumns.HEIGHT, mHeight);
    }
    if (!mNoMedia) {
        if (MediaFile.isVideoFileType(mFileType)) {
            map.put(Video.Media.ARTIST, (mArtist != null && mArtist.length() > 0 ? mArtist : MediaStore.UNKNOWN_STRING));
            map.put(Video.Media.ALBUM, (mAlbum != null && mAlbum.length() > 0 ? mAlbum : MediaStore.UNKNOWN_STRING));
            map.put(Video.Media.DURATION, mDuration);
        // FIXME - add RESOLUTION
        } else if (MediaFile.isImageFileType(mFileType)) {
        // FIXME - add DESCRIPTION
        } else if (MediaFile.isAudioFileType(mFileType)) {
            map.put(Audio.Media.ARTIST, (mArtist != null && mArtist.length() > 0) ? mArtist : MediaStore.UNKNOWN_STRING);
            map.put(Audio.Media.ALBUM_ARTIST, (mAlbumArtist != null && mAlbumArtist.length() > 0) ? mAlbumArtist : null);
            map.put(Audio.Media.ALBUM, (mAlbum != null && mAlbum.length() > 0) ? mAlbum : MediaStore.UNKNOWN_STRING);
            map.put(Audio.Media.COMPOSER, mComposer);
            map.put(Audio.Media.GENRE, mGenre);
            if (mYear != 0) {
                map.put(Audio.Media.YEAR, mYear);
            }
            map.put(Audio.Media.TRACK, mTrack);
            if (SystemProperties.BLUETI_ENHANCEMENT) {
                map.put(Audio.Media.NUMBER_OF_TRACKS, mNumberOfTracks);
            }
            map.put(Audio.Media.DURATION, mDuration);
            map.put(Audio.Media.COMPILATION, mCompilation);
        }
    }
    return map;
}
#end_block

#method_before
@Override
public int hashCode() {
    if (SystemProperties.BLUETI_ENHANCEMENT)
        return mReceiverComponent.hashCode();
    else
        return 0;
}
#method_after
@Override
public int hashCode() {
    if (SystemProperties.BLUETI_ENHANCEMENT) {
        return mReceiverComponent.hashCode();
    } else {
        return 0;
    }
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (SystemProperties.BLUETI_ENHANCEMENT)
        return mReceiverComponent.equals(obj);
    else
        return false;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (SystemProperties.BLUETI_ENHANCEMENT) {
        return mReceiverComponent.equals(obj);
    } else {
        return false;
    }
}
#end_block

#method_before
public void registerMediaPlayerEventReceiver(ComponentName eventReceiver) {
    if (SystemProperties.BLUETI_ENHANCEMENT) {
        // TODO enforce the rule about the receiver being declared in the manifest
        IAudioService service = getService();
        try {
            service.registerMediaPlayerEventReceiver(eventReceiver);
        } catch (RemoteException e) {
            Log.e(TAG, "Dead object in registerMediaButtonEventReceiver" + e);
        }
    } else {
        Log.e(TAG, "SystemProperties.BLUETI_ENHANCEMENT==false, registerMediaPlayerEventReceiver not implemented");
    }
}
#method_after
public void registerMediaPlayerEventReceiver(ComponentName eventReceiver) {
    if (SystemProperties.BLUETI_ENHANCEMENT) {
        // TODO enforce the rule about the receiver being declared in the manifest
        IAudioService service = getService();
        try {
            service.registerMediaPlayerEventReceiver(eventReceiver);
        } catch (RemoteException e) {
            Log.e(TAG, "Dead object in registerMediaButtonEventReceiver" + e);
        }
    } else {
        Log.e(TAG, "SystemProperties.BLUETI_ENHANCEMENT==false," + "registerMediaPlayerEventReceiver not implemented");
    }
}
#end_block

#method_before
public void unregisterMediaPlayerEventReceiver(ComponentName eventReceiver) {
    if (SystemProperties.BLUETI_ENHANCEMENT) {
        IAudioService service = getService();
        try {
            service.unregisterMediaPlayerEventReceiver(eventReceiver);
        } catch (RemoteException e) {
            Log.e(TAG, "Dead object in unregisterMediaButtonEventReceiver" + e);
        }
    } else {
        Log.e(TAG, "SystemProperties.BLUETI_ENHANCEMENT==false, unregisterMediaPlayerEventReceiver not implemented");
    }
}
#method_after
public void unregisterMediaPlayerEventReceiver(ComponentName eventReceiver) {
    if (SystemProperties.BLUETI_ENHANCEMENT) {
        IAudioService service = getService();
        try {
            service.unregisterMediaPlayerEventReceiver(eventReceiver);
        } catch (RemoteException e) {
            Log.e(TAG, "Dead object in unregisterMediaButtonEventReceiver" + e);
        }
    } else {
        Log.e(TAG, "SystemProperties.BLUETI_ENHANCEMENT==false," + " unregisterMediaPlayerEventReceiver not implemented");
    }
}
#end_block

#method_before
public void setCurrentMediaPlaybackStatus(int status, long elapsed) {
    if (SystemProperties.BLUETI_ENHANCEMENT) {
        IAudioService service = getService();
        try {
            service.setCurrentMediaPlaybackStatus(status, elapsed);
        } catch (RemoteException e) {
            Log.e(TAG, "Dead object in setCurrentMediaPlaybackStatus" + e);
        }
    } else {
        Log.e(TAG, "SystemProperties.BLUETI_ENHANCEMENT==false, setCurrentMediaPlaybackStatus not implemented");
    }
}
#method_after
public void setCurrentMediaPlaybackStatus(int status, long elapsed) {
    if (SystemProperties.BLUETI_ENHANCEMENT) {
        IAudioService service = getService();
        try {
            service.setCurrentMediaPlaybackStatus(status, elapsed);
        } catch (RemoteException e) {
            Log.e(TAG, "Dead object in setCurrentMediaPlaybackStatus" + e);
        }
    } else {
        Log.e(TAG, "SystemProperties.BLUETI_ENHANCEMENT==false," + " setCurrentMediaPlaybackStatus not implemented");
    }
}
#end_block

#method_before
public void setCurrentMedia(Bundle metadata) {
    if (SystemProperties.BLUETI_ENHANCEMENT) {
        IAudioService service = getService();
        try {
            service.setCurrentMedia(metadata);
        } catch (RemoteException e) {
            Log.e(TAG, "Dead object in setCurrentMediaPlaybackStatus" + e);
        }
    } else {
        Log.e(TAG, "SystemProperties.BLUETI_ENHANCEMENT==false, setCurrentMedia not implemented");
    }
}
#method_after
public void setCurrentMedia(Bundle metadata) {
    if (SystemProperties.BLUETI_ENHANCEMENT) {
        IAudioService service = getService();
        try {
            service.setCurrentMedia(metadata);
        } catch (RemoteException e) {
            Log.e(TAG, "Dead object in setCurrentMediaPlaybackStatus" + e);
        }
    } else {
        Log.e(TAG, "SystemProperties.BLUETI_ENHANCEMENT==false," + " setCurrentMedia not implemented");
    }
}
#end_block

#method_before
public void setCurrentMediaPlayerSettings(Bundle settings) {
    if (SystemProperties.BLUETI_ENHANCEMENT) {
        IAudioService service = getService();
        try {
            service.setCurrentMediaPlayerSettings(settings);
        } catch (RemoteException e) {
            Log.e(TAG, "Dead object in setCurrentMediaPlayerSettings" + e);
        }
    } else {
        Log.e(TAG, "SystemProperties.BLUETI_ENHANCEMENT==false, setCurrentMediaPlayerSettings not implemented");
    }
}
#method_after
public void setCurrentMediaPlayerSettings(Bundle settings) {
    if (SystemProperties.BLUETI_ENHANCEMENT) {
        IAudioService service = getService();
        try {
            service.setCurrentMediaPlayerSettings(settings);
        } catch (RemoteException e) {
            Log.e(TAG, "Dead object in setCurrentMediaPlayerSettings" + e);
        }
    } else {
        Log.e(TAG, "SystemProperties.BLUETI_ENHANCEMENT==false," + " setCurrentMediaPlayerSettings not implemented");
    }
}
#end_block

#method_before
public static Uri getContentUri(String volumeName) {
    return Uri.parse(CONTENT_AUTHORITY_SLASH + volumeName + "/video/media");
}
#method_after
public static Uri getContentUri(String volumeName) {
    return Uri.parse(CONTENT_AUTHORITY_SLASH + volumeName + "/images/media");
}
#end_block

#method_before
public static Bitmap getThumbnail(ContentResolver cr, long origId, int kind, BitmapFactory.Options options) {
    return InternalThumbnails.getThumbnail(cr, origId, InternalThumbnails.DEFAULT_GROUP_ID, kind, options, EXTERNAL_CONTENT_URI, true);
}
#method_after
public static Bitmap getThumbnail(ContentResolver cr, long origId, int kind, BitmapFactory.Options options) {
    return InternalThumbnails.getThumbnail(cr, origId, InternalThumbnails.DEFAULT_GROUP_ID, kind, options, EXTERNAL_CONTENT_URI, false);
}
#end_block

#method_before
public static Bitmap getThumbnail(ContentResolver cr, long origId, long groupId, int kind, BitmapFactory.Options options) {
    return InternalThumbnails.getThumbnail(cr, origId, groupId, kind, options, EXTERNAL_CONTENT_URI, true);
}
#method_after
public static Bitmap getThumbnail(ContentResolver cr, long origId, long groupId, int kind, BitmapFactory.Options options) {
    return InternalThumbnails.getThumbnail(cr, origId, groupId, kind, options, EXTERNAL_CONTENT_URI, false);
}
#end_block

#method_before
public static Uri getContentUri(String volumeName) {
    return Uri.parse(CONTENT_AUTHORITY_SLASH + volumeName + "/video/thumbnails");
}
#method_after
public static Uri getContentUri(String volumeName) {
    return Uri.parse(CONTENT_AUTHORITY_SLASH + volumeName + "/images/thumbnails");
}
#end_block

#method_before
public static Uri getContentUri(String volumeName) {
    return Uri.parse(CONTENT_AUTHORITY_SLASH + volumeName + "/video/media");
}
#method_after
public static Uri getContentUri(String volumeName) {
    return Uri.parse(CONTENT_AUTHORITY_SLASH + volumeName + "/audio/media");
}
#end_block

#method_before
public static final Uri getContentUri(String volumeName, long playlistId) {
    return Uri.parse(CONTENT_AUTHORITY_SLASH + volumeName + "/audio/playlists/" + playlistId + "/members");
}
#method_after
public static final Uri getContentUri(String volumeName, long genreId) {
    return Uri.parse(CONTENT_AUTHORITY_SLASH + volumeName + "/audio/genres/" + genreId + "/members");
}
#end_block

#method_before
public static void cancelThumbnailRequest(ContentResolver cr, long origId, long groupId) {
    InternalThumbnails.cancelThumbnailRequest(cr, origId, EXTERNAL_CONTENT_URI, groupId);
}
#method_after
public static void cancelThumbnailRequest(ContentResolver cr, long origId) {
    InternalThumbnails.cancelThumbnailRequest(cr, origId, EXTERNAL_CONTENT_URI, InternalThumbnails.DEFAULT_GROUP_ID);
}
#end_block

#method_before
public static Bitmap getThumbnail(ContentResolver cr, long origId, long groupId, int kind, BitmapFactory.Options options) {
    return InternalThumbnails.getThumbnail(cr, origId, groupId, kind, options, EXTERNAL_CONTENT_URI, true);
}
#method_after
public static Bitmap getThumbnail(ContentResolver cr, long origId, int kind, BitmapFactory.Options options) {
    return InternalThumbnails.getThumbnail(cr, origId, InternalThumbnails.DEFAULT_GROUP_ID, kind, options, EXTERNAL_CONTENT_URI, true);
}
#end_block

#method_before
private String[] parseMetadata(Bundle metadata) {
    if (SystemProperties.BLUETI_ENHANCEMENT) {
        if (metadata == null)
            return new String[1];
        Set<String> keys = metadata.keySet();
        String[] properties = new String[keys.size() * 2];
        int j = 0;
        for (String key : keys) {
            if (!mMetadataMap.containsKey(key))
                continue;
            properties[j++] = mMetadataMap.get(key);
            // This could be done by a separate class which handle
            // Integer and String metadata. However this would imply
            // the native code to constantly call the VM methods to
            // extract the field, which is actually more expensive than
            // converting it to String
            properties[j++] = metadata.get(key).toString();
        }
        return properties;
    } else {
        Log.e(TAG, "SystemProperties.BLUETI_ENHANCEMENT == false, parseMetadata not implemented");
        return null;
    }
}
#method_after
private String[] parseMetadata(Bundle metadata) {
    if (SystemProperties.BLUETI_ENHANCEMENT) {
        if (metadata == null) {
            return new String[1];
        }
        Set<String> keys = metadata.keySet();
        String[] properties = new String[keys.size() * 2];
        int j = 0;
        for (String key : keys) {
            if (!mMetadataMap.containsKey(key)) {
                continue;
            }
            properties[j++] = mMetadataMap.get(key);
            // This could be done by a separate class which handle
            // Integer and String metadata. However this would imply
            // the native code to constantly call the VM methods to
            // extract the field, which is actually more expensive than
            // converting it to String
            properties[j++] = metadata.get(key).toString();
        }
        return properties;
    } else {
        Log.e(TAG, "SystemProperties.BLUETI_ENHANCEMENT == false," + " parseMetadata not implemented");
        return null;
    }
}
#end_block

#method_before
private String[] parseMediaPlayerSettings(Bundle settings) {
    if (SystemProperties.BLUETI_ENHANCEMENT) {
        if (settings == null)
            return new String[1];
        Set<String> keys = settings.keySet();
        String[] properties = new String[keys.size() * 2];
        int j = 0;
        for (String key : keys) {
            if (!mSettingsMap.containsKey(key)) {
                Log.e(TAG, "Ignoring unknown setting " + key);
                continue;
            }
            int value = settings.getInt(key);
            if (!mSettingValuesMap.containsKey(value)) {
                Log.e(TAG, "Ignoring setting " + key + " because of unkown value " + value);
                continue;
            }
            properties[j++] = mSettingsMap.get(key);
            properties[j++] = mSettingValuesMap.get(value);
        }
        return properties;
    } else {
        Log.e(TAG, "SystemProperties.BLUETI_ENHANCEMENT == false, parseMediaPlayerSettings not implemented");
        return null;
    }
}
#method_after
private String[] parseMediaPlayerSettings(Bundle settings) {
    if (SystemProperties.BLUETI_ENHANCEMENT) {
        if (settings == null) {
            return new String[1];
        }
        Set<String> keys = settings.keySet();
        String[] properties = new String[keys.size() * 2];
        int j = 0;
        for (String key : keys) {
            if (!mSettingsMap.containsKey(key)) {
                Log.e(TAG, "Ignoring unknown setting " + key);
                continue;
            }
            int value = settings.getInt(key);
            if (!mSettingValuesMap.containsKey(value)) {
                Log.e(TAG, "Ignoring setting " + key + " because of unkown value " + value);
                continue;
            }
            properties[j++] = mSettingsMap.get(key);
            properties[j++] = mSettingValuesMap.get(value);
        }
        return properties;
    } else {
        Log.e(TAG, "SystemProperties.BLUETI_ENHANCEMENT == false," + " parseMediaPlayerSettings not implemented");
        return null;
    }
}
#end_block

#method_before
private void avrcpRegisterMediaPlayer(Bundle metadata, Bundle settings) {
    if (SystemProperties.BLUETI_ENHANCEMENT) {
        String[] parsedMetadata = parseMetadata(metadata);
        String[] parsedSettings = parseMediaPlayerSettings(settings);
        Log.i(TAG, "Register player - metadata: " + parsedMetadata.length + " settings: " + parsedSettings.length);
        avrcpRegisterMediaPlayerNative(mBluetoothService, parsedMetadata, parsedSettings);
    } else {
        Log.e(TAG, "SystemProperties.BLUETI_ENHANCEMENT == false, avrcpRegisterMediaPlayer not implemented");
    }
}
#method_after
private void avrcpRegisterMediaPlayer(Bundle metadata, Bundle settings) {
    if (SystemProperties.BLUETI_ENHANCEMENT) {
        String[] parsedMetadata = parseMetadata(metadata);
        String[] parsedSettings = parseMediaPlayerSettings(settings);
        Log.i(TAG, "Register player - metadata: " + parsedMetadata.length + " settings: " + parsedSettings.length);
        avrcpRegisterMediaPlayerNative(mBluetoothService, parsedMetadata, parsedSettings);
    } else {
        Log.e(TAG, "SystemProperties.BLUETI_ENHANCEMENT == false," + " avrcpRegisterMediaPlayer not implemented");
    }
}
#end_block

#method_before
private static HashMap<Integer, String> createStatusMap() {
    if (SystemProperties.BLUETI_ENHANCEMENT) {
        HashMap<Integer, String> map = new HashMap<Integer, String>();
        map.put(AudioManager.MEDIA_PLAYBACK_STATUS_PLAYING, "playing");
        map.put(AudioManager.MEDIA_PLAYBACK_STATUS_STOPPED, "stopped");
        map.put(AudioManager.MEDIA_PLAYBACK_STATUS_PAUSED, "paused");
        map.put(AudioManager.MEDIA_PLAYBACK_STATUS_FORWARD_SEEK, "forward-seek");
        map.put(AudioManager.MEDIA_PLAYBACK_STATUS_REVERSE_SEEK, "reverse-seek");
        return map;
    } else {
        Log.e(TAG, "SystemProperties.BLUETI_ENHANCEMENT == false, createStatusMap not implemented");
        return null;
    }
}
#method_after
private static HashMap<Integer, String> createStatusMap() {
    if (SystemProperties.BLUETI_ENHANCEMENT) {
        HashMap<Integer, String> map = new HashMap<Integer, String>();
        map.put(AudioManager.MEDIA_PLAYBACK_STATUS_PLAYING, "playing");
        map.put(AudioManager.MEDIA_PLAYBACK_STATUS_STOPPED, "stopped");
        map.put(AudioManager.MEDIA_PLAYBACK_STATUS_PAUSED, "paused");
        map.put(AudioManager.MEDIA_PLAYBACK_STATUS_FORWARD_SEEK, "forward-seek");
        map.put(AudioManager.MEDIA_PLAYBACK_STATUS_REVERSE_SEEK, "reverse-seek");
        return map;
    } else {
        Log.e(TAG, "SystemProperties.BLUETI_ENHANCEMENT == false," + " createStatusMap not implemented");
        return null;
    }
}
#end_block

#method_before
private static HashMap<String, String> createSettingsMap() {
    if (SystemProperties.BLUETI_ENHANCEMENT) {
        HashMap<String, String> map = new HashMap<String, String>();
        map.put(AudioManager.MEDIA_PLAYER_SETTING_EQUALIZER, "Equalizer");
        map.put(AudioManager.MEDIA_PLAYER_SETTING_REPEAT, "Repeat");
        map.put(AudioManager.MEDIA_PLAYER_SETTING_SHUFFLE, "Shuffle");
        map.put(AudioManager.MEDIA_PLAYER_SETTING_SCAN, "Scan");
        return map;
    } else {
        Log.e(TAG, "SystemProperties.BLUETI_ENHANCEMENT == false, createSettingsMap not implemented");
        return null;
    }
}
#method_after
private static HashMap<String, String> createSettingsMap() {
    if (SystemProperties.BLUETI_ENHANCEMENT) {
        HashMap<String, String> map = new HashMap<String, String>();
        map.put(AudioManager.MEDIA_PLAYER_SETTING_EQUALIZER, "Equalizer");
        map.put(AudioManager.MEDIA_PLAYER_SETTING_REPEAT, "Repeat");
        map.put(AudioManager.MEDIA_PLAYER_SETTING_SHUFFLE, "Shuffle");
        map.put(AudioManager.MEDIA_PLAYER_SETTING_SCAN, "Scan");
        return map;
    } else {
        Log.e(TAG, "SystemProperties.BLUETI_ENHANCEMENT == false," + " createSettingsMap not implemented");
        return null;
    }
}
#end_block

#method_before
private static HashMap<Integer, String> createSettingValuesMap() {
    if (SystemProperties.BLUETI_ENHANCEMENT) {
        HashMap<Integer, String> map = new HashMap<Integer, String>();
        // We rely on the fact that equalizer, repeat, shuffle and scan modes
        // share some states, so we avoid populating the map with several
        // values.
        map.put(AudioManager.MEDIA_PLAYER_EQUALIZER_MODE_OFF, "off");
        map.put(AudioManager.MEDIA_PLAYER_EQUALIZER_MODE_ON, "on");
        map.put(AudioManager.MEDIA_PLAYER_REPEAT_MODE_SINGLETRACK, "singletrack");
        map.put(AudioManager.MEDIA_PLAYER_REPEAT_MODE_ALLTRACKS, "alltracks");
        map.put(AudioManager.MEDIA_PLAYER_REPEAT_MODE_GROUP, "group");
        return map;
    } else {
        Log.e(TAG, "SystemProperties.BLUETI_ENHANCEMENT == false, createSettingValuesMap not implemented");
        return null;
    }
}
#method_after
private static HashMap<Integer, String> createSettingValuesMap() {
    if (SystemProperties.BLUETI_ENHANCEMENT) {
        HashMap<Integer, String> map = new HashMap<Integer, String>();
        // We rely on the fact that equalizer, repeat, shuffle and scan modes
        // share some states, so we avoid populating the map with several
        // values.
        map.put(AudioManager.MEDIA_PLAYER_EQUALIZER_MODE_OFF, "off");
        map.put(AudioManager.MEDIA_PLAYER_EQUALIZER_MODE_ON, "on");
        map.put(AudioManager.MEDIA_PLAYER_REPEAT_MODE_SINGLETRACK, "singletrack");
        map.put(AudioManager.MEDIA_PLAYER_REPEAT_MODE_ALLTRACKS, "alltracks");
        map.put(AudioManager.MEDIA_PLAYER_REPEAT_MODE_GROUP, "group");
        return map;
    } else {
        Log.e(TAG, "SystemProperties.BLUETI_ENHANCEMENT == false," + " createSettingValuesMap not implemented");
        return null;
    }
}
#end_block

#method_before
private static HashMap<String, String> createMetadataMap() {
    if (SystemProperties.BLUETI_ENHANCEMENT) {
        HashMap<String, String> map = new HashMap<String, String>();
        map.put(AudioManager.EXTRA_MEDIA_TITLE, "Title");
        map.put(AudioManager.EXTRA_MEDIA_ARTIST, "Artist");
        map.put(AudioManager.EXTRA_MEDIA_ALBUM, "Album");
        map.put(AudioManager.EXTRA_MEDIA_GENRE, "Genre");
        map.put(AudioManager.EXTRA_MEDIA_NUMBER_OF_TRACKS, "NumberOfTracks");
        map.put(AudioManager.EXTRA_MEDIA_TRACK_NUMBER, "Number");
        map.put(AudioManager.EXTRA_MEDIA_TRACK_DURATION, "Duration");
        return map;
    } else {
        Log.e(TAG, "SystemProperties.BLUETI_ENHANCEMENT == false, createMetadataMap not implemented");
        return null;
    }
}
#method_after
private static HashMap<String, String> createMetadataMap() {
    if (SystemProperties.BLUETI_ENHANCEMENT) {
        HashMap<String, String> map = new HashMap<String, String>();
        map.put(AudioManager.EXTRA_MEDIA_TITLE, "Title");
        map.put(AudioManager.EXTRA_MEDIA_ARTIST, "Artist");
        map.put(AudioManager.EXTRA_MEDIA_ALBUM, "Album");
        map.put(AudioManager.EXTRA_MEDIA_GENRE, "Genre");
        map.put(AudioManager.EXTRA_MEDIA_NUMBER_OF_TRACKS, "NumberOfTracks");
        map.put(AudioManager.EXTRA_MEDIA_TRACK_NUMBER, "Number");
        map.put(AudioManager.EXTRA_MEDIA_TRACK_DURATION, "Duration");
        return map;
    } else {
        Log.e(TAG, "SystemProperties.BLUETI_ENHANCEMENT == false," + " createMetadataMap not implemented");
        return null;
    }
}
#end_block

#method_before
private synchronized void onMediaPlayerPropertyChanged(String[] propValues) {
    if (SystemProperties.BLUETI_ENHANCEMENT) {
        if (!mBluetoothService.isEnabled()) {
            return;
        }
        Log.d(TAG, "Received MediaPlayer setting: " + propValues[0] + "=" + propValues[1]);
        String name = propValues[0];
        String key = null;
        int val = -1;
        for (Map.Entry<String, String> entry : mSettingsMap.entrySet()) {
            if (entry.getValue().equalsIgnoreCase(propValues[0])) {
                key = entry.getKey();
                break;
            }
        }
        if (key == null) {
            Log.e(TAG, "Unknown setting key: " + propValues[0]);
            return;
        }
        for (Map.Entry<Integer, String> entry : mSettingValuesMap.entrySet()) {
            if (entry.getValue().equalsIgnoreCase(propValues[1])) {
                val = entry.getKey();
                break;
            }
        }
        if (val == -1) {
            Log.e(TAG, "Unknown setting value " + propValues[1] + " for key " + propValues[0]);
            return;
        }
        Log.d(TAG, "Setting MediaPlayer value: " + key + " = " + val);
        Intent intent = mContext.registerReceiver(null, new IntentFilter(AudioManager.ACTION_MEDIA_PLAYER_SETTINGS_CHANGED));
        if (intent != null) {
            intent.removeExtra(key);
        } else {
            intent = new Intent(AudioManager.ACTION_MEDIA_PLAYER_SETTINGS_CHANGED);
        }
        intent.putExtra(key, val);
        intent.addFlags(Intent.FLAG_FROM_BACKGROUND);
        mContext.sendStickyBroadcast(intent);
    } else {
        Log.e(TAG, "SystemProperties.BLUETI_ENHANCEMENT == false, createMetadataMap not implemented");
    }
}
#method_after
private synchronized void onMediaPlayerPropertyChanged(String[] propValues) {
    if (SystemProperties.BLUETI_ENHANCEMENT) {
        if (!mBluetoothService.isEnabled()) {
            return;
        }
        Log.d(TAG, "Received MediaPlayer setting: " + propValues[0] + "=" + propValues[1]);
        String name = propValues[0];
        String key = null;
        int val = -1;
        for (Map.Entry<String, String> entry : mSettingsMap.entrySet()) {
            if (entry.getValue().equalsIgnoreCase(propValues[0])) {
                key = entry.getKey();
                break;
            }
        }
        if (key == null) {
            Log.e(TAG, "Unknown setting key: " + propValues[0]);
            return;
        }
        for (Map.Entry<Integer, String> entry : mSettingValuesMap.entrySet()) {
            if (entry.getValue().equalsIgnoreCase(propValues[1])) {
                val = entry.getKey();
                break;
            }
        }
        if (val == -1) {
            Log.e(TAG, "Unknown setting value " + propValues[1] + " for key " + propValues[0]);
            return;
        }
        Log.d(TAG, "Setting MediaPlayer value: " + key + " = " + val);
        Intent intent = mContext.registerReceiver(null, new IntentFilter(AudioManager.ACTION_MEDIA_PLAYER_SETTINGS_CHANGED));
        if (intent != null) {
            intent.removeExtra(key);
        } else {
            intent = new Intent(AudioManager.ACTION_MEDIA_PLAYER_SETTINGS_CHANGED);
        }
        intent.putExtra(key, val);
        intent.addFlags(Intent.FLAG_FROM_BACKGROUND);
        mContext.sendStickyBroadcast(intent);
    } else {
        Log.e(TAG, "SystemProperties.BLUETI_ENHANCEMENT == false," + " createMetadataMap not implemented");
    }
}
#end_block

#method_before
synchronized void onCreatePairedDeviceResult(String address, int result) {
    if (result == BluetoothDevice.BOND_SUCCESS) {
        setBondState(address, BluetoothDevice.BOND_BONDED);
        if (mBondState.isAutoPairingAttemptsInProgress(address)) {
            mBondState.clearPinAttempts(address);
        }
    /* TI-BlueZ Start */
    } else if (result == BluetoothDevice.UNBOND_REASON_AUTH_FAILED) {
        if (mBondState.getAttempt(address) == 1) {
            mBondState.addAutoPairingFailure(address);
            pairingAttempt(address, result);
        }
    /* TI-BlueZ End */
    } else if (result == BluetoothDevice.UNBOND_REASON_REMOTE_DEVICE_DOWN && mBondState.isAutoPairingAttemptsInProgress(address)) {
        pairingAttempt(address, result);
    } else {
        setBondState(address, BluetoothDevice.BOND_NONE, result);
        if (mBondState.isAutoPairingAttemptsInProgress(address)) {
            mBondState.clearPinAttempts(address);
        }
    }
}
#method_after
synchronized void onCreatePairedDeviceResult(String address, int result) {
    if (result == BluetoothDevice.BOND_SUCCESS) {
        setBondState(address, BluetoothDevice.BOND_BONDED);
        if (mBondState.isAutoPairingAttemptsInProgress(address)) {
            mBondState.clearPinAttempts(address);
        }
    } else if (result == BluetoothDevice.UNBOND_REASON_AUTH_FAILED && mBondState.getAttempt(address) == 1) {
        mBondState.addAutoPairingFailure(address);
        pairingAttempt(address, result);
    } else if (result == BluetoothDevice.UNBOND_REASON_REMOTE_DEVICE_DOWN && mBondState.isAutoPairingAttemptsInProgress(address)) {
        pairingAttempt(address, result);
    } else {
        setBondState(address, BluetoothDevice.BOND_NONE, result);
        if (mBondState.isAutoPairingAttemptsInProgress(address)) {
            mBondState.clearPinAttempts(address);
        }
    }
}
#end_block

#method_before
private void pairingAttempt(String address, int result) {
    // This happens when our initial guess of "0000" as the pass key
    // fails. Try to create the bond again and display the pin dialog
    // to the user. Use back-off while posting the delayed
    // message. The initial value is
    // INIT_AUTO_PAIRING_FAILURE_ATTEMPT_DELAY and the max value is
    // MAX_AUTO_PAIRING_FAILURE_ATTEMPT_DELAY. If the max value is
    // reached, display an error to the user.
    int attempt = mBondState.getAttempt(address);
    if (SystemProperties.BLUETI_ENHANCEMENT) {
        attempt = mBondState.getAttempt(address) + 1;
    }
    if (attempt * INIT_AUTO_PAIRING_FAILURE_ATTEMPT_DELAY > MAX_AUTO_PAIRING_FAILURE_ATTEMPT_DELAY) {
        mBondState.clearPinAttempts(address);
        setBondState(address, BluetoothDevice.BOND_NONE, result);
        return;
    }
    Message message = mHandler.obtainMessage(MESSAGE_AUTO_PAIRING_FAILURE_ATTEMPT_DELAY);
    message.obj = address;
    boolean postResult = mHandler.sendMessageDelayed(message, attempt * INIT_AUTO_PAIRING_FAILURE_ATTEMPT_DELAY);
    if (!postResult) {
        mBondState.clearPinAttempts(address);
        setBondState(address, BluetoothDevice.BOND_NONE, result);
        return;
    }
}
#method_after
private void pairingAttempt(String address, int result) {
    // This happens when our initial guess of "0000" as the pass key
    // fails. Try to create the bond again and display the pin dialog
    // to the user. Use back-off while posting the delayed
    // message. The initial value is
    // INIT_AUTO_PAIRING_FAILURE_ATTEMPT_DELAY and the max value is
    // MAX_AUTO_PAIRING_FAILURE_ATTEMPT_DELAY. If the max value is
    // reached, display an error to the user.
    int attempt = mBondState.getAttempt(address);
    if (SystemProperties.BLUETI_ENHANCEMENT) {
        attempt = mBondState.getAttempt(address) + 1;
    }
    if (SystemProperties.BLUETI_ENHANCEMENT) {
        if (attempt * INIT_AUTO_PAIRING_FAILURE_ATTEMPT_DELAY > MAX_AUTO_PAIRING_FAILURE_ATTEMPT_DELAY_TI) {
            mBondState.clearPinAttempts(address);
            setBondState(address, BluetoothDevice.BOND_NONE, result);
            return;
        }
    } else {
        if (attempt * INIT_AUTO_PAIRING_FAILURE_ATTEMPT_DELAY > MAX_AUTO_PAIRING_FAILURE_ATTEMPT_DELAY) {
            mBondState.clearPinAttempts(address);
            setBondState(address, BluetoothDevice.BOND_NONE, result);
            return;
        }
    }
    Message message = mHandler.obtainMessage(MESSAGE_AUTO_PAIRING_FAILURE_ATTEMPT_DELAY);
    message.obj = address;
    boolean postResult = mHandler.sendMessageDelayed(message, attempt * INIT_AUTO_PAIRING_FAILURE_ATTEMPT_DELAY);
    if (!postResult) {
        mBondState.clearPinAttempts(address);
        setBondState(address, BluetoothDevice.BOND_NONE, result);
        return;
    }
}
#end_block

#method_before
public synchronized boolean setScanMode(int mode, int duration) {
    mContext.enforceCallingOrSelfPermission(android.Manifest.permission.WRITE_SECURE_SETTINGS, "Need WRITE_SECURE_SETTINGS permission");
    boolean pairable;
    if (SystemProperties.BLUETI_ENHANCEMENT) {
        if (DBG)
            Log.d(TAG, "setScanMode(): mode " + mode);
    }
    // BLUETI_ENHANCEMENT
    boolean discoverable = false;
    switch(mode) {
        case BluetoothAdapter.SCAN_MODE_NONE:
            pairable = false;
            if (SystemProperties.BLUETI_ENHANCEMENT) {
                if (DBG)
                    Log.d(TAG, "Set BT non-connectable and non-discoverable");
                setPropertyBoolean("Connectable", false);
            } else {
                discoverable = false;
            }
            break;
        case BluetoothAdapter.SCAN_MODE_CONNECTABLE:
            pairable = true;
            if (SystemProperties.BLUETI_ENHANCEMENT) {
                if (DBG)
                    Log.d(TAG, "Set BT connectable and non-discoverable");
                setPropertyBoolean("Discoverable", false);
            } else {
                discoverable = false;
            }
            break;
        case BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE:
            pairable = true;
            if (SystemProperties.BLUETI_ENHANCEMENT) {
                if (DBG)
                    Log.d(TAG, "Set BT connectable and discoverable");
                setPropertyBoolean("Discoverable", true);
            } else {
                discoverable = true;
                if (DBG)
                    Log.d(TAG, "BT Discoverable for " + duration + " seconds");
            }
            break;
        default:
            Log.w(TAG, "Requested invalid scan mode " + mode);
            return false;
    }
    if (!SystemProperties.BLUETI_ENHANCEMENT) {
        setPropertyBoolean("Discoverable", discoverable);
        setPropertyBoolean("Pairable", pairable);
    }
    return true;
}
#method_after
public synchronized boolean setScanMode(int mode, int duration) {
    mContext.enforceCallingOrSelfPermission(android.Manifest.permission.WRITE_SECURE_SETTINGS, "Need WRITE_SECURE_SETTINGS permission");
    boolean pairable;
    // BLUETI_ENHANCEMENT
    boolean discoverable = false;
    if (SystemProperties.BLUETI_ENHANCEMENT) {
        if (DBG)
            Log.d(TAG, "setScanMode(): mode " + mode);
    }
    switch(mode) {
        case BluetoothAdapter.SCAN_MODE_NONE:
            pairable = false;
            if (SystemProperties.BLUETI_ENHANCEMENT) {
                if (DBG)
                    Log.d(TAG, "Set BT non-connectable and non-discoverable");
                setPropertyBoolean("Connectable", false);
            } else {
                discoverable = false;
            }
            break;
        case BluetoothAdapter.SCAN_MODE_CONNECTABLE:
            pairable = true;
            if (SystemProperties.BLUETI_ENHANCEMENT) {
                if (DBG)
                    Log.d(TAG, "Set BT connectable and non-discoverable");
                setPropertyBoolean("Discoverable", false);
            } else {
                discoverable = false;
            }
            break;
        case BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE:
            pairable = true;
            if (SystemProperties.BLUETI_ENHANCEMENT) {
                if (DBG)
                    Log.d(TAG, "Set BT connectable and discoverable");
                setPropertyBoolean("Discoverable", true);
            } else {
                discoverable = true;
                if (DBG)
                    Log.d(TAG, "BT Discoverable for " + duration + " seconds");
            }
            break;
        default:
            Log.w(TAG, "Requested invalid scan mode " + mode);
            return false;
    }
    if (!SystemProperties.BLUETI_ENHANCEMENT) {
        setPropertyBoolean("Discoverable", discoverable);
        setPropertyBoolean("Pairable", pairable);
    }
    return true;
}
#end_block

#method_before
/**
 * @param on true set the local Bluetooth module to be connectable
 *                and not discoverable
 *           false set the local Bluetooth module to be not connectable
 *                 and not dicoverable
 */
synchronized void switchConnectable(boolean on) {
    if (SystemProperties.BLUETI_ENHANCEMENT) {
        if (DBG)
            Log.d(TAG, "switchConnectable " + on);
        setAdapterPropertyBooleanNative("Connectable", on ? 1 : 0);
    } else {
        setAdapterPropertyBooleanNative("Powered", on ? 1 : 0);
    }
}
#method_after
/**
 * @param on true set the local Bluetooth module to be connectable
 *                The dicoverability is recovered to what it was before
 *                switchConnectable(false) call
 *           false set the local Bluetooth module to be not connectable
 *                 and not dicoverable
 * After BLUETI_ENHANCEMENT,
 * on true set the local Bluetooth module to be connectable
 *                and not discoverable
 *           false set the local Bluetooth module to be not connectable
 *                 and not dicoverable
 */
synchronized void switchConnectable(boolean on) {
    if (SystemProperties.BLUETI_ENHANCEMENT) {
        if (DBG)
            Log.d(TAG, "switchConnectable " + on);
        setAdapterPropertyBooleanNative("Connectable", on ? 1 : 0);
    } else {
        setAdapterPropertyBooleanNative("Powered", on ? 1 : 0);
    }
}
#end_block

#method_before
private void registerForAirplaneMode(IntentFilter filter) {
    final ContentResolver resolver = mContext.getContentResolver();
    final String airplaneModeRadios = Settings.System.getString(resolver, Settings.System.AIRPLANE_MODE_RADIOS);
    final String toggleableRadios = Settings.System.getString(resolver, Settings.System.AIRPLANE_MODE_TOGGLEABLE_RADIOS);
    mIsAirplaneSensitive = airplaneModeRadios == null ? true : airplaneModeRadios.contains(Settings.System.RADIO_BLUETOOTH);
    mIsAirplaneToggleable = toggleableRadios == null ? false : toggleableRadios.contains(Settings.System.RADIO_BLUETOOTH);
    if (SystemProperties.BLUETI_ENHANCEMENT)
        if (DBG)
            Log.d(TAG, "registerForAirplaneMode(): mIsAirplaneSensitive " + mIsAirplaneSensitive + " mIsAirplaneToggleable " + mIsAirplaneToggleable);
    if (mIsAirplaneSensitive) {
        filter.addAction(Intent.ACTION_AIRPLANE_MODE_CHANGED);
    }
}
#method_after
private void registerForAirplaneMode(IntentFilter filter) {
    final ContentResolver resolver = mContext.getContentResolver();
    final String airplaneModeRadios = Settings.System.getString(resolver, Settings.System.AIRPLANE_MODE_RADIOS);
    final String toggleableRadios = Settings.System.getString(resolver, Settings.System.AIRPLANE_MODE_TOGGLEABLE_RADIOS);
    mIsAirplaneSensitive = airplaneModeRadios == null ? true : airplaneModeRadios.contains(Settings.System.RADIO_BLUETOOTH);
    mIsAirplaneToggleable = toggleableRadios == null ? false : toggleableRadios.contains(Settings.System.RADIO_BLUETOOTH);
    if (SystemProperties.BLUETI_ENHANCEMENT) {
        if (DBG) {
            Log.d(TAG, "registerForAirplaneMode(): mIsAirplaneSensitive " + mIsAirplaneSensitive + " mIsAirplaneToggleable " + mIsAirplaneToggleable);
        }
    }
    if (mIsAirplaneSensitive) {
        filter.addAction(Intent.ACTION_AIRPLANE_MODE_CHANGED);
    }
}
#end_block

#method_before
public void setProfile(CamcorderProfile profile) {
    setOutputFormat(profile.fileFormat);
    setVideoFrameRate(profile.videoFrameRate);
    setVideoSize(profile.videoFrameWidth, profile.videoFrameHeight);
    setVideoEncodingBitRate(profile.videoBitRate);
    setVideoEncoder(profile.videoCodec);
    if (profile.quality >= CamcorderProfile.QUALITY_TIME_LAPSE_LOW && profile.quality <= CamcorderProfile.QUALITY_TIME_LAPSE_QVGA) {
        // Enable time lapse. Also don't set audio for time lapse.
        setParameter(String.format("time-lapse-enable=1"));
    } else {
        setAudioEncodingBitRate(profile.audioBitRate);
        setAudioChannels(profile.audioChannels);
        setAudioSamplingRate(profile.audioSampleRate);
        setAudioEncoder(profile.audioCodec);
    }
    if (SystemProperties.OMAP_ENHANCEMENT) {
        // Set Encoder Profile  from system properties for H264 Encoder
        if (profile.videoCodec == 2) {
            String encProfile;
            encProfile = SystemProperties.get("video.h264enc.profile");
            if (encProfile.equals("1") || encProfile.equals("2") || encProfile.equals("8")) {
                Log.v(TAG, "Profile read is : " + encProfile);
            } else {
                Log.v(TAG, " Profile is not set or is Invalid .. So setting Baseline as Default");
                encProfile = "1";
            }
            setParameter(String.format("video-param-encoder-profile=" + encProfile));
        }
    }
}
#method_after
public void setProfile(CamcorderProfile profile) {
    setOutputFormat(profile.fileFormat);
    setVideoFrameRate(profile.videoFrameRate);
    setVideoSize(profile.videoFrameWidth, profile.videoFrameHeight);
    setVideoEncodingBitRate(profile.videoBitRate);
    setVideoEncoder(profile.videoCodec);
    if (profile.quality >= CamcorderProfile.QUALITY_TIME_LAPSE_LOW && profile.quality <= CamcorderProfile.QUALITY_TIME_LAPSE_QVGA) {
        // Enable time lapse. Also don't set audio for time lapse.
        setParameter(String.format("time-lapse-enable=1"));
    } else {
        setAudioEncodingBitRate(profile.audioBitRate);
        setAudioChannels(profile.audioChannels);
        setAudioSamplingRate(profile.audioSampleRate);
        setAudioEncoder(profile.audioCodec);
    }
    if (SystemProperties.OMAP_ENHANCEMENT) {
        // Set Encoder Profile  from system properties for H264 Encoder
        if (profile.videoCodec == MediaRecorder.VideoEncoder.H264) {
            String encProfile;
            encProfile = SystemProperties.get("video.h264enc.profile");
            if (encProfile.equals("1") || encProfile.equals("2") || encProfile.equals("8")) {
                Log.v(TAG, "Profile read is : " + encProfile);
            } else {
                Log.v(TAG, " Profile is not set or is Invalid .. So setting Baseline as Default");
                encProfile = "1";
            }
            setParameter(String.format("video-param-encoder-profile=" + encProfile));
        }
    }
}
#end_block

#method_before
public void surfaceDestroyed(SurfaceHolder holder) {
}
#method_after
public void surfaceDestroyed(SurfaceHolder holder) {
    this.holder = null;
}
#end_block

#method_before
private void doPlayAll(int repeatCnt) {
    if ("false".equals(System.getProperty("omap.enhancement"))) {
        return;
    }
    String[] uriList;
    int ix = 0;
    int VideoMediaCnt = 0;
    String[] titles;
    for (int index = 0; index < mAlbumDataAdapter.size(); index++) {
        MediaItem item = mAlbumDataAdapter.get(index);
        if (item == null) {
            Log.w(TAG, "item not ready yet, ignore the request");
            continue;
        }
        if ((item.getSupportedOperations() & MediaItem.SUPPORT_PLAY) != 0) {
            VideoMediaCnt++;
        }
    }
    uriList = new String[VideoMediaCnt];
    titles = new String[VideoMediaCnt];
    for (int index = 0; index < mAlbumDataAdapter.size(); index++) {
        MediaItem item = mAlbumDataAdapter.get(index);
        if (item == null) {
            Log.w(TAG, "item not ready yet, ignore the request");
            continue;
        }
        if ((item.getSupportedOperations() & MediaItem.SUPPORT_PLAY) != 0) {
            uriList[ix] = item.getPlayUri().toString();
            titles[ix] = item.getName();
            ix++;
        }
    }
    PhotoPage.playVideo((Activity) mActivity, uriList, titles, repeatCnt);
}
#method_after
private void doPlayAll(int repeatCnt) {
    if ("true".equals(System.getProperty("omap.enhancement"))) {
        String[] uriList;
        int ix = 0;
        int VideoMediaCnt = 0;
        String[] titles;
        for (int index = 0; index < mAlbumDataAdapter.size(); index++) {
            MediaItem item = mAlbumDataAdapter.get(index);
            if (item == null) {
                Log.w(TAG, "item not ready yet, ignore the request");
                continue;
            }
            if ((item.getSupportedOperations() & MediaItem.SUPPORT_PLAY) != 0) {
                VideoMediaCnt++;
            }
        }
        uriList = new String[VideoMediaCnt];
        titles = new String[VideoMediaCnt];
        for (int index = 0; index < mAlbumDataAdapter.size(); index++) {
            MediaItem item = mAlbumDataAdapter.get(index);
            if (item == null) {
                Log.w(TAG, "item not ready yet, ignore the request");
                continue;
            }
            if ((item.getSupportedOperations() & MediaItem.SUPPORT_PLAY) != 0) {
                uriList[ix] = item.getPlayUri().toString();
                titles[ix] = item.getName();
                ix++;
            }
        }
        PhotoPage.playVideo((Activity) mActivity, uriList, titles, repeatCnt);
    }
}
#end_block

#method_before
public static void playVideo(Activity activity, String[] arrayuri, String[] titles, int repeatCnt) {
    if ("false".equals(System.getProperty("omap.enhancement"))) {
        return;
    }
    try {
        Intent intent = new Intent(Intent.ACTION_VIEW).setDataAndType(Uri.parse(arrayuri[0]), "video/*");
        intent.putExtra(Intent.EXTRA_TITLE, titles[0]);
        intent.putExtra("UriArray", arrayuri);
        intent.putExtra("TitlesArray", titles);
        intent.putExtra("RepeatCnt", repeatCnt);
        activity.startActivity(intent);
    } catch (ActivityNotFoundException e) {
        Toast.makeText(activity, activity.getString(R.string.video_err), Toast.LENGTH_SHORT).show();
    }
}
#method_after
public static void playVideo(Activity activity, String[] arrayuri, String[] titles, int repeatCnt) {
    if ("true".equals(System.getProperty("omap.enhancement"))) {
        try {
            Intent intent = new Intent(Intent.ACTION_VIEW).setDataAndType(Uri.parse(arrayuri[0]), "video/*");
            intent.putExtra(Intent.EXTRA_TITLE, titles[0]);
            intent.putExtra("UriArray", arrayuri);
            intent.putExtra("TitlesArray", titles);
            intent.putExtra("RepeatCnt", repeatCnt);
            activity.startActivity(intent);
        } catch (ActivityNotFoundException e) {
            Toast.makeText(activity, activity.getString(R.string.video_err), Toast.LENGTH_SHORT).show();
        }
    }
}
#end_block

#method_before
@Override
public void handleMessage(Message msg) {
    FaceResult[] faces;
    int faceCount;
    FaceResult face;
    switch(msg.what) {
        case RESTART_PREVIEW:
            {
                restartPreview();
                if (mJpegPictureCallbackTime != 0) {
                    long now = System.currentTimeMillis();
                    mJpegCallbackFinishTime = now - mJpegPictureCallbackTime;
                    Log.v(TAG, "mJpegCallbackFinishTime = " + mJpegCallbackFinishTime + "ms");
                    mJpegPictureCallbackTime = 0;
                }
                break;
            }
        case CLEAR_SCREEN_DELAY:
            {
                getWindow().clearFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);
                break;
            }
        case FIRST_TIME_INIT:
            {
                initializeFirstTime();
                mParameters.set(PARM_MANUALCONVERGENCE_VALUE, mManualConvergenceValue.intValue());
                break;
            }
        case DISPLAY_FACE:
            {
                faces = (FaceResult[]) msg.obj;
                faceCount = msg.arg1;
                int i;
                // add new FaceRectangles if needed
                if (mAllocatedFaces < faceCount) {
                    for (i = mAllocatedFaces; i < faceCount; i++) {
                        FaceRectangle faceRec = new FaceRectangle(Camera.this);
                        mFaceRectangles[i] = faceRec;
                    }
                    mAllocatedFaces = faceCount;
                }
                // Display FaceRectangles with updated coordinates
                for (i = 0; i < faceCount; i++) {
                    face = faces[i];
                    if (!mFaceRectangles[i].isVisible()) {
                        mAbsoluteLayout.addView(mFaceRectangles[i]);
                    }
                    mFaceRectangles[i].show(face.getLeft(), face.getTop(), face.getWidth(), face.getHeight());
                }
                // Hide FaceRectangles if we have less faces than previous calls
                if (mAllocatedFaces > faceCount) {
                    for (i = mAllocatedFaces; i < faceCount; i++) {
                        mFaceRectangles[i].clear();
                    }
                }
                break;
            }
        case HIDE_FACE:
            {
                for (int i = 0; i < mAllocatedFaces; i++) {
                    mAbsoluteLayout.removeView(mFaceRectangles[i]);
                    mFaceRectangles[i].clear();
                }
                break;
            }
        case SET_CAMERA_PARAMETERS_WHEN_IDLE:
            {
                setCameraParametersWhenIdle(0);
                break;
            }
        case CLEAR_FOCUS_RECT:
            {
                if (null != mHeadUpDisplay) {
                    mHeadUpDisplay.setEnabled(true);
                }
                clearFocusState();
                break;
            }
        case MANUAL_CONVERGENCE_CHANGED:
            {
                mManualConvergenceValue = (Integer) msg.obj;
                mParameters.set(PARM_MANUALCONVERGENCE_VALUE, mManualConvergenceValue.intValue());
                if (mCameraDevice != null) {
                    mCameraDevice.setParameters(mParameters);
                }
                break;
            }
        case MANUAL_EXPOSURE_CHANGED:
            {
                mManualExposureRight = (Integer) msg.obj;
                mManualExposureRight = mManualExposureRight.intValue() & 0xffff;
                mManualExposureLeft = (Integer) msg.obj;
                mManualExposureLeft = (mManualExposureLeft.intValue() >> 16) & 0xffff;
                mParameters.set(PARM_MANUAL_EXPOSURE_RIGHT, mManualExposureRight.intValue());
                mParameters.set(PARM_MANUAL_EXPOSURE_LEFT, mManualExposureLeft.intValue());
                if (mCameraDevice != null) {
                    mCameraDevice.setParameters(mParameters);
                }
                break;
            }
        case MANUAL_GAIN_CHANGED:
            {
                mManualGainRight = (Integer) msg.obj;
                mManualGainRight = mManualGainRight.intValue() & 0xffff;
                mManualGainLeft = (Integer) msg.obj;
                mManualGainLeft = (mManualGainLeft.intValue() >> 16) & 0xffff;
                mParameters.set(PARM_MANUAL_GAIN_EV_RIGHT, mManualGainRight.intValue());
                mParameters.set(PARM_MANUAL_GAIN_EV_LEFT, mManualGainLeft.intValue());
                ConvertEV2ISO isoConverter = new ConvertEV2ISO();
                mParameters.set(PARM_MANUAL_GAIN_ISO_LEFT, isoConverter.convert(100, mManualGainLeft.intValue()));
                mParameters.set(PARM_MANUAL_GAIN_ISO_RIGHT, isoConverter.convert(100, mManualGainRight.intValue()));
                if (mCameraDevice != null) {
                    mCameraDevice.setParameters(mParameters);
                }
                break;
            }
    }
}
#method_after
@Override
public void handleMessage(Message msg) {
    FaceResult[] faces;
    int faceCount;
    FaceResult face;
    switch(msg.what) {
        case RESTART_PREVIEW:
            {
                restartPreview();
                if (mJpegPictureCallbackTime != 0) {
                    long now = System.currentTimeMillis();
                    mJpegCallbackFinishTime = now - mJpegPictureCallbackTime;
                    Log.v(TAG, "mJpegCallbackFinishTime = " + mJpegCallbackFinishTime + "ms");
                    mJpegPictureCallbackTime = 0;
                }
                break;
            }
        case CLEAR_SCREEN_DELAY:
            {
                getWindow().clearFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);
                break;
            }
        case FIRST_TIME_INIT:
            {
                initializeFirstTime();
                mParameters.set(PARM_MANUALCONVERGENCE_VALUE, mManualConvergenceValue.intValue());
                break;
            }
        case DISPLAY_FACE:
            {
                faces = (FaceResult[]) msg.obj;
                faceCount = msg.arg1;
                int i;
                // add new FaceRectangles if needed
                if (mAllocatedFaces < faceCount) {
                    for (i = mAllocatedFaces; i < faceCount; i++) {
                        FaceRectangle faceRec = new FaceRectangle(Camera.this);
                        mFaceRectangles[i] = faceRec;
                    }
                    mAllocatedFaces = faceCount;
                }
                // Display FaceRectangles with updated coordinates
                for (i = 0; i < faceCount; i++) {
                    face = faces[i];
                    if (!mFaceRectangles[i].isVisible()) {
                        mAbsoluteLayout.addView(mFaceRectangles[i]);
                    }
                    mFaceRectangles[i].show(face.getLeft(), face.getTop(), face.getWidth(), face.getHeight());
                }
                // Hide FaceRectangles if we have less faces than previous calls
                if (mAllocatedFaces > faceCount) {
                    for (i = (mAllocatedFaces - 1); i >= faceCount; i--) {
                        mAbsoluteLayout.removeView(mFaceRectangles[i]);
                        mFaceRectangles[i].clear();
                    }
                }
                break;
            }
        case HIDE_FACE:
            {
                for (int i = 0; i < mAllocatedFaces; i++) {
                    mAbsoluteLayout.removeView(mFaceRectangles[i]);
                    mFaceRectangles[i].clear();
                }
                break;
            }
        case SET_CAMERA_PARAMETERS_WHEN_IDLE:
            {
                setCameraParametersWhenIdle(0);
                break;
            }
        case CLEAR_FOCUS_RECT:
            {
                if (null != mHeadUpDisplay) {
                    mHeadUpDisplay.setEnabled(true);
                }
                clearFocusState();
                break;
            }
        case MANUAL_CONVERGENCE_CHANGED:
            {
                mManualConvergenceValue = (Integer) msg.obj;
                mParameters.set(PARM_MANUALCONVERGENCE_VALUE, mManualConvergenceValue.intValue());
                if (mCameraDevice != null) {
                    mCameraDevice.setParameters(mParameters);
                }
                break;
            }
        case MANUAL_GAIN_EXPOSURE_CHANGED:
            {
                Bundle data;
                data = msg.getData();
                ConvertEV2ISO isoConverter = new ConvertEV2ISO();
                mManualExposureRight = data.getInt("EXPOSURE_RIGHT");
                if (mManualExposureRight < 1) {
                    mManualExposureRight = 1;
                }
                mManualExposureLeft = data.getInt("EXPOSURE_LEFT");
                if (mManualExposureLeft < 1) {
                    mManualExposureLeft = 1;
                }
                mManualGainEVRight = data.getInt("GAIN_EV_RIGHT");
                mManualGainEVLeft = data.getInt("GAIN_EV_LEFT");
                mManualGainRight = isoConverter.convert(100, mManualGainEVRight);
                if (mManualGainRight < 100) {
                    mManualGainRight = 100;
                }
                mManualGainLeft = isoConverter.convert(100, mManualGainEVLeft);
                if (mManualGainLeft < 100) {
                    mManualGainLeft = 100;
                }
                mParameters.set(PARM_MANUAL_EXPOSURE_RIGHT, mManualExposureRight.intValue());
                mParameters.set(PARM_MANUAL_EXPOSURE_LEFT, mManualExposureLeft.intValue());
                mParameters.set(PARM_MANUAL_GAIN_ISO_LEFT, mManualGainLeft.intValue());
                mParameters.set(PARM_MANUAL_GAIN_ISO_RIGHT, mManualGainRight.intValue());
                if (mCameraDevice != null) {
                    mCameraDevice.setParameters(mParameters);
                }
                break;
            }
    }
}
#end_block

#method_before
@Override
public boolean onDown(MotionEvent e) {
    if (mTouchFocusEnabled) {
        int x = (int) e.getX();
        int y = (int) e.getY();
        android.widget.FrameLayout frame = (android.widget.FrameLayout) findViewById(R.id.frame);
        mFocusHorizontalOffset = frame.getLeft();
        mFocusVerticalOffset = frame.getTop();
        mFocusHorizontalOffset += mSurfaceView.getLeft();
        mFocusVerticalOffset += mSurfaceView.getTop();
        x -= (mTouchFocusRectangleWidth / 2 + mFocusHorizontalOffset);
        y -= (mTouchFocusRectangleHeight / 2 + mFocusVerticalOffset);
        if ((x < 0) || (x > mSurfaceView.getWidth() - mTouchFocusRectangleWidth / 2))
            return true;
        if ((y < 0) || (y > mSurfaceView.getHeight() - mTouchFocusRectangleHeight / 2))
            return true;
        mTouchFocusRectangle.show(x, y, mTouchFocusRectangleWidth, mTouchFocusRectangleHeight);
        int previewWidth = mParameters.getPreviewSize().width;
        int previewHeight = mParameters.getPreviewSize().height;
        double scaleX = ((double) previewWidth) / ((double) mSurfaceView.getWidth());
        double scaleY = ((double) previewHeight) / ((double) mSurfaceView.getHeight());
        x += mTouchFocusRectangleWidth / 2;
        y += mTouchFocusRectangleHeight / 2;
        x *= scaleX;
        y *= scaleY;
        mParameters.set(PARM_TOUCH_COORD, x + "," + y);
        mCameraDevice.setParameters(mParameters);
        doFocus(true);
    } else if (mTouchConvergenceEnabled) {
        int x = (int) e.getX();
        int y = (int) e.getY();
        android.widget.FrameLayout frame = (android.widget.FrameLayout) findViewById(R.id.frame);
        mFocusHorizontalOffset = frame.getLeft();
        mFocusVerticalOffset = frame.getTop();
        mFocusHorizontalOffset += mSurfaceView.getLeft();
        mFocusVerticalOffset += mSurfaceView.getTop();
        x -= mFocusHorizontalOffset;
        y -= mFocusVerticalOffset;
        if ((x < 0) || (x > mSurfaceView.getWidth()))
            return true;
        if ((y < 0) || (y > mSurfaceView.getHeight()))
            return true;
        int previewWidth = mParameters.getPreviewSize().width;
        int previewHeight = mParameters.getPreviewSize().height;
        double scaleX = ((double) previewWidth) / ((double) mSurfaceView.getWidth());
        double scaleY = ((double) previewHeight) / ((double) mSurfaceView.getHeight());
        x *= scaleX;
        y *= scaleY;
        mParameters.set(PARM_AUTOCONVERGENCE_COORDS, x + "," + y);
        mCameraDevice.setParameters(mParameters);
    }
    return true;
}
#method_after
@Override
public boolean onDown(MotionEvent e) {
    if (mTouchFocusEnabled || mTouchConvergenceEnabled) {
        int x = (int) e.getX();
        int y = (int) e.getY();
        android.widget.FrameLayout frame = (android.widget.FrameLayout) findViewById(R.id.frame);
        mFocusHorizontalOffset = frame.getLeft();
        mFocusVerticalOffset = frame.getTop();
        mFocusHorizontalOffset += mSurfaceView.getLeft();
        mFocusVerticalOffset += mSurfaceView.getTop();
        x -= mFocusHorizontalOffset;
        y -= mFocusVerticalOffset;
        if ((x < 0) || (x > mSurfaceView.getWidth()))
            return true;
        if ((y < 0) || (y > mSurfaceView.getHeight()))
            return true;
        double scaleX = ((double) mPreviewWidth) / ((double) mSurfaceView.getWidth());
        double scaleY = ((double) mPreviewHeight) / ((double) mSurfaceView.getHeight());
        mParameters.set(PARM_TOUCH_COORD, (x * scaleX) + "," + (y * scaleY));
        mCameraDevice.setParameters(mParameters);
        if (mTouchFocusEnabled) {
            if (x > (mTouchFocusRectangleWidth / 2))
                x -= (mTouchFocusRectangleWidth / 2);
            else
                x = 0;
            if ((x + mTouchFocusRectangleWidth) > mSurfaceView.getWidth())
                x = mSurfaceView.getWidth() - mTouchFocusRectangleWidth;
            if (y > (mTouchFocusRectangleHeight / 2))
                y -= (mTouchFocusRectangleHeight / 2);
            else
                y = 0;
            if ((y + mTouchFocusRectangleHeight) > mSurfaceView.getHeight())
                y = mSurfaceView.getHeight() - mTouchFocusRectangleHeight;
            mTouchFocusRectangle.show(x, y, mTouchFocusRectangleWidth, mTouchFocusRectangleHeight);
            doFocus(true);
        }
    }
    return true;
}
#end_block

#method_before
private void resetLocalParameters() {
    mLastPreviewFramerate = getString(R.string.pref_omap4_camera_previewframerate_default);
    mSceneMode = getString(R.string.pref_omap4_camera_scenemode_default);
    mBurstImages = Integer.parseInt(getString(R.string.pref_omap4_camera_burst_default));
    mExposureMode = null;
    mLastPreviewSize = null;
    mLastGBCEMode = null;
    mCurrentMode = null;
    mLastS3D2DMode = null;
    mPreviewFormat = null;
    mPictureSize = null;
    mISO = null;
    mBracketRange = null;
    mAntibanding = null;
    mSaturation = null;
    mSharpness = null;
    mBrightness = null;
    mContrast = null;
    mJpegQuality = null;
    mColorEffect = null;
    mExposure = null;
    mFlashMode = null;
    mWhiteBalance = null;
    mFocusMode = null;
    mShutter = null;
    mFaceDetection = null;
    mThumbnailMode = null;
}
#method_after
private void resetLocalParameters() {
    mLastPreviewFramerate = getString(R.string.pref_omap4_camera_previewframerate_default);
    mSceneMode = getString(R.string.pref_omap4_camera_scenemode_default);
    mBurstImages = Integer.parseInt(getString(R.string.pref_omap4_camera_burst_default));
    mExposureMode = null;
    mLastPreviewSize = null;
    mLastGBCEMode = null;
    mCurrentMode = null;
    mLastS3D2DMode = null;
    mS3DFrameLayout = null;
    mPreviewFormat = null;
    mPictureSize = null;
    mISO = null;
    mBracketRange = null;
    mAntibanding = null;
    mSaturation = null;
    mSharpness = null;
    mBrightness = null;
    mContrast = null;
    mJpegQuality = null;
    mColorEffect = null;
    mExposure = null;
    mFlashMode = null;
    mWhiteBalance = null;
    mFocusMode = null;
    mShutter = null;
    mFaceDetection = null;
    mThumbnailMode = null;
}
#end_block

#method_before
private void overrideHudSettings(final String flashMode, final String whiteBalance, final String focusMode, final String colorEffect, final String gbce, final String bracketRange, final String burstCount) {
    mHeadUpDisplay.overrideSettings(CameraSettings.KEY_FLASH_MODE, flashMode);
    mHeadUpDisplay.overrideSettings(CameraSettings.KEY_WHITE_BALANCE, whiteBalance);
    mHeadUpDisplay.overrideSettings(CameraSettings.KEY_FOCUS_MODE, focusMode);
    mHeadUpDisplay.overrideSettings(CameraSettings.KEY_COLOR_EFFECT, colorEffect);
    mHeadUpDisplay.overrideSettings(CameraSettings.KEY_BURST, burstCount);
    mHeadUpDisplay.overrideSettings(CameraSettings.KEY_BRACKET_RANGE, bracketRange);
    mHeadUpDisplay.overrideSettings(CameraSettings.KEY_GBCE, gbce);
}
#method_after
private void overrideHudSettings(final String flashMode, final String whiteBalance, final String focusMode, final String colorEffect, final String gbce, final String iso, final String sharpness, final String bracketRange, final String burstCount) {
    mHeadUpDisplay.overrideSettings(CameraSettings.KEY_FLASH_MODE, flashMode);
    mHeadUpDisplay.overrideSettings(CameraSettings.KEY_WHITE_BALANCE, whiteBalance);
    mHeadUpDisplay.overrideSettings(CameraSettings.KEY_FOCUS_MODE, focusMode);
    mHeadUpDisplay.overrideSettings(CameraSettings.KEY_COLOR_EFFECT, colorEffect);
    mHeadUpDisplay.overrideSettings(CameraSettings.KEY_ISO, iso);
    mHeadUpDisplay.overrideSettings(CameraSettings.KEY_SHARPNESS, sharpness);
    mHeadUpDisplay.overrideSettings(CameraSettings.KEY_BURST, burstCount);
    mHeadUpDisplay.overrideSettings(CameraSettings.KEY_BRACKET_RANGE, bracketRange);
    mHeadUpDisplay.overrideSettings(CameraSettings.KEY_GBCE, gbce);
}
#end_block

#method_before
private void updateHud() {
    String whiteBalance, flash, focus, effect, gbce, bracketRange, burstCount;
    bracketRange = null;
    whiteBalance = null;
    flash = null;
    effect = null;
    focus = null;
    gbce = null;
    burstCount = null;
    if (!Parameters.SCENE_MODE_AUTO.equals(mSceneMode)) {
        whiteBalance = mParameters.getWhiteBalance();
        flash = mParameters.getFlashMode();
        focus = mParameters.getFocusMode();
        effect = mParameters.getColorEffect();
    } else {
        whiteBalance = null;
        flash = null;
        effect = null;
        focus = null;
    }
    if (mTempBracketingEnabled) {
        bracketRange = null;
    } else {
        bracketRange = getString(R.string.pref_omap4_camera_bracketrange_default);
    }
    if (mCurrentMode.equals(PARM_EXPOSURE_BRACKETING) || mCurrentMode.equals(PARM_TEMPORAL_BRACKETING)) {
        burstCount = getString(R.string.pref_omap4_camera_burst_default);
    } else {
        burstCount = null;
    }
    if (!mCurrentMode.equals(PARM_HQ_MODE)) {
        gbce = getString(R.string.pref_omap4_camera_gbce_default);
    } else {
        gbce = null;
    }
    overrideHudSettings(flash, whiteBalance, focus, effect, gbce, bracketRange, burstCount);
}
#method_after
private void updateHud() {
    String whiteBalance;
    String flash;
    String focus;
    String effect;
    String gbce;
    String bracketRange;
    String burstCount;
    String iso;
    String sharpness;
    bracketRange = null;
    whiteBalance = null;
    flash = null;
    effect = null;
    focus = null;
    gbce = null;
    burstCount = null;
    iso = null;
    sharpness = null;
    if (!Parameters.SCENE_MODE_AUTO.equals(mSceneMode)) {
        whiteBalance = mParameters.getWhiteBalance();
        flash = mParameters.getFlashMode();
        focus = mParameters.getFocusMode();
        effect = mParameters.getColorEffect();
        iso = mParameters.get(PARM_ISO);
        sharpness = mParameters.get(PARM_SHARPNESS);
    } else {
        whiteBalance = null;
        flash = null;
        effect = null;
        focus = null;
        iso = null;
        sharpness = null;
    }
    if (mTempBracketingEnabled) {
        bracketRange = null;
    } else {
        bracketRange = getString(R.string.pref_omap4_camera_bracketrange_default);
    }
    if (mCurrentMode.equals(PARM_EXPOSURE_BRACKETING) || mCurrentMode.equals(PARM_TEMPORAL_BRACKETING)) {
        burstCount = getString(R.string.pref_omap4_camera_burst_default);
    } else {
        burstCount = null;
    }
    if (!mCurrentMode.equals(PARM_HQ_MODE)) {
        gbce = getString(R.string.pref_omap4_camera_gbce_default);
    } else {
        gbce = null;
    }
    overrideHudSettings(flash, whiteBalance, focus, effect, gbce, iso, sharpness, bracketRange, burstCount);
}
#end_block

#method_before
private void initializeHeadUpDisplay() {
    CameraSettings settings = new CameraSettings(this, mInitialParams, CameraHolder.instance().getCameraInfo());
    mCameraSettings = settings;
    mPreferenceGroup = mCameraSettings.getPreferenceGroup(R.xml.camera_preferences);
    boolean isS3d = false;
    String valstr;
    Parameters params = mCameraDevice.getParameters();
    if ((valstr = params.get("s3d-supported")) != null) {
        isS3d = valstr.equals("true");
    }
    ListPreference videoStabilization = mPreferenceGroup.findPreference(CameraSettings.KEY_VSTAB);
    if ((videoStabilization != null) && isS3d) {
        // Enable the vstab stereo option only for stereo sensors based on support at HAL level
        mCameraSettings.filterUnsupportedOptions(mPreferenceGroup, videoStabilization, mCameraSettings.parseToList(params.get(Camera.PARM_VSTAB_VALUES)));
    } else {
        // /Filter out vstab option for image mode for 2D sensors
        mCameraSettings.filterUnsupportedOptions(mPreferenceGroup, videoStabilization, null);
    }
    mHeadUpDisplay.initialize(this, mPreferenceGroup, getZoomRatios(), mOrientationCompensation);
    if (mParameters.isZoomSupported()) {
        mHeadUpDisplay.setZoomListener(new ZoomControllerListener() {

            public void onZoomChanged(int index, float ratio, boolean isMoving) {
                onZoomValueChanged(index);
            }
        });
    }
    updateHud();
}
#method_after
private void initializeHeadUpDisplay() {
    CameraSettings settings = new CameraSettings(this, mInitialParams, CameraHolder.instance().getCameraInfo());
    mCameraSettings = settings;
    mPreferenceGroup = mCameraSettings.getPreferenceGroup(R.xml.camera_preferences);
    boolean isS3d = false;
    String valstr;
    Parameters params = mCameraDevice.getParameters();
    if ((valstr = params.get(PARM_S3D_SUPPORTED)) != null) {
        isS3d = valstr.equals("true");
    }
    ListPreference videoStabilization = mPreferenceGroup.findPreference(CameraSettings.KEY_VSTAB);
    if ((videoStabilization != null) && isS3d) {
        // Enable the vstab stereo option only for stereo sensors based on support at HAL level
        mCameraSettings.filterUnsupportedOptions(mPreferenceGroup, videoStabilization, mCameraSettings.parseToList(params.get(Camera.PARM_VSTAB_VALUES)));
    } else {
        // /Filter out vstab option for image mode for 2D sensors
        mCameraSettings.filterUnsupportedOptions(mPreferenceGroup, videoStabilization, null);
    }
    mHeadUpDisplay.initialize(this, mPreferenceGroup, getZoomRatios(), mOrientationCompensation);
    if (mParameters.isZoomSupported()) {
        mHeadUpDisplay.setZoomListener(new ZoomControllerListener() {

            public void onZoomChanged(int index, float ratio, boolean isMoving) {
                onZoomValueChanged(index);
            }
        });
    }
    updateHud();
}
#end_block

#method_before
private void startPreview() throws CameraHardwareException {
    if (mPausing || isFinishing())
        return;
    ensureCameraDevice();
    // the screen).
    if (mPreviewing)
        stopPreview();
    setPreviewDisplay(mSurfaceHolder);
    Util.setCameraDisplayOrientation(this, mCameraId, mCameraDevice);
    setCameraParameters(UPDATE_PARAM_ALL);
    mCameraDevice.setErrorCallback(mErrorCallback);
    try {
        Log.v(TAG, "startPreview");
        mCameraDevice.startPreview();
    } catch (Throwable ex) {
        closeCamera();
        throw new RuntimeException("startPreview failed", ex);
    }
    mPreviewing = true;
    mZoomState = ZOOM_STOPPED;
    mStatus = IDLE;
    mCurrentPreviewSize = mParameters.getPreviewSize();
}
#method_after
private void startPreview() throws CameraHardwareException {
    if (mPausing || isFinishing())
        return;
    ensureCameraDevice();
    // the screen).
    if (mPreviewing)
        stopPreview();
    setPreviewDisplay(mSurfaceHolder);
    Util.setCameraDisplayOrientation(this, mCameraId, mCameraDevice);
    setCameraParameters(UPDATE_PARAM_ALL);
    mCameraDevice.setErrorCallback(mErrorCallback);
    try {
        Log.v(TAG, "startPreview");
        mCameraDevice.startPreview();
    } catch (Throwable ex) {
        closeCamera();
        throw new RuntimeException("startPreview failed", ex);
    }
    mPreviewing = true;
    mZoomState = ZOOM_STOPPED;
    mStatus = IDLE;
}
#end_block

#method_before
private void updatePreviewAspectRatio() {
    Size size = mParameters.getPictureSize();
    PreviewFrameLayout frameLayout = (PreviewFrameLayout) findViewById(R.id.frame_layout);
    frameLayout.setAspectRatio((double) size.width / size.height);
}
#method_after
private void updatePreviewAspectRatio() {
    int index = mLastPreviewSize.indexOf('x');
    if (index == -1)
        return;
    mPreviewWidth = Integer.parseInt(mLastPreviewSize.substring(0, index));
    mPreviewHeight = Integer.parseInt(mLastPreviewSize.substring(index + 1));
    PreviewFrameLayout frameLayout = (PreviewFrameLayout) findViewById(R.id.frame_layout);
    frameLayout.setAspectRatio((double) mPreviewWidth / mPreviewHeight);
}
#end_block

#method_before
private void updateCameraParametersPreference() {
    boolean restartPreview = false;
    // get overridden by 'ensureCameraDevice()'
    if (null == mCameraDevice) {
        return;
    }
    // Set picture size.
    String pictureSize = mPreferences.getString(CameraSettings.KEY_PICTURE_SIZE, null);
    if (pictureSize == null) {
        CameraSettings.initialCameraPictureSize(this, mParameters);
    } else if (!pictureSize.equals(mPictureSize)) {
        List<Size> supported = mParameters.getSupportedPictureSizes();
        CameraSettings.setCameraPictureSize(pictureSize, supported, mParameters);
        mPictureSize = pictureSize;
    }
    updatePreviewAspectRatio();
    String previewSize = mPreferences.getString(CameraSettings.KEY_PREVIEW_SIZE, getString(R.string.pref_omap4_camera_previewsize_default));
    if (!previewSize.equals(mLastPreviewSize)) {
        CameraSettings.setCameraPreviewSize(previewSize, mParameters.getSupportedPreviewSizes(), mParameters);
        mLastPreviewSize = previewSize;
        restartPreview = true;
    }
    String gbce = mPreferences.getString(CameraSettings.KEY_GBCE, getString(R.string.pref_omap4_camera_gbce_default));
    if (!gbce.equals(mLastGBCEMode)) {
        setGBCEGLBCE(gbce, mParameters);
        mLastGBCEMode = gbce;
    }
    String s3d2d = mPreferences.getString(CameraSettings.KEY_S3D2D_PREVIEW_MODE, getString(R.string.pref_omap4_camera_s3d2dpreview_default));
    if (!s3d2d.equals(mLastS3D2DMode)) {
        mParameters.set(PARM_S3D2DPREVIEW, s3d2d);
        mLastS3D2DMode = s3d2d;
        restartPreview = true;
    }
    String framerate = mPreferences.getString(CameraSettings.KEY_PREVIEW_FRAMERATE, getString(R.string.pref_omap4_camera_previewframerate_default));
    if (!framerate.equals(mLastPreviewFramerate)) {
        CameraSettings.setCameraPreviewFramerate(Integer.parseInt(framerate), mParameters.getSupportedPreviewFrameRates(), mParameters);
        mLastPreviewFramerate = framerate;
        restartPreview = true;
    }
    String previewFormat = mPreferences.getString(CameraSettings.KEY_PREVIEW_FORMAT, getString(R.string.pref_omap4_camera_prevformat_default));
    if (!previewFormat.equals(mPreviewFormat)) {
        mParameters.setPreviewFormat(Integer.parseInt(previewFormat));
        mPreviewFormat = previewFormat;
        restartPreview = true;
    }
    String iso = mPreferences.getString(CameraSettings.KEY_ISO, getString(R.string.pref_omap4_camera_iso_default));
    if (!iso.equals(mISO)) {
        mParameters.set(PARM_ISO, iso);
        mISO = iso;
    }
    String mode = mPreferences.getString(CameraSettings.KEY_MODE, getString(R.string.pref_omap4_camera_mode_default));
    if (!mode.equals(mCurrentMode)) {
        setCaptureMode(mode, mParameters);
        restartPreview = true;
        mCurrentMode = mode;
    }
    String bracketRange = mPreferences.getString(CameraSettings.KEY_BRACKET_RANGE, getString(R.string.pref_omap4_camera_bracketrange_default));
    if (!bracketRange.equals(mBracketRange)) {
        mParameters.set(PARM_TEMPORAL_BRACKETING_RANGE_POS, Integer.parseInt(bracketRange));
        mParameters.set(PARM_TEMPORAL_BRACKETING_RANGE_NEG, Integer.parseInt(bracketRange));
        mBracketRange = bracketRange;
    }
    String sensorOrientation = getString(R.string.pref_omap4_camera_sensor_orientation_default);
    mParameters.set(PARM_SENSOR_ORIENTATION, sensorOrientation);
    String scene = mPreferences.getString(CameraSettings.KEY_SCENE_MODE, getString(R.string.pref_omap4_camera_scenemode_default));
    if (isSupported(mSceneMode, mParameters.getSupportedSceneModes()) && !mSceneMode.equals(scene)) {
        mParameters.setSceneMode(scene);
        mSceneMode = scene;
        // Disables effects in case a scene different from 'auto' is selected
        if (!Parameters.SCENE_MODE_AUTO.equals(scene)) {
            Editor edit = mPreferences.edit();
            edit.putString(CameraSettings.KEY_COLOR_EFFECT, Parameters.EFFECT_NONE);
            edit.commit();
            if (mHeadUpDisplay != null) {
                mHeadUpDisplay.reloadPreferences();
            }
            mParameters.setColorEffect(Parameters.EFFECT_NONE);
        }
    }
    String antibanding = mPreferences.getString(CameraSettings.KEY_ANTIBANDING, getString(R.string.pref_omap4_camera_antibanding_default));
    if (!antibanding.equals(mAntibanding)) {
        mParameters.setAntibanding(antibanding);
        mAntibanding = antibanding;
    }
    String saturation = mPreferences.getString(CameraSettings.KEY_SATURATION, getString(R.string.pref_omap4_camera_saturation_default));
    if (!saturation.equals(mSaturation)) {
        mParameters.set(PARM_SATURATION, Integer.parseInt(saturation));
        mSaturation = saturation;
    }
    String sharpness = mPreferences.getString(CameraSettings.KEY_SHARPNESS, getString(R.string.pref_omap4_camera_sharpness_default));
    if (!sharpness.equals(mSharpness)) {
        mParameters.set(PARM_SHARPNESS, Integer.parseInt(sharpness));
        mSharpness = sharpness;
    }
    String brightness = mPreferences.getString(CameraSettings.KEY_BRIGHTNESS, getString(R.string.pref_omap4_camera_brightness_default));
    if (!brightness.equals(mBrightness)) {
        mParameters.set(PARM_BRIGHTNESS, Integer.parseInt(brightness));
        mBrightness = brightness;
    }
    String contrast = mPreferences.getString(CameraSettings.KEY_CONTRAST, getString(R.string.pref_omap4_camera_contrast_default));
    if (!contrast.equals(mContrast)) {
        mParameters.set(PARM_CONTRAST, Integer.parseInt(contrast));
        mContrast = contrast;
    }
    String exposureMode = mPreferences.getString(CameraSettings.KEY_EXPOSURE_MODE, getString(R.string.pref_omap4_camera_exposuremode_default));
    if (!exposureMode.equals(mExposureMode)) {
        mParameters.set(PARM_EXPOSURE_MODE, exposureMode);
        mExposureMode = exposureMode;
    }
    String shutter = mPreferences.getString(CameraSettings.KEY_SHUTTER, getString(R.string.pref_omap4_camera_shutter_default));
    if (!shutter.equals(mShutter)) {
        mParameters.set(PARM_SHUTTER, shutter);
        mShutter = shutter;
    }
    String thumbnail = mPreferences.getString(CameraSettings.KEY_THUMBNAIL, getString(R.string.pref_omap4_camera_thumbnail_default));
    if (!thumbnail.equals(mThumbnailMode)) {
        mThumbnailMode = thumbnail;
        setThumbnailMode(thumbnail);
    }
    updateOrientationPreference();
    int burst = Integer.parseInt(mPreferences.getString(CameraSettings.KEY_BURST, getString(R.string.pref_omap4_camera_burst_default)));
    if ((burst != mBurstImages) && (!mCurrentMode.equals(PARM_EXPOSURE_BRACKETING) && (!mCurrentMode.equals(PARM_TEMPORAL_BRACKETING)))) {
        mBurstImages = burst;
        restartPreview = true;
        if (0 < mBurstImages) {
            setCaptureMode(PARM_HS_MODE, mParameters);
        }
        mParameters.set(PARM_BURST, mBurstImages);
    }
    String face = mPreferences.getString(CameraSettings.KEY_FACE_DETECTION, getString(R.string.pref_omap4_camera_face_default));
    if (!face.equals(mFaceDetection)) {
        mFaceDetection = face;
        restartPreview = true;
        mParameters.set(PARM_FACE_DETECTION, face);
    }
    String jpegQuality = mPreferences.getString(CameraSettings.KEY_JPEG_QUALITY, getString(R.string.pref_omap4_camera_jpegquality_default));
    if (!jpegQuality.equals(mJpegQuality)) {
        mParameters.setJpegQuality(JpegEncodingQualityMappings.getQualityNumber(jpegQuality));
        mJpegQuality = jpegQuality;
    }
    int thumbWidth = Integer.parseInt(getString(R.string.pref_omap4_camera_thumbwidth_default));
    int thumbHeight = Integer.parseInt(getString(R.string.pref_omap4_camera_thumbheight_default));
    mParameters.setJpegThumbnailSize(thumbWidth, thumbHeight);
    int thumbQuality = Integer.parseInt(getString(R.string.pref_omap4_camera_thumbquality_default));
    mParameters.setJpegThumbnailQuality(thumbQuality);
    String colorEffect = mPreferences.getString(CameraSettings.KEY_COLOR_EFFECT, getString(R.string.pref_omap4_camera_coloreffect_default));
    if (isSupported(colorEffect, mParameters.getSupportedColorEffects()) && !colorEffect.equals(mColorEffect)) {
        mParameters.setColorEffect(colorEffect);
        mColorEffect = colorEffect;
    }
    String exposure = mPreferences.getString(CameraSettings.KEY_EXPOSURE, getString(R.string.pref_omap4_exposure_default));
    if (!exposure.equals(mExposure)) {
        try {
            int value = Integer.parseInt(exposure);
            int max = mParameters.getMaxExposureCompensation();
            int min = mParameters.getMinExposureCompensation();
            if (value >= min && value <= max) {
                mParameters.setExposureCompensation(value);
            } else {
                Log.w(TAG, "invalid exposure range: " + exposure);
            }
        } catch (NumberFormatException e) {
            Log.w(TAG, "invalid exposure: " + exposure);
        }
        mExposure = exposure;
    }
    if (mGLRootView != null)
        updateHud();
    String flashMode = mPreferences.getString(CameraSettings.KEY_FLASH_MODE, getString(R.string.pref_omap4_camera_flashmode_default));
    List<String> supportedFlash = mParameters.getSupportedFlashModes();
    if (!flashMode.equals(mFlashMode)) {
        if (isSupported(flashMode, supportedFlash)) {
            mParameters.setFlashMode(flashMode);
        } else {
            flashMode = mParameters.getFlashMode();
            if (flashMode == null) {
                flashMode = getString(R.string.pref_omap4_camera_flashmode_no_flash);
            }
        }
        mFlashMode = flashMode;
    }
    String whiteBalance = mPreferences.getString(CameraSettings.KEY_WHITE_BALANCE, getString(R.string.pref_omap4_camera_whitebalance_default));
    if (!whiteBalance.equals(mWhiteBalance)) {
        if (isSupported(whiteBalance, mParameters.getSupportedWhiteBalance())) {
            mParameters.setWhiteBalance(whiteBalance);
        } else {
            whiteBalance = mParameters.getWhiteBalance();
            if (whiteBalance == null) {
                whiteBalance = Parameters.WHITE_BALANCE_AUTO;
            }
        }
        mWhiteBalance = whiteBalance;
    }
    String focusMode = mPreferences.getString(CameraSettings.KEY_FOCUS_MODE, getString(R.string.pref_omap4_camera_focusmode_default));
    if (focusMode.equals(PARM_TOUCH_FOCUS)) {
        mTouchFocusEnabled = true;
    } else {
        mTouchFocusEnabled = false;
    }
    if (!focusMode.equals(mFocusMode)) {
        if (isSupported(focusMode, mParameters.getSupportedFocusModes())) {
            mParameters.setFocusMode(focusMode);
        } else {
            focusMode = mParameters.getFocusMode();
            if (focusMode == null) {
                focusMode = Parameters.FOCUS_MODE_AUTO;
            }
        }
        mFocusMode = focusMode;
    }
    String mAutoConvergenceMode = mPreferences.getString(CameraSettings.KEY_AUTOCONVERGENCE_MODE, getString(R.string.pref_omap4_camera_autoconvergence_default));
    if (mAutoConvergenceMode.equals(PARM_AUTOCONVERGENCE_FFT)) {
        mTouchConvergenceEnabled = true;
    } else {
        mTouchConvergenceEnabled = false;
    }
    if (mAutoConvergenceMode.equals(PARM_AUTOCONVERGENCE_MANUAL) && mACManualOff) {
        if (mHeadUpDisplay != null) {
            mACManualOff = false;
            if (Integer.decode(mParameters.get(PARM_MANUALCONVERGENCE_VALUE)) != null) {
                Integer.parseInt(mParameters.get(PARM_MANUALCONVERGENCE_VALUE));
            }
            AutoConvergenceSettings mcsDialog = new AutoConvergenceSettings(this, mHandler, mManualConvergenceValue.intValue());
            if (mAbsoluteLayout != null) {
                mcsDialog.show();
            }
        } else if (mAutoConvergenceMode.equals(PARM_AUTOCONVERGENCE_MANUAL)) {
            mAutoConvergenceMode = getString(R.string.pref_omap4_camera_autoconvergence_default);
            Editor edit = mPreferences.edit();
            edit.putString(CameraSettings.KEY_AUTOCONVERGENCE_MODE, mAutoConvergenceMode);
            edit.commit();
            mACManualOff = true;
        }
    }
    if (!mAutoConvergenceMode.equals(PARM_AUTOCONVERGENCE_MANUAL)) {
        mACManualOff = true;
    }
    mParameters.set(PARM_AUTOCONVERGENCE, mAutoConvergenceMode);
    String manualExposure = mPreferences.getString(CameraSettings.KEY_MANUAL_EXPOSURE, getString(R.string.pref_omap4_camera_manual_exposure_default));
    if (manualExposure.equals(getString(R.string.pref_omap4_camera_manual_exposure_on)) && mManualExposureOff) {
        if (mHeadUpDisplay != null) {
            mManualExposureOff = false;
            if (mManualExposureLeft.decode(mParameters.get(PARM_MANUAL_EXPOSURE_LEFT)) != null) {
                mManualExposureLeft.parseInt(mParameters.get(PARM_MANUAL_EXPOSURE_LEFT));
                mManualExposureRight.parseInt(mParameters.get(PARM_MANUAL_EXPOSURE_RIGHT));
            }
            ManualExposureSettings manualExposureDialog = new ManualExposureSettings(this, mHandler, mManualExposureLeft.intValue(), mManualExposureRight.intValue());
            if (mAbsoluteLayout != null) {
                manualExposureDialog.show();
            }
        } else if (manualExposure.equals(getString(R.string.pref_omap4_camera_manual_exposure_on))) {
            manualExposure = getString(R.string.pref_omap4_camera_manual_exposure_default);
            Editor edit = mPreferences.edit();
            edit.putString(CameraSettings.KEY_MANUAL_EXPOSURE, manualExposure);
            edit.commit();
            mManualExposureOff = true;
            mParameters.set(PARM_MANUAL_EXPOSURE_LEFT, 0);
            mParameters.set(PARM_MANUAL_EXPOSURE_RIGHT, 0);
        }
    }
    if (!manualExposure.equals(getString(R.string.pref_omap4_camera_manual_exposure_on))) {
        mManualExposureOff = true;
        mParameters.set(PARM_MANUAL_EXPOSURE_LEFT, 0);
        mParameters.set(PARM_MANUAL_EXPOSURE_RIGHT, 0);
    }
    mParameters.set(PARM_MANUAL_EXPOSURE_MODES, manualExposure);
    String manualGain = mPreferences.getString(CameraSettings.KEY_MANUAL_GAIN, getString(R.string.pref_omap4_camera_manual_gain_default));
    if (manualGain.equals(getString(R.string.pref_omap4_camera_manual_gain_on)) && mManualGainOff) {
        if (mHeadUpDisplay != null) {
            mManualGainOff = false;
            if (mManualGainLeft.decode(mParameters.get(PARM_MANUAL_GAIN_EV_LEFT)) != null) {
                mManualGainLeft.parseInt(mParameters.get(PARM_MANUAL_GAIN_EV_LEFT));
                mManualGainRight.parseInt(mParameters.get(PARM_MANUAL_GAIN_EV_RIGHT));
            }
            ManualGainSettings manualGainDialog = new ManualGainSettings(this, mHandler, mManualGainLeft.intValue(), mManualGainRight.intValue());
            if (mAbsoluteLayout != null) {
                manualGainDialog.show();
            }
        } else if (manualGain.equals(getString(R.string.pref_omap4_camera_manual_gain_on))) {
            manualGain = getString(R.string.pref_omap4_camera_manual_gain_default);
            Editor edit = mPreferences.edit();
            edit.putString(CameraSettings.KEY_MANUAL_GAIN, manualGain);
            edit.commit();
            mManualGainOff = true;
            mParameters.set(PARM_MANUAL_GAIN_ISO_LEFT, 0);
            mParameters.set(PARM_MANUAL_GAIN_ISO_RIGHT, 0);
        }
    }
    if (!manualGain.equals(getString(R.string.pref_omap4_camera_manual_gain_on))) {
        mManualGainOff = true;
        mParameters.set(PARM_MANUAL_GAIN_ISO_LEFT, 0);
        mParameters.set(PARM_MANUAL_GAIN_ISO_RIGHT, 0);
    }
    mParameters.set(PARM_MANUAL_GAIN_MODES, manualGain);
    String mCaptureFormat = mPreferences.getString(CameraSettings.KEY_IMAGE_CAPTURE_FORMAT, getString(R.string.pref_omap4_camera_image_capture_format_default));
    mParameters.set(PARM_IMAGE_CAPTURE_FORMAT, mCaptureFormat);
    String vstab = mPreferences.getString(CameraSettings.KEY_VSTAB, (getString(R.string.pref_omap4_camera_vstab_default)));
    int vstabEn = Integer.parseInt(vstab);
    mParameters.set(PARM_VSTAB, vstabEn);
    if (mIsVstabEnabled && vstabEn == 0) {
        mIsVstabEnabled = false;
        restartPreview = true;
    } else if (!mIsVstabEnabled && vstabEn > 0) {
        mIsVstabEnabled = true;
        restartPreview = true;
    }
    if (mCaptureFormat.contains("+"))
        mCaptureFormat = mCaptureFormat.substring(mCaptureFormat.indexOf("+") + 1);
    if (mCaptureFormat.equals("jpeg"))
        mCurrentImageCaptureFormat = "jpg";
    else
        mCurrentImageCaptureFormat = mCaptureFormat;
    mCameraDevice.setParameters(mParameters);
    if (restartPreview) {
        restartPreview();
    }
}
#method_after
private void updateCameraParametersPreference() {
    boolean restartPreview = false;
    boolean frameParamUpdated = false;
    // get overridden by 'ensureCameraDevice()'
    if (null == mCameraDevice) {
        return;
    }
    String s3dFrameLayout = mPreferences.getString(CameraSettings.KEY_S3D_FRAME_LAYOUT, getString(R.string.pref_omap4_camera_s3d_frame_layout_default));
    if (!s3dFrameLayout.equals(mS3DFrameLayout)) {
        mParameters.set(PARM_S3D_FRAME_LAYOUT, s3dFrameLayout);
        mS3DFrameLayout = s3dFrameLayout;
        frameParamUpdated = true;
        restartPreview = true;
    }
    String s3d2d = mPreferences.getString(CameraSettings.KEY_S3D2D_PREVIEW_MODE, getString(R.string.pref_omap4_camera_s3d2dpreview_default));
    if (!s3d2d.equals(mLastS3D2DMode)) {
        mParameters.set(PARM_S3D2DPREVIEW, s3d2d);
        mLastS3D2DMode = s3d2d;
        restartPreview = true;
    }
    // Set picture size.
    String pictureSize = mPreferences.getString(CameraSettings.KEY_PICTURE_SIZE, "640x480");
    if (pictureSize == null) {
        CameraSettings.initialCameraPictureSize(this, mParameters);
    } else if (frameParamUpdated || !pictureSize.equals(mPictureSize)) {
        List<Size> supported = mParameters.getSupportedPictureSizes();
        CameraSettings.setCameraPictureSize(pictureSize, supported, mParameters);
        mPictureSize = pictureSize;
    }
    String previewSize = mPreferences.getString(CameraSettings.KEY_PREVIEW_SIZE, getString(R.string.pref_omap4_camera_previewsize_default));
    if (frameParamUpdated || !previewSize.equals(mLastPreviewSize)) {
        List<Size> supported = mParameters.getSupportedPreviewSizes();
        CameraSettings.setCameraPreviewSize(previewSize, supported, mParameters);
        mLastPreviewSize = previewSize;
        frameParamUpdated = true;
        restartPreview = true;
    }
    String gbce = mPreferences.getString(CameraSettings.KEY_GBCE, getString(R.string.pref_omap4_camera_gbce_default));
    if (!gbce.equals(mLastGBCEMode)) {
        setGBCEGLBCE(gbce, mParameters);
        mLastGBCEMode = gbce;
    }
    String framerate = mPreferences.getString(CameraSettings.KEY_PREVIEW_FRAMERATE, getString(R.string.pref_omap4_camera_previewframerate_default));
    if (!framerate.equals(mLastPreviewFramerate)) {
        CameraSettings.setCameraPreviewFramerate(Integer.parseInt(framerate), mParameters.getSupportedPreviewFrameRates(), mParameters);
        mLastPreviewFramerate = framerate;
        restartPreview = true;
    }
    String previewFormat = mPreferences.getString(CameraSettings.KEY_PREVIEW_FORMAT, getString(R.string.pref_omap4_camera_prevformat_default));
    if (!previewFormat.equals(mPreviewFormat)) {
        mParameters.setPreviewFormat(Integer.parseInt(previewFormat));
        mPreviewFormat = previewFormat;
        restartPreview = true;
    }
    String iso = mPreferences.getString(CameraSettings.KEY_ISO, getString(R.string.pref_omap4_camera_iso_default));
    if (!iso.equals(mISO)) {
        if (2 == mCameraId) {
            // Only for DualCamera mode
            if (mHeadUpDisplay != null) {
                if (mManualExposureLeft.decode(mParameters.get(PARM_MANUAL_EXPOSURE_LEFT)) != null) {
                    mManualExposureLeft.parseInt(mParameters.get(PARM_MANUAL_EXPOSURE_LEFT));
                    mManualExposureRight.parseInt(mParameters.get(PARM_MANUAL_EXPOSURE_RIGHT));
                } else {
                    mManualExposureLeft = 0;
                    mManualExposureRight = 0;
                }
            }
            mISO = iso;
            if (mISO.equals(getString(R.string.pref_omap4_camera_iso_default))) {
                mParameters.set(PARM_MANUAL_GAIN_ISO_LEFT, 0);
                mParameters.set(PARM_MANUAL_GAIN_ISO_RIGHT, 0);
            } else {
                mParameters.set(PARM_MANUAL_GAIN_ISO_LEFT, mISO);
                mParameters.set(PARM_MANUAL_GAIN_ISO_RIGHT, mISO);
            }
        } else {
            mParameters.set(PARM_ISO, iso);
            mISO = iso;
        }
    }
    String mode = mPreferences.getString(CameraSettings.KEY_MODE, getString(R.string.pref_omap4_camera_mode_default));
    if (!mode.equals(mCurrentMode)) {
        setCaptureMode(mode, mParameters);
        restartPreview = true;
        mCurrentMode = mode;
    }
    String bracketRange = mPreferences.getString(CameraSettings.KEY_BRACKET_RANGE, getString(R.string.pref_omap4_camera_bracketrange_default));
    if (!bracketRange.equals(mBracketRange)) {
        mParameters.set(PARM_TEMPORAL_BRACKETING_RANGE_POS, Integer.parseInt(bracketRange));
        mParameters.set(PARM_TEMPORAL_BRACKETING_RANGE_NEG, Integer.parseInt(bracketRange));
        mBracketRange = bracketRange;
    }
    String sensorOrientation = getString(R.string.pref_omap4_camera_sensor_orientation_default);
    mParameters.set(PARM_SENSOR_ORIENTATION, sensorOrientation);
    String scene = mPreferences.getString(CameraSettings.KEY_SCENE_MODE, getString(R.string.pref_omap4_camera_scenemode_default));
    if (isSupported(mSceneMode, mParameters.getSupportedSceneModes()) && !mSceneMode.equals(scene)) {
        mParameters.setSceneMode(scene);
        mSceneMode = scene;
        // Disables effects in case a scene different from 'auto' is selected
        if (!Parameters.SCENE_MODE_AUTO.equals(scene)) {
            Editor edit = mPreferences.edit();
            edit.putString(CameraSettings.KEY_COLOR_EFFECT, Parameters.EFFECT_NONE);
            edit.commit();
            if (mHeadUpDisplay != null) {
                mHeadUpDisplay.reloadPreferences();
            }
            mParameters.setColorEffect(Parameters.EFFECT_NONE);
        }
    }
    String antibanding = mPreferences.getString(CameraSettings.KEY_ANTIBANDING, getString(R.string.pref_omap4_camera_antibanding_default));
    if (!antibanding.equals(mAntibanding)) {
        mParameters.setAntibanding(antibanding);
        mAntibanding = antibanding;
    }
    String saturation = mPreferences.getString(CameraSettings.KEY_SATURATION, getString(R.string.pref_omap4_camera_saturation_default));
    if (!saturation.equals(mSaturation)) {
        mParameters.set(PARM_SATURATION, Integer.parseInt(saturation));
        mSaturation = saturation;
    }
    String sharpness = mPreferences.getString(CameraSettings.KEY_SHARPNESS, getString(R.string.pref_omap4_camera_sharpness_default));
    if (!sharpness.equals(mSharpness)) {
        mParameters.set(PARM_SHARPNESS, Integer.parseInt(sharpness));
        mSharpness = sharpness;
    }
    String brightness = mPreferences.getString(CameraSettings.KEY_BRIGHTNESS, getString(R.string.pref_omap4_camera_brightness_default));
    if (!brightness.equals(mBrightness)) {
        mParameters.set(PARM_BRIGHTNESS, Integer.parseInt(brightness));
        mBrightness = brightness;
    }
    String contrast = mPreferences.getString(CameraSettings.KEY_CONTRAST, getString(R.string.pref_omap4_camera_contrast_default));
    if (!contrast.equals(mContrast)) {
        mParameters.set(PARM_CONTRAST, Integer.parseInt(contrast));
        mContrast = contrast;
    }
    String exposureMode = mPreferences.getString(CameraSettings.KEY_EXPOSURE_MODE, getString(R.string.pref_omap4_camera_exposuremode_default));
    if (2 == mCameraId) {
        // 3d DualCamera Mode
        if (exposureMode.equals("manual") && MExpMGainOff) {
            if (mHeadUpDisplay != null) {
                MExpMGainOff = false;
                if (mManualExposureLeft.decode(mParameters.get(PARM_MANUAL_EXPOSURE_LEFT)) != null) {
                    mManualExposureLeft.parseInt(mParameters.get(PARM_MANUAL_EXPOSURE_LEFT));
                    mManualExposureRight.parseInt(mParameters.get(PARM_MANUAL_EXPOSURE_RIGHT));
                }
                ManualGainExposureSettings manualGainExposureDialog = new ManualGainExposureSettings(this, mHandler, mManualExposureLeft.intValue(), mManualExposureRight.intValue(), mManualGainEVLeft.intValue(), mManualGainEVRight.intValue());
                if (mAbsoluteLayout != null) {
                    Editor edit = mPreferences.edit();
                    edit.putString(CameraSettings.KEY_EXPOSURE_MODE, exposureMode);
                    edit.commit();
                    manualGainExposureDialog.show();
                }
            }
        } else if (exposureMode.equals(getString(R.string.pref_omap4_camera_exposuremode_default))) {
            // Auto ExposureMode 3d
            MExpMGainOff = true;
            mParameters.set(PARM_MANUAL_EXPOSURE_LEFT, 0);
            mParameters.set(PARM_MANUAL_EXPOSURE_RIGHT, 0);
            mParameters.set(PARM_MANUAL_GAIN_ISO_LEFT, mISO);
            mParameters.set(PARM_MANUAL_GAIN_ISO_RIGHT, mISO);
        } else {
            // Other 3d
            MExpMGainOff = true;
            mParameters.set(PARM_MANUAL_EXPOSURE_LEFT, 0);
            mParameters.set(PARM_MANUAL_EXPOSURE_RIGHT, 0);
            mParameters.set(PARM_MANUAL_GAIN_ISO_LEFT, mISO);
            mParameters.set(PARM_MANUAL_GAIN_ISO_RIGHT, mISO);
        }
    }
    mParameters.set(PARM_EXPOSURE_MODE, exposureMode);
    String shutter = mPreferences.getString(CameraSettings.KEY_SHUTTER, getString(R.string.pref_omap4_camera_shutter_default));
    if (!shutter.equals(mShutter)) {
        mParameters.set(PARM_SHUTTER, shutter);
        mShutter = shutter;
    }
    String thumbnail = mPreferences.getString(CameraSettings.KEY_THUMBNAIL, getString(R.string.pref_omap4_camera_thumbnail_default));
    if (!thumbnail.equals(mThumbnailMode)) {
        mThumbnailMode = thumbnail;
        setThumbnailMode(thumbnail);
    }
    updateOrientationPreference();
    int burst = Integer.parseInt(mPreferences.getString(CameraSettings.KEY_BURST, getString(R.string.pref_omap4_camera_burst_default)));
    if ((burst != mBurstImages) && (!mCurrentMode.equals(PARM_EXPOSURE_BRACKETING) && (!mCurrentMode.equals(PARM_TEMPORAL_BRACKETING)))) {
        mBurstImages = burst;
        restartPreview = true;
        if (0 < mBurstImages) {
            setCaptureMode(PARM_HS_MODE, mParameters);
        }
        mParameters.set(PARM_BURST, mBurstImages);
    }
    String face = mPreferences.getString(CameraSettings.KEY_FACE_DETECTION, getString(R.string.pref_omap4_camera_face_default));
    if (!face.equals(mFaceDetection)) {
        mFaceDetection = face;
        restartPreview = true;
        mParameters.set(PARM_FACE_DETECTION, face);
    }
    String jpegQuality = mPreferences.getString(CameraSettings.KEY_JPEG_QUALITY, getString(R.string.pref_omap4_camera_jpegquality_default));
    if (!jpegQuality.equals(mJpegQuality)) {
        mParameters.setJpegQuality(JpegEncodingQualityMappings.getQualityNumber(jpegQuality));
        mJpegQuality = jpegQuality;
    }
    int thumbWidth = Integer.parseInt(getString(R.string.pref_omap4_camera_thumbwidth_default));
    int thumbHeight = Integer.parseInt(getString(R.string.pref_omap4_camera_thumbheight_default));
    mParameters.setJpegThumbnailSize(thumbWidth, thumbHeight);
    int thumbQuality = Integer.parseInt(getString(R.string.pref_omap4_camera_thumbquality_default));
    mParameters.setJpegThumbnailQuality(thumbQuality);
    String colorEffect = mPreferences.getString(CameraSettings.KEY_COLOR_EFFECT, getString(R.string.pref_omap4_camera_coloreffect_default));
    if (isSupported(colorEffect, mParameters.getSupportedColorEffects()) && !colorEffect.equals(mColorEffect)) {
        mParameters.setColorEffect(colorEffect);
        mColorEffect = colorEffect;
    }
    String exposure = mPreferences.getString(CameraSettings.KEY_EXPOSURE, getString(R.string.pref_omap4_exposure_default));
    if (!exposure.equals(mExposure)) {
        try {
            int value = Integer.parseInt(exposure);
            int max = mParameters.getMaxExposureCompensation();
            int min = mParameters.getMinExposureCompensation();
            if (value >= min && value <= max) {
                mParameters.setExposureCompensation(value);
            } else {
                Log.w(TAG, "invalid exposure range: " + exposure);
            }
        } catch (NumberFormatException e) {
            Log.w(TAG, "invalid exposure: " + exposure);
        }
        mExposure = exposure;
    }
    if (mGLRootView != null)
        updateHud();
    String flashMode = mPreferences.getString(CameraSettings.KEY_FLASH_MODE, getString(R.string.pref_omap4_camera_flashmode_default));
    List<String> supportedFlash = mParameters.getSupportedFlashModes();
    if (!flashMode.equals(mFlashMode)) {
        if (isSupported(flashMode, supportedFlash)) {
            mParameters.setFlashMode(flashMode);
        } else {
            flashMode = mParameters.getFlashMode();
            if (flashMode == null) {
                flashMode = getString(R.string.pref_omap4_camera_flashmode_no_flash);
            }
        }
        mFlashMode = flashMode;
    }
    String whiteBalance = mPreferences.getString(CameraSettings.KEY_WHITE_BALANCE, getString(R.string.pref_omap4_camera_whitebalance_default));
    if (!whiteBalance.equals(mWhiteBalance)) {
        if (isSupported(whiteBalance, mParameters.getSupportedWhiteBalance())) {
            mParameters.setWhiteBalance(whiteBalance);
        } else {
            whiteBalance = mParameters.getWhiteBalance();
            if (whiteBalance == null) {
                whiteBalance = Parameters.WHITE_BALANCE_AUTO;
            }
        }
        mWhiteBalance = whiteBalance;
    }
    String focusMode = mPreferences.getString(CameraSettings.KEY_FOCUS_MODE, getString(R.string.pref_omap4_camera_focusmode_default));
    if (focusMode.equals(PARM_TOUCH_FOCUS)) {
        mTouchFocusEnabled = true;
    } else {
        mTouchFocusEnabled = false;
    }
    if (!focusMode.equals(mFocusMode)) {
        if (isSupported(focusMode, mParameters.getSupportedFocusModes())) {
            mParameters.setFocusMode(focusMode);
        } else {
            focusMode = mParameters.getFocusMode();
            if (focusMode == null) {
                focusMode = Parameters.FOCUS_MODE_AUTO;
            }
        }
        mFocusMode = focusMode;
    }
    String autoConvergenceMode = mPreferences.getString(CameraSettings.KEY_AUTOCONVERGENCE_MODE, getString(R.string.pref_omap4_camera_autoconvergence_default));
    mTouchConvergenceEnabled = false;
    if (autoConvergenceMode.equals(PARM_AUTOCONVERGENCE_FFT)) {
        mTouchConvergenceEnabled = true;
        mACManualOff = true;
    } else if (autoConvergenceMode.equals(PARM_AUTOCONVERGENCE_MANUAL)) {
        if (mACManualOff) {
            mACManualOff = false;
            if (mHeadUpDisplay != null) {
                AutoConvergenceSettings mcsDialog = new AutoConvergenceSettings(this, mHandler, mManualConvergenceValue.intValue());
                if (mAbsoluteLayout != null) {
                    mcsDialog.show();
                }
            }
        }
    } else {
        mACManualOff = true;
    }
    mParameters.set(PARM_AUTOCONVERGENCE, autoConvergenceMode);
    String mCaptureFormat = mPreferences.getString(CameraSettings.KEY_IMAGE_CAPTURE_FORMAT, getString(R.string.pref_omap4_camera_image_capture_format_default));
    mParameters.set(PARM_IMAGE_CAPTURE_FORMAT, mCaptureFormat);
    String vstab = mPreferences.getString(CameraSettings.KEY_VSTAB, (getString(R.string.pref_omap4_camera_vstab_default)));
    int vstabEn = Integer.parseInt(vstab);
    mParameters.set(PARM_VSTAB, vstabEn);
    if (mIsVstabEnabled && vstabEn == 0) {
        mIsVstabEnabled = false;
        restartPreview = true;
    } else if (!mIsVstabEnabled && vstabEn > 0) {
        mIsVstabEnabled = true;
        restartPreview = true;
    }
    if (mCaptureFormat.contains("+"))
        mCaptureFormat = mCaptureFormat.substring(mCaptureFormat.indexOf("+") + 1);
    if (mCaptureFormat.equals("jpeg"))
        mCurrentImageCaptureFormat = "jpg";
    else
        mCurrentImageCaptureFormat = mCaptureFormat;
    mCameraDevice.setParameters(mParameters);
    if (restartPreview) {
        if (frameParamUpdated) {
            updatePreviewAspectRatio();
        }
        restartPreview();
    }
}
#end_block

#method_before
// We separate the parameters into several subsets, so we can update only
// the subsets actually need updating. The PREFERENCE set needs extra
private void setCameraParameters(int updateSet) {
    if ((updateSet & UPDATE_PARAM_INITIALIZE) != 0) {
        updateCameraParametersInitialize();
    }
    if ((updateSet & UPDATE_PARAM_ZOOM) != 0) {
        updateCameraParametersZoom();
    }
    if ((updateSet & UPDATE_PARAM_PREFERENCE) != 0) {
        updateCameraParametersPreference();
    }
    mCameraDevice.setParameters(mParameters);
}
#method_after
// We separate the parameters into several subsets, so we can update only
// the subsets actually need updating. The PREFERENCE set needs extra
private void setCameraParameters(int updateSet) {
    if ((updateSet & UPDATE_PARAM_INITIALIZE) != 0) {
        updateCameraParametersInitialize();
    }
    if ((updateSet & UPDATE_PARAM_ZOOM) != 0) {
        updateCameraParametersZoom();
        mCameraDevice.setParameters(mParameters);
    }
    if ((updateSet & UPDATE_PARAM_PREFERENCE) != 0) {
        updateCameraParametersPreference();
    }
}
#end_block

#method_before
protected void onRestorePreferencesClicked() {
    if (mPausing)
        return;
    Runnable runnable = new Runnable() {

        public void run() {
            mHeadUpDisplay.restorePreferences(mParameters);
        }
    };
    MenuHelper.confirmAction(this, getString(R.string.confirm_restore_title), getString(R.string.confirm_restore_message), runnable);
}
#method_after
protected void onRestorePreferencesClicked() {
    if (mPausing)
        return;
    Runnable runnable = new Runnable() {

        public void run() {
            mHeadUpDisplay.restorePreferences(mParameters);
            // Also reset digital zoom
            mZoomValue = 0;
            setCameraParametersWhenIdle(UPDATE_PARAM_ZOOM);
            mHeadUpDisplay.setZoomIndex(mZoomValue);
        }
    };
    MenuHelper.confirmAction(this, getString(R.string.confirm_restore_title), getString(R.string.confirm_restore_message), runnable);
}
#end_block

#method_before
public int parseResult(String faceData) {
    String[] dataList = null;
    String[] recList = null;
    String origin, dimensions, roll;
    int top, left, width, height, j, i;
    if (null == faceData)
        return -1;
    dataList = tokenize(faceData, FACE_DATA_SEP);
    if ((null == dataList) || (0 == dataList.length)) {
        return -1;
    }
    for (j = 0, i = 0; (i < dataList.length) && (j < MAX_FACES); i += FACE_REC_DATA_COUNT, j++) {
        try {
            roll = dataList[i];
            origin = dataList[i + 1];
            dimensions = dataList[i + 2];
        } catch (IndexOutOfBoundsException e) {
            break;
        }
        top = left = width = height = 0;
        recList = tokenize(origin, FACE_REC_SEP);
        if ((null != recList) && (FACE_REC_DATA_COUNT != recList.length)) {
            left = Integer.parseInt(recList[0]);
            top = Integer.parseInt(recList[1]);
        }
        recList = tokenize(dimensions, FACE_REC_SEP);
        if ((null != recList) && (FACE_REC_DATA_COUNT != recList.length)) {
            width = Integer.parseInt(recList[0]);
            height = Integer.parseInt(recList[1]);
        }
        if (null == mFaces[j]) {
            mFaces[j] = new FaceResult();
        }
        // translate the face detection results for front facing camera
        // front facing camera preview is mirrored
        CameraInfo info = CameraHolder.instance().getCameraInfo()[mCameraId];
        if (info.facing == CameraInfo.CAMERA_FACING_FRONT) {
            int previewWidth = mParameters.getPreviewSize().width;
            // lets make sure the difference will be in bounds
            if ((left + width) <= previewWidth) {
                left = previewWidth - left - width;
            } else {
                left = previewWidth;
            }
        }
        mFaces[j].setDimensions(left, top, width, height);
        mFaces[j].setRoll(Integer.parseInt(roll));
        mFaces[j].transform(mCurrentPreviewSize.width, mCurrentPreviewSize.height, mSurfaceView.getWidth(), mSurfaceView.getHeight());
    }
    return j;
}
#method_after
public int parseResult(String faceData) {
    String[] dataList = null;
    String[] recList = null;
    String origin, dimensions, roll;
    int top, left, width, height, j, i;
    if (null == faceData)
        return -1;
    dataList = tokenize(faceData, FACE_DATA_SEP);
    if ((null == dataList) || (0 == dataList.length)) {
        return -1;
    }
    for (j = 0, i = 0; (i < dataList.length) && (j < MAX_FACES); i += FACE_REC_DATA_COUNT, j++) {
        try {
            roll = dataList[i];
            origin = dataList[i + 1];
            dimensions = dataList[i + 2];
        } catch (IndexOutOfBoundsException e) {
            break;
        }
        top = left = width = height = 0;
        recList = tokenize(origin, FACE_REC_SEP);
        if ((null != recList) && (FACE_REC_DATA_COUNT != recList.length)) {
            left = Integer.parseInt(recList[0]);
            top = Integer.parseInt(recList[1]);
        }
        recList = tokenize(dimensions, FACE_REC_SEP);
        if ((null != recList) && (FACE_REC_DATA_COUNT != recList.length)) {
            width = Integer.parseInt(recList[0]);
            height = Integer.parseInt(recList[1]);
        }
        if (null == mFaces[j]) {
            mFaces[j] = new FaceResult();
        }
        // translate the face detection results for front facing camera
        // front facing camera preview is mirrored
        CameraInfo info = CameraHolder.instance().getCameraInfo()[mCameraId];
        if (info.facing == CameraInfo.CAMERA_FACING_FRONT) {
            // lets make sure the difference will be in bounds
            if ((left + width) <= mPreviewWidth) {
                left = mPreviewWidth - left - width;
            } else {
                left = mPreviewWidth;
            }
        }
        mFaces[j].setDimensions(left, top, width, height);
        mFaces[j].setRoll(Integer.parseInt(roll));
        mFaces[j].transform(mPreviewWidth, mPreviewHeight, mSurfaceView.getWidth(), mSurfaceView.getHeight());
    }
    return j;
}
#end_block

#method_before
public static boolean setCameraPictureSize(String candidate, List<Size> supported, Parameters parameters) {
    int index = candidate.indexOf('x');
    if (index == NOT_FOUND)
        return false;
    int width = Integer.parseInt(candidate.substring(0, index));
    int height = Integer.parseInt(candidate.substring(index + 1));
    for (Size size : supported) {
        if (size.width == width && size.height == height) {
            parameters.setPictureSize(width, height);
            return true;
        }
    }
    return false;
}
#method_after
public static boolean setCameraPictureSize(String candidate, List<Size> supported, Parameters parameters) {
    int index = candidate.indexOf('x');
    if (index == NOT_FOUND)
        return false;
    int width = Integer.parseInt(candidate.substring(0, index));
    int height = Integer.parseInt(candidate.substring(index + 1));
    for (Size size : supported) {
        if (size.width == width && size.height == height) {
            parameters.setPictureSize(width * getWidthModifier3D(parameters), height * getHeightModifier3D(parameters));
            return true;
        }
    }
    return false;
}
#end_block

#method_before
public static boolean setCameraPreviewSize(String candidate, List<Size> supported, Parameters parameters) {
    int index = candidate.indexOf('x');
    if (index == NOT_FOUND)
        return false;
    int width = Integer.parseInt(candidate.substring(0, index));
    int height = Integer.parseInt(candidate.substring(index + 1));
    for (Size size : supported) {
        if (size.width == width && size.height == height) {
            parameters.setPreviewSize(width, height);
            return true;
        }
    }
    return false;
}
#method_after
public static boolean setCameraPreviewSize(String candidate, List<Size> supported, Parameters parameters) {
    int index = candidate.indexOf('x');
    if (index == NOT_FOUND)
        return false;
    int width = Integer.parseInt(candidate.substring(0, index));
    int height = Integer.parseInt(candidate.substring(index + 1));
    for (Size size : supported) {
        if (size.width == width && size.height == height) {
            parameters.setPreviewSize(width * getWidthModifier3D(parameters), height * getHeightModifier3D(parameters));
            return true;
        }
    }
    return false;
}
#end_block

#method_before
private void initPreference(PreferenceGroup group) {
    ListPreference videoQuality = group.findPreference(KEY_VIDEO_QUALITY);
    ListPreference pictureSize = group.findPreference(KEY_PICTURE_SIZE);
    ListPreference whiteBalance = group.findPreference(KEY_WHITE_BALANCE);
    ListPreference colorEffect = group.findPreference(KEY_COLOR_EFFECT);
    ListPreference sceneMode = group.findPreference(KEY_SCENE_MODE);
    ListPreference flashMode = group.findPreference(KEY_FLASH_MODE);
    ListPreference focusMode = group.findPreference(KEY_FOCUS_MODE);
    ListPreference exposure = group.findPreference(KEY_EXPOSURE);
    IconListPreference cameraId = (IconListPreference) group.findPreference(KEY_CAMERA_ID);
    ListPreference videoFlashMode = group.findPreference(KEY_VIDEOCAMERA_FLASH_MODE);
    ListPreference previewSize = group.findPreference(KEY_PREVIEW_SIZE);
    ListPreference previewFramerate = group.findPreference(KEY_PREVIEW_FRAMERATE);
    ListPreference antibanding = group.findPreference(KEY_ANTIBANDING);
    ListPreference exposureMode = group.findPreference(KEY_EXPOSURE_MODE);
    ListPreference iso = group.findPreference(KEY_ISO);
    ListPreference instance = (ListPreference) group.findPreference(KEY_INSTANCE);
    ListPreference s3d2dpreviewMode = group.findPreference(KEY_S3D2D_PREVIEW_MODE);
    ListPreference autoConvergenceMode = group.findPreference(KEY_AUTOCONVERGENCE_MODE);
    ListPreference imageCaptureFormat = group.findPreference(KEY_IMAGE_CAPTURE_FORMAT);
    ListPreference videominFramerate = group.findPreference(KEY_VIDEO_MINFRAMERATE);
    ListPreference videoStabilization = group.findPreference(KEY_VSTAB);
    ListPreference manualExposure = group.findPreference(KEY_MANUAL_EXPOSURE);
    ListPreference manualGain = group.findPreference(KEY_MANUAL_GAIN);
    // to check if the preference is available here
    if (videoQuality != null) {
        // Modify video duration settings.
        // The first entry is for MMS video duration, and we need to fill
        // in the device-dependent value (in seconds).
        CharSequence[] entries = videoQuality.getEntries();
        CharSequence[] values = videoQuality.getEntryValues();
        for (int i = 0; i < entries.length; ++i) {
            if (VIDEO_QUALITY_MMS.equals(values[i])) {
                entries[i] = entries[i].toString().replace("30", Integer.toString(MMS_VIDEO_DURATION));
                break;
            }
        }
    }
    if (pictureSize != null) {
        filterUnsupportedOptions(group, pictureSize, sizeListToStringList(mParameters.getSupportedPictureSizes()));
    }
    if (previewSize != null) {
        filterUnsupportedOptions(group, previewSize, sizeListToStringList(mParameters.getSupportedPreviewSizes()));
    }
    if (previewFramerate != null) {
        filterUnsupportedOptionsInt(group, previewFramerate, mParameters.getSupportedPreviewFrameRates());
    }
    if (whiteBalance != null) {
        filterUnsupportedOptions(group, whiteBalance, mParameters.getSupportedWhiteBalance());
    }
    if (colorEffect != null) {
        filterUnsupportedOptions(group, colorEffect, mParameters.getSupportedColorEffects());
    }
    if (sceneMode != null) {
        filterUnsupportedOptions(group, sceneMode, mParameters.getSupportedSceneModes());
    }
    if (flashMode != null) {
        filterUnsupportedOptions(group, flashMode, mParameters.getSupportedFlashModes());
    }
    if (focusMode != null) {
        filterUnsupportedOptions(group, focusMode, mParameters.getSupportedFocusModes());
    }
    if (videoFlashMode != null) {
        filterUnsupportedOptions(group, videoFlashMode, mParameters.getSupportedFlashModes());
    }
    if (antibanding != null) {
        filterUnsupportedOptions(group, antibanding, mParameters.getSupportedAntibanding());
    }
    if (exposureMode != null) {
        filterUnsupportedOptions(group, exposureMode, parseToList(mParameters.get(Camera.PARM_SUPPORTED_EXPOSURE_MODES)));
    }
    if (iso != null) {
        filterUnsupportedOptions(group, iso, parseToList(mParameters.get(Camera.PARM_SUPPORTED_ISO_MODES)));
    }
    if (exposure != null) {
        buildExposureCompensation(group, exposure);
    }
    if (instance != null) {
        filterUnsupportedOptions(group, instance, parseToList(mParameters.get(Camera.PARM_SUPPORTED_CAMERAS)));
    }
    if (s3d2dpreviewMode != null) {
        filterUnsupportedOptions(group, s3d2dpreviewMode, parseToList(mParameters.get(Camera.PARM_SUPPORTED_S3D2DPREVIEW_MODES)));
    }
    if (autoConvergenceMode != null) {
        filterUnsupportedOptions(group, autoConvergenceMode, parseToList(mParameters.get(Camera.PARM_SUPPORTED_AUTOCONVERGENCE_MODES)));
    }
    if (imageCaptureFormat != null) {
        filterUnsupportedOptions(group, imageCaptureFormat, parseToList(mParameters.get(Camera.PARM_SUPPORTED_IMAGE_CAPTURE_FORMATS)));
    }
    if (cameraId != null)
        buildCameraId(group, cameraId);
    if (videoStabilization != null) {
        filterUnsupportedOptions(group, videoStabilization, parseToList(mParameters.get(Camera.PARM_VSTAB_VALUES)));
    }
    if (manualExposure != null) {
        filterUnsupportedOptions(group, manualExposure, parseToList(mParameters.get(Camera.PARM_MANUAL_EXPOSURE_MODES)));
    }
    if (manualGain != null) {
        filterUnsupportedOptions(group, manualGain, parseToList(mParameters.get(Camera.PARM_MANUAL_GAIN_MODES)));
    }
}
#method_after
private void initPreference(PreferenceGroup group) {
    ListPreference videoQuality = group.findPreference(KEY_VIDEO_QUALITY);
    ListPreference pictureSize = group.findPreference(KEY_PICTURE_SIZE);
    ListPreference whiteBalance = group.findPreference(KEY_WHITE_BALANCE);
    ListPreference colorEffect = group.findPreference(KEY_COLOR_EFFECT);
    ListPreference sceneMode = group.findPreference(KEY_SCENE_MODE);
    ListPreference flashMode = group.findPreference(KEY_FLASH_MODE);
    ListPreference focusMode = group.findPreference(KEY_FOCUS_MODE);
    ListPreference exposure = group.findPreference(KEY_EXPOSURE);
    IconListPreference cameraId = (IconListPreference) group.findPreference(KEY_CAMERA_ID);
    ListPreference videoFlashMode = group.findPreference(KEY_VIDEOCAMERA_FLASH_MODE);
    ListPreference previewSize = group.findPreference(KEY_PREVIEW_SIZE);
    ListPreference previewFramerate = group.findPreference(KEY_PREVIEW_FRAMERATE);
    ListPreference antibanding = group.findPreference(KEY_ANTIBANDING);
    ListPreference exposureMode = group.findPreference(KEY_EXPOSURE_MODE);
    ListPreference iso = group.findPreference(KEY_ISO);
    ListPreference instance = (ListPreference) group.findPreference(KEY_INSTANCE);
    ListPreference s3d2dpreviewMode = group.findPreference(KEY_S3D2D_PREVIEW_MODE);
    ListPreference s3dFrameLayout = group.findPreference(KEY_S3D_FRAME_LAYOUT);
    ListPreference autoConvergenceMode = group.findPreference(KEY_AUTOCONVERGENCE_MODE);
    ListPreference imageCaptureFormat = group.findPreference(KEY_IMAGE_CAPTURE_FORMAT);
    ListPreference videominFramerate = group.findPreference(KEY_VIDEO_MINFRAMERATE);
    // to check if the preference is available here
    if (videoQuality != null) {
        // Modify video duration settings.
        // The first entry is for MMS video duration, and we need to fill
        // in the device-dependent value (in seconds).
        CharSequence[] entries = videoQuality.getEntries();
        CharSequence[] values = videoQuality.getEntryValues();
        for (int i = 0; i < entries.length; ++i) {
            if (VIDEO_QUALITY_MMS.equals(values[i])) {
                entries[i] = entries[i].toString().replace("30", Integer.toString(MMS_VIDEO_DURATION));
                break;
            }
        }
    }
    if (pictureSize != null) {
        filterUnsupportedOptions(group, pictureSize, sizeListToStringList(mParameters.getSupportedPictureSizes()));
    }
    if (previewSize != null) {
        filterUnsupportedOptions(group, previewSize, sizeListToStringList(mParameters.getSupportedPreviewSizes()));
    }
    if (previewFramerate != null) {
        filterUnsupportedOptionsInt(group, previewFramerate, mParameters.getSupportedPreviewFrameRates());
    }
    if (whiteBalance != null) {
        filterUnsupportedOptions(group, whiteBalance, mParameters.getSupportedWhiteBalance());
    }
    if (colorEffect != null) {
        filterUnsupportedOptions(group, colorEffect, mParameters.getSupportedColorEffects());
    }
    if (sceneMode != null) {
        filterUnsupportedOptions(group, sceneMode, mParameters.getSupportedSceneModes());
    }
    if (flashMode != null) {
        filterUnsupportedOptions(group, flashMode, mParameters.getSupportedFlashModes());
    }
    if (focusMode != null) {
        filterUnsupportedOptions(group, focusMode, mParameters.getSupportedFocusModes());
    }
    if (videoFlashMode != null) {
        filterUnsupportedOptions(group, videoFlashMode, mParameters.getSupportedFlashModes());
    }
    if (antibanding != null) {
        filterUnsupportedOptions(group, antibanding, mParameters.getSupportedAntibanding());
    }
    if (exposureMode != null) {
        List<String> supported = parseToList(mParameters.get(Camera.PARM_SUPPORTED_EXPOSURE_MODES));
        if (mParameters.get(Camera.PARM_CAMERA_NAME).equals("DualCamera")) {
            filterUnsupportedOptions(group, exposureMode, supported);
        } else {
            supported.remove("manual");
            filterUnsupportedOptions(group, exposureMode, supported);
        }
    }
    if (iso != null) {
        filterUnsupportedOptions(group, iso, parseToList(mParameters.get(Camera.PARM_SUPPORTED_ISO_MODES)));
    }
    if (exposure != null) {
        buildExposureCompensation(group, exposure);
    }
    if (instance != null) {
        filterUnsupportedOptions(group, instance, parseToList(mParameters.get(Camera.PARM_SUPPORTED_CAMERAS)));
    }
    if (s3d2dpreviewMode != null) {
        filterUnsupportedOptions(group, s3d2dpreviewMode, parseToList(mParameters.get(Camera.PARM_SUPPORTED_S3D2DPREVIEW_MODES)));
    }
    if (s3dFrameLayout != null) {
        filterUnsupportedOptions(group, s3dFrameLayout, parseToList(mParameters.get(Camera.PARM_SUPPORTED_S3D_FRAME_LAYOUTS)));
    }
    if (autoConvergenceMode != null) {
        filterUnsupportedOptions(group, autoConvergenceMode, parseToList(mParameters.get(Camera.PARM_SUPPORTED_AUTOCONVERGENCE_MODES)));
    }
    if (imageCaptureFormat != null) {
        filterUnsupportedOptions(group, imageCaptureFormat, parseToList(mParameters.get(Camera.PARM_SUPPORTED_IMAGE_CAPTURE_FORMATS)));
    }
    if (cameraId != null)
        buildCameraId(group, cameraId);
}
#end_block

#method_before
public void filterUnsupportedOptions(PreferenceGroup group, ListPreference pref, List<String> supported) {
    // only one options for the settings.
    if (supported == null || supported.size() <= 1) {
        removePreference(group, pref.getKey());
        return;
    }
    pref.filterUnsupported(supported);
    if (pref.getEntries().length <= 1) {
        removePreference(group, pref.getKey());
        return;
    }
    // Set the value to the first entry if it is invalid.
    String value = pref.getValue();
    if (pref.findIndexOfValue(value) == NOT_FOUND) {
        pref.setValueIndex(0);
    }
}
#method_after
public void filterUnsupportedOptions(PreferenceGroup group, ListPreference pref, List<String> supported) {
    if (supported == null || supported.size() <= 1) {
        removePreference(group, pref.getKey());
        return;
    }
    pref.filterUnsupported(supported);
    if (pref.getEntries().length <= 1) {
        removePreference(group, pref.getKey());
        return;
    }
    // Set the value to the first entry if it is invalid.
    String value = pref.getValue();
    if (pref.findIndexOfValue(value) == NOT_FOUND) {
        pref.setValueIndex(0);
    }
}
#end_block

#method_before
public static boolean isImageFileType(int fileType) {
    return (fileType >= FIRST_IMAGE_FILE_TYPE && fileType <= LAST_IMAGE_FILE_TYPE);
}
#method_after
public static boolean isImageFileType(int fileType) {
    if (SystemProperties.OMAP_ENHANCEMENT) {
        return (fileType >= FIRST_IMAGE_FILE_TYPE && fileType <= LAST_IMAGE_FILE_TYPE_S3D);
    } else {
        return (fileType >= FIRST_IMAGE_FILE_TYPE && fileType <= LAST_IMAGE_FILE_TYPE);
    }
}
#end_block

#method_before
private synchronized final void init() {
    // it's safe to set initial state to unplugged
    // we'll receive uevent if we boot-up with cable inserted
    mHDMIState = 0;
    mPrevHDMIState = mHDMIState;
    int newState = mHDMIState;
    char[] buffer = new char[1024];
    try {
        FileReader file = new FileReader(HDMI_STATE_PATH);
        int len = file.read(buffer, 0, 1024);
        newState = Integer.valueOf((new String(buffer, 0, len)).trim());
    } catch (FileNotFoundException e) {
        Slog.w(TAG, "This kernel does not have hdmi hotplug support");
    } catch (Exception e) {
        Slog.e(TAG, "", e);
    }
    update(HDMIName, newState);
}
#method_after
private synchronized final void init() {
    // it's safe to set initial state to unplugged
    // we'll receive uevent if we boot-up with cable inserted
    mHDMIState = 0;
    mPrevHDMIState = mHDMIState;
    int newState = mHDMIState;
    char[] buffer = new char[1024];
    try {
        FileReader file = new FileReader(HDMI_STATE_PATH);
        int len = file.read(buffer, 0, 1024);
        newState = Integer.valueOf((new String(buffer, 0, len)).trim());
        update(HDMIName, newState);
    } catch (FileNotFoundException e) {
        Slog.w(TAG, "This kernel does not have hdmi support");
    } catch (Exception e) {
        Slog.e(TAG, "", e);
    }
}
#end_block

#method_before
@Override
public void onReceive(Context context, Intent intent) {
    if (intent != null) {
        String action = intent.getAction();
        if (SystemProperties.OMAP_ENHANCEMENT && action.equals(ACTION_HDMI_PLUG)) {
            int state = intent.getIntExtra("state", 0);
            if (state == 1) {
                Log.d(TAG, "VideoPlaybackBroadcastReceiver.onReceive() : Switching to HDMI_TV)");
                mOmapMMHandle.setDisplayId(DISPLAY_TYPE_HDMI_TV);
            } else {
                Log.d(TAG, "VideoPlaybackBroadcastReceiver.onReceive() : Switching to LCD-Primary");
                mOmapMMHandle.setDisplayId(DISPLAY_TYPE_LCD_PRIMARY);
            }
        }
    }
}
#method_after
@Override
public void onReceive(Context context, Intent intent) {
    if (intent == null) {
        Log.e(TAG, "VideoPlaybackBroadcastReceiver intent is NULL!");
        return;
    }
    String action = intent.getAction();
    if (SystemProperties.OMAP_ENHANCEMENT && action.equals(ACTION_HDMI_PLUG)) {
        int state = intent.getIntExtra("state", 0);
        if (state == 1) {
            Log.d(TAG, "VideoPlaybackBroadcastReceiver.onReceive() : Switching to HDMI_TV)");
            mOmapMMHandle.setDisplayId(DISPLAY_TYPE_HDMI_TV);
        } else {
            Log.d(TAG, "VideoPlaybackBroadcastReceiver.onReceive() : Switching to LCD-Primary");
            mOmapMMHandle.setDisplayId(DISPLAY_TYPE_LCD_PRIMARY);
        }
    }
}
#end_block

#method_before
private void openVideo() {
    if (mUri == null || mSurfaceHolder == null) {
        // not ready for playback just yet, will try again later
        return;
    }
    // Tell the music playback service to pause
    // TODO: these constants need to be published somewhere in the framework.
    Intent i = new Intent("com.android.music.musicservicecommand");
    i.putExtra("command", "pause");
    mContext.sendBroadcast(i);
    /* TI FM UI port -start */
    if (SystemProperties.OMAP_ENHANCEMENT) {
        // Tell the FM playback service to pause,as the video playback will start.
        // TODO: these constants need to be published somewhere in the framework.
        Intent fm = new Intent("com.ti.server.fmpausecmd");
        mContext.sendBroadcast(fm);
    }
    /* TI FM UI port -stop */
    // we shouldn't clear the target state, because somebody might have
    // called start() previously
    release(false);
    try {
        mMediaPlayer = new MediaPlayer();
        mMediaPlayer.setOnPreparedListener(mPreparedListener);
        mMediaPlayer.setOnVideoSizeChangedListener(mSizeChangedListener);
        mDuration = -1;
        mMediaPlayer.setOnCompletionListener(mCompletionListener);
        mMediaPlayer.setOnErrorListener(mErrorListener);
        mMediaPlayer.setOnBufferingUpdateListener(mBufferingUpdateListener);
        mCurrentBufferPercentage = 0;
        mMediaPlayer.setDataSource(mContext, mUri, mHeaders);
        mMediaPlayer.setDisplay(mSurfaceHolder);
        mMediaPlayer.setAudioStreamType(AudioManager.STREAM_MUSIC);
        mMediaPlayer.setScreenOnWhilePlaying(true);
        mMediaPlayer.prepareAsync();
        // we don't set the target state here either, but preserve the
        // target state that was there before.
        mCurrentState = STATE_PREPARING;
        attachMediaController();
        if (SystemProperties.OMAP_ENHANCEMENT) {
            mOmapMMHandle.setVideoSurface(mSurfaceHolder);
        }
    } catch (IOException ex) {
        Log.w(TAG, "Unable to open content: " + mUri, ex);
        mCurrentState = STATE_ERROR;
        mTargetState = STATE_ERROR;
        mErrorListener.onError(mMediaPlayer, MediaPlayer.MEDIA_ERROR_UNKNOWN, 0);
        return;
    } catch (IllegalArgumentException ex) {
        Log.w(TAG, "Unable to open content: " + mUri, ex);
        mCurrentState = STATE_ERROR;
        mTargetState = STATE_ERROR;
        mErrorListener.onError(mMediaPlayer, MediaPlayer.MEDIA_ERROR_UNKNOWN, 0);
        return;
    }
}
#method_after
private void openVideo() {
    if (mUri == null || mSurfaceHolder == null) {
        // not ready for playback just yet, will try again later
        return;
    }
    // Tell the music playback service to pause
    // TODO: these constants need to be published somewhere in the framework.
    Intent i = new Intent("com.android.music.musicservicecommand");
    i.putExtra("command", "pause");
    mContext.sendBroadcast(i);
    /* TI FM UI port -start */
    if (SystemProperties.OMAP_ENHANCEMENT) {
        // Tell the FM playback service to pause,as the video playback will start.
        // TODO: these constants need to be published somewhere in the framework.
        Intent fm = new Intent("com.ti.server.fmpausecmd");
        mContext.sendBroadcast(fm);
    }
    /* TI FM UI port -stop */
    // we shouldn't clear the target state, because somebody might have
    // called start() previously
    release(false);
    try {
        mMediaPlayer = new MediaPlayer();
        mMediaPlayer.setOnPreparedListener(mPreparedListener);
        mMediaPlayer.setOnVideoSizeChangedListener(mSizeChangedListener);
        mDuration = -1;
        mMediaPlayer.setOnCompletionListener(mCompletionListener);
        mMediaPlayer.setOnErrorListener(mErrorListener);
        mMediaPlayer.setOnBufferingUpdateListener(mBufferingUpdateListener);
        mCurrentBufferPercentage = 0;
        mMediaPlayer.setDataSource(mContext, mUri, mHeaders);
        mMediaPlayer.setDisplay(mSurfaceHolder);
        mMediaPlayer.setAudioStreamType(AudioManager.STREAM_MUSIC);
        mMediaPlayer.setScreenOnWhilePlaying(true);
        mMediaPlayer.prepareAsync();
        // we don't set the target state here either, but preserve the
        // target state that was there before.
        mCurrentState = STATE_PREPARING;
        attachMediaController();
        if (SystemProperties.OMAP_ENHANCEMENT) {
            mOmapMMHandle.setVideoSurface(mSurfaceHolder);
            mOmapMMHandle.setMediaPlayer(mMediaPlayer);
        }
    } catch (IOException ex) {
        Log.w(TAG, "Unable to open content: " + mUri, ex);
        mCurrentState = STATE_ERROR;
        mTargetState = STATE_ERROR;
        mErrorListener.onError(mMediaPlayer, MediaPlayer.MEDIA_ERROR_UNKNOWN, 0);
        return;
    } catch (IllegalArgumentException ex) {
        Log.w(TAG, "Unable to open content: " + mUri, ex);
        mCurrentState = STATE_ERROR;
        mTargetState = STATE_ERROR;
        mErrorListener.onError(mMediaPlayer, MediaPlayer.MEDIA_ERROR_UNKNOWN, 0);
        return;
    }
}
#end_block

#method_before
@Override
public void onReceive(Context context, Intent intent) {
    String action = intent.getAction();
    if (action.equals(Intent.ACTION_DOCK_EVENT)) {
        int dockState = intent.getIntExtra(Intent.EXTRA_DOCK_STATE, Intent.EXTRA_DOCK_STATE_UNDOCKED);
        int config;
        switch(dockState) {
            case Intent.EXTRA_DOCK_STATE_DESK:
                config = AudioSystem.FORCE_BT_DESK_DOCK;
                break;
            case Intent.EXTRA_DOCK_STATE_CAR:
                config = AudioSystem.FORCE_BT_CAR_DOCK;
                break;
            case Intent.EXTRA_DOCK_STATE_UNDOCKED:
            default:
                config = AudioSystem.FORCE_NONE;
        }
        AudioSystem.setForceUse(AudioSystem.FOR_DOCK, config);
    } else if (action.equals(BluetoothA2dp.ACTION_SINK_STATE_CHANGED)) {
        int state = intent.getIntExtra(BluetoothA2dp.EXTRA_SINK_STATE, BluetoothA2dp.STATE_DISCONNECTED);
        BluetoothDevice btDevice = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
        String address = btDevice.getAddress();
        boolean isConnected = (mConnectedDevices.containsKey(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP) && ((String) mConnectedDevices.get(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP)).equals(address));
        if (isConnected && state != BluetoothA2dp.STATE_CONNECTED && state != BluetoothA2dp.STATE_PLAYING) {
            if (btDevice.isBluetoothDock()) {
                if (state == BluetoothA2dp.STATE_DISCONNECTED) {
                    // introduction of a delay for transient disconnections of docks when
                    // power is rapidly turned off/on, this message will be canceled if
                    // we reconnect the dock under a preset delay
                    makeA2dpDeviceUnavailableLater(address);
                // the next time isConnected is evaluated, it will be false for the dock
                }
            } else {
                makeA2dpDeviceUnavailableNow(address);
            }
        } else if (!isConnected && (state == BluetoothA2dp.STATE_CONNECTED || state == BluetoothA2dp.STATE_PLAYING)) {
            if (btDevice.isBluetoothDock()) {
                // this could be a reconnection after a transient disconnection
                cancelA2dpDeviceTimeout();
                mDockAddress = address;
            } else {
                // a dock: cancel the dock timeout, and make the dock unavailable now
                if (hasScheduledA2dpDockTimeout()) {
                    cancelA2dpDeviceTimeout();
                    makeA2dpDeviceUnavailableNow(mDockAddress);
                }
            }
            makeA2dpDeviceAvailable(address);
        }
    } else if (action.equals(BluetoothHeadset.ACTION_STATE_CHANGED)) {
        int state = intent.getIntExtra(BluetoothHeadset.EXTRA_STATE, BluetoothHeadset.STATE_ERROR);
        int device = AudioSystem.DEVICE_OUT_BLUETOOTH_SCO;
        BluetoothDevice btDevice = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
        String address = null;
        if (btDevice != null) {
            address = btDevice.getAddress();
            BluetoothClass btClass = btDevice.getBluetoothClass();
            if (btClass != null) {
                switch(btClass.getDeviceClass()) {
                    case BluetoothClass.Device.AUDIO_VIDEO_WEARABLE_HEADSET:
                    case BluetoothClass.Device.AUDIO_VIDEO_HANDSFREE:
                        device = AudioSystem.DEVICE_OUT_BLUETOOTH_SCO_HEADSET;
                        break;
                    case BluetoothClass.Device.AUDIO_VIDEO_CAR_AUDIO:
                        device = AudioSystem.DEVICE_OUT_BLUETOOTH_SCO_CARKIT;
                        break;
                }
            }
        }
        boolean isConnected = (mConnectedDevices.containsKey(device) && ((String) mConnectedDevices.get(device)).equals(address));
        if (isConnected && state != BluetoothHeadset.STATE_CONNECTED) {
            AudioSystem.setDeviceConnectionState(device, AudioSystem.DEVICE_STATE_UNAVAILABLE, address);
            mConnectedDevices.remove(device);
            mBluetoothHeadsetConnected = false;
            clearAllScoClients();
        } else if (!isConnected && state == BluetoothHeadset.STATE_CONNECTED) {
            AudioSystem.setDeviceConnectionState(device, AudioSystem.DEVICE_STATE_AVAILABLE, address);
            mConnectedDevices.put(new Integer(device), address);
            mBluetoothHeadsetConnected = true;
        }
    } else if (action.equals(Intent.ACTION_HEADSET_PLUG)) {
        int state = intent.getIntExtra("state", 0);
        int microphone = intent.getIntExtra("microphone", 0);
        if (microphone != 0) {
            boolean isConnected = mConnectedDevices.containsKey(AudioSystem.DEVICE_OUT_WIRED_HEADSET);
            if (state == 0 && isConnected) {
                AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_WIRED_HEADSET, AudioSystem.DEVICE_STATE_UNAVAILABLE, "");
                mConnectedDevices.remove(AudioSystem.DEVICE_OUT_WIRED_HEADSET);
            } else if (state == 1 && !isConnected) {
                AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_WIRED_HEADSET, AudioSystem.DEVICE_STATE_AVAILABLE, "");
                mConnectedDevices.put(new Integer(AudioSystem.DEVICE_OUT_WIRED_HEADSET), "");
            }
        } else {
            boolean isConnected = mConnectedDevices.containsKey(AudioSystem.DEVICE_OUT_WIRED_HEADPHONE);
            if (state == 0 && isConnected) {
                AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_WIRED_HEADPHONE, AudioSystem.DEVICE_STATE_UNAVAILABLE, "");
                mConnectedDevices.remove(AudioSystem.DEVICE_OUT_WIRED_HEADPHONE);
            } else if (state == 1 && !isConnected) {
                AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_WIRED_HEADPHONE, AudioSystem.DEVICE_STATE_AVAILABLE, "");
                mConnectedDevices.put(new Integer(AudioSystem.DEVICE_OUT_WIRED_HEADPHONE), "");
            }
        }
    } else if (SystemProperties.OMAP_ENHANCEMENT && action.equals(ACTION_HDMI_PLUG)) {
        int state = intent.getIntExtra("state", 0);
        boolean isConnected = mConnectedDevices.containsKey(AudioSystem.DEVICE_OUT_AUX_DIGITAL);
        if (state == 0 && isConnected) {
            AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_AUX_DIGITAL, AudioSystem.DEVICE_STATE_UNAVAILABLE, "");
            mConnectedDevices.remove(AudioSystem.DEVICE_OUT_AUX_DIGITAL);
        } else if (state == 1 && !isConnected) {
            AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_AUX_DIGITAL, AudioSystem.DEVICE_STATE_AVAILABLE, "");
            mConnectedDevices.put(new Integer(AudioSystem.DEVICE_OUT_AUX_DIGITAL), "");
        }
    } else if (action.equals(BluetoothHeadset.ACTION_AUDIO_STATE_CHANGED)) {
        int state = intent.getIntExtra(BluetoothHeadset.EXTRA_AUDIO_STATE, BluetoothHeadset.STATE_ERROR);
        synchronized (mScoClients) {
            if (!mScoClients.isEmpty()) {
                switch(state) {
                    case BluetoothHeadset.AUDIO_STATE_CONNECTED:
                        state = AudioManager.SCO_AUDIO_STATE_CONNECTED;
                        break;
                    case BluetoothHeadset.AUDIO_STATE_DISCONNECTED:
                        state = AudioManager.SCO_AUDIO_STATE_DISCONNECTED;
                        break;
                    default:
                        state = AudioManager.SCO_AUDIO_STATE_ERROR;
                        break;
                }
                if (state != AudioManager.SCO_AUDIO_STATE_ERROR) {
                    Intent newIntent = new Intent(AudioManager.ACTION_SCO_AUDIO_STATE_CHANGED);
                    newIntent.putExtra(AudioManager.EXTRA_SCO_AUDIO_STATE, state);
                    mContext.sendStickyBroadcast(newIntent);
                }
            }
        }
    } else if (SystemProperties.OMAP_ENHANCEMENT && action.equals(ACTION_FM_PLUG)) {
        int state = intent.getIntExtra("state", 0);
        boolean isConnected = mConnectedDevices.containsKey(AudioSystem.DEVICE_IN_FM_ANALOG);
        if (state == 0 && isConnected) {
            Log.v(TAG, "calling FM Rx Analog  Off");
            AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_IN_FM_ANALOG, AudioSystem.DEVICE_STATE_UNAVAILABLE, "");
            mConnectedDevices.remove(AudioSystem.DEVICE_IN_FM_ANALOG);
        } else if (state == 1 && !isConnected) {
            Log.v(TAG, "calling FM Rx Analog On");
            AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_IN_FM_ANALOG, AudioSystem.DEVICE_STATE_AVAILABLE, "");
            mConnectedDevices.put(new Integer(AudioSystem.DEVICE_IN_FM_ANALOG), "");
        }
    } else if (SystemProperties.OMAP_ENHANCEMENT && action.equals(POWER_MODE)) {
        Intent noisyIntent = new Intent(AudioManager.ACTION_AUDIO_BECOMING_NOISY);
        mContext.sendBroadcast(noisyIntent);
        boolean isConnected = mConnectedDevices.containsKey(AudioSystem.DEVICE_OUT_WIRED_HEADSET) | mConnectedDevices.containsKey(AudioSystem.DEVICE_OUT_WIRED_HEADPHONE);
        if (intent.getBooleanExtra("LP", false) && isConnected) {
            // enable low power mode
            AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_LOW_POWER, AudioSystem.DEVICE_STATE_AVAILABLE, "");
            mConnectedDevices.put(new Integer(AudioSystem.DEVICE_OUT_LOW_POWER), "");
            Log.e(TAG, "Action: power mode is now LP, re-routing");
        } else {
            Log.e(TAG, "Action: power mode is now HQ, re-routing");
            AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_LOW_POWER, AudioSystem.DEVICE_STATE_UNAVAILABLE, "");
            mConnectedDevices.remove(AudioSystem.DEVICE_OUT_LOW_POWER);
        }
    } else if (SystemProperties.OMAP_ENHANCEMENT && action.equals(MAIN_MIC_CHOICE)) {
        /*
                 * mic choice is not configurable by intent yet, this is here for future use.
                 * eventually, the mic choice will be set from applications using this intent
                 * and we will update the logic to be flexible for mics other than DMIC0.
                 */
        Intent noisyIntent = new Intent(AudioManager.ACTION_AUDIO_BECOMING_NOISY);
        mContext.sendBroadcast(noisyIntent);
        if (intent.getBooleanExtra("DMic0L", true)) {
            Log.e(TAG, "MAIN MIC - DMIC0L selected");
        } else if (intent.getBooleanExtra("AMic0", true)) {
            Log.e(TAG, "MAIN MIC - AMIC selected");
        } else {
            Log.e(TAG, "MAIN MIC - invalid selection, only [DMIC0L,AMIC0] supported");
        }
    } else if (SystemProperties.OMAP_ENHANCEMENT && action.equals(SUB_MIC_CHOICE)) {
        // mic choice is not configurable by intent yet, this is here for future use
        Intent noisyIntent = new Intent(AudioManager.ACTION_AUDIO_BECOMING_NOISY);
        mContext.sendBroadcast(noisyIntent);
        if (intent.getBooleanExtra("DMic0R", true)) {
            Log.e(TAG, "SUB MIC - DMIC0R selected");
        } else if (intent.getBooleanExtra("AMic1", true)) {
            Log.e(TAG, "SUB MIC - AMIC selected");
        } else {
            Log.e(TAG, "SUB MIC - invalid selection, only [DMIC0R,AMIC] supported");
        }
    }
}
#method_after
@Override
public void onReceive(Context context, Intent intent) {
    String action = intent.getAction();
    if (action.equals(Intent.ACTION_DOCK_EVENT)) {
        int dockState = intent.getIntExtra(Intent.EXTRA_DOCK_STATE, Intent.EXTRA_DOCK_STATE_UNDOCKED);
        int config;
        switch(dockState) {
            case Intent.EXTRA_DOCK_STATE_DESK:
                config = AudioSystem.FORCE_BT_DESK_DOCK;
                break;
            case Intent.EXTRA_DOCK_STATE_CAR:
                config = AudioSystem.FORCE_BT_CAR_DOCK;
                break;
            case Intent.EXTRA_DOCK_STATE_UNDOCKED:
            default:
                config = AudioSystem.FORCE_NONE;
        }
        AudioSystem.setForceUse(AudioSystem.FOR_DOCK, config);
    } else if (action.equals(BluetoothA2dp.ACTION_SINK_STATE_CHANGED)) {
        int state = intent.getIntExtra(BluetoothA2dp.EXTRA_SINK_STATE, BluetoothA2dp.STATE_DISCONNECTED);
        BluetoothDevice btDevice = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
        String address = btDevice.getAddress();
        boolean isConnected = (mConnectedDevices.containsKey(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP) && ((String) mConnectedDevices.get(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP)).equals(address));
        if (isConnected && state != BluetoothA2dp.STATE_CONNECTED && state != BluetoothA2dp.STATE_PLAYING) {
            if (btDevice.isBluetoothDock()) {
                if (state == BluetoothA2dp.STATE_DISCONNECTED) {
                    // introduction of a delay for transient disconnections of docks when
                    // power is rapidly turned off/on, this message will be canceled if
                    // we reconnect the dock under a preset delay
                    makeA2dpDeviceUnavailableLater(address);
                // the next time isConnected is evaluated, it will be false for the dock
                }
            } else {
                makeA2dpDeviceUnavailableNow(address);
            }
        } else if (!isConnected && (state == BluetoothA2dp.STATE_CONNECTED || state == BluetoothA2dp.STATE_PLAYING)) {
            if (btDevice.isBluetoothDock()) {
                // this could be a reconnection after a transient disconnection
                cancelA2dpDeviceTimeout();
                mDockAddress = address;
            } else {
                // a dock: cancel the dock timeout, and make the dock unavailable now
                if (hasScheduledA2dpDockTimeout()) {
                    cancelA2dpDeviceTimeout();
                    makeA2dpDeviceUnavailableNow(mDockAddress);
                }
            }
            makeA2dpDeviceAvailable(address);
        }
    } else if (action.equals(BluetoothHeadset.ACTION_STATE_CHANGED)) {
        int state = intent.getIntExtra(BluetoothHeadset.EXTRA_STATE, BluetoothHeadset.STATE_ERROR);
        int device = AudioSystem.DEVICE_OUT_BLUETOOTH_SCO;
        BluetoothDevice btDevice = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
        String address = null;
        if (btDevice != null) {
            address = btDevice.getAddress();
            BluetoothClass btClass = btDevice.getBluetoothClass();
            if (btClass != null) {
                switch(btClass.getDeviceClass()) {
                    case BluetoothClass.Device.AUDIO_VIDEO_WEARABLE_HEADSET:
                    case BluetoothClass.Device.AUDIO_VIDEO_HANDSFREE:
                        device = AudioSystem.DEVICE_OUT_BLUETOOTH_SCO_HEADSET;
                        break;
                    case BluetoothClass.Device.AUDIO_VIDEO_CAR_AUDIO:
                        device = AudioSystem.DEVICE_OUT_BLUETOOTH_SCO_CARKIT;
                        break;
                }
            }
        }
        boolean isConnected = (mConnectedDevices.containsKey(device) && ((String) mConnectedDevices.get(device)).equals(address));
        if (isConnected && state != BluetoothHeadset.STATE_CONNECTED) {
            AudioSystem.setDeviceConnectionState(device, AudioSystem.DEVICE_STATE_UNAVAILABLE, address);
            mConnectedDevices.remove(device);
            mBluetoothHeadsetConnected = false;
            clearAllScoClients();
        } else if (!isConnected && state == BluetoothHeadset.STATE_CONNECTED) {
            AudioSystem.setDeviceConnectionState(device, AudioSystem.DEVICE_STATE_AVAILABLE, address);
            mConnectedDevices.put(new Integer(device), address);
            mBluetoothHeadsetConnected = true;
        }
    } else if (action.equals(Intent.ACTION_HEADSET_PLUG)) {
        int state = intent.getIntExtra("state", 0);
        int microphone = intent.getIntExtra("microphone", 0);
        if (microphone != 0) {
            boolean isConnected = mConnectedDevices.containsKey(AudioSystem.DEVICE_OUT_WIRED_HEADSET);
            if (state == 0 && isConnected) {
                AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_WIRED_HEADSET, AudioSystem.DEVICE_STATE_UNAVAILABLE, "");
                mConnectedDevices.remove(AudioSystem.DEVICE_OUT_WIRED_HEADSET);
            } else if (state == 1 && !isConnected) {
                AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_WIRED_HEADSET, AudioSystem.DEVICE_STATE_AVAILABLE, "");
                mConnectedDevices.put(new Integer(AudioSystem.DEVICE_OUT_WIRED_HEADSET), "");
            }
        } else {
            boolean isConnected = mConnectedDevices.containsKey(AudioSystem.DEVICE_OUT_WIRED_HEADPHONE);
            if (state == 0 && isConnected) {
                AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_WIRED_HEADPHONE, AudioSystem.DEVICE_STATE_UNAVAILABLE, "");
                mConnectedDevices.remove(AudioSystem.DEVICE_OUT_WIRED_HEADPHONE);
            } else if (state == 1 && !isConnected) {
                AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_WIRED_HEADPHONE, AudioSystem.DEVICE_STATE_AVAILABLE, "");
                mConnectedDevices.put(new Integer(AudioSystem.DEVICE_OUT_WIRED_HEADPHONE), "");
            }
        }
    } else if (SystemProperties.OMAP_ENHANCEMENT && action.equals(ACTION_HDMI_PLUG)) {
        int state = intent.getIntExtra("state", 0);
        boolean isConnected = mConnectedDevices.containsKey(AudioSystem.DEVICE_OUT_AUX_DIGITAL);
        if (state == 0 && isConnected) {
            AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_AUX_DIGITAL, AudioSystem.DEVICE_STATE_UNAVAILABLE, "");
            mConnectedDevices.remove(AudioSystem.DEVICE_OUT_AUX_DIGITAL);
        } else if (state == 1 && !isConnected) {
            AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_AUX_DIGITAL, AudioSystem.DEVICE_STATE_AVAILABLE, "");
            mConnectedDevices.put(new Integer(AudioSystem.DEVICE_OUT_AUX_DIGITAL), "");
        }
    } else if (action.equals(BluetoothHeadset.ACTION_AUDIO_STATE_CHANGED)) {
        int state = intent.getIntExtra(BluetoothHeadset.EXTRA_AUDIO_STATE, BluetoothHeadset.STATE_ERROR);
        synchronized (mScoClients) {
            if (!mScoClients.isEmpty()) {
                switch(state) {
                    case BluetoothHeadset.AUDIO_STATE_CONNECTED:
                        state = AudioManager.SCO_AUDIO_STATE_CONNECTED;
                        break;
                    case BluetoothHeadset.AUDIO_STATE_DISCONNECTED:
                        state = AudioManager.SCO_AUDIO_STATE_DISCONNECTED;
                        break;
                    default:
                        state = AudioManager.SCO_AUDIO_STATE_ERROR;
                        break;
                }
                if (state != AudioManager.SCO_AUDIO_STATE_ERROR) {
                    Intent newIntent = new Intent(AudioManager.ACTION_SCO_AUDIO_STATE_CHANGED);
                    newIntent.putExtra(AudioManager.EXTRA_SCO_AUDIO_STATE, state);
                    mContext.sendStickyBroadcast(newIntent);
                }
            }
        }
    } else if (SystemProperties.OMAP_ENHANCEMENT && action.equals(ACTION_FM_PLUG)) {
        int state = intent.getIntExtra("state", 0);
        boolean isConnected = mConnectedDevices.containsKey(AudioSystem.DEVICE_IN_FM_ANALOG);
        if (state == 0 && isConnected) {
            Log.v(TAG, "calling FM Rx Analog  Off");
            AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_IN_FM_ANALOG, AudioSystem.DEVICE_STATE_UNAVAILABLE, "");
            mConnectedDevices.remove(AudioSystem.DEVICE_IN_FM_ANALOG);
        } else if (state == 1 && !isConnected) {
            Log.v(TAG, "calling FM Rx Analog On");
            AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_IN_FM_ANALOG, AudioSystem.DEVICE_STATE_AVAILABLE, "");
            mConnectedDevices.put(new Integer(AudioSystem.DEVICE_IN_FM_ANALOG), "");
        }
    } else if (SystemProperties.OMAP_ENHANCEMENT && action.equals(ACTION_FMTX_PLUG)) {
        int state = intent.getIntExtra("state", 0);
        boolean isConnected = mConnectedDevices.containsKey(AudioSystem.DEVICE_OUT_FM_TRANSMIT);
        if (state == 0 && isConnected) {
            Log.e(TAG, "calling FM Transmit Off");
            AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_FM_TRANSMIT, AudioSystem.DEVICE_STATE_UNAVAILABLE, "");
            mConnectedDevices.remove(AudioSystem.DEVICE_OUT_FM_TRANSMIT);
        } else if (state == 1 && !isConnected) {
            Log.e(TAG, "calling FM Transmit On");
            AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_FM_TRANSMIT, AudioSystem.DEVICE_STATE_AVAILABLE, "");
            mConnectedDevices.put(new Integer(AudioSystem.DEVICE_OUT_FM_TRANSMIT), "");
        }
    } else if (SystemProperties.OMAP_ENHANCEMENT && action.equals(POWER_MODE)) {
        Intent noisyIntent = new Intent(AudioManager.ACTION_AUDIO_BECOMING_NOISY);
        mContext.sendBroadcast(noisyIntent);
        boolean isConnected = mConnectedDevices.containsKey(AudioSystem.DEVICE_OUT_WIRED_HEADSET) | mConnectedDevices.containsKey(AudioSystem.DEVICE_OUT_WIRED_HEADPHONE);
        if (intent.getBooleanExtra("LP", false) && isConnected) {
            // enable low power mode
            AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_LOW_POWER, AudioSystem.DEVICE_STATE_AVAILABLE, "");
            mConnectedDevices.put(new Integer(AudioSystem.DEVICE_OUT_LOW_POWER), "");
            Log.e(TAG, "Action: power mode is now LP, re-routing");
        } else {
            Log.e(TAG, "Action: power mode is now HQ, re-routing");
            AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_LOW_POWER, AudioSystem.DEVICE_STATE_UNAVAILABLE, "");
            mConnectedDevices.remove(AudioSystem.DEVICE_OUT_LOW_POWER);
        }
    } else if (SystemProperties.OMAP_ENHANCEMENT && action.equals(MAIN_MIC_CHOICE)) {
        /*
                 * mic choice is not configurable by intent yet, this is here for future use.
                 * eventually, the mic choice will be set from applications using this intent
                 * and we will update the logic to be flexible for mics other than DMIC0.
                 */
        Intent noisyIntent = new Intent(AudioManager.ACTION_AUDIO_BECOMING_NOISY);
        mContext.sendBroadcast(noisyIntent);
        if (intent.getBooleanExtra("DMic0L", true)) {
            Log.e(TAG, "MAIN MIC - DMIC0L selected");
        } else if (intent.getBooleanExtra("AMic0", true)) {
            Log.e(TAG, "MAIN MIC - AMIC selected");
        } else {
            Log.e(TAG, "MAIN MIC - invalid selection, only [DMIC0L,AMIC0] supported");
        }
    } else if (SystemProperties.OMAP_ENHANCEMENT && action.equals(SUB_MIC_CHOICE)) {
        // mic choice is not configurable by intent yet, this is here for future use
        Intent noisyIntent = new Intent(AudioManager.ACTION_AUDIO_BECOMING_NOISY);
        mContext.sendBroadcast(noisyIntent);
        if (intent.getBooleanExtra("DMic0R", true)) {
            Log.e(TAG, "SUB MIC - DMIC0R selected");
        } else if (intent.getBooleanExtra("AMic1", true)) {
            Log.e(TAG, "SUB MIC - AMIC selected");
        } else {
            Log.e(TAG, "SUB MIC - invalid selection, only [DMIC0R,AMIC] supported");
        }
    }
}
#end_block

#method_before
@Override
public void onReceive(Context context, Intent intent) {
    String action = intent.getAction();
    if (action.equals(ACTION_HDMI_PLUG)) {
        int state = intent.getIntExtra("state", 0);
        if (state == 1) {
            Log.d(TAG, "UiCloningBroadcastReceiver.onReceive() : Cloning UI to HDMI-TV");
            CloneUiToDisplay(DISPLAY_TYPE_HDMI_TV);
        } else {
            Log.d(TAG, "UiCloningBroadcastReceiver.onReceive() : Stopping UI on HDMI-TV");
            CloneUiToDisplay(DISPLAY_TYPE_LCD_PRIMARY);
        }
    }
}
#method_after
@Override
public void onReceive(Context context, Intent intent) {
    String action = intent.getAction();
    if (action.equals(ACTION_HDMI_PLUG)) {
        int state = intent.getIntExtra("state", 0);
        if (state == 1) {
            Log.d(TAG, "UiCloningBroadcastReceiver.onReceive() : Cloning UI to HDMI-TV");
            CloneUiToDisplay(DISPLAY_TYPE_HDMI_TV);
        } else {
            Log.d(TAG, "UiCloningBroadcastReceiver.onReceive() : Stopping UI on HDMI-TV");
            CloneUiToDisplay(DISPLAY_TYPE_NONE);
        }
    }
}
#end_block

#method_before
@Override
public void run() {
    EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_SYSTEM_RUN, SystemClock.uptimeMillis());
    Looper.prepare();
    android.os.Process.setThreadPriority(android.os.Process.THREAD_PRIORITY_FOREGROUND);
    BinderInternal.disableBackgroundScheduling(true);
    String factoryTestStr = SystemProperties.get("ro.factorytest");
    int factoryTest = "".equals(factoryTestStr) ? SystemServer.FACTORY_TEST_OFF : Integer.parseInt(factoryTestStr);
    LightsService lights = null;
    PowerManagerService power = null;
    BatteryService battery = null;
    ConnectivityService connectivity = null;
    IPackageManager pm = null;
    Context context = null;
    WindowManagerService wm = null;
    BluetoothService bluetooth = null;
    BluetoothA2dpService bluetoothA2dp = null;
    /* TI HID port - start */
    BluetoothHidService bluetoothHid = null;
    /* TI HID port - end */
    HeadsetObserver headset = null;
    HDMIObserver hdmi = null;
    DockObserver dock = null;
    UiModeManagerService uiMode = null;
    RecognitionManagerService recognition = null;
    ThrottleService throttle = null;
    UiCloningService uiCloning = null;
    // Critical services...
    try {
        Slog.i(TAG, "Entropy Service");
        ServiceManager.addService("entropy", new EntropyService());
        Slog.i(TAG, "Power Manager");
        power = new PowerManagerService();
        ServiceManager.addService(Context.POWER_SERVICE, power);
        Slog.i(TAG, "Activity Manager");
        context = ActivityManagerService.main(factoryTest);
        Slog.i(TAG, "Telephony Registry");
        ServiceManager.addService("telephony.registry", new TelephonyRegistry(context));
        AttributeCache.init(context);
        Slog.i(TAG, "Package Manager");
        pm = PackageManagerService.main(context, factoryTest != SystemServer.FACTORY_TEST_OFF);
        ActivityManagerService.setSystemProcess();
        mContentResolver = context.getContentResolver();
        // The AccountManager must come before the ContentService
        try {
            Slog.i(TAG, "Account Manager");
            ServiceManager.addService(Context.ACCOUNT_SERVICE, new AccountManagerService(context));
        } catch (Throwable e) {
            Slog.e(TAG, "Failure starting Account Manager", e);
        }
        Slog.i(TAG, "Content Manager");
        ContentService.main(context, factoryTest == SystemServer.FACTORY_TEST_LOW_LEVEL);
        Slog.i(TAG, "System Content Providers");
        ActivityManagerService.installSystemProviders();
        Slog.i(TAG, "Battery Service");
        battery = new BatteryService(context);
        ServiceManager.addService("battery", battery);
        Slog.i(TAG, "Lights Service");
        lights = new LightsService(context);
        Slog.i(TAG, "Vibrator Service");
        ServiceManager.addService("vibrator", new VibratorService(context));
        // only initialize the power service after we have started the
        // lights service, content providers and the battery service.
        power.init(context, lights, ActivityManagerService.getDefault(), battery);
        Slog.i(TAG, "Alarm Manager");
        AlarmManagerService alarm = new AlarmManagerService(context);
        ServiceManager.addService(Context.ALARM_SERVICE, alarm);
        Slog.i(TAG, "Init Watchdog");
        Watchdog.getInstance().init(context, battery, power, alarm, ActivityManagerService.self());
        // Sensor Service is needed by Window Manager, so this goes first
        Slog.i(TAG, "Sensor Service");
        ServiceManager.addService(Context.SENSOR_SERVICE, new SensorService(context));
        Slog.i(TAG, "Window Manager");
        wm = WindowManagerService.main(context, power, factoryTest != SystemServer.FACTORY_TEST_LOW_LEVEL);
        ServiceManager.addService(Context.WINDOW_SERVICE, wm);
        ((ActivityManagerService) ServiceManager.getService("activity")).setWindowManager(wm);
        // support Bluetooth - see bug 988521
        if (SystemProperties.get("ro.kernel.qemu").equals("1")) {
            Slog.i(TAG, "Registering null Bluetooth Service (emulator)");
            ServiceManager.addService(BluetoothAdapter.BLUETOOTH_SERVICE, null);
        } else if (factoryTest == SystemServer.FACTORY_TEST_LOW_LEVEL) {
            Slog.i(TAG, "Registering null Bluetooth Service (factory test)");
            ServiceManager.addService(BluetoothAdapter.BLUETOOTH_SERVICE, null);
        } else {
            Slog.i(TAG, "Bluetooth Service");
            bluetooth = new BluetoothService(context);
            ServiceManager.addService(BluetoothAdapter.BLUETOOTH_SERVICE, bluetooth);
            bluetooth.initAfterRegistration();
            bluetoothA2dp = new BluetoothA2dpService(context, bluetooth);
            ServiceManager.addService(BluetoothA2dpService.BLUETOOTH_A2DP_SERVICE, bluetoothA2dp);
            /* TI HID port - start */
            if (SystemProperties.OMAP_ENHANCEMENT) {
                bluetoothHid = new BluetoothHidService(context, bluetooth);
                ServiceManager.addService(BluetoothHidService.BLUETOOTH_HID_SERVICE, bluetoothHid);
            }
            /* TI HID port - end */
            int bluetoothOn = Settings.Secure.getInt(mContentResolver, Settings.Secure.BLUETOOTH_ON, 0);
            if (bluetoothOn > 0) {
                bluetooth.enable();
            }
        }
    } catch (RuntimeException e) {
        Slog.e("System", "Failure starting core service", e);
    }
    DevicePolicyManagerService devicePolicy = null;
    StatusBarService statusBar = null;
    InputMethodManagerService imm = null;
    AppWidgetService appWidget = null;
    NotificationManagerService notification = null;
    WallpaperManagerService wallpaper = null;
    LocationManagerService location = null;
    if (factoryTest != SystemServer.FACTORY_TEST_LOW_LEVEL) {
        try {
            Slog.i(TAG, "Device Policy");
            devicePolicy = new DevicePolicyManagerService(context);
            ServiceManager.addService(Context.DEVICE_POLICY_SERVICE, devicePolicy);
        } catch (Throwable e) {
            Slog.e(TAG, "Failure starting DevicePolicyService", e);
        }
        try {
            Slog.i(TAG, "Status Bar");
            statusBar = new StatusBarService(context);
            ServiceManager.addService(Context.STATUS_BAR_SERVICE, statusBar);
        } catch (Throwable e) {
            Slog.e(TAG, "Failure starting StatusBarService", e);
        }
        try {
            Slog.i(TAG, "Clipboard Service");
            ServiceManager.addService(Context.CLIPBOARD_SERVICE, new ClipboardService(context));
        } catch (Throwable e) {
            Slog.e(TAG, "Failure starting Clipboard Service", e);
        }
        try {
            Slog.i(TAG, "Input Method Service");
            imm = new InputMethodManagerService(context, statusBar);
            ServiceManager.addService(Context.INPUT_METHOD_SERVICE, imm);
        } catch (Throwable e) {
            Slog.e(TAG, "Failure starting Input Manager Service", e);
        }
        try {
            Slog.i(TAG, "NetStat Service");
            ServiceManager.addService("netstat", new NetStatService(context));
        } catch (Throwable e) {
            Slog.e(TAG, "Failure starting NetStat Service", e);
        }
        try {
            Slog.i(TAG, "NetworkManagement Service");
            ServiceManager.addService(Context.NETWORKMANAGEMENT_SERVICE, new NetworkManagementService(context));
        } catch (Throwable e) {
            Slog.e(TAG, "Failure starting NetworkManagement Service", e);
        }
        try {
            Slog.i(TAG, "Connectivity Service");
            connectivity = ConnectivityService.getInstance(context);
            ServiceManager.addService(Context.CONNECTIVITY_SERVICE, connectivity);
        } catch (Throwable e) {
            Slog.e(TAG, "Failure starting Connectivity Service", e);
        }
        try {
            Slog.i(TAG, "Throttle Service");
            throttle = new ThrottleService(context);
            ServiceManager.addService(Context.THROTTLE_SERVICE, throttle);
        } catch (Throwable e) {
            Slog.e(TAG, "Failure starting ThrottleService", e);
        }
        try {
            Slog.i(TAG, "Accessibility Manager");
            ServiceManager.addService(Context.ACCESSIBILITY_SERVICE, new AccessibilityManagerService(context));
        } catch (Throwable e) {
            Slog.e(TAG, "Failure starting Accessibility Manager", e);
        }
        try {
            /*
                 * NotificationManagerService is dependant on MountService,
                 * (for media / usb notifications) so we must start MountService first.
                 */
            Slog.i(TAG, "Mount Service");
            ServiceManager.addService("mount", new MountService(context));
        } catch (Throwable e) {
            Slog.e(TAG, "Failure starting Mount Service", e);
        }
        try {
            Slog.i(TAG, "Notification Manager");
            notification = new NotificationManagerService(context, statusBar, lights);
            ServiceManager.addService(Context.NOTIFICATION_SERVICE, notification);
        } catch (Throwable e) {
            Slog.e(TAG, "Failure starting Notification Manager", e);
        }
        try {
            Slog.i(TAG, "Device Storage Monitor");
            ServiceManager.addService(DeviceStorageMonitorService.SERVICE, new DeviceStorageMonitorService(context));
        } catch (Throwable e) {
            Slog.e(TAG, "Failure starting DeviceStorageMonitor service", e);
        }
        try {
            Slog.i(TAG, "Location Manager");
            location = new LocationManagerService(context);
            ServiceManager.addService(Context.LOCATION_SERVICE, location);
        } catch (Throwable e) {
            Slog.e(TAG, "Failure starting Location Manager", e);
        }
        try {
            Slog.i(TAG, "Search Service");
            ServiceManager.addService(Context.SEARCH_SERVICE, new SearchManagerService(context));
        } catch (Throwable e) {
            Slog.e(TAG, "Failure starting Search Service", e);
        }
        if (INCLUDE_DEMO) {
            Slog.i(TAG, "Installing demo data...");
            (new DemoThread(context)).start();
        }
        try {
            Slog.i(TAG, "DropBox Service");
            ServiceManager.addService(Context.DROPBOX_SERVICE, new DropBoxManagerService(context, new File("/data/system/dropbox")));
        } catch (Throwable e) {
            Slog.e(TAG, "Failure starting DropBoxManagerService", e);
        }
        try {
            Slog.i(TAG, "Wallpaper Service");
            wallpaper = new WallpaperManagerService(context);
            ServiceManager.addService(Context.WALLPAPER_SERVICE, wallpaper);
        } catch (Throwable e) {
            Slog.e(TAG, "Failure starting Wallpaper Service", e);
        }
        try {
            Slog.i(TAG, "Audio Service");
            ServiceManager.addService(Context.AUDIO_SERVICE, new AudioService(context));
        } catch (Throwable e) {
            Slog.e(TAG, "Failure starting Audio Service", e);
        }
        try {
            Slog.i(TAG, "Headset Observer");
            // Listen for wired headset changes
            headset = new HeadsetObserver(context);
        } catch (Throwable e) {
            Slog.e(TAG, "Failure starting HeadsetObserver", e);
        }
        try {
            Slog.i(TAG, "HDMI Observer");
            // Listen for hdmi changes
            hdmi = new HDMIObserver(context);
        } catch (Throwable e) {
            Slog.e(TAG, "Failure starting HDMIObserver", e);
        }
        try {
            Slog.i(TAG, "Dock Observer");
            // Listen for dock station changes
            dock = new DockObserver(context, power);
        } catch (Throwable e) {
            Slog.e(TAG, "Failure starting DockObserver", e);
        }
        try {
            Slog.i(TAG, "UI Mode Manager Service");
            // Listen for dock station changes
            uiMode = new UiModeManagerService(context);
        } catch (Throwable e) {
            Slog.e(TAG, "Failure starting UiModeManagerService", e);
        }
        try {
            Slog.i(TAG, "Backup Service");
            ServiceManager.addService(Context.BACKUP_SERVICE, new BackupManagerService(context));
        } catch (Throwable e) {
            Slog.e(TAG, "Failure starting Backup Service", e);
        }
        try {
            Slog.i(TAG, "AppWidget Service");
            appWidget = new AppWidgetService(context);
            ServiceManager.addService(Context.APPWIDGET_SERVICE, appWidget);
        } catch (Throwable e) {
            Slog.e(TAG, "Failure starting AppWidget Service", e);
        }
        try {
            Slog.i(TAG, "Recognition Service");
            recognition = new RecognitionManagerService(context);
        } catch (Throwable e) {
            Slog.e(TAG, "Failure starting Recognition Service", e);
        }
        try {
            com.android.server.status.StatusBarPolicy.installIcons(context, statusBar);
        } catch (Throwable e) {
            Slog.e(TAG, "Failure installing status bar icons", e);
        }
        try {
            Slog.i(TAG, "DiskStats Service");
            ServiceManager.addService("diskstats", new DiskStatsService(context));
        } catch (Throwable e) {
            Slog.e(TAG, "Failure starting DiskStats Service", e);
        }
        if (SystemProperties.OMAP_ENHANCEMENT) {
            try {
                Slog.i(TAG, "UiCloningService");
                uiCloning = new UiCloningService(context);
            } catch (Throwable e) {
                Slog.e(TAG, "Failure starting UiCloningService", e);
            }
        }
    }
    // make sure the ADB_ENABLED setting value matches the secure property value
    Settings.Secure.putInt(mContentResolver, Settings.Secure.ADB_ENABLED, "1".equals(SystemProperties.get("persist.service.adb.enable")) ? 1 : 0);
    // register observer to listen for settings changes
    mContentResolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.ADB_ENABLED), false, new AdbSettingsObserver());
    // Before things start rolling, be sure we have decided whether
    // we are in safe mode.
    final boolean safeMode = wm.detectSafeMode();
    if (safeMode) {
        try {
            ActivityManagerNative.getDefault().enterSafeMode();
            // Post the safe mode state in the Zygote class
            Zygote.systemInSafeMode = true;
            // Disable the JIT for the system_server process
            VMRuntime.getRuntime().disableJitCompilation();
        } catch (RemoteException e) {
        }
    } else {
        // Enable the JIT for the system_server process
        VMRuntime.getRuntime().startJitCompilation();
    }
    if (devicePolicy != null) {
        devicePolicy.systemReady();
    }
    if (notification != null) {
        notification.systemReady();
    }
    if (statusBar != null) {
        statusBar.systemReady();
    }
    wm.systemReady();
    power.systemReady();
    try {
        pm.systemReady();
    } catch (RemoteException e) {
    }
    // These are needed to propagate to the runnable below.
    final BatteryService batteryF = battery;
    final ConnectivityService connectivityF = connectivity;
    final DockObserver dockF = dock;
    final ThrottleService throttleF = throttle;
    final UiModeManagerService uiModeF = uiMode;
    final AppWidgetService appWidgetF = appWidget;
    final WallpaperManagerService wallpaperF = wallpaper;
    final InputMethodManagerService immF = imm;
    final RecognitionManagerService recognitionF = recognition;
    final LocationManagerService locationF = location;
    // We now tell the activity manager it is okay to run third party
    // code.  It will call back into us once it has gotten to the state
    // where third party code can really run (but before it has actually
    // started launching the initial applications), for us to complete our
    // initialization.
    ((ActivityManagerService) ActivityManagerNative.getDefault()).systemReady(new Runnable() {

        public void run() {
            Slog.i(TAG, "Making services ready");
            if (batteryF != null)
                batteryF.systemReady();
            if (connectivityF != null)
                connectivityF.systemReady();
            if (dockF != null)
                dockF.systemReady();
            if (uiModeF != null)
                uiModeF.systemReady();
            if (recognitionF != null)
                recognitionF.systemReady();
            Watchdog.getInstance().start();
            if (appWidgetF != null)
                appWidgetF.systemReady(safeMode);
            if (wallpaperF != null)
                wallpaperF.systemReady();
            if (immF != null)
                immF.systemReady();
            if (locationF != null)
                locationF.systemReady();
            if (throttleF != null)
                throttleF.systemReady();
        }
    });
    Looper.loop();
    Slog.d(TAG, "System ServerThread is exiting!");
}
#method_after
@Override
public void run() {
    EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_SYSTEM_RUN, SystemClock.uptimeMillis());
    Looper.prepare();
    android.os.Process.setThreadPriority(android.os.Process.THREAD_PRIORITY_FOREGROUND);
    BinderInternal.disableBackgroundScheduling(true);
    String factoryTestStr = SystemProperties.get("ro.factorytest");
    int factoryTest = "".equals(factoryTestStr) ? SystemServer.FACTORY_TEST_OFF : Integer.parseInt(factoryTestStr);
    LightsService lights = null;
    PowerManagerService power = null;
    BatteryService battery = null;
    ConnectivityService connectivity = null;
    IPackageManager pm = null;
    Context context = null;
    WindowManagerService wm = null;
    BluetoothService bluetooth = null;
    BluetoothA2dpService bluetoothA2dp = null;
    /* TI HID port - start */
    BluetoothHidService bluetoothHid = null;
    /* TI HID port - end */
    HeadsetObserver headset = null;
    HDMIObserver hdmi = null;
    DockObserver dock = null;
    UiModeManagerService uiMode = null;
    RecognitionManagerService recognition = null;
    ThrottleService throttle = null;
    UiCloningService uiCloning = null;
    // Critical services...
    try {
        Slog.i(TAG, "Entropy Service");
        ServiceManager.addService("entropy", new EntropyService());
        Slog.i(TAG, "Power Manager");
        power = new PowerManagerService();
        ServiceManager.addService(Context.POWER_SERVICE, power);
        Slog.i(TAG, "Activity Manager");
        context = ActivityManagerService.main(factoryTest);
        Slog.i(TAG, "Telephony Registry");
        ServiceManager.addService("telephony.registry", new TelephonyRegistry(context));
        AttributeCache.init(context);
        Slog.i(TAG, "Package Manager");
        pm = PackageManagerService.main(context, factoryTest != SystemServer.FACTORY_TEST_OFF);
        ActivityManagerService.setSystemProcess();
        mContentResolver = context.getContentResolver();
        // The AccountManager must come before the ContentService
        try {
            Slog.i(TAG, "Account Manager");
            ServiceManager.addService(Context.ACCOUNT_SERVICE, new AccountManagerService(context));
        } catch (Throwable e) {
            Slog.e(TAG, "Failure starting Account Manager", e);
        }
        Slog.i(TAG, "Content Manager");
        ContentService.main(context, factoryTest == SystemServer.FACTORY_TEST_LOW_LEVEL);
        Slog.i(TAG, "System Content Providers");
        ActivityManagerService.installSystemProviders();
        Slog.i(TAG, "Battery Service");
        battery = new BatteryService(context);
        ServiceManager.addService("battery", battery);
        Slog.i(TAG, "Lights Service");
        lights = new LightsService(context);
        Slog.i(TAG, "Vibrator Service");
        ServiceManager.addService("vibrator", new VibratorService(context));
        // only initialize the power service after we have started the
        // lights service, content providers and the battery service.
        power.init(context, lights, ActivityManagerService.getDefault(), battery);
        Slog.i(TAG, "Alarm Manager");
        AlarmManagerService alarm = new AlarmManagerService(context);
        ServiceManager.addService(Context.ALARM_SERVICE, alarm);
        Slog.i(TAG, "Init Watchdog");
        Watchdog.getInstance().init(context, battery, power, alarm, ActivityManagerService.self());
        // Sensor Service is needed by Window Manager, so this goes first
        Slog.i(TAG, "Sensor Service");
        ServiceManager.addService(Context.SENSOR_SERVICE, new SensorService(context));
        Slog.i(TAG, "Window Manager");
        wm = WindowManagerService.main(context, power, factoryTest != SystemServer.FACTORY_TEST_LOW_LEVEL);
        ServiceManager.addService(Context.WINDOW_SERVICE, wm);
        ((ActivityManagerService) ServiceManager.getService("activity")).setWindowManager(wm);
        // support Bluetooth - see bug 988521
        if (SystemProperties.get("ro.kernel.qemu").equals("1")) {
            Slog.i(TAG, "Registering null Bluetooth Service (emulator)");
            ServiceManager.addService(BluetoothAdapter.BLUETOOTH_SERVICE, null);
        } else if (factoryTest == SystemServer.FACTORY_TEST_LOW_LEVEL) {
            Slog.i(TAG, "Registering null Bluetooth Service (factory test)");
            ServiceManager.addService(BluetoothAdapter.BLUETOOTH_SERVICE, null);
        } else {
            Slog.i(TAG, "Bluetooth Service");
            bluetooth = new BluetoothService(context);
            ServiceManager.addService(BluetoothAdapter.BLUETOOTH_SERVICE, bluetooth);
            bluetooth.initAfterRegistration();
            bluetoothA2dp = new BluetoothA2dpService(context, bluetooth);
            ServiceManager.addService(BluetoothA2dpService.BLUETOOTH_A2DP_SERVICE, bluetoothA2dp);
            /* TI HID port - start */
            if (SystemProperties.OMAP_ENHANCEMENT) {
                bluetoothHid = new BluetoothHidService(context, bluetooth);
                ServiceManager.addService(BluetoothHidService.BLUETOOTH_HID_SERVICE, bluetoothHid);
            }
            /* TI HID port - end */
            int bluetoothOn = Settings.Secure.getInt(mContentResolver, Settings.Secure.BLUETOOTH_ON, 0);
            if (bluetoothOn > 0) {
                bluetooth.enable();
            }
        }
    } catch (RuntimeException e) {
        Slog.e("System", "Failure starting core service", e);
    }
    DevicePolicyManagerService devicePolicy = null;
    StatusBarService statusBar = null;
    InputMethodManagerService imm = null;
    AppWidgetService appWidget = null;
    NotificationManagerService notification = null;
    WallpaperManagerService wallpaper = null;
    LocationManagerService location = null;
    if (factoryTest != SystemServer.FACTORY_TEST_LOW_LEVEL) {
        try {
            Slog.i(TAG, "Device Policy");
            devicePolicy = new DevicePolicyManagerService(context);
            ServiceManager.addService(Context.DEVICE_POLICY_SERVICE, devicePolicy);
        } catch (Throwable e) {
            Slog.e(TAG, "Failure starting DevicePolicyService", e);
        }
        try {
            Slog.i(TAG, "Status Bar");
            statusBar = new StatusBarService(context);
            ServiceManager.addService(Context.STATUS_BAR_SERVICE, statusBar);
        } catch (Throwable e) {
            Slog.e(TAG, "Failure starting StatusBarService", e);
        }
        try {
            Slog.i(TAG, "Clipboard Service");
            ServiceManager.addService(Context.CLIPBOARD_SERVICE, new ClipboardService(context));
        } catch (Throwable e) {
            Slog.e(TAG, "Failure starting Clipboard Service", e);
        }
        try {
            Slog.i(TAG, "Input Method Service");
            imm = new InputMethodManagerService(context, statusBar);
            ServiceManager.addService(Context.INPUT_METHOD_SERVICE, imm);
        } catch (Throwable e) {
            Slog.e(TAG, "Failure starting Input Manager Service", e);
        }
        try {
            Slog.i(TAG, "NetStat Service");
            ServiceManager.addService("netstat", new NetStatService(context));
        } catch (Throwable e) {
            Slog.e(TAG, "Failure starting NetStat Service", e);
        }
        try {
            Slog.i(TAG, "NetworkManagement Service");
            ServiceManager.addService(Context.NETWORKMANAGEMENT_SERVICE, new NetworkManagementService(context));
        } catch (Throwable e) {
            Slog.e(TAG, "Failure starting NetworkManagement Service", e);
        }
        try {
            Slog.i(TAG, "Connectivity Service");
            connectivity = ConnectivityService.getInstance(context);
            ServiceManager.addService(Context.CONNECTIVITY_SERVICE, connectivity);
        } catch (Throwable e) {
            Slog.e(TAG, "Failure starting Connectivity Service", e);
        }
        try {
            Slog.i(TAG, "Throttle Service");
            throttle = new ThrottleService(context);
            ServiceManager.addService(Context.THROTTLE_SERVICE, throttle);
        } catch (Throwable e) {
            Slog.e(TAG, "Failure starting ThrottleService", e);
        }
        try {
            Slog.i(TAG, "Accessibility Manager");
            ServiceManager.addService(Context.ACCESSIBILITY_SERVICE, new AccessibilityManagerService(context));
        } catch (Throwable e) {
            Slog.e(TAG, "Failure starting Accessibility Manager", e);
        }
        try {
            /*
                 * NotificationManagerService is dependant on MountService,
                 * (for media / usb notifications) so we must start MountService first.
                 */
            Slog.i(TAG, "Mount Service");
            ServiceManager.addService("mount", new MountService(context));
        } catch (Throwable e) {
            Slog.e(TAG, "Failure starting Mount Service", e);
        }
        try {
            Slog.i(TAG, "Notification Manager");
            notification = new NotificationManagerService(context, statusBar, lights);
            ServiceManager.addService(Context.NOTIFICATION_SERVICE, notification);
        } catch (Throwable e) {
            Slog.e(TAG, "Failure starting Notification Manager", e);
        }
        try {
            Slog.i(TAG, "Device Storage Monitor");
            ServiceManager.addService(DeviceStorageMonitorService.SERVICE, new DeviceStorageMonitorService(context));
        } catch (Throwable e) {
            Slog.e(TAG, "Failure starting DeviceStorageMonitor service", e);
        }
        try {
            Slog.i(TAG, "Location Manager");
            location = new LocationManagerService(context);
            ServiceManager.addService(Context.LOCATION_SERVICE, location);
        } catch (Throwable e) {
            Slog.e(TAG, "Failure starting Location Manager", e);
        }
        try {
            Slog.i(TAG, "Search Service");
            ServiceManager.addService(Context.SEARCH_SERVICE, new SearchManagerService(context));
        } catch (Throwable e) {
            Slog.e(TAG, "Failure starting Search Service", e);
        }
        if (INCLUDE_DEMO) {
            Slog.i(TAG, "Installing demo data...");
            (new DemoThread(context)).start();
        }
        try {
            Slog.i(TAG, "DropBox Service");
            ServiceManager.addService(Context.DROPBOX_SERVICE, new DropBoxManagerService(context, new File("/data/system/dropbox")));
        } catch (Throwable e) {
            Slog.e(TAG, "Failure starting DropBoxManagerService", e);
        }
        try {
            Slog.i(TAG, "Wallpaper Service");
            wallpaper = new WallpaperManagerService(context);
            ServiceManager.addService(Context.WALLPAPER_SERVICE, wallpaper);
        } catch (Throwable e) {
            Slog.e(TAG, "Failure starting Wallpaper Service", e);
        }
        try {
            Slog.i(TAG, "Audio Service");
            ServiceManager.addService(Context.AUDIO_SERVICE, new AudioService(context));
        } catch (Throwable e) {
            Slog.e(TAG, "Failure starting Audio Service", e);
        }
        try {
            Slog.i(TAG, "Headset Observer");
            // Listen for wired headset changes
            headset = new HeadsetObserver(context);
        } catch (Throwable e) {
            Slog.e(TAG, "Failure starting HeadsetObserver", e);
        }
        try {
            Slog.i(TAG, "HDMI Observer");
            // Listen for hdmi changes
            hdmi = new HDMIObserver(context);
        } catch (Throwable e) {
            Slog.e(TAG, "Failure starting HDMIObserver", e);
        }
        try {
            Slog.i(TAG, "Dock Observer");
            // Listen for dock station changes
            dock = new DockObserver(context, power);
        } catch (Throwable e) {
            Slog.e(TAG, "Failure starting DockObserver", e);
        }
        try {
            Slog.i(TAG, "UI Mode Manager Service");
            // Listen for dock station changes
            uiMode = new UiModeManagerService(context);
        } catch (Throwable e) {
            Slog.e(TAG, "Failure starting UiModeManagerService", e);
        }
        try {
            Slog.i(TAG, "Backup Service");
            ServiceManager.addService(Context.BACKUP_SERVICE, new BackupManagerService(context));
        } catch (Throwable e) {
            Slog.e(TAG, "Failure starting Backup Service", e);
        }
        try {
            Slog.i(TAG, "AppWidget Service");
            appWidget = new AppWidgetService(context);
            ServiceManager.addService(Context.APPWIDGET_SERVICE, appWidget);
        } catch (Throwable e) {
            Slog.e(TAG, "Failure starting AppWidget Service", e);
        }
        try {
            Slog.i(TAG, "Recognition Service");
            recognition = new RecognitionManagerService(context);
        } catch (Throwable e) {
            Slog.e(TAG, "Failure starting Recognition Service", e);
        }
        try {
            com.android.server.status.StatusBarPolicy.installIcons(context, statusBar);
        } catch (Throwable e) {
            Slog.e(TAG, "Failure installing status bar icons", e);
        }
        try {
            Slog.i(TAG, "DiskStats Service");
            ServiceManager.addService("diskstats", new DiskStatsService(context));
        } catch (Throwable e) {
            Slog.e(TAG, "Failure starting DiskStats Service", e);
        }
        if (SystemProperties.OMAP_ENHANCEMENT) {
            if (SystemProperties.getBoolean("tv.hdmi.uicloning.enable", false)) {
                try {
                    Slog.i(TAG, "UiCloningService");
                    uiCloning = new UiCloningService(context);
                } catch (Throwable e) {
                    Slog.e(TAG, "Failure starting UiCloningService", e);
                }
            }
        }
    }
    // make sure the ADB_ENABLED setting value matches the secure property value
    Settings.Secure.putInt(mContentResolver, Settings.Secure.ADB_ENABLED, "1".equals(SystemProperties.get("persist.service.adb.enable")) ? 1 : 0);
    // register observer to listen for settings changes
    mContentResolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.ADB_ENABLED), false, new AdbSettingsObserver());
    // Before things start rolling, be sure we have decided whether
    // we are in safe mode.
    final boolean safeMode = wm.detectSafeMode();
    if (safeMode) {
        try {
            ActivityManagerNative.getDefault().enterSafeMode();
            // Post the safe mode state in the Zygote class
            Zygote.systemInSafeMode = true;
            // Disable the JIT for the system_server process
            VMRuntime.getRuntime().disableJitCompilation();
        } catch (RemoteException e) {
        }
    } else {
        // Enable the JIT for the system_server process
        VMRuntime.getRuntime().startJitCompilation();
    }
    if (devicePolicy != null) {
        devicePolicy.systemReady();
    }
    if (notification != null) {
        notification.systemReady();
    }
    if (statusBar != null) {
        statusBar.systemReady();
    }
    wm.systemReady();
    power.systemReady();
    try {
        pm.systemReady();
    } catch (RemoteException e) {
    }
    // These are needed to propagate to the runnable below.
    final BatteryService batteryF = battery;
    final ConnectivityService connectivityF = connectivity;
    final DockObserver dockF = dock;
    final ThrottleService throttleF = throttle;
    final UiModeManagerService uiModeF = uiMode;
    final AppWidgetService appWidgetF = appWidget;
    final WallpaperManagerService wallpaperF = wallpaper;
    final InputMethodManagerService immF = imm;
    final RecognitionManagerService recognitionF = recognition;
    final LocationManagerService locationF = location;
    // We now tell the activity manager it is okay to run third party
    // code.  It will call back into us once it has gotten to the state
    // where third party code can really run (but before it has actually
    // started launching the initial applications), for us to complete our
    // initialization.
    ((ActivityManagerService) ActivityManagerNative.getDefault()).systemReady(new Runnable() {

        public void run() {
            Slog.i(TAG, "Making services ready");
            if (batteryF != null)
                batteryF.systemReady();
            if (connectivityF != null)
                connectivityF.systemReady();
            if (dockF != null)
                dockF.systemReady();
            if (uiModeF != null)
                uiModeF.systemReady();
            if (recognitionF != null)
                recognitionF.systemReady();
            Watchdog.getInstance().start();
            if (appWidgetF != null)
                appWidgetF.systemReady(safeMode);
            if (wallpaperF != null)
                wallpaperF.systemReady();
            if (immF != null)
                immF.systemReady();
            if (locationF != null)
                locationF.systemReady();
            if (throttleF != null)
                throttleF.systemReady();
        }
    });
    Looper.loop();
    Slog.d(TAG, "System ServerThread is exiting!");
}
#end_block

#method_before
private void initVideoView() {
    mVideoWidth = 0;
    mVideoHeight = 0;
    getHolder().addCallback(mSHCallback);
    getHolder().setType(SurfaceHolder.SURFACE_TYPE_PUSH_BUFFERS);
    setFocusable(true);
    setFocusableInTouchMode(true);
    requestFocus();
    mCurrentState = STATE_IDLE;
    mTargetState = STATE_IDLE;
    if (SystemProperties.OMAP_ENHANCEMENT) {
        mOmapMMHandle = new OmapMMLibrary();
        // if the OmapMMHandle is non-null, initialise jni
        if (mOmapMMHandle != null) {
            mOmapMMHandle.native_init();
        }
    }
}
#method_after
private void initVideoView() {
    mVideoWidth = 0;
    mVideoHeight = 0;
    getHolder().addCallback(mSHCallback);
    getHolder().setType(SurfaceHolder.SURFACE_TYPE_PUSH_BUFFERS);
    setFocusable(true);
    setFocusableInTouchMode(true);
    requestFocus();
    mCurrentState = STATE_IDLE;
    mTargetState = STATE_IDLE;
    if (SystemProperties.OMAP_ENHANCEMENT) {
        omapMMHandle = new OmapMMLibrary();
        // if the OmapMMHandle is non-null, initialise jni
        if (omapMMHandle != null) {
            omapMMHandle.native_init();
        }
    }
}
#end_block

#method_before
public void stopPlayback() {
    if (mMediaPlayer != null) {
        mMediaPlayer.stop();
        mMediaPlayer.release();
        mMediaPlayer = null;
        mCurrentState = STATE_IDLE;
        mTargetState = STATE_IDLE;
    }
    // Unregister for device HDMI-Hotplug intent broadcasts.
    if (SystemProperties.OMAP_ENHANCEMENT) {
        mContext.unregisterReceiver(mReceiver);
        // delete the memory for hdmi intent
        if (mHdmiIntent != null) {
            mHdmiIntent = null;
        }
        // delete the omapMMHandle memory
        if (mOmapMMHandle != null) {
            mOmapMMHandle = null;
        }
    }
}
#method_after
public void stopPlayback() {
    if (mMediaPlayer != null) {
        mMediaPlayer.stop();
        mMediaPlayer.release();
        mMediaPlayer = null;
        mCurrentState = STATE_IDLE;
        mTargetState = STATE_IDLE;
    }
    // Unregister for device HDMI-Hotplug intent broadcasts.
    if (SystemProperties.OMAP_ENHANCEMENT) {
        mContext.unregisterReceiver(mReceiver);
        // delete the omapMMHandle memory
        if (omapMMHandle != null) {
            omapMMHandle = null;
        }
    }
}
#end_block

#method_before
private void openVideo() {
    if (mUri == null || mSurfaceHolder == null) {
        // not ready for playback just yet, will try again later
        return;
    }
    // Tell the music playback service to pause
    // TODO: these constants need to be published somewhere in the framework.
    Intent i = new Intent("com.android.music.musicservicecommand");
    i.putExtra("command", "pause");
    mContext.sendBroadcast(i);
    /* TI FM UI port -start */
    if (SystemProperties.OMAP_ENHANCEMENT) {
        // Tell the FM playback service to pause,as the video playback will start.
        // TODO: these constants need to be published somewhere in the framework.
        Intent fm = new Intent("com.ti.server.fmpausecmd");
        mContext.sendBroadcast(fm);
    }
    /* TI FM UI port -stop */
    // we shouldn't clear the target state, because somebody might have
    // called start() previously
    release(false);
    try {
        mMediaPlayer = new MediaPlayer();
        mMediaPlayer.setOnPreparedListener(mPreparedListener);
        mMediaPlayer.setOnVideoSizeChangedListener(mSizeChangedListener);
        mDuration = -1;
        mMediaPlayer.setOnCompletionListener(mCompletionListener);
        mMediaPlayer.setOnErrorListener(mErrorListener);
        mMediaPlayer.setOnBufferingUpdateListener(mBufferingUpdateListener);
        mCurrentBufferPercentage = 0;
        mMediaPlayer.setDataSource(mContext, mUri, mHeaders);
        mMediaPlayer.setDisplay(mSurfaceHolder);
        mMediaPlayer.setAudioStreamType(AudioManager.STREAM_MUSIC);
        mMediaPlayer.setScreenOnWhilePlaying(true);
        mMediaPlayer.prepareAsync();
        // we don't set the target state here either, but preserve the
        // target state that was there before.
        mCurrentState = STATE_PREPARING;
        attachMediaController();
        if (SystemProperties.OMAP_ENHANCEMENT) {
            mOmapMMHandle.setVideoSurface(mSurfaceHolder);
        }
    } catch (IOException ex) {
        Log.w(TAG, "Unable to open content: " + mUri, ex);
        mCurrentState = STATE_ERROR;
        mTargetState = STATE_ERROR;
        mErrorListener.onError(mMediaPlayer, MediaPlayer.MEDIA_ERROR_UNKNOWN, 0);
        return;
    } catch (IllegalArgumentException ex) {
        Log.w(TAG, "Unable to open content: " + mUri, ex);
        mCurrentState = STATE_ERROR;
        mTargetState = STATE_ERROR;
        mErrorListener.onError(mMediaPlayer, MediaPlayer.MEDIA_ERROR_UNKNOWN, 0);
        return;
    }
}
#method_after
private void openVideo() {
    if (mUri == null || mSurfaceHolder == null) {
        // not ready for playback just yet, will try again later
        return;
    }
    // Tell the music playback service to pause
    // TODO: these constants need to be published somewhere in the framework.
    Intent i = new Intent("com.android.music.musicservicecommand");
    i.putExtra("command", "pause");
    mContext.sendBroadcast(i);
    /* TI FM UI port -start */
    if (SystemProperties.OMAP_ENHANCEMENT) {
        // Tell the FM playback service to pause,as the video playback will start.
        // TODO: these constants need to be published somewhere in the framework.
        Intent fm = new Intent("com.ti.server.fmpausecmd");
        mContext.sendBroadcast(fm);
    }
    /* TI FM UI port -stop */
    // we shouldn't clear the target state, because somebody might have
    // called start() previously
    release(false);
    try {
        mMediaPlayer = new MediaPlayer();
        mMediaPlayer.setOnPreparedListener(mPreparedListener);
        mMediaPlayer.setOnVideoSizeChangedListener(mSizeChangedListener);
        mDuration = -1;
        mMediaPlayer.setOnCompletionListener(mCompletionListener);
        mMediaPlayer.setOnErrorListener(mErrorListener);
        mMediaPlayer.setOnBufferingUpdateListener(mBufferingUpdateListener);
        mCurrentBufferPercentage = 0;
        mMediaPlayer.setDataSource(mContext, mUri, mHeaders);
        mMediaPlayer.setDisplay(mSurfaceHolder);
        mMediaPlayer.setAudioStreamType(AudioManager.STREAM_MUSIC);
        mMediaPlayer.setScreenOnWhilePlaying(true);
        mMediaPlayer.prepareAsync();
        // we don't set the target state here either, but preserve the
        // target state that was there before.
        mCurrentState = STATE_PREPARING;
        attachMediaController();
        if (SystemProperties.OMAP_ENHANCEMENT) {
            omapMMHandle.setVideoSurface(mSurfaceHolder);
        }
    } catch (IOException ex) {
        Log.w(TAG, "Unable to open content: " + mUri, ex);
        mCurrentState = STATE_ERROR;
        mTargetState = STATE_ERROR;
        mErrorListener.onError(mMediaPlayer, MediaPlayer.MEDIA_ERROR_UNKNOWN, 0);
        return;
    } catch (IllegalArgumentException ex) {
        Log.w(TAG, "Unable to open content: " + mUri, ex);
        mCurrentState = STATE_ERROR;
        mTargetState = STATE_ERROR;
        mErrorListener.onError(mMediaPlayer, MediaPlayer.MEDIA_ERROR_UNKNOWN, 0);
        return;
    }
}
#end_block

#method_before
@Override
public void onReceive(Context context, Intent intent) {
    String action = intent.getAction();
    if (SystemProperties.OMAP_ENHANCEMENT && action.equals(ACTION_HDMI_PLUG)) {
        int state = intent.getIntExtra("state", 0);
        if (state == 1) {
            Log.d(TAG, "VideoPlaybackBroadcastReceiver.onReceive() : Switching to HDMI_TV)");
            mOmapMMHandle.setDisplayId(DISPLAY_TYPE_HDMI_TV);
        } else {
            Log.d(TAG, "VideoPlaybackBroadcastReceiver.onReceive() : Switching to LCD-Primary");
            mOmapMMHandle.setDisplayId(DISPLAY_TYPE_LCD_PRIMARY);
        }
    }
}
#method_after
@Override
public void onReceive(Context context, Intent intent) {
    String action = intent.getAction();
    if (SystemProperties.OMAP_ENHANCEMENT && action.equals(ACTION_HDMI_PLUG)) {
        int state = intent.getIntExtra("state", 0);
        if (state == 1) {
            Log.d(TAG, "VideoPlaybackBroadcastReceiver.onReceive() : Switching to HDMI_TV)");
            omapMMHandle.setDisplayId(DISPLAY_TYPE_HDMI_TV);
        } else {
            Log.d(TAG, "VideoPlaybackBroadcastReceiver.onReceive() : Switching to LCD-Primary");
            omapMMHandle.setDisplayId(DISPLAY_TYPE_LCD_PRIMARY);
        }
    }
}
#end_block

